      9:9 /* RWI-F */
#define NV_PFB_MRS_A9_0                                  0x00000000 /* RWI-V */
#define NV_PFB_MRS_A9_1                                  0x00000001 /* RW--V */
#define NV_PFB_MRS_A10                                        10:10 /* RWI-F */
#define NV_PFB_MRS_A10_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_A10_1                                 0x00000001 /* RW--V */
#define NV_PFB_MRS_A11                                        11:11 /* RWI-F */
#define NV_PFB_MRS_A11_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_A11_1                                 0x00000001 /* RW--V */
#define NV_PFB_MRS_A12                                        12:12 /* RWI-F */
#define NV_PFB_MRS_A12_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_A12_1                                 0x00000001 /* RW--V */
#define NV_PFB_MRS_BA0                                        20:20 /* RWI-F */
#define NV_PFB_MRS_BA0_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_BA0_1                                 0x00000001 /* RW--V */
#define NV_PFB_MRS_BA1                                        21:21 /* RWI-F */
#define NV_PFB_MRS_BA1_0                                 0x00000000 /* RWI-V */
#define NV_PFB_MRS_BA1_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS                                      0x001002C4 /* RW-4R */
#define NV_PFB_EMRS_A0                                          0:0 /* RWI-F */
#define NV_PFB_EMRS_A0_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A0_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A1                                          1:1 /* RWI-F */
#define NV_PFB_EMRS_A1_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A1_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A2                                          2:2 /* RWI-F */
#define NV_PFB_EMRS_A2_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A2_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A3                                          3:3 /* RWI-F */
#define NV_PFB_EMRS_A3_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A3_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A4                                          4:4 /* RWI-F */
#define NV_PFB_EMRS_A4_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A4_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A5                                          5:5 /* RWI-F */
#define NV_PFB_EMRS_A5_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A5_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A6                                          6:6 /* RWI-F */
#define NV_PFB_EMRS_A6_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A6_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A7                                          7:7 /* RWI-F */
#define NV_PFB_EMRS_A7_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A7_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A8                                          8:8 /* RWI-F */
#define NV_PFB_EMRS_A8_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A8_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A9                                          9:9 /* RWI-F */
#define NV_PFB_EMRS_A9_0                                 0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A9_1                                 0x00000001 /* RW--V */
#define NV_PFB_EMRS_A10                                       10:10 /* RWI-F */
#define NV_PFB_EMRS_A10_0                                0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A10_1                                0x00000001 /* RW--V */
#define NV_PFB_EMRS_A11                                       11:11 /* RWI-F */
#define NV_PFB_EMRS_A11_0                                0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A11_1                                0x00000001 /* RW--V */
#define NV_PFB_EMRS_A12                                       12:12 /* RWI-F */
#define NV_PFB_EMRS_A12_0                                0x00000000 /* RWI-V */
#define NV_PFB_EMRS_A12_1                                0x00000001 /* RW--V */
#define NV_PFB_EMRS_BA0                                       20:20 /* RWI-F */
#define NV_PFB_EMRS_BA0_0                                0x00000000 /* RW--V */
#define NV_PFB_EMRS_BA0_1                                0x00000001 /* RWI-V */
#define NV_PFB_EMRS_BA1                                       21:21 /* RWI-F */
#define NV_PFB_EMRS_BA1_0                                0x00000000 /* RWI-V */
#define NV_PFB_EMRS_BA1_1                                0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT                                   0x001002C8 /* RW-4R */
#define NV_PFB_MRS_EXT_A0                                       0:0 /* RWI-F */
#define NV_PFB_MRS_EXT_A0_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A0_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A1                                       1:1 /* RWI-F */
#define NV_PFB_MRS_EXT_A1_0                              0x00000000 /* RW--V */
#define NV_PFB_MRS_EXT_A1_1                              0x00000001 /* RWI-V */
#define NV_PFB_MRS_EXT_A2                                       2:2 /* RWI-F */
#define NV_PFB_MRS_EXT_A2_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A2_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A3                                       3:3 /* RWI-F */
#define NV_PFB_MRS_EXT_A3_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A3_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A4                                       4:4 /* RWI-F */
#define NV_PFB_MRS_EXT_A4_0                              0x00000000 /* RW--V */
#define NV_PFB_MRS_EXT_A4_1                              0x00000001 /* RWI-V */
#define NV_PFB_MRS_EXT_A5                                       5:5 /* RWI-F */
#define NV_PFB_MRS_EXT_A5_0                              0x00000000 /* RW--V */
#define NV_PFB_MRS_EXT_A5_1                              0x00000001 /* RWI-V */
#define NV_PFB_MRS_EXT_A6                                       6:6 /* RWI-F */
#define NV_PFB_MRS_EXT_A6_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A6_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A7                                       7:7 /* RWI-F */
#define NV_PFB_MRS_EXT_A7_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A7_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A8                                       8:8 /* RWI-F */
#define NV_PFB_MRS_EXT_A8_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A8_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A9                                       9:9 /* RWI-F */
#define NV_PFB_MRS_EXT_A9_0                              0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A9_1                              0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A10                                    10:10 /* RWI-F */
#define NV_PFB_MRS_EXT_A10_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A10_1                             0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A11                                    11:11 /* RWI-F */
#define NV_PFB_MRS_EXT_A11_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A11_1                             0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_A12                                    12:12 /* RWI-F */
#define NV_PFB_MRS_EXT_A12_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_A12_1                             0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_BA0                                    20:20 /* RWI-F */
#define NV_PFB_MRS_EXT_BA0_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_BA0_1                             0x00000001 /* RW--V */
#define NV_PFB_MRS_EXT_BA1                                    21:21 /* RWI-F */
#define NV_PFB_MRS_EXT_BA1_0                             0x00000000 /* RWI-V */
#define NV_PFB_MRS_EXT_BA1_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT                                  0x001002CC /* RW-4R */
#define NV_PFB_EMRS_EXT_A0                                      0:0 /* RWI-F */
#define NV_PFB_EMRS_EXT_A0_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A0_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A1                                      1:1 /* RWI-F */
#define NV_PFB_EMRS_EXT_A1_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A1_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A2                                      2:2 /* RWI-F */
#define NV_PFB_EMRS_EXT_A2_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A2_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A3                                      3:3 /* RWI-F */
#define NV_PFB_EMRS_EXT_A3_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A3_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A4                                      4:4 /* RWI-F */
#define NV_PFB_EMRS_EXT_A4_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A4_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A5                                      5:5 /* RWI-F */
#define NV_PFB_EMRS_EXT_A5_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A5_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A6                                      6:6 /* RWI-F */
#define NV_PFB_EMRS_EXT_A6_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A6_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A7                                      7:7 /* RWI-F */
#define NV_PFB_EMRS_EXT_A7_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A7_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A8                                      8:8 /* RWI-F */
#define NV_PFB_EMRS_EXT_A8_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A8_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A9                                      9:9 /* RWI-F */
#define NV_PFB_EMRS_EXT_A9_0                             0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A9_1                             0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A10                                   10:10 /* RWI-F */
#define NV_PFB_EMRS_EXT_A10_0                            0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A10_1                            0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A11                                   11:11 /* RWI-F */
#define NV_PFB_EMRS_EXT_A11_0                            0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A11_1                            0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_A12                                   12:12 /* RWI-F */
#define NV_PFB_EMRS_EXT_A12_0                            0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_A12_1                            0x00000001 /* RW--V */
#define NV_PFB_EMRS_EXT_BA0                                   20:20 /* RWI-F */
#define NV_PFB_EMRS_EXT_BA0_0                            0x00000000 /* RW--V */
#define NV_PFB_EMRS_EXT_BA0_1                            0x00000001 /* RWI-V */
#define NV_PFB_EMRS_EXT_BA1                                   21:21 /* RWI-F */
#define NV_PFB_EMRS_EXT_BA1_0                            0x00000000 /* RWI-V */
#define NV_PFB_EMRS_EXT_BA1_1                            0x00000001 /* RW--V */
#define NV_PFB_REF                                       0x001002D0 /* -W-4R */
#define NV_PFB_REF_CMD                                          0:0 /* -W--F */
#define NV_PFB_REF_CMD_REFRESH                           0x00000001 /* -W--V */
#define NV_PFB_PRE                                       0x001002D4 /* -W-4R */
#define NV_PFB_PRE_CMD                                          0:0 /* -W--F */
#define NV_PFB_PRE_CMD_PRECHARGE                         0x00000001 /* -W--V */
#define NV_PFB_ZCOMP(i)                          (0x00100300+(i)*4) /* RW-4A */
#define NV_PFB_ZCOMP__SIZE_1                                      8 /*       */
#define NV_PFB_ZCOMP_BASE_TAG_ADR                              17:6 /* RW-UF */
#define NV_PFB_ZCOMP_MODE                                     26:26 /* RWIVF */
#define NV_PFB_ZCOMP_MODE_16                             0x00000000 /* RW--V */
#define NV_PFB_ZCOMP_MODE_32                             0x00000001 /* RWI-V */
#define NV_PFB_ZCOMP_ENDIAN                                   27:27 /* RWIVF */
#define NV_PFB_ZCOMP_ENDIAN_LITTLE                       0x00000000 /* RWI-V */
#define NV_PFB_ZCOMP_ENDIAN_BIG                          0x00000001 /* RW--V */
#define NV_PFB_ZCOMP_AA                                       29:28 /* RWIVF */
#define NV_PFB_ZCOMP_AA_DISABLED                         0x00000000 /* RWI-V */
#define NV_PFB_ZCOMP_AA_CENTER_1                         0x00000001 /* RW--V */
#define NV_PFB_ZCOMP_AA_CENTER_CORNER_2                  0x00000002 /* RW--V */
#define NV_PFB_ZCOMP_AA_SQUARE_OFFSET_4                  0x00000003 /* RW--V */
#define NV_PFB_ZCOMP_EN                                       31:31 /* RWIVF */
#define NV_PFB_ZCOMP_EN_FALSE                            0x00000000 /* RWI-V */
#define NV_PFB_ZCOMP_EN_TRUE                             0x00000001 /* RW--V */
#define NV_PFB_ZCOMP_MAX_TAG                             0x00100320 /* R-X4R */
#define NV_PFB_ZCOMP_MAX_TAG_ADR_LO                             5:0 /* C-IVF */
#define NV_PFB_ZCOMP_MAX_TAG_ADR_LO_3F                   0x0000003F /* C-I-V */
#define NV_PFB_ZCOMP_MAX_TAG_ADR                               17:6 /* C-IVF */
#define NV_PFB_ZCOMP_MAX_TAG_ADR_VALUE                   0x000001FF /* C-I-V */
#define NV_PFB_ZCOMP_OFFSET                              0x00100324 /* RW-4R */
#define NV_PFB_ZCOMP_OFFSET_ADR_SPACE                           3:0 /* RW-UF */
#define NV_PFB_ZCOMP_OFFSET_ADR                               25:14 /* RW-UF */
#define NV_PFB_ZCOMP_OFFSET_EN                                31:31 /* RWIVF */
#define NV_PFB_ZCOMP_OFFSET_EN_FALSE                     0x00000000 /* RWI-V */
#define NV_PFB_ZCOMP_OFFSET_EN_TRUE                      0x00000001 /* RW--V */
#define NV_PFB_ARB_PREDIVIDER                            0x00100328 /* RW-4R */
#define NV_PFB_ARB_PREDIVIDER_DIV                               7:0 /* RW-UF */
#define NV_PFB_ARB_PREDIVIDER_DIV_20                     0x00000020 /* RWIUV */
#define NV_PFB_ARB_TIMEOUT                               0x0010032C /* RW-4R */
#define NV_PFB_ARB_TIMEOUT_LP                                   7:4 /* RW-UF */
#define NV_PFB_ARB_TIMEOUT_LP_8                          0x00000008 /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_LP_DISABLE                    0x0000000F /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_ZO                                  11:8 /* RW-UF */
#define NV_PFB_ARB_TIMEOUT_ZO_8                          0x00000008 /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_ZO_DISABLE                    0x0000000F /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_TX                                 15:12 /* RW-UF */
#define NV_PFB_ARB_TIMEOUT_TX_8                          0x00000008 /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_TX_DISABLE                    0x0000000F /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_ZR                                 19:16 /* RW-UF */
#define NV_PFB_ARB_TIMEOUT_ZR_8                          0x00000008 /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_ZR_DISABLE                    0x0000000F /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_ZW                                 23:20 /* RW-UF */
#define NV_PFB_ARB_TIMEOUT_ZW_8                          0x00000008 /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_ZW_DISABLE                    0x0000000F /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_CR                                 27:24 /* RW-UF */
#define NV_PFB_ARB_TIMEOUT_CR_8                          0x00000008 /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_CR_DISABLE                    0x0000000F /* RW-UV */
#define NV_PFB_ARB_TIMEOUT_CW                                 31:28 /* RW-UF */
#define NV_PFB_ARB_TIMEOUT_CW_8                          0x00000008 /* RWIUV */
#define NV_PFB_ARB_TIMEOUT_CW_DISABLE                    0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ                               0x00100330 /* RW-4R */
#define NV_PFB_ARB_XFER_SZ_LP                                   7:4 /* RW-UF */
#define NV_PFB_ARB_XFER_SZ_LP_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_LP_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_LP_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZO                                  11:8 /* RW-UF */
#define NV_PFB_ARB_XFER_SZ_ZO_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_ZO_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZO_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_TX                                 15:12 /* RW-UF */
#define NV_PFB_ARB_XFER_SZ_TX_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_TX_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_TX_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZR                                 19:16 /* RW-UF */
#define NV_PFB_ARB_XFER_SZ_ZR_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_ZR_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZR_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZW                                 23:20 /* RW-UF */
#define NV_PFB_ARB_XFER_SZ_ZW_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_ZW_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_ZW_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_CR                                 27:24 /* RW-UF */
#define NV_PFB_ARB_XFER_SZ_CR_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_CR_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_CR_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_CW                                 31:28 /* RW-UF */
#define NV_PFB_ARB_XFER_SZ_CW_8                          0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_SZ_CW_MIN                        0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_SZ_CW_INF                        0x0000000F /* RW-UV */
#define NV_PFB_ARB_XFER_REM                              0x00100334 /* RW-4R */
#define NV_PFB_ARB_XFER_REM_LP                                  7:4 /* RW-UF */
#define NV_PFB_ARB_XFER_REM_LP_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_LP_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_LP_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZO                                 11:8 /* RW-UF */
#define NV_PFB_ARB_XFER_REM_ZO_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZO_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_ZO_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_TX                                15:12 /* RW-UF */
#define NV_PFB_ARB_XFER_REM_TX_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_TX_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_TX_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZR                                19:16 /* RW-UF */
#define NV_PFB_ARB_XFER_REM_ZR_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZR_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_ZR_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZW                                23:20 /* RW-UF */
#define NV_PFB_ARB_XFER_REM_ZW_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_ZW_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_ZW_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_CR                                27:24 /* RW-UF */
#define NV_PFB_ARB_XFER_REM_CR_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_CR_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_CR_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_CW                                31:28 /* RW-UF */
#define NV_PFB_ARB_XFER_REM_CW_0                         0x00000000 /* RW-UV */
#define NV_PFB_ARB_XFER_REM_CW_4                         0x00000004 /* RWIUV */
#define NV_PFB_ARB_XFER_REM_CW_8                         0x00000008 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK                             0x00100338 /* RW-4R */
#define NV_PFB_ARB_DIFF_BANK_LP                                 1:1 /* RW-UF */
#define NV_PFB_ARB_DIFF_BANK_LP_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_LP_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_ZO                                 2:2 /* RW-UF */
#define NV_PFB_ARB_DIFF_BANK_ZO_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_ZO_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_TX                                 3:3 /* RW-UF */
#define NV_PFB_ARB_DIFF_BANK_TX_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_TX_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_ZR                                 4:4 /* RW-UF */
#define NV_PFB_ARB_DIFF_BANK_ZR_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_ZR_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_ZW                                 5:5 /* RW-UF */
#define NV_PFB_ARB_DIFF_BANK_ZW_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_ZW_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_CR                                 6:6 /* RW-UF */
#define NV_PFB_ARB_DIFF_BANK_CR_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_CR_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_ARB_DIFF_BANK_CW                                 7:7 /* RW-UF */
#define NV_PFB_ARB_DIFF_BANK_CW_DISABLED                 0x00000000 /* RW-UV */
#define NV_PFB_ARB_DIFF_BANK_CW_ENABLED                  0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0                               0x00100340 /* RW-4R */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_HP                          0:0 /* RW-UF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_HP_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_HP_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_LP                          1:1 /* RW-UF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_LP_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_LP_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZO                          2:2 /* RW-UF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZO_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZO_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_TX                          3:3 /* RW-UF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_TX_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_TX_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZR                          4:4 /* RW-UF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZR_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZR_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZW                          5:5 /* RW-UF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZW_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_ZW_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CR                          6:6 /* RW-UF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CR_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CR_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CW                          7:7 /* RW-UF */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CW_DISABLED          0x00000000 /* RW-UV */
#define NV_PFB_CLOSE_PAGE0_DIFF_ROW_CW_ENABLED           0x00000001 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1                               0x00100344 /* RW-4R */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_HP                         0:0 /* RW-UF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_HP_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_HP_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_LP                         1:1 /* RW-UF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_LP_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_LP_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZO                         2:2 /* RW-UF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZO_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZO_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_TX                         3:3 /* RW-UF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_TX_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_TX_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZR                         4:4 /* RW-UF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZR_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZR_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZW                         5:5 /* RW-UF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZW_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_ZW_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CR                         6:6 /* RW-UF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CR_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CR_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CW                         7:7 /* RW-UF */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CW_DISABLED         0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE1_DIFF_BANK_CW_ENABLED          0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2                               0x00100348 /* RW-4R */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_HP                           0:0 /* RW-UF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_HP_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_HP_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_LP                           1:1 /* RW-UF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_LP_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_LP_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZO                           2:2 /* RW-UF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZO_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZO_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_TX                           3:3 /* RW-UF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_TX_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_TX_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZR                           4:4 /* RW-UF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZR_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZR_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZW                           5:5 /* RW-UF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZW_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_ZW_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CR                           6:6 /* RW-UF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CR_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CR_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CW                           7:7 /* RW-UF */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CW_DISABLED           0x00000000 /* RWIUV */
#define NV_PFB_CLOSE_PAGE2_Q_EMPTY_CW_ENABLED            0x00000001 /* RW-UV */
#define NV_PFB_BPARB                                     0x0010034C /* RW-4R */
#define NV_PFB_BPARB_HP_ARB_MODE                                3:0 /* RWI-F */
#define NV_PFB_BPARB_HP_ARB_MODE_REL_WTRMRK_10           0x00000000 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_REL_WTRMRK_8            0x00000001 /* RWIUV */
#define NV_PFB_BPARB_HP_ARB_MODE_REL_WTRMRK_6            0x00000002 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_REL_WTRMRK_4            0x00000003 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_NEVER              0x00000004 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_1_IF_ACT           0x00000005 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_2_IF_ACT           0x00000006 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_3_IF_ACT           0x00000007 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_4_IF_ACT           0x00000008 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_5_IF_ACT           0x00000009 /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_6_IF_ACT           0x0000000a /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_7_IF_ACT           0x0000000b /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_8_IF_ACT           0x0000000c /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_9_IF_ACT           0x0000000d /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_10_IF_ACT          0x0000000e /* RW-UV */
#define NV_PFB_BPARB_HP_ARB_MODE_KEEP_IF_ACTIVE          0x0000000f /* RW-UV */
#define NV_PFB_CMDQ                                      0x00100350 /* RW-4R */
#define NV_PFB_CMDQ_RW                                          4:0 /* RWI-F */
#define NV_PFB_CMDQ_RW_4                                 0x00000004 /* RW-UV */
#define NV_PFB_CMDQ_RW_8                                 0x00000008 /* RW-UV */
#define NV_PFB_CMDQ_RW_10                                0x0000000A /* RW-UV */
#define NV_PFB_CMDQ_RW_12                                0x0000000C /* RW-UV */
#define NV_PFB_CMDQ_RW_14                                0x0000000E /* RW-UV */
#define NV_PFB_CMDQ_RW_16                                0x00000010 /* RWIUV */
#define NV_PFB_CMDQ_ACT                                        10:8 /* RWI-F */
#define NV_PFB_CMDQ_ACT_1                                0x00000001 /* RW-UV */
#define NV_PFB_CMDQ_ACT_2                                0x00000002 /* RW-UV */
#define NV_PFB_CMDQ_ACT_3                                0x00000003 /* RW-UV */
#define NV_PFB_CMDQ_ACT_4                                0x00000004 /* RWIUV */
#define NV_PFB_CMDQ_PRE                                       14:12 /* RWI-F */
#define NV_PFB_CMDQ_PRE_1                                0x00000001 /* RW-UV */
#define NV_PFB_CMDQ_PRE_2                                0x00000002 /* RW-UV */
#define NV_PFB_CMDQ_PRE_3                                0x00000003 /* RW-UV */
#define NV_PFB_CMDQ_PRE_4                                0x00000004 /* RWIUV */
#define NV_PFB_ILL_INSTR(i)                      (0x00100360+(i)*4) /* R--4A */
#define NV_PFB_ILL_INSTR__SIZE_1                                  4 /*       */
#define NV_PFB_ILL_INSTR_REQID                                  4:0 /* R--VF */
#define NV_PFB_ILL_INSTR_CMD                                   26:5 /* R--VF */
#define NV_PFB_ILL_INSTR_CODE                                 30:27 /* R--VF */
#define NV_PFB_ILL_INSTR_TRAPPED                                 31 /* R--VF */
/* dev_fb.ref */
#define NV_PFBM                               0x3FFFFFFF:0x08000000 /* RW--M */
/* dev_fb.ref */
#define NV_PFBIN                              0x007FFFFF:0x00700000 /* RW--M */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00680000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
/* dev_ext_devices.ref */
/* dev_fifo.ref */
#define NV_USER                               0x00BFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                   32 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                  32 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                  32 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                  32 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                  32 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_DMA_PUT(i,j)    (0x00800040+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_DMA_PUT__SIZE_1                                  32 /*       */
#define NV_USER_DMA_PUT__SIZE_2                                   8 /*       */
#define NV_USER_DMA_PUT_OFFSET                                 31:2 /* -WXUF */
#define NV_USER_DMA_GET(i,j)    (0x00800044+(i)*0x10000+(j)*0x2000) /* R--4A */
#define NV_USER_DMA_GET__SIZE_1                                  32 /*       */
#define NV_USER_DMA_GET__SIZE_2                                   8 /*       */
#define NV_USER_DMA_GET_OFFSET                                 31:2 /* R-XUF */
#define NV_USER_REF(i,j)        (0x00800048+(i)*0x10000+(j)*0x2000) /* R--4A */
#define NV_USER_REF__SIZE_1                                      32 /*       */
#define NV_USER_REF__SIZE_2                                       8 /*       */
#define NV_USER_REF_CNT                                        31:0 /* R-XUF */
/* dev_fifo.ref */
#define NV_UDMA_OBJECT(j)                   (0x00000000+(j)*0x2000) /* -W-4A */
#define NV_UDMA_OBJECT__SIZE_1                                   32 /*       */
#define NV_UDMA_OBJECT__SIZE_2                                    8 /*       */
#define NV_UDMA_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_UDMA_SET_REF(j)                  (0x00000050+(j)*0x2000) /* R--4A */
#define NV_UDMA_SET_REF__SIZE_1                                  32 /*       */
#define NV_UDMA_SET_REF__SIZE_2                                   8 /*       */
#define NV_UDMA_SET_REF_CNT                                    31:0 /* R-XUF */
#define NV_UDMA_SEM_CTXDMA(j)               (0x00000060+(j)*0x2000) /* -W-4A */
#define NV_UDMA_SEM_CTXDMA__SIZE_1                               32 /*       */
#define NV_UDMA_SEM_CTXDMA__SIZE_2                                8 /*       */
#define NV_UDMA_SEM_CTXDMA_HANDLE                              31:0 /* -W-VF */
#define NV_UDMA_SEM_OFFSET(j)               (0x00000064+(j)*0x2000) /* -W-4A */
#define NV_UDMA_SEM_OFFSET__SIZE_1                               32 /*       */
#define NV_UDMA_SEM_OFFSET__SIZE_2                                8 /*       */
#define NV_UDMA_SEM_OFFSET_ADDRESS                             11:2 /* -W-VF */
#define NV_UDMA_SEM_ACQUIRE(j)              (0x00000068+(j)*0x2000) /* -W-4A */
#define NV_UDMA_SEM_ACQUIRE__SIZE_1                              32 /*       */
#define NV_UDMA_SEM_ACQUIRE__SIZE_2                               8 /*       */
#define NV_UDMA_SEM_ACQUIRE_VALUE                              31:0 /* -W-VF */
#define NV_UDMA_SEM_RELEASE(j)              (0x0000006C+(j)*0x2000) /* -W-4A */
#define NV_UDMA_SEM_RELEASE__SIZE_1                              32 /*       */
#define NV_UDMA_SEM_RELEASE__SIZE_2                               8 /*       */
#define NV_UDMA_SEM_RELEASE_VALUE                              31:0 /* -W-VF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_ENGINE                       ( 1*32+17):( 1*32+16) /* RWXVF */
#define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMHT_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMHT_CHID                         ( 1*32+28):( 1*32+24) /* RWXUF */
#define NV_RAMHT_STATUS                       ( 1*32+31):( 1*32+31) /* RWXUF */
#define NV_RAMHT_STATUS_INVALID                          0x00000000 /* RW--V */
#define NV_RAMHT_STATUS_VALID                            0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+12):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_SUBCHANNEL                   ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXUF */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000003FF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_1                      0x000007FF:0x00000000 /* RW--M */
#define NV_RAMFC_DMA_PUT                      ( 0*32+31):( 0*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_GET                      ( 1*32+31):( 1*32+ 2) /* RWXUF */
#define NV_RAMFC_REF_CNT                      ( 2*32+31):( 2*32+ 0) /* RWXUF */
#define NV_RAMFC_DMA_INST                     ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_RAMFC_DMA_COUNT                    ( 3*32+28):( 3*32+18) /* RWXUF */
#define NV_RAMFC_DMA_METHOD                   ( 4*32+12):( 4*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_SUBCHANNEL               ( 4*32+15):( 4*32+13) /* RWXUF */
#define NV_RAMFC_DMA_METHOD_COUNT             ( 4*32+28):( 4*32+18) /* RWXUF */
#define NV_RAMFC_DMA_METHOD_TYPE              ( 4*32+ 0):( 4*32+ 0) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_TRIG               ( 5*32+ 7):( 5*32+ 3) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_SIZE               ( 5*32+15):( 5*32+13) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_MAX_REQS           ( 5*32+20):( 5*32+16) /* RWXUF */
#define NV_RAMFC_BIG_ENDIAN                   ( 5*32+31):( 5*32+31) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_0                 ( 6*32+ 1):( 6*32+ 0) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_1                 ( 6*32+ 5):( 6*32+ 4) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_2                 ( 6*32+ 9):( 6*32+ 8) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_3                 ( 6*32+13):( 6*32+12) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_4                 ( 6*32+17):( 6*32+16) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_5                 ( 6*32+21):( 6*32+20) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_6                 ( 6*32+25):( 6*32+24) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_7                 ( 6*32+29):( 6*32+28) /* RWXUF */
#define NV_RAMFC_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMFC_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE                 ( 7*32+ 1):( 7*32+ 0) /* RWXUF */
#define NV_RAMFC_PULL1_ENGINE_SW                         0x00000000 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_GRAPHICS                   0x00000001 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_DVD                        0x00000002 /* RW--V */
#define NV_RAMFC_PULL1_ACQ_STATE              ( 7*32+ 4):( 7*32+ 4) /* RWXVF */
#define NV_RAMFC_PULL1_ACQ_STATE_INACTIVE                0x00000000 /* RW--V */
#define NV_RAMFC_PULL1_ACQ_STATE_ACTIVE                  0x00000001 /* RW--V */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE        ( 7*32+17):( 7*32+16) /* RWXUF */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_NVM               0x00000000 /* RW--V */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_PCI               0x00000002 /* RW--V */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_AGP               0x00000003 /* RW--V */
#define NV_RAMFC_ACQUIRE_VALUE                ( 8*32+31):( 8*32+ 0) /* RWXUF */
#define NV_RAMFC_ACQUIRE_TIMESTAMP            ( 9*32+31):( 9*32+ 0) /* RWXUF */
#define NV_RAMFC_ACQUIRE_TIMEOUT              (10*32+30):(10*32+ 0) /* RWXUF */
#define NV_RAMFC_SEMAPHORE_CTXDMA             (11*32+ 0):(11*32+ 0) /* RWXVF */
#define NV_RAMFC_SEMAPHORE_CTXDMA_INVALID                0x00000000 /* RW--V */
#define NV_RAMFC_SEMAPHORE_CTXDMA_VALID                  0x00000001 /* RW--V */
#define NV_RAMFC_SEMAPHORE_OFFSET             (11*32+11):(11*32+ 2) /* RWXUF */
#define NV_RAMFC_SEMAPHORE_PAGE_ADDRESS       (11*32+31):(11*32+12) /* RWXUF */
#define NV_RAMFC_DMA_SUBROUTINE_STATE         (12*32+ 0):(12*32+ 0) /* RWXVF */
#define NV_RAMFC_DMA_SUBROUTINE_STATE_INACTIVE           0x00000000 /* RW--V */
#define NV_RAMFC_DMA_SUBROUTINE_STATE_ACTIVE             0x00000001 /* RW--V */
#define NV_RAMFC_DMA_SUBROUTINE_RETURN_OFFSET (12*32+31):(12*32+ 2) /* RWXUF */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_RAMDVD_CTX_TABLE                   (63*32+31):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT(c,s) (((c)*4+((s)/2))*32+((s)%2)*16+15):(((c)*4+((s)/2))*32+((s)%2)*16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0        ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1        ( 0*32+31):( 0*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2        ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3        ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4        ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5        ( 2*32+31):( 2*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6        ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7        ( 3*32+31):( 3*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0       (60*32+15):(60*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1       (60*32+31):(60*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2       (61*32+15):(61*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3       (61*32+31):(61*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4       (62*32+15):(62*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5       (62*32+31):(62*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6       (63*32+15):(63*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7       (63*32+31):(63*32+16) /* RWXUF */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_DMA_CLASS                          ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+12):( 0*32+12) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_PAGE_ENTRY                     ( 0*32+13):( 0*32+13) /* RWXVF */
#define NV_DMA_PAGE_ENTRY_NOT_LINEAR                     0x00000000 /* RW--V */
#define NV_DMA_PAGE_ENTRY_LINEAR                         0x00000001 /* RW--V */
#define NV_DMA_FLAGS_ACCESS                   ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_DMA_FLAGS_ACCESS_READ_WRITE                   0x00000000 /* RW--V */
#define NV_DMA_FLAGS_ACCESS_OTHER                        0x00000001 /* RW--V */
#define NV_DMA_FLAGS_MAPPING_COHERENCY        ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_DMA_FLAGS_MAPPING_COHERENCY_UNCACHED          0x00000000 /* RW--V */
#define NV_DMA_FLAGS_MAPPING_COHERENCY_CACHED            0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE                    ( 0*32+17):( 0*32+16) /* RWXVF */
#define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
#define NV_DMA_TARGET_NODE_NVM_TILED                     0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
#define NV_DMA_MEMORY_CLASS                   ( 0*32+19):( 0*32+18) /* RWXVF */
#define NV_DMA_MEMORY_CLASS_NV01_MEMORY_LOCAL_LINEAR     0x00000000 /* RW--V */
#define NV_DMA_MEMORY_CLASS_NV01_MEMORY_LOCAL_BANKED     0x00000001 /* RW--V */
#define NV_DMA_MEMORY_CLASS_NV01_MEMORY_SYSTEM           0x00000002 /* RW--V */
#define NV_DMA_MEMORY_CLASS_OTHER                        0x00000003 /* RW--V */
#define NV_DMA_ADJUST                         ( 0*32+31):( 0*32+20) /* RWXUF */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
#define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
#define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */

#endif // _NV20_REF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mc\nv20\mcnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* MC Manager ********************************\
*                                                                           *
* Module: MCNV20.C                                                          *
*   The master control chip dependent HAL routines are kept here.           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nv20_ref.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// NV20 MC HAL entry points.
//

//
// nvHalMcControl
//
RM_STATUS
nvHalMcControl_NV20(VOID *arg)
{
    PMCCONTROLARG_000 pMcControlArg = (PMCCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMcControlArg->pHalHwInfo;
    PMCHALINFO pMcHalInfo;
    PMCHALINFO_NV20 pMcHalPvtInfo;
    U032 M, N, O, P;
    U032 crystal, pmc_boot0;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalMcControl_NV20\r\n");

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pMcControlArg->id != MC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pMcControlArg->pHalHwInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pMcHalPvtInfo = (PMCHALINFO_NV20)pHalHwInfo->pMcHalPvtInfo;

    switch (pMcControlArg->cmd)
    {
        case MC_CONTROL_SETREVISION:
        {
            PPRAMHALINFO pPramHalInfo = pHalHwInfo->pPramHalInfo;

            // set the inst mem offset
            pPramHalInfo->PraminOffset = DEVICE_BASE(NV_PRAMIN);

            //
            // Get chip revision information.
            //
            // We need to be careful here that the values we pull from the
            // hardware line up with the constants defined in mc.h, or
            // else we need to convert them accordingly.
            //
            pmc_boot0 = REG_RD32(NV_PMC_BOOT_0);

            pMcHalInfo->Subrevision      = 0;
            pMcHalInfo->MaskRevision     = MC_GET_MASKREVISION(pmc_boot0);
            pMcHalInfo->Revision         = MC_GET_REVISION(pmc_boot0);
            pMcHalInfo->Implementation   = MC_GET_IMPLEMENTATION(pmc_boot0);
            pMcHalInfo->Architecture     = MC_GET_ARCHITECTURE(pmc_boot0);
            pMcHalInfo->Manufacturer     = NV_PMC_BOOT_0_MANUFACTURER_NVIDIA;

            //
            // Take the Implementation out of the Architecture field.
            //
            pMcHalInfo->Architecture     ^= pMcHalInfo->Implementation;
            break;
        }
        case MC_CONTROL_INIT:
        {
            PDACHALINFO pDacHalInfo = pMcControlArg->pHalHwInfo->pDacHalInfo;
            PFIFOHALINFO pFifoHalInfo = pMcControlArg->pHalHwInfo->pFifoHalInfo;

            // JJV - Reset toggle the Master Control for the fifo and the Bus Mastering logic.
            // This is a fix for a DELL restart hang.19990409-125432.
            {
                U032 x;

                x=REG_RD32(NV_PMC_ENABLE);
                x&=~(DRF_DEF(_PMC, _ENABLE, _PFIFO, _ENABLED) | DRF_DEF(_PMC, _ENABLE, _PPMI, _ENABLED));
                REG_WR32(NV_PMC_ENABLE,x); 
                x|=(DRF_DEF(_PMC, _ENABLE, _PFIFO, _ENABLED) | DRF_DEF(_PMC, _ENABLE, _PPMI, _ENABLED));
                REG_WR32(NV_PMC_ENABLE,x); 
            }

            //
            // Save original MC registers.
            //
            pMcHalPvtInfo->SavePmc = REG_RD32(NV_PMC_ENABLE);
            if (pMcHalPvtInfo->SavePmc == 0)
            {
                //
                // This is 0 if NV not boot device! Enable everything so we at least work.
                //
                pMcHalPvtInfo->SavePmc = 0xFFFFFFFF;
                //
                // Reset all devices and interrupts.
                //
                REG_WR32(NV_PMC_ENABLE, 0x00000000);
            }
            pMcHalPvtInfo->SaveIntrEn0 = REG_RD32(NV_PMC_INTR_EN_0);
            REG_WR32(NV_PMC_ENABLE, 0xFFFFFFFF);

            //
            // Get the current clock settings.  This, of course, assumes that someone
            // has already started up the PLL's.
            //
            // Determine current strap crystal frequency (in Hz)
            //
            if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
                pMcHalInfo->CrystalFreq = 13500000;
            else if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
                pMcHalInfo->CrystalFreq = 14318180;

            // Get the crystal (Fin) * 1000
            crystal = pMcHalInfo->CrystalFreq;

            M = REG_RD_DRF(_PRAMDAC, _MPLL_COEFF, _MDIV);
            N = REG_RD_DRF(_PRAMDAC, _MPLL_COEFF, _NDIV);
            P = REG_RD_DRF(_PRAMDAC, _MPLL_COEFF, _PDIV);
            O = 1;
    
            pDacHalInfo->MPllM = M;
            pDacHalInfo->MPllN = N;
            pDacHalInfo->MPllO = O;
            pDacHalInfo->MPllP = P;
            pDacHalInfo->MClk  = ( M != 0 ) ? (N * crystal / (1 << P) / M) : 0;
    
            M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
            N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
            P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
            O = 1;
    
            pDacHalInfo->VPllM = M;
            pDacHalInfo->VPllN = N;
            pDacHalInfo->VPllO = O;
            pDacHalInfo->VPllP = P;
            pDacHalInfo->VClk  = ( M != 0 ) ? (N * crystal / (1 << P) / M) : 0;

            M = REG_RD_DRF(_PRAMDAC, _NVPLL_COEFF, _MDIV);
            N = REG_RD_DRF(_PRAMDAC, _NVPLL_COEFF, _NDIV);
            P = REG_RD_DRF(_PRAMDAC, _NVPLL_COEFF, _PDIV);
            O = 1;
    
            pDacHalInfo->NVPllM = M;
            pDacHalInfo->NVPllN = N;
            pDacHalInfo->NVPllO = O;
            pDacHalInfo->NVPllP = P;
            pDacHalInfo->NVClk  = ( M != 0 ) ? (N * crystal / (1 << P) / M) : 0;

            //
            // Initialize number of crtcs.
            //
            pDacHalInfo->NumCrtcs = 1;

            //
            // Get chip revision information.
            //
            // We need to be careful here that the values we pull from the
            // hardware line up with the constants defined in mc.h, or
            // else we need to convert them accordingly.
            //
            pmc_boot0 = REG_RD32(NV_PMC_BOOT_0);

            pMcHalInfo->Subrevision      = 0;
            pMcHalInfo->MaskRevision     = MC_GET_MASKREVISION(pmc_boot0);
            pMcHalInfo->Revision         = MC_GET_REVISION(pmc_boot0);
            pMcHalInfo->Implementation   = MC_GET_IMPLEMENTATION(pmc_boot0);
            pMcHalInfo->Architecture     = MC_GET_ARCHITECTURE(pmc_boot0);
            pMcHalInfo->Manufacturer     = NV_PMC_BOOT_0_MANUFACTURER_NVIDIA;

            //
            // Take the Implementation out of the Architecture field.
            //
            pMcHalInfo->Architecture     ^= pMcHalInfo->Implementation;

            //
            // Set fifo count/context size here so the values are
            // available for the rest of the STATE_INIT sequence.
            //
            pFifoHalInfo->Count = NUM_FIFOS_NV20;
            pFifoHalInfo->ContextSize = FC1_SIZE_NV20;
            break;
        }
        case MC_CONTROL_DESTROY:
            REG_WR32(NV_PMC_ENABLE, pMcHalPvtInfo->SavePmc);
            REG_WR32(NV_PMC_INTR_EN_0, pMcHalPvtInfo->SaveIntrEn0);
            break;
        case MC_CONTROL_LOAD:
        case MC_CONTROL_UNLOAD:
        case MC_CONTROL_UPDATE:
            break;
    }
    return (RM_OK);
}


//
// nvHalMcPower
//
RM_STATUS
nvHalMcPower_NV20(VOID *arg)
{
    PMCPOWERARG_000 pMcPowerArg = (PMCPOWERARG_000)arg;
    PHALHWINFO pHalHwInfo = pMcPowerArg->pHalHwInfo;
    PMCHALINFO_NV20 pMcHalPvtInfo;
    PMCHALPOWERINFO_NV20 pMcHalPowerInfo;
    PDACHALINFO pDacHalInfo; 
    PHWREG nvAddr;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalMcPower_NV20\r\n");

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pMcPowerArg->id != MC_POWER_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pMcPowerArg->pHalHwInfo;
    pMcHalPvtInfo = (PMCHALINFO_NV20)pHalHwInfo->pMcHalPvtInfo;
    pMcHalPowerInfo = &pMcHalPvtInfo->PowerInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Handle power management state transition.
    //
    switch (pMcPowerArg->newLevel)
    {
        case MC_POWER_LEVEL_0:
            switch (pMcPowerArg->oldLevel)
            {
                case MC_POWER_LEVEL_1:
                    //
                    // Turn up clock.
                    //
                    FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _ON);
                    break;
                case MC_POWER_LEVEL_2:
                    break;
                case MC_POWER_LEVEL_4:
                    //
                    // Restore fb regs.
                    // XXX Does cstatus really need to be power managed?
                    //     It's an ro register!?!?
                    //
                    REG_WR32(NV_PBUS_DEBUG_1, pMcHalPowerInfo->PbusDebug1);
                    REG_WR32(NV_PFB_TIMING2, pMcHalPowerInfo->PfbTiming2);
                    REG_WR32(NV_PFB_CFG0, pMcHalPowerInfo->PfbCfg0);
                    REG_WR32(NV_PFB_CFG1, pMcHalPowerInfo->PfbCfg1);
                    REG_WR32(NV_PGRAPH_FBCFG0, pMcHalPowerInfo->PfbCfg0);
                    REG_WR32(NV_PGRAPH_FBCFG1, pMcHalPowerInfo->PfbCfg1);
                    REG_WR32(NV_PFB_CSTATUS, pMcHalPowerInfo->PfbCstatus);
                    REG_WR32(NV_PFB_REFCTRL, pMcHalPowerInfo->PfbRefCtrl);
                    REG_WR32(NV_PFB_MRS, pMcHalPowerInfo->PfbMrs);
                    //REG_WR32(NV_PFB_EMRS, pMcHalPowerInfo->PfbEmrs);
                    REG_WR32(NV_PFB_REF, pMcHalPowerInfo->PfbRef);

                    //
                    // Turn up clock.
                    //
                    FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _ON);

                    //
                    // restore CRTC config (may include endian-ness)
                    //
                    for (i=0; i < pDacHalInfo->NumCrtcs; i++)
                    {
                        REG_WR32(NV_PCRTC_CONFIG + pDacHalInfo->CrtcInfo[i].RegOffset, 
                                 pMcHalPowerInfo->SaveCrtcConfig[i]);
                    }                 

                    break;

                case MC_POWER_LEVEL_3:
                {
                    PFIFOHALINFO_NV20 pFifoHalPvtInfo;
                    NV20_TILE_VALUES *tvp;
                    NV20_ZCOMP_VALUES *zvp;

                    pFifoHalPvtInfo = (PFIFOHALINFO_NV20)pMcPowerArg->pHalHwInfo->pFifoHalPvtInfo;

                    //
                    // Restore fb regs.
                    // XXX Does cstatus really need to be power managed?
                    //     It's an ro register!?!?
                    //
                    REG_WR32(NV_PBUS_DEBUG_1, pMcHalPowerInfo->PbusDebug1);
                    REG_WR32(NV_PFB_TIMING2, pMcHalPowerInfo->PfbTiming2);
                    REG_WR32(NV_PFB_CFG0, pMcHalPowerInfo->PfbCfg0);
                    REG_WR32(NV_PFB_CFG1, pMcHalPowerInfo->PfbCfg1);
                    REG_WR32(NV_PGRAPH_FBCFG0, pMcHalPowerInfo->PfbCfg0);
                    REG_WR32(NV_PGRAPH_FBCFG1, pMcHalPowerInfo->PfbCfg1);
                    REG_WR32(NV_PFB_CSTATUS, pMcHalPowerInfo->PfbCstatus);
                    REG_WR32(NV_PFB_REFCTRL, pMcHalPowerInfo->PfbRefCtrl);
                    REG_WR32(NV_PFB_MRS, pMcHalPowerInfo->PfbMrs);
                    //REG_WR32(NV_PFB_EMRS, pMcHalPowerInfo->PfbEmrs);
                    REG_WR32(NV_PFB_REF, pMcHalPowerInfo->PfbRef);

                    REG_WR32(NV_PFIFO_RAMHT, pMcHalPowerInfo->PfifoRamHt);
                    REG_WR32(NV_PFIFO_RAMFC, pMcHalPowerInfo->PfifoRamFc);
                    REG_WR32(NV_PFIFO_RAMRO, pMcHalPowerInfo->PfifoRamRo);

                    //
                    // Make sure write protection is disabled.
                    //
                    FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _DISABLE);
                    
                    // restore video registers - 8/29/2000 - dpearce
                    REG_WR32(NV_PVIDEO_INTR_EN,pMcHalPowerInfo->PvideoIntrEn);
                    REG_WR32(NV_PVIDEO_BUFFER,pMcHalPowerInfo->PvideoBuffer);
                    REG_WR32(NV_PVIDEO_STOP,pMcHalPowerInfo->PvideoStop);
                    REG_WR32(NV_PVIDEO_BASE(0),pMcHalPowerInfo->PvideoBase0);
                    REG_WR32(NV_PVIDEO_BASE(1),pMcHalPowerInfo->PvideoBase1);
                    REG_WR32(NV_PVIDEO_LIMIT(0),pMcHalPowerInfo->PvideoLimit0);
                    REG_WR32(NV_PVIDEO_LIMIT(1),pMcHalPowerInfo->PvideoLimit1);
                    REG_WR32(NV_PVIDEO_LUMINANCE(0),pMcHalPowerInfo->PvideoLuminance0);
                    REG_WR32(NV_PVIDEO_LUMINANCE(1),pMcHalPowerInfo->PvideoLuminance1);
                    REG_WR32(NV_PVIDEO_CHROMINANCE(0),pMcHalPowerInfo->PvideoChrominance0);
                    REG_WR32(NV_PVIDEO_CHROMINANCE(1),pMcHalPowerInfo->PvideoChrominance1);
                    REG_WR32(NV_PVIDEO_OFFSET(0),pMcHalPowerInfo->PvideoOffset0);
                    REG_WR32(NV_PVIDEO_OFFSET(1),pMcHalPowerInfo->PvideoOffset1);
                    REG_WR32(NV_PVIDEO_SIZE_IN(0),pMcHalPowerInfo->PvideoSizeIn0);
                    REG_WR32(NV_PVIDEO_SIZE_IN(1),pMcHalPowerInfo->PvideoSizeIn1);
                    REG_WR32(NV_PVIDEO_POINT_IN(0),pMcHalPowerInfo->PvideoPointIn0);
                    REG_WR32(NV_PVIDEO_POINT_IN(1),pMcHalPowerInfo->PvideoPointIn1);
                    REG_WR32(NV_PVIDEO_DS_DX(0),pMcHalPowerInfo->PvideoDsDx0);
                    REG_WR32(NV_PVIDEO_DS_DX(1),pMcHalPowerInfo->PvideoDsDx1);
                    REG_WR32(NV_PVIDEO_DT_DY(0),pMcHalPowerInfo->PvideoDtDy0);
                    REG_WR32(NV_PVIDEO_DT_DY(1),pMcHalPowerInfo->PvideoDtDy1);
                    REG_WR32(NV_PVIDEO_POINT_OUT(0),pMcHalPowerInfo->PvideoPointOut0);
                    REG_WR32(NV_PVIDEO_POINT_OUT(1),pMcHalPowerInfo->PvideoPointOut1);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(0),pMcHalPowerInfo->PvideoSizeOut0);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(1),pMcHalPowerInfo->PvideoSizeOut1);
                    REG_WR32(NV_PVIDEO_FORMAT(0),pMcHalPowerInfo->PvideoFormat0);
                    REG_WR32(NV_PVIDEO_FORMAT(1),pMcHalPowerInfo->PvideoFormat1);
                    REG_WR32(NV_PVIDEO_COLOR_KEY,pMcHalPowerInfo->PvideoColorKey);

                    //
                    // Restore SetOffsetRange registers.
                    //
                    REG_WR32(NV_PCRTC_RASTER_START, pMcHalPowerInfo->PcrtcRasterStart);
                    REG_WR32(NV_PCRTC_RASTER_STOP, pMcHalPowerInfo->PcrtcRasterStop);

                    //
                    // Restore tiling registers.
                    //
                    tvp = &pMcHalPowerInfo->TilingValues[0];
                    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++, tvp++)
                    {
                        REG_WR32(NV_PFB_TLIMIT(i),      tvp->tlimit);
                        REG_WR32(NV_PFB_TSIZE(i),       tvp->tsize);
                        REG_WR32(NV_PFB_TILE(i),        tvp->tile);

                        REG_WR32(NV_PGRAPH_TLIMIT(i),   tvp->tlimit);
                        REG_WR32(NV_PGRAPH_TSIZE(i),    tvp->tsize);
                        REG_WR32(NV_PGRAPH_TILE(i),     tvp->tile);
                    }

                    //
                    // Restore Z compression registers.
                    //
                    zvp = &pMcHalPowerInfo->ZcompValues[0];
                    for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++, zvp++)
                    {
                        REG_WR32(NV_PFB_ZCOMP(i), zvp->zcomp);
                        REG_WR32(NV_PGRAPH_ZCOMP(i), zvp->zcomp);
                    }
                    REG_WR32(NV_PFB_ZCOMP_OFFSET, pMcHalPowerInfo->ZcompOffset);
                    REG_WR32(NV_PGRAPH_ZCOMP_OFFSET, pMcHalPowerInfo->ZcompOffset);

                    //
                    // Restore fifo mode register.
                    //
                    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

                    //
                    // Turn up clock.
                    //
                    FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _ON);

                    //
                    // restore CRTC config (may include endian-ness)
                    //
                    for (i=0; i < pDacHalInfo->NumCrtcs; i++)
                    {
                        REG_WR32(NV_PCRTC_CONFIG + pDacHalInfo->CrtcInfo[i].RegOffset, 
                                 pMcHalPowerInfo->SaveCrtcConfig[i]);
                    }                 
                }
            }
            break;
        case MC_POWER_LEVEL_1:
            //
            // Turn down clocks.
            //
            FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _VPLL);
            FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _VPLL2);
            break;
        case MC_POWER_LEVEL_2:
            break;
        case MC_POWER_LEVEL_4:
            // refresh
            pMcHalPowerInfo->PfbTiming2 = REG_RD32(NV_PFB_TIMING2);
            // max refresh
            FLD_WR_DRF_NUM(_PFB, _TIMING2, _REFRESH, 0xFFFFFFFF);

            //
            // Chip has been init'd with the BIOS init tables, unless the BIOS
            // has an incompatible structure and the table was not found, in
            // which case we used a default table, which may not have the
            // correct RAM config, so we save away the current config for
            // restoration above.
            //
            pMcHalPowerInfo->PfbCfg0 = REG_RD32(NV_PFB_CFG0);
            pMcHalPowerInfo->PfbCfg1 = REG_RD32(NV_PFB_CFG1);
            pMcHalPowerInfo->PfbCstatus = REG_RD32(NV_PFB_CSTATUS);
            pMcHalPowerInfo->PfbRefCtrl = REG_RD32(NV_PFB_REFCTRL);
            pMcHalPowerInfo->PfbMrs = REG_RD32(NV_PFB_MRS);
            pMcHalPowerInfo->PfbEmrs = REG_RD32(NV_PFB_EMRS);
            pMcHalPowerInfo->PfbRef = REG_RD32(NV_PFB_REF);
            pMcHalPowerInfo->PbusDebug1 = REG_RD32(NV_PBUS_DEBUG_1);
            // CRTC config (may include endian-ness)
            for (i=0; i< pDacHalInfo->NumCrtcs; i++)
            {
                pMcHalPowerInfo->SaveCrtcConfig[i] = REG_RD32(NV_PCRTC_CONFIG + pDacHalInfo->CrtcInfo[i].RegOffset); 
            }
            //
            // Turn down clock.
            //
            //FLD_WR_DRF_DEF(_PRAMDAC, _PLL_SETUP_CONTROL, _PWRDWN, _VPLL);
            //FLD_WR_DRF_DEF(_PRAMDAC, _PLL_SETUP_CONTROL, _PWRDWN, _VPLL2);
            break;
        case MC_POWER_LEVEL_3:
        {
            NV20_TILE_VALUES *tvp;
            NV20_ZCOMP_VALUES *zvp;

            //
            // Save tiling value.
            //
            tvp = &pMcHalPowerInfo->TilingValues[0];
            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++, tvp++)
            {
                tvp->tlimit = REG_RD32(NV_PFB_TLIMIT(i));
                tvp->tsize  = REG_RD32(NV_PFB_TSIZE(i));
                tvp->tile   = REG_RD32(NV_PFB_TILE(i));
            }

            //
            // Save SetOffsetRange regs.
            //
            pMcHalPowerInfo->PcrtcRasterStart = REG_RD32(NV_PCRTC_RASTER_START);
            pMcHalPowerInfo->PcrtcRasterStop = REG_RD32(NV_PCRTC_RASTER_STOP);

            //save some video registers
            pMcHalPowerInfo->PvideoIntrEn=REG_RD32(NV_PVIDEO_INTR_EN) ;
            pMcHalPowerInfo->PvideoBuffer=REG_RD32(NV_PVIDEO_BUFFER) ;
            pMcHalPowerInfo->PvideoStop=REG_RD32(NV_PVIDEO_STOP) ;
            pMcHalPowerInfo->PvideoBase0=REG_RD32(NV_PVIDEO_BASE(0)) ;
            pMcHalPowerInfo->PvideoBase1=REG_RD32(NV_PVIDEO_BASE(1)) ;
            pMcHalPowerInfo->PvideoLimit0=REG_RD32(NV_PVIDEO_LIMIT(0)) ;
            pMcHalPowerInfo->PvideoLimit1=REG_RD32(NV_PVIDEO_LIMIT(1)) ;
            pMcHalPowerInfo->PvideoLuminance0=REG_RD32(NV_PVIDEO_LUMINANCE(0)) ;
            pMcHalPowerInfo->PvideoLuminance1=REG_RD32(NV_PVIDEO_LUMINANCE(1)) ;
            pMcHalPowerInfo->PvideoChrominance0=REG_RD32(NV_PVIDEO_CHROMINANCE(0)) ;
            pMcHalPowerInfo->PvideoChrominance1=REG_RD32(NV_PVIDEO_CHROMINANCE(1)) ;
            pMcHalPowerInfo->PvideoOffset0=REG_RD32(NV_PVIDEO_OFFSET(0)) ;
            pMcHalPowerInfo->PvideoOffset1=REG_RD32(NV_PVIDEO_OFFSET(1)) ;
            pMcHalPowerInfo->PvideoSizeIn0=REG_RD32(NV_PVIDEO_SIZE_IN(0)) ;
            pMcHalPowerInfo->PvideoSizeIn1=REG_RD32(NV_PVIDEO_SIZE_IN(1)) ;
            pMcHalPowerInfo->PvideoPointIn0=REG_RD32(NV_PVIDEO_POINT_IN(0)) ;
            pMcHalPowerInfo->PvideoPointIn1=REG_RD32(NV_PVIDEO_POINT_IN(1)) ;
            pMcHalPowerInfo->PvideoDsDx0=REG_RD32(NV_PVIDEO_DS_DX(0)) ;
            pMcHalPowerInfo->PvideoDsDx1=REG_RD32(NV_PVIDEO_DS_DX(1)) ;
            pMcHalPowerInfo->PvideoDtDy0=REG_RD32(NV_PVIDEO_DT_DY(0)) ;
            pMcHalPowerInfo->PvideoDtDy1=REG_RD32(NV_PVIDEO_DT_DY(1)) ;
            pMcHalPowerInfo->PvideoPointOut0=REG_RD32(NV_PVIDEO_POINT_OUT(0)) ;
            pMcHalPowerInfo->PvideoPointOut1=REG_RD32(NV_PVIDEO_POINT_OUT(1)) ;
            pMcHalPowerInfo->PvideoSizeOut0=REG_RD32(NV_PVIDEO_SIZE_OUT(0)) ;
            pMcHalPowerInfo->PvideoSizeOut1=REG_RD32(NV_PVIDEO_SIZE_OUT(1)) ;
            pMcHalPowerInfo->PvideoFormat0=REG_RD32(NV_PVIDEO_FORMAT(0)) ;
            pMcHalPowerInfo->PvideoFormat1=REG_RD32(NV_PVIDEO_FORMAT(1)) ;
            pMcHalPowerInfo->PvideoColorKey=REG_RD32(NV_PVIDEO_COLOR_KEY) ;


            //
            // Save Z compression registers.
            //
            zvp = &pMcHalPowerInfo->ZcompValues[0];
            for (i = 0; i < NV_PFB_ZCOMP__SIZE_1; i++, zvp++)
            {
                zvp->zcomp = REG_RD32(NV_PFB_ZCOMP(i));
            }
            pMcHalPowerInfo->ZcompOffset = REG_RD32(NV_PFB_ZCOMP_OFFSET);

            // refresh
            pMcHalPowerInfo->PfbTiming2 = REG_RD32(NV_PFB_TIMING2);
            // max refresh
            FLD_WR_DRF_NUM(_PFB, _TIMING2, _REFRESH, 0xFFFFFFFF);

            //
            // Chip has been init'd with the BIOS init tables, unless the BIOS
            // has an incompatible structure and the table was not found, in
            // which case we used a default table, which may not have the
            // correct RAM config, so we save away the current config for
            // restoration above.
            //
            pMcHalPowerInfo->PfbCfg0 = REG_RD32(NV_PFB_CFG0);
            pMcHalPowerInfo->PfbCfg1 = REG_RD32(NV_PFB_CFG1);
#ifdef DEBUG
            //
            // Assume NV_PGRAPH_CFG0/NV_PGRAPH_CFG1 are the same.
            //
            if (REG_RD32(NV_PFB_CFG0) != REG_RD32(NV_PGRAPH_FBCFG0))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: pfb_cfg0 != pgraph_cfg0\n");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, " pfb_cfg0 ", REG_RD32(NV_PFB_CFG0));
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, " pgraph_cfg0 ", REG_RD32(NV_PGRAPH_FBCFG0));
                DBG_BREAKPOINT();
            }
            if (REG_RD32(NV_PFB_CFG1) != REG_RD32(NV_PGRAPH_FBCFG1))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: pfb_cfg1 != pgraph_cfg1\n");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, " pfb_cfg1 ", REG_RD32(NV_PFB_CFG1));
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, " pgraph_cfg1 ", REG_RD32(NV_PGRAPH_FBCFG1));
                DBG_BREAKPOINT();
            }
#endif

            pMcHalPowerInfo->PfbCstatus = REG_RD32(NV_PFB_CSTATUS);
            pMcHalPowerInfo->PfbRefCtrl = REG_RD32(NV_PFB_REFCTRL);
            pMcHalPowerInfo->PfbMrs = REG_RD32(NV_PFB_MRS);
            pMcHalPowerInfo->PfbEmrs = REG_RD32(NV_PFB_EMRS);
            pMcHalPowerInfo->PfbRef = REG_RD32(NV_PFB_REF);
            pMcHalPowerInfo->PbusDebug1 = REG_RD32(NV_PBUS_DEBUG_1);
            pMcHalPowerInfo->PfifoRamHt = REG_RD32(NV_PFIFO_RAMHT);
            pMcHalPowerInfo->PfifoRamFc = REG_RD32(NV_PFIFO_RAMFC);
            pMcHalPowerInfo->PfifoRamRo = REG_RD32(NV_PFIFO_RAMRO);

            // CRTC config (may include endian-ness)
            for (i=0; i< pDacHalInfo->NumCrtcs; i++)
            {
                pMcHalPowerInfo->SaveCrtcConfig[i] = REG_RD32(NV_PCRTC_CONFIG + pDacHalInfo->CrtcInfo[i].RegOffset); 
            }

/*
When going into hibernation, the NT miniport makes a power state transition from state 0 to state 3.  State 3
implies that ALL clocks have been put in a power-down state, i.e. lowered.  Unfortunately, NT also requires 
the ability to perform VGA accesses *AFTER* the power management call.  Putting PClk into a power-down state 
disables VGA accesses, so for the time being, for NT, we cannot allow PClk to be put into a power-down state.
NOTE:  This is a liability if the system does not truly remove power from the device during hibernation.  In
this case, PClk will still be drawing full current, which could lead to power saving specs' being violated or,
more importantly, reliability problems with the device.
*/
#ifndef NTRM
            //
            // Turn down clock.
            //
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_SETUP_CONTROL, _PWRDWN, _VPLL);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_SETUP_CONTROL, _PWRDWN, _VPLL2);
            break;
#endif
        }
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

BOOL IsNV20_NV20(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV20) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV20));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mc\nv10\mcnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* MC Manager ********************************\
*                                                                           *
* Module: MCNV10.C                                                          *
*   The master control chip dependent HAL routines are kept here.           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nv10_ref.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// NV10 MC HAL entry points.
//

//
// nvHalMcControl
//
RM_STATUS
nvHalMcControl_NV10(VOID *arg)
{
    PMCCONTROLARG_000 pMcControlArg = (PMCCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMcControlArg->pHalHwInfo;
    PMCHALINFO pMcHalInfo;
    PMCHALINFO_NV10 pMcHalPvtInfo;
    U032 M, N, O, P;
    U032 crystal, pmc_boot0;
    U032 IsPllSlowed = 0;  // some compilers think its uninitialized otherwise

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalMcControl_NV10\r\n");

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pMcControlArg->id != MC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pMcControlArg->pHalHwInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pMcHalPvtInfo = (PMCHALINFO_NV10)pHalHwInfo->pMcHalPvtInfo;

    switch (pMcControlArg->cmd)
    {
        case MC_CONTROL_SETREVISION:
        {
            PPRAMHALINFO pPramHalInfo = pHalHwInfo->pPramHalInfo;

            // set the inst mem offset
            pPramHalInfo->PraminOffset = DEVICE_BASE(NV_PRAMIN);

            //
            // Get chip revision information.
            //
            // We need to be careful here that the values we pull from the
            // hardware line up with the constants defined in mc.h, or
            // else we need to convert them accordingly.
            //
            // On NV10 and family, they do so we're OK.
            //
            pmc_boot0 = REG_RD32(NV_PMC_BOOT_0);

            pMcHalInfo->Subrevision      = 0;
            pMcHalInfo->MaskRevision     = MC_GET_MASKREVISION(pmc_boot0);
            pMcHalInfo->Revision         = MC_GET_REVISION(pmc_boot0);
            pMcHalInfo->Implementation   = MC_GET_IMPLEMENTATION(pmc_boot0);
            pMcHalInfo->Architecture     = MC_GET_ARCHITECTURE(pmc_boot0);
            pMcHalInfo->Manufacturer     = NV_PMC_BOOT_0_MANUFACTURER_NVIDIA;
            break;
        }
        case MC_CONTROL_INIT:
        {
            PDACHALINFO pDacHalInfo = pHalHwInfo->pDacHalInfo;
            PFIFOHALINFO pFifoHalInfo = pHalHwInfo->pFifoHalInfo;

            // JJV - Reset toggle the Master Control for the fifo and the Bus Mastering logic.
            // This is a fix for a DELL restart hang.19990409-125432.
            {
                U032 x;

                x=REG_RD32(NV_PMC_ENABLE);
                x&=~(DRF_DEF(_PMC, _ENABLE, _PFIFO, _ENABLED) | DRF_DEF(_PMC, _ENABLE, _PPMI, _ENABLED));
                REG_WR32(NV_PMC_ENABLE,x); 
                x|=(DRF_DEF(_PMC, _ENABLE, _PFIFO, _ENABLED) | DRF_DEF(_PMC, _ENABLE, _PPMI, _ENABLED));
                REG_WR32(NV_PMC_ENABLE,x); 
            }

            //
            // Save original MC registers.
            //
            pMcHalPvtInfo->SavePmc = REG_RD32(NV_PMC_ENABLE);
            if (pMcHalPvtInfo->SavePmc == 0)
            {
                //
                // This is 0 if NV not boot device! Enable everything so we at least work.
                //
                pMcHalPvtInfo->SavePmc = 0xFFFFFFFF;
                //
                // Reset all devices and interrupts.
                //
                REG_WR32(NV_PMC_ENABLE, 0x00000000);
            }
            pMcHalPvtInfo->SaveIntrEn0 = REG_RD32(NV_PMC_INTR_EN_0);
            REG_WR32(NV_PMC_ENABLE, 0xFFFFFFFF);

            //
            // Get the current clock settings.  This, of course, assumes that someone
            // has already started up the PLL's.
            //
            // Determine current strap crystal frequency (in Hz)
            //
            if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
                pMcHalInfo->CrystalFreq = 13500000;
            else if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
                pMcHalInfo->CrystalFreq = 14318180;

            // Get the crystal (Fin) * 1000
            crystal = pMcHalInfo->CrystalFreq;

            M = REG_RD_DRF(_PRAMDAC, _MPLL_COEFF, _MDIV);
            N = REG_RD_DRF(_PRAMDAC, _MPLL_COEFF, _NDIV);
            P = REG_RD_DRF(_PRAMDAC, _MPLL_COEFF, _PDIV);
            O = 1;
    
            pDacHalInfo->MPllM = M;
            pDacHalInfo->MPllN = N;
            pDacHalInfo->MPllO = O;
            pDacHalInfo->MPllP = P;
            pDacHalInfo->MClk  = ( M != 0 ) ? (N * crystal / (1 << P) / M) : 0;
    
            M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
            N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
            P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
            O = 1;
    
            pDacHalInfo->VPllM = M;
            pDacHalInfo->VPllN = N;
            pDacHalInfo->VPllO = O;
            pDacHalInfo->VPllP = P;
            pDacHalInfo->VClk  = ( M != 0 ) ? (N * crystal / (1 << P) / M) : 0;

            // Make sure to disable the clock slowdown circuit
            if (IsNV11_NV10(pMcHalInfo))
            {
                IsPllSlowed = REG_RD_DRF(_PBUS, _DEBUG_1, _CORE_SLOWDWN);
                FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, 0);
            }

            M = REG_RD_DRF(_PRAMDAC, _NVPLL_COEFF, _MDIV);
            N = REG_RD_DRF(_PRAMDAC, _NVPLL_COEFF, _NDIV);
            P = REG_RD_DRF(_PRAMDAC, _NVPLL_COEFF, _PDIV);
            O = 1;
    
            // Restore the clock slowdown circuit
            if (IsNV11_NV10(pMcHalInfo))
                FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

            pDacHalInfo->NVPllM = M;
            pDacHalInfo->NVPllN = N;
            pDacHalInfo->NVPllO = O;
            pDacHalInfo->NVPllP = P;
            pDacHalInfo->NVClk  = ( M != 0 ) ? (N * crystal / (1 << P) / M) : 0;

            //
            // Get chip revision information.
            //
            // We need to be careful here that the values we pull from the
            // hardware line up with the constants defined in chipid.h, or
            // else we need to convert them accordingly.
            //
            // On NV10 and family, they do so we're OK.
            //
            pmc_boot0 = REG_RD32(NV_PMC_BOOT_0);

            pMcHalInfo->Subrevision      = 0;
            pMcHalInfo->MaskRevision     =  pmc_boot0 &        0xFF;
            pMcHalInfo->Revision         = (pmc_boot0 &     0xF0000) >> 16; 
            pMcHalInfo->Implementation   = (pmc_boot0 &    0xF00000) >> 20;
            pMcHalInfo->Architecture     = (pmc_boot0 &  0xFFF00000) >> 20;
            pMcHalInfo->Manufacturer     = NV_PMC_BOOT_0_MANUFACTURER_NVIDIA;

            // take the Implementation out of the Architecture field
            pMcHalInfo->Architecture     ^= pMcHalInfo->Implementation;

            //
            // Initialize number of crtcs.
            //
            // NOTE: This code needs to be flushed out further to consider the board
            // layout and the number of physical display connectors.  An NV11 device on
            // a board with only a VGA connector should only report one CRTC available.
            //
            if (IsNV11_NV10(pMcHalInfo))
                pDacHalInfo->NumCrtcs = 2;
            else
                pDacHalInfo->NumCrtcs = 1;


            //
            // Because of a HW bug in NV10/NV15 (fixed in NV11) regarding Celsius SetContextDmaVertex when
            // passed the NULL object, we need to guarantee the first DWORD of the BIOS image looks like a
            // valid context DMA.
            // 
            // Lucky for us normally what lives at instance addr 0 is the first part of the BIOS VGA
            // signature (0xAA55), which appears to have the NV_DMA_PAGE_ENTRY_LINEAR set. But on IKOS and
            // possibly non-IBM Compatible BIOS's, we may not be so lucky. So, we'll check what's there
            // and if necessary, OR-in the NV_DMA_PAGE_TABLE_PRESENT bit (gulp).
            //
            if (IsNV10_NV10(pMcHalInfo) || IsNV15_NV10(pMcHalInfo))
            {
                U032 inst_addr0 = REG_RD32(DEVICE_BASE(NV_PRAMIN));

                if ((DRF_VAL(_DMA, _PAGE, _TABLE, inst_addr0) == NV_DMA_PAGE_TABLE_NOT_PRESENT) &&
                    (DRF_VAL(_DMA, _PAGE, _ENTRY, inst_addr0) == NV_DMA_PAGE_ENTRY_NOT_LINEAR))
                {
#if !defined(IKOS) && !defined(MACOS)
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Non-VGA BIOS image? Setting the PAGE_TABLE_PRESENT bit");
                    DBG_BREAKPOINT();
#endif
                    REG_WR32(DEVICE_BASE(NV_PRAMIN), (inst_addr0 | DRF_DEF(_DMA, _PAGE, _TABLE, _PRESENT)));
                }
            }

            //
            // Set fifo count/context size here so the values are
            // available for the rest of the STATE_INIT sequence.
            //
            pFifoHalInfo->Count = NUM_FIFOS_NV10;
            pFifoHalInfo->ContextSize = FC_SIZE_NV10;
            break;
        }
        case MC_CONTROL_DESTROY:
            REG_WR32(NV_PMC_ENABLE, pMcHalPvtInfo->SavePmc);
            REG_WR32(NV_PMC_INTR_EN_0, pMcHalPvtInfo->SaveIntrEn0);
            break;
        case MC_CONTROL_LOAD:
        case MC_CONTROL_UNLOAD:
        case MC_CONTROL_UPDATE:
            break;
    }
    return (RM_OK);
}


//
// nvHalMcPower
//
RM_STATUS
nvHalMcPower_NV10(VOID *arg)
{
    PMCPOWERARG_000 pMcPowerArg = (PMCPOWERARG_000)arg;
    PHALHWINFO pHalHwInfo = pMcPowerArg->pHalHwInfo;
    PMCHALINFO_NV10 pMcHalPvtInfo;
    PMCHALPOWERINFO_NV10 pMcHalPowerInfo;
    PDACHALINFO pDacHalInfo; 
    PHWREG nvAddr;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalMcPower_NV10\r\n");

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pMcPowerArg->id != MC_POWER_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pMcPowerArg->pHalHwInfo;
    pMcHalPvtInfo = (PMCHALINFO_NV10)pHalHwInfo->pMcHalPvtInfo;
    pMcHalPowerInfo = &pMcHalPvtInfo->PowerInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;
	
    //
    // Handle power management state transition.
    //
    switch (pMcPowerArg->newLevel)
    {
        case MC_POWER_LEVEL_0:
            switch (pMcPowerArg->oldLevel)
            {
                case MC_POWER_LEVEL_1:
                    //
                    // Turn up clock.
                    //
                    FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _ON);
                    break;
                case MC_POWER_LEVEL_2:
                {
                    U032 data32;

                    //
                    // This section is for mobile only!
                    //
                    // We don't expose the MobileOperation switch to the HAL
                    // at the moment, so we rely on the RM to never use this
                    // state (MC_POWER_LEVEL_2) except when MobileOperation
                    // is defined.
                    //
                    // Refer to mcstate.c for the MobileOperation check.
                    //
                    data32 = REG_RD32(NV_PFB_SELF_REF);
                    data32 &= ~(SF_DEF(_PFB, _SELF_REF_CMD, _ENABLED));
                    REG_WR32(NV_PFB_SELF_REF, data32);
                    break;
                }
                case MC_POWER_LEVEL_4:
                    // must set FBI differential
                    REG_WR32(NV_PBUS_DEBUG_1, pMcHalPowerInfo->PbusDebug1);
                    // refresh
                    REG_WR32(NV_PFB_TIMING2, pMcHalPowerInfo->PfbTiming2);
                    REG_WR32(NV_PFB_CFG, pMcHalPowerInfo->PfbBoot0);
                    REG_WR32(NV_PFB_CSTATUS, pMcHalPowerInfo->PfbConfig0);
                    REG_WR32(NV_PFB_REFCTRL, pMcHalPowerInfo->PfbConfig1);
                    REG_WR32(NV_PFB_MRS, pMcHalPowerInfo->PfbMrs);
                    //REG_WR32(NV_PFB_EMRS, pMcHalPowerInfo->PfbEmrs);
                    REG_WR32(NV_PFB_REF, pMcHalPowerInfo->PfbRef);
                    //
                    // Turn up clock.
                    //
                    FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _ON);

                    //
                    // restore CRTC config (may include endian-ness)
                    //
                    for (i=0; i < pDacHalInfo->NumCrtcs; i++)
                    {
                        REG_WR32(NV_PCRTC_CONFIG + pDacHalInfo->CrtcInfo[i].RegOffset, 
                                 pMcHalPowerInfo->SaveCrtcConfig[i]);
                    }                 

                    break;

                case MC_POWER_LEVEL_3:
                {
                    PFIFOHALINFO_NV10 pFifoHalPvtInfo;
                    NV10_TILE_VALUES *tvp;

                    pFifoHalPvtInfo = (PFIFOHALINFO_NV10)pMcPowerArg->pHalHwInfo->pFifoHalPvtInfo;

                    //
                    // Restore fb regs.
                    //

                    // must set FBI differential
                    REG_WR32(NV_PBUS_DEBUG_1, pMcHalPowerInfo->PbusDebug1);
                    // refresh
                    REG_WR32(NV_PFB_TIMING2, pMcHalPowerInfo->PfbTiming2);
                    REG_WR32(NV_PFB_CFG, pMcHalPowerInfo->PfbBoot0);
                    REG_WR32(NV_PFB_CSTATUS, pMcHalPowerInfo->PfbConfig0);
                    REG_WR32(NV_PFB_REFCTRL, pMcHalPowerInfo->PfbConfig1);
                    REG_WR32(NV_PFB_MRS, pMcHalPowerInfo->PfbMrs);
                    //REG_WR32(NV_PFB_EMRS, pMcHalPowerInfo->PfbEmrs);
                    REG_WR32(NV_PFB_REF, pMcHalPowerInfo->PfbRef);

                    REG_WR32(NV_PFIFO_RAMHT, pMcHalPowerInfo->PfifoRamHt);
                    REG_WR32(NV_PFIFO_RAMFC, pMcHalPowerInfo->PfifoRamFc);
                    REG_WR32(NV_PFIFO_RAMRO, pMcHalPowerInfo->PfifoRamRo);

                    //
                    // Make sure write protection is disabled.
                    //
                    FLD_WR_DRF_DEF(_PFB, _NVM, _MODE, _DISABLE);
					
                    //
                    // Restore tiling registers.
                    //
                    tvp = (NV10_TILE_VALUES *)&pMcHalPowerInfo->TilingValues[0];
                    for (i = 0; i < NV_PFB_TILE__SIZE_1; i++, tvp++)
                    {
                        REG_WR32(NV_PFB_TLIMIT(i),      tvp->tlimit);
                        REG_WR32(NV_PFB_TSIZE(i),       tvp->tsize);
                        REG_WR32(NV_PFB_TILE(i),        tvp->tile);

                        REG_WR32(NV_PGRAPH_TLIMIT(i),   tvp->tlimit);
                        REG_WR32(NV_PGRAPH_TSIZE(i),    tvp->tsize);
                        REG_WR32(NV_PGRAPH_TILE(i),     tvp->tile);
                    }
                    
                    //
                    // Restore fifo mode register.
                    //
                    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

                    //
                    // Set to unused channel to force context switch
                    // when fifo is accessed.
                    //
                    REG_WR32(NV_PFIFO_CACHE0_PUSH1, NUM_FIFOS_NV10-1);
                    REG_WR32(NV_PFIFO_CACHE1_PUSH1, NUM_FIFOS_NV10-1);

                    //
                    // Turn up clock.
                    //
                    FLD_WR_DRF_DEF(_PRAMDAC, _PLL_SETUP_CONTROL, _PWRDWN, _ON);

                    //
                    // restore CRTC config for each head (may include endian-ness)
                    //
                    for (i=0; i < pDacHalInfo->NumCrtcs; i++)
                    {
                        REG_WR32(NV_PCRTC_CONFIG + pDacHalInfo->CrtcInfo[i].RegOffset, 
                                 pMcHalPowerInfo->SaveCrtcConfig[i]);
                    }                 

                    //REG_WR32(NV_PVIDEO_STOP,pMcHalPowerInfo->PvideoStop);
                    REG_WR32(NV_PVIDEO_BASE(0),pMcHalPowerInfo->PvideoBase0);
                    REG_WR32(NV_PVIDEO_BASE(1),pMcHalPowerInfo->PvideoBase1);
                    REG_WR32(NV_PVIDEO_LIMIT(0),pMcHalPowerInfo->PvideoLimit0);
                    REG_WR32(NV_PVIDEO_LIMIT(1),pMcHalPowerInfo->PvideoLimit1);
                    REG_WR32(NV_PVIDEO_LUMINANCE(0),pMcHalPowerInfo->PvideoLuminance0);
                    REG_WR32(NV_PVIDEO_LUMINANCE(1),pMcHalPowerInfo->PvideoLuminance1);
                    REG_WR32(NV_PVIDEO_CHROMINANCE(0),pMcHalPowerInfo->PvideoChrominance0);
                    REG_WR32(NV_PVIDEO_CHROMINANCE(1),pMcHalPowerInfo->PvideoChrominance1);
                    REG_WR32(NV_PVIDEO_OFFSET(0),pMcHalPowerInfo->PvideoOffset0);
                    REG_WR32(NV_PVIDEO_OFFSET(1),pMcHalPowerInfo->PvideoOffset1);
                    REG_WR32(NV_PVIDEO_SIZE_IN(0),pMcHalPowerInfo->PvideoSizeIn0);
                    REG_WR32(NV_PVIDEO_SIZE_IN(1),pMcHalPowerInfo->PvideoSizeIn1);
                    REG_WR32(NV_PVIDEO_POINT_IN(0),pMcHalPowerInfo->PvideoPointIn0);
                    REG_WR32(NV_PVIDEO_POINT_IN(1),pMcHalPowerInfo->PvideoPointIn1);
                    REG_WR32(NV_PVIDEO_DS_DX(0),pMcHalPowerInfo->PvideoDsDx0);
                    REG_WR32(NV_PVIDEO_DS_DX(1),pMcHalPowerInfo->PvideoDsDx1);
                    REG_WR32(NV_PVIDEO_DT_DY(0),pMcHalPowerInfo->PvideoDtDy0);
                    REG_WR32(NV_PVIDEO_DT_DY(1),pMcHalPowerInfo->PvideoDtDy1);
                    REG_WR32(NV_PVIDEO_POINT_OUT(0),pMcHalPowerInfo->PvideoPointOut0);
                    REG_WR32(NV_PVIDEO_POINT_OUT(1),pMcHalPowerInfo->PvideoPointOut1);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(0),pMcHalPowerInfo->PvideoSizeOut0);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(1),pMcHalPowerInfo->PvideoSizeOut1);
                    REG_WR32(NV_PVIDEO_FORMAT(0),pMcHalPowerInfo->PvideoFormat0);
                    REG_WR32(NV_PVIDEO_FORMAT(1),pMcHalPowerInfo->PvideoFormat1);
                    REG_WR32(NV_PVIDEO_COLOR_KEY,pMcHalPowerInfo->PvideoColorKey);
                    REG_WR32(NV_PVIDEO_INTR_EN,pMcHalPowerInfo->PvideoIntrEn);

                    //
                    // Restore SetOffsetRange registers.
                    //
                    REG_WR32(NV_PCRTC_RASTER_START, pMcHalPowerInfo->PcrtcRasterStart);
                    REG_WR32(NV_PCRTC_RASTER_STOP, pMcHalPowerInfo->PcrtcRasterStop);
                }
            }
            break;
        case MC_POWER_LEVEL_1:
            //
            // Turn down clock.
            //
            FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _VPLL);
            break;
        case MC_POWER_LEVEL_2:
            //
            // This section is for mobile only!
            //
            // We don't expose the MobileOperation switch to the HAL
            // at the moment, so we rely on the RM to never use this
            // state (MC_POWER_LEVEL_2) except when MobileOperation
            // is defined.
            //
            // Refer to mcstate.c for the MobileOperation check.
            //
            FLD_WR_DRF_DEF(_PFB, _SELF_REF, _CMD, _ENABLED);
            break;
        case MC_POWER_LEVEL_4:
            pMcHalPowerInfo->PfbTiming2 = REG_RD32(NV_PFB_TIMING2);     // refresh
            FLD_WR_DRF_NUM(_PFB, _TIMING2, _REFRESH, 0xFFFFFFFF);       // max refresh
            // Chip has been init'd with the BIOS init tables, unless the BIOS
            // has an incompatible structure and the table was not found, in which case
            // we used a default table, which may not have the correct RAM config, so
            // we save away the current config for restoration above.
            pMcHalPowerInfo->PfbBoot0 = REG_RD32(NV_PFB_CFG);
            pMcHalPowerInfo->PfbConfig0 = REG_RD32(NV_PFB_CSTATUS);
            pMcHalPowerInfo->PfbConfig1 = REG_RD32(NV_PFB_REFCTRL);
            pMcHalPowerInfo->PfbMrs = REG_RD32(NV_PFB_MRS);
            pMcHalPowerInfo->PfbEmrs = REG_RD32(NV_PFB_EMRS);
            pMcHalPowerInfo->PfbRef     = REG_RD32(NV_PFB_REF);
            // RAM config - FBI differential
            pMcHalPowerInfo->PbusDebug1 = REG_RD32(NV_PBUS_DEBUG_1);
            // CRTC config (may include endian-ness)
            for (i=0; i< pDacHalInfo->NumCrtcs; i++)
            {
                pMcHalPowerInfo->SaveCrtcConfig[i] = REG_RD32(NV_PCRTC_CONFIG + pDacHalInfo->CrtcInfo[i].RegOffset); 
            }

            //
            // Turn down clock.
            //
            //FLD_WR_DRF_DEF(_PRAMDAC, _PLL_SETUP_CONTROL, _PWRDWN, _VPLL);
            break;
        case MC_POWER_LEVEL_3:
        {
            NV10_TILE_VALUES *tvp;
            


            //
            // Save tiling value.
            //
            tvp = (NV10_TILE_VALUES *)&pMcHalPowerInfo->TilingValues[0];
            for (i = 0; i < NV_PFB_TILE__SIZE_1; i++, tvp++)
            {
                tvp->tlimit = REG_RD32(NV_PFB_TLIMIT(i));
                tvp->tsize  = REG_RD32(NV_PFB_TSIZE(i));
                tvp->tile   = REG_RD32(NV_PFB_TILE(i));
            }

            //
            // Save SetOffsetRange regs.
            //
            pMcHalPowerInfo->PcrtcRasterStart = REG_RD32(NV_PCRTC_RASTER_START);
            pMcHalPowerInfo->PcrtcRasterStop = REG_RD32(NV_PCRTC_RASTER_STOP);
            
            //save interrupt allowance state for later restoration
            pMcHalPowerInfo->PvideoIntrEn=REG_RD32(NV_PVIDEO_INTR_EN);
                        
            //save stateful video registers
			//pMcHalPowerInfo->PvideoBuffer=REG_RD32(NV_PVIDEO_BUFFER);
			//stop is buffer return control, do not modify on restart
			//pMcHalPowerInfo->PvideoStop=REG_RD32(NV_PVIDEO_STOP);
			pMcHalPowerInfo->PvideoBase0=REG_RD32(NV_PVIDEO_BASE(0));
			pMcHalPowerInfo->PvideoBase1=REG_RD32(NV_PVIDEO_BASE(1));
			pMcHalPowerInfo->PvideoLimit0=REG_RD32(NV_PVIDEO_LIMIT(0));
			pMcHalPowerInfo->PvideoLimit1=REG_RD32(NV_PVIDEO_LIMIT(1));
			pMcHalPowerInfo->PvideoLuminance0=REG_RD32(NV_PVIDEO_LUMINANCE(0));
			pMcHalPowerInfo->PvideoLuminance1=REG_RD32(NV_PVIDEO_LUMINANCE(1));
			pMcHalPowerInfo->PvideoChrominance0=REG_RD32(NV_PVIDEO_CHROMINANCE(0));
			pMcHalPowerInfo->PvideoChrominance1=REG_RD32(NV_PVIDEO_CHROMINANCE(1));
			pMcHalPowerInfo->PvideoOffset0=REG_RD32(NV_PVIDEO_OFFSET(0));
			pMcHalPowerInfo->PvideoOffset1=REG_RD32(NV_PVIDEO_OFFSET(1));
			pMcHalPowerInfo->PvideoSizeIn0=REG_RD32(NV_PVIDEO_SIZE_IN(0));
			pMcHalPowerInfo->PvideoSizeIn1=REG_RD32(NV_PVIDEO_SIZE_IN(1));
			pMcHalPowerInfo->PvideoPointIn0=REG_RD32(NV_PVIDEO_POINT_IN(0));
			pMcHalPowerInfo->PvideoPointIn1=REG_RD32(NV_PVIDEO_POINT_IN(1));
			pMcHalPowerInfo->PvideoDsDx0=REG_RD32(NV_PVIDEO_DS_DX(0));
			pMcHalPowerInfo->PvideoDsDx1=REG_RD32(NV_PVIDEO_DS_DX(1));
			pMcHalPowerInfo->PvideoDtDy0=REG_RD32(NV_PVIDEO_DT_DY(0));
			pMcHalPowerInfo->PvideoDtDy1=REG_RD32(NV_PVIDEO_DT_DY(1));
			pMcHalPowerInfo->PvideoPointOut0=REG_RD32(NV_PVIDEO_POINT_OUT(0));
			pMcHalPowerInfo->PvideoPointOut1=REG_RD32(NV_PVIDEO_POINT_OUT(1));
			pMcHalPowerInfo->PvideoSizeOut0=REG_RD32(NV_PVIDEO_SIZE_OUT(0));
			pMcHalPowerInfo->PvideoSizeOut1=REG_RD32(NV_PVIDEO_SIZE_OUT(1));
			pMcHalPowerInfo->PvideoFormat0=REG_RD32(NV_PVIDEO_FORMAT(0));
			pMcHalPowerInfo->PvideoFormat1=REG_RD32(NV_PVIDEO_FORMAT(1));
			pMcHalPowerInfo->PvideoColorKey=REG_RD32(NV_PVIDEO_COLOR_KEY);
			
            pMcHalPowerInfo->PfbTiming2 = REG_RD32(NV_PFB_TIMING2);     // refresh
            FLD_WR_DRF_NUM(_PFB, _TIMING2, _REFRESH, 0xFFFFFFFF);       // max refresh
            // Chip has been init'd with the BIOS init tables, unless the BIOS
            // has an incompatible structure and the table was not found, in which case
            // we used a default table, which may not have the correct RAM config, so
            // we save away the current config for restoration above.
            pMcHalPowerInfo->PfbBoot0 = REG_RD32(NV_PFB_CFG);
            pMcHalPowerInfo->PfbConfig0 = REG_RD32(NV_PFB_CSTATUS);
            pMcHalPowerInfo->PfbConfig1 = REG_RD32(NV_PFB_REFCTRL);
            pMcHalPowerInfo->PfbMrs = REG_RD32(NV_PFB_MRS);
            pMcHalPowerInfo->PfbEmrs = REG_RD32(NV_PFB_EMRS);
            pMcHalPowerInfo->PfbRef     = REG_RD32(NV_PFB_REF);
            pMcHalPowerInfo->PfifoRamHt = REG_RD32(NV_PFIFO_RAMHT);
            pMcHalPowerInfo->PfifoRamFc = REG_RD32(NV_PFIFO_RAMFC);
            pMcHalPowerInfo->PfifoRamRo = REG_RD32(NV_PFIFO_RAMRO);
            // RAM config - FBI differential
            pMcHalPowerInfo->PbusDebug1 = REG_RD32(NV_PBUS_DEBUG_1);

            // CRTC config (may include endian-ness)
            for (i=0; i< pDacHalInfo->NumCrtcs; i++)
            {
                pMcHalPowerInfo->SaveCrtcConfig[i] = REG_RD32(NV_PCRTC_CONFIG + pDacHalInfo->CrtcInfo[i].RegOffset); 
            }

/*
When going into hibernation, the NT miniport makes a power state transition from state 0 to state 3.  State 3
implies that ALL clocks have been put in a power-down state, i.e. lowered.  Unfortunately, NT also requires 
the ability to perform VGA accesses *AFTER* the power management call.  Putting PClk into a power-down state 
disables VGA accesses, so for the time being, for NT, we cannot allow PClk to be put into a power-down state.
NOTE:  This is a liability if the system does not truly remove power from the device during hibernation.  In
this case, PClk will still be drawing full current, which could lead to power saving specs' being violated or,
more importantly, reliability problems with the device.
*/
#ifndef NTRM
            //
            // Turn down clock.
            //
            FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _VPLL);
#endif
            break;
        }
        default:
            return RM_ERR_BAD_ARGUMENT;
    }

    return RM_OK;
}

BOOL IsNV10_NV10(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV10));
}

BOOL IsNV10MaskRevA02orBetter_NV10(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    // Is this NV10 A02 or better.  Note that "better" also includes all 
    // NV1X parts above NV10.
    return ((pMcHalInfo->MaskRevision >= MC_MASK_REVISION_A2) ||
            (pMcHalInfo->Implementation > MC_IMPLEMENTATION_NV10));
}

BOOL IsNV10MaskRevA03orBetter_NV10(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    // Is this NV10 A03 or better.  Note that "better" also includes all 
    // NV1X parts above NV10.
    return ((pMcHalInfo->MaskRevision >= MC_MASK_REVISION_A3) ||
            (pMcHalInfo->Implementation > MC_IMPLEMENTATION_NV10));
}

BOOL IsNV15_NV10(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    // Is this NV15?
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV15));
}

BOOL IsNV10orBetter_NV10(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    // Is this NV10 or better?
    return ((pMcHalInfo->Architecture >= MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation >= MC_IMPLEMENTATION_NV10));
}

BOOL IsNV15orBetter_NV10(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    // Is this NV15 or better?
    return ((pMcHalInfo->Architecture >= MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation >= MC_IMPLEMENTATION_NV11));
}

BOOL IsNV11orBetter_NV10(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    // Is this NV11 or better?
    return (((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
             (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV11)) ||
             (pMcHalInfo->Architecture >= MC_ARCHITECTURE_NV20));
}

BOOL IsNV11_NV10(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    // Is this NV11?
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV11));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mc\nv\mcstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* MC Manager ********************************\
*                                                                           *
* Module: MCSTATE.C                                                         *
*   The Master Control state is changed in this module.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <mc.h>
#include <os.h>
#include "nvhw.h"
#include "nvcm.h"
#include <bios.h>   //For hotkey defs.  Can remove once those are put in nv_ref.h

// Registry access
extern char strDevNodeRM[];
extern VOID dbgDumpMTRRs(VOID);

//
// Change Master Control hardware state.
//
RM_STATUS stateMc
(
    PHWINFO pDev, // handle to an nv device
    U032 msg
)
{
    RM_STATUS status;
    U032      data,temp;
    
    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:
            //
            // Enable all devices and interrupts.
            //
            // We must toggle the AGP COMMAND register to make sure that if we went thru a power standby,
            // AGP will be reset and send all command packets, not just those it thinks are not cached.
            // We only need to transition the SBA/AGP enable bits to reset NV for this case.
            //
            status = RM_OK;
            data = REG_RD32(NV_PBUS_PCI_NV_19);     // read AGP COMMAND
            REG_WR32(NV_PBUS_PCI_NV_19,
                     (data & ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON) |
                               DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE, _ON))));
            temp = REG_RD32(NV_PRAMIN_DATA032(0));  // read inst mem to delay
            REG_WR32(NV_PBUS_PCI_NV_19, data);      // restore

            REG_WR32(NV_PMC_ENABLE, 0xFFFFFFFF);    // enable all engines
            REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);    // setup in mcinit

#ifdef DEBUG
            // At times, it may be useful to verify the processors MTRRs
            dbgDumpMTRRs();
#endif
            if (status != RM_OK)
            {
                return (status);
            }

            break;
        case STATE_UNLOAD:
            //
            // Clear interrupts.
            //
            REG_WR32(NV_PMC_INTR_EN_0, 0x00000000);
            break;
        case STATE_INIT:
            //
            // We must determine if there is any customer-specific code
            // we need to enable for this device.  Start the customer
            // coding at generic (reference drivers), and then override
            // it with information from the registry  
            //
            pDev->Video.HalInfo.CustomizationCode = CUSTOMER_GENERIC;
            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "CustomizationCode", &data) == RM_OK)
                pDev->Video.HalInfo.CustomizationCode = data;

            //
            // Make sure we can find NV before partying on it.
            //
            status = initMapping(pDev);
            if (status)
                return (status);

            //
            // One time initialization.
            //
            status = initMc(pDev);
            if (status)
                return (status);
            break;
        case STATE_DESTROY:
            nvHalMcControl(pDev, MC_CONTROL_DESTROY);
            break;
    }    
    return (RM_OK);
}

RM_STATUS initMc
(
    PHWINFO pDev
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    U032 data;
    U008 lock;

    //
    // Call into HAL to chip-specific initialization.
    //
    nvHalMcControl(pDev, MC_CONTROL_INIT);

    //
    // Enable the interrupt mapping within the chip
    //
    switch(pDev->Mapping.IntPin)
    {
        case 0x01:
        case 0x0A:
            pDev->Chip.IntrEn0 = DRF_DEF(_PMC, _INTR_EN_0, _INTA, _HARDWARE);
            break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Bad initialization table!");
            DBG_BREAKPOINT();
            return(RM_ERROR);
    }

    //
    // Determine the current bus
    //
#ifdef IKOS
    //For IKOS just set bus type to PCI.
    pDev->Chip.Bus = BUS_PCI;
#else

    //
    // Instead of reading the strap, walk the PCI config space.  See if there is an AGP cap
    // after the power mgmt cap.
    //
    if (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) == NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)
        pDev->Chip.Bus = BUS_AGP;
    else 
        pDev->Chip.Bus = BUS_PCI;
#endif // IKOS

    //
    // Set our flag indicating if AGP fast-writes are enabled for both NV10
    // and the chipset ... only A03 silicon or better has working FW support.
    //
    pRmInfo->AGP.AGPFWEnable = (IsNV10MaskRevA03orBetter(pDev) &&
                                REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE));

    //
    // Set our flag indicating if AGP fast-writes are at full speed or half speed.
    // Unfortunately, NV15 needs to run in NV10 crippled mode due to a compatibility
    // issue with Camino (and, unfortunately, it's not a selectable NV15 setting).
    // For NV11, if PBUS_DEBUG_1_AGPFW_ADIS is set, then we're not using NV10 compat
    // and do have fullspeed fastwrites (currently only settable through the registry.
    //
    pRmInfo->AGP.AGPFullSpeedFW = (pRmInfo->AGP.AGPFWEnable &&
                                   IsNV11orBetter(pDev) && 
                                   REG_RD_DRF(_PBUS, _DEBUG_1, _AGPFW_ADIS));

    //
    // Set the PCI Device ID's
    //
    pDev->Chip.HalInfo.PCIDeviceID = REG_RD32(NV_PBUS_PCI_NV_0);
    pDev->Chip.HalInfo.PCISubDeviceID = REG_RD32(NV_PBUS_PCI_NV_11);

    //
    // Determine what graphics capabilities we have.
    //
    // For future chips, we default to basic capabilities which is safest and most
    // reasonable in the compatibility versions of the drivers. For the performance
    // drivers that ship with the chip, we'll add the correct detection in that version.
    //
    if (IsNV10(pDev)) {
        //
        // NV10 relies on the PCI ID to match GL functionality
        //
        if ((pDev->Chip.HalInfo.PCIDeviceID >> 16) == 0x103)
            pDev->Graphics.Capabilities = (  NV_CFG_GRAPHICS_CAPS_AKILL_USERCLIP    // fast user clip planes
                                             | NV_CFG_GRAPHICS_CAPS_AA_LINES        // AA lines
                                             | NV_CFG_GRAPHICS_CAPS_AA_POLYS        // AA polys
                                             | NV_CFG_GRAPHICS_CAPS_2SIDED_LIGHTING // two-sided lighting
                                             | NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC  // anything not yet covered
                                             | 0x8);                                // max clips = 8
        else 
            pDev->Graphics.Capabilities = 0x1;                              // no AA lines/polys, max clips = 1

    } else if (IsNV15(pDev)) {
        //
        // NV15 relies on the PCI ID to match GL functionality
        //
        if ((pDev->Chip.HalInfo.PCIDeviceID >> 16) == 0x153)
            pDev->Graphics.Capabilities = ( NV_CFG_GRAPHICS_CAPS_LOGIC_OPS          // logic ops
                                             | NV_CFG_GRAPHICS_CAPS_AKILL_USERCLIP  // fast user clip planes
                                             | NV_CFG_GRAPHICS_CAPS_AA_LINES        // AA lines
                                             | NV_CFG_GRAPHICS_CAPS_AA_POLYS        // AA polys
                                             | NV_CFG_GRAPHICS_CAPS_2SIDED_LIGHTING // two-sided lighting
                                             | NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC  // anything not yet covered
                                             | 0x8);                                // max clips = 8
        else 
            pDev->Graphics.Capabilities = 0x1;                              // no AA lines/polys, max clips = 1

        // needs NV15 aliased line fix
        if (IsNV15MaskRevA03(pDev) ||
            IsNV15MaskRevA02(pDev)) {
            pDev->Graphics.Capabilities |=   NV_CFG_GRAPHICS_CAPS_NV15_ALINES;      // aliased line fix
        }
    } else if (IsNV11(pDev)) {
        //
        // NV11 relies on the PCI ID to match GL functionality
        // (note: no AA_LINES or AA_POLYS for the NV11 GL part)
        //
        if ((pDev->Chip.HalInfo.PCIDeviceID >> 16) == 0x113)
            pDev->Graphics.Capabilities = ( NV_CFG_GRAPHICS_CAPS_LOGIC_OPS          // logic ops
                                             | NV_CFG_GRAPHICS_CAPS_AKILL_USERCLIP  // fast user clip planes
                                             | NV_CFG_GRAPHICS_CAPS_2SIDED_LIGHTING // two-sided lighting
                                             | NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC  // anything not yet covered
                                             | 0x8);                                // max clips = 8
        else 
            pDev->Graphics.Capabilities = 0x1;                              // no AA lines/polys, max clips = 1

    } else {
        // all future (and pre-NV10) chips land here
        pDev->Graphics.Capabilities = 0x1;                                  // no AA lines/polys, max clips = 1
    }

    //
    // Set the BIOS revision and check the RM DWORD for driver compatibility
    //
    if (mcSetBiosRevision(pDev) != RM_OK)
        return (RM_ERROR);

    //
    // Temporary workaround to disable twinview functionality via a registry key
    //
    // Note the original count was determined down in the HAL routine
    //
    // AS SOON AS THE BIOS->RESMAN DISPLAY TABLE IS IN PLACE, REMOVE THIS OVERRIDE
    //
    if (IsNV11(pDev))
        if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "TwinViewDisabled", &data) == RM_OK)
            pDev->Dac.HalInfo.NumCrtcs = 1;


    //
    // Determine if we're running this device in a mobile environment.  This
    // will enable various power saving and device functionality that is not
    // available with desktop devices.
    //
    {
        pDev->Power.MobileOperation = 0;
        pDev->Power.IdleNVCLK = 100000000;
        pDev->Power.PostNVCLK = 0;
        pDev->Power.IdleMCLK = 100000000;
        pDev->Power.PostMCLK = 0;

        //Read the BIOS bit that indicates whether this is a laptop or not.
        lock = ReadCRTCLock(pDev, 0);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 0);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 0); // Restore lock state

        if (IsNV11(pDev) && (data & NV_IS_MOBILE_BIOS))
            pDev->Power.MobileOperation = 1;

        //
        // Just in case, check the registry for an override enable
        //
        if (IsNV11(pDev))
            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "Mobile", &data) == RM_OK)
                pDev->Power.MobileOperation = data;

        //
        // Check for a registry override for the Idle NVClock setting
        //
        if (IsNV11(pDev))
            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "IDLENVCLOCK", &data) == RM_OK)
                pDev->Power.IdleNVCLK = data;

        //
        // Check for a registry override for the Idle MClock setting
        //
        if (IsNV11(pDev))
            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "IDLEMCLOCK", &data) == RM_OK)
                pDev->Power.IdleMCLK = data;

        // 
        // Just in case this is not a real mobile BIOS, make sure hw power 
        // features are enabled
        //
        //if (pDev->Power.MobileOperation)
        //{
        //  FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, 3);
        //  FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _PCIM_THROTTLE, _ENABLED);
        //}
    }

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mc\nv\mc.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* MC Manager ********************************\
*                                                                           *
* Module: MC.C                                                              *
*   All global exceptions are dispatched through this module.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <fb.h>
#include <gr.h>
#include <tmr.h>
#include <mc.h>
#include <os.h>
#include <devinit.h>
#include "nvhw.h"
#include "nvver.h"

//---------------------------------------------------------------------------
//
//  Create/Delete chip id object.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Chip specific object method.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Resource Manager exception service handlers entrypoint.
//
//---------------------------------------------------------------------------

VOID mcService
(
    PHWINFO pDev  // pointer to an nv device
)
{
    V032 pending;
    V032 pmc;
#ifdef RM_STATS
    U032 EnterTimeLo;
    U032 EnterTimeHi;
    U032 ExitTimeLo;
    U032 ExitTimeHi;
    U032 ServiceTimeLo;
    U032 ServiceTimeHi;
#endif
    U032 SemaState;
    
    //
    // This is an entrypoint routine.  Aquire semaphore.
    //
    osWaitSemaphore(&SemaState);
#ifdef RM_STATS
    pDev->Chip.ServiceCount++;
    tmrGetCurrentTime(&EnterTimeHi, &EnterTimeLo);
#endif
    osEnterCriticalCode(pDev);
    do
    {
        //
        // Process all exceptions as required
        //
        pending = 0;
        pmc     = REG_RD32(NV_PMC_INTR_0);
        
        if (pmc & DRF_DEF(_PMC, _INTR_0, _PTIMER, _PENDING))
        {
#ifdef RM_STATS
            pDev->Timer.ServiceCount++;
#endif
            pending |= tmrService(pDev);
        }
        
        if (pmc & (DRF_DEF(_PMC, _INTR_0, _PCRTC,    _PENDING) |
                   DRF_DEF(_PMC, _INTR_0, _PCRTC2,    _PENDING)))
        {
#ifdef RM_STATS
            pDev->Dac.ServiceCount++;
#endif
            pending |= dacService(pDev);
        }
        
        if (pmc & DRF_DEF(_PMC, _INTR_0, _PGRAPH, _PENDING))
        {
#ifdef RM_STATS
            pDev->Graphics.ServiceCount++;
#endif
            pending |= grService(pDev);
        }
        
        if (pmc & DRF_DEF(_PMC, _INTR_0, _PMEDIA, _PENDING))
        {
#ifdef RM_STATS
            pDev->MediaPort.ServiceCount++;
#endif
            pending |= mpService(pDev); 
        }
        
        if ((pmc & DRF_DEF(_PMC, _INTR_0, _PFIFO, _PENDING))
         || (REG_RD_DRF(_PFIFO, _DEBUG_0, _CACHE_ERROR0) == NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING))
        {
#ifdef RM_STATS
            pDev->Fifo.ServiceCount++;
#endif
            pending |= fifoService(pDev);
        }
        
        if (pmc & DRF_DEF(_PMC, _INTR_0, _PVIDEO, _PENDING))
        {
#ifdef RM_STATS
            pDev->Video.ServiceCount++;
#endif
            pending |= videoService(pDev); 
        }
    }
    while (pending);
    osExitCriticalCode(pDev);

#ifdef RM_STATS
    //
    // Add time spent in service routines to accumulated time.
    //
    tmrGetCurrentTime(&ExitTimeHi, &ExitTimeLo);
    ServiceTimeLo = ExitTimeLo - EnterTimeLo;
    ServiceTimeHi = ExitTimeHi - EnterTimeHi;
    if (ServiceTimeLo > ExitTimeLo)
        ServiceTimeHi--;
    pDev->Chip.ServiceTimeLo += ServiceTimeLo;
    if (pDev->Chip.ServiceTimeLo < ServiceTimeLo)
        ServiceTimeHi++;
    pDev->Chip.ServiceTimeHi += ServiceTimeHi;    
#endif
    //
    // This is an entrypoint routine.  Release semaphore.
    //
    osSignalSemaphore(&SemaState);
}

#define BIOS_RM_DWORD_REV       0x02050100

//
// Determine the current BIOS revision.
//
// If we've got a BIOS that is later than rev 2.05.01, we'll also check the dword
// that's been added to the BIOS header which indicates the minimum driver revision
// required for this HW.
//
// This allows us to add support for future chips before they've been completely
// validated. If a previously shipped driver turns out to not be able to safely
// boot the HW, we'll change the BIOS dword to require a later driver to boot.
//
RM_STATUS
mcSetBiosRevision
(
    PHWINFO pDev
)
{
#ifndef IKOS
    U032 offset;
    BMP_Control_Block bmpCtrlBlk;
    U016 minDrvRev;
    RM_STATUS rmStatus;
#endif

#ifndef IKOS
    rmStatus = DevinitGetBMPControlBlock(pDev,
                                         &bmpCtrlBlk,
                                         &offset);
    if (rmStatus == RM_OK)
    {
        // set the BiosRevision and BiosRMDword (if it's available)
        switch (bmpCtrlBlk.CTL_Version)
        {
            case BMP_INIT_TABLE_VER_1:
            {
                BMP_Struc_Rev1 BmpStrucRev1;
                BiosReadStructure(pDev,
                                  (U008 *) &BmpStrucRev1,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT1_FMT);
                pDev->Chip.BiosRevision       = BmpStrucRev1.BIOS_Version;
                pDev->Chip.BiosOEMRevision    = 0;
                pDev->Chip.BiosRMDword        = 0x0;      // not supported
                break;
            }

            case BMP_INIT_TABLE_VER_2:
            case BMP_INIT_TABLE_VER_3:
            case BMP_INIT_TABLE_VER_4:
            {
                BMP_Struc_Rev2 BmpStrucRev2;
                BiosReadStructure(pDev,
                                  (U008 *) &BmpStrucRev2,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT2_FMT);
                pDev->Chip.BiosRevision       = BmpStrucRev2.BIOS_Version;
                pDev->Chip.BiosOEMRevision    = 0;
                pDev->Chip.BiosRMDword        = BmpStrucRev2.BIOS_DriverInfo;
                break;
            }

            // default is BMP init table version 5 base-level functionality
            default:
            {
                BMP_Struc_Rev5 BmpStrucRev5;
                BiosReadStructure(pDev,
                                  (U008 *) &BmpStrucRev5,
                                  offset,
                                  (U032 *) 0,
                                  BMP_INIT5_FMT);

                pDev->Chip.BiosRevision       = BmpStrucRev5.BIOS_Version;
                pDev->Chip.BiosOEMRevision    = BmpStrucRev5.BMP_OEMRevision;
                pDev->Chip.BiosRMDword        = BmpStrucRev5.BIOS_DriverInfo;
                break;
            }
        }
    
        minDrvRev = (U016)(pDev->Chip.BiosRMDword & 0xFFFF);
                    
        // Check if we're loading a driver that is at the required rev or higher
        if (minDrvRev > NV_DRIVER_VERSION_NUMBER)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Later driver revision required!\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "          HW expects a revision >= ", minDrvRev);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "          RM driver version is ", NV_DRIVER_VERSION_NUMBER);
            return RM_ERROR;
        }
    
        return RM_OK;
    }
    else
#endif
    {
        U032 i = 0, found = 0;

        //
        // We have ourselves on old BIOS.     
        //
        // This is nasty, but we need to scan for the POST string
        //   I'm not sure this will work on the MAC, but it shouldn't matter.
        //
        while (!found && (i < 0x100))
        {
            if (REG_RD08(pDev->Pram.HalInfo.PraminOffset+i) == 'O')
                if (REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+1) == 'S')
                    if (REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+2) == ' ')
                        if (REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+3) == 'V')
                        {
                            pDev->Chip.BiosRevision =
                                ((REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+4) - '0') << 24)
                              | ((REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+6) - '0') << 20)
                              | ((REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+7) - '0') << 16);
                             
                            if (REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+8) != '.')
                                pDev->Chip.BiosRevision |= (REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+8) - 'A') & 0xFF;
                            else
                            {
                                pDev->Chip.BiosRevision |=
                                    ((REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+9) - '0') << 4)
                                  | ((REG_RD08(pDev->Pram.HalInfo.PraminOffset+i+10) - '0'));
                            }
                        found = 1;
                        }                            
                            
            i++;  
        }                                  
        pDev->Chip.BiosOEMRevision = 0;
        return RM_OK;
    }
}


//
// A possible power state change is triggered by a variety of sources through
// the resman.  This routine will check the current state of the system and
// determine if a power-related change is required.
//
// All algorithms are localized in this routine as opposed to being sprinkled
// throughout the rest of the code.
//
RM_STATUS mcPowerStateTrigger
(
    PHWINFO pDev
)
{

    //
    // Perform mobile-specific power management
    //

    if (pDev->Power.PostNVCLK == 0)
        pDev->Power.PostNVCLK = pDev->Dac.HalInfo.NVClk;
    if (pDev->Power.PostMCLK == 0)
        pDev->Power.PostMCLK = pDev->Dac.HalInfo.MClk;

    if (pDev->Power.MobileOperation)
    {
        //
        // If there are currently any celsius (3D) objects allocated in this device
        // keep the clocks high; otherwise drop them down to 125.
        //
        // Note that an idle setting of 0 equates to a feature disable
        //
        if (pDev->Graphics.HalInfo.has3dObject)
        {
            if ((pDev->Dac.HalInfo.NVClk != pDev->Power.PostNVCLK) && (pDev->Power.IdleNVCLK))
            {
                pDev->Dac.HalInfo.NVClk = pDev->Power.PostNVCLK;
                dacProgramNVClk(pDev);
            }
            //if ((pDev->Dac.HalInfo.MClk != pDev->Power.PostMCLK) && (pDev->Power.IdleMCLK))
            //{
            //    pDev->Dac.HalInfo.MClk = pDev->Power.PostMCLK;
            //    dacProgramMClk(pDev);
            //}

        }
        else
        {
            if ((pDev->Dac.HalInfo.NVClk != pDev->Power.IdleNVCLK) && (pDev->Power.IdleNVCLK))
            {
                pDev->Dac.HalInfo.NVClk = pDev->Power.IdleNVCLK;
                dacProgramNVClk(pDev);
            }
            //if ((pDev->Dac.HalInfo.MClk != pDev->Power.IdleMCLK) && (pDev->Power.IdleMCLK))
            //{
            //    pDev->Dac.HalInfo.MClk = pDev->Power.IdleMCLK;
            //    dacProgramMClk(pDev);
            //}

        }
        
    }   
    return RM_OK;
}


//---------------------------------------------------------------------------
//
//  Chip ID functions.
//
//---------------------------------------------------------------------------


//-------------------------------------------------------------------
// NV4 and family
//-------------------------------------------------------------------
BOOL IsNV4(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV04) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV04));
}

BOOL IsNV5(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV04) &&
            (pMcHalInfo->Implementation >= MC_IMPLEMENTATION_NV05));
}

BOOL IsNV0A(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV04) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV0A));
}

BOOL IsNV5orBetter(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return ((pMcHalInfo->Architecture > MC_ARCHITECTURE_NV04) ||
            ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV04) &&
             (pMcHalInfo->Implementation >= MC_IMPLEMENTATION_NV05)));
}

//-------------------------------------------------------------------
// NV10 and family.
//-------------------------------------------------------------------
BOOL IsNV10(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV10));
}

BOOL IsNV10MaskRevA02orBetter(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    // Is this NV10 A02 or better.  Note that "better" also includes all 
    // NV1X parts above NV10.
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            ((pMcHalInfo->MaskRevision >= MC_MASK_REVISION_A2) ||
             (pMcHalInfo->Implementation > MC_IMPLEMENTATION_NV10)));
}

BOOL IsNV10MaskRevA03orBetter(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    // Is this NV10 A03 or better.  Note that "better" also includes all 
    // NV1X parts above NV10.
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (((pMcHalInfo->MaskRevision >= MC_MASK_REVISION_A3) &&
             (pMcHalInfo->MaskRevision != MC_MASK_REVISION_A6)) ||
             (pMcHalInfo->Implementation > MC_IMPLEMENTATION_NV10)));
}

BOOL IsNV11(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    // Is this NV11?
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV11));
}

BOOL IsNV15(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV15));
}

BOOL IsNV20(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV20) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV20));
}

BOOL IsNV10orBetter(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return ((pMcHalInfo->Architecture >= MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation >= MC_IMPLEMENTATION_NV10));
}

BOOL IsNV15orBetter(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return ((pMcHalInfo->Architecture >= MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation >= MC_IMPLEMENTATION_NV11));
}

BOOL IsNV15MaskRevA01(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    // Is this NV15 Mask Revision A01?
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV15) &&
            (pMcHalInfo->MaskRevision == MC_MASK_REVISION_A1));
}

BOOL IsNV15MaskRevA02(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    // Is this NV15 Mask Revision A02?
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV15) &&
            (pMcHalInfo->MaskRevision == MC_MASK_REVISION_A2));
}

BOOL IsNV15MaskRevA03(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    // Is this NV15 Mask Revision A03?
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV15) &&
            (pMcHalInfo->MaskRevision == MC_MASK_REVISION_A3));
}

BOOL IsNV11orBetter(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    // Is this NV11 or better?
    return (((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV10) &&
             (pMcHalInfo->Implementation >= MC_IMPLEMENTATION_NV11) &&
             (pMcHalInfo->Implementation != MC_IMPLEMENTATION_NV15)) ||
             (pMcHalInfo->Architecture >= MC_ARCHITECTURE_NV20));
}

BOOL IsNV20orBetter(PHWINFO pDev)
{
    PMCHALINFO pMcHalInfo = pDev->halHwInfo.pMcHalInfo;

    // assert the architecture has been setup
    RM_ASSERT(pMcHalInfo->Architecture);

    return (pMcHalInfo->Architecture >= MC_ARCHITECTURE_NV20);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\inc\nv4\nv4_ref.h ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/***************************************************************************\
*                                                                           *
*               NV4 Hardware Reference Manual extracted defines.            *
*                                                                           *
\***************************************************************************/
#ifndef _NV4_REF_H_
#define _NV4_REF_H_

//
// These registers are to be accessed only by nv4-specific code.
//

/* dev_bus.ref */
#define NV_MSPACE                             0x07FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_RSPACE                             0x00FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY                         3:0 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_PC                            4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_PC_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_PC_OVERRIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_DELAY                       11:8 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_DELAY_4               0x00000004 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_DELAY_8               0x00000008 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_PC                         12:12 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_PC_NORMAL             0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_PC_OVERRIDE           0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_DELAY                       19:16 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_DELAY_8                0x00000008 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_DELAY_10               0x0000000A /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_PC                          20:20 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_PC_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_PC_OVERRIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_DELAY                       27:24 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_DELAY_8                0x00000008 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_DELAY_14               0x0000000E /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_PC                          28:28 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_PC_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_PC_OVERRIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1                                  0x00001084 /* RW-4R */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE                           0:0 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED            0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD                                1:1 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY                0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_HASH_DECODE                             2:2 /* RWIVF */
#define NV_PBUS_DEBUG_1_HASH_DECODE_1FF                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_HASH_DECODE_2FF                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD                                4:3 /* RWIVF */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                 0x00000002 /* RW--V */
/* NV_PBUS_DEBUG_1_PCI_WRITE is shared (see nv_ref.h) */
#define NV_PBUS_DEBUG_1_PCIS_2_1                                6:6 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY                              7:7 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE0                                  7:7 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE0_ZERO                      0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE0_ONE                       0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST                           8:8 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST                           9:9 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY                        10:10 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED          0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED           0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ                             12:12 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_DPSH_DECODE                           13:13 /* RWIVF */
#define NV_PBUS_DEBUG_1_DPSH_DECODE_NV4                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_DPSH_DECODE_NV3                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE1                                14:14 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE1_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_FBI_DIFFERENTIAL                      14:14 /* RWIVF */
#define NV_PBUS_DEBUG_1_FBI_DIFFERENTIAL_ENABLED         0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_FBI_DIFFERENTIAL_DISABLED        0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE2                                15:15 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE2_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE2_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPFW_DWOD                            15:15 /* RWIVF */
#define NV_PBUS_DEBUG_1_AGPFW_DWOD_DISABLED              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_AGPFW_DWOD_ENABLED               0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE3                                16:16 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE3_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE3_ONE                       0x00000001 /* RW--V */
/* NV_PBUS_DEBUG_1_OPENGL is shared (see nv_ref.h) */
#define NV_PBUS_DEBUG_1_SPARE4                                17:17 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE4_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE4_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE5                                18:18 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE5_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE5_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE6                                19:19 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE6_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE6_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE7                                20:20 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE7_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE7_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE8                                21:21 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE8_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE8_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE9                                22:22 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE9_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE9_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE10                               23:23 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE10_ZERO                     0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE10_ONE                      0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_2                                  0x00001088 /* RW-4R */
#define NV_PBUS_DEBUG_2_AGP_DIFFERENTIAL                        0:0 /* RWIVF */
#define NV_PBUS_DEBUG_2_AGP_DIFFERENTIAL_DISABLED        0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_DIFFERENTIAL_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_2_AGP_VREF                                0:0 /* RWIVF */
#define NV_PBUS_DEBUG_2_AGP_VREF_DISABLED                0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_VREF_ENABLED                 0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_DELAY                        9:4 /* RWIUF */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_DELAY_34              0x00000022 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_PC                         12:12 /* RWIVF */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_PC_NORMAL             0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_PC_OVERRIDE           0x00000001 /* RW0-V */
#define NV_PBUS_DEBUG_2_AGP_AD_STB                            12:12 /* RWIVF */
#define NV_PBUS_DEBUG_2_AGP_AD_STB_NONDIFFERENTIAL       0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_AD_STB_DIFFERENTIAL          0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_3                                  0x0000108C /* RW-4R */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE                            1:0 /* RWIVF */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE_UNLIMITED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE_64_BYTES            0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK                            7:4 /* RWIVF */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ         0x00000005 /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ         0x00000006 /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ         0x00000007 /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ         0x00000008 /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ         0x00000009 /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ        0x0000000A /* RWI-V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ        0x0000000B /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ        0x0000000C /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ        0x0000000D /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ        0x0000000E /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ        0x0000000F /* RW--V */
#define NV_PBUS_DEBUG_CTL                                0x00001090 /* RW-4R */
#define NV_PBUS_DEBUG_CTL_MODE                                  0:0 /* RWIVF */
#define NV_PBUS_DEBUG_CTL_MODE_DISABLED                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTL_MODE_ENABLED                   0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTL_READ_SELECT                           4:4 /* RWIVF */
#define NV_PBUS_DEBUG_CTL_READ_SELECT_0                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTL_READ_SELECT_1                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_READ                               0x00001094 /* R--4R */
#define NV_PBUS_DEBUG_READ_DATA                                31:0 /* R-XUF */
#define NV_PBUS_DEBUG_HOST                               0x0000109C /* RW-4R */
#define NV_PBUS_DEBUG_HOST_SEL                                  2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_0                              0x000010A0 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_0_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_1                              0x000010A4 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_1_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_2                              0x000010A8 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_2_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_3                              0x000010AC /* RW-4R */
#define NV_PBUS_DEBUG_SEL_3_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_CTRIM_0                            0x000010B0 /* RW-4R */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NE_DELAY                       3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NE_DELAY_8              0x00000003 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SE_DELAY                       7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SE_DELAY_8              0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NW_DELAY                      11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NW_DELAY_8              0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SW_DELAY                     15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SW_DELAY_8              0x00000005 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_M_NW_DELAY                      19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_M_NW_DELAY_8               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_M_SW_DELAY                      23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_M_SW_DELAY_8               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_U_NW_DELAY                      27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_U_NW_DELAY_8               0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_U_SW_DELAY                      31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_U_SW_DELAY_8               0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NE_TRIM                        3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NE_TRIM_8               0x00000003 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NE_TRIM_INIT            0x00000003 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SE_TRIM                        7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SE_TRIM_8               0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SE_TRIM_INIT            0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NW_TRIM                       11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NW_TRIM_8               0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NW_TRIM_INIT            0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SW_TRIM                      15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SW_TRIM_8               0x00000005 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SW_TRIM_INIT            0x00000005 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_0_M_NW_TRIM                       19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_M_NW_TRIM_8                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_M_NW_TRIM_INIT             0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_0_M_SW_TRIM                       23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_M_SW_TRIM_8                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_M_SW_TRIM_INIT             0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NC_TRIM                      27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NC_TRIM_8               0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_NC_TRIM_INIT            0x00000003 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SC_TRIM                      31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SC_TRIM_8               0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_0_NV_SC_TRIM_INIT            0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_1                            0x000010B4 /* RW-4R */
#define NV_PBUS_DEBUG_CTRIM_1_C0_DELAY                          3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_1_C0_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_C1_DELAY                          7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_1_C1_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_C2_DELAY                         11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_1_C2_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_C3_DELAY                        15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_1_C3_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_C4_DELAY                        19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_1_C4_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_C5_DELAY                        23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_1_C5_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_C6_DELAY                        27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_1_C6_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_C7_DELAY                        31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_1_C7_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_M_SHAPE                           3:0 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_1_M_SHAPE_0                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_M_SHAPE_INIT               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_1_N_SHAPE                           7:4 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_1_N_SHAPE_0                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_N_SHAPE_INIT               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_1_P_SHAPE                          11:8 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_1_P_SHAPE_0                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_P_SHAPE_INIT               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_1_SPARE0                          15:12 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_1_SPARE0_0                   0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_SPARE0_INIT                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_1_FP_SHAPE                        19:16 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_1_FP_SHAPE_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_FP_SHAPE_INIT              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_1_FPDP_SHAPE                      23:20 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_1_FPDP_SHAPE_0               0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_FPDP_SHAPE_INIT            0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_1_FPIO_SHAPE                      27:24 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_1_FPIO_SHAPE_0               0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_FPIO_SHAPE_INIT            0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_1_SPARE1                          31:28 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_1_SPARE1_0                   0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_1_SPARE1_INIT                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_2                            0x000010B8 /* RW-4R */
#define NV_PBUS_DEBUG_CTRIM_2_C0_DELAY                          3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_2_C0_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_C1_DELAY                          7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_2_C1_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_C2_DELAY                         11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_2_C2_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_C3_DELAY                        15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_2_C3_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_C4_DELAY                        19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_2_C4_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_C5_DELAY                        23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_2_C5_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_C6_DELAY                        27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_2_C6_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_C7_DELAY                        31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_2_C7_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_0_SHAPE                       3:0 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_0_SHAPE_0              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_0_SHAPE_INIT           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_1_SHAPE                       7:4 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_1_SHAPE_0              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_1_SHAPE_INIT           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_2_SHAPE                      11:8 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_2_SHAPE_0              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_2_SHAPE_INIT           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_3_SHAPE                     15:12 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_3_SHAPE_0              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_M2I_3_SHAPE_INIT           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_0_SHAPE                     19:16 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_0_SHAPE_0              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_0_SHAPE_INIT           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_1_SHAPE                     23:20 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_1_SHAPE_0              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_1_SHAPE_INIT           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_2_SHAPE                     27:24 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_2_SHAPE_0              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_2_SHAPE_INIT           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_3_SHAPE                     31:28 /* RWISF */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_3_SHAPE_0              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_2_M2O_3_SHAPE_INIT           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3                            0x000010BC /* RW-4R */
#define NV_PBUS_DEBUG_CTRIM_3_C0_DELAY                          3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_C0_DELAY_8                 0x00000003 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_C1_DELAY                          7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_C1_DELAY_8                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_C2_DELAY                         11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_C2_DELAY_8                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_C3_DELAY                        15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_C3_DELAY_8                 0x00000003 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_C4_DELAY                        19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_C4_DELAY_8                 0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_C5_DELAY                        23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_C5_DELAY_8                 0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_C6_DELAY                        27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_C6_DELAY_F                 0x0000000f /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_C7_DELAY                        31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_C7_DELAY_F                 0x0000000f /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_CCIR_CLK_OUT_TRIM                 3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_CCIR_CLK_OUT_TRIM_8        0x00000003 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_CCIR_CLK_OUT_TRIM_INIT     0x00000003 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_PCLK_TRIM                         7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_PCLK_TRIM_8                0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_PCLK_TRIM_INIT             0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_VCLK_TRIM                        11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_VCLK_TRIM_8                0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_VCLK_TRIM_INIT             0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_VSCLK_TRIM                      15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_VSCLK_TRIM_8               0x00000003 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_VSCLK_TRIM_INIT            0x00000003 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_FPCLK_TRIM                      19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_FPCLK_TRIM_8               0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_FPCLK_TRIM_INIT            0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_FPDPCLK_TRIM                    23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_FPDPCLK_TRIM_8             0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_FPDPCLK_TRIM_INIT          0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_NVCLK                    24:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_NVCLK_ENABLE        0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_NVCLK_EN_INIT       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_MCLK                     25:25 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_MCLK_ENABLE         0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_MCLK_EN_INIT        0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_CLK4X                    26:26 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_CLK4X_ENABLE        0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_CLK4X_EN_INIT       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_CCIR_O                   27:27 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_CCIR_O_ENABLE       0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_CCIR_O_EN_INIT      0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_VIP_HCLK                 28:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_VIP_HCLK_ENABLE     0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_VIP_HCLK_EN_INIT    0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_VCLK2                    29:29 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_VCLK2_ENABLE        0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_VCLK2_EN_INIT       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_PCLK                     30:30 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_PCLK_ENABLE         0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_PCLK_EN_INIT        0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_CCIR2                    31:31 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_CCIR2_ENABLE        0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_3_BYPASS_CCIR2_EN_INIT       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_4                            0x000010C4 /* RW-4R */
#define NV_PBUS_DEBUG_CTRIM_4_C0_DELAY                          3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_C0_DELAY_8                 0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_C1_DELAY                          7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_C1_DELAY_8                 0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_C2_DELAY                         11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_C2_DELAY_8                 0x00000003 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_C3_DELAY                        15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_C3_DELAY_8                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_C4_DELAY                        19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_C4_DELAY_8                 0x0000000C /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_C5_DELAY                        23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_C5_DELAY_8                 0x0000000B /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_C6_DELAY                        27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_C6_DELAY_8                 0x0000000D /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_C7_DELAY                        31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_C7_DELAY_8                 0x0000000A /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_0_TRIM                        3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_0_TRIM_8               0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_0_TRIM_INIT            0x00000003 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_1_TRIM                        7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_1_TRIM_8               0x00000002 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_1_TRIM_INIT            0x00000003 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_2_TRIM                       11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_2_TRIM_8               0x00000003 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_2_TRIM_INIT            0x00000004 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_3_TRIM                      15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_3_TRIM_8               0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_M2I_3_TRIM_INIT            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_0_TRIM                      19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_0_TRIM_8               0x0000000C /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_0_TRIM_INIT            0x0000000B /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_1_TRIM                      23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_1_TRIM_8               0x0000000B /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_1_TRIM_INIT            0x0000000A /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_2_TRIM                      27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_2_TRIM_8               0x0000000D /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_2_TRIM_INIT            0x0000000C /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_3_TRIM                      31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_3_TRIM_8               0x0000000A /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_4_M2O_3_TRIM_INIT            0x00000009 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_5                            0x000010C8 /* RW-4R */
#define NV_PBUS_DEBUG_CTRIM_5_C0_DELAY                          3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_C0_DELAY_8                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_C1_DELAY                          7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_C1_DELAY_8                 0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_C2_DELAY                         11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_C2_DELAY_8                 0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_C3_DELAY                        15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_C3_DELAY_8                 0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_C4_DELAY                        19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_C4_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_C5_DELAY                        23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_C5_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_C6_DELAY                        27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_C6_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_C7_DELAY                        31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_C7_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_FPIOCLK_TRIM                      3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_FPIOCLK_TRIM_8             0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_FPIOCLK_TRIM_INIT          0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE0                            7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE0_8                   0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE0_INIT                0x00000008 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE1                           11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE1_8                   0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE1_INIT                0x00000008 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE2                          15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE2_8                   0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE2_INIT                0x00000008 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE3                          19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE3_0                   0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE3_INIT                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE4                          23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE4_0                   0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE4_INIT                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE5                          27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE5_0                   0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_SPARE5_INIT                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_5_M_DELAY                         31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_5_M_DELAY_0                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_5_M_DELAY_INIT               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_6                            0x000010CC /* RW-4R */
#define NV_PBUS_DEBUG_CTRIM_6_C0_DELAY                          3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_C0_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_C1_DELAY                          7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_C1_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_C2_DELAY                         11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_C2_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_C3_DELAY                        15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_C3_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_C4_DELAY                        19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_C4_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_C5_DELAY                        23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_C5_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_C6_DELAY                        27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_C6_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_C7_DELAY                        31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_C7_DELAY_0                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_0_DELAY                  3:0 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_0_DELAY_0         0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_0_DELAY_INIT      0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_1_DELAY                  7:4 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_1_DELAY_0         0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_1_DELAY_INIT      0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_2_DELAY                 11:8 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_2_DELAY_0         0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_2_DELAY_INIT      0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_3_DELAY                15:12 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_3_DELAY_0         0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2I_3_DELAY_INIT      0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_0_DELAY                19:16 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_0_DELAY_0         0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_0_DELAY_INIT      0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_1_DELAY                23:20 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_1_DELAY_0         0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_1_DELAY_INIT      0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_2_DELAY                27:24 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_2_DELAY_0         0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_2_DELAY_INIT      0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_3_DELAY                31:28 /* RWIUF */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_3_DELAY_0         0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTRIM_6_FBIO_M2O_3_DELAY_INIT      0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_AGPPLL                             0x000010C0 /* RW-4R */
#define NV_PBUS_DEBUG_AGPPLL_COEFF_MDIV                         7:0 /* RWIUF */
#define NV_PBUS_DEBUG_AGPPLL_COEFF_MDIV_1                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_AGPPLL_COEFF_NDIV                        15:8 /* RWIUF */
#define NV_PBUS_DEBUG_AGPPLL_COEFF_NDIV_4                0x00000004 /* RWI-V */
#define NV_PBUS_DEBUG_AGPPLL_SETUP                            24:16 /* RWIUF */
#define NV_PBUS_DEBUG_AGPPLL_SETUP_DEFAULT               0x0000011C /* RWI-V */
#define NV_PBUS_DEBUG_AGPPLL_PWRDWN                           28:28 /* RWIVF */
#define NV_PBUS_DEBUG_AGPPLL_PWRDWN_ON                   0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_AGPPLL_PWRDWN_OFF                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_AGPPLL_STATUS                           31:31 /* R--VF */
#define NV_PBUS_DEBUG_AGPPLL_STATUS_NOTLOCKED            0x00000000 /* R---V */
#define NV_PBUS_DEBUG_AGPPLL_STATUS_LOCKED               0x00000001 /* R---V */
#define NV_PBUS_DEBUG_PORT                               0x000010D0 /* RW-4R */
#define NV_PBUS_DEBUG_PORT_MODE                                 0:0 /* RWIVF */
#define NV_PBUS_DEBUG_PORT_MODE_NORMAL                   0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_PORT_MODE_AGP4X                    0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_PRIV_ASRC                          0x000010E0 /* RW-4R */
#define NV_PBUS_DEBUG_PRIV_ASRC_EAST_SEL                      31:31 /* RWIVF */
#define NV_PBUS_DEBUG_PRIV_ASRC_EAST_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_PRIV_ASRC_EAST_OVERIDE             0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_PRIV_ASRC_EAST_VALUE                    30:24 /* RWIVF */
#define NV_PBUS_DEBUG_PRIV_ASRC_EAST_VALUE_0             0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_PRIV_ASRC_SOUTH_SEL                     23:23 /* RWIVF */
#define NV_PBUS_DEBUG_PRIV_ASRC_SOUTH_NORMAL             0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_PRIV_ASRC_SOUTH_OVERIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_PRIV_ASRC_SOUTH_VALUE                   22:16 /* RWIVF */
#define NV_PBUS_DEBUG_PRIV_ASRC_SOUTH_VALUE_0            0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_PRIV_ASRC_WEST_SEL                      15:15 /* RWIVF */
#define NV_PBUS_DEBUG_PRIV_ASRC_WEST_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_PRIV_ASRC_WEST_OVERIDE             0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_PRIV_ASRC_WEST_VALUE                     14:8 /* RWIVF */
#define NV_PBUS_DEBUG_PRIV_ASRC_WEST_VALUE_0             0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_PRIV_ASRC_NORTH_SEL                       7:7 /* RWIVF */
#define NV_PBUS_DEBUG_PRIV_ASRC_NORTH_NORMAL             0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_PRIV_ASRC_NORTH_OVERIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_PRIV_ASRC_NORTH_VALUE                     6:0 /* RWIVF */
#define NV_PBUS_DEBUG_PRIV_ASRC_NORTH_VALUE_0            0x00000000 /* RW--V */
#define NV_PBUS_INTR_0                                   0x00001100 /* RW-4R */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR                            0:0 /* RWXVF */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING         0x00000000 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET               0x00000001 /* -W--V */
#define NV_PBUS_INTR_0_HOTPLUG                                  4:4 /* RWXVF */
#define NV_PBUS_INTR_0_HOTPLUG_NOT_PENDING               0x00000000 /* R---V */
#define NV_PBUS_INTR_0_HOTPLUG_PENDING                   0x00000001 /* R---V */
#define NV_PBUS_INTR_0_HOTPLUG_RESET                     0x00000001 /* -W--V */
#define NV_PBUS_INTR_EN_0                                0x00001140 /* RWI4R */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR                         0:0 /* RWIVF */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED         0x00000000 /* RWI-V */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED          0x00000001 /* RW--V */
#define NV_PBUS_INTR_EN_0_HOTPLUG                               4:4 /* RWIVF */
#define NV_PBUS_INTR_EN_0_HOTPLUG_DISABLED               0x00000000 /* RWI-V */
#define NV_PBUS_INTR_EN_0_HOTPLUG_ENABLED                0x00000001 /* RW--V */
#define NV_PBUS_ROM_CONFIG                               0x00001200 /* RWI4R */
#define NV_PBUS_ROM_CONFIG_TW1                                  3:0 /* RWIVF */
#define NV_PBUS_ROM_CONFIG_TW1_DEFAULT                   0x0000000F /* RWI-V */
#define NV_PBUS_ROM_CONFIG_TW0                                  5:4 /* RWIVF */
#define NV_PBUS_ROM_CONFIG_TW0_DEFAULT                   0x00000003 /* RWI-V */


#define NV_PBUS_PCI_NV_2_REVISION_ID_A01                 0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_2_REVISION_ID_B01                 0x00000010 /* ----V */
#define NV_PBUS_PCI_NV_5_BASE_ADDRESS                         31:24 /* RWXUF */
#define NV_PBUS_PCI_NV_17_AGP_REV_MAJOR_1                0x00000001 /* C---V */
/* dev_bus.ref */
/* dev_bus.ref */
/* dev_bus.ref */
#define NV_PRMIO_RMA_ID                                  0x00007100 /* R--4R */
#define NV_PRMIO_RMA_ID_CODE                                   31:0 /* C--UF */
#define NV_PRMIO_RMA_ID_CODE_VALID                       0x2B16D065 /* C---V */
#define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */
#define NV_PRMIO_RMA_PTR_SPACE                                31:31 /* RWIVF */
#define NV_PRMIO_RMA_PTR_SPACE_REGISTER                  0x00000000 /* RWI-V */
#define NV_PRMIO_RMA_PTR_SPACE_MEMORY                    0x00000001 /* RW--V */
#define NV_PRMIO_RMA_PTR_ADDRESS                               26:2 /* RWIUF */
#define NV_PRMIO_RMA_PTR_ADDRESS_0                       0x00000000 /* RWI-V */
#define NV_PRMIO_RMA_DATA                                0x00007108 /* RW-4R */
#define NV_PRMIO_RMA_DATA_PORT                                 31:0 /* RWXUF */
#define NV_PRMIO_RMA_DATA32                              0x0000710C /* RW-4R */
#define NV_PRMIO_RMA_DATA32_BYTE2                             23:16 /* RWXUF */
#define NV_PRMIO_RMA_DATA32_BYTE1                              15:8 /* RWXUF */
#define NV_PRMIO_RMA_DATA32_BYTE0                               7:0 /* RWXUF */
/* dev_bus.ref */
#define NV_EXPROM                             0x0000FFFF:0x00000000 /* R---D */
#define NV_EXPROM_BIOS_ROM008(i)                   (0x00000000+(i)) /* RW-1A */
#define NV_EXPROM_BIOS_ROM008__SIZE_1                         65536 /*       */
#define NV_EXPROM_BIOS_ROM008_VALUE                             7:0 /* RW-VF */
#define NV_EXPROM_BIOS_ROM016(i)                 (0x00000000+(i)*2) /* RW-2A */
#define NV_EXPROM_BIOS_ROM016__SIZE_1                         32768 /*       */
#define NV_EXPROM_BIOS_ROM016_VALUE                            15:0 /* RW-VF */
#define NV_EXPROM_BIOS_ROM032(i)                 (0x00000000+(i)*4) /* RW-4A */
#define NV_EXPROM_BIOS_ROM032__SIZE_1                         16384 /*       */
#define NV_EXPROM_BIOS_ROM032_VALUE                            31:0 /* RW-VF */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_dac.ref */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN                   14:12 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON           0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_MPLL         0x00000001 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_VPLL         0x00000002 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_NVPLL        0x00000004 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF          0x00000007 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE                    25:24 /* RWIVF */
/* dev_fifo.ref */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             9:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_TIMESLICE                           0x00002044 /* RW-4R */
#define NV_PFIFO_DMA_TIMESLICE_SELECT                          16:0 /* RWIUF */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_1                  0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_16K                0x00003fff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_32K                0x00007fff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_64K                0x0000ffff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_128K               0x0001ffff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_TIMEOUT                        24:24 /* RWIUF */
#define NV_PFIFO_DMA_TIMESLICE_TIMEOUT_DISABLED          0x00000000 /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_TIMEOUT_ENABLED           0x00000001 /* RWI-V */
#define NV_PFIFO_PIO_TIMESLICE                           0x00002048 /* RW-4R */
#define NV_PFIFO_PIO_TIMESLICE_SELECT                          16:0 /* RWIUF */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_1                  0x00000000 /* RWI-V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_16K                0x00003fff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_32K                0x00007fff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_64K                0x0000ffff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_128K               0x0001ffff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_TIMEOUT                        24:24 /* RWIUF */
#define NV_PFIFO_PIO_TIMESLICE_TIMEOUT_DISABLED          0x00000000 /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_TIMEOUT_ENABLED           0x00000001 /* RWI-V */
#define NV_PFIFO_TIMESLICE                               0x0000204C /* RW-4R */
#define NV_PFIFO_TIMESLICE_TIMER                               17:0 /* RWIUF */
#define NV_PFIFO_TIMESLICE_TIMER_EXPIRED                 0x0003FFFF /* RWI-V */
#define NV_PFIFO_NEXT_CHANNEL                            0x00002050 /* RW-4R */
#define NV_PFIFO_NEXT_CHANNEL_CHID                              3:0 /* RWXUF */
#define NV_PFIFO_NEXT_CHANNEL_MODE                              8:8 /* RWXVF */
#define NV_PFIFO_NEXT_CHANNEL_MODE_PIO                   0x00000000 /* RW--V */
#define NV_PFIFO_NEXT_CHANNEL_MODE_DMA                   0x00000001 /* RW--V */
#define NV_PFIFO_NEXT_CHANNEL_SWITCH                          12:12 /* RWIVF */
#define NV_PFIFO_NEXT_CHANNEL_SWITCH_NOT_PENDING         0x00000000 /* RWI-V */
#define NV_PFIFO_NEXT_CHANNEL_SWITCH_PENDING             0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */
#define NV_PFIFO_RAMHT_BASE_ADDRESS                             8:4 /* RWIUF */
#define NV_PFIFO_RAMHT_BASE_ADDRESS_10000                0x00000010 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE                                   17:16 /* RWIUF */
#define NV_PFIFO_RAMHT_SIZE_4K                           0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_16K                          0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_32K                          0x00000003 /* RW--V */
#define NV_PFIFO_RAMHT_SEARCH                                 25:24 /* RWIUF */
#define NV_PFIFO_RAMHT_SEARCH_16                         0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SEARCH_32                         0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SEARCH_64                         0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SEARCH_128                        0x00000003 /* RW--V */
#define NV_PFIFO_RAMFC                                   0x00002214 /* RW-4R */
#define NV_PFIFO_RAMFC_BASE_ADDRESS                             8:1 /* RWIUF */
#define NV_PFIFO_RAMFC_BASE_ADDRESS_11000                0x00000088 /* RWI-V */
#define NV_PFIFO_RAMFC_SIZE                                   16:16 /* RWIVF */
#define NV_PFIFO_RAMFC_SIZE_1K                           0x00000000 /* RWI-V */
#define NV_PFIFO_RAMFC_SIZE_2K                           0x00000001 /* RW--V */
#define NV_PFIFO_RAMFC_BASE_ADDRESS2                          23:17 /* RWIUF */
#define NV_PFIFO_RAMFC_BASE_ADDRESS_11400                0x00000045 /* RWI-V */
#define NV_PFIFO_RAMRO                                   0x00002218 /* RW-4R */
#define NV_PFIFO_RAMRO_BASE_ADDRESS                             8:1 /* RWIUF */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_11200                0x00000089 /* RWI-V */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_11400                0x0000008A /* RWI-V */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_11500                0x0000008B /* RWI-V */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_11800                0x0000008C /* RW--V */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_12000                0x00000090 /* RW--V */
#define NV_PFIFO_RAMRO_SIZE                                   16:16 /* RWIVF */
#define NV_PFIFO_RAMRO_SIZE_512                          0x00000000 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_MODE                                    0x00002504 /* RW-4R */
#define NV_PFIFO_MODE_CHANNEL_0                                 0:0 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_0_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_0_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_1                                 1:1 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_1_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_1_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_2                                 2:2 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_2_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_2_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_3                                 3:3 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_3_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_3_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_4                                 4:4 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_4_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_4_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_5                                 5:5 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_5_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_5_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_6                                 6:6 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_6_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_6_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_7                                 7:7 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_7_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_7_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_8                                 8:8 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_8_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_8_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_9                                 9:9 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_9_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_9_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_10                              10:10 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_10_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_10_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_11                              11:11 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_11_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_11_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_12                              12:12 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_12_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_12_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_13                              13:13 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_13_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_13_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_14                              14:14 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_14_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_14_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_15                              15:15 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_15_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_15_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_DMA                                     0x00002508 /* RW-4R */
#define NV_PFIFO_DMA_CHANNEL_0                                  0:0 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_0_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_0_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_1                                  1:1 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_1_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_1_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_2                                  2:2 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_2_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_2_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_3                                  3:3 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_3_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_3_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_4                                  4:4 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_4_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_4_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_5                                  5:5 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_5_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_5_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_6                                  6:6 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_6_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_6_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_7                                  7:7 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_7_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_7_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_8                                  8:8 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_8_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_8_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_9                                  9:9 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_9_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_9_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_10                               10:10 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_10_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_10_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_11                               11:11 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_11_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_11_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_12                               12:12 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_12_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_12_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_13                               13:13 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_13_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_13_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_14                               14:14 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_14_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_14_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_15                               15:15 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_15_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_15_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_SIZE                                    0x0000250C /* RW-4R */
#define NV_PFIFO_SIZE_CHANNEL_0                                 0:0 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_0_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_0_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_1                                 1:1 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_1_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_1_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_2                                 2:2 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_2_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_2_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_3                                 3:3 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_3_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_3_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_4                                 4:4 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_4_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_4_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_5                                 5:5 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_5_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_5_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_6                                 6:6 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_6_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_6_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_7                                 7:7 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_7_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_7_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_8                                 8:8 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_8_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_8_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_9                                 9:9 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_9_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_9_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_10                              10:10 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_10_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_10_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_11                              11:11 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_11_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_11_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_12                              12:12 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_12_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_12_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_13                              13:13 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_13_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_13_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_14                              14:14 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_14_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_14_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_15                              15:15 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_15_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_15_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH                        0x00003224 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG                          7:3 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_8_BYTES           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_16_BYTES          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_24_BYTES          0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_32_BYTES          0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_40_BYTES          0x00000004 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_48_BYTES          0x00000005 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_56_BYTES          0x00000006 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_64_BYTES          0x00000007 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_72_BYTES          0x00000008 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_80_BYTES          0x00000009 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_88_BYTES          0x0000000A /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_96_BYTES          0x0000000B /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_104_BYTES         0x0000000C /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_112_BYTES         0x0000000D /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_120_BYTES         0x0000000E /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES         0x0000000F /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_136_BYTES         0x00000010 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_144_BYTES         0x00000011 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_152_BYTES         0x00000012 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_160_BYTES         0x00000013 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_168_BYTES         0x00000014 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_176_BYTES         0x00000015 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_184_BYTES         0x00000016 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_192_BYTES         0x00000017 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_200_BYTES         0x00000018 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_208_BYTES         0x00000019 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_216_BYTES         0x0000001A /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_224_BYTES         0x0000001B /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_232_BYTES         0x0000001C /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_240_BYTES         0x0000001D /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_248_BYTES         0x0000001E /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_256_BYTES         0x0000001F /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE                        15:13 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_32_BYTES          0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_64_BYTES          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_96_BYTES          0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES         0x00000003 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_160_BYTES         0x00000004 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_192_BYTES         0x00000005 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_224_BYTES         0x00000006 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_256_BYTES         0x00000007 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS                    20:16 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_0             0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_1             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_2             0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_3             0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_4             0x00000004 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_5             0x00000005 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_6             0x00000006 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_7             0x00000007 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8             0x00000008 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_9             0x00000009 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_10            0x0000000A /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_11            0x0000000B /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_12            0x0000000C /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_13            0x0000000D /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_14            0x0000000E /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_15            0x0000000F /* RW--V */
#define NV_PFIFO_CACHE1_DMA_PUT_OFFSET                         28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_GET_OFFSET                         28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_DCOUNT                       0x000032A0 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_DCOUNT_VALUE                       12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_GET_JMP_SHADOW               0x000032A4 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_GET_JMP_SHADOW_OFFSET              28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_RSVD_SHADOW                  0x000032A8 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_RSVD_SHADOW_CMD                    31:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD_TYPE                   0:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD_TYPE_INC        0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD_TYPE_NON_INC    0x00000001 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD                       12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_SUBCHANNEL                  15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD_COUNT                28:18 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD_COUNT_0         0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR                       31:30 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_NONE             0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_NON_CACHE        0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_RESERVED_CMD     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_PROTECTION       0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_INSTANCE                     0x0000322C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_INSTANCE_ADDRESS                   15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL                          0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_CTL_ADJUST                         11:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_TABLE                    12:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_TABLE_NOT_PRESENT   0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_TABLE_PRESENT       0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_ENTRY                    13:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_ENTRY_NOT_LINEAR    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_ENTRY_LINEAR        0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE                   17:16 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE_NVM          0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE_PCI          0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE_AGP          0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_AT_INFO                       31:31 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_CTL_AT_INFO_INVALID          0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_AT_INFO_VALID            0x00000001 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_LIMIT                        0x00003234 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_LIMIT_OFFSET                       28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG                      0x00003238 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS                   28:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_STATE                       0:0 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_STATE_INVALID        0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_STATE_VALID          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE                      0x0000323C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS             31:12 /* RWXUF */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    4:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                     8:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_ram.ref */
/* dev_fifo.ref */
#define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                   16 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                  16 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                  16 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                  16 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                  16 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_DMA_PUT(i,j)    (0x00800040+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_DMA_PUT__SIZE_1                                  32 /*       */
#define NV_USER_DMA_PUT__SIZE_2                                   8 /*       */
#define NV_USER_DMA_PUT_OFFSET                                 28:2 /* -WXUF */
#define NV_USER_DMA_GET(i,j)    (0x00800044+(i)*0x10000+(j)*0x2000) /* R--4A */
#define NV_USER_DMA_GET__SIZE_1                                  32 /*       */
#define NV_USER_DMA_GET__SIZE_2                                   8 /*       */
#define NV_USER_DMA_GET_OFFSET                                 28:2 /* R-XUF */
#define NV_USER_REF(i,j)        (0x00800048+(i)*0x10000+(j)*0x2000) /* R--4A */
#define NV_USER_REF__SIZE_1                                      32 /*       */
#define NV_USER_REF__SIZE_2                                       8 /*       */
#define NV_USER_REF_CNT                                        31:0 /* R-XUF */
/* dev_vga.ref */
#define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
#define NV_CIO_CRE_VID_END_7_0                                  7:0 /* RW--F */
#define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
#define NV_CIO_CRE_VID_END_ENABLE                               4:4 /* RW--F */
#define NV_CIO_CRE_VID_END_10_8                                 2:0 /* RW--F */
#define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
#define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
/* dev_graphics.ref */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_FE_STATE                              1:1 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_FE_STATE_NORMAL                0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_FE_STATE_RESET                 0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE                           2:2 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL             0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET              0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_D3D_PIPE_STATE                        3:3 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_D3D_PIPE_STATE_NORMAL          0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_D3D_PIPE_STATE_RESET           0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_PREROP_STATE                          4:4 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_PREROP_STATE_NORMAL            0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_PREROP_STATE_RESET             0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_ROP_STATE                             5:5 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_ROP_STATE_NORMAL               0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_ROP_STATE_RESET                0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_RSTR_STATE                            6:6 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_RSTR_STATE_NORMAL              0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_RSTR_STATE_RESET               0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_LIGHT_STATE                           7:7 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_LIGHT_STATE_NORMAL             0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_LIGHT_STATE_RESET              0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_DMA_STATE                             8:8 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_DMA_STATE_NORMAL               0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_DMA_STATE_RESET                0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_SPARE1                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE2                              13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_MINUSD5                             14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_MINUSD5_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_MINUSD5_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_BLIT_DST_LIMIT                      15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BLIT_DST_LIMIT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BLIT_DST_LIMIT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_LIMIT_CHECK                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_LIMIT_CHECK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_LIMIT_CHECK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_LIMIT_INT                           17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_LIMIT_INT_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_LIMIT_INT_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_OVRFLW_INT                          18:18 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_OVRFLW_INT_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_OVRFLW_INT_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D                  20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D                  21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y                           25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CWIVF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_1_PATCH_INV                             8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_PATCH_INV_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_PATCH_INV_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_ALT_RW_SEQ                          10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_ALT_RW_SEQ_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_ALT_RW_SEQ_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_INSTANCE                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_ALOM_BURST                          17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_ALOM_BURST_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_ALOM_BURST_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_BIDIR_DRAIN                         18:18 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_BIDIR_DRAIN_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_BIDIR_DRAIN_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_EARLY_POST                          19:19 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_EARLY_POST_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_EARLY_POST_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CTX                                 20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CTX_DISABLED                   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CTX_ENABLED                    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_FIXED_ADRS                          21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_FIXED_ADRS_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_FIXED_ADRS_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DITHER_RANGE_ADJ_2D                 22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_DITHER_RANGE_ADJ_2D_DISABLED   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_DITHER_RANGE_ADJ_2D_ENABLED    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DITHER_RANGE_ADJ_3D                 23:23 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_DITHER_RANGE_ADJ_3D_DISABLED   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_DITHER_RANGE_ADJ_3D_ENABLED    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CACHE                               24:24 /* CWIVF */
#define NV_PGRAPH_DEBUG_1_CACHE_IGNORE                   0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_1_CACHE_FLUSH                    0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_1_CACHE_MODE                          25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CACHE_MODE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CACHE_MODE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_UCLAMP                              29:29 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_UCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_UCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_RCLAMP                              30:30 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_RCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_RCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DX6_2PIXMODE                        31:31 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_DX6_2PIXMODE_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_DX6_2PIXMODE_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_HONOR_SRCFMT                          0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_HONOR_SRCFMT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_HONOR_SRCFMT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_PINGPONG                              0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_PINGPONG_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_PINGPONG_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE1                                4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE2                                5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE3                                6:6 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE3_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE3_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE4                                7:7 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE4_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE4_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE5                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE5_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE5_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE6                                9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE6_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE6_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE7                              10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE7_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE7_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_MCLK_RECTS                          11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_MCLK_RECTS_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_MCLK_RECTS_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                      13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FOG_3D                              14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPECULAR_3D                         15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPECULAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPECULAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ALPHA_3D                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ALPHA_3D_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ALPHA_3D_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ                            18:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ_CRZRWCW               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ_ZRWCRW                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ_AUTO                  0x00000002 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D                        20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_2D                         22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_2D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_2D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FAST_VERTEX_LOAD                    23:23 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FAST_VERTEX_LOAD1_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FAST_VERTEX_LOAD_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BLIT_MULTILINE                      24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BLIT_MULTILINE_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BLIT_MULTILINE_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
#define NV_PGRAPH_DEBUG_3_CULLING                               0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_CULLING_TYPE                          1:1 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_TYPE_DX3               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_TYPE_DX5               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH                      4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D                         5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_IMAGE                       6:6 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_IMAGE_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_IMAGE_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH                                7:7 /* CWIVF */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE                  0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE                0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ                        8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D                        9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ                   10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D                   11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_2D                       12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_2D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_2D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_3D                       13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_2D                        14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_PREDITHER_2D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_2D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_3D                        15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_PREDITHER_3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD                         17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT                        18:18 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH                        19:19 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK                          20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL                     21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK                        22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DMA_CHECK                           23:23 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DMA_CHECK_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DMA_CHECK_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_RAMREADBACK                         24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_RAMREADBACK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_RAMREADBACK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_CLIP_METHODS                        25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CLIP_METHODS_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CLIP_METHODS_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_EXCLUDE_ROP_IN_IDLE                 27:27 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_EXCLUDE_ROP_IN_IDLE_DISABLED   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_EXCLUDE_ROP_IN_IDLE_ENABLED    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_STATE_CHECK                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_STATE_CHECK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_STATE_CHECK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_CONTEXT_METHODS                     29:29 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CONTEXT_METHODS_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CONTEXT_METHODS_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_OPERATION_METHOD                    30:30 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_OPERATION_METHOD_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_OPERATION_METHOD_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_IGNORE_PATCHVALID                   31:31 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_IGNORE_PATCHVALID_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_IGNORE_PATCHVALID_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS                                0x00400104 /* RW-4R */
#define NV_PGRAPH_NSTATUS_STATE_IN_USE                        11:11 /* RWIVF */
#define NV_PGRAPH_NSTATUS_STATE_IN_USE_NOT_PENDING       0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_STATE_IN_USE_PENDING           0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS_INVALID_STATE                       12:12 /* RWIVF */
#define NV_PGRAPH_NSTATUS_INVALID_STATE_NOT_PENDING      0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_INVALID_STATE_PENDING          0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS_BAD_ARGUMENT                        13:13 /* RWIVF */
#define NV_PGRAPH_NSTATUS_BAD_ARGUMENT_NOT_PENDING       0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_BAD_ARGUMENT_PENDING           0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS_PROTECTION_FAULT                    14:14 /* RWIVF */
#define NV_PGRAPH_NSTATUS_PROTECTION_FAULT_NOT_PENDING   0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_PROTECTION_FAULT_PENDING       0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL                            0x00400170 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHANGE                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_CHANGE_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_CHANGE_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_USER                               0x00400174 /* RW-4R */
#define NV_PGRAPH_CTX_USER_SUBCH                              15:13 /* RWIVF */
#define NV_PGRAPH_CTX_USER_SUBCH_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_USER_CHID                               28:24 /* RWIVF */
#define NV_PGRAPH_CTX_USER_CHID_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_USER_SINGLE_STEP                        31:31 /* RWIVF */
#define NV_PGRAPH_CTX_USER_SINGLE_STEP_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_USER_SINGLE_STEP_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1                            0x00400160 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH2                            0x00400164 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT                       1:0 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT_INVALID              0x00 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT_CGA6_M1              0x01 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT_LE_M1                0x02 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT                     13:8 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_INVALID             0x00 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_Y8               0x01 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16A8Y8          0x02 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X24Y8            0x03 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A1R5G5B5         0x06 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X1R5G5B5         0x07 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16A1R5G5B5      0x08 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X17R5G5B5        0x09 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_R5G6B5           0x0A /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A16R5G6B5        0x0B /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16R5G6B5        0x0C /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A8R8G8B8         0x0D /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X8R8G8B8         0x0E /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_Y16              0x0F /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A16Y16           0x10 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16Y16           0x11 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_V8YB8U8YA8       0x12 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_YB8V8YA8U8       0x13 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_Y32              0x14 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_AY8              0x15 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_EYB8ECR8EYA8ECB8 0x16 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_ECR8EYB8ECB8EYA8 0x17 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_NOTIFY_INSTANCE                 31:16 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH2_NOTIFY_INSTANCE_INVALID        0x0000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH3                            0x00400168 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_0                   15:0 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_0_INVALID         0x0000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_1                  31:16 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_1_INVALID         0x0000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH4                            0x0040016C /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH4_USER_INSTANCE                    15:0 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH4_USER_INSTANCE_INVALID          0x0000 /* RW--V */
#define NV_PGRAPH_CTX_CACHE1(i)                  (0x00400180+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE1__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE1_GRCLASS                            7:0 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CHROMA_KEY                       12:12 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_USER_CLIP                        13:13 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_SWIZZLE                          14:14 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_PATCH_CONFIG                     17:15 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_SYNCHRONIZE                      18:18 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_ENDIAN_MODE                      19:19 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_DITHER_MODE                      21:20 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CLASS_TYPE                       22:22 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_SINGLE_STEP                      23:23 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_PATCH_STATUS                     24:24 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CONTEXT_SURFACE                  25:25 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CONTEXT_SURFACE0                 25:25 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CONTEXT_SURFACE1                 26:26 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CONTEXT_PATTERN                  27:27 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CONTEXT_ROP                      28:28 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CONTEXT_BETA1                    29:29 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CONTEXT_BETA4                    30:30 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE2(i)                  (0x004001a0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE2__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE2_MONO_FORMAT                        1:0 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE2_COLOR_FORMAT                      13:8 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE2_NOTIFY_INSTANCE                  31:16 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE3(i)                  (0x004001c0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE3__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE3_DMA_INSTANCE_0                    15:0 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE3_DMA_INSTANCE_1                   31:16 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE4(i)                  (0x004001e0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE4__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE4_USER_INSTANCE                     15:0 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0(i)              (0x00400730+(i)*4) /* RW-4A */
#define NV_PGRAPH_FFINTFC_FIFO_0__SIZE_1                          4 /*       */
#define NV_PGRAPH_FFINTFC_FIFO_0_TAG                            0:0 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0_TAG_MTHD                0x00000000 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_TAG_CHSW                0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH                          3:1 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_0                 0x00000000 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_1                 0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_2                 0x00000002 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_3                 0x00000003 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_4                 0x00000004 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_5                 0x00000005 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_6                 0x00000006 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_7                 0x00000007 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_MTHD                          14:4 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0_MTHD_CTX_SWITCH         0x00000000 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_1(i)              (0x00400740+(i)*4) /* RW-4A */
#define NV_PGRAPH_FFINTFC_FIFO_1__SIZE_1                          4 /*       */
#define NV_PGRAPH_FFINTFC_FIFO_1_ARGUMENT                      31:0 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_2(i)              (0x00400750+(i)*4) /* RW-4A */
#define NV_PGRAPH_FFINTFC_FIFO_2__SIZE_1                          4 /*       */
#define NV_PGRAPH_FFINTFC_FIFO_2_ARGUMENT                      31:0 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_PTR                       0x00400750 /* RW-4R */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_WRITE                        2:0 /* RWIVF */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_WRITE_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_READ                         6:4 /* RWIVF */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_READ_0                0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2                            0x00400754 /* RW-4R */
#define NV_PGRAPH_FFINTFC_ST2_STATUS                            0:0 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_STATUS_INVALID             0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_STATUS_VALID               0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_MTHD                             11:1 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_MTHD_CTX_SWITCH            0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH                           14:12 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_0                    0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_3                    0x00000003 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_4                    0x00000004 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_5                    0x00000005 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_6                    0x00000006 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_7                    0x00000007 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID                            18:15 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_CHID_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_1                     0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_2                     0x00000002 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_3                     0x00000003 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_4                     0x00000004 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_5                     0x00000005 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_6                     0x00000006 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_7                     0x00000007 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_8                     0x00000008 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_9                     0x00000009 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_10                    0x0000000A /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_11                    0x0000000B /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_12                    0x0000000C /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_13                    0x0000000D /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_14                    0x0000000E /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_15                    0x0000000F /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_16                    0x00000010 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_17                    0x00000011 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_18                    0x00000012 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_19                    0x00000013 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_20                    0x00000014 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_21                    0x00000015 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_22                    0x00000016 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_23                    0x00000017 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_24                    0x00000018 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_25                    0x00000019 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_26                    0x0000001A /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_27                    0x0000001B /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_28                    0x0000001C /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_29                    0x0000001D /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_30                    0x0000001E /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_31                    0x0000001F /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_STATUS                     19:19 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_CHID_STATUS_INVALID        0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_STATUS_VALID          0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CH_SWITCH_DETECT                20:20 /* -WIVF */
#define NV_PGRAPH_FFINTFC_ST2_CH_SWITCH_DETECT_CLEAR     0x00000000 /* -WI-V */
#define NV_PGRAPH_FFINTFC_ST2_CH_SWITCH_DETECT_SET       0x00000001 /* -W--V */
#define NV_PGRAPH_FFINTFC_ST2_FIFO_HOLD                       21:21 /* -WIVF */
#define NV_PGRAPH_FFINTFC_ST2_FIFO_HOLD_CLEAR            0x00000000 /* -WI-V */
#define NV_PGRAPH_FFINTFC_ST2_FIFO_HOLD_SET              0x00000001 /* -W--V */
#define NV_PGRAPH_FFINTFC_ST2_D                          0x00400758 /* RW-4R */
#define NV_PGRAPH_FFINTFC_ST2_D_ARGUMENT                       31:0 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_D_ARGUMENT_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_STATUS                                 0x00400700 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_FE                                     5:5 /* R-IVF */
#define NV_PGRAPH_STATUS_FE_IDLE                         0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_FE_BUSY                         0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_RASTERIZER                             6:6 /* R-IVF */
#define NV_PGRAPH_STATUS_RASTERIZER_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_RASTERIZER_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_ENGINE                           17:17 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_BUFFER_NOTIFY                    21:21 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_BUFFER_NOTIFY_IDLE          0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_BUFFER_NOTIFY_BUSY          0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_D3D                                  24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_D3D_IDLE                        0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_D3D_BUSY                        0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_CACHE                                25:25 /* R-IVF */
#define NV_PGRAPH_STATUS_CACHE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_CACHE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_LIGHTING                             26:26 /* R-IVF */
#define NV_PGRAPH_STATUS_LIGHTING_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_LIGHTING_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PREROP                               27:27 /* R-IVF */
#define NV_PGRAPH_STATUS_PREROP_IDLE                     0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PREROP_BUSY                     0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_ROP                                  28:28 /* R-IVF */
#define NV_PGRAPH_STATUS_ROP_IDLE                        0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_ROP_BUSY                        0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_USER                            29:29 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_USER_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_USER_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x00400704 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_MTHD                            12:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_SUBCH                          15:13 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CHID                           27:24 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x00400708 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_SURFACE                                0x0040070C /* RW-4R */
#define NV_PGRAPH_SURFACE_TYPE                                  1:0 /* RWIVF */
#define NV_PGRAPH_SURFACE_TYPE_INVALID                   0x00000000 /* RWI-V */
#define NV_PGRAPH_SURFACE_TYPE_NON_SWIZZLE               0x00000001 /* RW--V */
#define NV_PGRAPH_SURFACE_TYPE_SWIZZLE                   0x00000002 /* RW--V */
#define NV_PGRAPH_SURFACE_TYPE_053                       0x00000001 /* RWC-V */
#define NV_PGRAPH_NOTIFY                                 0x00400714 /* RW-4R */
#define NV_PGRAPH_NOTIFY_BUFFER_REQ                             0:0 /* RWIVF */
#define NV_PGRAPH_NOTIFY_BUFFER_REQ_NOT_PENDING          0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_BUFFER_REQ_PENDING              0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_BUFFER_STYLE                           8:8 /* RWIVF */
#define NV_PGRAPH_NOTIFY_BUFFER_STYLE_WRITE_ONLY         0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_BUFFER_STYLE_WRITE_THEN_AWAKEN  0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_REQ                                  16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                 0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_REQ_PENDING                     0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_STYLE                                20:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_STYLE_WRITE_ONLY                0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_STYLE_WRITE_THEN_AWAKEN         0x00000001 /* RW--V */
#define NV_PGRAPH_BOFFSET(i)                     (0x00400640+(i)*4) /* RW-4A */
#define NV_PGRAPH_BOFFSET__SIZE_1                                 6 /*       */
#define NV_PGRAPH_BOFFSET_LINADRS                              26:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET_LINADRS_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET0                               0x00400640 /* RW-4R */
#define NV_PGRAPH_BOFFSET0__ALIAS_1            NV_PGRAPH_BOFFSET(0) /*       */
#define NV_PGRAPH_BOFFSET0_LINADRS                             26:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET0_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET0_LINADRS_042                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BOFFSET0_LINADRS_058                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BOFFSET1                               0x00400644 /* RW-4R */
#define NV_PGRAPH_BOFFSET1__ALIAS_1            NV_PGRAPH_BOFFSET(1) /*       */
#define NV_PGRAPH_BOFFSET1_LINADRS                             26:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET1_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET1_LINADRS_042                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BOFFSET1_LINADRS_059                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BOFFSET2                               0x00400648 /* RW-4R */
#define NV_PGRAPH_BOFFSET2__ALIAS_1            NV_PGRAPH_BOFFSET(2) /*       */
#define NV_PGRAPH_BOFFSET2_LINADRS                             26:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET2_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET2_LINADRS_053                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BOFFSET2_LINADRS_05A                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BOFFSET3                               0x0040064C /* RW-4R */
#define NV_PGRAPH_BOFFSET3__ALIAS_1            NV_PGRAPH_BOFFSET(3) /*       */
#define NV_PGRAPH_BOFFSET3_LINADRS                             26:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET3_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET3_LINADRS_053                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BOFFSET3_LINADRS_05B                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BOFFSET4                               0x00400650 /* RW-4R */
#define NV_PGRAPH_BOFFSET4__ALIAS_1            NV_PGRAPH_BOFFSET(4) /*       */
#define NV_PGRAPH_BOFFSET4_LINADRS                             26:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET4_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET5                               0x00400654 /* RW-4R */
#define NV_PGRAPH_BOFFSET5__ALIAS_1            NV_PGRAPH_BOFFSET(5) /*       */
#define NV_PGRAPH_BOFFSET5_LINADRS                             26:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET5_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET5_LINADRS_052                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BBASE(i)                       (0x00400658+(i)*4) /* RW-4A */
#define NV_PGRAPH_BBASE__SIZE_1                                   6 /*       */
#define NV_PGRAPH_BBASE_LINADRS                                26:0 /* RWIUF */
#define NV_PGRAPH_BBASE_LINADRS_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE0                                 0x00400658 /* RW-4R */
#define NV_PGRAPH_BBASE0__ALIAS_1                NV_PGRAPH_BBASE(0) /*       */
#define NV_PGRAPH_BBASE0_LINADRS                               26:0 /* RWIUF */
#define NV_PGRAPH_BBASE0_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE1                                 0x0040065c /* RW-4R */
#define NV_PGRAPH_BBASE1__ALIAS_1                NV_PGRAPH_BBASE(1) /*       */
#define NV_PGRAPH_BBASE1_LINADRS                               26:0 /* RWIUF */
#define NV_PGRAPH_BBASE1_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE2                                 0x00400660 /* RW-4R */
#define NV_PGRAPH_BBASE2__ALIAS_1                NV_PGRAPH_BBASE(2) /*       */
#define NV_PGRAPH_BBASE2_LINADRS                               26:0 /* RWIUF */
#define NV_PGRAPH_BBASE2_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE3                                 0x00400664 /* RW-4R */
#define NV_PGRAPH_BBASE3__ALIAS_1                NV_PGRAPH_BBASE(3) /*       */
#define NV_PGRAPH_BBASE3_LINADRS                               26:0 /* RWIUF */
#define NV_PGRAPH_BBASE3_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE4                                 0x00400668 /* RW-4R */
#define NV_PGRAPH_BBASE4__ALIAS_1                NV_PGRAPH_BBASE(4) /*       */
#define NV_PGRAPH_BBASE4_LINADRS                               26:0 /* RWIUF */
#define NV_PGRAPH_BBASE4_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE5                                 0x0040066C /* RW-4R */
#define NV_PGRAPH_BBASE5__ALIAS_1                NV_PGRAPH_BBASE(5) /*       */
#define NV_PGRAPH_BBASE5_LINADRS                               26:0 /* RWIUF */
#define NV_PGRAPH_BBASE5_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH(i)                      (0x00400670+(i)*4) /* RW-4A */
#define NV_PGRAPH_BPITCH__SIZE_1                                  5 /*       */
#define NV_PGRAPH_BPITCH_VALUE                                 15:0 /* RWIUF */
#define NV_PGRAPH_BPITCH_VALUE_0                         0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH0                                0x00400670 /* RW-4R */
#define NV_PGRAPH_BPITCH0__ALIAS_1              NV_PGRAPH_BPITCH(0) /*       */
#define NV_PGRAPH_BPITCH0_VALUE                                15:0 /* RWIUF */
#define NV_PGRAPH_BPITCH0_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH0_VALUE_042                      0x00000020 /* RWC-V */
#define NV_PGRAPH_BPITCH0_VALUE_058                      0x00000010 /* RWC-V */
#define NV_PGRAPH_BPITCH1                                0x00400674 /* RW-4R */
#define NV_PGRAPH_BPITCH1__ALIAS_1              NV_PGRAPH_BPITCH(1) /*       */
#define NV_PGRAPH_BPITCH1_VALUE                                15:0 /* RWIUF */
#define NV_PGRAPH_BPITCH1_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH1_VALUE_042                      0x00000020 /* RWC-V */
#define NV_PGRAPH_BPITCH1_VALUE_059                      0x00000010 /* RWC-V */
#define NV_PGRAPH_BPITCH2                                0x00400678 /* RW-4R */
#define NV_PGRAPH_BPITCH2__ALIAS_1              NV_PGRAPH_BPITCH(2) /*       */
#define NV_PGRAPH_BPITCH2_VALUE                                15:0 /* RWIUF */
#define NV_PGRAPH_BPITCH2_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH2_VALUE_053                      0x00000020 /* RWC-V */
#define NV_PGRAPH_BPITCH2_VALUE_05A                      0x00000010 /* RWC-V */
#define NV_PGRAPH_BPITCH3                                0x0040067C /* RW-4R */
#define NV_PGRAPH_BPITCH3__ALIAS_1              NV_PGRAPH_BPITCH(3) /*       */
#define NV_PGRAPH_BPITCH3_VALUE                                15:0 /* RWIUF */
#define NV_PGRAPH_BPITCH3_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH3_VALUE_053                      0x00000020 /* RWC-V */
#define NV_PGRAPH_BPITCH3_VALUE_05B                      0x00000010 /* RWC-V */
#define NV_PGRAPH_BPITCH4                                0x00400680 /* RW-4R */
#define NV_PGRAPH_BPITCH4__ALIAS_1              NV_PGRAPH_BPITCH(4) /*       */
#define NV_PGRAPH_BPITCH4_VALUE                                15:0 /* RWIUF */
#define NV_PGRAPH_BPITCH4_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BLIMIT(i)                      (0x00400684+(i)*4) /* RW-4A */
#define NV_PGRAPH_BLIMIT__SIZE_1                                  6 /*       */
#define NV_PGRAPH_BLIMIT_VALUE                                 26:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT_TYPE                                 31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT_TYPE_IN_MEMORY                  0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT_TYPE_NULL                       0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT0                                0x00400684 /* RW-4R */
#define NV_PGRAPH_BLIMIT0__ALIAS_1              NV_PGRAPH_BLIMIT(0) /*       */
#define NV_PGRAPH_BLIMIT0_VALUE                                26:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT0_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT0_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT0_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT1                                0x00400688 /* RW-4R */
#define NV_PGRAPH_BLIMIT1__ALIAS_1              NV_PGRAPH_BLIMIT(1) /*       */
#define NV_PGRAPH_BLIMIT1_VALUE                                26:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT1_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT1_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT1_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT2                                0x0040068c /* RW-4R */
#define NV_PGRAPH_BLIMIT2__ALIAS_1              NV_PGRAPH_BLIMIT(2) /*       */
#define NV_PGRAPH_BLIMIT2_VALUE                                26:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT2_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT2_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT2_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT3                                0x00400690 /* RW-4R */
#define NV_PGRAPH_BLIMIT3__ALIAS_1              NV_PGRAPH_BLIMIT(3) /*       */
#define NV_PGRAPH_BLIMIT3_VALUE                                26:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT3_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT3_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT3_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT4                                0x00400694 /* RW-4R */
#define NV_PGRAPH_BLIMIT4__ALIAS_1              NV_PGRAPH_BLIMIT(4) /*       */
#define NV_PGRAPH_BLIMIT4_VALUE                                26:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT4_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT4_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT4_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT5                                0x00400698 /* RW-4R */
#define NV_PGRAPH_BLIMIT5__ALIAS_1              NV_PGRAPH_BLIMIT(5) /*       */
#define NV_PGRAPH_BLIMIT5_VALUE                                26:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT5_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT5_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT5_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE2                              0x0040069c /* RW-4R */
#define NV_PGRAPH_BSWIZZLE2_WIDTH                             19:16 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE2_WIDTH_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE2_WIDTH_053                    0x00000000 /* RWC-V */
#define NV_PGRAPH_BSWIZZLE2_HEIGHT                            27:24 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE2_HEIGHT_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE2_HEIGHT_053                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BSWIZZLE5                              0x004006a0 /* RW-4R */
#define NV_PGRAPH_BSWIZZLE5_WIDTH                             19:16 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE5_WIDTH_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE5_WIDTH_052                    0x00000000 /* RWC-V */
#define NV_PGRAPH_BSWIZZLE5_HEIGHT                            27:24 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE5_HEIGHT_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE5_HEIGHT_052                   0x00000000 /* RWC-V */
#define NV_PGRAPH_BPIXEL                                 0x00400724 /* RW-4R */
#define NV_PGRAPH_BPIXEL_DEPTH0                                 3:0 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH0_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_YB8V8YA8U8               0x0000000f /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_042                      0x00000001 /* RWC-V */
#define NV_PGRAPH_BPIXEL_DEPTH0_058                      0x00000001 /* RWC-V */
#define NV_PGRAPH_BPIXEL_DEPTH1                                 7:4 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH1_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_YB8V8YA8U8               0x0000000f /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_059                      0x00000001 /* RWC-V */
#define NV_PGRAPH_BPIXEL_DEPTH2                                11:8 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH2_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_YB8V8YA8U8               0x0000000f /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_053                      0x00000002 /* RWC-V */
#define NV_PGRAPH_BPIXEL_DEPTH2_05A                      0x00000002 /* RWC-V */
#define NV_PGRAPH_BPIXEL_DEPTH3                               15:12 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH3_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_YB8V8YA8U8               0x0000000f /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_05B                      0x00000002 /* RWC-V */
#define NV_PGRAPH_BPIXEL_DEPTH4                               19:16 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH4_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH4_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_YB8V8YA8U8               0x0000000f /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5                               23:20 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH5_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH5_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_YB8V8YA8U8               0x0000000f /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_052                      0x00000001 /* RWC-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX                         0x00400610 /* RW-4R */
#define NV_PGRAPH_LIMIT_VIOL_PIX_ADRS                          26:0 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_ADRS_0                  0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BTILED                       27:27 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BTILED_NO_VIOL          0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BTILED_VIOL             0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BPITCH                       28:28 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BPITCH_NO_VIOL          0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BPITCH_VIOL             0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BLIT                         29:29 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BLIT_NO_VIOL            0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BLIT_VIOL               0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_LIMIT                        30:30 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_LIMIT_NO_VIOL           0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_LIMIT_VIOL              0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_OVRFLW                       31:31 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_OVRFLW_NO_VIOL          0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_OVRFLW_VIOL             0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_Z                           0x00400614 /* RW-4R */
#define NV_PGRAPH_LIMIT_VIOL_Z_ADRS                            26:0 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_Z_ADRS_0                    0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_Z_LIMIT                          30:30 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_Z_LIMIT_NO_VIOL             0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_Z_LIMIT_VIOL                0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_Z_OVRFLW                         31:31 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_Z_OVRFLW_NO_VIOL            0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_Z_OVRFLW_VIOL               0x00000001 /* RW--V */
#define NV_PGRAPH_STATE                                  0x00400710 /* RW-4R */
#define NV_PGRAPH_STATE_BUFFER_0                                0:0 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_0_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_0_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_0_042                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_BUFFER_0_058                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_BUFFER_1                                1:1 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_1_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_1_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_1_042                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_BUFFER_1_059                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_BUFFER_2                                2:2 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_2_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_2_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_2_053                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_BUFFER_2_05A                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_BUFFER_3                                3:3 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_3_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_3_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_3_053                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_BUFFER_3_05B                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_BUFFER_4                                4:4 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_4_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_4_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_4_038                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_BUFFER_5                                5:5 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_5_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_5_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_5_052                     0x00000000 /* RWC-V */
#define NV_PGRAPH_STATE_PITCH_0                                 8:8 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_0_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_0_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_0_042                      0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PITCH_0_058                      0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PITCH_1                                 9:9 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_1_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_1_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_1_042                      0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PITCH_1_059                      0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PITCH_2                               10:10 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_2_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_2_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_2_053                      0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PITCH_2_05A                      0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PITCH_3                               11:11 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_3_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_3_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_3_053                      0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PITCH_3_05B                      0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PITCH_4                               12:12 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_4_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_4_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CHROMA_COLOR                          16:16 /* RWIVF */
#define NV_PGRAPH_STATE_CHROMA_COLOR_INVALID             0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CHROMA_COLOR_VALID               0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CHROMA_COLOR_057                 0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT                       17:17 /* RWIVF */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT_INVALID          0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT_VALID            0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT_017              0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT                     20:20 /* RWIVF */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT_INVALID        0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT_VALID          0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT_044            0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT                      21:21 /* RWIVF */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT_INVALID         0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT_VALID           0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT_044             0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_CPATTERN_SELECT                       22:22 /* RWIVF */
#define NV_PGRAPH_STATE_CPATTERN_SELECT_INVALID          0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CPATTERN_SELECT_VALID            0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CPATTERN_SELECT_044              0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PATTERN_COLOR0                        24:24 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_COLOR0_INVALID           0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_COLOR0_VALID             0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_COLOR0_018               0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PATTERN_COLOR1                        25:25 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_COLOR1_INVALID           0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_COLOR1_VALID             0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_COLOR1_018               0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PATTERN_PATT0                         26:26 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_PATT0_INVALID            0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_PATT0_VALID              0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_PATT0_018                0x00000001 /* RWC-V */
#define NV_PGRAPH_STATE_PATTERN_PATT1                         27:27 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_PATT1_INVALID            0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_PATT1_VALID              0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_PATT1_018                0x00000001 /* RWC-V */
#define NV_PGRAPH_CACHE_INDEX                            0x00400728 /* RW-4R */
#define NV_PGRAPH_CACHE_INDEX_BANK                              2:2 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_BANK_10                    0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_BANK_32                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS                             12:3 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_ADRS_0                     0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_1024                  0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_1024                  0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_TEXTURE_RAM_0         0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_TEXTURE_RAM_1K        0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_PALETTE_RAM_0         0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_PALETTE_RAM_512       0x00000200 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_MISS_DATA_RAM_0       0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_MISS_DATA_RAM_32      0x00000020 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_RLATENCY_RAM_0        0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_RLATENCY_RAM_384      0x00000180 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_FLATENCY_RAM_0        0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_FLATENCY_RAM_448      0x000001C0 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP                              14:13 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_OP_WR_CACHE                0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_CACHE                0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_INDEX                0x00000002 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_NOP                     0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_TEXTURE_RAM             0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_PALETTE_RAM             0x00000002 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_MISS_DATA_RAM           0x00000003 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RLATENCY_RAM            0x00000004 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_FLATENCY_RAM            0x00000005 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_TEX_PIPE                        15:15 /* RWIVF */
#define NV_PGRAPH_CACHE_INDEX_TEX_PIPE_0                 0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_TEX_PIPE_1                 0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL                           29:24 /* RWIVF */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_NOP                  0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_INDEX_REG            0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TIME_CNT             0x00000020 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_CACHE_IDLE_CNT       0x00000021 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP0_PIX_CNT          0x00000022 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP0_MISS_CNT         0x00000023 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP0_COAL_STALL_CNT   0x00000024 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP0_REPL_STALL_CNT   0x00000025 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP0_MP_Q_STALL_CNT   0x00000026 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP0_TEX2MA_STALL_CNT 0x00000027 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_LIT2TEX_STALL_CNT    0x00000028 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_RBFR_FULL_STALL_CNT  0x00000029 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP1_PIX_CNT          0x0000002A /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP1_MISS_CNT         0x0000002B /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP1_COAL_STALL_CNT   0x0000002C /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP1_REPL_STALL_CNT   0x0000002D /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP1_MP_Q_STALL_CNT   0x0000002E /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TP1_TEX2MA_STALL_CNT 0x0000002F /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_TEX2LIT_REGLD_CNT    0x00000030 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_RDSEL_C2DMA_TAKEN_CNT      0x00000031 /* RW--V */
#define NV_PGRAPH_CACHE_RAM                              0x0040072c /* RW-4R */
#define NV_PGRAPH_CACHE_RAM_VALUE                              31:0 /* RWXVF */
#define NV_PGRAPH_DMA_PITCH                              0x00400760 /* RW-4R */
#define NV_PGRAPH_DMA_PITCH_S0                                 15:0 /* RWXSF */
#define NV_PGRAPH_DMA_PITCH_S1                                31:16 /* RWXSF */
#define NV_PGRAPH_DVD_COLORFMT                           0x00400764 /* RW-4R */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE                            5:0 /* RWNVF */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE_FORMAT_INVALID            0x00 /* RWN-V */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE_FORMAT_LE_V8YB8U8YA8      0x12 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE_FORMAT_LE_YB8V8YA8U8      0x13 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY                             9:8 /* RWNVF */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_INVALID             0x00 /* RWN-V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_LE_A8Y8U8V8         0x01 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_LE_A4V6YB6A4U6YA6   0x02 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_TRANSPARENT         0x03 /* RW--V */
#define NV_PGRAPH_SCALED_FORMAT                          0x00400768 /* RW-4R */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN                        17:16 /* RWIVF */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN_INVALID           0x00000000 /* RWI-V */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN_CENTER            0x00000001 /* RW--V */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN_CORNER            0x00000002 /* RW--V */
#define NV_PGRAPH_SCALED_FORMAT_INTERPOLATOR                  24:24 /* RWIVF */
#define NV_PGRAPH_SCALED_FORMAT_INTERPOLATOR_ZOH         0x00000000 /* RWI-V */
#define NV_PGRAPH_SCALED_FORMAT_INTERPOLATOR_FOH         0x00000001 /* RW--V */
#define NV_PGRAPH_PATT_COLOR0                            0x00400800 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_VALUE_018                  0x00000000 /* RWC-V */
#define NV_PGRAPH_PATT_COLOR0_VALUE_044                  0x00000000 /* RWC-V */
#define NV_PGRAPH_PATT_COLOR1                            0x00400804 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_VALUE_018                  0x00000000 /* RWC-V */
#define NV_PGRAPH_PATT_COLOR1_VALUE_044                  0x00000000 /* RWC-V */
#define NV_PGRAPH_PATT_COLORRAM(i)               (0x00400900+(i)*4) /* R--4A */
#define NV_PGRAPH_PATT_COLORRAM__SIZE_1                          64 /*       */
#define NV_PGRAPH_PATT_COLORRAM_VALUE                          23:0 /* R--UF */
#define NV_PGRAPH_PATT_COLORRAM_VALUE_044                0x00000000 /* R-C-V */
#define NV_PGRAPH_PATTERN(i)                     (0x00400808+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_BITMAP_018                     0x00000000 /* RWC-V */
#define NV_PGRAPH_PATTERN_BITMAP_044                     0x00000000 /* RWC-V */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400810 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X_8Y              0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X_1Y             0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X_64Y             0x00000002 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_018                0x00000000 /* RWC-V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_044                0x00000000 /* RWC-V */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT                          4:4 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT_2COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT_FULLCOLOR         0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT_044               0x00000000 /* RWC-V */
#define NV_PGRAPH_MONO_COLOR0                            0x00400600 /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400604 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_ROP3_VALUE_043                         0x00000000 /* RWC-V */
#define NV_PGRAPH_CHROMA                                 0x00400814 /* RW-4R */
#define NV_PGRAPH_CHROMA_VALUE                                 31:0 /* RWXUF */
#define NV_PGRAPH_CHROMA_VALUE_017                       0x00000000 /* RWC-V */
#define NV_PGRAPH_CHROMA_VALUE_057                       0x00000000 /* RWC-V */
#define NV_PGRAPH_BETA_AND                               0x00400608 /* RW-4R */
#define NV_PGRAPH_BETA_AND_VALUE_FRACTION                     30:23 /* RWXUF */
#define NV_PGRAPH_BETA_AND_VALUE_FRACTION_012            0x00000000 /* RWC-V */
#define NV_PGRAPH_BETA_PREMULT                           0x0040060c /* RW-4R */
#define NV_PGRAPH_BETA_PREMULT_VALUE                           31:0 /* RWXUF */
#define NV_PGRAPH_BETA_PREMULT_VALUE_072                 0x00000000 /* RWC-V */
#define NV_PGRAPH_DPRAM_INDEX                            0x00400828 /* RW-4R */
#define NV_PGRAPH_DPRAM_INDEX_ADRS                              6:0 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_ADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT                           10:8 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS                0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0              0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1              0x00000001 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_IDATA               0x00000001 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA               0x00000002 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0              0x00000002 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_IWE                 0x00000003 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1              0x00000003 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_XY                  0x00000004 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE_0                0x00000004 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ODATA               0x00000005 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE_1                0x00000005 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_OWE                 0x00000006 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA_0             0x00000006 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_SCOMP               0x00000007 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA_1             0x00000007 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_PWD                 0x00000008 /* RW--V */
#define NV_PGRAPH_DPRAM_DATA                             0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_0                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_0_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_1                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_1_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_0                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_0_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_1                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_1_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE_0                             0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE_0__ALIAS_1          NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_0_VALUE                             23:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE_1                             0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE_1__ALIAS_1          NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_1_VALUE                             23:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA_0                          0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA_0__ALIAS_1       NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_0_VALUE                          31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA_1                          0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA_1__ALIAS_1       NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_1_VALUE                          31:0 /* RWXVF */
#define NV_PGRAPH_STORED_FMT                             0x00400830 /* RW-4R */
#define NV_PGRAPH_STORED_FMT_MONO0                              5:0 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_MONO0_04A                   0x0000000C /* RWC-V */
#define NV_PGRAPH_STORED_FMT_PATT0                             13:8 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_PATT0_044                   0x0000000B /* RWC-V */
#define NV_PGRAPH_STORED_FMT_PATT1                            21:16 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_PATT1_044                   0x0000000B /* RWC-V */
#define NV_PGRAPH_STORED_FMT_CHROMA                           29:24 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_CHROMA_057                  0x0000000B /* RWC-V */
#define NV_PGRAPH_FORMATS                                0x00400618 /* RW-4R */
#define NV_PGRAPH_FORMATS_ROP                                   2:0 /* R-XVF */
#define NV_PGRAPH_FORMATS_ROP_Y8                         0x00000000 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB15                      0x00000001 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB16                      0x00000002 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_Y16                        0x00000003 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_INVALID                    0x00000004 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB24                      0x00000005 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB30                      0x00000006 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_Y32                        0x00000007 /* -W--V */
#define NV_PGRAPH_FORMATS_SRC                                   9:4 /* R-XVF */
#define NV_PGRAPH_FORMATS_SRC_INVALID                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_Y8                      0x00000001 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16A8Y8                 0x00000002 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X24Y8                   0x00000003 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A1R5G5B5                0x00000006 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X1R5G5B5                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16A1R5G5B5             0x00000008 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X17R5G5B5               0x00000009 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_R5G6B5                  0x0000000A /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A16R5G6B5               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16R5G6B5               0x0000000C /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A8R8G8B8                0x0000000D /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X8R8G8B8                0x0000000E /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_Y16                     0x0000000F /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A16Y16                  0x00000010 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16Y16                  0x00000011 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_V8YB8U8YA8              0x00000012 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_YB8V8YA8U8              0x00000013 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_Y32                     0x00000014 /* RW--V */
#define NV_PGRAPH_FORMATS_FB                                  15:12 /* R-XVF */
#define NV_PGRAPH_FORMATS_FB_INVALID                     0x00000000 /* RWI-V */
#define NV_PGRAPH_FORMATS_FB_Y8                          0x00000001 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1R5G5B5_Z1R5G5B5           0x00000002 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1R5G5B5_O1R5G5B5           0x00000003 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_A1R5G5B5                    0x00000004 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_R5G6B5                      0x00000005 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_Y16                         0x00000006 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X8R8G8B8_Z8R8G8B8           0x00000007 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X8R8G8B8_O1Z7R8G8B8         0x00000008 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1A7R8G8B8_Z1A7R8G8B8       0x00000009 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1A7R8G8B8_O1A7R8G8B8       0x0000000a /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X8R8G8B8_O8R8G8B8           0x0000000b /* RW--V */
#define NV_PGRAPH_FORMATS_FB_A8R8G8B8                    0x0000000c /* RW--V */
#define NV_PGRAPH_FORMATS_FB_Y32                         0x0000000d /* RW--V */
#define NV_PGRAPH_FORMATS_FB_V8YB8U8YA8                  0x0000000e /* RW--V */
#define NV_PGRAPH_FORMATS_FB_YB8V8YA8U8                  0x0000000f /* RW--V */
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400514 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                       17:0 /* RWBUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0               0x00000000 /* RWB-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    20:20 /* RWVVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RWV-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_IMAGE_DATA_64                24:24 /* RWVVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_IMAGE_DATA_64_FALSE     0x00000000 /* RWV-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_IMAGE_DATA_64_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWBUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWB-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400518 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                        0:0 /* RWNVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED          0x00000000 /* RWN-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE            0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UUMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UUMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2                         0x0040051C /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3                         0x00400520 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0                     0:0 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL         0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY                   4:4 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG                     12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL           0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE           0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX                    22:16 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0             0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX                   30:24 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0            0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400500 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x00400504 /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE_019               0x00000000 /* RWC-V */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE_053               0x00000000 /* RWC-V */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE_019               0x00000000 /* RWC-V */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE_053               0x00000000 /* RWC-V */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE_019               0x00000000 /* RWC-V */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE_053               0x00000000 /* RWC-V */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE_019               0x00000000 /* RWC-V */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE_053               0x00000000 /* RWC-V */
#define NV_PGRAPH_ABS_UCLIP3D_XMIN                       0x00400550 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP3D_XMIN_VALUE                       15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP3D_XMAX                       0x00400558 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP3D_XMAX_VALUE                       17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP3D_YMIN                       0x00400554 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP3D_YMIN_VALUE                       15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP3D_YMAX                       0x0040055C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP3D_YMAX_VALUE                       17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWNVF */
#define NV_PGRAPH_SOURCE_COLOR_VALUE_0                   0x00000000 /* RWN-V */
#define NV_PGRAPH_VALID1                                 0x00400508 /* RW-4R */
#define NV_PGRAPH_VALID1_VLD                                   22:0 /* RWNVF */
#define NV_PGRAPH_VALID1_VLD_0                           0x00000000 /* RWN-V */
#define NV_PGRAPH_VALID1_VLD_NOCLIP                       (0x1<<19) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_SRCCOLOR                     (0x1<<16) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTMOVE                      (0x1<<21) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTX01                        (0x3<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTX02                        (0x7<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTX03                        (0xf<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTXCHAIN01                   (0x3<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTXCHAIN02                   (0x7<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTXCHAIN03                   (0xf<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTY01                        (0x3<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTY02                        (0x7<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTY03                        (0xf<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTYCHAIN01                  (0x3<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTYCHAIN02                  (0x7<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTYCHAIN03                  (0xf<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_X_OFFSET                      (0x1<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_XCHAIN_OFFSET                 (0x1<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_Y_OFFSET                      (0x1<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_YCHAIN_OFFSET                (0x1<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCOLOR0                    (0x1<<17) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCOLOR1                    (0x1<<18) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCLIP                      (0x1<<20) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTFONT                      (0x1<<22) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTOFFSET                    (0x1<<22) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTBPITCH                     (0x1<<2) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTBOFFSET                    (0x1<<3) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDUDX                       (0x1<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDVDY                       (0x1<<5) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPOINT                      (0x1<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSIZE                       (0x1<<9) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCH                     (0x1<<10) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSTART                     (0x1<<11) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDUDX2                     (0x1<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDVDY2                     (0x1<<13) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPOINT2                    (0x1<<14) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSIZE2                     (0x1<<15) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCH2                    (0x1<<16) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSTART2                    (0x1<<17) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTOFFSIN                     (0x1<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTOFFSOUT                    (0x1<<1) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCHIN                    (0x1<<2) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCHOUT                   (0x1<<3) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTLENGTH                     (0x1<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCOUNT                      (0x1<<5) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTFORMAT                     (0x1<<6) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTNOTIFY                     (0x1<<7) /* RW--V */
#define NV_PGRAPH_VALID1_CLIP_MIN                             28:28 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIP_MIN_NO_ERROR               0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIP_MIN_ONLY                   0x00000001 /* RW--V */
#define NV_PGRAPH_VALID1_CLIP_MIN_019                    0x00000000 /* RWC-V */
#define NV_PGRAPH_VALID1_CLIP_MIN_053                    0x00000000 /* RWC-V */
#define NV_PGRAPH_VALID1_CLIPA_MIN                            29:29 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIPA_MIN_NO_ERROR              0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIPA_MIN_ONLY                  0x00000001 /* RW--V */
#define NV_PGRAPH_VALID1_CLIP_MAX                             30:30 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIP_MAX_NO_ERROR               0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIP_MAX_ONLY                   0x00000001 /* RW--V */
#define NV_PGRAPH_VALID1_CLIP_MAX_019                    0x00000000 /* RWC-V */
#define NV_PGRAPH_VALID1_CLIP_MAX_053                    0x00000000 /* RWC-V */
#define NV_PGRAPH_VALID1_CLIPA_MAX                            31:31 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIPA_MAX_NO_ERROR              0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIPA_MAX_ONLY                  0x00000001 /* RW--V */
#define NV_PGRAPH_VALID2                                 0x00400578 /* RW-4R */
#define NV_PGRAPH_VALID2_VLD2                                  28:0 /* RWNVF */
#define NV_PGRAPH_VALID2_VLD2_0                          0x00000000 /* RWN-V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE0A               (1<<28) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE0C               (1<<27) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE1A               (1<<26) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE1C               (1<<25) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBFACTOR              (1<<24) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FILTER1                 (1<<23) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_OFFSET1                 (1<<22) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FORMAT1                 (1<<21) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_BLEND                   (1<<20) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_CONTROL2                (1<<19) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_CONTROL1                (1<<18) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_CONTROL0                (1<<17) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FILTER0                 (1<<16) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FORMAT0                 (1<<15) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_OFFSET0                 (1<<14) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FOGCOLOR                (1<<13) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COLORKEY                (1<<12) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_V1                       (1<<9) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_U1                       (1<<8) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_V0                       (1<<7) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_U0                       (1<<6) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_X                        (1<<5) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_Y                        (1<<4) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_ZETA                     (1<<3) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_M                        (1<<2) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COLOR                    (1<<1) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_SPECULAR                 (1<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX3FULLVERTEX               (0x7f<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX5FULLVERTEX               (0x7f<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX6FULLVERTEX              (0x1ff<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX3FULLSTATE               (0x3f<<13) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX5FULLSTATE              (0x1ff<<12) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX6FULLSTATE             (0xffff<<13) /* RW--V */
#define NV_PGRAPH_VALID2_CLIP3D_MIN                           30:30 /* RWIVF */
#define NV_PGRAPH_VALID2_CLIP3D_MIN_NO_ERROR             0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID2_CLIP3D_MIN_ONLY                 0x00000001 /* RW--V */
#define NV_PGRAPH_VALID2_CLIP3D_MAX                           31:31 /* RWIVF */
#define NV_PGRAPH_VALID2_CLIP3D_MAX_NO_ERROR             0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID2_CLIP3D_MAX_ONLY                 0x00000001 /* RW--V */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
#define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXUF */
#define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
#define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXUF */
#define NV_PGRAPH_MISC24_2                               0x00400574 /* RW-4R */
#define NV_PGRAPH_MISC24_2_VALUE                               23:0 /* RWXUF */
#define NV_PGRAPH_PASSTHRU_0                             0x0040057C /* RW-4R */
#define NV_PGRAPH_PASSTHRU_0_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_PASSTHRU_1                             0x00400580 /* RW-4R */
#define NV_PGRAPH_PASSTHRU_1_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_PASSTHRU_2                             0x00400584 /* RW-4R */
#define NV_PGRAPH_PASSTHRU_2_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_DIMX_TEXTURE                           0x00400588 /* RW-4R */
#define NV_PGRAPH_DIMX_TEXTURE_VALUE                           15:0 /* RWXUF */
#define NV_PGRAPH_WDIMX_TEXTURE                          0x0040058c /* RW-4R */
#define NV_PGRAPH_WDIMX_TEXTURE_VALUE                          16:0 /* RWXSF */
#define NV_PGRAPH_U_RAM(i)                       (0x00400d00+(i)*4) /* RW-4A */
#define NV_PGRAPH_U_RAM__SIZE_1                                  16 /*       */
#define NV_PGRAPH_U_RAM_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_V_RAM(i)                       (0x00400d40+(i)*4) /* RW-4A */
#define NV_PGRAPH_V_RAM__SIZE_1                                  16 /*       */
#define NV_PGRAPH_V_RAM_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_M_RAM(i)                       (0x00400d80+(i)*4) /* RW-4A */
#define NV_PGRAPH_M_RAM__SIZE_1                                  16 /*       */
#define NV_PGRAPH_M_RAM_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
#define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_U0                                 0x004005c4 /* RW-4R */
#define NV_PGRAPH_D3D_U0_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_V0                                 0x004005c8 /* RW-4R */
#define NV_PGRAPH_D3D_V0_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_U1                                 0x004005cc /* RW-4R */
#define NV_PGRAPH_D3D_U1_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_V1                                 0x004005d0 /* RW-4R */
#define NV_PGRAPH_D3D_V1_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_ZETA                               0x004005d4 /* RW-4R */
#define NV_PGRAPH_D3D_ZETA_VALUE                               31:0 /* RWXFF */
#define NV_PGRAPH_D3D_RGB                                0x004005d8 /* RW-4R */
#define NV_PGRAPH_D3D_RGB_VALUE                                31:0 /* RWXUF */
#define NV_PGRAPH_D3D_S                                  0x004005dc /* RW-4R */
#define NV_PGRAPH_D3D_S_VALUE                                  31:0 /* RWXUF */
#define NV_PGRAPH_D3D_M                                  0x004005e0 /* RW-4R */
#define NV_PGRAPH_D3D_M_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_FORMAT0                                0x004005A8 /* RW-4R */
#define NV_PGRAPH_FORMAT0_CONTEXT_DMA                           1:1 /* RWXVF */
#define NV_PGRAPH_FORMAT0_CONTEXT_DMA_A                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_CONTEXT_DMA_B                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLORKEYENABLE                        2:2 /* RWXVF */
#define NV_PGRAPH_FORMAT0_COLORKEYENABLE_FALSE           0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLORKEYENABLE_TRUE            0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_ZOH                            5:5 /* RWXVF */
#define NV_PGRAPH_FORMAT0_ORIGIN_ZOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_ZOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_FOH                            7:7 /* RWXVF */
#define NV_PGRAPH_FORMAT0_ORIGIN_FOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_FOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR                                10:8 /* RWXVF */
#define NV_PGRAPH_FORMAT0_COLOR_LE_Y8                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_AY8                   0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_A1R5G5B5              0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_X1R5G5B5              0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_A4R4G4B4              0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_R5G6B5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_A8R8G8B8              0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_X8R8G8B8              0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS                       15:12 /* RWXVF */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_INVALID          0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_1                0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_2                0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_3                0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_4                0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_6                0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_7                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_8                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_9                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_10               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_11               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_12               0x0000000C /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_13               0x0000000D /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_14               0x0000000E /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_15               0x0000000F /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U                         19:16 /* RWXVF */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V                         23:20 /* RWXVF */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU                     26:24 /* RWXVF */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPU                               27:27 /* RWXVF */
#define NV_PGRAPH_FORMAT0_WRAPU_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPU_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV                     30:28 /* RWXVF */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPV                               31:31 /* RWXVF */
#define NV_PGRAPH_FORMAT0_WRAPV_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPV_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1                                0x004005AC /* RW-4R */
#define NV_PGRAPH_FORMAT1_CONTEXT_DMA                           1:1 /* RWXVF */
#define NV_PGRAPH_FORMAT1_CONTEXT_DMA_A                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_CONTEXT_DMA_B                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLORKEYENABLE                        2:2 /* RWXVF */
#define NV_PGRAPH_FORMAT1_COLORKEYENABLE_FALSE           0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLORKEYENABLE_TRUE            0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_ZOH                            5:5 /* RWXVF */
#define NV_PGRAPH_FORMAT1_ORIGIN_ZOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_ZOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_FOH                            7:7 /* RWXVF */
#define NV_PGRAPH_FORMAT1_ORIGIN_FOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_FOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR                                10:8 /* RWXVF */
#define NV_PGRAPH_FORMAT1_COLOR_LE_Y8                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_AY8                   0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_A1R5G5B5              0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_X1R5G5B5              0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_A4R4G4B4              0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_R5G6B5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_A8R8G8B8              0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_X8R8G8B8              0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS                       15:12 /* RWXVF */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_INVALID          0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_1                0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_2                0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_3                0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_4                0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_6                0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_7                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_8                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_9                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_10               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_11               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_12               0x0000000C /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_13               0x0000000D /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_14               0x0000000E /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_15               0x0000000F /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U                         19:16 /* RWXVF */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V                         23:20 /* RWXVF */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU                     26:24 /* RWXVF */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPU                               27:27 /* RWXVF */
#define NV_PGRAPH_FORMAT1_WRAPU_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPU_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV                     30:28 /* RWXVF */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPV                               31:31 /* RWXVF */
#define NV_PGRAPH_FORMAT1_WRAPV_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPV_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_BUNDLE_BASE                            0x00400E00 /* RW-4R */
#define NV_PGRAPH_TEXTUREOFFSET0                         0x00400E00 /* RW-4R */
#define NV_PGRAPH_TEXTUREOFFSET0_BUNDLE                  0x00000000 /* ----B */
#define NV_PGRAPH_TEXTUREOFFSET0_VALUE                         31:0 /* RWXUF */
#define NV_PGRAPH_TEXTUREOFFSET1                         0x00400E04 /* RW-4R */
#define NV_PGRAPH_TEXTUREOFFSET1_BUNDLE                  0x00000001 /* ----B */
#define NV_PGRAPH_TEXTUREOFFSET1_VALUE                         31:0 /* RWXUF */
#define NV_PGRAPH_TEXTUREPALETTE0                        0x00400E08 /* RW-4R */
#define NV_PGRAPH_TEXTUREPALETTE0_BUNDLE                 0x00000002 /* ----B */
#define NV_PGRAPH_TEXTUREPALETTE0_CONTEXT_DMA                   0:0 /* RWXVF */
#define NV_PGRAPH_TEXTUREPALETTE0_CONTEXT_DMA_A          0x00000000 /* RW--V */
#define NV_PGRAPH_TEXTUREPALETTE0_CONTEXT_DMA_B          0x00000001 /* RW--V */
#define NV_PGRAPH_TEXTUREPALETTE0_OFFSET                       31:6 /* RWXUF */
#define NV_PGRAPH_TEXTUREPALETTE1                        0x00400E0C /* RW-4R */
#define NV_PGRAPH_TEXTUREPALETTE1_BUNDLE                 0x00000003 /* ----B */
#define NV_PGRAPH_TEXTUREPALETTE1_CONTEXT_DMA                   0:0 /* RWXVF */
#define NV_PGRAPH_TEXTUREPALETTE1_CONTEXT_DMA_A          0x00000000 /* RW--V */
#define NV_PGRAPH_TEXTUREPALETTE1_CONTEXT_DMA_B          0x00000001 /* RW--V */
#define NV_PGRAPH_TEXTUREPALETTE1_OFFSET                       31:6 /* RWXUF */
#define NV_PGRAPH_TEXFORMAT0                             0x00400E10 /* RW-4R */
#define NV_PGRAPH_TEXFORMAT0_BUNDLE                      0x00000004 /* ----B */
#define NV_PGRAPH_TEXFORMAT0_CONTEXT_DMA                        1:1 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_CONTEXT_DMA_A               0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_CONTEXT_DMA_B               0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_CUBEMAPENABLE                      2:2 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_CUBEMAPENABLE_OFF           0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_CUBEMAPENABLE_ON            0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_ORIGIN_ZOH                         4:4 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_ORIGIN_ZOH_CENTER           0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_ORIGIN_ZOH_CORNER           0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_ORIGIN_FOH                         6:6 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_ORIGIN_FOH_CENTER           0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_ORIGIN_FOH_CORNER           0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR                             11:7 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_Y8                 0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_AY8                0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_A1R5G5B5           0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_X1R5G5B5           0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_A4R4G4B4           0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_R5G6B5             0x00000005 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_A8R8G8B8           0x00000006 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_X8R8G8B8           0x00000007 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_I8_A1R5G5B5        0x00000008 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_I8_R5G6B5          0x00000009 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_I8_A4R4G4B4        0x0000000A /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_I8_A8R8G8B8        0x0000000B /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_DXT1_A1R5G5B5      0x0000000C /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_DXT23_A8R8G8B8     0x0000000E /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_DXT45_A8R8G8B8     0x0000000F /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_IMAGE_A1R5G5B5     0x00000010 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_IMAGE_R5G6B5       0x00000011 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_IMAGE_A8R8G8B8     0x00000012 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_IMAGE_Y8           0x00000013 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_IMAGE_SY8          0x00000014 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_IMAGE_X7SY9        0x00000015 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_IMAGE_R8B8         0x00000016 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_IMAGE_G8B8         0x00000017 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_COLOR_LE_IMAGE_SG8SB8       0x00000018 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS                    15:12 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_INVALID       0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_1             0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_2             0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_3             0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_4             0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_5             0x00000005 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_6             0x00000006 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_7             0x00000007 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_8             0x00000008 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_9             0x00000009 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_10            0x0000000A /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_11            0x0000000B /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_MIPMAP_LEVELS_12            0x0000000C /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U                      19:16 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_1               0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_2               0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_4               0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_8               0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_16              0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_32              0x00000005 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_64              0x00000006 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_128             0x00000007 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_256             0x00000008 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_512             0x00000009 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_1024            0x0000000A /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_U_2048            0x0000000B /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V                      23:20 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_1               0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_2               0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_4               0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_8               0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_16              0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_32              0x00000005 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_64              0x00000006 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_128             0x00000007 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_256             0x00000008 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_512             0x00000009 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_1024            0x0000000A /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_BASE_SIZE_V_2048            0x0000000B /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSU                  26:24 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSU_WRAP        0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSU_MIRROR      0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSU_CLAMP       0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSU_BORDER      0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_WRAPU                            27:27 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_WRAPU_FALSE                 0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_WRAPU_TRUE                  0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSV                  30:28 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSV_WRAP        0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSV_MIRROR      0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSV_CLAMP       0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_TEXTUREADDRESSV_BORDER      0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_WRAPV                            31:31 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT0_WRAPV_FALSE                 0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT0_WRAPV_TRUE                  0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1                             0x00400E14 /* RW-4R */
#define NV_PGRAPH_TEXFORMAT1_BUNDLE                      0x00000005 /* ----B */
#define NV_PGRAPH_TEXFORMAT1_CONTEXT_DMA                        1:1 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_CONTEXT_DMA_A               0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_CONTEXT_DMA_B               0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_CUBEMAPENABLE                      2:2 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_CUBEMAPENABLE_OFF           0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_CUBEMAPENABLE_ON            0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_ORIGIN_ZOH                         4:4 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_ORIGIN_ZOH_CENTER           0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_ORIGIN_ZOH_CORNER           0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_ORIGIN_FOH                         6:6 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_ORIGIN_FOH_CENTER           0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_ORIGIN_FOH_CORNER           0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR                             11:7 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_Y8                 0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_AY8                0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_A1R5G5B5           0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_X1R5G5B5           0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_A4R4G4B4           0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_R5G6B5             0x00000005 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_A8R8G8B8           0x00000006 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_X8R8G8B8           0x00000007 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_I8_A1R5G5B5        0x00000008 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_I8_R5G6B5          0x00000009 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_I8_A4R4G4B4        0x0000000A /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_I8_A8R8G8B8        0x0000000B /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_DXT1_A1R5G5B5      0x0000000C /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_DXT23_A8R8G8B8     0x0000000E /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_DXT45_A8R8G8B8     0x0000000F /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_IMAGE_A1R5G5B5     0x00000010 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_IMAGE_R5G6B5       0x00000011 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_IMAGE_A8R8G8B8     0x00000012 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_IMAGE_Y8           0x00000013 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_IMAGE_SY8          0x00000014 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_IMAGE_X7SY9        0x00000015 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_IMAGE_R8B8         0x00000016 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_IMAGE_G8B8         0x00000017 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_COLOR_LE_IMAGE_SG8SB8       0x00000018 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS                    15:12 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_INVALID       0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_1             0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_2             0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_3             0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_4             0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_5             0x00000005 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_6             0x00000006 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_7             0x00000007 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_8             0x00000008 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_9             0x00000009 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_10            0x0000000A /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_11            0x0000000B /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_12            0x0000000C /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_13            0x0000000D /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_14            0x0000000E /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_MIPMAP_LEVELS_15            0x0000000F /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U                      19:16 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_1               0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_2               0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_4               0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_8               0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_16              0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_32              0x00000005 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_64              0x00000006 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_128             0x00000007 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_256             0x00000008 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_512             0x00000009 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_1024            0x0000000A /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_U_2048            0x0000000B /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V                      23:20 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_1               0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_2               0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_4               0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_8               0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_16              0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_32              0x00000005 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_64              0x00000006 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_128             0x00000007 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_256             0x00000008 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_512             0x00000009 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_1024            0x0000000A /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_BASE_SIZE_V_2048            0x0000000B /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSU                  26:24 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSU_WRAP        0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSU_MIRROR      0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSU_CLAMP       0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSU_BORDER      0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_WRAPU                            27:27 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_WRAPU_FALSE                 0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_WRAPU_TRUE                  0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSV                  30:28 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSV_WRAP        0x00000001 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSV_MIRROR      0x00000002 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSV_CLAMP       0x00000003 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_TEXTUREADDRESSV_BORDER      0x00000004 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_WRAPV                            31:31 /* RWXVF */
#define NV_PGRAPH_TEXFORMAT1_WRAPV_FALSE                 0x00000000 /* RW--V */
#define NV_PGRAPH_TEXFORMAT1_WRAPV_TRUE                  0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0                          0x00400E18 /* RW-4R */
#define NV_PGRAPH_TEXCONTROL0_0_BUNDLE                   0x00000006 /* ----B */
#define NV_PGRAPH_TEXCONTROL0_0_COLORKEY_OP                     1:0 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_0_COLORKEY_OP_DISABLE      0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_COLORKEY_OP_CHANGE_ALPHA 0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_COLORKEY_OP_CHANGE_ALL   0x00000002 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_COLORKEY_OP_MATCH_KILL   0x00000003 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_ALPHAKILLENABLE                 2:2 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_0_ALPHAKILLENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_ALPHAKILLENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_FIELDENABLE                     3:3 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_0_FIELDENABLE_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_FIELDENABLE_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_LOGMAXANISO                     5:4 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_0_LOGMAXANISO_1            0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_LOGMAXANISO_2            0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_MAXLODCLAMP                    17:6 /* RWXSF */
#define NV_PGRAPH_TEXCONTROL0_0_MINLODCLAMP                   29:18 /* RWXSF */
#define NV_PGRAPH_TEXCONTROL0_0_ENABLE                        30:30 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_0_ENABLE_FALSE             0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_0_ENABLE_TRUE              0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1                          0x00400E1C /* RW-4R */
#define NV_PGRAPH_TEXCONTROL0_1_BUNDLE                   0x00000007 /* ----B */
#define NV_PGRAPH_TEXCONTROL0_1_COLORKEY_OP                     1:0 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_1_COLORKEY_OP_DISABLE      0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_COLORKEY_OP_CHANGE_ALPHA 0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_COLORKEY_OP_CHANGE_ALL   0x00000002 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_COLORKEY_OP_MATCH_KILL   0x00000003 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_ALPHAKILLENABLE                 2:2 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_1_ALPHAKILLENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_ALPHAKILLENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_FIELDENABLE                     3:3 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_1_FIELDENABLE_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_FIELDENABLE_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_LOGMAXANISO                     5:4 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_1_LOGMAXANISO_1            0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_LOGMAXANISO_2            0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_MAXLODCLAMP                    17:6 /* RWXSF */
#define NV_PGRAPH_TEXCONTROL0_1_MINLODCLAMP                   29:18 /* RWXSF */
#define NV_PGRAPH_TEXCONTROL0_1_ENABLE                        30:30 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL0_1_ENABLE_FALSE             0x00000000 /* RW--V */
#define NV_PGRAPH_TEXCONTROL0_1_ENABLE_TRUE              0x00000001 /* RW--V */
#define NV_PGRAPH_TEXCONTROL1_0                          0x00400E20 /* RW-4R */
#define NV_PGRAPH_TEXCONTROL1_0_BUNDLE                   0x00000008 /* ----B */
#define NV_PGRAPH_TEXCONTROL1_0_IMAGEPITCH                    31:16 /* RWXUF */
#define NV_PGRAPH_TEXCONTROL1_1                          0x00400E24 /* RW-4R */
#define NV_PGRAPH_TEXCONTROL1_1_BUNDLE                   0x00000009 /* ----B */
#define NV_PGRAPH_TEXCONTROL1_1_IMAGEPITCH                    31:16 /* RWXUF */
#define NV_PGRAPH_TEXCONTROL2_0                          0x00400E28 /* RW-4R */
#define NV_PGRAPH_TEXCONTROL2_0_BUNDLE                   0x0000000A /* ----B */
#define NV_PGRAPH_TEXCONTROL2_0_PERTURB_DU                     11:0 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL2_0_PERTURB_DV                    23:12 /* RWXUF */
#define NV_PGRAPH_TEXCONTROL2_0_IMAGE_LODF                    31:24 /* RWXUF */
#define NV_PGRAPH_TEXCONTROL2_1                          0x00400E2C /* RW-4R */
#define NV_PGRAPH_TEXCONTROL2_1_BUNDLE                   0x0000000B /* ----B */
#define NV_PGRAPH_TEXCONTROL2_1_PERTURB_DU                     11:0 /* RWXVF */
#define NV_PGRAPH_TEXCONTROL2_1_PERTURB_DV                    23:12 /* RWXUF */
#define NV_PGRAPH_TEXCONTROL2_1_IMAGE_LODF                    31:24 /* RWXUF */
#define NV_PGRAPH_IMAGERECT0                             0x00400E30 /* RW-4R */
#define NV_PGRAPH_IMAGERECT0_BUNDLE                      0x0000000C /* ----B */
#define NV_PGRAPH_IMAGERECT0_HEIGHT                            10:0 /* RWXUF */
#define NV_PGRAPH_IMAGERECT0_WIDTH                            26:16 /* RWXUF */
#define NV_PGRAPH_IMAGERECT1                             0x00400E34 /* RW-4R */
#define NV_PGRAPH_IMAGERECT1_BUNDLE                      0x0000000D /* ----B */
#define NV_PGRAPH_IMAGERECT1_HEIGHT                            10:0 /* RWXUF */
#define NV_PGRAPH_IMAGERECT1_WIDTH                            26:16 /* RWXUF */
#define NV_PGRAPH_FILTER0                                0x004005B0 /* RW-4R */
#define NV_PGRAPH_FILTER0_BUNDLE                         0x0000000E /* ----B */
#define NV_PGRAPH_FILTER0_KERNEL_SIZE_X                         4:1 /* RWXUF */
#define NV_PGRAPH_FILTER0_KERNEL_SIZE_Y                        12:9 /* RWXUF */
#define NV_PGRAPH_FILTER0_MIPMAP_DITHER_ENABLE                15:15 /* RWXVF */
#define NV_PGRAPH_FILTER0_MIPMAP_DITHER_ENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER0_MIPMAP_DITHER_ENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_MIPMAPLODBIAS                       23:16 /* RWXSF */
#define NV_PGRAPH_FILTER0_TEXTUREMIN                          26:24 /* RWXVF */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MIN_ENABLE              27:27 /* RWXVF */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MIN_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MIN_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG                          30:28 /* RWXVF */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MAG_ENABLE              31:31 /* RWXVF */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MAG_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MAG_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1                                0x004005B4 /* RW-4R */
#define NV_PGRAPH_FILTER1_BUNDLE                         0x0000000F /* ----B */
#define NV_PGRAPH_FILTER1_KERNEL_SIZE_X                         4:1 /* RWXUF */
#define NV_PGRAPH_FILTER1_KERNEL_SIZE_Y                        12:9 /* RWXUF */
#define NV_PGRAPH_FILTER1_MIPMAPLODBIAS                       23:16 /* RWXSF */
#define NV_PGRAPH_FILTER1_MIPMAP_DITHER_ENABLE                15:15 /* RWXVF */
#define NV_PGRAPH_FILTER1_MIPMAP_DITHER_ENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER1_MIPMAP_DITHER_ENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN                          26:24 /* RWXVF */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MIN_ENABLE              27:27 /* RWXVF */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MIN_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MIN_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG                          30:28 /* RWXVF */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MAG_ENABLE              31:31 /* RWXVF */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MAG_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MAG_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW                       0x00400E40 /* RW-4R */
#define NV_PGRAPH_COMBINE0ALPHAICW_BUNDLE                0x00000010 /* ----B */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE                     3:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_ALPHA                      4:4 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_ALPHA_FROMBLUE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_ALPHA_FROMALPHA     0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_MAP                        7:5 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_D_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE                    11:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_ALPHA                    12:12 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_ALPHA_FROMBLUE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_ALPHA_FROMALPHA     0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_MAP                      15:13 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_C_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE                   19:16 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_ALPHA                    20:20 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_ALPHA_FROMBLUE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_ALPHA_FROMALPHA     0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_MAP                      23:21 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_B_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE                   27:24 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_ALPHA                    28:28 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_ALPHA_FROMBLUE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_ALPHA_FROMALPHA     0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_MAP                      31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAICW_A_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW                       0x00400E44 /* RW-4R */
#define NV_PGRAPH_COMBINE1ALPHAICW_BUNDLE                0x00000011 /* ----B */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE                     3:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_ALPHA                      4:4 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_ALPHA_FROMBLUE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_ALPHA_FROMALPHA     0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_MAP                        7:5 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_D_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE                    11:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_ALPHA                    12:12 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_ALPHA_FROMBLUE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_ALPHA_FROMALPHA     0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_MAP                      15:13 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_C_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE                   19:16 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_ALPHA                    20:20 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_ALPHA_FROMBLUE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_ALPHA_FROMALPHA     0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_MAP                      23:21 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_B_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE                   27:24 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_ALPHA                    28:28 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_ALPHA_FROMBLUE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_ALPHA_FROMALPHA     0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_MAP                      31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAICW_A_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW                       0x00400E48 /* RW-4R */
#define NV_PGRAPH_COMBINE0COLORICW_BUNDLE                0x00000012 /* ----B */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE                     3:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_ALPHA                      4:4 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_D_ALPHA_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_ALPHA_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_MAP                        7:5 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_D_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_D_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE                    11:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_ALPHA                    12:12 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_C_ALPHA_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_ALPHA_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_MAP                      15:13 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_C_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_C_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE                   19:16 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_ALPHA                    20:20 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_B_ALPHA_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_ALPHA_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_MAP                      23:21 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_B_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_B_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE                   27:24 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_ALPHA                    28:28 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_A_ALPHA_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_ALPHA_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_MAP                      31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLORICW_A_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLORICW_A_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW                       0x00400E4C /* RW-4R */
#define NV_PGRAPH_COMBINE1COLORICW_BUNDLE                0x00000013 /* ----B */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE                     3:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_ALPHA                      4:4 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_D_ALPHA_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_ALPHA_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_MAP                        7:5 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_D_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_D_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE                    11:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_ALPHA                    12:12 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_C_ALPHA_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_ALPHA_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_MAP                      15:13 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_C_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_C_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE                   19:16 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_ALPHA                    20:20 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_B_ALPHA_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_ALPHA_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_MAP                      23:21 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_B_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_B_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE                   27:24 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_R0           0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_R1           0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_R2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_R3           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_R4           0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_R5           0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_R8           0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_R9           0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_RC           0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_SOURCE_RD           0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_ALPHA                    28:28 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_A_ALPHA_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_ALPHA_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_MAP                      31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLORICW_A_MAP_UNSIGNED_IDENT  0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_MAP_UNSIGNED_INVERT 0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_MAP_EXPAND_NORMAL   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_MAP_EXPAND_NEGATE   0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_MAP_HALFBIAS_NORMAL 0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_MAP_HALFBIAS_NEGATE 0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_MAP_SIGNED_IDENTITY 0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLORICW_A_MAP_SIGNED_NEGATE   0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0FACTOR                         0x00400E50 /* RW-4R */
#define NV_PGRAPH_COMBINE0FACTOR_BUNDLE                  0x00000014 /* ----B */
#define NV_PGRAPH_COMBINE0FACTOR_BLUE                           7:0 /* RWXUF */
#define NV_PGRAPH_COMBINE0FACTOR_GREEN                         15:8 /* RWXUF */
#define NV_PGRAPH_COMBINE0FACTOR_RED                          23:16 /* RWXUF */
#define NV_PGRAPH_COMBINE0FACTOR_ALPHA                        31:24 /* RWXUF */
#define NV_PGRAPH_COMBINE1FACTOR                         0x00400E54 /* RW-4R */
#define NV_PGRAPH_COMBINE1FACTOR_BUNDLE                  0x00000015 /* ----B */
#define NV_PGRAPH_COMBINE1FACTOR_BLUE                           7:0 /* RWXUF */
#define NV_PGRAPH_COMBINE1FACTOR_GREEN                         15:8 /* RWXUF */
#define NV_PGRAPH_COMBINE1FACTOR_RED                          23:16 /* RWXUF */
#define NV_PGRAPH_COMBINE1FACTOR_ALPHA                        31:24 /* RWXUF */
#define NV_PGRAPH_COMBINE0ALPHAOCW                       0x00400E58 /* RW-4R */
#define NV_PGRAPH_COMBINE0ALPHAOCW_BUNDLE                0x00000016 /* ----B */
#define NV_PGRAPH_COMBINE0ALPHAOCW_CD_DST                       3:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAOCW_CD_DST_R0             0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_CD_DST_R4             0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_CD_DST_R5             0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_CD_DST_R8             0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_CD_DST_R9             0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_CD_DST_RC             0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_CD_DST_RD             0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_AB_DST                       7:4 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAOCW_AB_DST_R0             0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_AB_DST_R4             0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_AB_DST_R5             0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_AB_DST_R8             0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_AB_DST_R9             0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_AB_DST_RC             0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_AB_DST_RD             0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_SUM_DST                     11:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAOCW_SUM_DST_R0            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_SUM_DST_R4            0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_SUM_DST_R5            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_SUM_DST_R8            0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_SUM_DST_R9            0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_SUM_DST_RC            0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_SUM_DST_RD            0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_MUX_ENABLE                 14:14 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAOCW_MUX_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_MUX_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_OPERATION                  17:15 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHAOCW_OPERATION_NOSHIFT     0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_OPERATION_BIAS        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_OPERATION_LEFT1       0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_OPERATION_LEFT1_BIAS  0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_OPERATION_LEFT2       0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHAOCW_OPERATION_RIGHT1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW                       0x00400E5C /* RW-4R */
#define NV_PGRAPH_COMBINE1ALPHAOCW_BUNDLE                0x00000017 /* ----B */
#define NV_PGRAPH_COMBINE1ALPHAOCW_CD_DST                       3:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAOCW_CD_DST_R0             0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_CD_DST_R4             0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_CD_DST_R5             0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_CD_DST_R8             0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_CD_DST_R9             0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_CD_DST_RC             0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_CD_DST_RD             0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_AB_DST                       7:4 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAOCW_AB_DST_R0             0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_AB_DST_R4             0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_AB_DST_R5             0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_AB_DST_R8             0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_AB_DST_R9             0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_AB_DST_RC             0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_AB_DST_RD             0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_SUM_DST                     11:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAOCW_SUM_DST_R0            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_SUM_DST_R4            0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_SUM_DST_R5            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_SUM_DST_R8            0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_SUM_DST_R9            0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_SUM_DST_RC            0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_SUM_DST_RD            0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_MUX_ENABLE                 14:14 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAOCW_MUX_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_MUX_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_OPERATION                  17:15 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHAOCW_OPERATION_NOSHIFT     0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_OPERATION_BIAS        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_OPERATION_LEFT1       0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_OPERATION_LEFT1_BIAS  0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_OPERATION_LEFT2       0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHAOCW_OPERATION_RIGHT1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA                          0x00400590 /* RW-4R */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR                          0x00400594 /* RW-4R */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_0                         1:1 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_0_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_0_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_1                         9:9 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_1_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_1_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_2                       17:17 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_2_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_2_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_3                       25:25 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_3_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_3_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA                          0x00400598 /* RW-4R */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR                          0x0040059C /* RW-4R */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_0                         1:1 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_0_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_0_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_1                         9:9 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_1_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_1_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_2                       17:17 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_2_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_2_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_3                       25:25 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_3_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_3_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW                       0x00400E60 /* RW-4R */
#define NV_PGRAPH_COMBINE0COLOROCW_BUNDLE                0x00000018 /* ----B */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DST                       3:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DST_R0             0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DST_R4             0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DST_R5             0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DST_R8             0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DST_R9             0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DST_RC             0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DST_RD             0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DST                       7:4 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DST_R0             0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DST_R4             0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DST_R5             0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DST_R8             0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DST_R9             0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DST_RC             0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DST_RD             0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_SUM_DST                     11:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOROCW_SUM_DST_R0            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_SUM_DST_R4            0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_SUM_DST_R5            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_SUM_DST_R8            0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_SUM_DST_R9            0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_SUM_DST_RC            0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_SUM_DST_RD            0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DOT_ENABLE              12:12 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DOT_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_CD_DOT_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DOT_ENABLE              13:13 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DOT_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_AB_DOT_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_MUX_ENABLE                 14:14 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOROCW_MUX_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_MUX_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_OPERATION                  17:15 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOROCW_OPERATION_NOSHIFT     0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_OPERATION_BIAS        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_OPERATION_LEFT1       0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_OPERATION_LEFT1_BIAS  0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_OPERATION_LEFT2       0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOROCW_OPERATION_RIGHT1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW                       0x00400E64 /* RW-4R */
#define NV_PGRAPH_COMBINE1COLOROCW_BUNDLE                0x00000019 /* ----B */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DST                       3:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DST_R0             0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DST_R4             0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DST_R5             0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DST_R8             0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DST_R9             0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DST_RC             0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DST_RD             0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DST                       7:4 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DST_R0             0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DST_R4             0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DST_R5             0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DST_R8             0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DST_R9             0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DST_RC             0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DST_RD             0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_SUM_DST                     11:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOROCW_SUM_DST_R0            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_SUM_DST_R4            0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_SUM_DST_R5            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_SUM_DST_R8            0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_SUM_DST_R9            0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_SUM_DST_RC            0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_SUM_DST_RD            0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DOT_ENABLE              12:12 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DOT_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_CD_DOT_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DOT_ENABLE              13:13 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DOT_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_AB_DOT_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_MUX_ENABLE                 14:14 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOROCW_MUX_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_MUX_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_OPERATION                  17:15 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOROCW_OPERATION_NOSHIFT     0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_OPERATION_BIAS        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_OPERATION_LEFT1       0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_OPERATION_LEFT1_BIAS  0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_OPERATION_LEFT2       0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_OPERATION_RIGHT1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_MUX_SELECT                 27:27 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOROCW_MUX_SELECT_LSB        0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_MUX_SELECT_MSB        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_ITERATION_COUNT            29:28 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOROCW_ITERATION_COUNT_ONE   0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOROCW_ITERATION_COUNT_TWO   0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0                      0x00400E68 /* RW-4R */
#define NV_PGRAPH_COMBINESPECFOGCW0_BUNDLE               0x0000001A /* ----B */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE                    3:0 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_R0          0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_R1          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_R2          0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_R3          0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_R4          0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_R5          0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_R8          0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_R9          0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_RC          0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_RD          0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_RE          0x0000000E /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_SOURCE_RF          0x0000000F /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_ALPHA                     4:4 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_ALPHA_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_ALPHA_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_INVERSE                   5:5 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_INVERSE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_D_INVERSE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE                   11:8 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_R0          0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_R1          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_R2          0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_R3          0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_R4          0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_R5          0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_R8          0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_R9          0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_RC          0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_RD          0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_RE          0x0000000E /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_SOURCE_RF          0x0000000F /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_ALPHA                   12:12 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_ALPHA_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_ALPHA_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_INVERSE                 13:13 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_INVERSE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_C_INVERSE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE                  19:16 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_R0          0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_R1          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_R2          0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_R3          0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_R4          0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_R5          0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_R8          0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_R9          0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_RC          0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_RD          0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_RE          0x0000000E /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_SOURCE_RF          0x0000000F /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_ALPHA                   20:20 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_ALPHA_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_ALPHA_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_INVERSE                 21:21 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_INVERSE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_B_INVERSE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE                  27:24 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_R0          0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_R1          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_R2          0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_R3          0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_R4          0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_R5          0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_R8          0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_R9          0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_RC          0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_RD          0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_RE          0x0000000E /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_SOURCE_RF          0x0000000F /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_ALPHA                   28:28 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_ALPHA_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_ALPHA_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_INVERSE                 29:29 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_INVERSE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW0_A_INVERSE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1                      0x00400E6C /* RW-4R */
#define NV_PGRAPH_COMBINESPECFOGCW1_BUNDLE               0x0000001B /* ----B */
#define NV_PGRAPH_COMBINESPECFOGCW1_ADDINV_R12                  5:5 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_ADDINV_R12_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_ADDINV_R12_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_ADDINV_R5                   6:6 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_ADDINV_R5_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_ADDINV_R5_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_SPECCLAMP                   7:7 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_SPECCLAMP_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_SPECCLAMP_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE                   11:8 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_R0          0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_R1          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_R2          0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_R3          0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_R4          0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_R5          0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_R8          0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_R9          0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_RC          0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_SOURCE_RD          0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_ALPHA                   12:12 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_ALPHA_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_ALPHA_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_INVERSE                 13:13 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_INVERSE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_G_INVERSE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE                  19:16 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_R0          0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_R1          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_R2          0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_R3          0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_R4          0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_R5          0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_R8          0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_R9          0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_RC          0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_SOURCE_RD          0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_ALPHA                   20:20 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_ALPHA_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_ALPHA_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_INVERSE                 21:21 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_INVERSE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_F_INVERSE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE                  27:24 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_R0          0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_R1          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_R2          0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_R3          0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_R4          0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_R5          0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_R8          0x00000008 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_R9          0x00000009 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_RC          0x0000000C /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_SOURCE_RD          0x0000000D /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_ALPHA                   28:28 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_ALPHA_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_ALPHA_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_INVERSE                 29:29 /* RWXVF */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_INVERSE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINESPECFOGCW1_E_INVERSE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0                               0x00400818 /* RW-4R */
#define NV_PGRAPH_CONTROL0_BUNDLE                        0x0000001C /* ----B */
#define NV_PGRAPH_CONTROL0_ALPHAREF                             7:0 /* RWXUF */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC                           11:8 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_NEVER               0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_LESS                0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_EQUAL               0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_LESSEQUAL           0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_GREATER             0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_NOTEQUAL            0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_GREATEREQUAL        0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_ALWAYS              0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHATESTENABLE                    12:12 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ALPHATESTENABLE_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHATESTENABLE_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ORIGIN                             13:13 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ORIGIN_CENTER                 0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ORIGIN_CORNER                 0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZENABLE                            14:14 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ZENABLE_FALSE                 0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZENABLE_TRUE                  0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC                              19:16 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ZFUNC_NEVER                   0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_LESS                    0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_EQUAL                   0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_LESSEQUAL               0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_GREATER                 0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_NOTEQUAL                0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_GREATEREQUAL            0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_ALWAYS                  0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL0_CULLMODE                           21:20 /* RWXVF */
#define NV_PGRAPH_CONTROL0_CULLMODE_NONE                 0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_CULLMODE_CW                   0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL0_CULLMODE_CCW                  0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL0_DITHERENABLE                       22:22 /* RWXVF */
#define NV_PGRAPH_CONTROL0_DITHERENABLE_FALSE            0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_DITHERENABLE_TRUE             0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_PERSPECTIVE_ENABLE               23:23 /* RWXVF */
#define NV_PGRAPH_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZWRITEENABLE                       24:24 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ZWRITEENABLE_FALSE            0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZWRITEENABLE_TRUE             0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_STENCIL_WRITE_ENABLE               25:25 /* RWXVF */
#define NV_PGRAPH_CONTROL0_STENCIL_WRITE_ENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_STENCIL_WRITE_ENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHA_WRITE_ENABLE                 26:26 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ALPHA_WRITE_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHA_WRITE_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_RED_WRITE_ENABLE                   27:27 /* RWXVF */
#define NV_PGRAPH_CONTROL0_RED_WRITE_ENABLE_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_RED_WRITE_ENABLE_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_GREEN_WRITE_ENABLE                 28:28 /* RWXVF */
#define NV_PGRAPH_CONTROL0_GREEN_WRITE_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_GREEN_WRITE_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_BLUE_WRITE_ENABLE                  29:29 /* RWXVF */
#define NV_PGRAPH_CONTROL0_BLUE_WRITE_ENABLE_FALSE       0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_BLUE_WRITE_ENABLE_TRUE        0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_FORMAT                           31:30 /* RWXVF */
#define NV_PGRAPH_CONTROL0_Z_FORMAT_FIXED                0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_FORMAT_FLOAT                0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL1                               0x0040081c /* RW-4R */
#define NV_PGRAPH_CONTROL1_BUNDLE                        0x0000001D /* ----B */
#define NV_PGRAPH_CONTROL1_STENCIL_TEST_ENABLE                  0:0 /* RWXVF */
#define NV_PGRAPH_CONTROL1_STENCIL_TEST_ENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_TEST_ENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC                         7:4 /* RWXVF */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_NEVER            0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_LESS             0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_EQUAL            0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_LESSEQUAL        0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_GREATER          0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_NOTEQUAL         0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_GREATEREQUAL     0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_ALWAYS           0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_REF                         15:8 /* RWXUF */
#define NV_PGRAPH_CONTROL1_STENCIL_MASK_READ                  23:16 /* RWXUF */
#define NV_PGRAPH_CONTROL1_STENCIL_MASK_WRITE                 31:24 /* RWXUF */
#define NV_PGRAPH_CONTROL2                               0x00400820 /* RW-4R */
#define NV_PGRAPH_CONTROL2_BUNDLE                        0x0000001E /* ----B */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL                      3:0 /* RWXVF */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_KEEP          0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_ZERO          0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_REPLACE       0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_INCRSAT       0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_DECRSAT       0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_INVERT        0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_INCR          0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_DECR          0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL                     7:4 /* RWXVF */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_KEEP         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_ZERO         0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_REPLACE      0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT      0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT      0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_INVERT       0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_INCR         0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_DECR         0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS                    11:8 /* RWXVF */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_KEEP         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_ZERO         0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_REPLACE      0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_INCRSAT      0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_DECRSAT      0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_INVERT       0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_INCR         0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_DECR         0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL3                               0x00400E7C /* RW-4R */
#define NV_PGRAPH_CONTROL3_BUNDLE                        0x0000001F /* ----B */
#define NV_PGRAPH_CONTROL3_FLATSHADE_OP                         0:0 /* RWXVF */
#define NV_PGRAPH_CONTROL3_FLATSHADE_OP_LASTVTX          0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL3_FLATSHADE_OP_FIRSTVTX         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL3_PREMULTALPHA                         2:2 /* RWXVF */
#define NV_PGRAPH_CONTROL3_PREMULTALPHA_FALSE            0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL3_PREMULTALPHA_TRUE             0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL3_TEXTUREMAPBLEND                      4:4 /* RWXVF */
#define NV_PGRAPH_CONTROL3_SPECULARENABLE                       5:5 /* RWXVF */
#define NV_PGRAPH_CONTROL3_SPECULARENABLE_FALSE          0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL3_SPECULARENABLE_TRUE           0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL3_TEXTUREPERSPECTIVE                   6:6 /* RWXVF */
#define NV_PGRAPH_CONTROL3_TEXTUREPERSPECTIVE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL3_TEXTUREPERSPECTIVE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL3_SHADEMODE                            7:7 /* RWXVF */
#define NV_PGRAPH_CONTROL3_SHADEMODE_FLAT                0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL3_SHADEMODE_GOURAUD             0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL3_FOGENABLE                            8:8 /* RWXVF */
#define NV_PGRAPH_CONTROL3_FOGENABLE_FALSE               0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL3_FOGENABLE_TRUE                0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL3_POINT_PARAMS_EN                      9:9 /* RWXVF */
#define NV_PGRAPH_CONTROL3_POINT_PARAMS_EN_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL3_POINT_PARAMS_EN_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL3_W_BUFFER_SELECT                    13:10 /* RWXVF */
#define NV_PGRAPH_CONTROL3_W_BUFFER_SELECT_0             0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL3_W_BUFFER_SELECT_1             0x00000001 /* RW--V */
#define NV_PGRAPH_BLEND                                  0x00400824 /* RW-4R */
#define NV_PGRAPH_BLEND_BUNDLE                           0x00000020 /* ----B */
#define NV_PGRAPH_BLEND_BLENDEQUATION                           2:0 /* RWXVF */
#define NV_PGRAPH_BLEND_BLENDEQUATION_SUBTRACT           0x00000000 /* RW--V */
#define NV_PGRAPH_BLEND_BLENDEQUATION_REVSUBTRACT        0x00000001 /* RW--V */
#define NV_PGRAPH_BLEND_BLENDEQUATION_ADD                0x00000002 /* RW--V */
#define NV_PGRAPH_BLEND_BLENDEQUATION_MIN                0x00000003 /* RW--V */
#define NV_PGRAPH_BLEND_BLENDEQUATION_MAX                0x00000004 /* RW--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND                         3:0 /* -WXVF */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_DECAL            0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_MODULATE         0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_DECALALPHA       0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_MODULATEALPHA    0x00000004 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_DECALMASK        0x00000005 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_MODULATEMASK     0x00000006 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_COPY             0x00000007 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_ADD              0x00000008 /* -W--V */
#define NV_PGRAPH_BLEND_MASK_BIT                                5:4 /* -WXVF */
#define NV_PGRAPH_BLEND_MASK_BIT_LSB                     0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_MASK_BIT_MSB                     0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_SHADEMODE                               7:6 /* -WXVF */
#define NV_PGRAPH_BLEND_SHADEMODE_FLAT                   0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SHADEMODE_GOURAUD                0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_SHADEMODE_PHONG                  0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREPERSPECTIVE                      8:8 /* -WXVF */
#define NV_PGRAPH_BLEND_TEXTUREPERSPECTIVE_FALSE         0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREPERSPECTIVE_TRUE          0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SPECULARENABLE                        12:12 /* -WXVF */
#define NV_PGRAPH_BLEND_SPECULARENABLE_FALSE             0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_SPECULARENABLE_TRUE              0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_FOGENABLE                             16:16 /* -WXVF */
#define NV_PGRAPH_BLEND_FOGENABLE_FALSE                  0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_FOGENABLE_TRUE                   0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_ALPHABLENDENABLE                      20:20 /* -WXVF */
#define NV_PGRAPH_BLEND_ALPHABLENDENABLE_FALSE           0x00000000 /* RW--V */
#define NV_PGRAPH_BLEND_ALPHABLENDENABLE_TRUE            0x00000001 /* RW--V */
#define NV_PGRAPH_BLEND_SRCBLEND                              27:24 /* -WXVF */
#define NV_PGRAPH_BLEND_SRCBLEND_INVCONSTCOLOR           0x0000000D /* RW--V */
#define NV_PGRAPH_BLEND_SRCBLEND_CONSTALPHA              0x0000000E /* RW--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVCONSTALPHA           0x0000000F /* RW--V */
#define NV_PGRAPH_BLEND_SRCBLEND_ZERO                    0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_ONE                     0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_SRCCOLOR                0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVSRCCOLOR             0x00000004 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_SRCALPHA                0x00000005 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVSRCALPHA             0x00000006 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_DESTALPHA               0x00000007 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVDESTALPHA            0x00000008 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_DESTCOLOR               0x00000009 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVDESTCOLOR            0x0000000A /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_SRCALPHASAT             0x0000000B /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVSRCALPHASAT          0x0000000C /* ----V */
#define NV_PGRAPH_BLEND_SRCBLEND_BETA                    0x0000000D /* ----V */
#define NV_PGRAPH_BLEND_DESTBLEND                             31:28 /* -WXVF */
#define NV_PGRAPH_BLEND_DESTBLEND_ZERO                   0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_ONE                    0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_SRCCOLOR               0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVSRCCOLOR            0x00000004 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_SRCALPHA               0x00000005 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVSRCALPHA            0x00000006 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_DESTALPHA              0x00000007 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVDESTALPHA           0x00000008 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_DESTCOLOR              0x00000009 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVDESTCOLOR           0x0000000A /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_SRCALPHASAT            0x0000000B /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVSRCALPHASAT         0x0000000B /* RW--V */
#define NV_PGRAPH_BLEND_DESTBLEND_CONSTCOLOR             0x0000000C /* RW--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVCONSTCOLOR          0x0000000D /* RW--V */
#define NV_PGRAPH_BLEND_DESTBLEND_CONSTALPHA             0x0000000E /* RW--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVCONSTALPHA          0x0000000F /* RW--V */
#define NV_PGRAPH_BLENDCOLOR                             0x00400E84 /* RW-4R */
#define NV_PGRAPH_BLENDCOLOR_BUNDLE                      0x00000021 /* ----B */
#define NV_PGRAPH_BLENDCOLOR_BLUE                               7:0 /* RWXVF */
#define NV_PGRAPH_BLENDCOLOR_GREEN                             15:8 /* RWXVF */
#define NV_PGRAPH_BLENDCOLOR_RED                              23:16 /* RWXVF */
#define NV_PGRAPH_BLENDCOLOR_ALPHA                            31:24 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER                            0x00400E88 /* RW-4R */
#define NV_PGRAPH_SETUPRASTER_BUNDLE                     0x00000022 /* ----B */
#define NV_PGRAPH_SETUPRASTER_FRONTFACEMODE                     1:0 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_FRONTFACEMODE_FILL         0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_FRONTFACEMODE_POINT        0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_FRONTFACEMODE_LINE         0x00000002 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_BACKFACEMODE                      3:2 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_BACKFACEMODE_FILL          0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_BACKFACEMODE_POINT         0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_BACKFACEMODE_LINE          0x00000002 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POFFSETPOINTENABLE                6:6 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_POFFSETPOINTENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POFFSETPOINTENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POFFSETLINEENABLE                 7:7 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_POFFSETLINEENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POFFSETLINEENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POFFSETFILLENABLE                 8:8 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_POFFSETFILLENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POFFSETFILLENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POINTSMOOTHENABLE                 9:9 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_POINTSMOOTHENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POINTSMOOTHENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_LINESMOOTHENABLE                10:10 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_LINESMOOTHENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_LINESMOOTHENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POLYSMOOTHENABLE                11:11 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_POLYSMOOTHENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_POLYSMOOTHENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_LINEWIDTH                       20:12 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_CULLCONTROL                     22:21 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_CULLCONTROL_CULLNON        0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_CULLCONTROL_CULLFRONTFACE  0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_CULLCONTROL_CULLBACKFACE   0x00000002 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_CULLCONTROL_CULLALL        0x00000003 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_FRONTFACE                       23:23 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_FRONTFACE_CW_FRONT         0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_FRONTFACE_CCW_FRONT        0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_SWATHWIDTH                      27:26 /* R-XVF */
#define NV_PGRAPH_SETUPRASTER_SWATHWIDTH_8               0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_SWATHWIDTH_16              0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_SWATHWIDTH_32              0x00000002 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_SWATHWIDTH_64              0x00000003 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_CULLENABLE                      28:28 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_CULLENABLE_FALSE           0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_CULLENABLE_TRUE            0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_Z_FORMAT                        29:29 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_Z_FORMAT_FIXED             0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_Z_FORMAT_FLOAT             0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_ZCLIPENABLE                     31:30 /* RWXVF */
#define NV_PGRAPH_SETUPRASTER_ZCLIPENABLE_NONE           0x00000000 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_ZCLIPENABLE_MIN_ONLY       0x00000001 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_ZCLIPENABLE_MAX_ONLY       0x00000002 /* RW--V */
#define NV_PGRAPH_SETUPRASTER_ZCLIPENABLE_MIN_AND_MAX    0x00000003 /* RW--V */
#define NV_PGRAPH_FOGCOLOR                               0x00400E8C /* RW-4R */
#define NV_PGRAPH_FOGCOLOR_BUNDLE                        0x00000023 /* ----B */
#define NV_PGRAPH_FOGCOLOR_BLUE                                 7:0 /* RWXVF */
#define NV_PGRAPH_FOGCOLOR_GREEN                               15:8 /* RWXVF */
#define NV_PGRAPH_FOGCOLOR_RED                                23:16 /* RWXVF */
#define NV_PGRAPH_FOGCOLOR_ALPHA                              31:24 /* RWXVF */
#define NV_PGRAPH_ZOFFSETFACTOR                          0x00400E90 /* RW-4R */
#define NV_PGRAPH_ZOFFSETFACTOR_BUNDLE                   0x00000024 /* ----B */
#define NV_PGRAPH_ZOFFSETFACTOR_VALUE                          31:0 /* RWXFF */
#define NV_PGRAPH_ZOFFSETBIAS                            0x00400E94 /* RW-4R */
#define NV_PGRAPH_ZOFFSETBIAS_BUNDLE                     0x00000025 /* ----B */
#define NV_PGRAPH_ZOFFSETBIAS_VALUE                            31:0 /* RWXFF */
#define NV_PGRAPH_ZCLIPMIN                               0x00400E98 /* RW-4R */
#define NV_PGRAPH_ZCLIPMIN_BUNDLE                        0x00000026 /* ----B */
#define NV_PGRAPH_ZCLIPMIN_VALUE                               31:0 /* RWXFF */
#define NV_PGRAPH_ZCLIPMAX                               0x00400E9C /* RW-4R */
#define NV_PGRAPH_ZCLIPMAX_BUNDLE                        0x00000027 /* ----B */
#define NV_PGRAPH_ZCLIPMAX_VALUE                               31:0 /* RWXFF */
#define NV_PGRAPH_COLORKEYCOLOR0                         0x00400EA0 /* RW-4R */
#define NV_PGRAPH_COLORKEYCOLOR0_BUNDLE                  0x00000028 /* ----B */
#define NV_PGRAPH_COLORKEYCOLOR0_VALUE                         31:0 /* RWXVF */
#define NV_PGRAPH_COLORKEYCOLOR1                         0x00400EA4 /* RW-4R */
#define NV_PGRAPH_COLORKEYCOLOR1_BUNDLE                  0x00000029 /* ----B */
#define NV_PGRAPH_COLORKEYCOLOR1_VALUE                         31:0 /* RWXVF */
#define NV_PGRAPH_POINTSIZE                              0x00400EA8 /* RW-4R */
#define NV_PGRAPH_POINTSIZE_BUNDLE                       0x0000002A /* ----B */
#define NV_PGRAPH_POINTSIZE_VALUE                               8:0 /* RWXVF */
#define NV_PGRAPH_WINDOWCLIP_HORIZONTAL(i)       (0x00400F00+(i)*4) /* RW-4A */
#define NV_PGRAPH_WINDOWCLIP_HORIZONTAL__SIZE_1                   8 /*       */
#define NV_PGRAPH_WINDOWCLIP_HORIZONTAL_MIN                    11:0 /* RWXSF */
#define NV_PGRAPH_WINDOWCLIP_HORIZONTAL_MAX                   27:16 /* RWXSF */
#define NV_PGRAPH_WINDOWCLIP_VERTICAL(i)         (0x00400F20+(i)*4) /* RW-4A */
#define NV_PGRAPH_WINDOWCLIP_VERTICAL__SIZE_1                     8 /*       */
#define NV_PGRAPH_WINDOWCLIP_VERTICAL_MIN                      11:0 /* RWXSF */
#define NV_PGRAPH_WINDOWCLIP_VERTICAL_MAX                     27:16 /* RWXSF */
#define NV_PGRAPH_XFMODE0                                0x00400F40 /* RW-4R */
#define NV_PGRAPH_XFMODE0_T0_EN                                 0:0 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T0_EN_OFF                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_EN_ON                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_MODE                               1:1 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T0_MODE_PASS                   0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_MODE_TRANSFORM              0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_DIV                                2:2 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T0_DIV_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_DIV_ON                      0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_S                                  5:3 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T0_S_PASS                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_S_EYE                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_S_OBJECT                    0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_S_SPHERE                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_S_NORMAL                    0x00000004 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_S_REFLECTION                0x00000005 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_S_EMBOSS                    0x00000006 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_T                                  8:6 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T0_T_PASS                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_T_EYE                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_T_OBJECT                    0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_T_SPHERE                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_T_NORMAL                    0x00000004 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_T_REFLECTION                0x00000005 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_T_EMBOSS                    0x00000006 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_U                                 11:9 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T0_U_PASS                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_U_EYE                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_U_OBJECT                    0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_U_NORMAL                    0x00000004 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_U_REFLECTION                0x00000005 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_U_EMBOSS                    0x00000006 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_Q                                13:12 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T0_Q_PASS                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_Q_EYE                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T0_Q_OBJECT                    0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_EN                               14:14 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T1_EN_OFF                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_EN_ON                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_MODE                             15:15 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T1_MODE_PASS                   0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_MODE_TRANSFORM              0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_DIV                              16:16 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T1_DIV_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_DIV_ON                      0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_S                                19:17 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T1_S_PASS                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_S_EYE                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_S_OBJECT                    0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_S_SPHERE                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_S_NORMAL                    0x00000004 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_S_REFLECTION                0x00000005 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_S_EMBOSS                    0x00000006 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_T                                22:20 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T1_T_PASS                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_T_EYE                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_T_OBJECT                    0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_T_SPHERE                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_T_NORMAL                    0x00000004 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_T_REFLECTION                0x00000005 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_T_EMBOSS                    0x00000006 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_U                                25:23 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T1_U_PASS                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_U_EYE                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_U_OBJECT                    0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_U_NORMAL                    0x00000004 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_U_REFLECTION                0x00000005 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_U_EMBOSS                    0x00000006 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_Q                                27:26 /* RWXVF */
#define NV_PGRAPH_XFMODE0_T1_Q_PASS                      0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_Q_EYE                       0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_T1_Q_OBJECT                    0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE0_EYETYPE                             28:28 /* RWXVF */
#define NV_PGRAPH_XFMODE0_EYETYPE_INFINITE               0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_EYETYPE_LOCAL                  0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_LIGHTING                            29:29 /* RWXVF */
#define NV_PGRAPH_XFMODE0_LIGHTING_OFF                   0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_LIGHTING_ON                    0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_NORMAL                              30:30 /* RWXVF */
#define NV_PGRAPH_XFMODE0_NORMAL_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_NORMAL_ON                      0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE0_FOG                                 31:31 /* RWXVF */
#define NV_PGRAPH_XFMODE0_FOG_OFF                        0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE0_FOG_ON                         0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1                                0x00400F44 /* RW-4R */
#define NV_PGRAPH_XFMODE1_LIGHT0                                1:0 /* RWXVF */
#define NV_PGRAPH_XFMODE1_LIGHT0_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT0_INFINITE                0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT0_LOCAL                   0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT0_SPOT                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT1                                3:2 /* RWXVF */
#define NV_PGRAPH_XFMODE1_LIGHT1_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT1_INFINITE                0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT1_LOCAL                   0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT1_SPOT                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT2                                5:4 /* RWXVF */
#define NV_PGRAPH_XFMODE1_LIGHT2_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT2_INFINITE                0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT2_LOCAL                   0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT2_SPOT                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT3                                7:6 /* RWXVF */
#define NV_PGRAPH_XFMODE1_LIGHT3_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT3_INFINITE                0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT3_LOCAL                   0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT3_SPOT                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT4                                9:8 /* RWXVF */
#define NV_PGRAPH_XFMODE1_LIGHT4_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT4_INFINITE                0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT4_LOCAL                   0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT4_SPOT                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT5                              11:10 /* RWXVF */
#define NV_PGRAPH_XFMODE1_LIGHT5_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT5_INFINITE                0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT5_LOCAL                   0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT5_SPOT                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT6                              13:12 /* RWXVF */
#define NV_PGRAPH_XFMODE1_LIGHT6_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT6_INFINITE                0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT6_LOCAL                   0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT6_SPOT                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT7                              15:14 /* RWXVF */
#define NV_PGRAPH_XFMODE1_LIGHT7_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT7_INFINITE                0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT7_LOCAL                   0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_LIGHT7_SPOT                    0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE1_FOGGEN                              17:16 /* RWXVF */
#define NV_PGRAPH_XFMODE1_FOGGEN_OFF                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_FOGGEN_RADIAL                  0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_FOGGEN_PLANE                   0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_FOGGEN_ABS_PLANAR              0x00000003 /* RW--V */
#define NV_PGRAPH_XFMODE1_LAT                                 18:18 /* RWXVF */
#define NV_PGRAPH_XFMODE1_LAT_OFF                        0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_LAT_ON                         0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR1I                             19:19 /* RWXVF */
#define NV_PGRAPH_XFMODE1_COLOR1I_OFF                    0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR1I_PASS                   0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR1O                             20:20 /* RWXVF */
#define NV_PGRAPH_XFMODE1_COLOR1O_OFF                    0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR1O_PASS                   0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR_MATERIAL                      24:21 /* RWXVF */
#define NV_PGRAPH_XFMODE1_COLOR_MATERIAL_DISABLED        0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR_MATERIAL_EMISSION        0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR_MATERIAL_AMBIENT         0x00000002 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR_MATERIAL_DIFFUSE         0x00000004 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR_MATERIAL_AMBIENT_DIFFUSE 0x00000006 /* RW--V */
#define NV_PGRAPH_XFMODE1_COLOR_MATERIAL_SPECULAR        0x00000008 /* RW--V */
#define NV_PGRAPH_XFMODE1_POINT_PARAM                         25:25 /* RWXVF */
#define NV_PGRAPH_XFMODE1_POINT_PARAM_OFF                0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_POINT_PARAM_ON                 0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_RESERVED                            26:26 /* RWXVF */
#define NV_PGRAPH_XFMODE1_RESERVED_0                     0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_SKIN_EN                             27:27 /* RWXVF */
#define NV_PGRAPH_XFMODE1_SKIN_EN_OFF                    0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_SKIN_EN_ON                     0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_PASS                                28:28 /* RWXVF */
#define NV_PGRAPH_XFMODE1_PASS_FULLOPERATION             0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_PASS_PASSTHROUGH               0x00000001 /* RW--V */
#define NV_PGRAPH_XFMODE1_HALFOFFSET                          29:29 /* RWXVF */
#define NV_PGRAPH_XFMODE1_HALFOFFSET_OFF                 0x00000000 /* RW--V */
#define NV_PGRAPH_XFMODE1_HALFOFFSET_ON                  0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0                           0x00400F48 /* RW-4R */
#define NV_PGRAPH_GLOBALSTATE0_FOGMODE                          2:0 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_FOGMODE_LINEAR            0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_FOGMODE_EXP               0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_FOGMODE_EXP2              0x00000003 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_FOGMODE_EXP_ABS           0x00000005 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_FOGMODE_EXP2_ABS          0x00000007 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_WINDOW_CLIPMODE                  4:4 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_WINDOW_CLIPMODE_INCLUSIVE 0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_WINDOW_CLIPMODE_EXCLUSIVE 0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_WITHIN_BEGINEND                  8:8 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_WITHIN_BEGINEND_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_WITHIN_BEGINEND_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB0ALPHA_SINGLETEX           16:16 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_COMB0ALPHA_SINGLETEX_TRUE 0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB0COLOR_SINGLETEX           17:17 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_COMB0COLOR_SINGLETEX_TRUE 0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB1ALPHA_BYPASS              18:18 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_COMB1ALPHA_BYPASS_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB1ALPHA_BYPASS_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB1COLOR_BYPASS              19:19 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_COMB1COLOR_BYPASS_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB1COLOR_BYPASS_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB0ALPHA_ADDCMP              20:20 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_COMB0ALPHA_ADDCMP_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB0ALPHA_ADDCMP_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB0COLOR_ADDCMP              21:21 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_COMB0COLOR_ADDCMP_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB0COLOR_ADDCMP_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB1ALPHA_ADDCMP              22:22 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_COMB1ALPHA_ADDCMP_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB1ALPHA_ADDCMP_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB1COLOR_ADDCMP              23:23 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_COMB1COLOR_ADDCMP_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_COMB1COLOR_ADDCMP_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_SETUP                        26:24 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_Z_SETUP_Z16ZFIXEDZBUFFER  0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_SETUP_Z16ZFIXEDWBUFFER  0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_SETUP_Z16ZFLOATZBUFFER  0x00000002 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_SETUP_Z16ZFLOATWBUFFER  0x00000003 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_SETUP_Z24ZFIXEDZBUFFER  0x00000004 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_SETUP_Z24ZFIXEDWBUFFER  0x00000005 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_SETUP_Z24ZFLOATZBUFFER  0x00000006 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_SETUP_Z24ZFLOATWBUFFER  0x00000007 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_INITIALIZED                  28:28 /* RWXVF */
#define NV_PGRAPH_GLOBALSTATE0_Z_INITIALIZED_FALSE       0x00000000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE0_Z_INITIALIZED_TRUE        0x00000001 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE1                           0x00400F4C /* RW-4R */
#define NV_PGRAPH_GLOBALSTATE1_DMA_INSTANCE_2                  15:0 /* RWXUF */
#define NV_PGRAPH_GLOBALSTATE1_DMA_INSTANCE_2_INVALID        0x0000 /* RW--V */
#define NV_PGRAPH_GLOBALSTATE1_DMA_INSTANCE_3                 31:16 /* RWXUF */
#define NV_PGRAPH_GLOBALSTATE1_DMA_INSTANCE_3_INVALID        0x0000 /* RW--V */
#define NV_PGRAPH_PIPE_ADDRESS                           0x00400F50 /* RW-4R */
#define NV_PGRAPH_PIPE_ADDRESS_VALUE                           14:2 /* RWXVF */
#define NV_PGRAPH_PIPE_DATA                              0x00400F54 /* RW-4R */
#define NV_PGRAPH_PIPE_DATA_VALUE                              31:0 /* RWXVF */
#define NV_PGRAPH_DMA_START_0                            0x00401000 /* RW-4R */
#define NV_PGRAPH_DMA_START_0_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_DMA_START_1                            0x00401004 /* RW-4R */
#define NV_PGRAPH_DMA_START_1_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_DMA_LENGTH                             0x00401008 /* RW-4R */
#define NV_PGRAPH_DMA_LENGTH_VALUE                             21:0 /* RWXUF */
#define NV_PGRAPH_DMA_MISC                               0x0040100C /* RW-4R */
#define NV_PGRAPH_DMA_MISC_COUNT                               15:0 /* RWXUF */
#define NV_PGRAPH_DMA_MISC_FMT_SRC                            18:16 /* RWXVF */
#define NV_PGRAPH_DMA_MISC_FMT_DST                            22:20 /* RWXVF */
#define NV_PGRAPH_DMA_DATA_0                             0x00401020 /* RW-4R */
#define NV_PGRAPH_DMA_DATA_0_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_DATA_1                             0x00401024 /* RW-4R */
#define NV_PGRAPH_DMA_DATA_1_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_RM                                 0x00401030 /* RW-4R */
#define NV_PGRAPH_DMA_RM_ASSIST_A                               0:0 /* RWIVF */
#define NV_PGRAPH_DMA_RM_ASSIST_A_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_DMA_RM_ASSIST_A_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_DMA_RM_ASSIST_A_RESET                  0x00000001 /* -W--C */
#define NV_PGRAPH_DMA_RM_ASSIST_B                               1:1 /* RWIVF */
#define NV_PGRAPH_DMA_RM_ASSIST_B_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_DMA_RM_ASSIST_B_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_DMA_RM_ASSIST_B_RESET                  0x00000001 /* -W--C */
#define NV_PGRAPH_DMA_RM_WRITE_REQ                              4:4 /* CWIVF */
#define NV_PGRAPH_DMA_RM_WRITE_REQ_NOT_PENDING           0x00000000 /* CWI-V */
#define NV_PGRAPH_DMA_RM_WRITE_REQ_PENDING               0x00000001 /* -W--T */
#define NV_PGRAPH_DMA_A_XLATE_INST                       0x00401040 /* RW-4R */
#define NV_PGRAPH_DMA_A_XLATE_INST_VALUE                       15:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_CONTROL                          0x00401044 /* RW-4R */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_TABLE                    12:12 /* RWIVF */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_TABLE_NOT_PRESENT   0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_TABLE_PRESENT       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_ENTRY                    13:13 /* RWXVF */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_ENTRY_NOT_LINEAR    0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_ENTRY_LINEAR        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE                   17:16 /* RWXUF */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE_NVM          0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE_PCI          0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE_AGP          0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_ADJUST                        31:20 /* RWXUF */
#define NV_PGRAPH_DMA_A_LIMIT                            0x00401048 /* RW-4R */
#define NV_PGRAPH_DMA_A_LIMIT_OFFSET                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_TLB_PTE                          0x0040104C /* RW-4R */
#define NV_PGRAPH_DMA_A_TLB_PTE_ACCESS                          1:1 /* RWXVF */
#define NV_PGRAPH_DMA_A_TLB_PTE_ACCESS_READ_ONLY         0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_A_TLB_PTE_ACCESS_READ_WRITE        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_A_TLB_PTE_FRAME_ADDRESS                 31:12 /* RWXUF */
#define NV_PGRAPH_DMA_A_TLB_TAG                          0x00401050 /* RW-4R */
#define NV_PGRAPH_DMA_A_TLB_TAG_ADDRESS                       31:12 /* RWXUF */
#define NV_PGRAPH_DMA_A_ADJ_OFFSET                       0x00401054 /* RW-4R */
#define NV_PGRAPH_DMA_A_ADJ_OFFSET_VALUE                       31:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_OFFSET                           0x00401058 /* RW-4R */
#define NV_PGRAPH_DMA_A_OFFSET_VALUE                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_SIZE                             0x0040105C /* RW-4R */
#define NV_PGRAPH_DMA_A_SIZE_VALUE                             24:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_Y_SIZE                           0x00401060 /* RW-4R */
#define NV_PGRAPH_DMA_A_Y_SIZE_VALUE                           10:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_XLATE_INST                       0x00401080 /* RW-4R */
#define NV_PGRAPH_DMA_B_XLATE_INST_VALUE                       15:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_CONTROL                          0x00401084 /* RW-4R */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_TABLE                    12:12 /* RWIVF */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_TABLE_NOT_PRESENT   0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_TABLE_PRESENT       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_ENTRY                    13:13 /* RWXVF */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_ENTRY_NOT_LINEAR    0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_ENTRY_LINEAR        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE                   17:16 /* RWXUF */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE_NVM          0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE_PCI          0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE_AGP          0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_ADJUST                        31:20 /* RWXUF */
#define NV_PGRAPH_DMA_B_LIMIT                            0x00401088 /* RW-4R */
#define NV_PGRAPH_DMA_B_LIMIT_OFFSET                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_TLB_PTE                          0x0040108C /* RW-4R */
#define NV_PGRAPH_DMA_B_TLB_PTE_ACCESS                          1:1 /* RWXVF */
#define NV_PGRAPH_DMA_B_TLB_PTE_ACCESS_READ_ONLY         0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_B_TLB_PTE_ACCESS_READ_WRITE        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_B_TLB_PTE_FRAME_ADDRESS                 31:12 /* RWXUF */
#define NV_PGRAPH_DMA_B_TLB_TAG                          0x00401090 /* RW-4R */
#define NV_PGRAPH_DMA_B_TLB_TAG_ADDRESS                       31:12 /* RWXUF */
#define NV_PGRAPH_DMA_B_ADJ_OFFSET                       0x00401094 /* RW-4R */
#define NV_PGRAPH_DMA_B_ADJ_OFFSET_VALUE                       31:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_OFFSET                           0x00401098 /* RW-4R */
#define NV_PGRAPH_DMA_B_OFFSET_VALUE                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_SIZE                             0x0040109C /* RW-4R */
#define NV_PGRAPH_DMA_B_SIZE_VALUE                             24:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_Y_SIZE                           0x004010A0 /* RW-4R */
#define NV_PGRAPH_DMA_B_Y_SIZE_VALUE                           10:0 /* RWXUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR                      1:0 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000001 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U                            5:4 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V                            7:6 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR                        11:10 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_NORMAL            0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_COLOR_INVERSE     0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_INVERSE     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_ONE         0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING                         13:12 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_CULLING_ILLEGAL            0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE          0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER                         15:15 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_ILLEGAL       0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                      22:20 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE                     26:24 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ROP                             28:28 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA                      29:29 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_SRCALPHA        0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_DESTCOLOR       0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0                    30:30 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_DESTCOLOR     0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1                    31:31 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_SRCCOLOR      0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_KEY                          7:0 /* RWXUF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE                     11:8 /* RWXVF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_ILLEGAL       0x00000000 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_FALSE         0x00000001 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LT            0x00000002 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_EQ            0x00000003 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LE            0x00000004 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GT            0x00000005 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_NE            0x00000006 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GE            0x00000007 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_TRUE          0x00000008 /* RW--V */
/* dev_video.ref */
#define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
#define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
#define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
#define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
#define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
#define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
#define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
#define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
#define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
#define NV_PVIDEO_BUFF0_START_ADDRESS                          23:2 /* RW-UF */
#define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
#define NV_PVIDEO_BUFF1_START_ADDRESS                          23:2 /* RW-UF */
#define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
#define NV_PVIDEO_BUFF0_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
#define NV_PVIDEO_BUFF1_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
#define NV_PVIDEO_BUFF0_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
#define NV_PVIDEO_BUFF1_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
#define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
#define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
#define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
#define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
#define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
#define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
#define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
#define NV_PVIDEO_FIFO_THRES_SIZE                               7:3 /* RW--F */
#define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
#define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
#define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
#define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
#define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
#define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
#define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
#define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
#define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
#define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
#define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
#define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
#define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
#define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
#define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
#define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
#define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
#define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
#define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
#define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
#define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
#define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
/* dev_media.ref */
#define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
#define NV_PME_DEBUG_0                                   0x00200080 /* RWI4R */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH                         0:0 /* RWI-F */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_DISABLED         0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_ENABLED          0x00000001 /* RW--V */
#define NV_PME_DEBUG_0_CAPTURE_00_FF                            4:4 /* RWI-F */
#define NV_PME_DEBUG_0_CAPTURE_00_FF_DISABLED            0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_CAPTURE_00_FF_ENABLED             0x00000001 /* RW--V */
#define NV_PME_DEBUG_1                                   0x00200084 /* RWI4R */
#define NV_PME_DEBUG_1_SEL                                      1:0 /* RWI-F */
#define NV_PME_DEBUG_1_SEL_VIPCLK                        0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_SEL_MCLK                          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1_SEL_GLOB                          0x00000002 /* RW--V */
#define NV_PME_DEBUG_1_VIPCLK_SEL                               6:4 /* RWI-F */
#define NV_PME_DEBUG_1_VIPCLK_SEL_DEFAULT                0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_MCLK_SEL                                 9:8 /* RWI-F */
#define NV_PME_DEBUG_1_MCLK_SEL_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
#define NV_PME_INTR_0_IMAGE_NOTIFY                              0:0 /* RWIVF */
#define NV_PME_INTR_0_IMAGE_NOTIFY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_PENDING               0x00000001 /* R---V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_RESET                 0x00000001 /* -W--V */
#define NV_PME_INTR_0_VBI_NOTIFY                                4:4 /* RWIVF */
#define NV_PME_INTR_0_VBI_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VBI_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VBI_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VID_NOTIFY                                8:8 /* RWIVF */
#define NV_PME_INTR_0_VID_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VID_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VID_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_AUD_NOTIFY                              12:12 /* RWIVF */
#define NV_PME_INTR_0_AUD_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_AUD_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_AUD_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VMI                                     16:16 /* RWIVF */
#define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
#define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
#define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY                           0:0 /* RWIVF */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_DISABLED           0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_ENABLED            0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY                             4:4 /* RWIVF */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VID_NOTIFY                             8:8 /* RWIVF */
#define NV_PME_INTR_EN_0_VID_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VID_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY                           12:12 /* RWIVF */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VMI                                  16:16 /* RWIVF */
#define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
#define NV_PME_CONFIG_0_BUS_MODE                                1:0 /* RWIVF */
#define NV_PME_CONFIG_0_BUS_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_BUS_MODE_VMI                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_BUS_MODE_CCIR656                 0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_IMAGE                                   4:4 /* RWIVF */
#define NV_PME_CONFIG_0_IMAGE_DISABLED                   0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_IMAGE_ENABLED                    0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
#define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
#define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
#define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
#define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
#define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
#define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
#define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
#define NV_PME_NULL_DATA                                 0x00200208 /* RWI4R */
#define NV_PME_NULL_DATA_COMPARE                                0:0 /* RWIVF */
#define NV_PME_NULL_DATA_COMPARE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_NULL_DATA_COMPARE_ENABLED                 0x00000001 /* RW--V */
#define NV_PME_NULL_DATA_LINE_DETECT                            4:4 /* RWIVF */
#define NV_PME_NULL_DATA_LINE_DETECT_DISABLED            0x00000000 /* RWI-V */
#define NV_PME_NULL_DATA_LINE_DETECT_ENABLED             0x00000001 /* RW--V */
#define NV_PME_NULL_DATA_BYTE                                 31:24 /* RWXVF */
#define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */ 
#define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */ 
#define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
#define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */ 
#define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
#define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */ 
#define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
#define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_START_ADDRESS                         23:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_START_ADDRESS                         23:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */ 
#define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
#define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
#define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
#define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI                                       0x002003a4 /* RWI4R */
#define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
#define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
#define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_START_ADDRESS                       23:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_START_ADDRESS                       23:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
#define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
#define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
#define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
#define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_Y_CROP                              0x0020042c /* RW-4R */
#define NV_PME_IMAGE_Y_CROP_STARTLINE                           8:0 /* RWXVF */
#define NV_PME_FIFO_LINE_START                           0x00200480 /* RW-4R */
#define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* RWXVF */
#define NV_PME_FIFO_CURRENT                              0x00200484 /* RW-4R */
#define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
#define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
#define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R---V */
#define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R---V */
#define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R---V */
#define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
#define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R---V */
#define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R---V */
#define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
#define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */  
#define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PDFB                               0x01FFFFFF:0x01000000 /* RW--D */
#define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PDFB_DATA032__SIZE_1                              524288 /*       */
#define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PDFB_DATA024__SIZE_1                             1048576 /*       */
#define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PDFB_DATA016__SIZE_1                             1572864 /*       */
#define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PDFB_DATA008__SIZE_1                             2097152 /*       */
#define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00680000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
/* dev_ext_devices.ref */
/* dev_framebuffer.ref */
#define NV_PFB_BOOT_0                                    0x00100000 /* RW-4R */
#define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB                     0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_8MB                     0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_16MB                    0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_32MB                    0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128                             2:2 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_OFF                  0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_ON                   0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE                                  5:3 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_TYPE_256K                      0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE_512K_2BANK                0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE_512K_4BANK                0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE_1024K_2BANK               0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE_SGRAM_8MBIT               0x00000000 /* R---V */
#define NV_PFB_BOOT_0_RAM_TYPE_SGRAM_16MBIT              0x00000001 /* R---V */
#define NV_PFB_BOOT_0_RAM_TYPE_SGRAM_16MBIT_4BANK        0x00000002 /* R---V */
#define NV_PFB_BOOT_0_RAM_TYPE_SDRAM_16MBIT              0x00000003 /* R---V */
#define NV_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBIT              0x00000004 /* R---V */
#define NV_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBITX16           0x00000005 /* R---V */
#define NV_PFB_BOOT_0_UMA                                       8:8 /* RW-VF */
#define NV_PFB_BOOT_0_UMA_DISABLE                        0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_UMA_ENABLE                         0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE                                15:12 /* RW-VF */
#define NV_PFB_BOOT_0_UMA_SIZE_DEFAULT                   0x00000007 /* RWI-V */
#define NV_PFB_BOOT_0_UMA_SIZE_2M                        0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_4M                        0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_6M                        0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_8M                        0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_10M                       0x00000004 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_12M                       0x00000005 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_14M                       0x00000006 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_16M                       0x00000007 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_18M                       0x00000008 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_20M                       0x00000009 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_22M                       0x0000000a /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_24M                       0x0000000b /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_26M                       0x0000000c /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_28M                       0x0000000d /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_30M                       0x0000000e /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_32M                       0x0000000f /* RW--V */
#define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
#define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
#define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64                        13:8 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT          0x00000010 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_SLOW_CLK                       14:14 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_SLOW_CLK_DISABLED         0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_SLOW_CLK_ENABLED          0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
#define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_INVERT                             28:28 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_OFF                    0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CKE_INVERT_ON                     0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFINC                                 29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_REFINC_DISABLED                   0x00000000 /* RW--V */
#define NV_PFB_DEBUG_0_REFINC_ENABLED                    0x00000001 /* RWI-V */
#define NV_PFB_DEBUG_0_SAVE_POWER                             30:30 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_ON                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SAVE_POWER_OFF                    0x00000001 /* RW--V */
#define NV_PFB_GREEN_0                                   0x001000C0 /* RW-4R */
#define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_0                                  0x00100200 /* RW-4R */
#define NV_PFB_CONFIG_0_TYPE                                   14:0 /* RWIVF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_8BPP          0x00000120 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_16BPP         0x00000220 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_32BPP         0x00000320 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_8BPP            0x00004120 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_16BPP           0x00004220 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_32BPP           0x00004320 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_TETRIS                      0x00002000 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_NOTILING                    0x00001114 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE                           17:15 /* RWI-F */
#define NV_PFB_CONFIG_0_TETRIS_MODE_PASS                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_1                    0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_2                    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_3                    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_4                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_5                    0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_6                    0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_7                    0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT                          19:18 /* RWI-F */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_0                   0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_1                   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_2                   0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP                             22:20 /* RWI-F */
#define NV_PFB_CONFIG_0_BANK_SWAP_OFF                    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_BANK_SWAP_1M                     0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_2M                     0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_4M                     0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_UNUSED                                23:23 /* RW-VF */
#define NV_PFB_CONFIG_0_SCRAMBLE_EN                           29:29 /* RWIVF */
#define NV_PFB_CONFIG_0_SCRAMBLE_EN_INIT                 0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_SCRAMBLE_ACTIVE                  0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PRAMIN_WR                             28:28 /* RWIVF */
#define NV_PFB_CONFIG_0_PRAMIN_WR_INIT                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_PRAMIN_WR_DISABLED               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PRAMIN_WR_MASK                        27:24 /* RWIVF */
#define NV_PFB_CONFIG_0_PRAMIN_WR_MASK_INIT              0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_PRAMIN_WR_MASK_CLEAR             0x0000000f /* RWI-V */
#define NV_PFB_CONFIG_1                                  0x00100204 /* RW-4R */
#define NV_PFB_CONFIG_1_CAS_LATENCY                             2:0 /* RWIVF */
#define NV_PFB_CONFIG_1_CAS_LATENCY_3                    0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_1_CAS_LATENCY_2                    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_CAS_LATENCY_4                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS                                 7:4 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_RAS_DEFAULT                  0x00000009 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_RAS_9CYCLES                  0x00000008 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS_8CYCLES                  0x00000007 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS_7CYCLES                  0x00000006 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_PCHG                               10:8 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_PCHG_2CYCLES                 0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW                               14:12 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_LOW_DEFAULT                  0x00000006 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_LOW_7CYCLES                  0x00000007 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW_5CYCLES                  0x00000005 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW_4CYCLES                  0x00000004 /* RW--V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS                            18:16 /* RWIUF */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT               0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_2CYCLES               0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_0CYCLES               0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_WRITE_TO_READ                         22:20 /* RWIUF */
#define NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_SPECIAL32                             20:20 /* RWIUF */
#define NV_PFB_CONFIG_1_SPECIAL32_ON                     0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_SPECIAL32_OFF                    0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1                         26:24 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT            0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_2CYCLES            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_0CYCLES            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE                         30:28 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT            0x00000004 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_5CYCLES            0x00000005 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_3CYCLES            0x00000003 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_2CYCLES            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG                          31:31 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_ON                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_OFF                 0x00000000 /* RW--V */
#define NV_PFB_RTL                                       0x00100300 /* RW-4R */
#define NV_PFB_RTL_H                                            0:0 /* RWIUF */
#define NV_PFB_RTL_H_DEFAULT                             0x00000000 /* RWI-V */
#define NV_PFB_RTL_MC                                           1:1 /* RWIUF */
#define NV_PFB_RTL_MC_DEFAULT                            0x00000000 /* RWI-V */
#define NV_PFB_RTL_V                                            2:2 /* RWIUF */
#define NV_PFB_RTL_V_DEFAULT                             0x00000000 /* RWI-V */
#define NV_PFB_RTL_G                                            3:3 /* RWIUF */
#define NV_PFB_RTL_G_DEFAULT                             0x00000000 /* RWI-V */
#define NV_PFB_RTL_GB                                           4:4 /* RWIUF */
#define NV_PFB_RTL_GB_DEFAULT                            0x00000000 /* RWI-V */
#define NV_PFB_SCRAMBLE(i)                     (0x00100400+((i)*4)) /* RW-4A */
#define NV_PFB_SCRAMBLE_SIZE_1                                    8 /*       */
#define NV_PFB_SCRAMBLE_w0                                      4:0 /* RWXUF */
#define NV_PFB_SCRAMBLE_w1                                     12:8 /* RWXUF */
#define NV_PFB_SCRAMBLE_w2                                    20:16 /* RWXUF */
#define NV_PFB_SCRAMBLE_w3                                    28:24 /* RWXUF */
#define NV_PFB_SCRAMBLE_EN                               0x00100420 /* RW-4R */
#define NV_PFB_SCRAMBLE_VALUE_0                          0x03020100 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_1                          0x07060504 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_2                          0x0b0a0908 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_3                          0x0f0e0d0c /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_4                          0x13121110 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_5                          0x17161514 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_6                          0x1b1a1918 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_7                          0x1f1e1d1c /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION                              5:0 /* RWIVF */
#define NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS            0x0000000a /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS            0x0000000d /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS            0x0000000f /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS            0x00000010 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000014 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000019 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS            0x0000001e /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000020 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000024 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000028 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000032 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_DEFAULT               0x00000014 /* RWI-V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT              0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING                                12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_ENABLED                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DISABLED                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG                          23:13 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILE                                  14:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILE_OLD1024_FIXED               0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_OLD1024_VARIABLE            0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_TETRIS_ALLOW                0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT2           0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON                       13:13 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_ENABLED          0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_DISABLED         0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE                 14:14 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_FIXED      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_VARIABLE   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE              17:15 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_PASS    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_1       0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_2       0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_3       0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_4       0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_5       0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_6       0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_7       0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT             19:18 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_0      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_1      0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_2      0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP                20:20 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_OFF       0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_ON        0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB            22:21 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_1M    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_2M    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_4M    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_UNUSED                   23:23 /* RW--F */
#define NV_PFB_CONFIG_1_SGRAM100                                3:3 /* RWIVF */
#define NV_PFB_CONFIG_1_SGRAM100_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_SGRAM100_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON                           29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF                  0x00000000 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_ON                   0x00000001 /* RWI-V */
/* dev_ram.ref */
#define NV_PNVM                               0x0FFFFFFF:0x08000000 /* RW--M */
#define NV_PNVM_DATA032(i)                       (0x08000000+(i)*4) /* RW-4A */
#define NV_PNVM_DATA032__SIZE_1                            33554432 /*       */
#define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PNVM_DATA016(i)           (0x08000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PNVM_DATA016__SIZE_1                           67108864  /*       */
#define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PNVM_DATA008(i)                         (0x08000000+(i)) /* RW-1A */
#define NV_PNVM_DATA008__SIZE_1                           134217728 /*       */
#define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAMIN                             0x007FFFFF:0x00700000 /* RW--M */
#define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
#define NV_PRAMIN_RAMHT_0                     0x00710FFF:0x00710000 /* RW--M */
#define NV_PRAMIN_RAMFC_0                     0x007111FF:0x00711000 /* RW--M */
#define NV_PRAMIN_RAMRO_0                     0x007113FF:0x00711200 /* RW--M */
#define NV_PRAMIN_CTX_0(i)                    (0x00700000 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_0__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_0_NVCLASS                                11:0 /* RWXUF */
#define NV_PRAMIN_CTX_0_NVCLASS_NV_ROOT                  0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_NVCLASS_012                      0x00000012 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_017                      0x00000017 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_018                      0x00000018 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_019                      0x00000019 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_01C                      0x0000001C /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_01D                      0x0000001D /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_01E                      0x0000001E /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_01F                      0x0000001F /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_021                      0x00000021 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_030                      0x00000030 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_036                      0x00000036 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_037                      0x00000037 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_038                      0x00000038 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_039                      0x00000039 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_042                      0x00000042 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_043                      0x00000043 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_044                      0x00000044 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_048                      0x00000048 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_04A                      0x0000004A /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_04B                      0x0000004B /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_052                      0x00000052 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_053                      0x00000053 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_054                      0x00000054 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_055                      0x00000055 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_057                      0x00000057 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_058                      0x00000058 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_059                      0x00000059 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05A                      0x0000005A /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05B                      0x0000005B /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05C                      0x0000005C /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05E                      0x0000005E /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_05F                      0x0000005F /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_060                      0x00000060 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_061                      0x00000061 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_064                      0x00000064 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_065                      0x00000065 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_066                      0x00000066 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_067                      0x00000067 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_072                      0x00000072 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_076                      0x00000076 /* RWC-V */
#define NV_PRAMIN_CTX_0_NVCLASS_077                      0x00000077 /* RWC-V */
#define NV_PRAMIN_CTX_0_CHROMA_KEY                            12:12 /* RWXUF */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_DISABLE               0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_ENABLE                0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_USER_CLIP                             13:13 /* RWXUF */
#define NV_PRAMIN_CTX_0_USER_CLIP_DISABLE                0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_USER_CLIP_ENABLE                 0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_SWIZZLE                               14:14 /* RWXUF */
#define NV_PRAMIN_CTX_0_SWIZZLE_DISABLE                  0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_SWIZZLE_ENABLE                   0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG                          17:15 /* RWXUF */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_AND         0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_ROP_AND             0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_AND           0x00000002 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY             0x00000003 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_PRE         0x00000004 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_PRE           0x00000005 /* RW--V */
#define NV_PRAMIN_CTX_0_DITHER_MODE                           21:20 /* RWXUF */
#define NV_PRAMIN_CTX_0_DITHER_MODE_COMPATIBILITY        0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_DITHER_MODE_DITHER               0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_DITHER_MODE_TRUNCATE             0x00000002 /* RW--V */
#define NV_PRAMIN_CTX_0_DITHER_MODE_SUBTRACT_TRUNCATE    0x00000003 /* RW--V */
#define NV_PRAMIN_CTX_0_SINGLE_STEP                           23:23 /* RWXUF */
#define NV_PRAMIN_CTX_0_SINGLE_STEP_DISABLE              0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_SINGLE_STEP_ENABLE               0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_STATUS                          24:24 /* RWXUF */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_INVALID             0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_VALID               0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE                       25:25 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE_INVALID          0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE_VALID            0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0                      25:25 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_INVALID         0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_VALID           0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1                      26:26 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_INVALID         0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_VALID           0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN                       27:27 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_INVALID          0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_VALID            0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_ROP                           28:28 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_INVALID              0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_VALID                0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1                         29:29 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_INVALID            0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_VALID              0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4                         30:30 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_INVALID            0x00000000 /* RWD-V */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_VALID              0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_1(i)                    (0x00700004 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_1__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_1_MONO_FORMAT                             7:0 /* RWXUF */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_INVALID                    0x00 /* RWD-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_CGA6_M1                    0x01 /* RW--V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_LE_M1                      0x02 /* RW--V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_018                        0x01 /* RWC-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_044                        0x01 /* RWC-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_04A                        0x01 /* RWC-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_04B                        0x01 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT                           15:8 /* RWXUF */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_INVALID                   0x00 /* RWD-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y8                     0x01 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A8Y8                0x02 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X24Y8                  0x03 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A1R5G5B5               0x06 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X1R5G5B5               0x07 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A1R5G5B5            0x08 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X17R5G5B5              0x09 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_R5G6B5                 0x0A /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16R5G6B5              0x0B /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16R5G6B5              0x0C /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A8R8G8B8               0x0D /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X8R8G8B8               0x0E /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y16                    0x0F /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16Y16                 0x10 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16Y16                 0x11 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_V8YB8U8YA8             0x12 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_YB8V8YA8U8             0x13 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y32                    0x14 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_017                 0x00000002 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_018                 0x00000002 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_01C                 0x00000003 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_01D                 0x00000003 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_01E                 0x00000003 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_021                 0x00000001 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_036                 0x00000001 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_037                 0x00000006 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_044                 0x0000000B /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_04A                 0x0000000C /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_04B                 0x00000003 /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_057                 0x0000000B /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_05C                 0x0000000C /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_05D                 0x0000000C /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_05E                 0x0000000C /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_060                 0x0000000A /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_061                 0x0000000A /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_076                 0x0000000A /* RWC-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_077                 0x00000006 /* RWC-V */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE                       31:16 /* RWXUF */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_INVALID              0x0000 /* RWD-V */
#define NV_PRAMIN_CTX_2(i)                    (0x00700008 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_2__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE                         15:0 /* RWXUF */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_INVALID               0x0000 /* RWD-V */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE                        31:16 /* RWXUF */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_INVALID               0x0000 /* RWD-V */
#define NV_PRAMIN_CTX_3(i)                    (0x0070000C + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_3__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_3_METHOD_TRAPS                           31:0 /* RWXUF */
#define NV_PRAMIN_CTX_3_METHOD_TRAPS_DISABLED            0x00000000 /* RWD-V */
#define NV_PRAMIN_DATA032(i)                     (0x00700000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                            524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                31:0 /* RWXVF */
#define NV_PRAMIN_DATA016(i)         (0x00700000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PRAMIN_DATA016__SIZE_1                           1572864 /*       */
#define NV_PRAMIN_DATA016_VALUE                                15:0 /* RWXVF */
#define NV_PRAMIN_DATA008(i)                       (0x00700000+(i)) /* RW-1A */
#define NV_PRAMIN_DATA008__SIZE_1                           2097152 /*       */
#define NV_PRAMIN_DATA008_VALUE                                 7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_FIFO_DMA_OPCODE                    ( 0*32+31):( 0*32+29) /* RWXUF */
#define NV_FIFO_DMA_OPCODE_METHOD                        0x00000000 /* ----V */
#define NV_FIFO_DMA_OPCODE_JUMP                          0x00000001 /* ----V */
#define NV_FIFO_DMA_OPCODE_NONINC_METHOD                 0x00000002 /* ----V */
#define NV_FIFO_DMA_METHOD_COUNT              ( 0*32+28):( 0*32+18) /* RWXUF */
#define NV_FIFO_DMA_METHOD_SUBCHANNEL         ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_FIFO_DMA_METHOD_ADDRESS            ( 0*32+12):( 0*32+ 2) /* RWXUF */
#define NV_FIFO_DMA_DATA                      ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_FIFO_DMA_JUMP_OFFSET                                28:2 /* RWXUF */
/* dev_ram.ref */
#define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_ENGINE                       ( 1*32+17):( 1*32+16) /* RWXVF */
#define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMHT_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMHT_CHID                         ( 1*32+28):( 1*32+24) /* RWXUF */
#define NV_RAMHT_STATUS                       ( 1*32+31):( 1*32+31) /* RWXUF */
#define NV_RAMHT_STATUS_INVALID                          0x00000000 /* RW--V */
#define NV_RAMHT_STATUS_VALID                            0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+12):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_SUBCHANNEL                   ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXVF */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMFC_DMA_PUT                      ( 0*32+28):( 0*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_GET                      ( 1*32+28):( 1*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_INST                     ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_RAMFC_DMA_COUNT                    ( 2*32+28):( 2*32+18) /* RWXUF */
#define NV_RAMFC_DMA_METHOD                   ( 3*32+12):( 3*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_SUBCHANNEL               ( 3*32+15):( 3*32+13) /* RWXUF */
#define NV_RAMFC_DMA_METHOD_COUNT             ( 3*32+28):( 3*32+18) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_TRIG               ( 4*32+ 7):( 4*32+ 3) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_SIZE               ( 4*32+15):( 4*32+13) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_MAX_REQS           ( 4*32+20):( 4*32+16) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_0                 ( 5*32+ 1):( 5*32+ 0) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_1                 ( 5*32+ 5):( 5*32+ 4) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_2                 ( 5*32+ 9):( 5*32+ 8) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_3                 ( 5*32+13):( 5*32+12) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_4                 ( 5*32+17):( 5*32+16) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_5                 ( 5*32+21):( 5*32+20) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_6                 ( 5*32+25):( 5*32+24) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_7                 ( 5*32+29):( 5*32+28) /* RWXUF */
#define NV_RAMFC_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMFC_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE                 ( 6*32+ 1):( 6*32+ 0) /* RWXUF */
#define NV_RAMFC_PULL1_ENGINE_SW                         0x00000000 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_GRAPHICS                   0x00000001 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_DVD                        0x00000002 /* RW--V */
/* dev_ram.ref */
#define NV_RAMDVD_CTX_TABLE                   (63*32+31):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT(c,s) (((c)*4+((s)/2))*32+((s)%2)*16+15):(((c)*4+((s)/2))*32+((s)%2)*16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0        ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1        ( 0*32+31):( 0*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2        ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3        ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4        ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5        ( 2*32+31):( 2*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6        ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7        ( 3*32+31):( 3*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0       (60*32+15):(60*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1       (60*32+31):(60*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2       (61*32+15):(61*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3       (61*32+31):(61*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4       (62*32+15):(62*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5       (62*32+31):(62*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6       (63*32+15):(63*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7       (63*32+31):(63*32+16) /* RWXUF */
/* dev_ram.ref */
#define NV_DMA_CLASS                          ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+12):( 0*32+12) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_PAGE_ENTRY                     ( 0*32+13):( 0*32+13) /* RWXVF */
#define NV_DMA_PAGE_ENTRY_NOT_LINEAR                     0x00000000 /* RW--V */
#define NV_DMA_PAGE_ENTRY_LINEAR                         0x00000001 /* RW--V */
#define NV_DMA_FLAGS_ACCESS                   ( 0*32+15):( 0*32+14) /* RWXVF */
#define NV_DMA_FLAGS_ACCESS_READ_WRITE                   0x00000000 /* RW--V */
#define NV_DMA_FLAGS_ACCESS_READ_ONLY                    0x00000001 /* RW--V */
#define NV_DMA_FLAGS_ACCESS_WRITE_ONLY                   0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE                    ( 0*32+17):( 0*32+16) /* RWXVF */
#define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
#define NV_DMA_TARGET_NODE_NVM_TILED                     0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
#define NV_DMA_ADJUST                         ( 0*32+31):( 0*32+20) /* RWXUF */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
#define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
#define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */
#ifdef DEFUNCT
/* dev_realmode.ref */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1                      0x00000300 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_2                      0x00000230 /* R--1R */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1                    0x00000301 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_2                    0x00000231 /* R--1R */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MPU_401_COM                                0x00000331 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_1                       0x00000301 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_2                       0x00000231 /* -W-1R */
#define NV_IO_MPU_401_COM_UART_MODE                             7:0 /* -WIVF */
#define NV_IO_MPU_401_COM_UART_MODE_COMPLEX              0x000000ff /* -WI-V */
#define NV_IO_MPU_401_COM_UART_MODE_SIMPLE               0x0000003f /* -W--V */
/* dev_realmode.ref */
#define NV_PRM                                0x00005FFF:0x00004000 /* RW--D */
#define NV_PRM_INTR_0                                    0x00004100 /* RW-4R */
#define NV_PRM_INTR_0_TRACE_MPU401                              0:0 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING           0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_PENDING               0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_RESET                 0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_FM                                  4:4 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_FM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_PENDING                   0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_RESET                     0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL                          8:8 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING       0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING           0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET             0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER                          12:12 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_EN_0                                 0x00004140 /* RW-4R */
#define NV_PRM_INTR_EN_0_TRACE_MPU401                           0:0 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED           0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED            0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_FM                               4:4 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_FM_DISABLED               0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_FM_ENABLED                0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL                       8:8 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED       0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED        0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER                       12:12 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_RAMRM                                     0x00004200 /* RW-4R */
#define NV_PRM_RAMRM_BASE_ADDRESS                             15:12 /* RWXVF */
#define NV_PRM_RAMRM_BASE_ADDRESS_2000                   0x00002000 /* RWI-V */
#define NV_PRM_TRACE                                     0x00004300 /* RW-4R */
#define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
#define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWXVF */
#define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_IO_READ                                    5:5 /* RWXVF */
#define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
#define NV_PRM_TRACE_INDEX                               0x00004310 /* RW-4R */
#define NV_PRM_TRACE_INDEX_ADDRESS                              9:0 /* RWXUF */
#define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0                                  0x00004320 /* RW-4R */
#define NV_PRM_IGNORE_0_MPU401                                  1:0 /* RWXVF */
#define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_FM                                      5:4 /* RWXVF */
#define NV_PRM_IGNORE_0_FM_DISABLED                      0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_FM_WRITES                        0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS                         0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS_WRITES                  0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL                              9:8 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED              0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS                 0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER                              13:12 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_MIXER_DISABLED                0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES            0x00000003 /* RW--V */
/* dev_realmode.ref */
#define NV_PRMIO                              0x00007FFF:0x00007000 /* RW--D */
/* dev_realmode.ref */
/* dev_realmode.ref */
#define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
#define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
#define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
#define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
#define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
#define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
#define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
#endif

#endif // _NV4_REF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class012.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*************************** NV1_BETA_SOLID ********************************\
*                                                                           *
* Module: CLASS012.C                                                        *
*   This module implements the NV1_BETA_SOLID object class                  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mc\nv\mcpower.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************************************************************
*
*   File: mcpower.c
*
*   Description:
*       This file contains the resource manager power management API.
*
******************************************************************************/

#include <nvrm.h>
#include <devinit.h>
#include "nvhw.h"

#define KERNEL_PM_STATE_CHANGE // Do in kernel state changes which used to be done in OS-specific section

// this define is in the chip-specific headers; it seems like it ought to go in nv_ref.h.
#define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */

//  Transition between power states
//  States are:
//  Level 0 - full on
//  Level 1 - slowed clocks
//  Level 2 - slowed clocks, mobile style (not all devices support)
//  Level 3 - very slow clocks, state saved (regs & instance memory)
RM_STATUS mcPowerState
(
    PHWINFO pDev, 
    U032    state
)
{
    U032 i, data, data32, ChipID, status;
    U016 data16;
    U008 lock, retry = 0;
    U032 *fb_sv, Head=0;
    BOOL   biosUsedToInit;

    switch (state) 
    {
        case MC_POWER_LEVEL_0:          // power up
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Power Level 0");
            switch (pDev->Power.State)  // procedure depends on what state we are transitioning from
            {
                case MC_POWER_LEVEL_1:
                    // turn clocks up
                    FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON);
                    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, pDev->Power.coeff_select);
                    REG_WR32(NV_PRAMDAC_NVPLL_COEFF, pDev->Power.nvpll);         // nvclk
                    REG_WR32(NV_PRAMDAC_MPLL_COEFF, pDev->Power.mpll);           // mclk
                    
                    nvHalMcPower(pDev, MC_POWER_LEVEL_0, pDev->Power.State);
                    
                    pDev->DeviceDisabled = FALSE;     // let ISR handle interrupts
                    break;
                
                case MC_POWER_LEVEL_2:
                    
                    data32 = (pDev->Power.PbusDebug1 & ~(SF_DEF(_PBUS, _DEBUG_1_IDDQ, _ONE)));
                    REG_WR32(NV_PBUS_DEBUG_1, data32);

                    osDelay(2); // wait 2 ms

                    data32 &= ~(SF_DEF(_PBUS, _DEBUG_1_PLL_STOPCLK, _ENABLE));
                    REG_WR32(NV_PBUS_DEBUG_1, data32);

                    nvHalMcPower(pDev, MC_POWER_LEVEL_0, pDev->Power.State);
                    
                    // now we are powered up
                    
#if 0
                    // Check for active displays and enable them
                    data32 = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[0].pVidLutCurDac))->DisplayType;
                    if ((data32 == DISPLAY_TYPE_MONITOR) || (data32 == DISPLAY_TYPE_FLAT_PANEL) || (data32 == DISPLAY_TYPE_TV))
                    {
                        dacEnableDac(pDev, 0);
                    }
                    data32 = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[1].pVidLutCurDac))->DisplayType;
                    if ((data32 == DISPLAY_TYPE_MONITOR) || (data32 == DISPLAY_TYPE_FLAT_PANEL) || (data32 == DISPLAY_TYPE_TV))
                    {
                        dacEnableDac(pDev, 1);
                    }
#endif                    
                    // now we are powered up
                    break;
                case MC_POWER_LEVEL_3:
                    // turn off bus master before resetting master enable
                    // else we may get spurious bus master cycles 
                    data32 = REG_RD32(NV_PBUS_PCI_NV_1);
                    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_1, _BUS_MASTER, _DISABLED);
                    // Reset the chip, in case the HW didn't.
                    REG_WR32(NV_PMC_ENABLE, 0);
                    REG_RD32(NV_PMC_ENABLE);
                    REG_RD32(NV_PMC_ENABLE);

                    REG_WR32(NV_PMC_ENABLE, -1);
                    REG_RD32(NV_PMC_ENABLE);
                    REG_RD32(NV_PMC_ENABLE);
                    // restore bus master enable
                    REG_WR32(NV_PBUS_PCI_NV_1, data32);

                    // turn DAC on
                    REG_WR32(NV_PRAMDAC_TEST_CONTROL, 0); // make sure test modes are off!
                    FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF); // leave output off

                    // Delay for a while before initializing chip; verify strap register is reading correctly.
                    // Note: it's not just incorrect strap values which cause the problem; without the delay,
                    // the problem still occurs, even if correct strap values are used to init.
                    // (else memory is not correctly init'd. Occurs on Dell Magellan (i820 chipset). Does not occur on rel4.)
               
                    while (REG_RD32(NV_PEXTDEV_BOOT_0) != pDev->Power.strapInfo) 
                    {
                        for (i=0; i<2000; i++) 
                        {
                            REG_RD32(NV_PMC_ENABLE);
                        }
                        REG_WR32(NV_PEXTDEV_BOOT_0, pDev->Power.strapInfo);    // WRITE STRAP REG
                        retry++;
                        if (retry == D0_DELAY_RETRIES) 
                            break;
                    }
                    // POST the device using BIOS init tables
                    DevinitInitializeDevice(pDev, (PHWREG)pDev->fb_save, &biosUsedToInit);

                    // turn clocks up
                    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, pDev->Power.coeff_select);
                    REG_WR32(NV_PRAMDAC_NVPLL_COEFF, pDev->Power.nvpll);         // nvclk
                    REG_WR32(NV_PRAMDAC_MPLL_COEFF, pDev->Power.mpll);           // mclk

                    // restore timer before attempting delay
                    REG_WR32(NV_PTIMER_NUMERATOR, pDev->Timer.Numerator);     
                    REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);     
                    // Wait 10 ms to allow PLL to lock.
                    // HW guy says 1 ms should be enough.
                    // In fact, very small delay seems to do it.
                    tmrDelay(pDev, 10000000); 
                                                
                    if (pDev == NvDBPtr_Table[0]) // if primary
                        // enable VGA I/O
                        REG_WR08(NV_PRMVIO_VSE2, 0x01);
                    // the chip may come up with instance memory write protected! Make sure its not.
                    nvHalFbControl(pDev, FB_CONTROL_INSTWR_ENABLE);
                    nvHalMcPower(pDev, MC_POWER_LEVEL_0, pDev->Power.State);

                    // restore critical registers lost during power down
                    REG_WR32(NV_PMC_ENABLE, pDev->Master.Enable);
                    //REG_WR32(NV_PBUS_PCI_NV_19, pDev->Master.PciNv19);    // not needed, now
                    // that we call nvUpdateAGPConfig (and dangerous, since FW could get re-enabled
                    // without re-enabling it in the motherboard chipset)

                    // next the display driver will get the foreground switch message, which calls rmEnableHires
                    // this starts us up again

                    //LPL: the 440BX-specific hack above to restore AGP registers
                    //can almost be removed.  The call below takes care of all the
                    //details (for more chipsets) except the register $50 issue.
                    NvUpdateAGPConfig(pDev);

                    // copy from save area to framebuffer instance memory
                    fb_sv = pDev->fb_save;

                    for(i=0; i < pDev->Pram.HalInfo.TotalInstSize / 4; i++)
                    {
                         data = *fb_sv++;
                         REG_WR32(NV_PRAMIN_DATA032(i), data);
                    }            
                    osFreeMem((VOID *)pDev->fb_save);
                    pDev->fb_save = 0;
                    pDev->DeviceDisabled = FALSE;     // let ISR handle interrupts
                    break;
            } // switch (pDev->Power.State)
#ifdef KERNEL_PM_STATE_CHANGE   // Do in kernel state changes which used to be done in OS-specific section
            // Unload VGA device state
            stateNv(pDev, STATE_UNLOAD);
            pDev->Vga.Enabled = FALSE;
            // Load HIRES device state
            stateNv(pDev, STATE_LOAD);
#endif            
            data16 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
            WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) (data16 & 0x3fff));     // enable syncs
            REG_WR32(NV_PMC_INTR_EN_0, 1);                 // re-enable interrupts.
            dacSetFan(pDev, 1);   // turn on fan
            
            // Set power state in PCI config reg so BIOS can read
            FLD_WR_DRF_DEF(_PBUS, _PCI_NV_25, _POWER_STATE, _D0);
            
            pDev->Power.State = MC_POWER_LEVEL_0;
            break;
        // end case MC_POWER_LEVEL_0
        
        //
        // Power Down
        //
        case MC_POWER_LEVEL_1:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Power Level 1");
            
#ifdef KERNEL_PM_STATE_CHANGE   // Do in kernel state changes which used to be done in OS-specific section
            // Unload HIRES device state
            stateNv(pDev, STATE_UNLOAD);
            pDev->Vga.Enabled = TRUE;
            // Load VGA device state
            stateNv(pDev, STATE_LOAD);
#endif            
            REG_WR32(NV_PMC_INTR_EN_0, 0);                      // disable all interrupts. 
            REG_WR32(NV_PMC_INTR_0, REG_RD32(NV_PMC_INTR_0));   // clear any pending ints
            pDev->DeviceDisabled = TRUE;                      // signal ISR to ignore
            dacSetFan(pDev, 0);   // turn off fan
            
            // stop fetching video mem
            data16 = ReadIndexed(NV_PRMVIO_SRX, 0x01);
            data16 |= 0x2000;   // screen off
            WriteIndexed(NV_PRMVIO_SRX, data16);
            
            // save current clock coefficients
            pDev->Power.coeff_select = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
            pDev->Power.nvpll = REG_RD32(NV_PRAMDAC_NVPLL_COEFF);   // nvclk
            pDev->Power.vpll = REG_RD32(NV_PRAMDAC_VPLL_COEFF);   // vclk
            pDev->Power.mpll = REG_RD32(NV_PRAMDAC_MPLL_COEFF);     // mclk

            // turn clocks down to save power
            FLD_WR_DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_SOURCE,_PROG_ALL);   // program all clocks
            FLD_WR_DRF_NUM(_PRAMDAC,_NVPLL_COEFF, _PDIV, 4);    // max pwr saving is not max divisor
            FLD_WR_DRF_NUM(_PRAMDAC,_NVPLL_COEFF, _NDIV, 4);    // pll lower limit around 4-10
            
            // High speed memories don't work with the following clock slow-down
            // Don't do it on NV15 Ultra or Quadro 2
            ChipID = REG_RD_DRF(_CONFIG_PCI, _NV_0, _DEVICE_ID);
            if ((ChipID != NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2) && (ChipID != NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3))
            {
                FLD_WR_DRF_NUM(_PRAMDAC,_MPLL_COEFF, _PDIV, 5);                 // div by 32
            }
            // Set PCLK to use the crystal
            FLD_WR_DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_SOURCE,_XTAL);  

            nvHalMcPower(pDev, MC_POWER_LEVEL_1, pDev->Power.State);

            // power down the DAC
            FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF);
            
            // Set power state in PCI config reg so BIOS can read
            FLD_WR_DRF_DEF(_PBUS, _PCI_NV_25, _POWER_STATE, _D3_HOT);
            
            pDev->Power.State = MC_POWER_LEVEL_1;
            break;
        
        case MC_POWER_LEVEL_2:
            
            // Power management for mobile chips:
            // Set RAM self-refresh mode (HAL)
            // Set flag to tell VGA BIOS to handle
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Power Level 2");

            // Blank both heads
            dacDisableDac(pDev, 0);
            dacDisableDac(pDev, 1);

            // Set power state in PCI config reg so BIOS can read
            FLD_WR_DRF_DEF(_PBUS, _PCI_NV_25, _POWER_STATE, _D3_HOT);

#ifdef KERNEL_PM_STATE_CHANGE   // Do in kernel state changes which used to be done in OS-specific section
            // Unload HIRES device state
            stateNv(pDev, STATE_UNLOAD);
            pDev->Vga.Enabled = TRUE;
            // Load VGA device state
            stateNv(pDev, STATE_LOAD);
#endif            
            nvHalMcPower(pDev, MC_POWER_LEVEL_2, pDev->Power.State);

            // leave the real mode access window pointing to PBUS_DEBUG_1 so that the BIOS can wake us up if called.
            REG_WR32(NV_PRMIO_RMA_PTR, NV_PBUS_DEBUG_1);    // point to PBUS_DEBUG_1 address
            lock = UnlockCRTC(pDev, Head);
            CRTC_WR(NV_CIO_CRE_RMA__INDEX, 5, Head);        // set data mode
            RestoreLock(pDev, Head, lock);

            data32 = REG_RD32(NV_PBUS_DEBUG_1);
            pDev->Power.PbusDebug1 = data32;                // save this for resume function
            FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _PLL_STOPCLK, _ENABLE);
    
            osDelay(2); // wait 2 ms

            FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _IDDQ, _ONE);
            
            pDev->Power.State = MC_POWER_LEVEL_2;
            break;
        
        case MC_POWER_LEVEL_3:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "Power Level 3");
#ifdef KERNEL_PM_STATE_CHANGE   // Do in kernel state changes which used to be done in OS-specific section
            // Unload HIRES device state
            stateNv(pDev, STATE_UNLOAD);
            pDev->Vga.Enabled = TRUE;
            // Load VGA device state
            stateNv(pDev, STATE_LOAD);
#endif            
            dacSetFan(pDev, 0);   // turn off fan
            REG_WR32(NV_PMC_INTR_EN_0, 0);                      // disable all interrupts. We're going to be shut down!
            REG_WR32(NV_PMC_INTR_0, REG_RD32(NV_PMC_INTR_0));   // clear any pending ints
            pDev->DeviceDisabled = TRUE;                      // signal ISR to ignore
            
            pDev->Power.strapInfo = REG_RD32(NV_PEXTDEV_BOOT_0);    // READ STRAPS

            nvHalMcPower(pDev, MC_POWER_LEVEL_3, pDev->Power.State);

            // We will always transition thru D0, so this SHOULDN'T ever be true.
            if (pDev->Power.State == MC_POWER_LEVEL_1) // if we slowed down mclk, restore it
            {
                REG_WR32(NV_PRAMDAC_MPLL_COEFF, pDev->Power.mpll);           // mclk
            }else if (pDev->Power.State == MC_POWER_LEVEL_4) //Have we gone through APM suspend?
            {
                // turn clocks up to avoid mem corruption when saving instance memory.
                REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, pDev->Power.coeff_select);
                REG_WR32(NV_PRAMDAC_NVPLL_COEFF, pDev->Power.nvpll);         // nvclk
                REG_WR32(NV_PRAMDAC_MPLL_COEFF, pDev->Power.mpll);           // mclk
            }
            
            // copy from framebuffer instance memory to save area.
            status = osAllocMem((VOID **)&pDev->fb_save, pDev->Pram.HalInfo.TotalInstSize);
            if (!status)
            {
                fb_sv = pDev->fb_save;
                for(i=0; i < pDev->Pram.HalInfo.TotalInstSize / 4; i++)
                {
                    *fb_sv++ = REG_RD32(NV_PRAMIN_DATA032(i));      // from the top--64k BIOS + instance memory
                                                                    // this actually decrements from the top
                }            
            }
            // Save clock coefficients
            if (pDev->Power.State == MC_POWER_LEVEL_0) // already slowed down clocks?
            {
                pDev->Power.nvpll = REG_RD32(NV_PRAMDAC_NVPLL_COEFF);   // nvclk
                pDev->Power.vpll = REG_RD32(NV_PRAMDAC_VPLL_COEFF);   // vclk
                pDev->Power.mpll = REG_RD32(NV_PRAMDAC_MPLL_COEFF);     // mclk
            }
            // turn clocks down to save power
            FLD_WR_DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_SOURCE,_PROG_ALL);   // program all clocks
            FLD_WR_DRF_NUM(_PRAMDAC,_NVPLL_COEFF, _PDIV, 4);    // max pwr saving is not max divisor
            FLD_WR_DRF_NUM(_PRAMDAC,_NVPLL_COEFF, _NDIV, 4);    // pll lower limit around 4-10
            FLD_WR_DRF_NUM(_PRAMDAC,_MPLL_COEFF, _PDIV, 5);                 // div by 32
            FLD_WR_DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_SOURCE,_XTAL);  // use crystal
            
            // Power down DAC
            FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF);

            // On some architectures it's not always the case that we will get
            // to D3 having come through D1. On the Mac we may get here from
            // D0. If that is the case we should save the power_coeff here.
            if (pDev->Power.State == MC_POWER_LEVEL_0) 
            {
                pDev->Power.coeff_select = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
            }

            // Save a few critical registers that are going to be lost
            pDev->Master.Enable = REG_RD32(NV_PMC_ENABLE);    // gr enable gets blown away
            pDev->Master.PciNv19 = REG_RD32(NV_PBUS_PCI_NV_19);     // read AGP COMMAND

            dacDisableDac(pDev, 1);         // blank display on second head
            
            // Set power state in PCI config reg so BIOS can read
            FLD_WR_DRF_DEF(_PBUS, _PCI_NV_25, _POWER_STATE, _D3_HOT);
            
            pDev->Power.State = MC_POWER_LEVEL_3;
            break; // case power level 3
    }
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class019.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV1_IMAGE_BLACK_RECTANGLE **************************\
*                                                                           *
* Module: CLASS019.C                                                        *
*   This module implements the NV1_IMAGE_BLACK_RECTANGLE object class       *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class017.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV1_CONTEXT_COLOR_KEY *****************************\
*                                                                           *
* Module: CLASS017.C                                                        *
*   This module implements the NV1_CONTEXT_COLOR_KEY object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class030.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** NV1_NULL_OBJECT ********************************\
*                                                                           *
* Module: CLASS030.C                                                        *
*   This module implements the NV1_NULL_OBJECT object class                 *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\mc\nv4\mcnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* MC Manager ********************************\
*                                                                           *
* Module: MCNV04.C                                                          *
*   The master control chip dependent HAL routines are kept here.           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nv4_ref.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// NV04 MC HAL entry points.
//

//
// nvHalMcControl
//
RM_STATUS
nvHalMcControl_NV04(VOID *arg)
{
    PMCCONTROLARG_000 pMcControlArg = (PMCCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMcControlArg->pHalHwInfo;
    PMCHALINFO pMcHalInfo;
    PMCHALINFO_NV04 pMcHalPvtInfo;
    U032 M, N, O, P;
    U032 crystal;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalMcControl_NV04\r\n");

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pMcControlArg->id != MC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pMcHalPvtInfo = (PMCHALINFO_NV04)pHalHwInfo->pMcHalPvtInfo;

    switch (pMcControlArg->cmd)
    {
        case MC_CONTROL_SETREVISION:
        {
            PPRAMHALINFO pPramHalInfo = pHalHwInfo->pPramHalInfo;

            // set the inst mem offset
            pPramHalInfo->PraminOffset = DEVICE_BASE(NV_PRAMIN);

            //
            // Get chip revision information.
            //
            // We need to be careful here that the values we pull from the
            // hardware line up with the constants defined in chipid.h, or
            // else we need to convert them accordingly.
            //
            // On NV4 and family, they do so we're OK.
            //

            pMcHalInfo->Revision = REG_RD_DRF(_PMC, _BOOT_0, _MAJOR_REVISION);
            pMcHalInfo->Subrevision = REG_RD_DRF(_PMC, _BOOT_0, _MINOR_REVISION);
            pMcHalInfo->Implementation = REG_RD_DRF(_PMC, _BOOT_0, _IMPLEMENTATION);
            pMcHalInfo->Architecture = REG_RD_DRF(_PMC, _BOOT_0, _ARCHITECTURE);
            pMcHalInfo->Manufacturer = REG_RD_DRF(_PMC, _BOOT_0, _MANUFACTURER);
            pMcHalInfo->MaskRevision = REG_RD_DRF(_PMC, _BOOT_0, _MASK_REVISION);

            //
            // Since the Implementation is used by the RM only, we
            // set it to the MASK_REVISION to make out chip id 
            // function implementations cleaner.
            //
            // NOTE: BE CAREFUL HERE!  The MaskRevision must line up
            // with the MC_IMPLEMENTATION macros in <mc.h>.
            //
            pMcHalInfo->Implementation = pMcHalInfo->MaskRevision;
            break;
        }
        case MC_CONTROL_INIT:
        {
            PDACHALINFO pDacHalInfo = pHalHwInfo->pDacHalInfo;
            PFIFOHALINFO pFifoHalInfo = pHalHwInfo->pFifoHalInfo;

            // JJV - Reset toggle the Master Control for the fifo and the Bus Mastering logic.
            // This is a fix for a DELL restart hang.19990409-125432.
            {
                U032 x;

                x=REG_RD32(NV_PMC_ENABLE);
                x&=~(DRF_DEF(_PMC, _ENABLE, _PFIFO, _ENABLED) | DRF_DEF(_PMC, _ENABLE, _PPMI, _ENABLED));
                REG_WR32(NV_PMC_ENABLE,x); 
                x|=(DRF_DEF(_PMC, _ENABLE, _PFIFO, _ENABLED) | DRF_DEF(_PMC, _ENABLE, _PPMI, _ENABLED));
                REG_WR32(NV_PMC_ENABLE,x); 
            }

            //
            // Save original MC registers.
            //
            pMcHalPvtInfo->SavePmc = REG_RD32(NV_PMC_ENABLE);
            if (pMcHalPvtInfo->SavePmc == 0)
            {
                //
                // This is 0 if NV not boot device! Enable everything so we at least work.
                //
                pMcHalPvtInfo->SavePmc = 0xFFFFFFFF;
                //
                // Reset all devices and interrupts.
                //
                REG_WR32(NV_PMC_ENABLE, 0x00000000);
            }
            pMcHalPvtInfo->SaveIntrEn0 = REG_RD32(NV_PMC_INTR_EN_0);
            REG_WR32(NV_PMC_ENABLE, 0xFFFFFFFF);
    
            //
            // Get the current clock settings.  This, of course, assumes that someone
            // has already started up the PLL's.
            //
            // Determine current strap crystal frequency (in Hz)
            //
            if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
                pMcHalInfo->CrystalFreq = 13500000;
            else if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
                pMcHalInfo->CrystalFreq = 14318180;

            // Get the crystal (Fin) * 1000
            crystal = pMcHalInfo->CrystalFreq;

            M = REG_RD_DRF(_PRAMDAC, _MPLL_COEFF, _MDIV);
            N = REG_RD_DRF(_PRAMDAC, _MPLL_COEFF, _NDIV);
            P = REG_RD_DRF(_PRAMDAC, _MPLL_COEFF, _PDIV);
            O = 1;
    
            pDacHalInfo->MPllM = M;
            pDacHalInfo->MPllN = N;
            pDacHalInfo->MPllO = O;
            pDacHalInfo->MPllP = P;
            if ((!P) && IsNV4_NV04(pMcHalInfo))
                P = 1;      // never really zero on NV4
            pDacHalInfo->MClk  = ( M != 0 ) ? (N * crystal / (1 << P) / M) : 0;
    
            M = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _MDIV);
            N = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _NDIV);
            P = REG_RD_DRF(_PRAMDAC, _VPLL_COEFF, _PDIV);
            O = 1;
    
            pDacHalInfo->VPllM = M;
            pDacHalInfo->VPllN = N;
            pDacHalInfo->VPllO = O;
            pDacHalInfo->VPllP = P;
            //pDacHalInfo->VClk  = (N * 12096 / (1 << P) / M) * 500;
            pDacHalInfo->VClk  = ( M != 0 ) ? (N * crystal / (1 << P) / M) : 0;

            M = REG_RD_DRF(_PRAMDAC, _NVPLL_COEFF, _MDIV);
            N = REG_RD_DRF(_PRAMDAC, _NVPLL_COEFF, _NDIV);
            P = REG_RD_DRF(_PRAMDAC, _NVPLL_COEFF, _PDIV);
            O = 1;
    
            pDacHalInfo->NVPllM = M;
            pDacHalInfo->NVPllN = N;
            pDacHalInfo->NVPllO = O;
            pDacHalInfo->NVPllP = P;
            pDacHalInfo->NVClk  = ( M != 0 ) ? (N * crystal / (1 << P) / M) : 0;

            //
            // Initialize number of crtcs.
            //
            pDacHalInfo->NumCrtcs = 1;

            //
            // Get chip revision information.
            //
            // We need to be careful here that the values we pull from the
            // hardware line up with the constants defined in chipid.h, or
            // else we need to convert them accordingly.
            //
            // On NV4 and family, they do so we're OK.
            //
            pMcHalInfo->Revision = REG_RD_DRF(_PMC, _BOOT_0, _MAJOR_REVISION);
            pMcHalInfo->Subrevision = REG_RD_DRF(_PMC, _BOOT_0, _MINOR_REVISION);
            pMcHalInfo->Implementation = REG_RD_DRF(_PMC, _BOOT_0, _IMPLEMENTATION);
            pMcHalInfo->Architecture = REG_RD_DRF(_PMC, _BOOT_0, _ARCHITECTURE);
            pMcHalInfo->Manufacturer = REG_RD_DRF(_PMC, _BOOT_0, _MANUFACTURER);
            pMcHalInfo->MaskRevision = REG_RD_DRF(_PMC, _BOOT_0, _MASK_REVISION);

            //
            // Since the Implementation is used by the RM only, we
            // set it to the MASK_REVISION to make out chip id 
            // function implementations cleaner.
            //
            // NOTE: BE CAREFUL HERE!  The MaskRevision must line up
            // with the MC_IMPLEMENTATION macros in <mc.h>.
            //
            pMcHalInfo->Implementation = pMcHalInfo->MaskRevision;

            //
            // If this is a TNT2 revB, enable AGP differential mode
            //
            if (IsNV5orBetter_NV04(pMcHalInfo) &&
                (REG_RD_DRF(_PBUS, _PCI_NV_2, _REVISION_ID) & NV_PBUS_PCI_NV_2_REVISION_ID_B01))
            {
                FLD_WR_DRF_DEF(_PBUS, _DEBUG_2, _AGP_AD_STB, _DIFFERENTIAL);
            }

            //
            // Only worry about PMI toggling for NV5 class devices
            //
            if (IsNV5orBetter_NV04(pMcHalInfo))
            {
                U032 savedPCI1, savedPCI19;

                //
                // Toggle PMI off to clear any strobe glitches from Camino that occurred during POST
                //
                // First disable bus mastering
                //
                savedPCI1 = REG_RD32(NV_PBUS_PCI_NV_1);
                REG_WR32(NV_PBUS_PCI_NV_1, savedPCI1 & ~DRF_DEF(_PBUS, _PCI_NV_1, _BUS_MASTER, _ENABLED));
                savedPCI19 = REG_RD32(NV_PBUS_PCI_NV_19);
                REG_WR32(NV_PBUS_PCI_NV_19, savedPCI19 & ~DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE, _ON));

                // Toggle PMI off                     
                REG_WR32(NV_PMC_ENABLE, 0xFFFFFFFF & ~DRF_DEF(_PMC, _ENABLE, _PPMI, _ENABLED));

                // Turn everything back on    
                REG_WR32(NV_PMC_ENABLE, 0xFFFFFFFF);

                //
                // Restore AGP Busmastering
                //
                REG_WR32(NV_PBUS_PCI_NV_1, savedPCI1);
                REG_WR32(NV_PBUS_PCI_NV_19, savedPCI19);
            }

            //
            // Set fifo count/context size here so the values are
            // available for the rest of the STATE_INIT sequence.
            //
            pFifoHalInfo->Count = NUM_FIFOS_NV04;
            pFifoHalInfo->ContextSize = FC_SIZE_NV04;
            break;
        }
        case MC_CONTROL_DESTROY:
            REG_WR32(NV_PMC_ENABLE, pMcHalPvtInfo->SavePmc);
            REG_WR32(NV_PMC_INTR_EN_0, pMcHalPvtInfo->SaveIntrEn0);
            break;
        case MC_CONTROL_LOAD:
        case MC_CONTROL_UNLOAD:
        case MC_CONTROL_UPDATE:
            break;
    }

    return (RM_OK);
}

//
// nvHalMcPower
//
RM_STATUS
nvHalMcPower_NV04(VOID *arg)
{
    PMCPOWERARG_000 pMcPowerArg = (PMCPOWERARG_000)arg;
    PHALHWINFO pHalHwInfo = pMcPowerArg->pHalHwInfo;
    PMCHALINFO_NV04 pMcHalPvtInfo;
    PMCHALPOWERINFO_NV04 pMcHalPowerInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvHalMcPower_NV04\r\n");

    // ASSERTIONS

    //
    // Verify interface revision.
    //
    if (pMcPowerArg->id != MC_POWER_000)
        return (RM_ERR_VERSION_MISMATCH);

    pMcHalPvtInfo = (PMCHALINFO_NV04)pHalHwInfo->pMcHalPvtInfo;
    pMcHalPowerInfo = &pMcHalPvtInfo->PowerInfo;

    //
    // Handle power management state transition.
    //
    switch (pMcPowerArg->newLevel)
    {
        case MC_POWER_LEVEL_0:
            switch (pMcPowerArg->oldLevel)
            {
                case MC_POWER_LEVEL_1:
                    //
                    // Turn up clock.
                    //
                    FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _ON);
                    break;
                case MC_POWER_LEVEL_2:
                    break;
                case MC_POWER_LEVEL_4:
                    //
                    // Power up mode - restore previous refresh value.
                    //
                    REG_WR32(NV_PFB_DEBUG_0, pMcHalPowerInfo->PfbDebug0);
                    REG_WR32(NV_PFB_BOOT_0, pMcHalPowerInfo->PfbBoot0);
                    REG_WR32(NV_PFB_CONFIG_0, pMcHalPowerInfo->PfbConfig0);
                    REG_WR32(NV_PFB_CONFIG_1, pMcHalPowerInfo->PfbConfig1);

                    //
                    // Turn up clock.
                    //
                    FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _ON);
                    break;
                case MC_POWER_LEVEL_3:
                {
                    PFIFOHALINFO_NV04 pFifoHalPvtInfo;

                    pFifoHalPvtInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalPvtInfo;
                    
                    //
                    // Power up mode - restore previous refresh value
                    //
                    REG_WR32(NV_PFB_DEBUG_0, pMcHalPowerInfo->PfbDebug0);
                    REG_WR32(NV_PFB_BOOT_0, pMcHalPowerInfo->PfbBoot0);
                    REG_WR32(NV_PFB_CONFIG_0, pMcHalPowerInfo->PfbConfig0);
                    REG_WR32(NV_PFB_CONFIG_1, pMcHalPowerInfo->PfbConfig1);

                    REG_WR32(NV_PFIFO_RAMHT, pMcHalPowerInfo->PfifoRamHt);
                    REG_WR32(NV_PFIFO_RAMFC, pMcHalPowerInfo->PfifoRamFc);
                    REG_WR32(NV_PFIFO_RAMRO, pMcHalPowerInfo->PfifoRamRo);

                    //
                    // Make sure write protection is disabled.
                    //
                    FLD_WR_DRF_DEF(_PFB, _CONFIG_0, _PRAMIN_WR, _INIT);

                    //
                    // Restore fifo mode register.
                    //
                    REG_WR32(NV_PFIFO_MODE, pFifoHalPvtInfo->Mode);

                    //
                    // Set to unused channel to force context switch
                    // when fifo is accessed.
                    //
                    REG_WR32(NV_PFIFO_CACHE0_PUSH1, NUM_FIFOS_NV04-1);
                    REG_WR32(NV_PFIFO_CACHE1_PUSH1, NUM_FIFOS_NV04-1);

                    //
                    // Turn up clock.
                    //
                    FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _ON);
                }
            }
            break;
        case MC_POWER_LEVEL_1:
            //
            // Turn down clock.
            //
            FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _VPLL);
            break;
        case MC_POWER_LEVEL_2:
            break;
        case MC_POWER_LEVEL_3:
        case MC_POWER_LEVEL_4:
            // power down mode - max out memory refresh value
            pMcHalPowerInfo->PfbDebug0 = REG_RD32(NV_PFB_DEBUG_0);
            FLD_WR_DRF_NUM(_PFB, _DEBUG_0, _REFRESH_COUNTX64, 0x01);

            // Chip has been init'd with the BIOS init tables, unless the BIOS
            // has an incompatible structure and the table was not found, in which case
            // we used a default table, which may not have the correct RAM config, so
            // we save away the current config for restoration above.
            pMcHalPowerInfo->PfbBoot0 = REG_RD32(NV_PFB_BOOT_0);
            pMcHalPowerInfo->PfbConfig0 = REG_RD32(NV_PFB_CONFIG_0);
            pMcHalPowerInfo->PfbConfig1 = REG_RD32(NV_PFB_CONFIG_1);

            pMcHalPowerInfo->PfifoRamHt = REG_RD32(NV_PFIFO_RAMHT);
            pMcHalPowerInfo->PfifoRamFc = REG_RD32(NV_PFIFO_RAMFC);
            pMcHalPowerInfo->PfifoRamRo = REG_RD32(NV_PFIFO_RAMRO);

/*
When going into hibernation, the NT miniport makes a power state transition from state 0 to state 3.  State 3
implies that ALL clocks have been put in a power-down state, i.e. lowered.  Unfortunately, NT also requires 
the ability to perform VGA accesses *AFTER* the power management call.  Putting PClk into a power-down state 
disables VGA accesses, so for the time being, for NT, we cannot allow PClk to be put into a power-down state.
NOTE:  This is a liability if the system does not truly remove power from the device during hibernation.  In
this case, PClk will still be drawing full current, which could lead to power saving specs' being violated or,
more importantly, reliability problems with the device.
*/
#ifndef NTRM
            //
            // Turn down clock.
            //
            //FLD_WR_DRF_DEF(_PRAMDAC,_PLL_SETUP_CONTROL, _PWRDWN, _VPLL);
#endif
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}


//
// Chip id functions internal to the HAL.
//
// Note that checking for an Architecture value of MC_ARCHITECTURE_NV04
// should probably be replaced with an ASSERT (i.e. these routines should
// only be used by code operating on an nv4 family device).
//
BOOL
IsNV4_NV04(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV04) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV04));
}

BOOL
IsNV5_NV04(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV04) &&
            (pMcHalInfo->Implementation >= MC_IMPLEMENTATION_NV05));
}

BOOL
IsNV0A_NV04(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    return ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV04) &&
            (pMcHalInfo->Implementation == MC_IMPLEMENTATION_NV0A));
}

BOOL
IsNV5orBetter_NV04(PMCHALINFO pMcHalInfo)
{
#ifdef DEBUG
    if (!pMcHalInfo->Architecture)
        return (RM_ERROR);
        //DBG_BREAKPOINT();   // mask revision hasn't been set yet
#endif
    return ((pMcHalInfo->Architecture > MC_ARCHITECTURE_NV04) ||
            ((pMcHalInfo->Architecture == MC_ARCHITECTURE_NV04) &&
             (pMcHalInfo->Implementation >= MC_IMPLEMENTATION_NV05)));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class018.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** NV01_CONTEXT_PATTERN ******************************\
*                                                                           *
* Module: CLASS018.C                                                        *
*   This module implements the NV01_CONTEXT_PATTERN object class            *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class021.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV1_IMAGE_FROM_CPU ******************************\
*                                                                           *
* Module: CLASS021.C                                                        *
*   This module implements the NV1_IMAGE_FROM_CPU object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class021Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation == NV_SRCCOPY_AND  ||  
                    pRenderObject->RCPatchContext.ColorKey == NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class021SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class021SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_SOLID:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class021Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class021SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class021SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class021Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class021SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class021SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class021Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class021SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class021SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class021Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class021SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class021SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class021Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class021SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class021SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class021Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class021SetOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class021SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class021Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class01e.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV1_RENDER_SOLID_RECTANGLE *************************\
*                                                                           *
* Module: CLASS01E.C                                                        *
*   This module implements the NV1_RENDER_SOLID_RECTANGLE object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class01EValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class01ESetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01ESetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01EValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class01ESetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01ESetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01ESetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01ESetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01ESetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01ESetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01ESetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01ESetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01ESetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01ESetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01EValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class01f.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*************************** NV1_IMAGE_BLIT ********************************\
*                                                                           *
* Module: CLASS01F.C                                                        *
*   This module implements the NV1_IMAGE_BLIT object class                  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class01FValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation == NV_SRCCOPY_AND  ||  
                    pRenderObject->RCPatchContext.ColorKey == NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL) &&
        (pRenderObject->RCPatchContext.SurfaceSource != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;    
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class01FSetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_SOLID:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class01FSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class01FSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetContextSurfaceSource
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextSurfaceSource\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.SurfaceSource = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_1:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.SurfaceSource = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.SurfaceSource = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class038.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV4_DVD_SUBPICTURE ******************************\
*                                                                           *
* Module: CLASS038.C                                                        *
*   This module implements the NV4_DVD_SUBPICTURE object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class042.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV4_CONTEXT_SURFACES_2D ****************************\
*                                                                           *
* Module: CLASS042.C                                                        *
*   This module implements the NV4_CONTEXT_SURFACES_2D object class         *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class01c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV1_RENDER_SOLID_LIN *****************************\
*                                                                           *
* Module: CLASS01C.C                                                        *
*   This module implements the NV1_RENDER_SOLID_LIN object class            *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class01CValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032 andMask,
    U032 orMask
)
{
    RM_STATUS status = RM_OK;
    
    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class01CSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: class01CSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01CValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class01CSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01CSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01CSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01CSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01CSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01CSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01CSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01CSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01CSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01CSetOperation\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01CValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class043.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*************************** NV3_CONTEXT_ROP *******************************\
*                                                                           *
* Module: CLASS043.C                                                        *
*   This module implements the NV3_CONTEXT_ROP object class                 *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class044.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV4_CONTEXT_PATTERN ******************************\
*                                                                           *
* Module: CLASS044.C                                                        *
*   This module implements the NV4_CONTEXT_PATTERN object class             *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class01d.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV1_RENDER_SOLID_TRIANGLE **************************\
*                                                                           *
* Module: CLASS01D.C                                                        *
*   This module implements the NV1_RENDER_SOLID_TRIANGLE object class       *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class01DValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class01DSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01DSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01DValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class01DSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01DSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01DSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01DSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01DSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01DSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01DSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01DSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01DSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01DSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01DValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class037.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV3_SCALED_IMAGE_FROM_MEMORY *************************\
*                                                                           *
* Module: CLASS037.C                                                        *
*   This module implements the NV3_SCALED_IMAGE_FROM_MEMORY object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class037Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class037SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class037SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class037SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class037SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class037SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class036.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV3_STRETCHED_IMAGE_FROM_CPU *************************\
*                                                                           *
* Module: CLASS036.C                                                        *
*   This module implements the NV3_STRETCHED_IMAGE_FROM_CPU object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class036Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation == NV_SRCCOPY_AND  ||  
                    pRenderObject->RCPatchContext.ColorKey == NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }
        
    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class036SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_SOLID:
                //
                // This is a valid colorkey object
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class036SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class036SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class036SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class036SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class036SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class046.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class046.C                                                        *
*   This module implements the NV04_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class046SetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate, 
                              0, 
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class046SetNotifyCtxDma

RM_STATUS class046SetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;
    
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046SetNotify

RM_STATUS class046StopImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046StopImage\r\n");

    // class046 supports only one head (head 0)
    dacDisableImage(pDev, 0);

    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046StopImage

RM_STATUS class046StopLUT
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046StopLUT\r\n");
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046StopLUT

RM_STATUS class046StopCursorImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    Head = 0;   // single-head class
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046StopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, Head);

    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046StopCursorImage

RM_STATUS class046StopDAC
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046StopDAC\r\n");

    // class046 supports only one head (head 0).
    dacDisableDac(pDev, 0);

    // reset display type
    SETDISPLAYTYPE(pDev, 0, 0xffffffff);
    
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046StopDAC

RM_STATUS class046SetImageCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV046_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;
    
    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

        if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class046SetImageCtxDma

RM_STATUS class046SetLUTCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV046_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;
    
    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

        if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma, 
                              0, 
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class046SetLUTCtxDma

RM_STATUS class046SetCursorCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV046_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;
    
    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

        if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma, 
                              0, 
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class046SetCursorCtxDma

RM_STATUS class046SetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // For this head, this becomes the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV046_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class046SetPanOffset

RM_STATUS class046GetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046GetOffset\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 
                                         pVidLutCurDac->Image[Data].Offset, 
                                         NV046_NOTIFICATION_INFO16_VALID_OFFSET, 
                                         NV046_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV046_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV046_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE; 
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046GetOffset

// This proc writes the notification for an image buffer.
RM_STATUS class046ImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV046_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV046_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;   
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class046SetImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
        //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV046_SET_IMAGE_OFFSET(0):
        case NV046_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV046_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x03) != 0)
                // The image offset must be a multiple of 4 bytes.
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV046_SET_IMAGE_FORMAT(0):
        case NV046_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  startAddr;
            U032  Head = 0;   // single-head class
            
            buffNum = (Offset == NV046_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV046_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x1F) != 0)
                // the minimum pitch must be a multiple of 32 bytes.
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;

            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV046_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The imageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr) + 
                               pVidLutCurDac->Image[buffNum].Offset);
            // add in the panning offset
            startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

            status = dacProgramVideoStart(pDev, Head, startAddr, pitch);
            if (status) 
                return NV046_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // setup so we get a callback to do the notify at the next VBlank.
            pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class046ImageNotify;
            pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->Image[buffNum].ImageCallback.Next    = NULL;
            pVidLutCurDac->Image[buffNum].ImageCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->Image[buffNum].ImageCallback.Param2  = buffNum;
            pVidLutCurDac->Image[buffNum].ImageCallback.Status  = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

            // Defaults to head 0.
            VBlankAddCallback(pDev, 0, &(pVidLutCurDac->Image[buffNum].ImageCallback));
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class046SetImageValues

// This proc is called from VBlank to program the LUT.
RM_STATUS class046ProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032*     startAddr;
    U032      numEntries;
    U032    Head = 0;   // single-head class

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset, 
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, Head, startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                myStatus,
                                NV046_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV046_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          myStatus, 
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;   
    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class046SetLUTValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
        //
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV046_SET_LUT_OFFSET(0):
        case NV046_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV046_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3FF) != 0)
                // The LUT offset must be a multiple of 1024 bytes.
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV046_SET_LUT_FORMAT(0):
        case NV046_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV046_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class046ProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class046SetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class046CursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV046_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV046_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;   
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class046SetCursorImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetCursorImageValues\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
        //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV046_SET_CURSOR_IMAGE_OFFSET(0):
        case NV046_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV046_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3ff) != 0)
                // The cursor image offset must be a multiple of 1024 bytes.
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV046_SET_CURSOR_IMAGE_FORMAT(0):
        case NV046_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            U032    Head = 0;   // single-head class
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV046_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            // The cursor is always 32x32 image with a color format LE_ROP1R5G5B5. 
            pVidLutCurDac->CursorImage[buffNum].Width       = 32; 
            pVidLutCurDac->CursorImage[buffNum].Height      = 32; 
            pVidLutCurDac->CursorImage[buffNum].ColorFormat = 0;  // LE_ROP1R5G5B5

            pVidLutCurDac->CursorImage[buffNum].NotifyAction = Data; 

            // Kick off the trasfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) + 
                                pVidLutCurDac->CursorImage[buffNum].Offset);
            status = nvHalDacProgramCursorImage(pDev, startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           32 /* width */, 
                                           32 /* height */, 0 /* colorFormat LE_ROP1R5G5B5 */,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status) 
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, Head);

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class046CursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        default:
            return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class046SetCursorImageValues

RM_STATUS class046SetCursorPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetCursorPoint\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, Head,
                                      (Data & 0xffff), /* cursorX */ 
                                      (Data >> 16));   /* cursorY */
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046SetCursorPoint

RM_STATUS class046SetDACValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV046_SET_DAC_IMAGE_SIZE(0):
        case NV046_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV046_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.    
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048. 
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set Horizontal Blank
        //
        case NV046_SET_DAC_HORIZONTAL_BLANK(0):
        case NV046_SET_DAC_HORIZONTAL_BLANK(1):
        {
            buffNum = (Offset == NV046_SET_DAC_HORIZONTAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 1024))       // width greater than 1024
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV046_SET_DAC_HORIZONTAL_SYNC(0):
        case NV046_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV046_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set Vertical Blank
        //
        case NV046_SET_DAC_VERTICAL_BLANK(0):
        case NV046_SET_DAC_VERTICAL_BLANK(1):
        {
            buffNum = (Offset == NV046_SET_DAC_VERTICAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 128))  // width greater than 128
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Vertical sync
        //
        case NV046_SET_DAC_VERTICAL_SYNC(0):
        case NV046_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV046_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set total size.
        //
        case NV046_SET_DAC_TOTAL_SIZE(0):
        case NV046_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV046_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.    
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2. 
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        // Set pixel clock.
        case NV046_SET_DAC_PIXEL_CLOCK(0):
        case NV046_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV046_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV046_SET_DAC_FORMAT(0):
        case NV046_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV046_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR) pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;
            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV046_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV046_SET_DAC_FORMAT_COLOR);

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;
            
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;   

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;
            pDev->Dac.HalInfo.PixelClock      = pVidLutCurDac->HalObject.Dac[buffNum].PixelClock;
            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;
			switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
				case NV046_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
					pDev->Dac.HalInfo.Depth = 8;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
					break;
				case NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
					pDev->Dac.HalInfo.Depth = 15;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV046_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
					pDev->Dac.HalInfo.Depth = 16;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
					pDev->Dac.HalInfo.Depth = 32;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
					break;
			}

            pDev->Dac.PixelDepth    = pDev->Dac.HalInfo.Depth;
            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth     = pDev->Dac.HalInfo.Depth;
            
            // Get output device...
            pVidLutCurDac->DisplayType		  = (Data >> DRF_SHIFT(NV046_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV046_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class046: invalid display type ", pVidLutCurDac->DisplayType);
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard		  = (Data >> DRF_SHIFT(NV046_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV046_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class046: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            
            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);

            if (pVidLutCurDac->CBase.NotifyXlate) 
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                                 modeSetStatus,
                                                 NV046_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                                  NV046_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */, 
                                  0 /* Data */, 
                                  modeSetStatus, 
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;   

            return modeSetStatus;
        }
        
        default:
            return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class046SetDACValues
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class047.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY methods.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/video/videoobj.c
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

RM_STATUS class047StopOverlayNow
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEO_OVERLAY_OBJECT           pOverlayObject;
    PVIDEO_OVERLAY_HAL_OBJECT       pOverlayHalObject;
    RM_STATUS                       status;
    U032                            Head = 0; // this is a single-head class

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    pOverlayHalObject = &pOverlayObject->HalObject;
    VidLutCurDac.Head = Head;

    //
    // Stop the current data transfer immediately.
    //
    if (pOverlayHalObject->Overlay[0].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray(pDev, pOverlayObject->Common.Base.NotifyXlate, 
                                0, // info32
                                0, // info16
                                RM_OK, 
                                NV047_NOTIFIERS_SET_OVERLAY(0));
        pOverlayHalObject->Overlay[0].State = OVERLAY_BUFFER_IDLE;
    }
    if (pOverlayHalObject->Overlay[1].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray(pDev, pOverlayObject->Common.Base.NotifyXlate, 
                                0,  // info32
                                0,  // info16
                                RM_OK, 
                                NV047_NOTIFIERS_SET_OVERLAY(1));
        pOverlayHalObject->Overlay[1].State = OVERLAY_BUFFER_IDLE;
    }

    //
    // Notify this one
    //
    if (pOverlayObject->Common.Base.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pOverlayObject->Common.Base.NotifyXlate, 
                                0, // info32
                                0, // info16
                                RM_OK, 
                                NV047_NOTIFIERS_SET_OVERLAY(BuffNum));
    }     

    //
    // Issue stop-immediately call to HAL.
    //
    (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, NV047_STOP_OVERLAY(BuffNum), NV047_STOP_OVERLAY_AS_SOON_AS_POSSIBLE, &status);

    //
    // Transition state of object back to uninitialized.
    //
    pOverlayObject->InitState = 0;

    //
    // Video has been disabled, so refresh arb settings.
    //
    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);

    //
    // Clear the active overlay object.
    //
    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pOverlayObject)
    {
        pDev->Video.HalInfo.ActiveVideoOverlayObject = NULL;
        pDev->Video.HalInfo.Enabled = 0;
    }

    return status;
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class047SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                   status;
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    PVIDEO_OVERLAY_HAL_OBJECT   pOverlayHalObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    pOverlayHalObject = &pOverlayObject->HalObject;

    if (pOverlayObject->CBase.NotifyTrigger)
        return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->CBase.NotifyXlate));
    if (status)
        return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pOverlayObject->CBase.NotifyXlate, 
                              0, 
                              (3 * 0x0010));
    if (status)
    {
        pOverlayObject->CBase.NotifyXlate = NULL;
        return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class047SetNotifyCtxDma

RM_STATUS class047SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    pOverlayObject->CBase.NotifyAction  = Data;
    pOverlayObject->CBase.NotifyTrigger = TRUE;
    
    return (NV047_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class047SetNotify

RM_STATUS class047StopOverlay
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT pOverlayObject;
    U032                  buffNum;
  
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047StopOverlay\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    buffNum = (Offset == NV047_STOP_OVERLAY(0)) ? 0 : 1;
    if (Data == NV047_STOP_OVERLAY_AS_SOON_AS_POSSIBLE) 
    {
        class047StopOverlayNow(pDev, (POBJECT)pOverlayObject, 
                               0 /* param1 */, buffNum, 
                               NV047_NOTIFICATION_STATUS_DONE_SUCCESS);
    }
    else
    {
        if (pOverlayObject->HalObject.Overlay[buffNum].State != OVERLAY_BUFFER_STOP_PENDING) {
            // setup so we get a callback to do the stop at the next VBlank.
            pOverlayObject->Overlay[buffNum].OverlayCallback.Proc   = class047StopOverlayNow;
            pOverlayObject->Overlay[buffNum].OverlayCallback.Object = (POBJECT) pOverlayObject;
            pOverlayObject->Overlay[buffNum].OverlayCallback.Next    = NULL;
            pOverlayObject->Overlay[buffNum].OverlayCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pOverlayObject->Overlay[buffNum].OverlayCallback.Param2  = buffNum;
            pOverlayObject->Overlay[buffNum].OverlayCallback.Status  = NV047_NOTIFICATION_STATUS_DONE_SUCCESS;

            // Defaults to head 0.
            VBlankAddCallback(pDev, 0, &(pOverlayObject->Overlay[buffNum].OverlayCallback));
            pOverlayObject->HalObject.Overlay[buffNum].State = OVERLAY_BUFFER_STOP_PENDING;
        }
    }

    return (NV047_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class047StopOverlay

RM_STATUS class047SetOverlayCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetOverlayCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    buffNum = (Offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);    

	if (Data == NV01_NULL_OBJECT)
    {
       	pOverlayObject->Overlay[buffNum].OverlayCtxDma = NULL;
        pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = NULL;
        return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->Overlay[buffNum].OverlayCtxDma));
    if (status)
        return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    // The overlay context dma MUST point to the frame buffer.
    if (pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo.AddressSpace != ADDR_FBMEM)
    {
        return NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
    }

    // Give HAL access to context dma.
    pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = &pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo;

    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class047SetOverlayCtxDma

RM_STATUS class047GetOffset
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047GetOffset\r\n");
    
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    if (!pOverlayObject->CBase.NotifyTrigger)
        // nothing to do.
        return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;

    //
    // The caller is expecting a notification. 
    //
    if (pOverlayObject->CBase.NotifyXlate) 
    {
        //
        // Give HAL chance to setup offset if necessary.
        //
        (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
        if (status)
            return status;
        status = notifyFillNotifierArray(pDev, pOverlayObject->CBase.NotifyXlate, 
                                         pOverlayObject->HalObject.Overlay[Data].Offset,   // info32
                                         NV047_NOTIFICATION_INFO16_VALID_OFFSET, // info16
                                         NV047_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV047_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pOverlayObject->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pOverlayObject, 
                          NV047_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pOverlayObject->CBase.NotifyAction);
        }
    }
    pOverlayObject->CBase.NotifyTrigger = FALSE; 
    return (NV047_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class047GetOffset

RM_STATUS class047SetOverlayValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    RM_STATUS status;
    U032                         Head = 0; // this is a single-head class

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetOverlayValues\r\n");

    VidLutCurDac.Head = Head;

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
	//
    // Initialize the overlay description via the HAL video engine manager.
    //
    switch (Offset)
    {
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
            (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
            return status;
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            U032 buffNum;

            buffNum = (Offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            pOverlayObject->Overlay[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV047_SET_OVERLAY_FORMAT_NOTIFY))) ? 1 : 0;


#if 0
            //
            // Below is commented out because of race condition problems when we have
            // an overlay object in a DMA channel and a PIO channel as is the case with 
            // VPE (jsun)
            //
            if (pOverlayObject->InitState == 0)
            {
                if (pDev->Video.HalInfo.ActiveVideoOverlayObject != NULL)
                {
                    return NV_OUT_OF_RESOURCES;
                }
            }
#endif

            (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);

            //
            // Ensure class-dependent video service handler is
            // setup properly.
            //
            if (status == RM_OK)
            {
                //
                // If video has just been enabled, then refresh arb settings.
                //
                if (pOverlayObject->InitState == 0)
                {
                    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);
                    pOverlayObject->InitState = 1;
                }

                pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) pOverlayObject;
                pDev->pOverlayServiceHandler = videoOverlayService;
            }
            return status;
        }
        default:
            return NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class047SetOverlayValues

RM_STATUS class047SetOverlayPointOutNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetOverlayPointOutNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class039.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV3_MEMORY_TO_MEMORY_FORMAT **************************\
*                                                                           *
* Module: CLASS039.C                                                        *
*   This module implements the NV3_MEMORY_TO_MEMORY_FORMAT object class     *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class04a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** NV4_GDI_RECTANGLE_TEXT ****************************\
*                                                                           *
* Module: CLASS04A.C                                                        *
*   This module implements the NV4_GDI_RECTANGLE_TEXT object class          *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04AValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class04ASetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;
    U032                    andMask, orMask;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class048.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV3_DX3_TEXTURED_TRIANGLE **************************\
*                                                                           *
* Module: CLASS048.C                                                        *
*   This module implements the NV3_DX3_TEXTURED_TRIANGLE object class       *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class048Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Surface != NULL) &&
        (pRenderObject->RCPatchContext.SurfaceZeta != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

        
    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class048SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class048SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
    
    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class048Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class048SetContextSurfaceColor
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class048SetContextSurfaceColor\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_2:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class048Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class048SetContextSurfaceZeta
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class048SetContextSurfaceZeta\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.SurfaceZeta = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_3:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.SurfaceZeta = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.SurfaceZeta = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class048Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class04b.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** NV3_GDI_RECTANGLE_TEXT ****************************\
*                                                                           *
* Module: CLASS04B.C                                                        *
*   This module implements the NV3_GDI_RECTANGLE_TEXT object class          *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04BValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class04BSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04BSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04BSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04BSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04BSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class052.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* NV4_CONTEXT_SURFACE_SWIZZLED ************************\
*                                                                           *
* Module: CLASS052.C                                                        *
*   This module implements the NV4_CONTEXT_SURFACE_SWIZZLED object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class04d.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04D.C                                                        *
*   This module implements the NV03_EXTERNAL_VIDEO_DECODER methods.         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <nv32.h>

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

// See kernel/mp/mpobj.c.

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DNotify\r\n");
    //
    // Set the notify DMA context
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class04DStopTransferVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStopTransferVbi\r\n");

    pDecoder = (PVIDEODECODEROBJECT)Object;

    //
    // Stop the current vbi data transfer immediately.
    //

    //
    // Probably should error check this data again
    // NV04F_STOP_TRANSFER_VBI_VALUE.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, NV04D_STOP_TRANSFER_VBI, Data, &status);

	 return (status);
}

RM_STATUS class04DStopTransferImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStopTransferImage\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    //
    // Probably should error check this data again
    // NV04F_STOP_TRANSFER_IMAGE_VALUE.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, NV04D_STOP_TRANSFER_IMAGE, Data, &status);

    return (status);
}

RM_STATUS class04DSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetContextDmaNotifies\r\n");
    //
    // Set the notify DMA context
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}

RM_STATUS class04DSetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECODEROBJECT         pDecoder;
    U032                        Buffer;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetContextDmaImage\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    Buffer = (Offset - Method->Low) >> 2;

	if (Data == NV01_NULL_OBJECT)
    {
       	pDecoder->ContextDmaImage[Buffer] = NULL;
        pDecoder->HalObject.SetImage[Buffer].CtxDma = NULL;
        return NV04D_NOTIFICATION_STATUS_DONE_SUCCESS;
    }

    //
    // Set the image DMA contexts
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pDecoder->ContextDmaImage[Buffer]));
    if (status)
        return (status);

    //
    // Give HAL access to context dma.
    //
    pDecoder->HalObject.SetImage[Buffer].CtxDma = &pDecoder->ContextDmaImage[Buffer]->HalInfo;

    return NV04D_NOTIFICATION_STATUS_DONE_SUCCESS;    
}

RM_STATUS class04DSetContextDmaVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECODEROBJECT         pDecoder;
    U032                        Buffer;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetContextDmaVbi\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    Buffer = (Offset - Method->Low) >> 2;

	if (Data == NV01_NULL_OBJECT)
    {
       	pDecoder->ContextDmaVbi[Buffer] = NULL;
        pDecoder->HalObject.SetVbi[Buffer].CtxDma = NULL;
        return NV04D_NOTIFICATION_STATUS_DONE_SUCCESS;
    }

    //
    // Set the data DMA contexts
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pDecoder->ContextDmaVbi[Buffer]));
    if (status)
        return (status);

    //
    // Give HAL access to context dma.
    //
    pDecoder->HalObject.SetVbi[Buffer].CtxDma = &pDecoder->ContextDmaVbi[Buffer]->HalInfo;
    
    return (RM_OK);
}

RM_STATUS class04DSetImageConfig
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT         pDecoder;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetImageStartLine\r\n");

    pDecoder = (PVIDEODECODEROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, NV04D_SET_IMAGE_CONFIG, Data, &status);
    
    return (status);
    
}

RM_STATUS class04DSetImageStartLine
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetImageStartLine\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, NV04D_SET_IMAGE_START_LINE, Data, &status);

    return (status);
    
}

RM_STATUS class04DSetVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;


    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetVbi\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, Offset, Data, &status);

    return (status);
}

RM_STATUS class04DSetImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetImage\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, Offset, Data, &status);

    return (status);
}

RM_STATUS class04DGetVbiOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    U032                        Buffer;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DGetVbiOffsetNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    Buffer = ((Offset - Method->Low) <= 0x03) ? 0 : 1;

    //
    // Get current position from HAL.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, Offset, Data, &status);

    //
    // Send back the data
    //
    notifyFillNotifierArray(pDev, pDecoder->CBase.NotifyXlate,
                            pDecoder->HalObject.SetVbi[Buffer].GetOffsetData,
                            0,
                            RM_OK,
                            NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(Buffer) );

    if (Data)
        osNotifyEvent(pDev, (POBJECT)pDecoder, 
                      NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(Buffer),
                      0, 
                      1, 
                      RM_OK, 
                      Data);

    return (status);
    
}

RM_STATUS class04DGetImageOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT         pDecoder;
    U032                        Buffer;
    RM_STATUS                   status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DGetImageOffsetNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    Buffer = ((Offset - Method->Low) <= 0x03) ? 0 : 1;

    //
    // Get current position from HAL.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, Offset, Data, &status);

    //
    // Send back the data
    //
    notifyFillNotifierArray(pDev, pDecoder->CBase.NotifyXlate,
                            pDecoder->HalObject.SetImage[Buffer].GetOffsetData,
                            0,
                            RM_OK,
                            NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(Buffer));

    if (Data)
        osNotifyEvent(pDev, (POBJECT)pDecoder,
                      NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(Buffer),
                      0, 
                      1, 
                      RM_OK, 
                      Data);

    return (status);
}

//---------------------------------------------------------------------------
//
// Exception Handling
//
//---------------------------------------------------------------------------

// This is a helper proc for VbiEvent.
// This procedure actually does the notification for the given buffer.
static void NotifyVbiBuffer
(
	PHWINFO				pDev,
    PVIDEODECODEROBJECT pDecoder,
    U032                BuffNum
)
{
    notifyFillNotifierArray(pDev, pDecoder->CBase.NotifyXlate, 
                             0, 
                             0, 
                             RM_OK, 
                             NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(BuffNum));

    if (pDecoder->HalObject.SetVbi[BuffNum].Notify)
        osNotifyEvent(pDev, (POBJECT)pDecoder, 
                      NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(BuffNum),
                      0, 
                      0, 
                      RM_OK, 
                      pDecoder->HalObject.SetVbi[BuffNum].Notify);
}

// This is a helper proc for ImageEvent.
// This procedure actually does the notification for the given buffer.
static VOID NotifyImageBuffer
(
	PHWINFO				pDev,
    PVIDEODECODEROBJECT pDecoder,
    U032                BuffNum
)
{
    //
    // Include 32bit info value.
    //
    notifyFillNotifierArray(pDev, pDecoder->CBase.NotifyXlate, 
                             pDecoder->HalObject.SetImage[BuffNum].Info32,
                             0,
                             RM_OK, 
                             NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(BuffNum));

    if (pDecoder->HalObject.SetImage[BuffNum].Notify)
        osNotifyEvent(pDev, (POBJECT)pDecoder, 
                      NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(BuffNum),
                      0, 
                      1, 
                      RM_OK, 
                      pDecoder->HalObject.SetImage[BuffNum].Notify);
}

static VOID VbiEvents
(
    PHWINFO pDev,
    PVIDEODECODEROBJECT pDecoder,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecoder->HalObject;
    U032 events = CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1);

    //
    // Call into HAL and get status on VBI events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECODER, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (pDecoder->LastVbiBufferProcessed == 1)
    {
        // Check buffer 0 first.
        if (events & CLASS04D_VBI_EVENT(0))
        {
            NotifyVbiBuffer(pDev, pDecoder, 0);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_VBI_EVENT(0),
                                       pIntrStatus);
            pDecoder->LastVbiBufferProcessed = 0;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_VBI;
        }
        // Now buffer 1.
        if (events & CLASS04D_VBI_EVENT(1))
        {
            NotifyVbiBuffer(pDev, pDecoder, 1);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_VBI_EVENT(1),
                                       pIntrStatus);
            pDecoder->LastVbiBufferProcessed = 1;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_VBI;
        }
    }
    else
    {
        // Check buffer 1 first.
        if (events & CLASS04D_VBI_EVENT(1))
        {
            NotifyVbiBuffer(pDev, pDecoder, 1);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_VBI_EVENT(1),
                                       pIntrStatus);
            pDecoder->LastVbiBufferProcessed = 1;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_VBI;
        }
        // Now buffer 0.
        if (events & CLASS04D_VBI_EVENT(0))
        {
            NotifyVbiBuffer(pDev, pDecoder, 0);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_VBI_EVENT(0),
                                       pIntrStatus);
            pDecoder->LastVbiBufferProcessed = 0;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_VBI;
        }

    }

    return;
}

static VOID ImageEvents
(
    PHWINFO pDev,
    PVIDEODECODEROBJECT pDecoder,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecoder->HalObject;
    U032 events = CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1);

    //
    // Call into HAL and get status on Image events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECODER, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (pDecoder->LastImageBufferProcessed == 1)
    {
        // Check buffer 0 first.
        if (events & CLASS04D_IMAGE_EVENT(0))
        {
            NotifyImageBuffer(pDev, pDecoder, 0);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_IMAGE_EVENT(0),
                                       pIntrStatus);
            pDecoder->LastImageBufferProcessed = 0;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_IMAGE;
        }
        // Now buffer 1.
        if (events & CLASS04D_IMAGE_EVENT(1))
        {
            NotifyImageBuffer(pDev, pDecoder, 1);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_IMAGE_EVENT(1),
                                       pIntrStatus);
            pDecoder->LastImageBufferProcessed = 1;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_IMAGE;
        }
    }
    else
    {
        // Check buffer 1 first.
        if (events & CLASS04D_IMAGE_EVENT(1))
        {
            NotifyImageBuffer(pDev, pDecoder, 1);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_IMAGE_EVENT(1),
                                       pIntrStatus);
            pDecoder->LastImageBufferProcessed = 1;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_IMAGE;
        }
        // Now buffer 0.
        if (events & CLASS04D_IMAGE_EVENT(0))
        {
            NotifyImageBuffer(pDev, pDecoder, 0);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_IMAGE_EVENT(0),
                                       pIntrStatus);
            pDecoder->LastImageBufferProcessed = 0;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_IMAGE;
        }

    }

    //
    // If we had any pending image events, issue os-dependent callback.
    //
    if (events)
        osmpCheckCallbacks(pDev, 1);

    return;
}

//
// class04DService
//
V032 class04DService
(
    PHWINFO pDev
)
{
    PVIDEODECODEROBJECT pDecoder;
    U032 eventsPending, intrStatus;

    //
    // Handle case where we don't have a current decoder object.
    //
    pDecoder = (PVIDEODECODEROBJECT)(pDev->MediaPort.CurrentDecoder);
    if (pDecoder == NULL)
    {
        //
        // This exception is spurious.  Call into HAL to give it a
        // chance to reset the pending condition and then we're done.
        //
        eventsPending = 0xffffffff;
        (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECODER, NULL, &eventsPending, &intrStatus);
        return (intrStatus);
    }

    //
    // The order in which we process this interrupt is dependent on
    // the last event/buffer processed.
    //
    if (pDecoder->LastEventProcessed == EVENT_PROCESSED_IMAGE) 
    {
        VbiEvents(pDev, pDecoder, &intrStatus);
        ImageEvents(pDev, pDecoder, &intrStatus);
    }
    else
    {
        ImageEvents(pDev, pDecoder, &intrStatus);
        VbiEvents(pDev, pDecoder, &intrStatus);
    }

    return (intrStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class053.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV4_CONTEXT_SURFACES_ARGB_ZS *************************\
*                                                                           *
* Module: CLASS053.C                                                        *
*   This module implements the NV4_CONTEXT_SURFACES_ARGB_ZS object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//
RM_STATUS class053SetClipHorizontal
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS               status = RM_OK;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class053SetClipHorizontal\r\n");

    //
    // ERROR CHECKING??
    //

    return (status);
}

RM_STATUS class053SetClipVertical
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS               status = RM_OK;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class053SetClipVertical\r\n");

    //
    // ERROR CHECKING??
    //

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class049.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class049.C                                                        *
*   This module implements the NV05_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class049SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate, 
                              0, 
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class049SetNotifyCtxDma

RM_STATUS class049SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;
    
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049SetNotify

RM_STATUS class049StopImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049StopImage\r\n");

    // class049 supports only one head (head 0)
    dacDisableImage(pDev, 0);

    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049StopImage

RM_STATUS class049StopLUT
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049StopLUT\r\n");
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049StopLUT

RM_STATUS class049StopCursorImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    Head = 0;   // single-head class
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049StopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, Head);

    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049StopCursorImage

RM_STATUS class049StopDAC
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049StopDAC\r\n");

    // class049 supports only one head (head 0).
    dacDisableDac(pDev, 0);

    // reset display type
    SETDISPLAYTYPE(pDev, 0, 0xffffffff);
    
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049StopDAC

RM_STATUS class049SetImageCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV049_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;
    
    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

	if (Data == NV01_NULL_OBJECT)
    {
       	pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
       	pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class049SetImageCtxDma

RM_STATUS class049SetLUTCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV049_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;
    
    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

	if (Data == NV01_NULL_OBJECT)
    {
       	pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma, 
                              0, 
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class049SetLUTCtxDma

RM_STATUS class049SetCursorCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV049_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;
    
    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

	if (Data == NV01_NULL_OBJECT)
    {
       	pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma, 
                              0, 
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class049SetCursorCtxDma

RM_STATUS class049SetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // For this head, this becomes the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV049_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class049SetPanOffset

RM_STATUS class049GetOffset
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049GetOffset\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 
                                         pVidLutCurDac->Image[Data].Offset, 
                                         NV049_NOTIFICATION_INFO16_VALID_OFFSET, 
                                         NV049_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV049_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV049_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE; 
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049GetOffset

// This proc writes the notification for an image buffer.
RM_STATUS class049ImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV049_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV049_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;   
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class049SetImageValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
	//
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV049_SET_IMAGE_OFFSET(0):
        case NV049_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV049_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x03) != 0)
            	// The image offset must be a multiple of 4 bytes.
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV049_SET_IMAGE_FORMAT(0):
        case NV049_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  startAddr;
            U032  when;
            
            buffNum = (Offset == NV049_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV049_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x1F) != 0)
            	// the minimum pitch must be a multiple of 32 bytes.
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;
            
            // when = DRF_VAL(049, _SET_IMAGE, _FORMAT_WHEN, Data);    // XXX win3.1/watcom can't grok this
            when = (Data >> DRF_SHIFT(NV049_SET_IMAGE_FORMAT_WHEN)) & DRF_MASK(NV049_SET_IMAGE_FORMAT_WHEN);
            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV049_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;

            if (when == NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY) 
            {
                // Change the default flip functionality to end of hsync.

                // Unfortunately the HSYNC bit is in different locations on NV5/NV10
                if (IsNV10orBetter(pDev))
                    FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV10);
                else
                    FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV5);
            }
            else
            {
                // Change the default flip functionality to end of vsync.
                FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA);
            }

            // Program the hardware.
            // The imageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr) + 
                                pVidLutCurDac->Image[buffNum].Offset);
            // add in the panning offset
            startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

            status = dacProgramVideoStart(pDev, Head, startAddr, pitch);
            if (status) 
            {
                pVidLutCurDac->Image[buffNum].NotifyTrigger = FALSE;
                return NV049_NOTIFICATION_STATUS_ERROR_INVALID_STATE;
            }
            if (when == NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
            {
                // Do the notify right here.
                class049ImageNotify(pDev, (POBJECT)pVidLutCurDac, 
                                    0 /* param 1*/, buffNum,
                                    NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
            }
            else
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class049ImageNotify;
                pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->Image[buffNum].ImageCallback.Next    = NULL;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->Image[buffNum].ImageCallback.Param2  = buffNum;
                pVidLutCurDac->Image[buffNum].ImageCallback.Status  = NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

                // Default to head 0.
                VBlankAddCallback(pDev, 0, &(pVidLutCurDac->Image[buffNum].ImageCallback));
            }
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class049SetImageValues

// This proc is called from VBlank to program the LUT.
RM_STATUS class049ProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032*     startAddr;
    U032      numEntries;
    U032    Head = 0;   // single-head class

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset, 
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, Head, startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                myStatus,
                                NV049_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV049_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          myStatus, 
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;   
    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class049SetLUTValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
	//
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV049_SET_LUT_OFFSET(0):
        case NV049_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV049_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3FF) != 0)
            	// The LUT offset must be a multiple of 1024 bytes.
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV049_SET_LUT_FORMAT(0):
        case NV049_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV049_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class049ProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class049SetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class049CursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV049_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV049_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;   
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class049SetCursorImageValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetCursorImageValues\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
	//
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV049_SET_CURSOR_IMAGE_OFFSET(0):
        case NV049_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV049_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3ff) != 0)
            	// The cursor image offset must be a multiple of 1024 bytes.
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV049_SET_CURSOR_IMAGE_FORMAT(0):
        case NV049_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            U032    Head = 0;   // single-head class
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV049_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            // The cursor is always 32x32 image with a color format LE_ROP1R5G5B5. 
            pVidLutCurDac->CursorImage[buffNum].Width       = 32; 
            pVidLutCurDac->CursorImage[buffNum].Height      = 32; 
            pVidLutCurDac->CursorImage[buffNum].ColorFormat = 0;  // LE_ROP1R5G5B5

            pVidLutCurDac->CursorImage[buffNum].NotifyAction = Data; 

            // Kick off the transfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) + 
                               pVidLutCurDac->CursorImage[buffNum].Offset);
            status = nvHalDacProgramCursorImage(pDev, startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           32 /* width */, 
                                           32 /* height */, 0 /* colorFormat LE_ROP1R5G5B5 */,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status) 
            {
                pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = FALSE;
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, Head);

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class049CursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        default:
            return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class049SetCursorImageValues

RM_STATUS class049SetCursorPoint
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetCursorPoint\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, Head,
                                      (Data & 0xffff), /* cursorX */ 
                                      (Data >> 16));   /* cursorY */
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049SetCursorPoint

RM_STATUS class049SetDACValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
	//
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV049_SET_DAC_IMAGE_SIZE(0):
        case NV049_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV049_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.    
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048. 
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV049_SET_DAC_HORIZONTAL_SYNC(0):
        case NV049_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV049_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set Vertical sync
        //
        case NV049_SET_DAC_VERTICAL_SYNC(0):
        case NV049_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV049_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set total size.
        //
        case NV049_SET_DAC_TOTAL_SIZE(0):
        case NV049_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV049_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.    
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2. 
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        // Set pixel clock.
        case NV049_SET_DAC_PIXEL_CLOCK(0):
        case NV049_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV049_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV049_SET_DAC_FORMAT(0):
        case NV049_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV049_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR)pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;

            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV049_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV049_SET_DAC_FORMAT_COLOR);

			switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
				case NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
					pDev->Dac.HalInfo.Depth = 8;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
					pDev->Dac.HalInfo.Depth = 15;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
					pDev->Dac.HalInfo.Depth = 16;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
					pDev->Dac.HalInfo.Depth = 32;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
					break;
			}

            pDev->Dac.PixelDepth                   = pDev->Dac.HalInfo.Depth;
            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth = pDev->Dac.HalInfo.Depth;

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;
            
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;   

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;

            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;

            // Get output device...
            pVidLutCurDac->DisplayType		  = (Data >> DRF_SHIFT(NV049_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV049_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class049: invalid display type ", pVidLutCurDac->DisplayType);
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard		  = (Data >> DRF_SHIFT(NV049_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV049_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class046: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }


            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);

            if (pVidLutCurDac->CBase.NotifyXlate) 
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                                 modeSetStatus,
                                                 NV049_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                                  NV049_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */, 
                                  0 /* Data */, 
                                  modeSetStatus, 
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;   

            return modeSetStatus;
        }
        
        default:
            return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class049SetDACValues
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class054.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV4_DX5_TEXTURED_TRIANGLE **************************\
*                                                                           *
* Module: CLASS054.C                                                        *
*   This module implements the NV4_DX5_TEXTURED_TRIANGLE object class       *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class055.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* NV4_DX6_MULTI_TEXTURE_TRIANGLE ************************\
*                                                                           *
* Module: CLASS055.C                                                        *
*   This module implements the NV4_DX6_MULTI_TEXTURE_TRIANGLE object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class056.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_CELSIUS_PRIMITIVE **************************\
*                                                                           *
* Module: CLASS056.C                                                        *
*   This module implements the NV10_CELSIUS_PRIMITIVE object class          *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class057.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV4_CONTEXT_COLOR_KEY ****************************\
*                                                                           *
* Module: CLASS057.C                                                        *
*   This module implements the NV4_CONTEXT_COLOR_KEY object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class058.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV3_CONTEXT_SURFACE_0 ****************************\
*                                                                           *
* Module: CLASS058.C                                                        *
*   This module implements the NV3_CONTEXT_SURFACE_0 object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class059.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV3_CONTEXT_SURFACE_1 ****************************\
*                                                                           *
* Module: CLASS059.C                                                        *
*   This module implements the NV3_CONTEXT_SURFACE_1 object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class05b.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV3_CONTEXT_SURFACE_3 ****************************\
*                                                                           *
* Module: CLASS05B.C                                                        *
*   This module implements the NV3_CONTEXT_SURFACE_3 object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class05a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV3_CONTEXT_SURFACE_2 ****************************\
*                                                                           *
* Module: CLASS05A.C                                                        *
*   This module implements the NV3_CONTEXT_SURFACE_2 object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class04e.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <nv32.h>

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

// See kernel/mp/mpobj.c.


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04ENotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ENotify\r\n");
    //
    // Set the notify DMA context
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class04EStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStopTransfer\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    //
    // Stop the current data transfer immediately.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, &pDecompress->HalObject, NV04E_STOP_TRANSFER, Data, &status);

    return (RM_OK);
}
RM_STATUS class04ESetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ESetContextNotifies\r\n");
    //
    // Set the notify DMA context
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}

RM_STATUS class04ESetContextDmaData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    U032                        Buffer;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ESetContextDmaDma\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    Buffer = (Offset - Method->Low) >> 2;

	if (Data == NV01_NULL_OBJECT)
    {
       	pDecompress->ContextDmaData[Buffer] = NULL;
        pDecompress->HalObject.ReadData[Buffer].CtxDma = NULL;
        return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
    }

    //
    // Set the data DMA contexts
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pDecompress->ContextDmaData[Buffer]));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }

    //
    // Give the HAL access to the context dma.
    //
    pDecompress->HalObject.ReadData[Buffer].CtxDma = &pDecompress->ContextDmaData[Buffer]->HalInfo;

    return (RM_OK);
}
RM_STATUS class04ESetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    U032                        Buffer;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ESetContextDmaImage\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    Buffer = (Offset - Method->Low) >> 2;

	if (Data == NV01_NULL_OBJECT)
    {
       	pDecompress->ContextDmaImage[Buffer] = NULL;
        pDecompress->HalObject.WriteImage[Buffer].CtxDma = NULL;
        return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
    }

    //
    // Set the data DMA contexts
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pDecompress->ContextDmaImage[Buffer]));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }

    //
    // Give the HAL access to the context dma.
    //
    pDecompress->HalObject.WriteImage[Buffer].CtxDma = &pDecompress->ContextDmaImage[Buffer]->HalInfo;
    
    return (RM_OK);
}

RM_STATUS class04EReadData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    RM_STATUS                   status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EReadData\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, &pDecompress->HalObject, Offset, Data, &status);

    return status;
}

RM_STATUS class04EWriteImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    RM_STATUS                   status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EWriteImage\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, &pDecompress->HalObject, Offset, Data, &status);

    return status;
}

//---------------------------------------------------------------------------
//
// Exception Handling
//
//---------------------------------------------------------------------------

static void NotifyDataBuffer
(
	PHWINFO				        pDev,
    PVIDEODECOMPRESSOROBJECT    pDecompress,
    U032                        BuffNum
)
{
    notifyFillNotifierArray(pDev,  pDecompress->CBase.NotifyXlate, 
                            0, 
                            0, 
                            RM_OK, 
                            NV04E_NOTIFIERS_SET_DATA_NOTIFY(BuffNum) );

    if (pDecompress->HalObject.ReadData[BuffNum].Notify)
        osNotifyEvent(pDev, (POBJECT)pDecompress, 
                      NV04E_NOTIFIERS_SET_DATA_NOTIFY(BuffNum),
                      0, 
                      0, 
                      RM_OK, 
                      pDecompress->HalObject.ReadData[BuffNum].Notify);
}

static void NotifyImageBuffer
(
	PHWINFO				        pDev,
    PVIDEODECOMPRESSOROBJECT    pDecompress,
    U032                        BuffNum
)
{
    //
    // Only call the completion routine if one was expected
    //
    notifyFillNotifierArray(pDev,  pDecompress->CBase.NotifyXlate, 
                            0, 
                            0, 
                            RM_OK, 
                            NV04E_NOTIFIERS_SET_IMAGE_NOTIFY(BuffNum) );
}

static VOID VideoEvents
(
    PHWINFO pDev,
    PVIDEODECOMPRESSOROBJECT pDecompress,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecompress->HalObject;
    U032 events = CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1);

    //
    // Call into HAL and get status on Video events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (events & CLASS04E_VIDEO_EVENT(0))
    {
        NotifyDataBuffer(pDev, pDecompress, 0);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_VIDEO_EVENT(0),
                                   pIntrStatus);
    }

    if (events & CLASS04E_VIDEO_EVENT(1))
    {
        NotifyDataBuffer(pDev, pDecompress, 1);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_VIDEO_EVENT(1),
                                   pIntrStatus);
    }

    return;
}

static VOID AudioEvents
(
    PHWINFO pDev,
    PVIDEODECOMPRESSOROBJECT pDecompress,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecompress->HalObject;
    U032 events = CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1);

    //
    // Call into HAL and get status on Video events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (events & CLASS04E_AUDIO_EVENT(0))
    {
        NotifyDataBuffer(pDev, pDecompress, 0);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_AUDIO_EVENT(0),
                                   pIntrStatus);
    }

    if (events & CLASS04E_AUDIO_EVENT(1))
    {
        NotifyDataBuffer(pDev, pDecompress, 1);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_AUDIO_EVENT(1),
                                   pIntrStatus);
    }

    return;
}

static VOID ImageEvents
(
    PHWINFO pDev,
    PVIDEODECOMPRESSOROBJECT pDecompress,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecompress->HalObject;
    U032 events = CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1);

    //
    // Call into HAL and get status on Video events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (events & CLASS04E_IMAGE_EVENT(0))
    {
        NotifyImageBuffer(pDev, pDecompress, 0);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_IMAGE_EVENT(0),
                                   pIntrStatus);
    }

    if (events & CLASS04E_IMAGE_EVENT(1))
    {
        NotifyImageBuffer(pDev, pDecompress, 1);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_IMAGE_EVENT(1),
                                   pIntrStatus);
    }

    return;
}

//
// class04EService
//
V032 class04EService
(
    PHWINFO pDev
)
{
    PVIDEODECOMPRESSOROBJECT pDecompress;
    U032 eventsPending, intrStatus;

    //
    // Handle case where we don't have a current decompressor object.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)(pDev->MediaPort.CurrentDecompressor);
    if (pDecompress == NULL)
    {
        //
        // This exception is spurious.  Call into HAL to give it a
        // chance to reset the pending condition and then we're done.
        //
        eventsPending = 0xffffffff;
        (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, NULL, &eventsPending, &intrStatus);
        return (intrStatus);
    }

    //
    // Process events.
    //
    VideoEvents(pDev, pDecompress, &intrStatus);
    AudioEvents(pDev, pDecompress, &intrStatus);
#ifdef NOTYET
    ImageEvents(pDev, pDecompress, &intrStatus);
#endif

    return (intrStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class04f.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: CLASS04F.C                                                        *
*   This module implements the NV_EXTERNAL_PARALLEL_BUS object              *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <nv32.h>

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/mp/mpobj.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FSetContextDmaNotifies\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}

RM_STATUS class04FNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FNotify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS class04FStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PPARALLELBUSOBJECT pBus;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FStopTransfer\r\n");

    pBus = (PPARALLELBUSOBJECT)Object;

    //
    // Probably should error check this data again NV04F_STOP_TRANSFER_VALUE.
    //
    (void) nvHalMpMethod(pDev, NV1_EXTERNAL_PARALLEL_BUS, &pBus->HalObject, NV04F_STOP_TRANSFER, Data, &status);

    return (status);
}

RM_STATUS class04FWrite
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PPARALLELBUSOBJECT      pBus;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FWrite\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pBus = (PPARALLELBUSOBJECT)Object;

    (void) nvHalMpMethod(pDev, NV1_EXTERNAL_PARALLEL_BUS, &pBus->HalObject, Offset, Data, &status);

    return (status);
}


RM_STATUS class04FRead
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PPARALLELBUSOBJECT      pBus;
    PPARALLELBUSHALOBJECT   pBusHalObj;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FRead\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pBus = (PPARALLELBUSOBJECT)Object;
    pBusHalObj = (PPARALLELBUSHALOBJECT)&pBus->HalObject;

    (void) nvHalMpMethod(pDev, NV1_EXTERNAL_PARALLEL_BUS, &pBus->HalObject, Offset, Data, &status);

    //
    // If this is the transfer method, handle posting of the notify.
    //
    switch (Offset - Method->Low)
    {
        //
        // Get Data
        //
        case 0x08:

            //
            // Send back the data.
            // XXX (scottl):  should 'status' be written to notify
            // area in this case?
            //
            notifyFillNotifierArray(pDev,  pBus->CBase.NotifyXlate, 
                                    pBusHalObj->Read.ReadData,
                                    0, 
                                    RM_OK, 
                                    NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY );
            
            //DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "r");
            
            //tmrDelay(100000);         // 500ns delay    
            
            break;
        default:
            break;            
    }

    return (status);
}

RM_STATUS class04FSetInterruptNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PPARALLELBUSOBJECT   pBus;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FSetInterruptNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PPARALLELBUSOBJECT)Object;

    //
    // Set the notify data
    //
    pBus->InterruptNotifyPending = Data;

    (void) nvHalMpMethod(pDev, NV1_EXTERNAL_PARALLEL_BUS, &pBus->HalObject, Offset, Data, &status);

    return (status);
}    


//---------------------------------------------------------------------------
//
// Exception Handling
//
//---------------------------------------------------------------------------

//
// Handle parallel bus portion of MediaPort exceptions.
//
V032 class04FService
(
    PHWINFO pDev
)
{
    PPARALLELBUSOBJECT pParallelBus;
    VOID *pMpHalObj;
    U032 eventPending = CLASS04F_PBUS_EVENT;
    V032 intrStatus = 0;

    //
    // Handle parallel bus exceptions.
    //
    pParallelBus = (PPARALLELBUSOBJECT)(pDev->MediaPort.CurrentParallelBusObj);
    if (pParallelBus)
        pMpHalObj = (VOID *)&pParallelBus->HalObject;
    else
        pMpHalObj = NULL;

    //
    // Call into the HAL to get pending status.
    //
    (void) nvHalMpGetEventStatus(pDev, NV01_EXTERNAL_PARALLEL_BUS, pMpHalObj, &eventPending, &intrStatus);

    //
    // Now process any pending events.
    //
    if (pParallelBus && eventPending == CLASS04F_PBUS_EVENT)
    {    
         notifyFillNotifierArray(pDev, pParallelBus->CBase.NotifyXlate, 
                                 0, 
                                 0, 
                                 RM_OK, 
                                 NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY );

        if (pParallelBus->InterruptNotifyPending)
            osNotifyEvent(pDev, (POBJECT)pParallelBus,
                          NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY,
                          0, 
                          1, 
                          RM_OK, 
                          pParallelBus->InterruptNotifyPending);

        //
        // This is a single-shot notify.  Clear the notify type.
        //
        pParallelBus->InterruptNotifyPending = 0;            
    }

    //
    // Call into HAL to finish processing exception (will clear
    // pending bit in interrupt register).
    //
    (void) nvHalMpServiceEvent(pDev, NV01_EXTERNAL_PARALLEL_BUS, pMpHalObj, eventPending, &intrStatus);

    return (intrStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class050.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* Monitor Bus Manager ******************************\
*                                                                           *
* Module: CLASS050.C                                                        *
*   This module implements the NV_EXTERNAL_MONITOR_BUS object               *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <class.h>
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <vga.h>
#include <i2c.h>
#include <nv32.h>

//
// Externs.
//

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

RM_STATUS class050Create
(
	PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    RM_STATUS           status;
    PMONITORBUSOBJECT   pBus;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Create\r\n");
    //
    // Create the NV_EXTERNAL_PARALLEL_BUS object.
    //
    status = osAllocMem((VOID **)Object, sizeof(MONITORBUSOBJECT));
    if (status)
        return (status);
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, UserName);

    //
    // Initialize the new object structure.
    //
    pBus->Write.AddressSize = 0;
    pBus->Write.DataSize = 0;
    pBus->Write.Address  = 0;
    pBus->Write.Data     = 0;
    pBus->Read.AddressSize = 0;
    pBus->Read.DataSize  = 0;
    pBus->Read.Address   = 0;
    pBus->Read.Notify    = 0;
    pBus->InterruptNotifyPending = 0;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pBus->CBase, 
                                      pBus->CBase.ChID, 
                                      pBus->CInstance);
    if (status != RM_OK)
    {
        osFreeMem(*Object);
    }

    return(RM_OK);
}

RM_STATUS class050Destroy
(
	PHWINFO pDev,
    POBJECT Object
)
{
    PMONITORBUSOBJECT  pBus;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Destroy\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)Object;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pBus->CBase, pBus->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class050SetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050SetContextDmaNotifies\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class050Notify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Notify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class050StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050StopTransfer\r\n");
    return (RM_OK);
}


RM_STATUS class050Write
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PMONITORBUSOBJECT   pBus;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Write\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)Object;

    //
    // Process the write request.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Size
        //
        case 0x00:
            pBus->Write.DataSize = (U016)(Data & 0x0000FFFF);
            pBus->Write.AddressSize = (U016)((Data >> 16) & 0x0000FFFF);
            break;
        //
        // Set Address
        //
        case 0x04:
            pBus->Write.Address = Data;
            break;
        //
        // Set Data
        //
        case 0x08:

            pBus->Write.Data = Data;

            //
            // I2C Bus
            //
            //i2cWrite( (U008)pPioBus->Write.Address,
            //          pPioBus->Write.AddressSize-1,
            //          ((U008 *)&(pPioBus->Write.Address))+1,
            //          pPioBus->Write.DataSize,
            //          (U008 *)&(pPioBus->Write.Data));
                              
            break;
            
        default:
            break;            

    }
    return (RM_OK);
}


RM_STATUS class050Read
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PMONITORBUSOBJECT   pBus;
    U032                data32;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Read\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)Object;

    //
    // Process the write request.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Size
        //
        case 0x00:
            pBus->Read.DataSize = (U016)(Data & 0x0000FFFF);
            pBus->Read.AddressSize = (U016)((Data >> 16) & 0x0000FFFF);
            break;
        //
        // Set Address
        //
        case 0x04:
            pBus->Read.Address = Data;
            break;
        //
        // Get Data
        //
        case 0x08:

            pBus->Read.Notify = Data;

            //
            // I2C Bus
            //
            //i2cRead( (U008)pPioBus->Read.Address,
            //         pPioBus->Read.AddressSize-1,
            //         ((U008 *)&(pPioBus->Read.Address))+1,
            //         pPioBus->Read.DataSize,
            //         (U008 *)&(pPioBus->Read.Data));
            data32 = 0;
                                          
            //
            // Send back the data
            //
            notifyFillNotifierArray(pDev,  pBus->CBase.NotifyXlate, 
                                     data32, 
                                     0, 
                                     RM_OK, 
                                     NV050_NOTIFICATION_READ_GET_DATA_NOTIFY );
            
            break;
            
        default:
            break;            

    }
    return (RM_OK);
}

RM_STATUS class050SetInterruptNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PMONITORBUSOBJECT   pBus;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050SetInterruptNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)Object;
    
    //
    // Make sure the interrupt is enabled
    //
    
    return (RM_OK);   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class051.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* Serial Bus Manager *******************************\
*                                                                           *
* Module: CLASS051.C                                                        *
*   This module implements the NV_EXTERNAL_SERIAL_BUS object                *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <class.h>
#include <dma.h>   
#include <modular.h>
#include <mp.h>
#include <os.h>
#include <vga.h>
#include <i2c.h>
#include <tmr.h>
#include <nv32.h>

// XXX hack - since BusType is unused, use it as a flag to indicate autoincrement mode
#define SET_AUTO_INCREMENT_FLAG(v)    pBus->BusType = (v)
#define AUTO_INCREMENT_FLAG()         pBus->BusType

//
// Externs.
//

extern char strDevNodeRM[];
char strExternalSerialOnPrimary[] = "ExternalSerialOnPrimary";

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

RM_STATUS class051Create
(
	PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    RM_STATUS           status;
    PSERIALBUSOBJECT    pBus;
    U032                data32;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Create\r\n");
    //
    // Create the NV_EXTERNAL_PARALLEL_BUS object.
    //
    status = osAllocMem((VOID **)Object, sizeof(SERIALBUSOBJECT));
    if (status)
        return (status);
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, UserName);

    //
    // Initialize the new object structure.
    //
    pBus->Write.AddressSize = 0;
    pBus->Write.DataSize = 0;
    pBus->Write.Address  = 0;
    pBus->Write.Data     = 0;
    pBus->Read.AddressSize = 0;
    pBus->Read.DataSize  = 0;
    pBus->Read.Address   = 0;
    pBus->Read.Notify    = 0;
    pBus->InterruptNotifyPending = 0;
	//
	// initialize the Default Port ID (only affects hw with multiple I2C ports)
	//
    if ( OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strExternalSerialOnPrimary, &data32) == RM_OK) {
        pBus->DefaultPortID = NV_I2C_PORT_PRIMARY;
    }
    else {
        pBus->DefaultPortID = NV_I2C_PORT_SECONDARY;
    }

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pBus->CBase, 
                                      pBus->CBase.ChID, 
                                      pBus->CInstance);
    if (status != RM_OK)
    {
        osFreeMem(*Object);
    }

    SET_AUTO_INCREMENT_FLAG(0);



    return(RM_OK);

}

RM_STATUS class051Destroy
(
	PHWINFO pDev,
    POBJECT Object
)
{
    PSERIALBUSOBJECT  pBus;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Destroy\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)Object;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pBus->CBase, pBus->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class051SetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051SetContextDmaNotifies\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class051Notify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Notify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class051StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051StopTransfer\r\n");
    return (RM_OK);
}


RM_STATUS class051Write
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PSERIALBUSOBJECT   pBus;
    U008               lock;
    U032               NoStopFlag;
    U032               portID;
    U032               Head = 0;    // TO DO: make the class usable on other heads
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Write\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)Object;

    //
    // Process the write request.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Size
        //
        case 0x00:
            pBus->Write.DataSize = (U016)(Data & 0x0000FFFF);
            pBus->Write.AddressSize = (U016)((Data >> 16) & 0x0000FFFF);
            break;
        //
        // Set Address
        //
        case 0x04:
            pBus->Write.Address = Data;
            SET_AUTO_INCREMENT_FLAG(0);
            break;
        //
        // Set Data
        //
        case 0x08:

            pBus->Write.Data = Data;

            //
            // I2C Bus
            //
    		// Unlock CRTC extended regs
            CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

            //
            // I2C Bus
            //
            //
            // Check for the hack I2C interface on the MPC daughterboard
            //
            if ((pBus->Write.Address & 0xFF) == pDev->MediaPort.HalInfo.MPCDeviceAddr) {
                i2cWrite_ALT( pDev, Head, pBus->DefaultPortID, 
                          (U008)pBus->Write.Address,
                          (U016)(pBus->Write.AddressSize-1),
                          ((U008 *)&(pBus->Write.Address))+1,
                          pBus->Write.DataSize,
                          (U008 *)&(pBus->Write.Data));
			}
            else {
				// check for override of DefaultPortID 
				// (XXX temporary until PortID is added as a method )
			    if ( pBus->Write.AddressSize & 0x8000 ) {
				    pBus->Write.AddressSize &= 0x7fff;
					portID = NV_I2C_PORT_PRIMARY;
				}
				else {
					portID = pBus->DefaultPortID;
				}

                NoStopFlag = Data & 0xFF000000;
                if ( ((pBus->Write.DataSize <= 3) && NoStopFlag) || AUTO_INCREMENT_FLAG() ) {
                    if ( AUTO_INCREMENT_FLAG() ) {
                        i2cSend ( pDev, Head, portID,
                                  (U008)0,
                                  (U016)0,
                                  NULL,
                                  pBus->Write.DataSize,
                                  (U008 *)&(pBus->Write.Data),
                                  NoStopFlag);
                    }
                    else {
                        i2cSend ( pDev, Head, portID,
                                  (U008)pBus->Write.Address,
                                  (U016)(pBus->Write.AddressSize-1),
                                  ((U008 *)&(pBus->Write.Address))+1,
                                  pBus->Write.DataSize,
                                  (U008 *)&(pBus->Write.Data),
                                  NoStopFlag);
                        SET_AUTO_INCREMENT_FLAG(1);
                    }
                    if ( NoStopFlag == 0 )
                        SET_AUTO_INCREMENT_FLAG(0);
                }
                else {
                    i2cWrite( pDev, Head, portID,
                              (U008)pBus->Write.Address,
                              (U016)(pBus->Write.AddressSize-1),
                              ((U008 *)&(pBus->Write.Address))+1,
                              pBus->Write.DataSize,
                              (U008 *)&(pBus->Write.Data));
                }
			}
               
    		if (lock == 0)
                CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
                              
            break;
            
        default:
            break;            

    }
    return (RM_OK);
}


RM_STATUS class051Read
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PSERIALBUSOBJECT   pBus;
    U032               val32;
    U008               lock;
    U032               Head = 0;    // TO DO: make the class usable on other heads

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Read\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)Object;

    //
    // Process the write request.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Size
        //
        case 0x00:
            pBus->Read.DataSize = (U016)(Data & 0x0000FFFF);
            pBus->Read.AddressSize = (U016)((Data >> 16) & 0x0000FFFF);
            break;
        //
        // Set Address
        //
        case 0x04:
            pBus->Read.Address = Data;
            break;
        //
        // Get Data
        //
        case 0x08:

            pBus->Read.Notify = Data;

            //
            // I2C Bus
            //
        	// Unlock CRTC extended regs
            CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
            
            //
            // Check for the hack I2C interface on the MPC daughterboard
            //
            if ((pBus->Read.Address & 0xFF) == pDev->MediaPort.HalInfo.MPCDeviceAddr) {
                i2cRead_ALT( pDev, Head, pBus->DefaultPortID, 
                         (U008)pBus->Read.Address,
                         (U016)(pBus->Read.AddressSize-1),
                         ((U008 *)&(pBus->Read.Address))+1,
                         pBus->Read.DataSize,
                         (U008 *)&(val32));
			}
            else {
				// check for override of DefaultPortID 
				// (XXX temporary until PortID is added as a method )
			    if ( pBus->Read.AddressSize & 0x8000 ) {
				    pBus->Read.AddressSize &= 0x7fff;
					i2cRead( pDev, Head, NV_I2C_PORT_PRIMARY,
							 (U008)pBus->Read.Address,
							 (U016)(pBus->Read.AddressSize-1),
							 ((U008 *)&(pBus->Read.Address))+1,
							 pBus->Read.DataSize,
							 (U008 *)&(val32));
				}
				else {
					i2cRead( pDev, Head, pBus->DefaultPortID,
							 (U008)pBus->Read.Address,
							 (U016)(pBus->Read.AddressSize-1),
							 ((U008 *)&(pBus->Read.Address))+1,
							 pBus->Read.DataSize,
							 (U008 *)&(val32));
				}
			}
                           
    		if (lock == 0)
                CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
                              
            //
            // Send back the data
            //
            notifyFillNotifierArray( pDev, pBus->CBase.NotifyXlate, 
                                     val32,
                                     0, 
                                     RM_OK, 
                                     NV051_NOTIFICATION_READ_GET_DATA_NOTIFY );
            
            break;
            
        default:
            break;            

    }
    return (RM_OK);
}

RM_STATUS class051SetInterruptNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PSERIALBUSOBJECT   pBus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051SetInterruptNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)Object;
    
    //
    // Make sure the interrupt is enabled
    //
    
    return (RM_OK);   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class05d.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV4_RENDER_SOLID_TRIANGLE **************************\
*                                                                           *
* Module: CLASS05D.C                                                        *
*   This module implements the NV4_RENDER_SOLID_TRIANGLE object class       *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class05DValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class05DSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask =  DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05DSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class05f.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** NV4_IMAGE_BLIT *********************************\
*                                                                           *
* Module: CLASS05F.C                                                        *
*   This module implements the NV4_IMAGE_BLIT object class                  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class05FValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.ColorKey == NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class05FSetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05FSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05FSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetContextSurfaces2d
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class062.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV10_CONTEXT_SURFACES_2D ***************************\
*                                                                           *
* Module: CLASS062.C                                                        *
*   This module implements the NV10_CONTEXT_SURFACES_2D object class        *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class060.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* NV4_INDEXED_IMAGE_FROM_CPU **************************\
*                                                                           *
* Module: CLASS060.C                                                        *
*   This module implements the NV4_INDEXED_IMAGE_FROM_CPU object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"
#include "nvhw.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class060Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class060SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class060SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class060SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class060SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class060SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class060SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class060SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class060SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class060SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetColorConversion\r\n");

    //
    // If we're an NV10, kick it back as an error, since POSTDITHER_2D lives
    // in PGRAPH_DEBUG_2 there (and NV5_INDEXED_IMAGE should be used anyway).
    //
    if (IsNV10orBetter(pDev))
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode.
    //
    // Since this comes in as a synchronous graphics exception, we can
    // assume we own the channel and can change the dither mode.
    //
    // The HAL graphics exception handler will be sure that we modify the
    // hardware, so we just handle error checking here.
    // 
    if ((Data != NV064_SET_COLOR_CONVERSION_DITHER) &&
        (Data != NV064_SET_COLOR_CONVERSION_TRUNCATE))
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class05c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV4_RENDER_SOLID_LIN *****************************\
*                                                                           *
* Module: CLASS05C.C                                                        *
*   This module implements the NV4_RENDER_SOLID_LIN object class            *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class05CValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class05CSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;
    U032                    andMask, orMask;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //            
                andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05CSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;
    U032                    andMask, orMask;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class05e.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* NV4_RENDER_SOLID_RECTANGLE **************************\
*                                                                           *
* Module: CLASS05E.C                                                        *
*   This module implements the NV4_RENDER_SOLID_RECTANGLE object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class05EValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class05ESetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05ESetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class061.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV4_IMAGE_FROM_CPU ******************************\
*                                                                           *
* Module: CLASS061.C                                                        *
*   This module implements the NV4_IMAGE_FROM_CPU object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class061Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class061SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class061SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class061SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class063.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV05_SCALED_IMAGE_FROM_MEMORY ************************\
*                                                                           *
* Module: class063.C                                                        *
*   This module implements the NV05_SCALED_IMAGE_FROM_MEMORY object class   *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class063Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class063SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.  
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class063SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class063SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class063SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class063SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class063SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
                
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class063SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class063SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV063_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV063_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV063_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV063_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class072.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** NV4_CONTEXT_BETA *******************************\
*                                                                           *
* Module: CLASS072.C                                                        *
*   This module implements the NV4_CONTEXT_BETA object class                *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class065.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV05_IMAGE_FROM_CPU ******************************\
*                                                                           *
* Module: CLASS065.C                                                        *
*   This module implements the NV05_IMAGE_FROM_CPU object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class065Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class065SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class065SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class065SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0 );
    
    return (status);
}


RM_STATUS class065SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class065SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV065_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV065_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV065_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class064.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* NV05_INDEXED_IMAGE_FROM_CPU **************************\
*                                                                           *
* Module: CLASS064.C                                                        *
*   This module implements the NV05_INDEXED_IMAGE_FROM_CPU object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class064Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class064SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class064SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class064SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        andMask = 0xffffffff;
        orMask = 0;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class064SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class064SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV064_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV064_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV064_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class077.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV4_SCALED_IMAGE_FROM_MEMORY *************************\
*                                                                           *
* Module: CLASS077.C                                                        *
*   This module implements the NV4_SCALED_IMAGE_FROM_MEMORY object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class077Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class077SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class077SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        orMask = 0;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
                
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class077SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class07b.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_TEXTURE_FROM_CPU ***************************\
*                                                                           *
* Module: CLASS07B.C                                                        *
*   This module implements the NV10_TEXTURE_FROM_CPU object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class067.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class067.C                                                        *
*   This module implements the NV10_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class067SetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate, 
                              0, 
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class067SetNotifyCtxDma

RM_STATUS class067SetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;
    
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067SetNotify

RM_STATUS class067StopImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopImage\r\n");

    // class067 supports only one head (head 0)
    dacDisableImage(pDev, 0);

    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopImage

RM_STATUS class067StopLUT
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopLUT\r\n");
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopLUT

RM_STATUS class067StopCursorImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, Head);

    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopCursorImage

RM_STATUS class067StopDAC
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopDAC\r\n");

    // class067 supports only one head (head 0).
    dacDisableDac(pDev, 0);

    // reset display type
    SETDISPLAYTYPE(pDev, 0, 0xffffffff);
    
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopDAC

RM_STATUS class067SetImageCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV067_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;
    
    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class067SetImageCtxDma

RM_STATUS class067SetLUTCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV067_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;
    
    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma, 
                              0, 
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class067SetLUTCtxDma

RM_STATUS class067SetCursorCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV067_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;
    
    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma, 
                              0, 
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class067SetCursorCtxDma

RM_STATUS class067SetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // For this head, this becomes the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV067_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class067SetPanOffset

RM_STATUS class067GetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067GetOffset\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 
                                         pVidLutCurDac->Image[Data].Offset, 
                                         NV067_NOTIFICATION_INFO16_VALID_OFFSET, 
                                         NV067_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV067_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE; 
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067GetOffset

// This proc writes the notification for an image buffer.
RM_STATUS class067ImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV067_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;   
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class067SetImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV067_SET_IMAGE_OFFSET(0):
        case NV067_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV067_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x03) != 0)
                // The image offset must be a multiple of 4 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV067_SET_IMAGE_FORMAT(0):
        case NV067_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  startAddr;
            U032  when;
            
            buffNum = (Offset == NV067_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV067_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x3F) != 0)
                // the pitch must be a multiple of 64 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;
            
            // when = DRF_VAL(067, _SET_IMAGE, _FORMAT_WHEN, Data);     // XXX win3.1/watcom can't grok this
            when = (Data >> DRF_SHIFT(NV067_SET_IMAGE_FORMAT_WHEN)) & DRF_MASK(NV067_SET_IMAGE_FORMAT_WHEN);
            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV067_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;

            if (when == NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY) 
            {
                // Change the default flip functionality to end of hsync.
                FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV10);
            }
            else
            {
                // Change the default flip functionality to end of vsync.
                FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA);
            }

            // Program the hardware.
            // The imageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr) + 
                               pVidLutCurDac->Image[buffNum].Offset);
            // add in the panning offset
            startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

            status = dacProgramVideoStart(pDev, Head, startAddr, pitch);
            if (status) 
            {
                pVidLutCurDac->Image[buffNum].NotifyTrigger = FALSE;
                return NV067_NOTIFICATION_STATUS_ERROR_INVALID_STATE;
            }
            if (when == NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
            {
                // Do the notify right here.
                class067ImageNotify(pDev, (POBJECT)pVidLutCurDac, 
                                    0 /* param 1*/, buffNum,
                                    NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
            }
            else
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class067ImageNotify;
                pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->Image[buffNum].ImageCallback.Next    = NULL;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->Image[buffNum].ImageCallback.Param2  = buffNum;
                pVidLutCurDac->Image[buffNum].ImageCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->Image[buffNum].ImageCallback));
            }
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class067SetImageValues

// This proc is called from VBlank to program the LUT.
RM_STATUS class067ProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032*     startAddr;
    U032      numEntries;
    U032      Head = 0;   // single-head class

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset, 
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, Head, startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                myStatus,
                                NV067_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          myStatus, 
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;   
    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class067SetLUTValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV067_SET_LUT_OFFSET(0):
        case NV067_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV067_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3FF) != 0)
                // The LUT offset must be a multiple of 1024 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV067_SET_LUT_FORMAT(0):
        case NV067_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV067_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class067ProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class067SetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class067CursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV067_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;   
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class067SetCursorImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorImageValues\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV067_SET_CURSOR_IMAGE_OFFSET(0):
        case NV067_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV067_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3ff) != 0)
                // The cursor image offset must be a multiple of 1024 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV067_SET_CURSOR_IMAGE_FORMAT(0):
        case NV067_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            U032 Head = 0; // single-head class
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV067_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            pVidLutCurDac->CursorImage[buffNum].Width = 
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_WIDTH)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_WIDTH);
            pVidLutCurDac->CursorImage[buffNum].Height =
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_HEIGHT)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_HEIGHT);
            pVidLutCurDac->CursorImage[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_COLOR)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_COLOR);

            pVidLutCurDac->CursorImage[buffNum].NotifyAction =  
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY);

            // Kick off the transfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) + 
                               pVidLutCurDac->CursorImage[buffNum].Offset);
            status = nvHalDacProgramCursorImage(pDev, startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           pVidLutCurDac->CursorImage[buffNum].Width, 
                                           pVidLutCurDac->CursorImage[buffNum].Height, 
                                           pVidLutCurDac->CursorImage[buffNum].ColorFormat,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status) 
            {
                pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = FALSE;
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, Head);

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class067CursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    
                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class067SetCursorImageValues

RM_STATUS class067SetCursorPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorPoint\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, Head,
                                      (Data & 0xffff), /* cursorX */ 
                                      (Data >> 16));   /* cursorY */
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067SetCursorPoint

RM_STATUS class067SetDACValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV067_SET_DAC_IMAGE_SIZE(0):
        case NV067_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV067_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.    
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048. 
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal Blank
        //
        case NV067_SET_DAC_HORIZONTAL_BLANK(0):
        case NV067_SET_DAC_HORIZONTAL_BLANK(1):
        {
            buffNum = (Offset == NV067_SET_DAC_HORIZONTAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 1024. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 1024))          // width greater than 1024
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV067_SET_DAC_HORIZONTAL_SYNC(0):
        case NV067_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV067_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set Vertical Blank
        //
        case NV067_SET_DAC_VERTICAL_BLANK(0):
        case NV067_SET_DAC_VERTICAL_BLANK(1):
        {
            buffNum = (Offset == NV067_SET_DAC_VERTICAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 128. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 128))   // width greater than 128
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Vertical sync
        //
        case NV067_SET_DAC_VERTICAL_SYNC(0):
        case NV067_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV067_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set total size.
        //
        case NV067_SET_DAC_TOTAL_SIZE(0):
        case NV067_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV067_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.    
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2. 
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        // Set pixel clock.
        case NV067_SET_DAC_PIXEL_CLOCK(0):
        case NV067_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV067_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV067_SET_DAC_FORMAT(0):
        case NV067_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV067_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR)pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;

            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV067_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV067_SET_DAC_FORMAT_COLOR);

			switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
				case NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
					pDev->Dac.HalInfo.Depth = 8;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
					pDev->Dac.HalInfo.Depth = 15;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
					pDev->Dac.HalInfo.Depth = 16;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
					pDev->Dac.HalInfo.Depth = 32;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
					break;
			}

            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth = pDev->Dac.HalInfo.Depth;

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;
            
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;   

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;
            pDev->Dac.HalInfo.PixelClock      = pVidLutCurDac->HalObject.Dac[buffNum].PixelClock;
            pDev->Dac.PixelDepth              = pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth;
            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;

            // Get output device...
            pVidLutCurDac->DisplayType		  = (Data >> DRF_SHIFT(NV067_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV067_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class067: invalid display type ", pVidLutCurDac->DisplayType);
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard		  = (Data >> DRF_SHIFT(NV067_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV067_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class067: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);

            if (pVidLutCurDac->CBase.NotifyXlate) 
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                                 modeSetStatus,
                                                 NV067_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                                  NV067_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */, 
                                  0 /* Data */, 
                                  modeSetStatus, 
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;   

            return modeSetStatus;
        }
        
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class067SetDACValues
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class088.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_DVD_SUBPICTURE ******************************\
*                                                                           *
* Module: CLASS088.C                                                        *
*   This module implements the NV10_DVD_SUBPICTURE object class             *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class089.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV10_SCALED_IMAGE_FROM_MEMORY ************************\
*                                                                           *
* Module: class089.C                                                        *
*   This module implements the NV10_SCALED_IMAGE_FROM_MEMORY object class   *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class076.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV4_STRETCHED_IMAGE_FROM_CPU *************************\
*                                                                           *
* Module: CLASS076.C                                                        *
*   This module implements the NV4_STRETCHED_IMAGE_FROM_CPU object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class076Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class076SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class076SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetOperation\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class066.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV05_STRETCHED_IMAGE_FROM_CPU ************************\
*                                                                           *
* Module: CLASS066.C                                                        *
*   This module implements the NV05_STRETCHED_IMAGE_FROM_CPU object class   *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class066Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class066SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class066SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}

RM_STATUS class066SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV066_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV066_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV066_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
}

RM_STATUS class066SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetOperation\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class094.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV10_DX5_TEXTURED_TRIANGLE *************************\
*                                                                           *
* Module: CLASS094.C                                                        *
*   This module implements the NV10_DX5_TEXTURED_TRIANGLE object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class093.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV10_CONTEXT_SURFACES_3D ***************************\
*                                                                           *
* Module: CLASS093.C                                                        *
*   This module implements the NV10_CONTEXT_SURFACES_3D object class        *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class096.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV15_CELSIUS_PRIMITIVE **************************\
*                                                                           *
* Module: CLASS096.C                                                        *
*   This module implements the NV15_CELSIUS_PRIMITIVE object class          *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>
#include <dma.h>
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

extern VOID grGetState(PHWINFO, U032, BOOL);
extern VOID grPutState(PHWINFO, U032, BOOL);
extern VOID grSnapshotPrimAssm(PHWINFO, U032);
extern VOID grReloadPrimAssm(PHWINFO, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class095.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************** NV10_DX6_MULTI_TEXTURE_TRIANGLE ************************\
*                                                                           *
* Module: CLASS095.C                                                        *
*   This module implements the NV10_DX6_MULTI_TEXTURE_TRIANGLE object class *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class64.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER methods.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class64SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class64SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetNotify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS class64SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetVideoOutput\r\n");

    return (RM_OK);
}

RM_STATUS class64SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetVideoInput\r\n");

    return (RM_OK);
}

RM_STATUS class64SetDeltaDuDx
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetDeltaDuDx\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_SCALER, &pVidScaler->HalObject, NVFF7_SET_DELTA_DU_DX(0), Data, &status);

    return (status);
}

RM_STATUS class64SetDeltaDvDy
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetDeltaDvDy\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_SCALER, &pVidScaler->HalObject, NVFF7_SET_DELTA_DV_DY(0), Data, &status);

    return (status);
}

RM_STATUS class64SetPoint
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetPoint\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_SCALER, &pVidScaler->HalObject, NVFF7_SET_POINT(0), Data, &status);

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class65.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <nv32.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class65SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class65SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetNotify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class65SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetVideoOutput\r\n");

    return (RM_OK);
}

RM_STATUS class65SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetVideoInput\r\n");

    return (RM_OK);
}

RM_STATUS class65SetColorFormat
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetColorFormat\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_COLOR_FORMAT(0), Data, &status);

    return (status);
}

RM_STATUS class65SetColorKey
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_COLOR_KEY(0), Data, &status);

    return (status);
}

RM_STATUS class65SetPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetPoint\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_POINT(0), Data, &status);

    return (status);
}

RM_STATUS class65SetSize
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetSize\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;
    //
    // Initialize the color key rectangle.
    //
    // Set the width and height of the color key rectangle.
    //
    if (pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS)
    {
        U032 tempData;

        tempData = (Data & 0x0000FFFF);
        if (tempData > 0x00007FFF)
            tempData = 0x00007FFF;
        Data &= 0xFFFF0000;
        Data |= tempData;
    }

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_SIZE(0), Data, &status);

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class07a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class07a.C                                                        *
*   This module implements the NV10_VIDEO_OVERLAY methods.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

#if 0
static RM_STATUS class07AOverlayService(PHWINFO, POBJECT);
#endif

BOOL   HwOwnsBuffer(PHWINFO, U032, POBJECT);
extern VOID NV10_AdjustScalarForTV(PHWINFO, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/video/videoobj.c
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class07ASetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    PVIDEO_OVERLAY_HAL_OBJECT   pOverlayHalObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    pOverlayHalObject = &pOverlayObject->HalObject;
    
    if (pOverlayObject->CBase.NotifyTrigger)
        return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->CBase.NotifyXlate));
    if (status)
        return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pOverlayObject->CBase.NotifyXlate, 
                              0, 
                              (3 * 0x0010));
    if (status)
    {
        pOverlayObject->CBase.NotifyXlate = NULL;
        return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class07ASetNotifyCtxDma

RM_STATUS class07ASetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    pOverlayObject->CBase.NotifyAction  = Data;
    pOverlayObject->CBase.NotifyTrigger = TRUE;
    
    return (NV07A_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07ASetNotify

RM_STATUS class07AStopOverlay
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    RM_STATUS                    status;
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;


    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);

    return status;
} // end of class07AStopOverlay

RM_STATUS class07ASetOverlayCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    buffNum = (Offset == NV07A_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);

    if (Data == NV01_NULL_OBJECT)
    {
        pOverlayObject->Overlay[buffNum].OverlayCtxDma = NULL;
        pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = NULL;
        return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->Overlay[buffNum].OverlayCtxDma));
    if (status)
        return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    // The overlay context dma MUST point to the frame buffer.
    if (pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo.AddressSpace != ADDR_FBMEM)
    {
        return NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
    }

    // Give HAL access to context dma.
    pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = &pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo;

    return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07ASetOverlayCtxDma

RM_STATUS class07AGetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07AGetOffset\r\n");
    
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    if (!pOverlayObject->CBase.NotifyTrigger)
        // nothing to do.
        return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pOverlayObject->CBase.NotifyXlate) 
    {
        //
        // Give HAL chance to setup offset if necessary.
        //
        (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
        if (status)
            return status;
        status = notifyFillNotifierArray(pDev, pOverlayObject->CBase.NotifyXlate, 
                                         pOverlayObject->HalObject.Overlay[Data].Offset,   // info32
                                         NV07A_NOTIFICATION_INFO16_VALID_OFFSET, // info16
                                         NV07A_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV07A_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pOverlayObject->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pOverlayObject, 
                          NV07A_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pOverlayObject->CBase.NotifyAction);
        }
    }

    pOverlayObject->CBase.NotifyTrigger = FALSE; 
    return (NV07A_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07AGetOffset

RM_STATUS class07ASetOverlayValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayValues\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    // Initialize the overlay description.
    //
    switch (Offset)
    {
        case NV07A_SET_OVERLAY_LUMINANCE(0):
        case NV07A_SET_OVERLAY_LUMINANCE(1):
        case NV07A_SET_OVERLAY_CHROMINANCE(0):
        case NV07A_SET_OVERLAY_CHROMINANCE(1):
        case NV07A_SET_OVERLAY_COLORKEY(0):
        case NV07A_SET_OVERLAY_COLORKEY(1):
        case NV07A_SET_OVERLAY_OFFSET(0):
        case NV07A_SET_OVERLAY_OFFSET(1):
        case NV07A_SET_OVERLAY_SIZE_IN(0):
        case NV07A_SET_OVERLAY_SIZE_IN(1):
        case NV07A_SET_OVERLAY_POINT_IN(0):
        case NV07A_SET_OVERLAY_POINT_IN(1):
        case NV07A_SET_OVERLAY_DU_DX(0):
        case NV07A_SET_OVERLAY_DU_DX(1):
        case NV07A_SET_OVERLAY_DV_DY(0):
        case NV07A_SET_OVERLAY_DV_DY(1):
        case NV07A_SET_OVERLAY_POINT_OUT(0):
        case NV07A_SET_OVERLAY_POINT_OUT(1):
        case NV07A_SET_OVERLAY_SIZE_OUT(0):
        case NV07A_SET_OVERLAY_SIZE_OUT(1):
            (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
            return status;
        case NV07A_SET_OVERLAY_FORMAT(0):
        case NV07A_SET_OVERLAY_FORMAT(1):
        {
            RM_STATUS status;
            U032 buffNum;

            buffNum = (Offset == NV07A_SET_OVERLAY_FORMAT(0)) ? 0 : 1;

            // Check to see if we should awaken and notify 
            if (Data & 0x80000000 ) {
                // if so, set the appropriate action
                //pOverlayObject->Overlay[buffNum].NotifyAction = NV_OS_WRITE_THEN_AWAKEN;
                pOverlayObject->Overlay[buffNum].NotifyAction = 1;
            
            }

            (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);

            //
            // Ensure class-dependent video service handler is
            // setup properly.
            //
            if (status == RM_OK)
            {
                pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) pOverlayObject;
                pDev->pOverlayServiceHandler = videoOverlayService;
            }
            return status;
        }
        default:
            return NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class07ASetOverlayValues

RM_STATUS class07ASetOverlayPointOutNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayPointOutNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);
    
    return status;
}

RM_STATUS class07ASetOverlayLuminanceNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayLuminanceNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);

    return status;
}

RM_STATUS class07ASetOverlayChrominanceNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayChrominanceNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class09f.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** NV15_IMAGE_BLIT ********************************\
*                                                                           *
* Module: CLASS09F.C                                                        *
*   This module implements the NV15_IMAGE_BLIT object class                 *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>
#include <dma.h>
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


#ifdef SHOULD_BE_HW_METHODS

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class09FValidate
(
    PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||
                    pRenderObject->RCPatchContext.ColorKey == NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
        (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;

    } else {

        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class09FSetContextColorKey
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextClip
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextPattern
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextRop
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextBeta1
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextBeta4
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextSurfaces2d
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS)
    {
        //
        // Set the new value
        //
        andMask = ~DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG);
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}

#endif // SHOULD_BE_HW_METHODS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class63.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class63.C                                                         *
*   This module implements the NV_VIDEO_FROM_MEMORY methods.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

// statics
static RM_STATUS class63XferComplete(PHWINFO, POBJECT, U032, V032, RM_STATUS);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/video/videoobj.c
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
static RM_STATUS class63WaitVBlank
(
    PHWINFO       pDev,
    PVBLANKNOTIFY VBlankNotify,
    U032          buffer,
    U032          waitCount
)
{   
    //
    // Check for in-use.
    //
    if (VBlankNotify->Next)
        return (RM_ERR_NOTIFY_IN_USE);
    //
    // Stick this object on the appropriate queue waiting for the next VBlank
    //
    VBlankNotify->Next   = pDev->DBclass63VBlankList[buffer];
    pDev->DBclass63VBlankList[buffer] = VBlankNotify;

    pDev->Video.class63VBlankCount[buffer] = waitCount;

    return (RM_OK);
}

RM_STATUS class63VBlank
(
    PHWINFO pDev
)
{
    PVBLANKNOTIFY VBlankNotify;
    PVBLANKNOTIFY VBlankNext;

    //
    // Pull all notifies annd complete them.
    //
    if (--pDev->Video.class63VBlankCount[pDev->Framebuffer.Current] == 0)
    {
    VBlankNotify = pDev->DBclass63VBlankList[pDev->Framebuffer.Current];
    while (VBlankNotify)
    {
        VBlankNext         = VBlankNotify->Next;
        VBlankNotify->Next = NULL;
        VBlankNotify->Proc(pDev,
                           VBlankNotify->Object,
                           VBlankNotify->Param1,
                           VBlankNotify->Param2,
                           RM_OK);
        VBlankNotify = VBlankNext;

        //DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "n");
        
    }
    pDev->DBclass63VBlankList[pDev->Framebuffer.Current] = NULL;
    pDev->Video.class63VBlankCount[pDev->Framebuffer.Current] = 0;
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
RM_STATUS class63SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;
    PVIDEOFROMMEMOBJECT pVidFromMem;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetNotifyCtxDma\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    
    if (pVidFromMem->BufferObj.Base.NotifyTrigger)
        return (NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidFromMem->BufferObj.Base.NotifyXlate));
    if (status)
        return (NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidFromMem->BufferObj.Base.NotifyXlate, 0, (5 * 0x0010));
    if (status)
    {
        pVidFromMem->BufferObj.Base.NotifyXlate   = NULL;
        return (NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT);
    }
    
    //
    // Since NV4 uses the same notify buffer for all buffers, plug them into everywhere
    //
    pVidFromMem->BufferObj.Buffer[0].NotifyXlate = pVidFromMem->BufferObj.Base.NotifyXlate;
    pVidFromMem->BufferObj.Buffer[1].NotifyXlate = pVidFromMem->BufferObj.Base.NotifyXlate;
    
    return (status);
}

RM_STATUS class63SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //
    pVidFromMem->BufferObj.Base.NotifyAction  = Data;
    pVidFromMem->BufferObj.Base.NotifyTrigger = TRUE;
    
    return (RM_OK);
}

RM_STATUS class63StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEOFROMMEMOBJECT pVidFromMem;
    RM_STATUS           status;
    U032                Head = 0; // single head class
    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;

    VidLutCurDac.Head = Head;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StopTransfer\r\n");

    //
    // Stop the current data transfer immediately.
    //

    if (pVidFromMem->HalObject.Buffer[0].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                                 0, 
                                 0, 
                                 RM_OK, 
                                 NVFF8_NOTIFIERS_IMAGE_SCAN(0) );
        pVidFromMem->HalObject.Buffer[0].State = OVERLAY_BUFFER_IDLE;
    }
    if (pVidFromMem->HalObject.Buffer[1].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                                 0, 
                                 0, 
                                 RM_OK, 
                                 NVFF8_NOTIFIERS_IMAGE_SCAN(1) );
        pVidFromMem->HalObject.Buffer[1].State = OVERLAY_BUFFER_IDLE;
    }

    //
    // Notify this one
    //
    notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                             0, 
                             0, 
                             RM_OK, 
                             NVFF8_NOTIFIERS_IMAGE_SCAN(0) );
                    
    //
    // And the other one
    //
    notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                             0, 
                             0, 
                             RM_OK, 
                             NVFF8_NOTIFIERS_IMAGE_SCAN(1) );
    //
    // Issue stop-immediately call to HAL.
    //
    (void) nvHalVideoMethod(pDev, NV_VIDEO_FROM_MEMORY, &pVidFromMem->HalObject, NVFF8_STOP_TRANSFER(0), NVFF8_STOP_TRANSFER_VALUE, &status);
    
    //
    // Transition state of object back to uninitialized.
    //
    pVidFromMem->InitState = 0;

    //
    // Video has been disabled, so refresh arb settings.
    //
    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);

    // Clear the active overlay object.
    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pVidFromMem)
        pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) NULL;

    return status;
}

RM_STATUS class63SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetVideoOutput\r\n");

    return (RM_OK);
}

RM_STATUS class63SetImageCtxDma
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;
    U032 buffNum;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetImageCtxDma\r\n");

    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    buffNum = (Offset - Method->Low) >> 2;

    //
    // Set the image buffer DMA context.
    //
    status = mthdSetBufferCtxDma(pDev, Object, Method, Offset, Data);

    //
    // Give HAL access to context dma.
    //
    pVidFromMem->HalObject.Buffer[buffNum].bufferCtxDma = &pVidFromMem->BufferObj.Buffer[buffNum].Xlate->HalInfo;

    return status;
}

RM_STATUS class63ImageScan
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEOFROMMEMOBJECT     pVidFromMem;
    PVIDEOFROMMEMHALOBJECT  pVidFromMemHalObj;
    PBUFFEROBJECT           pBuffObject;
    U032                    Buffer;
    RM_STATUS               status;
    U032                    Size;
    U032                    Head = 0; // single-head class

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63ImageScan\r\n");

    VidLutCurDac.Head = Head;

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    pVidFromMemHalObj = &pVidFromMem->HalObject;
    pBuffObject = (PBUFFEROBJECT)Object;
    Buffer = ((Offset - Method->Low) <= 0x10) ? 0 : 1;

    //
    // Initialize the image buffer description.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Offset
        //
        case 0x00:
        case 0x14:
            dmaSetBufferStart(pBuffObject, &(pBuffObject->Buffer[Buffer]), Offset, Data);
            pVidFromMemHalObj->Buffer[Buffer].Start = pBuffObject->Buffer[Buffer].Start;
            break;
        //
        // Set Pitch
        //
        case 0x04:
        case 0x18:
            dmaSetBufferPitch(pBuffObject, &(pBuffObject->Buffer[Buffer]), Offset, Data);
            pVidFromMemHalObj->Buffer[Buffer].Pitch = pBuffObject->Buffer[Buffer].Pitch;
            break;
        //
        // Set Size
        //
        case 0x08:
        case 0x1C:

            //
            // Save away the width separately
            //
            pBuffObject->Buffer[Buffer].Width = (Data & 0xFFFF);
            pVidFromMemHalObj->Buffer[Buffer].Width = (Data & 0xFFFF);

            // Cheat for now to get the length
            Size = (Data & 0xFFFF) * ((Data & 0xFFFF0000)>>16);
            dmaSetBufferLength(pBuffObject, &(pBuffObject->Buffer[Buffer]), Offset, Size);
            pVidFromMemHalObj->Buffer[Buffer].Length = pBuffObject->Buffer[Buffer].Length;
            break;
        //
        // Set Format.
        //
        case 0x0C:
        case 0x20:
			//
			// For now, we must make the assumption that both buffers
			// have the same format.  Makes sense -- but if we want
			// different formats in the future, just move the format
			// field down from the BufferObj into the individual buffers.
			//
            pBuffObject->Sample.Format = Data;
            pVidFromMemHalObj->Format = Data;

            // Q: How do we know that this object is the one pointing to the h/w?
            // If this is a s/w only object then need to disable any writes to h/w!
			
            break;
        //
        // Set Notify
        //
        case 0x10:
        case 0x24:
#ifdef DEBUG_TIMING            
            if ((Offset - Method->Low) == 0x10)
            {    
                //DBG_PRINT_TIME("VideoKickoff0: ",REG_RD32(NV_PTIMER_TIME_1) - time0hi);
                DBG_PRINT_TIME("VideoKickoff0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                    
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
            } 
            else
            {    
                //DBG_PRINT_TIME("VideoKickoff1: ",REG_RD32(NV_PTIMER_TIME_1) - time1hi);
                DBG_PRINT_TIME("VideoKickoff1: ",REG_RD32(NV_PTIMER_TIME_0) - time1lo);
             
                time1hi = REG_RD32(NV_PTIMER_TIME_1);
                time1lo = REG_RD32(NV_PTIMER_TIME_0);
            }
#endif // DEBUG_TIMING            
            //
            // Verify all required data has been sent
            //  verify rest of imagescan

            //
            // YUV Buffers will be handled normally; RGB buffer will be
            // special cased, since they really aren't double-buffered.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
                ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
                ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
                ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
            {
                U032 when;
                U032 Head = 0;  // this is a single-head class
                //
                // We assume the format, pitch, and length are the same as the 
                // framebuffer.
                //
                // RGB video is not handled as a true double-buffered object,
                // but instead acts as a single-shot transfer with notify.
                // When the app wants a transfer, it sets a notify.  Nothing
                // really moves automatically (unlike back-end Video).
                //

                //
                // !!!!! SIMPLE VALIDATATION NEEDED !!!!!
                //  verify contexts

                //
                // Make sure outstanding notification doesn't exist.
                //
                if (pVidFromMem->VBlankNotify[Buffer].Pending)
                    return (NVFF8_NOTIFICATION_STATUS_IN_PROGRESS);

                //
                // This class does not have support for flipping on HSync.
                // That support is only in class 049 (NV05_VIDEO_LUT_CURSOR_DAC).
                // Simulate it with a registry setting.
                //
                if (IsNV5orBetter(pDev) && pDev->Video.FlipOnHsync == 0x1) 
                {
                    // Flip on HSync instead of VSync.
                    when = NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY; // just use the class 49 define.
                }
                else
                {
                    when = NV049_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER;
                }

                //
                // Validate notification.
                //
                status = dmaValidateXlate(pVidFromMem->BufferObj.Base.NotifyXlate,
                                          0,
                                          0x000F);

                dacProgramVideoStart(pDev, Head,
                                     pBuffObject->Buffer[Buffer].Start,
                                     pBuffObject->Buffer[Buffer].Pitch);

                if (!IsNV10orBetter(pDev) && when == NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
                {
                    // Change the default flip functionality to end of hsync.
                    FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV5);

                    // Don't wait for VSync for the notify. Just do it right here. The assumption is that
                    // HSync will happen before the driver pays attention to the notification.
                    // Do everything that would have normally been done in VBlank.
                    pDev->Framebuffer.FlipFrom = pDev->Framebuffer.Current;
                    pDev->Framebuffer.FlipTo   = pDev->Framebuffer.Current ^ 1;
                    pDev->Framebuffer.Current  ^= 1;

                    class63XferComplete(pDev, Object, Offset, Buffer, RM_OK);
                }
                else
                {
                    //
                    // We want to get a notify when done transferring to Buffer.  The
                    // VBlank notify algorithm works on which buffer you're transferring
                    // from, so we need to flip from the current buffer.  This dictates
                    // that the next vblank will cause this callback.
                    //
                    pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current ^ 1] = pBuffObject->Buffer[Buffer].Start;
                    pDev->Framebuffer.FlipTo = pDev->Framebuffer.Current ^ 1;
                    pDev->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_FLIP;
                    pVidFromMem->VBlankNotify[Buffer].Object  = Object;
                    pVidFromMem->VBlankNotify[Buffer].Proc    = class63XferComplete;
                    pVidFromMem->VBlankNotify[Buffer].Next    = NULL;
                    pVidFromMem->VBlankNotify[Buffer].Pending = FALSE;
                    pVidFromMem->VBlankNotify[Buffer].Xlate   = pVidFromMem->BufferObj.Base.NotifyXlate;
                    pVidFromMem->VBlankNotify[Buffer].Action  = Data;
                    pVidFromMem->VBlankNotify[Buffer].Param1  = Offset;
                    pVidFromMem->VBlankNotify[Buffer].Param2  = Buffer;

                    status = class63WaitVBlank(pDev, &(pVidFromMem->VBlankNotify[Buffer]), 
                                               pDev->Framebuffer.Current ^ 1, 1);
                }
            } // RGB Video
            else
            {
                //
                // YUV
                //
				// Here is an overview of how hardware overlay works:
                // VideoFroMem, VideoScaler and VideoColorKey objects are setup by DDraw before calling
                // the VideoFromMem->Notify method (which is where we are now).
                // 
                // The Notify method on VideoFromMemory class tells the RM that all the values for one
                // frame are setup and we should program the hardware. The RM then marks the appropriate
                // buffer as BUFFER_BUSY. 
                //
                // class63VideoService is the interrupt handler that handles the "scanout complete"
                // interrupt from the video engine. The video engine is double buffered. So the video
                // engine is constantly toggling the "current buffer". The RM tries to keep feeding
                // the video engine with new values.
                //
                // After handling the notification (if any) of a buffer completion, VideoService tries
                // to kickoff the other buffer. (For example, at the completion of buffer 0, we will try
                // to kickoff buffer 1 if it is in state BUFFER_BUSY). When a buffer is actually kicked off
                // (i.e loaded into the hardware registers), its state is marked BUFFER_NOTIFY_PENDING.
                //
                // If the other buffer is not BUFFER_BUSY at the completion of a buffer, we will restart
                // the same buffer by forcing the hardware to flip to the same buffer again. This is so
                // that we will always get an interrupt even when there are no new values to be loaded.
                // It is necessary to get an interrupt because the interrupt handler is the only place
                // (other than the first time) we actually kickoff a buffer by programming the hardware
                // registers.
                // 
                // State transitions of a buffer:
                // A buffer goes from state BUFFER_IDLE to BUFFER_BUSY when the notify method is invoked.
                // It goes from BUFFER_BUSY to BUFFER_NOTIFY_PENDING when its values are actually programmed
                // into the appropriate hardware registers (in class63InitXfer the very first time and in
                // class63VideoService the rest of the time).
                // It goes from BUFFER_NOTIFY_PENDING to BUFFER_IDLE when the hardware is finished scanning out
                // that buffer and a notification is written for it (in class63VideoService).
                //

                //
                // This will also kick off a call to the bufferXfer proc for this buffer.
                // The very first time the bufferXfer proc is setup to call class63InitXfer.
                //
                if (pBuffObject->Buffer[Buffer].Length) // KJK quick hack so we don't start running immediately!!
                {
                    if (pVidFromMemHalObj->Buffer[Buffer].State != OVERLAY_BUFFER_IDLE)
                    {
                        // Trying to kickoff a busy buffer.
#ifdef DEBUG_TIMING
                        DBG_PRINT_STRING_VALUE(0x10, "******TRYING TO KICKOFF BUSY BUFFER********: ",Buffer);
#endif
                        return NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                    }

                    //
                    // Check for DMA translation instances.
                    //
                    if (!pBuffObject->Buffer[Buffer].Xlate->HalInfo.Instance ||
                        !pBuffObject->Buffer[Buffer].NotifyXlate->HalInfo.Instance)
                        return (RM_ERR_INVALID_XLATE);
                    
                    pBuffObject->Buffer[Buffer].NotifyAction = Data;

                    //
                    // If this is the init stage on this object,
                    // make sure the video overlay hardware is available.
                    //
                    if (pVidFromMem->InitState == 0)
                    {
                        if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject != (POBJECT) NULL)
                        {
                            return NV_OUT_OF_RESOURCES;
                        }

                        //
                        // Validate patch
                        // XXX (scottl): do we need this anymore?!?!?
                        if (!pBuffObject->Valid)
                        {
                            pVidFromMem->CBase.ChID = pBuffObject->Base.ChID;
                            pBuffObject->Valid = TRUE;
                        }
                    }


                    //
                    // Call into HAL to program up any hw.
                    //
                    (void) nvHalVideoMethod(pDev, NV_VIDEO_FROM_MEMORY, &pVidFromMem->HalObject, NVFF8_IMAGE_SCAN_NOTIFY(0, Buffer), Data, &status);
                    if (status)
                    {
                        notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                                                 0, 
                                                 0, 
                                                 status, 
                                                 NVFF8_NOTIFIERS_IMAGE_SCAN(Buffer) );
                    }
                    else
                    {
                        //
                        // If video has just been enabled, then refresh arb settings.
                        //
                        if (pVidFromMem->InitState == 0)
                        {
                            nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);
                            pVidFromMem->InitState = 1;
                        }

                        // Make this the active overlay object.
                        pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) pVidFromMem;
                        pDev->pOverlayServiceHandler   = videoFromMemService;
                    }
                }
                else
                {
                	// Length is 0. Assume we want to stop the overlay.
                    class63StopTransfer(pDev, (POBJECT)pVidFromMem, 
                                        0 /*Method */, 0 /* Offset */, 0 /* data */);
                }
            }
            break;
    }
    return (RM_OK);
}

RM_STATUS class63GetOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    return (RM_OK);
}    

//---------------------------------------------------------------------------
//
//  Buffer transfer routines. 
//
//---------------------------------------------------------------------------

static RM_STATUS class63XferComplete
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Status
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63XferComplete\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;

    notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                             0, 
                             0, 
                             Status, 
                             NVFF8_NOTIFIERS_IMAGE_SCAN(Data) );
                             
    //KJK dmaEndXfer(pVidFromMem->BBuffer[Data].NotifyXlate, NULL);
    //
    // Do any OS specified action related to this notification.
    //
    if (pVidFromMem->BBuffer[Data].NotifyAction)
    {
        osNotifyEvent(pDev, Object, 
                      NVFF8_NOTIFIERS_IMAGE_SCAN(Data),
                      0, 
                      1, 
                      RM_OK, 
                      pVidFromMem->BBuffer[Data].NotifyAction);
                       
    }
    pVidFromMem->VBlankNotify[Data].Pending = FALSE;
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class07c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class07C.C                                                        *
*   This module implements the NV15_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>
#include <dma.h>
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

#define IS_2D_BASED_FLIP(pDev, Object)    \
    ((pDev)->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac == (VOID_PTR)(Object))

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class07CSetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate,
                              0,
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return (status);
} // end of class07CSetNotifyCtxDma

RM_STATUS class07CSetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CSetNotify

RM_STATUS class07CStopImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) Object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopImage\r\n");

    dacDisableImage(pDev, DACGETHEAD(pVidLutCurDac));

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CStopImage

RM_STATUS class07CStopLUT
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopLUT\r\n");
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CStopLUT

RM_STATUS class07CStopCursorImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) Object;
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, DACGETHEAD(pVidLutCurDac));

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CStopCursorImage

RM_STATUS class07CStopDAC
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) Object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopDAC\r\n");

    // only allow this method if this object was the last one to set a mode on this head
    if (pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac == (VOID_PTR)pVidLutCurDac)
    {
        dacDisableDac(pDev, DACGETHEAD(pVidLutCurDac));

        // reset display type
        SETDISPLAYTYPE(pDev, DACGETHEAD(pVidLutCurDac), 0xffffffff);
    }
    
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
    
} // end of class07CStopDAC

RM_STATUS class07CSetImageCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV07C_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;

    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07CSetImageCtxDma

RM_STATUS class07CSetLUTCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV07C_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;

    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma,
                              0,
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class07CSetLUTCtxDma

RM_STATUS class07CSetCursorCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV07C_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;

    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma,
                              0,
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class07CSetCursorCtxDma


RM_STATUS class07CSetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // For this head, this becomes the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV07C_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07CSetPanOffset

RM_STATUS class07CSetSemaphoreCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetSemaphoreCtxDma\r\n");

    //
    // Set the semaphore DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    if (pVidLutCurDac->Semaphore.ReleaseTrigger)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: SetSemaCtxdma: trigger active!\n");
        DBG_BREAKPOINT();
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
    }

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Semaphore.SemaphoreCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Semaphore.SemaphoreCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // There are some rules on alignment of both base/offset.
    // The hardware expects a single page of memory.
    //

    //
    // Validate the dma context.
    // Needs to be one page big at least.
    //
    status = dmaValidateXlate(pVidLutCurDac->Semaphore.SemaphoreCtxDma,
                              0,
                              0x1000);
    if (status)
    {
        pVidLutCurDac->Semaphore.SemaphoreCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07CSetSemaphoreCtxDma

RM_STATUS class07CSetSemaphoreOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status = RM_OK;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetSemaphoreOffset: ", Data);

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;


    if (pVidLutCurDac->Semaphore.ReleaseTrigger)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: SetSemaOffset: trigger active!\n");
        DBG_BREAKPOINT();
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
    }

    //
    // Better have the semaphore ctxdma plugged in.
    //
    if (pVidLutCurDac->Semaphore.SemaphoreCtxDma == NULL)
        return (NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE);

    //
    // Alignment check...for the host, 4byte aligned is OK.
    //
    // Note that for nv20 graphics (kelvin) release methods, the
    // alignment must be 16byte to workaround a hw bug.
    //
    if (Data & 0x3)
        return(NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    pVidLutCurDac->Semaphore.Offset = Data;

    return status;

} // end of class07CSetSemaphoreOffset

RM_STATUS class07CSetSemaphoreRelease
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 *ReleaseAddr;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetSemaphoreRelease: ", Data);

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    //
    // Better have the semaphore ctxdma plugged in.
    //
    if (pVidLutCurDac->Semaphore.SemaphoreCtxDma == NULL)
        return (NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE);

    if (pVidLutCurDac->Semaphore.ReleaseTrigger == TRUE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: semaphore trigger active!\n");
        DBG_BREAKPOINT();
        return (NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
    }

    status = dmaGetMappedAddress(pDev, pVidLutCurDac->Semaphore.SemaphoreCtxDma, pVidLutCurDac->Semaphore.Offset, 0x0003, (VOID **)&(ReleaseAddr));
    if (status)
        return (status);

    //
    // The actual release will occur after the next flip...
    //
    pVidLutCurDac->Semaphore.ReleaseAddr = ReleaseAddr;
    pVidLutCurDac->Semaphore.ReleaseValue = Data;
    pVidLutCurDac->Semaphore.ReleaseTrigger = TRUE;

    return status;

} // end of class07CSetSemaphoreOffset

RM_STATUS class07CSetOffsetRange
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         start, stop, polarity;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetOffsetRange\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->Polarity   = Data & 0x80000000;  // top bit is polarity (in/out of range)
    pVidLutCurDac->ScanRegion = Data & 0x7FFFFFFF;  // remaining bits are start/stop offsets

    // Extract the data (polarity indicates if the stall occurs inside or outside the start/stop range)
    start    = (Data >> DRF_SHIFT(NV07C_SET_OFFSET_RANGE_START)) & DRF_MASK(NV07C_SET_OFFSET_RANGE_START);
    stop     = (Data >> DRF_SHIFT(NV07C_SET_OFFSET_RANGE_STOP)) & DRF_MASK(NV07C_SET_OFFSET_RANGE_STOP);
    polarity = (Data >> DRF_SHIFT(NV07C_SET_OFFSET_RANGE_POLARITY)) & DRF_MASK(NV07C_SET_OFFSET_RANGE_POLARITY);

    // Program the hardware
    status = dacProgramScanRegion(pDev, DACGETHEAD(pVidLutCurDac), start, stop, polarity);

    if (status)
        return(NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    else
        return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);

} // end of class07CSetOffsetRange


RM_STATUS class07CGetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CGetOffset\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification.
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate,
                                         pVidLutCurDac->Image[Data].Offset,
                                         NV07C_NOTIFICATION_INFO16_VALID_OFFSET,
                                         NV07C_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV07C_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_NOTIFY,
                          0 /* Method */,
                          0 /* Data */,
                          status,
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE;
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CGetOffset


// This proc writes the notification for an image buffer.
RM_STATUS class07CImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 startAddr;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // assert we're on the expected vblank
    RM_ASSERT(pVidLutCurDac->Image[BuffNum].ImageCallback.VBlankCount ==
              pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter);

    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                Status,
                                NV07C_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */,
                          0 /* Data */,
                          Status,
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }

    // Check if this is a 2D or 3D flip
    if (IS_2D_BASED_FLIP(pDev, Object)) {
        //
        // For 2D panning flips, on a head with an active video overlay, update
        // the window start since DDraw won't see this as windows move event.
        //
        if (pDev->Video.HalInfo.ActiveVideoOverlayObject &&
            (pDev->Video.HalInfo.Head == DACGETHEAD(pVidLutCurDac))) {

            videoUpdateWindowStart(pDev,
                                   pVidLutCurDac->Image[BuffNum].DeltaX,
                                   pVidLutCurDac->Image[BuffNum].DeltaY);
        }
    } else {
        //
        // For 3D flips, if this is a synchronized multihead flip, only
        // the last head that completes their flip will increment READ_3D.
        //
        if (pVidLutCurDac->Image[BuffNum].MultiSync) {
            pDev->Dac.MultiSyncCounter--;
            if (pDev->Dac.MultiSyncCounter == 0) {
                FLD_WR_DRF_DEF(_PGRAPH, _INCREMENT, _READ_3D, _TRIGGER);
                pDev->Dac.MultiSyncCounter = pDev->Dac.HalInfo.NumCrtcs;
            }
        } else {
            FLD_WR_DRF_DEF(_PGRAPH, _INCREMENT, _READ_3D, _TRIGGER);
        }
    }

    startAddr = (U032)((size_t)(pVidLutCurDac->Image[BuffNum].ImageCtxDma->DescAddr) +
                pVidLutCurDac->Image[BuffNum].Offset);
    // add in the panning offset
    startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

    if (dacProgramVideoStart(pDev, DACGETHEAD(pVidLutCurDac), startAddr, pVidLutCurDac->Image[BuffNum].Pitch))
    {
        pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;
        return NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE;
    }

    //
    // Handle semaphore release.
    //
    if (pVidLutCurDac->Semaphore.ReleaseTrigger == TRUE)
    {
        *pVidLutCurDac->Semaphore.ReleaseAddr = pVidLutCurDac->Semaphore.ReleaseValue;
        pVidLutCurDac->Semaphore.ReleaseTrigger = FALSE;
    }

    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
}

static
VOID class07CSetScreenDeltaXY
(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac,
    U032 buffNum,
    U032 newOffset
)
{
    S032 pitch, bpp;
    S032 deltaOffset;
    S016 deltaX, deltaY;

    // Get the pitch for the current display width/depth
    nvHalFbGetSurfacePitch(pDev,
                           pDev->Framebuffer.HalInfo.HorizDisplayWidth,
                           pDev->Dac.HalInfo.Depth,
                           (U032 *)&pitch);

    bpp         = (pDev->Dac.HalInfo.Depth + 1) >> 3;    // bytes per pixel
    deltaOffset = (S032)(newOffset - pVidLutCurDac->Image[buffNum].Offset);

    deltaY = (S016)(deltaOffset / pitch);                // delta in screen Y
    deltaX  = (S016)(((deltaOffset) % pitch) / bpp);     // delta in screen X

    pVidLutCurDac->Image[buffNum].DeltaX = deltaX;
    pVidLutCurDac->Image[buffNum].DeltaY = deltaY;
}

RM_STATUS class07CSetImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV07C_SET_IMAGE_OFFSET(0):
        case NV07C_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV07C_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if ((Data & 0x03) != 0)
                // The image offset must be a multiple of 4 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            // For 2D flips, determine the screen delta x,y
            if (IS_2D_BASED_FLIP(pDev, Object)) {
                class07CSetScreenDeltaXY(pDev, pVidLutCurDac, buffNum, Data);
            }

            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;

            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV07C_SET_IMAGE_FORMAT(0):
        case NV07C_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  when, multisync, flags;

            buffNum = (Offset == NV07C_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x3F) != 0)
                // the pitch must be a multiple of 64 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;

            when = DRF_VAL(07C, _SET_IMAGE_FORMAT, _WHEN, Data);
            multisync = DRF_VAL(07C, _SET_IMAGE_FORMAT, _MULTIHEAD_SYNC, Data);
            flags = DRF_VAL(07C, _SET_IMAGE_FORMAT, _FLAGS, Data);

            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV07C_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;
            pVidLutCurDac->Image[buffNum].MultiSync = multisync;

            if (when == NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
            {
                // Change the default flip functionality to end of hsync.
                DAC_FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV10, DACGETHEAD(pVidLutCurDac));
            }
            else
            {
                // Change the default flip functionality to end of vsync.
                DAC_FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA, DACGETHEAD(pVidLutCurDac));
            }

            //
            // Programming the new PCRTC_START occurs during class07CImageNotify,
            // which is called immediately in the case of a flip on hsync or as
            // part of a vblank callback on vsync flips.
            //
            if (when == NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY) {

                // This hsync flip happens on the current VBlankCounter
                pVidLutCurDac->Image[buffNum].ImageCallback.VBlankCount =
                    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter;

#ifdef  STEREO_SUPPORT
                if (pDev->pStereoParams && pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED)
                {
                    //Shouldn't ever happen because we always force waiting for VSync for stereo.
                    __asm int 3
                } else
#endif  //STEREO_SUPPORT
                    // Do the flip/notify right here.
                    class07CImageNotify(pDev, (POBJECT)pVidLutCurDac,
                                        0 /* param 1*/, buffNum,
                                        NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
            } else {
#ifdef  STEREO_SUPPORT
                U032  startAddr;

                if (pDev->pStereoParams)
                {
                    // TO DO: this is a known truncation for IA64
                    startAddr = (SIZE_PTR)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr) +
                                pVidLutCurDac->Image[buffNum].Offset;
                    pDev->pStereoParams->FlipOffsets[3][0] = startAddr;
                }
#endif  //STEREO_SUPPORT

                pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class07CImageNotify;
                pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->Image[buffNum].ImageCallback.Next   = NULL;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param1 = 0;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param2 = buffNum;
                pVidLutCurDac->Image[buffNum].ImageCallback.Status = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
                pVidLutCurDac->Image[buffNum].ImageCallback.Flags = 0;

                if (flags & NV07C_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP)
                    pVidLutCurDac->Image[buffNum].ImageCallback.Flags |= CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP;

                // Check if the other buffer is already pending ...
                if (pVidLutCurDac->Image[buffNum ^ 1].NotifyTrigger == FALSE) {
                    // No, program/notify on the next vblank
                    pVidLutCurDac->Image[buffNum].ImageCallback.VBlankCount = pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter + 1;
                } else {
                    // Yes, program/notify on the next + 1 vblank
                    pVidLutCurDac->Image[buffNum].ImageCallback.VBlankCount = pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter + 2;
                    pVidLutCurDac->Image[buffNum].ImageCallback.Flags |= CALLBACK_FLAG_SPECIFIED_VBLANK_COUNT;
                }

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->Image[buffNum].ImageCallback));
            }
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class07CSetImageValues


// This proc is called from VBlank to program the LUT.
RM_STATUS class07CProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032     *startAddr;
    U032      numEntries;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset,
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, DACGETHEAD(pVidLutCurDac), startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                myStatus,
                                NV07C_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */,
                          0 /* Data */,
                          myStatus,
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;
    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class07CSetLUTValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV07C_SET_LUT_OFFSET(0):
        case NV07C_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV07C_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if ((Data & 0x3FF) != 0)
                // The LUT offset must be a multiple of 1024 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV07C_SET_LUT_FORMAT(0):
        case NV07C_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV07C_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class07CProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class07CSetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class07CCursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                Status,
                                NV07C_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */,
                          0 /* Data */,
                          Status,
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class07CSetCursorImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetCursorImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV07C_SET_CURSOR_IMAGE_OFFSET(0):
        case NV07C_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV07C_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if ((Data & 0x3ff) != 0)
                // The cursor image offset must be a multiple of 1024 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV07C_SET_CURSOR_IMAGE_FORMAT(0):
        case NV07C_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV07C_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            pVidLutCurDac->CursorImage[buffNum].Width =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_WIDTH)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_WIDTH);
            pVidLutCurDac->CursorImage[buffNum].Height =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_HEIGHT)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_HEIGHT);
            pVidLutCurDac->CursorImage[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR);

            pVidLutCurDac->CursorImage[buffNum].NotifyAction =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY);

            // Kick off the transfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) +
                               pVidLutCurDac->CursorImage[buffNum].Offset);
            
            status = nvHalDacProgramCursorImage(pDev, 
                                           startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           pVidLutCurDac->CursorImage[buffNum].Width,
                                           pVidLutCurDac->CursorImage[buffNum].Height,
                                           pVidLutCurDac->CursorImage[buffNum].ColorFormat,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status)
            {
                pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = FALSE;
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, DACGETHEAD(pVidLutCurDac));

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class07CCursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class07CSetCursorImageValues

RM_STATUS class07CSetCursorPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetCursorPoint\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, DACGETHEAD(pVidLutCurDac),
                                      (Data & 0xffff), /* cursorX */
                                      (Data >> 16));   /* cursorY */
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CSetCursorPoint

RM_STATUS class07CSetDACValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV07C_SET_DAC_IMAGE_SIZE(0):
        case NV07C_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048.
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal Blank
        //
        case NV07C_SET_DAC_HORIZONTAL_BLANK(0):
        case NV07C_SET_DAC_HORIZONTAL_BLANK(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_HORIZONTAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 1024.
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 1024))          // width greater than 1024
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV07C_SET_DAC_HORIZONTAL_SYNC(0):
        case NV07C_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256.
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set Vertical Blank
        //
        case NV07C_SET_DAC_VERTICAL_BLANK(0):
        case NV07C_SET_DAC_VERTICAL_BLANK(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_VERTICAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 128.
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 128))   // width greater than 128
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Vertical sync
        //
        case NV07C_SET_DAC_VERTICAL_SYNC(0):
        case NV07C_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16.
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set total size.
        //
        case NV07C_SET_DAC_TOTAL_SIZE(0):
        case NV07C_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2.
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        // Set pixel clock.
        case NV07C_SET_DAC_PIXEL_CLOCK(0):
        case NV07C_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV07C_SET_DAC_FORMAT(0):
        case NV07C_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV07C_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            //Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR)pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;

            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV07C_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV07C_SET_DAC_FORMAT_COLOR);

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;

            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;

            // NOTE: the modeset parameters are copied into pDev. This will be changed when we pass the pobject as a parameter to
            // the modeset function.

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;
            pDev->Dac.HalInfo.PixelClock      = pVidLutCurDac->HalObject.Dac[buffNum].PixelClock;
            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;
                        switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
                                case NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
                                        pDev->Dac.HalInfo.Depth = 8;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
                                        break;
                                case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
                                        pDev->Dac.HalInfo.Depth = 15;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
                                        break;
                                case NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
                                        pDev->Dac.HalInfo.Depth = 16;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
                                        break;
                                case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
                                        pDev->Dac.HalInfo.Depth = 32;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
                                        break;
                        }

            pDev->Dac.PixelDepth              = pDev->Dac.HalInfo.Depth;

            //LPL: this is a per-buffer, not per-head property -- are there times it
            // will differ between buffers?  I'm assuming not.
//            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PixelDepth = pDev->Dac.HalInfo.Depth;
            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth = pDev->Dac.HalInfo.Depth;

            // Get output device...
            pVidLutCurDac->DisplayType            = (Data >> DRF_SHIFT(NV07C_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV07C_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class07c: invalid display type ", pVidLutCurDac->DisplayType);
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard             = (Data >> DRF_SHIFT(NV07C_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV07C_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class07c: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);
            
            if (pVidLutCurDac->CBase.NotifyXlate)
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                                 modeSetStatus,
                                                 NV07C_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                                  NV07C_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */,
                                  0 /* Data */,
                                  modeSetStatus,
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;

            return modeSetStatus;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class07CSetDACValues
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\class08a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_IMAGE_FROM_CPU ******************************\
*                                                                           *
* Module: CLASS08A.C                                                        *
*   This module implements the NV10_IMAGE_FROM_CPU object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c047nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class047Method_NV10(PVIDEOMETHODARG_000);
     
//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv10/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class047Method
//
// Process all class047 methods.
//
RM_STATUS class047Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV047_STOP_OVERLAY(0):
        case NV047_STOP_OVERLAY(1):
            videoStopOverlay_NV10(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV047_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV047_SET_CONTEXT_DMA_OVERLAY(0):
        case NV047_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV10 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SizeIn Invalid Height!!\r\n");
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SizeIn Invalid Height!!\r\n");
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DS_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DT_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);
			videoAdjustScalarForTV_NV10(pHalHwInfo, buffNum);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;

            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV10(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);
            videoAdjustScalarForTV_NV10(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV10(pHalHwInfo, 1);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c04dnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: C04DNV10.C                                                        *
*   This module implements the chip-dependent portion of the                *
*   NV_EXTERNAL_VIDEO_DECODER object class and its corresponding methods.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv10/mpnv10.c.
//
RM_STATUS class04DMethod_NV10(PMPMETHODARG_000);
RM_STATUS class04DGetEventStatus_NV10(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04DServiceEvent_NV10(PMPSERVICEEVENTARG_000);

#define Y_SCALE_INCR_PRECISION  10

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv10/mpnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

#if 0
static RM_STATUS class04DFindNearestScaleFactor(
    U032 dwRealDivisor,
    U032 *dwSpecialIndex
)
{
    U032 dwIndex=0;
    U032 X_ScaleFactors[] = { 1,2,3,4,6,8,12,16,24, 0xFFFF };

    //
    // Converts dwRealDivisor into an index which will point to nearest best quality divisor,
    //  will always be greater than RealDivisor if not equal
    //
    *dwSpecialIndex = 0xFFFF;
    
    while (X_ScaleFactors[dwIndex] != 0xFFFF)
    {
    	if (dwRealDivisor >= X_ScaleFactors[dwIndex])
    		*dwSpecialIndex = dwIndex;
    	dwIndex++;
    }	

    // this should never occur
    if (*dwSpecialIndex == 0xFFFF)
    	{
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04DFindNearestScaleFactor, cannot find nearest scale factor !\r\n");
    	*dwSpecialIndex = 1; // could not find index so just do a verbatim copy
        return (RM_ERROR);
    	}

    return (RM_OK);
}
#endif

// these are the weights supplied by Al Z
// they are derived from files located here:
// /home/al/proj/nv10/cmodel/video
// filb5_8.fil filc5_8.fil fild5_8.fil file5_8.fil
//  filb5_8.fil  corresponds to the b's section

static S032 VPFilterCos[5][8][5] = {
    { {0, 0, 128, 0, 0 },             // a's
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 }  },
      
    { {-14,  78,  78, -14,  0},      //  b's
      {-10,  50, 101, -20,  7},
      { -3,  25, 123, -22,  5},
      {  2,   4, 135, -19,  6},
      {  5, -11, 140, -11,  5},
      {  6, -19, 135,   4,   2},
      {  5, -22, 123,  25, -3},
      {  7, -20, 101,  50, -10} },
      
    { {-10, 74, 74, -10,  0 },     //c's
      {-13, 60, 86,  -7,  2 },
      {-11, 48, 96,   1, -6 },
      {-10, 33,101,  10, -6 },
      { -8, 20,104,  20, -8 },
      {-6,  10,101,  33, -10},
      {-6,   1, 96,  48, -11},
      {  2, -7, 86, 60, -13 }  },
      
    { { 5, 59, 59,  5,  0},       // d's
      { 4, 55, 66, 12, -9},
      {-1, 47, 68, 18, -4},
      {-3, 39, 72, 24, -4},
      {-4, 32, 72, 32, -4},
      {-4, 24, 72, 39, -3},
      {-4, 18, 68, 47, -1},
      {-9, 12, 66, 55,  4} },
      
    { {22, 42, 42, 22, 0 },    // e's
      {18, 39, 43, 24, 6 },
      {15, 37, 44, 26, 6 },
      {12, 35, 44, 29, 8 },
      {10, 32, 44, 32, 10},
      { 8, 29, 44, 35, 12},
      { 6, 26, 44, 37, 15},
      { 4, 24, 43, 39, 18}  }
   };
      
static RM_STATUS class04DProgramWeights(
    PHALHWINFO pHalHwInfo,
    U032 WidthIn,
    U032 WidthOut
)
{
    PHWREG      nvAddr = pHalHwInfo->nvBaseAddr;
    U032        scalefactor;
    U032        chunkIndex;
    U032        i;
    U032        ACos;
    U032        BCos;
    U008        dummy1;
    U008        dummy2;
    U008        dummy3;
 
    /*
     * hardware does not support upscaling
     */

    if ( WidthOut > WidthIn ) {
        return(RM_ERROR);
    }
    
    if(WidthIn == 0 ) {
        // WidthIn is used to indicate "empty" capture
        // so don't reprogram the weights...
        return (RM_OK);
    }
    
    if((WidthOut == 0) || (WidthIn == 0)) {
      scalefactor = 65536;
    } else {
      scalefactor = WidthIn * 65536 / WidthOut;
    }
    
    if( scalefactor > 163840 ) { // if( scalefactor > 2.5 * ( 1<< 16) ) 
        chunkIndex = 4;  //use e
    } 
    else if( scalefactor > 100270 ) { // else if( scalefactor > 1.53 * ( 1<< 16) ) 
        chunkIndex = 3;  //use d
    } 
    else if( scalefactor > 76677 ) { // else if( scalefactor > 1.17 * ( 1<< 16) )
        chunkIndex = 2;  //use c
    } 
    else if( scalefactor > 65536 ) { // else if( scalefactor > 1.0 * ( 1<< 16) ) 
        chunkIndex = 1;  //use b
    } 
    else {
        chunkIndex = 0;  //use a
    } 

    for(i=0;i<8;i++ ) {
        dummy1 = (U008)VPFilterCos[chunkIndex][i][0];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][1];
        dummy3 = (U008)VPFilterCos[chunkIndex][i][2];
        ACos = 
            ((((unsigned long) dummy3 ) << 16 ) & 0xFF0000 ) |
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );
        
        dummy1 = (U008)VPFilterCos[chunkIndex][i][3];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][4];
        BCos = 
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );

        REG_WR32(NV_PME_HORIZ_WGHTS_A(i),ACos);
        REG_WR32(NV_PME_HORIZ_WGHTS_B(i),BCos);
    }

    return (RM_OK);
}
        
static RM_STATUS class04DStartVbi
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr;
    V032 stateSU, stateME;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartVbi\r\n");

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure the engine is configured correctly
    //
    FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _VBI2);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetVbi[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_ANC_BUFF0_START, pDecoderHalObj->SetVbi[0].Offset
                                       + (pDecoderHalObj->SetVbi[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF0_PITCH, pDecoderHalObj->SetVbi[0].Pitch);
        REG_WR32(NV_PME_ANC_BUFF0_LENGTH, pDecoderHalObj->SetVbi[0].Pitch * pDecoderHalObj->SetVbi[0].Height);
    } 
    else
    {
        REG_WR32(NV_PME_ANC_BUFF1_START, pDecoderHalObj->SetVbi[1].Offset
                                       + (pDecoderHalObj->SetVbi[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF1_PITCH, pDecoderHalObj->SetVbi[1].Pitch);
        REG_WR32(NV_PME_ANC_BUFF1_LENGTH, pDecoderHalObj->SetVbi[1].Pitch * pDecoderHalObj->SetVbi[1].Height);
    } 
    
    //
    // Program the global VBI settings
    //
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _START_LINE, pDecoderHalObj->SetVbi[1].FirstLine);
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _NUM_LINES, pDecoderHalObj->SetVbi[1].Height);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    
    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    }

    
    return(RM_OK);
}


static RM_STATUS class04DStartImage
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr;
    V032        stateSU, stateME;
    U032        xscaleincr;
    U032        yscaleincr;
    RM_STATUS   status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage\r\n");

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure the engine is configured correctly
    //
    if( pDecoderHalObj->lastImageStartLine == 99 ) {
      // program these up the first time through only
      FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
      FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _ENABLED);
      FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _ENABLED);
    }
    
    //
    // The hardware can only support dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetImage[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Calculate the scale factors given the in & out sizes
    //
    // only update scale weights if they change..
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) 
         || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
        status = class04DProgramWeights(pHalHwInfo,
                                        pDecoderHalObj->SetImage[0].WidthIn,
                                        pDecoderHalObj->SetImage[0].WidthOut);
      
      if (status)
          return (status);
    }  
                        
    //
    // Load up the buffer location and sizes
    //
    
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_TASKA_BUFF0_START, pDecoderHalObj->SetImage[0].Offset
                                         + (pDecoderHalObj->SetImage[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[0].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF0_PITCH, pDecoderHalObj->SetImage[0].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF0_LENGTH, pDecoderHalObj->SetImage[0].Pitch * pDecoderHalObj->SetImage[0].HeightOut);
        
    }
    else
    {
        REG_WR32(NV_PME_TASKA_BUFF1_START, pDecoderHalObj->SetImage[1].Offset
                                         + (pDecoderHalObj->SetImage[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[1].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF1_PITCH, pDecoderHalObj->SetImage[1].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF1_LENGTH, pDecoderHalObj->SetImage[1].Pitch * pDecoderHalObj->SetImage[1].HeightOut);
    } 
    
    //
    // turn on scaling
    //
    if((pDecoderHalObj->lastHeightIn != pDecoderHalObj->SetImage[0].HeightIn ) || (pDecoderHalObj->lastHeightOut != pDecoderHalObj->SetImage[0].HeightOut)) {
    
      yscaleincr = ((pDecoderHalObj->SetImage[0].HeightOut << Y_SCALE_INCR_PRECISION) - 1) / 
                 (pDecoderHalObj->SetImage[0].HeightIn - 1);
      REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, yscaleincr);
      // REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, (1 << 10));
    }
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
       
      xscaleincr = (65536 );
      if((pDecoderHalObj->SetImage[0].WidthOut != 0) && (pDecoderHalObj->SetImage[0].WidthIn != 0)) {
        // protection from  zero case
        xscaleincr = (65536 * pDecoderHalObj->SetImage[0].WidthIn) / pDecoderHalObj->SetImage[0].WidthOut;
      } 
      
      REG_WR_DRF_NUM(_PME, _TASKA_X_SCALE, _INCR, xscaleincr);
      FLD_WR_DRF_DEF(_PME, _TASKA_X_SCALE, _FILTER, _ENABLE);
    }

    //
    // program data width
    //

    if ( pDecoderHalObj->ImageDataWidth != (pDecoderHalObj->lastImageConfig & 0xFF) ) {
        if ( pDecoderHalObj->ImageDataWidth == 8 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _8_BIT);
        }
        else if ( pDecoderHalObj->ImageDataWidth == 16 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _16_BIT);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFFFFFF00) | pDecoderHalObj->ImageDataWidth;
    }

    //
    // program null data checking
    //

    if ( pDecoderHalObj->NullData != ((pDecoderHalObj->lastImageConfig >> 12) & 0x3) ) {
        if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _ENABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFF) |
                                    ((pDecoderHalObj->Task & 0x1) << 8) |
                                    ((pDecoderHalObj->NullData & 0x3) << 12) |
                                    ((pDecoderHalObj->NullValue & 0x16) << 16);
    }

    //
    // Program the image startline
    //
    if(pDecoderHalObj->lastImageStartLine != pDecoderHalObj->ImageStartLine ) {
      REG_WR_DRF_NUM(_PME, _TASKA_Y_CROP, _STARTLINE, pDecoderHalObj->ImageStartLine);
    }

    //
    // program maximum line length
    //
    if(pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) {
      if( pDecoderHalObj->SetImage[Buffer].WidthOut == 0 ) {
        // write the smallest possible value of line length that is still valid
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0x4);
      } else {
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 2 * pDecoderHalObj->SetImage[0].WidthIn);
      }
    }
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD));
            
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    }
     
    pDecoderHalObj->lastWidthIn = pDecoderHalObj->SetImage[Buffer].WidthIn;
    pDecoderHalObj->lastWidthOut = pDecoderHalObj->SetImage[Buffer].WidthOut;
    pDecoderHalObj->lastHeightIn = pDecoderHalObj->SetImage[Buffer].HeightIn;
    pDecoderHalObj->lastHeightOut = pDecoderHalObj->SetImage[Buffer].HeightOut;
    pDecoderHalObj->lastImageStartLine = pDecoderHalObj->ImageStartLine;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage-end\r\n");

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DMethod_NV10(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 offset, data;
    U032 buffNum;

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04D_STOP_TRANSFER_VBI:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _DISABLED);

            //
            // Stop the current vbi data transfer immediately
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _DISABLED);

            //
            // return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            break;
        case NV04D_STOP_TRANSFER_IMAGE:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKB_NOTIFY, _DISABLED);

            //
            // Stop the current image data transfer immediately.
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 0);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);
	 
            //
            // Return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);

            //
            // Reset the checks.
            //
            pDecoderHalObj->lastWidthIn               = 0;
            pDecoderHalObj->lastWidthOut              = 0;
            pDecoderHalObj->lastHeightIn              = 0;
            pDecoderHalObj->lastHeightOut             = 0;
            //
            // this is used to indicate the first time around...
            // 99 with likely never be used at a startline value since it
            // should be something like 0 - 21  
            //
            pDecoderHalObj->lastImageStartLine        = 99;
            break;
        case NV04D_SET_IMAGE_CONFIG:
        {
            U032 tmp;

            //
            // Make sure all the fields are legal before saving them.
            //
            tmp = data & 0xFF;
            if ( (tmp == 8) || (tmp == 16) ) {
                pDecoderHalObj->ImageDataWidth = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 8) & 0x1;
            // only support TASK A for now
            if ( tmp == NV04D_SET_IMAGE_CONFIG_TASK_A ) {
                pDecoderHalObj->Task = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 12) & 0x3;
            if ( (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED) ) {
                pDecoderHalObj->NullData = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pDecoderHalObj->NullValue = (data >> 16) & 0xFFFF;
            break;
        }
        case NV04D_SET_IMAGE_START_LINE:
            //
            // Load the local copy, but don't hit the hardware
            // until we actually need it.
            //
            if (data == 0)  data = 13;
            pDecoderHalObj->ImageStartLine = data;
            break;
        case NV04D_SET_VBI_SIZE(0):
        case NV04D_SET_VBI_SIZE(1):
            buffNum = (offset == NV04D_SET_VBI_SIZE(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].FirstLine = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Height    = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_VBI_OFFSET(0):
        case NV04D_SET_VBI_OFFSET(1):
            buffNum = (offset == NV04D_SET_VBI_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Offset = data;
            break;
        case NV04D_SET_VBI_FORMAT(0):
        case NV04D_SET_VBI_FORMAT(1):
            buffNum = (offset == NV04D_SET_VBI_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetVbi[buffNum].Notify = ((data >> 24) & 0xFF);
            //
            // Kick it off!!
            //
            class04DStartVbi(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_VBI_OFFSET_NOTIFY(0):
        case NV04D_GET_VBI_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_VBI_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].GetOffsetData = REG_RD_DRF(_PME, _ANC_CURRENT, _POS);
            break;
        case NV04D_SET_IMAGE_SIZE_IN(0):
        case NV04D_SET_IMAGE_SIZE_IN(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_IN(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthIn  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightIn = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_SIZE_OUT(0):
        case NV04D_SET_IMAGE_SIZE_OUT(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_OUT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthOut  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightOut = ((data >> 16) & 0xFFFF);
            //
            // Zero here is used to indicate we want a notify that a
            // field went by but no update.
            //
            if (pDecoderHalObj->SetImage[buffNum].HeightOut == 0)
                pDecoderHalObj->SetImage[buffNum].HeightOut = 1;
            break;
        case NV04D_SET_IMAGE_OFFSET(0):
        case NV04D_SET_IMAGE_OFFSET(1):
            buffNum = (offset == NV04D_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Offset = data;
            break;
        case NV04D_SET_IMAGE_FORMAT(0):
        case NV04D_SET_IMAGE_FORMAT(1):
            buffNum = (offset == NV04D_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetImage[buffNum].Notify = ((data >> 24) & 0xFF);
            
            //
            // Kick it off
            //
            class04DStartImage(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(0):
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_IMAGE_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].GetOffsetData = REG_RD_DRF(_PME, _TASK_CURRENT, _POS);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVbiEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_VBI_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_VBI_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_VBI_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_VBI_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVbiEvents\n");

    return;
}

static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
    
	// clear the interrupt, in case another shows up!
	REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
	
    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(0))
    {
        pDecoderHalObj->SetImage[0].Info32 = 0;
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(0);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF0_START );
                pDecoderHalObj->SetImage[0].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF0_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF0));
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(1))
    {
        pDecoderHalObj->SetImage[1].Info32 = 0;
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(1);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF1_START );
                pDecoderHalObj->SetImage[1].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF1_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF1));
            }
        }
    }	

    *pEventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}

//
// class04DGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04DGetEventStatus_NV10
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending VBI/IMAGE events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // No current decoder object, so treat exception as spurious.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
        pMpGetEventStatusArg->events = 0;
        return (RM_ERROR);
    }

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING))
            GetVbiEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    }
    if (eventsPending & (CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04DServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04DServiceEvent_NV10
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    if (event == CLASS04D_VBI_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_VBI_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else
    {
        status = RM_ERR_BAD_ARGUMENT;
    }

    //
    // XXX (scottl):
    //
    // Shouldn't this be #ifdef DEBUG???
    //
    if (event == CLASS04D_VBI_EVENT(0) || event == CLASS04D_VBI_EVENT(1))
    {
        U032 error;
        // and out the rest of the bits
        error = REG_RD32(NV_PME_ANC_ME_STATE) & 0x7E00;
        if (error) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: C04DNV10: errors detected in ME register\n");
        }
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv\classcmn.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Common Class Routines ************************\
*                                                                           *
* Module: classcmn.c                                                        *
*   This module implements the common class routines referenced in the      *
*   classTable in class.c                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"

/*
 * class04D common routines
 */
RM_STATUS Commonclass04DNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DStopTransferVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DStopTransferVbi(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DStopTransferImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DStopTransferImage(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DSetContextDmaNotifies(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DSetContextDmaImage(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetContextDmaVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DSetContextDmaVbi(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetImageConfig
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetImageConfig(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetImageStartLine
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetImageStartLine(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetVbi(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04DSetImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetImage(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04DGetVbiOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DGetVbiOffsetNotify(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04DGetImageOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DGetImageOffsetNotify(pDev, Object, Method, Offset, Data));
}  

/*
 * class04E common routines
 */
RM_STATUS Commonclass04ENotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ENotify(pDev, Object, Method, Offset, Data));
}  
  
RM_STATUS Commonclass04EStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04EStopTransfer(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04ESetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ESetContextDmaNotifies(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04ESetContextDmaData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ESetContextDmaData(pDev, Object, Method, Offset, Data));
} 
 
RM_STATUS Commonclass04ESetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ESetContextDmaImage(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04EReadData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04EReadData(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass04EWriteImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04EWriteImage(pDev, Object, Method, Offset, Data));
}

/*
 * class04F common routines
 */
RM_STATUS Commonclass04FSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FSetContextDmaNotifies(pDev, Object, Method, Offset, Data));
}  
  
RM_STATUS Commonclass04FNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FNotify(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass04FStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FStopTransfer(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04FWrite
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FWrite(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04FRead
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FRead(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04FSetInterruptNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FSetInterruptNotify(pDev, Object, Method, Offset, Data));
}  

/*
 * class63 common routines
 */
RM_STATUS Commonclass63SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}  
  
RM_STATUS Commonclass63SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetNotify(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63StopTransfer(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetVideoOutput(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63SetImageCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetImageCtxDma(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63ImageScan
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63ImageScan(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass63GetOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    return(class63GetOffsetNotify(pDev, Object, Method, Offset, Data));
}    

/*
 * class64 common routines
 */
RM_STATUS Commonclass64SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetNotify(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetVideoOutput(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetVideoInput(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetDeltaDuDx
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetDeltaDuDx(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetDeltaDvDy
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetDeltaDvDy(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetPoint
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetPoint(pDev, Object, Method, Offset, Data));
}  

/*
 * class65 common routines
 */
RM_STATUS Commonclass65SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass65SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetVideoOutput(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetVideoInput(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetColorFormat
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetColorFormat(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetColorKey(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetPoint
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetPoint(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetSize
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetSize(pDev, Object, Method, Offset, Data));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c04env10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DO_INTERRUPT_TIMING
U032 timePrev = 0;
#endif

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv10/mpnv10.c.
//
RM_STATUS class04EMethod_NV10(PMPMETHODARG_000);
RM_STATUS class04EGetEventStatus_NV10(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04EServiceEvent_NV10(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv10/mpnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04EStartRead(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING) ) {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartRead couldn't reset interrupt!\n");
		DBG_BREAKPOINT();
    }
#endif

    //
    // Make sure the engine is configured correctly 
    //
    FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
	//
	// XXX for now we only support transfers out framebuffer memory
    //
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT_SYSMEM, _DISABLED);
	if (Buffer == 0)
	{
		REG_WR32(NV_PME_FOUT_BUFF0_START, pDecompHalObj->ReadData[0].Offset
										+ (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
	} 
	else
	{
		REG_WR32(NV_PME_FOUT_BUFF1_START, pDecompHalObj->ReadData[1].Offset
										+ (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
	} 
							
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    }

	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _ENABLED);

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04EMethod_NV10(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 offset, data;
    U032 buffNum;

    pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04E_STOP_TRANSFER:
            //
            // Stop the current data transfer immediately.
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            break;
        case NV04E_SET_DATA_OFFSET(0):
        case NV04E_SET_DATA_OFFSET(1):
            buffNum = (offset == NV04E_SET_DATA_OFFSET(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Offset = data;
            break;
        case NV04E_SET_DATA_LENGTH(0):
        case NV04E_SET_DATA_LENGTH(1):
            buffNum = (offset == NV04E_SET_DATA_LENGTH(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Size = data;
            break;
        case NV04E_SET_DATA_NOTIFY(0):
        case NV04E_SET_DATA_NOTIFY(1):
            buffNum = (offset == NV04E_SET_DATA_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Notify = data;
            //
            // KICK IT OFF!!
            //
            class04EStartRead(pHalHwInfo, pDecompHalObj, buffNum);
            break;
        case NV04E_SET_IMAGE_FORMAT_IN(0):
        case NV04E_SET_IMAGE_FORMAT_IN(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_IN(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatIn = data;
            break;
        case NV04E_SET_IMAGE_SIZE(0):
        case NV04E_SET_IMAGE_SIZE(1):
            buffNum = (offset == NV04E_SET_IMAGE_SIZE(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Size = data;
            break;
        case NV04E_SET_IMAGE_OFFSET_OUT(0):
        case NV04E_SET_IMAGE_OFFSET_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_OFFSET_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Offset = data;
            break;
        case NV04E_SET_IMAGE_FORMAT_OUT(0):
        case NV04E_SET_IMAGE_FORMAT_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatOut = data;
            break;
        case NV04E_SET_IMAGE_NOTIFY(0):
        case NV04E_SET_IMAGE_NOTIFY(1):
            buffNum = (offset == NV04E_SET_IMAGE_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Notify = data;
            //
            // NOT SUPPORTED!!
            //
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
}


//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVideoEvents(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));

    // buffer 0
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVideoEvents\n");

    return;
}


#if 0
static VOID GetImageEvents(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    //
    // Not supported!!!
    //
    *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));

    return ;
}
#endif

//
// class04EGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04EGetEventStatus_NV10(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending events.
    //
    if (!(intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING)))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // Setup HAL object pointer.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
        pDecompHalObj = NULL;
    else
        pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING))
            GetVideoEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    }
    if (eventsPending & (CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1)))
    {
        //
        // Not supported!
        //if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
        //    GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        //else
            eventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04EServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04EServiceEvent_NV10
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04E_VIDEO_EVENT(0):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_VIDEO_EVENT(1):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(0):
        case CLASS04E_AUDIO_EVENT(1):
        case CLASS04E_IMAGE_EVENT(0):
        case CLASS04E_IMAGE_EVENT(1):
            //
            // These events aren't supported on nv10.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class04EServiceEvent; bogus event type ", event);
            DBG_BREAKPOINT();
            break;
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c64nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER object class and its         *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class64Method_NV10(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class64Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class64Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOSCALERHALOBJECT pVidScalerHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF7_SET_DELTA_DU_DX(0):
            pVidScalerHalObj->DeltaDuDx = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleX = videoConvertScaleFactor_NV10(data);
            break;
        case NVFF7_SET_DELTA_DV_DY(0):
            pVidScalerHalObj->DeltaDvDy = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleY = videoConvertScaleFactor_NV10(data);
            break;
        case NVFF7_SET_POINT(0):
            pVidScalerHalObj->xStart = (data & 0xffff);
            pVidScalerHalObj->yStart = (data >> 16);
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidScalerHalObj->xStart) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidScalerHalObj->yStart);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c04fnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: CLASS04F.C                                                        *
*   This module implements the NV_EXTERNAL_PARALLEL_BUS object              *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv10/mpnv10.c.
//
RM_STATUS class04FMethod_NV10(PMPMETHODARG_000);
RM_STATUS class04FGetEventStatus_NV10(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04FServiceEvent_NV10(PMPSERVICEEVENTARG_000);

#define	VIPREG_TIMEOUT_CNT	1000		// XXX arbitrary

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv10/mpnv10.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FMethod_NV10
(
    PMPMETHODARG_000 pMpMethodArg
)
{
    PPARALLELBUSHALOBJECT pPBusHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pPBusHalObj = (PPARALLELBUSHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04F_STOP_TRANSFER:
            //
            // Stop either read or write
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        case NV04F_WRITE_SIZE:
            pPBusHalObj->Write.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Write.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Write.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Write.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_WRITE_ADDRESS:
            pPBusHalObj->Write.Address = data;
            break;
        case NV04F_WRITE_DATA:
        {
            U032 vipCtrl, cnt;

            pPBusHalObj->Write.Data = data;

            //
            // Make sure there isn't a write pending
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_WRITE_DATA state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _PENDING) );

            //
            // Do the write now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Write.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Write.Address & 0x0000FFFF));
            REG_WR32(NV_PME_VIPREG_DATA, pPBusHalObj->Write.Data);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _START);
            break;
        }
        case NV04F_READ_SIZE:
            pPBusHalObj->Read.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Read.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Read.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Read.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_READ_ADDRESS:
            pPBusHalObj->Read.Address = data;
            break;
        case NV04F_READ_GET_DATA_NOTIFY:
        {
            U032 vipCtrl, cnt, data32;
            
            pPBusHalObj->Read.Notify = data;

            //
            // Make sure there isn't a read pending.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_READ_GET_DATA_NOTIFY state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            //
            // Do the read now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Read.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Read.Address & 0x0000FFFF));
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _START);
            
            //
            // Wait for the read to complete.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                    return(RM_ERROR);
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            data32 = REG_RD32(NV_PME_VIPREG_DATA);

            //
            // Save data off so that RM can return it via the notify.
            //
            pPBusHalObj->Read.ReadData = data32;
            break;
        }
        case NV04F_SET_INTERRUPT_NOTIFY:
            //
            // Make sure the interrupt is enabled
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _ENABLED);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

RM_STATUS class04FGetEventStatus_NV10
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    intr0 = REG_RD32(NV_PME_INTR_0);

    // XXX not final (need to finish porting class04F to NV10)

    //
    // Let RM know we've got a pbus event pending.
    //
    if (intr0 & DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _PENDING))
    {
        pMpGetEventStatusArg->events = CLASS04F_PBUS_EVENT;
    }
    else
    {
        pMpGetEventStatusArg->events = 0;
    }

    //
    // This value is given back in the service routine so we know
    // which exceptions we are to clear.
    //
    pMpGetEventStatusArg->intrStatus = intr0;

    return RM_OK;
}

RM_STATUS class04FServiceEvent_NV10
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The intrStatus value was saved off in GetEventStatus.
    //
    if (pMpServiceEventArg->event != CLASS04F_PBUS_EVENT)
    {
        pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
        return RM_ERR_BAD_ARGUMENT;
    }

    //
    // Clear the interrupt
    //
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _RESET));

    //
    // This is a single-shot notify.  Disable the interrupt.
    //
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _DISABLED);

    //
    // Clear state in exception data structure.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c047nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class047Method_NV20(PVIDEOMETHODARG_000);
     
//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class047Method
//
// Process all class047 methods.
//
RM_STATUS class047Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV047_STOP_OVERLAY(0):
        case NV047_STOP_OVERLAY(1):
            videoStopOverlay_NV20(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV047_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV047_SET_CONTEXT_DMA_OVERLAY(0):
        case NV047_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV20 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SizeIn Invalid Height!!\r\n");
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SizeIn Invalid Height!!\r\n");
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DS_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DT_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);
			videoAdjustScalarForTV_NV20(pHalHwInfo, buffNum);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV20(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);
            videoAdjustScalarForTV_NV20(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV20(pHalHwInfo, 1);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c65nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class65Method_NV10(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class65Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class65Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF6_SET_COLOR_FORMAT(0):
            pVidColorKeyHalObj->ColorFormat = data;
            pHalHwInfo->pVideoHalInfo->VideoColorFormat = data;
            break;
        case NVFF6_SET_COLOR_KEY(0):
            pVidColorKeyHalObj->Color = data;
            pHalHwInfo->pVideoHalInfo->VideoColor = data;
            if (data)
            {
                switch (pVidColorKeyHalObj->ColorFormat)
                {
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0x7FFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
                    case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFFFF);
                        break;
                    default:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data);
                        break;
                }
            }
            break;
        case NVFF6_SET_POINT(0):
            pVidColorKeyHalObj->xClipMin = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMin = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMin) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMin);
            break;
        case NVFF6_SET_SIZE(0):
            pVidColorKeyHalObj->xClipMax = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMax = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoSize =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMax) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMax);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c07anv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: C07ANV10.C                                                        *
*   This module implements the NV10_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class07aMethod_NV10(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv10/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class07aMethod
//
// Process all class07a methods.
//
RM_STATUS class07aMethod_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV07A_STOP_OVERLAY(0):
        case NV07A_STOP_OVERLAY(1):
            videoStopOverlay_NV10(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV07A_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV07A_SET_CONTEXT_DMA_OVERLAY(0):
        case NV07A_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV07A_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE(0):
        case NV07A_SET_OVERLAY_LUMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_LUMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_LUMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE(0):
        case NV07A_SET_OVERLAY_CHROMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_CHROMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_CHROMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_COLORKEY(0):
        case NV07A_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV10 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV07A_SET_OVERLAY_OFFSET(0):
        case NV07A_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_IN(0):
        case NV07A_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Check for overflow and limit if necessary
            if ((data & 0xFFFF) > 0x7fe) {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Overlay Warning! Width Overflow.\n\r");
                data = (data & 0xffff0000) | 0x7fe;
            }
            if ((data >> 16) > 0x7fe) {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Overlay Warning! Height Overflow.\n\r");
                data = (data & 0xffff) | 0x7fe0000;
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASizeIn Invalid Height!!\r\n");
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASizeIn Invalid Height!!\r\n");
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_IN(0):
        case NV07A_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DU_DX(0):
        case NV07A_SET_OVERLAY_DU_DX(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DU_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DV_DY(0):
        case NV07A_SET_OVERLAY_DV_DY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DV_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT(0):
        case NV07A_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // save a softcopy of the POINT_OUT values
            pOverlayHalObj->Overlay[buffNum].PointOut_x = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _X, data));

            pOverlayHalObj->Overlay[buffNum].PointOut_y = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _Y, data));

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);
			videoAdjustScalarForTV_NV10(pHalHwInfo, buffNum);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_OUT(0):
        case NV07A_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_FORMAT(0):
        case NV07A_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV10(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);

            // save a softcopy of the POINT_OUT values for both buffers
            pOverlayHalObj->Overlay[0].PointOut_x = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _X, data));

            pOverlayHalObj->Overlay[0].PointOut_y = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _Y, data));

            pOverlayHalObj->Overlay[1].PointOut_x = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _X, data));

            pOverlayHalObj->Overlay[1].PointOut_y = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _Y, data));

            videoAdjustScalarForTV_NV10(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV10(pHalHwInfo, 1);
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_LUMINANCE(0), data);
            REG_WR32(NV_PVIDEO_LUMINANCE(1), data);
            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_CHROMINANCE(0), data);
            REG_WR32(NV_PVIDEO_CHROMINANCE(1), data);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv10\c63nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDFRMEM.C                                                        *
*   This module implements the NV_VIDEO_FROM_MEMORY object class and its    *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DEBUG_TIMING

#define DBG_PRINT_TIME(s,v) DBG_PRINT_STRING_VALUE(0x10, s, v);
U032 time0hi=0, time0lo=0, time1hi=0, time1lo=0;

#endif // DEBUG_TIMING

//
// We can't quite use the DRF macros due to how they concatenate strings
// to create field accesses and do some bit shifting ... these are only
// used for NV_PVIDEO_FORMAT updates
//
#define VIDEO_FORMAT_FLD_WR_DEF(buf, fld, def)                                                  \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                     \
                (DRF_MASK(NV_PVIDEO_FORMAT ## fld) << DRF_SHIFT(NV_PVIDEO_FORMAT ## fld))) |    \
                DRF_DEF(_PVIDEO, _FORMAT, fld, def))

#define VIDEO_FORMAT_FLD_WR_PITCH(buf, val)                                                       \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                       \
                (DRF_MASK(NV_PVIDEO_FORMAT_PITCH) << DRF_SHIFT(NV_PVIDEO_FORMAT_PITCH))) | val)

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class63Method_NV10(PVIDEOMETHODARG_000);
RM_STATUS class63InitXfer_NV10(PHALHWINFO, VOID *, U032);
VOID class63DualSurfaceDesktop_NV10(PHALHWINFO, U032);

//
// Statics
//
static RM_STATUS class63StartXfer_NV10(PHALHWINFO, VOID *, U032);
static VOID class63DualSurface_NV10(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);
static VOID class63ColorKey_NV10(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv10/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class63Method
//
// This routine performs any chip-specific handling for all class63
// methods.
//
RM_STATUS class63Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF8_STOP_TRANSFER(0):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
            {
                // activate a PVIDEO_STOP and disappear the window by
                // setting SIZE_OUT to 0
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StopTransfer: set STOP_ACTIVE/IMMEDIATELY\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     PVIDEO BUFFER ", REG_RD32(NV_PVIDEO_BUFFER));
                REG_WR32(NV_PVIDEO_STOP,
                         DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                         DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            }
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV10;
            break;
        case NVFF8_IMAGE_SCAN_NOTIFY(0,0):
        case NVFF8_IMAGE_SCAN_NOTIFY(0,1):
            buffNum = (offset == NVFF8_IMAGE_SCAN_NOTIFY(0,0)) ? 0 : 1;
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurface_NV10(pHalHwInfo, pVidFromMemHalObj, buffNum);
            return pVidFromMemHalObj->KickOffProc(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

static VOID class63ColorKey_NV10
(
    PHALHWINFO pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj,
    U032 buffNum
)
{
    U032 color, colorFormat;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    color = pVidFromMemHalObj->Buffer[buffNum].VideoColor;
    colorFormat = pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat;

    //
    // Set the hardware to the specified color.
    //
    if (color)
    {
        switch (colorFormat)
        {
            case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
            case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFF);
                break;
            
            case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0x7FFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
            case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
            case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
            case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFFFF);
                break; 
                
            default:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color);
                break; 
        }
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _COLOR_KEY_EQUAL);
    } 
    else
    {
        // XXX does this do it??
        REG_WR32(NV_PVIDEO_COLOR_KEY, NV_PVIDEO_COLOR_KEY_VALUE_DONT_CARE);
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _ALWAYS);
    }
}

//
//      Program the video scalar to scan out the video to the TV encoder.
//
static VOID class63DualSurface_NV10(PHALHWINFO pHalHwInfo, PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj, U032 buffNum)

{
    U032    pitch0, pitch1, vbs, vbe, hbs, hbe, hw;
    U032    length, width, pitch, height;
    int     step_x, step_y;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Class63 has set up the scalar to render into a window, but we'll
    // change it to render to the full TV screen.
    // This means getting the source buffer size and scaling up to the
    // current resolution.
    //

    // get the width and height of the video object
    // height = length/width
    // step x = ((src_width -1) << 11) / (dest_width -1 )
    // step y = ((src_height -1) << 11) / (dest_height - 1)
    length = pVidFromMemHalObj->Buffer[buffNum].Length;
    pitch  = pVidFromMemHalObj->Buffer[buffNum].Pitch;
    width  = pVidFromMemHalObj->Buffer[buffNum].Width;
    if (width != 0) // we'll get objects with size 0
    {
        height = length/width;
        // XXX for now we'll leave it at masking 12 bits
        step_x = (((width - 1) << 11) / (pHalHwInfo->pFbHalInfo->HorizDisplayWidth - 1)) & 0xfff;
        step_y = (((height - 1) << 11) / (pHalHwInfo->pFbHalInfo->VertDisplayWidth - 1)) & 0xfff;
    }
    else
        return;

    // We have a valid video object
                    
    // find screen size
    if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
    {
        // doubled modes
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
    }
    else                                                            
    {
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
    }
    pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;

    // set up timing default values (640x480)
    vbs   = 0x00000240;
    vbe   = 0x0000005c;
    hbs   = 0x00000300;
    hbe   = 0x00000050;
        
    // adjust horizontal and vertical position/size
    // low-res modes don't quite use the same timings as their doubles
    switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
    {
        case 200:     // 320x200x16
            hbs   = 0x00000308;
            hbe   = 0x00000068;
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 240:     // 320x240x16
            hbs   = 0x00000308;
            hbe   = 0x00000050;
            break;             
        case 300:     // 400x300x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003d0;
            hbe   = 0x00000088;
            break;             
        case 384:     // 512x384x16
            vbs   = 0x00000230;
            vbe   = 0x00000080;
            hbs   = 0x00000290;
            hbe   = 0x00000090;
            break;             
        case 400:     // 640x400x16
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 480:     // 640x480x16
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            break;
        case 600:     // 800x600x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003a8;
            hbe   = 0x00000088;
            break;
        default:
            break;
    }            
    vbe--;
        
    // Output timing
    REG_WR32(NV_PRAMDAC_TV_VBLANK_START, vbs);   
    REG_WR32(NV_PRAMDAC_TV_VBLANK_END, vbe);    
    REG_WR32(NV_PRAMDAC_TV_HBLANK_START, hbs);     
    REG_WR32(NV_PRAMDAC_TV_HBLANK_END, hbe);    

    // Video scalar
    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
    REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(1), step_y);
    //WritePriv32(scale, NV_PVIDEO_STEP_SIZE);        // scale factor 1:1

    VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);
    //WritePriv32(pitch0, NV_PVIDEO_BUFF0_PITCH);     // pitch buffer 0

    VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);
    //WritePriv32(pitch1, NV_PVIDEO_BUFF1_PITCH);     // pitch buffer 1

    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
    REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);
    //WritePriv32(hw, NV_PVIDEO_WINDOW_SIZE);         // h (26:16), w (10:0)
}


//****************************************************************************************
//
//      Program the video scalar to scan out the framebuffer (desktop) to the TV encoder.
//      Or, turn off the video scalar for TV only or monitor.
VOID class63DualSurfaceDesktop_NV10(PHALHWINFO pHalHwInfo, U032 mode)
{
    U032 coeff=0, setup=0, vbs=0, vbe=0, hbs=0, hbe=0, start_buf0=0, start_buf1=0;
    U032 pitch0=0, pitch1=0, xy_pos=0, hw=0;
    U032 step_x=0, step_y=0;
    U032 fifo0, fifo1, reg32;
    int dualSurface = 0;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    switch (mode)
    {
        case DISPLAY_TYPE_MONITOR:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
            break;
        case DISPLAY_TYPE_TV:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER;
            break;

        case DISPLAY_TYPE_DUALSURFACE:
            dualSurface = 1;
        
            start_buf0 = 0;     // desktop starts at 0
            start_buf1 = 0;
            if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
            {
                // doubled modes
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY) >> 1; // 2:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY) >> 1; // 2:1
                //scale = 0x04000400;     // 2:1
            }
            else                                                            
            {
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY);      // 1:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY);      // 1:1
                //scale = 0x08000800;     // 1:1
            }
            pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;
            // set up timing default values (640x480)
            coeff = 0x10700;
            setup = 0x00001111;     // 565 pixel data, use second surface
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            xy_pos = 0;
            fifo0 = 0x20;           // watermark
            fifo1 = 0x03;
                
            // adjust horizontal and vertical position/size
            // low-res modes don't quite use the same timings as their doubles
            switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
            {
                case 200:     // 320x200x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000068;
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 240:     // 320x240x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000050;
                    break;             
                case 300:     // 400x300x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003d0;
                    hbe   = 0x00000088;
                    break;             
                case 384:     // 512x384x16
                    vbs   = 0x00000230;
                    vbe   = 0x00000080;
                    hbs   = 0x00000290;
                    hbe   = 0x00000090;
                    break;             
                case 400:     // 640x400x16
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 480:     // 640x480x16
                    vbs   = 0x00000240;
                    vbe   = 0x0000005c;
                    hbs   = 0x00000300;
                    hbe   = 0x00000050;
                    break;
                case 600:     // 800x600x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003a8;
                    hbe   = 0x00000088;
                    break;
                default:
                    dualSurface = 0;
                    break;
            }            
            break;
    }

    if (dualSurface)    // DualSurface requested and its a valid mode
    {
        // XXX idle everything??
        REG_WR32(NV_PVIDEO_BUFFER, 0);

        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, coeff);   
        REG_WR32(NV_PRAMDAC_TV_SETUP        , setup);          
        REG_WR32(NV_PRAMDAC_TV_VBLANK_START , vbs);   
        REG_WR32(NV_PRAMDAC_TV_VBLANK_END   , vbe);    
        REG_WR32(NV_PRAMDAC_TV_HBLANK_START , hbs);     
        REG_WR32(NV_PRAMDAC_TV_HBLANK_END   , hbe);    

        // Video scalar
        REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
        REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(1), step_y);

        VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);

        VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
        REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);

#if 0 
        // could set this, but for now lets just use the defaults
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo0);
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo1);
        //WritePriv32(fifo0, NV_PVIDEO_FIFO_THRES);       // fifo fill threshold
        //WritePriv32(fifo1, NV_PVIDEO_FIFO_BURST);       // fifo burst length
#endif

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_POINT_OUT(0), xy_pos);
        REG_WR32(NV_PVIDEO_POINT_OUT(1), xy_pos);
        videoAdjustScalarForTV_NV10(pHalHwInfo, 0);
        videoAdjustScalarForTV_NV10(pHalHwInfo, 1);
        //WritePriv32(xy_pos, NV_PVIDEO_WINDOW_START);    // x,y position within buffer (start display here)

        REG_WR32(NV_PVIDEO_OFFSET(0), start_buf0);
        //WritePriv32(start_buf0, NV_PVIDEO_BUFF0_START); // start address buffer 0

        REG_WR32(NV_PVIDEO_OFFSET(1), start_buf1);
        //WritePriv32(start_buf1, NV_PVIDEO_BUFF1_START); // start address buffer 1
            
        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE);  // enable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);  // enable scalar

        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8); // set format
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);  // set format

        // switch to buffer 0, which will force the scalar to load new values
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
#if 0
        reg32 = REG_RD32(NV_PVIDEO_SU_STATE);
        ////reg32 = ReadPriv32(NV_PVIDEO_SU_STATE);
        reg32 &= ~0x00010000; // NV_PVIDEO_SU_STATE_BUFF0_IN_USE = 0
        REG_WR32(NV_PVIDEO_SU_STATE, reg32); // clear BUFF0_IN_USE
        //WritePriv32(reg32, NV_PVIDEO_SU_STATE); // clear BUFF0_IN_USE
#endif
    }    
    else    // need to set up for either TV only or Monitor only
    {

        reg32 = REG_RD32(NV_PRAMDAC_TV_SETUP);
        //reg32 = ReadPriv32(NV_PRAMDAC_TV_SETUP);
        reg32 &= NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
        reg32 |= setup;
        REG_WR32(0x680700, setup);   // TV SETUP
        //WritePriv32(setup, 0x680700);   // TV SETUP

        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);  // disable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);  // disable scalar
    }
}

//---------------------------------------------------------------------------
//
//  Buffer transfer routines.
//
//---------------------------------------------------------------------------

RM_STATUS class63InitXfer_NV10
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    RM_STATUS       status = RM_OK;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63InitXfer\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV10(pHalHwInfo, NV_VIDEO_FROM_MEMORY);

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_CR8YB8CB8YA8);
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8);

    pVidFromMemHalObj->KickOffProc = class63StartXfer_NV10;

    status = class63StartXfer_NV10(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);

    return (status);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class63StartXfer_NV10
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    RM_STATUS status = RM_OK;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StartXfer\r\n");

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // XXX (scottl):
    // I've made a *MAJOR* assumption here that we do not use the BBufferXfer
    // proc to handle RGB video.  In looking at the transfer method in 
    // in class63.c (formally c63nv10.c), it looks like it's entirely
    // vblank driven.  By making this assumption, I'm able to avoid having
    // vblank info in the HAL.
    //
#ifdef DEBUG
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class63StartXfer: format is RGB!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // VideoStart, VideoSize and VideoScale are not double buffered.
    // So copy the values into the Buff0 versions to simulate true
    // double buffering.
    //
    pVidFromMemHalObj->Buffer[buffNum].VideoStart = pHalHwInfo->pVideoHalInfo->VideoStart;
    pVidFromMemHalObj->Buffer[buffNum].VideoSize = pHalHwInfo->pVideoHalInfo->VideoSize;
    pVidFromMemHalObj->Buffer[buffNum].VideoScale = pHalHwInfo->pVideoHalInfo->VideoScale;
    pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat = pHalHwInfo->pVideoHalInfo->VideoColorFormat;
    pVidFromMemHalObj->Buffer[buffNum].VideoColor = pHalHwInfo->pVideoHalInfo->VideoColor;

    //
    // Mark the buffer as BUSY. That is all we do here. The hardware
    // registers are programmed in videoService after the current buffer
    // completion.
    //
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_BUSY;

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_CR8YB8CB8YA8);
    }
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_YB8CR8YA8CB8);
    }

    // Write the offset straight away (must be 64byte aligned). If any of the low order
    // 6 bits are set from ImageScan.offset, we'll divide by 2 to convert bytes to texels
    // and shift this value by 4 to get into the integer portion of POINT_IN_S.
    REG_WR32(NV_PVIDEO_OFFSET(buffNum), pVidFromMemHalObj->Buffer[buffNum].Start);
    REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
             (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_S) << DRF_SHIFT(NV_PVIDEO_POINT_IN_S))) |
             DRF_NUM(_PVIDEO, _POINT, _IN_S, ((pVidFromMemHalObj->Buffer[buffNum].Start & 0x3F) >> 1) << 4));

    // Set the pitch (must be 64byte aligned).
    // If the LSB's are 0x2 then we're doing a bob and POINT_IN_T needs to be -1/2.
    //
    VIDEO_FORMAT_FLD_WR_PITCH(buffNum, pVidFromMemHalObj->Buffer[buffNum].Pitch);
    if ((pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x3) == 0x2)
    {
        REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
                 (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_T) << DRF_SHIFT(NV_PVIDEO_POINT_IN_T))) |
                 DRF_NUM(_PVIDEO, _POINT, _IN_T, (0xFFF8 >> 1)));
    }

    REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoStart);
    videoAdjustScalarForTV_NV10(pHalHwInfo, buffNum);
    REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoSize);
    REG_WR32(NV_PVIDEO_DS_DX(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleX);
    REG_WR32(NV_PVIDEO_DT_DY(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleY);

    class63ColorKey_NV10(pHalHwInfo, pVidFromMemHalObj, buffNum);

    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;

    // HW now owns the buffer
    if (buffNum == 0)
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _SET);

#ifdef DEBUG_TIMING
    if (buffNum == 0)
        vmmOutDebugString("\n0B");
    else
        vmmOutDebugString("\n1B");
#endif
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c04dnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: C04DNV20.C                                                        *
*   This module implements the chip-dependent portion of the                *
*   NV_EXTERNAL_VIDEO_DECODER object class and its corresponding methods.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv20/mpnv20.c.
//
RM_STATUS class04DMethod_NV20(PMPMETHODARG_000);
RM_STATUS class04DGetEventStatus_NV20(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04DServiceEvent_NV20(PMPSERVICEEVENTARG_000);

#define Y_SCALE_INCR_PRECISION  10

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv20/mpnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

#if 0
static RM_STATUS class04DFindNearestScaleFactor(
    U032 dwRealDivisor,
    U032 *dwSpecialIndex
)
{
    U032 dwIndex=0;
    U032 X_ScaleFactors[] = { 1,2,3,4,6,8,12,16,24, 0xFFFF };

    //
    // Converts dwRealDivisor into an index which will point to nearest best quality divisor,
    //  will always be greater than RealDivisor if not equal
    //
    *dwSpecialIndex = 0xFFFF;
    
    while (X_ScaleFactors[dwIndex] != 0xFFFF)
    {
    	if (dwRealDivisor >= X_ScaleFactors[dwIndex])
    		*dwSpecialIndex = dwIndex;
    	dwIndex++;
    }	

    // this should never occur
    if (*dwSpecialIndex == 0xFFFF)
    	{
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04DFindNearestScaleFactor, cannot find nearest scale factor !\r\n");
    	*dwSpecialIndex = 1; // could not find index so just do a verbatim copy
        return (RM_ERROR);
    	}

    return (RM_OK);
}
#endif

// these are the weights supplied by Al Z
// they are derived from files located here:
// /home/al/proj/nv10/cmodel/video
// filb5_8.fil filc5_8.fil fild5_8.fil file5_8.fil
//  filb5_8.fil  corresponds to the b's section

static S032 VPFilterCos[5][8][5] = {
    { {0, 0, 128, 0, 0 },             // a's
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 }  },
      
    { {-14,  78,  78, -14,  0},      //  b's
      {-10,  50, 101, -20,  7},
      { -3,  25, 123, -22,  5},
      {  2,   4, 135, -19,  6},
      {  5, -11, 140, -11,  5},
      {  6, -19, 135,   4,   2},
      {  5, -22, 123,  25, -3},
      {  7, -20, 101,  50, -10} },
      
    { {-10, 74, 74, -10,  0 },     //c's
      {-13, 60, 86,  -7,  2 },
      {-11, 48, 96,   1, -6 },
      {-10, 33,101,  10, -6 },
      { -8, 20,104,  20, -8 },
      {-6,  10,101,  33, -10},
      {-6,   1, 96,  48, -11},
      {  2, -7, 86, 60, -13 }  },
      
    { { 5, 59, 59,  5,  0},       // d's
      { 4, 55, 66, 12, -9},
      {-1, 47, 68, 18, -4},
      {-3, 39, 72, 24, -4},
      {-4, 32, 72, 32, -4},
      {-4, 24, 72, 39, -3},
      {-4, 18, 68, 47, -1},
      {-9, 12, 66, 55,  4} },
      
    { {22, 42, 42, 22, 0 },    // e's
      {18, 39, 43, 24, 6 },
      {15, 37, 44, 26, 6 },
      {12, 35, 44, 29, 8 },
      {10, 32, 44, 32, 10},
      { 8, 29, 44, 35, 12},
      { 6, 26, 44, 37, 15},
      { 4, 24, 43, 39, 18}  }
   };
      
static RM_STATUS class04DProgramWeights(
    PHALHWINFO pHalHwInfo,
    U032 WidthIn,
    U032 WidthOut
)
{
    PHWREG      nvAddr = pHalHwInfo->nvBaseAddr;
    U032        scalefactor;
    U032        chunkIndex;
    U032        i;
    U032        ACos;
    U032        BCos;
    U008        dummy1;
    U008        dummy2;
    U008        dummy3;
 
    /*
     * hardware does not support upscaling
     */

    if ( WidthOut > WidthIn ) {
        return(RM_ERROR);
    }
    
    if(WidthIn == 0 ) {
        // WidthIn is used to indicate "empty" capture
        // so don't reprogram the weights...
        return (RM_OK);
    }
    
    if((WidthOut == 0) || (WidthIn == 0)) {
      scalefactor = 65536;
    } else {
      scalefactor = WidthIn * 65536 / WidthOut;
    }
    
    if( scalefactor > 163840 ) { // if( scalefactor > 2.5 * ( 1<< 16) ) 
        chunkIndex = 4;  //use e
    } 
    else if( scalefactor > 100270 ) { // else if( scalefactor > 1.53 * ( 1<< 16) ) 
        chunkIndex = 3;  //use d
    } 
    else if( scalefactor > 76677 ) { // else if( scalefactor > 1.17 * ( 1<< 16) )
        chunkIndex = 2;  //use c
    } 
    else if( scalefactor > 65536 ) { // else if( scalefactor > 1.0 * ( 1<< 16) ) 
        chunkIndex = 1;  //use b
    } 
    else {
        chunkIndex = 0;  //use a
    } 

    for(i=0;i<8;i++ ) {
        dummy1 = (U008)VPFilterCos[chunkIndex][i][0];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][1];
        dummy3 = (U008)VPFilterCos[chunkIndex][i][2];
        ACos = 
            ((((unsigned long) dummy3 ) << 16 ) & 0xFF0000 ) |
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );
        
        dummy1 = (U008)VPFilterCos[chunkIndex][i][3];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][4];
        BCos = 
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );

        REG_WR32(NV_PME_HORIZ_WGHTS_A(i),ACos);
        REG_WR32(NV_PME_HORIZ_WGHTS_B(i),BCos);
    }

    return (RM_OK);
}
        
static RM_STATUS class04DStartVbi
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr;
    V032 stateSU, stateME;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartVbi\r\n");

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure the engine is configured correctly
    //
    FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _VBI2);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetVbi[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_ANC_BUFF0_START, pDecoderHalObj->SetVbi[0].Offset
                                       + (pDecoderHalObj->SetVbi[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF0_PITCH, pDecoderHalObj->SetVbi[0].Pitch);
        REG_WR32(NV_PME_ANC_BUFF0_LENGTH, pDecoderHalObj->SetVbi[0].Pitch * pDecoderHalObj->SetVbi[0].Height);
    } 
    else
    {
        REG_WR32(NV_PME_ANC_BUFF1_START, pDecoderHalObj->SetVbi[1].Offset
                                       + (pDecoderHalObj->SetVbi[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF1_PITCH, pDecoderHalObj->SetVbi[1].Pitch);
        REG_WR32(NV_PME_ANC_BUFF1_LENGTH, pDecoderHalObj->SetVbi[1].Pitch * pDecoderHalObj->SetVbi[1].Height);
    } 
    
    //
    // Program the global VBI settings
    //
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _START_LINE, pDecoderHalObj->SetVbi[1].FirstLine);
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _NUM_LINES, pDecoderHalObj->SetVbi[1].Height);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    
    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    }

    
    return(RM_OK);
}


static RM_STATUS class04DStartImage
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr;
    V032        stateSU, stateME;
    U032        xscaleincr;
    U032        yscaleincr;
    RM_STATUS   status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage\r\n");

    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Make sure the engine is configured correctly
    //
    if( pDecoderHalObj->lastImageStartLine == 99 ) {
      // program these up the first time through only
      FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
      FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _ENABLED);
      FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _ENABLED);
    }
    
    //
    // The hardware can only support dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetImage[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Calculate the scale factors given the in & out sizes
    //
    // only update scale weights if they change..
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) 
         || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
        status = class04DProgramWeights(pHalHwInfo,
                                        pDecoderHalObj->SetImage[0].WidthIn,
                                        pDecoderHalObj->SetImage[0].WidthOut);
      
      if (status)
          return (status);
    }  
                        
    //
    // Load up the buffer location and sizes
    //
    
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_TASKA_BUFF0_START, pDecoderHalObj->SetImage[0].Offset
                                         + (pDecoderHalObj->SetImage[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[0].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF0_PITCH, pDecoderHalObj->SetImage[0].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF0_LENGTH, pDecoderHalObj->SetImage[0].Pitch * pDecoderHalObj->SetImage[0].HeightOut);
        
    }
    else
    {
        REG_WR32(NV_PME_TASKA_BUFF1_START, pDecoderHalObj->SetImage[1].Offset
                                         + (pDecoderHalObj->SetImage[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[1].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF1_PITCH, pDecoderHalObj->SetImage[1].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF1_LENGTH, pDecoderHalObj->SetImage[1].Pitch * pDecoderHalObj->SetImage[1].HeightOut);
    } 
    
    //
    // turn on scaling
    //
    if((pDecoderHalObj->lastHeightIn != pDecoderHalObj->SetImage[0].HeightIn ) || (pDecoderHalObj->lastHeightOut != pDecoderHalObj->SetImage[0].HeightOut)) {
    
      yscaleincr = ((pDecoderHalObj->SetImage[0].HeightOut << Y_SCALE_INCR_PRECISION) - 1) / 
                 (pDecoderHalObj->SetImage[0].HeightIn - 1);
      REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, yscaleincr);
      // REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, (1 << 10));
    }
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
       
      xscaleincr = (65536 );
      if((pDecoderHalObj->SetImage[0].WidthOut != 0) && (pDecoderHalObj->SetImage[0].WidthIn != 0)) {
        // protection from  zero case
        xscaleincr = (65536 * pDecoderHalObj->SetImage[0].WidthIn) / pDecoderHalObj->SetImage[0].WidthOut;
      } 
      
      REG_WR_DRF_NUM(_PME, _TASKA_X_SCALE, _INCR, xscaleincr);
      FLD_WR_DRF_DEF(_PME, _TASKA_X_SCALE, _FILTER, _ENABLE);
    }

    //
    // program data width
    //

    if ( pDecoderHalObj->ImageDataWidth != (pDecoderHalObj->lastImageConfig & 0xFF) ) {
        if ( pDecoderHalObj->ImageDataWidth == 8 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _8);
        }
        else if ( pDecoderHalObj->ImageDataWidth == 16 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _16);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFFFFFF00) | pDecoderHalObj->ImageDataWidth;
    }

    //
    // program null data checking
    //

    if ( pDecoderHalObj->NullData != ((pDecoderHalObj->lastImageConfig >> 12) & 0x3) ) {
        if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _ENABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFF) |
                                    ((pDecoderHalObj->Task & 0x1) << 8) |
                                    ((pDecoderHalObj->NullData & 0x3) << 12) |
                                    ((pDecoderHalObj->NullValue & 0x16) << 16);
    }

    //
    // Program the image startline
    //
    if(pDecoderHalObj->lastImageStartLine != pDecoderHalObj->ImageStartLine ) {
      REG_WR_DRF_NUM(_PME, _TASKA_Y_CROP, _STARTLINE, pDecoderHalObj->ImageStartLine);
    }

    //
    // program maximum line length
    //
    if(pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) {
      if( pDecoderHalObj->SetImage[Buffer].WidthOut == 0 ) {
        // write the smallest possible value of line length that is still valid
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0x4);
      } else {
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 2 * pDecoderHalObj->SetImage[0].WidthIn);
      }
    }
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD));
            
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    }
     
    pDecoderHalObj->lastWidthIn = pDecoderHalObj->SetImage[Buffer].WidthIn;
    pDecoderHalObj->lastWidthOut = pDecoderHalObj->SetImage[Buffer].WidthOut;
    pDecoderHalObj->lastHeightIn = pDecoderHalObj->SetImage[Buffer].HeightIn;
    pDecoderHalObj->lastHeightOut = pDecoderHalObj->SetImage[Buffer].HeightOut;
    pDecoderHalObj->lastImageStartLine = pDecoderHalObj->ImageStartLine;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage-end\r\n");

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DMethod_NV20(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 offset, data;
    U032 buffNum;

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04D_STOP_TRANSFER_VBI:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _DISABLED);

            //
            // Stop the current vbi data transfer immediately
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _DISABLED);

            //
            // return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            break;
        case NV04D_STOP_TRANSFER_IMAGE:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKB_NOTIFY, _DISABLED);

            //
            // Stop the current image data transfer immediately.
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 0);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);
	 
            //
            // Return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);

            //
            // Reset the checks.
            //
            pDecoderHalObj->lastWidthIn               = 0;
            pDecoderHalObj->lastWidthOut              = 0;
            pDecoderHalObj->lastHeightIn              = 0;
            pDecoderHalObj->lastHeightOut             = 0;
            //
            // this is used to indicate the first time around...
            // 99 with likely never be used at a startline value since it
            // should be something like 0 - 21  
            //
            pDecoderHalObj->lastImageStartLine        = 99;
            break;
        case NV04D_SET_IMAGE_CONFIG:
        {
            U032 tmp;

            //
            // Make sure all the fields are legal before saving them.
            //
            tmp = data & 0xFF;
            if ( (tmp == 8) || (tmp == 16) ) {
                pDecoderHalObj->ImageDataWidth = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 8) & 0x1;
            // only support TASK A for now
            if ( tmp == NV04D_SET_IMAGE_CONFIG_TASK_A ) {
                pDecoderHalObj->Task = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 12) & 0x3;
            if ( (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED) ) {
                pDecoderHalObj->NullData = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pDecoderHalObj->NullValue = (data >> 16) & 0xFFFF;
            break;
        }
        case NV04D_SET_IMAGE_START_LINE:
            //
            // Load the local copy, but don't hit the hardware
            // until we actually need it.
            //
            if (data == 0)  data = 13;
            pDecoderHalObj->ImageStartLine = data;
            break;
        case NV04D_SET_VBI_SIZE(0):
        case NV04D_SET_VBI_SIZE(1):
            buffNum = (offset == NV04D_SET_VBI_SIZE(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].FirstLine = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Height    = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_VBI_OFFSET(0):
        case NV04D_SET_VBI_OFFSET(1):
            buffNum = (offset == NV04D_SET_VBI_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Offset = data;
            break;
        case NV04D_SET_VBI_FORMAT(0):
        case NV04D_SET_VBI_FORMAT(1):
            buffNum = (offset == NV04D_SET_VBI_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetVbi[buffNum].Notify = ((data >> 24) & 0xFF);
            //
            // Kick it off!!
            //
            class04DStartVbi(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_VBI_OFFSET_NOTIFY(0):
        case NV04D_GET_VBI_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_VBI_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].GetOffsetData = REG_RD_DRF(_PME, _ANC_CURRENT, _POS);
            break;
        case NV04D_SET_IMAGE_SIZE_IN(0):
        case NV04D_SET_IMAGE_SIZE_IN(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_IN(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthIn  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightIn = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_SIZE_OUT(0):
        case NV04D_SET_IMAGE_SIZE_OUT(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_OUT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthOut  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightOut = ((data >> 16) & 0xFFFF);
            //
            // Zero here is used to indicate we want a notify that a
            // field went by but no update.
            //
            if (pDecoderHalObj->SetImage[buffNum].HeightOut == 0)
                pDecoderHalObj->SetImage[buffNum].HeightOut = 1;
            break;
        case NV04D_SET_IMAGE_OFFSET(0):
        case NV04D_SET_IMAGE_OFFSET(1):
            buffNum = (offset == NV04D_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Offset = data;
            break;
        case NV04D_SET_IMAGE_FORMAT(0):
        case NV04D_SET_IMAGE_FORMAT(1):
            buffNum = (offset == NV04D_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetImage[buffNum].Notify = ((data >> 24) & 0xFF);
            
            //
            // Kick it off
            //
            class04DStartImage(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(0):
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_IMAGE_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].GetOffsetData = REG_RD_DRF(_PME, _TASK_CURRENT, _POS);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVbiEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_VBI_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_VBI_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_VBI_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_VBI_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVbiEvents\n");

    return;
}

static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
    
	// clear the interrupt, in case another shows up!
	REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
	
    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0

    if (*pEventsPending & CLASS04D_IMAGE_EVENT(0))
    {
        pDecoderHalObj->SetImage[0].Info32 = 0;
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(0);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF0_START );
                pDecoderHalObj->SetImage[0].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF0_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF0));
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(1))
    {
        pDecoderHalObj->SetImage[1].Info32 = 0;
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(1);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF1_START );
                pDecoderHalObj->SetImage[1].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF1_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF1));
            }
        }
    }	

    *pEventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}

//
// class04DGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04DGetEventStatus_NV20
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending VBI/IMAGE events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // No current decoder object, so treat exception as spurious.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
        pMpGetEventStatusArg->events = 0;
        return (RM_ERROR);
    }

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING))
            GetVbiEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    }
    if (eventsPending & (CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04DServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04DServiceEvent_NV20
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    if (event == CLASS04D_VBI_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_VBI_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else
    {
        status = RM_ERR_BAD_ARGUMENT;
    }

    //
    // XXX (scottl):
    //
    // Shouldn't this be #ifdef DEBUG???
    //
    if (event == CLASS04D_VBI_EVENT(0) || event == CLASS04D_VBI_EVENT(1))
    {
        U032 error;
        // and out the rest of the bits
        error = REG_RD32(NV_PME_ANC_ME_STATE) & 0x7E00;
        if (error) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: C04DNV20: errors detected in ME register\n");
        }
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c04env20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DO_INTERRUPT_TIMING
U032 timePrev = 0;
#endif

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv20/mpnv20.c.
//
RM_STATUS class04EMethod_NV20(PMPMETHODARG_000);
RM_STATUS class04EGetEventStatus_NV20(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04EServiceEvent_NV20(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv20/mpnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04EStartRead
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING) ) {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartRead couldn't reset interrupt!\n");
		DBG_BREAKPOINT();
    }
#endif

    //
    // Make sure the engine is configured correctly 
    //
    FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
	//
	// XXX for now we only support transfers out framebuffer memory
    //
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT_SYSMEM, _DISABLED);
	if (Buffer == 0)
	{
		REG_WR32(NV_PME_FOUT_BUFF0_START, pDecompHalObj->ReadData[0].Offset
										+ (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
	} 
	else
	{
		REG_WR32(NV_PME_FOUT_BUFF1_START, pDecompHalObj->ReadData[1].Offset
										+ (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
	} 
							
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    }

	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _ENABLED);

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04EMethod_NV20(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 offset, data;
    U032 buffNum;

    pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04E_STOP_TRANSFER:
            //
            // Stop the current data transfer immediately.
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            break;
        case NV04E_SET_DATA_OFFSET(0):
        case NV04E_SET_DATA_OFFSET(1):
            buffNum = (offset == NV04E_SET_DATA_OFFSET(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Offset = data;
            break;
        case NV04E_SET_DATA_LENGTH(0):
        case NV04E_SET_DATA_LENGTH(1):
            buffNum = (offset == NV04E_SET_DATA_LENGTH(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Size = data;
            break;
        case NV04E_SET_DATA_NOTIFY(0):
        case NV04E_SET_DATA_NOTIFY(1):
            buffNum = (offset == NV04E_SET_DATA_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Notify = data;
            //
            // KICK IT OFF!!
            //
            class04EStartRead(pHalHwInfo, pDecompHalObj, buffNum);
            break;
        case NV04E_SET_IMAGE_FORMAT_IN(0):
        case NV04E_SET_IMAGE_FORMAT_IN(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_IN(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatIn = data;
            break;
        case NV04E_SET_IMAGE_SIZE(0):
        case NV04E_SET_IMAGE_SIZE(1):
            buffNum = (offset == NV04E_SET_IMAGE_SIZE(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Size = data;
            break;
        case NV04E_SET_IMAGE_OFFSET_OUT(0):
        case NV04E_SET_IMAGE_OFFSET_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_OFFSET_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Offset = data;
            break;
        case NV04E_SET_IMAGE_FORMAT_OUT(0):
        case NV04E_SET_IMAGE_FORMAT_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatOut = data;
            break;
        case NV04E_SET_IMAGE_NOTIFY(0):
        case NV04E_SET_IMAGE_NOTIFY(1):
            buffNum = (offset == NV04E_SET_IMAGE_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Notify = data;
            //
            // NOT SUPPORTED!!
            //
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
}


//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVideoEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));

    // buffer 0
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVideoEvents\n");

    return;
}

#if 0
static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    //
    // Not supported!!!
    //
    *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));

    return ;
}
#endif

//
// class04EGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04EGetEventStatus_NV20
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending events.
    //
    if (!(intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING)))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // Setup HAL object pointer.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
        pDecompHalObj = NULL;
    else
        pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING))
            GetVideoEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    }
    if (eventsPending & (CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1)))
    {
        //
        // Not supported!
        //if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
        //    GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        //else
            eventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04EServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04EServiceEvent_NV20
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04E_VIDEO_EVENT(0):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_VIDEO_EVENT(1):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(0):
        case CLASS04E_AUDIO_EVENT(1):
        case CLASS04E_IMAGE_EVENT(0):
        case CLASS04E_IMAGE_EVENT(1):
            //
            // These events aren't supported on nv20.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class04EServiceEvent; bogus event type ", event);
            DBG_BREAKPOINT();
            break;
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c63nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDFRMEM.C                                                        *
*   This module implements the NV_VIDEO_FROM_MEMORY object class and its    *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DEBUG_TIMING

#define DBG_PRINT_TIME(s,v) DBG_PRINT_STRING_VALUE(0x10, s, v);
U032 time0hi=0, time0lo=0, time1hi=0, time1lo=0;

#endif // DEBUG_TIMING

//
// We can't quite use the DRF macros due to how they concatenate strings
// to create field accesses and do some bit shifting ... these are only
// used for NV_PVIDEO_FORMAT updates
//
#define VIDEO_FORMAT_FLD_WR_DEF(buf, fld, def)                                                  \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                     \
                (DRF_MASK(NV_PVIDEO_FORMAT ## fld) << DRF_SHIFT(NV_PVIDEO_FORMAT ## fld))) |    \
                DRF_DEF(_PVIDEO, _FORMAT, fld, def))

#define VIDEO_FORMAT_FLD_WR_PITCH(buf, val)                                                       \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                       \
                (DRF_MASK(NV_PVIDEO_FORMAT_PITCH) << DRF_SHIFT(NV_PVIDEO_FORMAT_PITCH))) | val)

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class63Method_NV20(PVIDEOMETHODARG_000);
RM_STATUS class63InitXfer_NV20(PHALHWINFO, VOID *, U032);
VOID class63DualSurfaceDesktop_NV20(PHALHWINFO, U032);

//
// Statics
//
static RM_STATUS class63StartXfer_NV20(PHALHWINFO, VOID *, U032);
static VOID class63DualSurface_NV20(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);
static VOID class63ColorKey_NV20(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class63Method
//
// This routine performs any chip-specific handling for all class63
// methods.
//
RM_STATUS class63Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF8_STOP_TRANSFER(0):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
            {
                // activate a PVIDEO_STOP and disappear the window by
                // setting SIZE_OUT to 0
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StopTransfer: set STOP_ACTIVE/IMMEDIATELY\n\r");
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     PVIDEO BUFFER ", REG_RD32(NV_PVIDEO_BUFFER));
                REG_WR32(NV_PVIDEO_STOP,
                         DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                         DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            }
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV20;
            break;
        case NVFF8_IMAGE_SCAN_NOTIFY(0,0):
        case NVFF8_IMAGE_SCAN_NOTIFY(0,1):
            buffNum = (offset == NVFF8_IMAGE_SCAN_NOTIFY(0,0)) ? 0 : 1;
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurface_NV20(pHalHwInfo, pVidFromMemHalObj, buffNum);
            return pVidFromMemHalObj->KickOffProc(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

static VOID class63ColorKey_NV20
(
    PHALHWINFO pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj,
    U032 buffNum
)
{
    U032 color, colorFormat;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    color = pVidFromMemHalObj->Buffer[buffNum].VideoColor;
    colorFormat = pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat;

    //
    // Set the hardware to the specified color.
    //
    if (color)
    {
        switch (colorFormat)
        {
            case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
            case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFF);
                break;
            
            case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0x7FFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
            case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
            case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
            case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFFFF);
                break; 
                
            default:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color);
                break; 
        }
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _COLOR_KEY_EQUAL);
    } 
    else
    {
        // XXX does this do it??
        REG_WR32(NV_PVIDEO_COLOR_KEY, NV_PVIDEO_COLOR_KEY_VALUE_DONT_CARE);
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _ALWAYS);
    }
}

//
//      Program the video scalar to scan out the video to the TV encoder.
//
static VOID class63DualSurface_NV20(PHALHWINFO pHalHwInfo, PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj, U032 buffNum)

{
    U032    pitch0, pitch1, vbs, vbe, hbs, hbe, hw;
    U032    length, width, pitch, height;
    int     step_x, step_y;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // Class63 has set up the scalar to render into a window, but we'll
    // change it to render to the full TV screen.
    // This means getting the source buffer size and scaling up to the
    // current resolution.
    //

    // get the width and height of the video object
    // height = length/width
    // step x = ((src_width -1) << 11) / (dest_width -1 )
    // step y = ((src_height -1) << 11) / (dest_height - 1)
    length = pVidFromMemHalObj->Buffer[buffNum].Length;
    pitch  = pVidFromMemHalObj->Buffer[buffNum].Pitch;
    width  = pVidFromMemHalObj->Buffer[buffNum].Width;
    if (width != 0) // we'll get objects with size 0
    {
        height = length/width;
        // XXX for now we'll leave it at masking 12 bits
        step_x = (((width - 1) << 11) / (pHalHwInfo->pFbHalInfo->HorizDisplayWidth - 1)) & 0xfff;
        step_y = (((height - 1) << 11) / (pHalHwInfo->pFbHalInfo->VertDisplayWidth - 1)) & 0xfff;
    }
    else
        return;


    // We have a valid video object
                    
    // find screen size
    if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
    {
        // doubled modes
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
    }
    else                                                            
    {
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
    }
    pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;

    // set up timing default values (640x480)
    vbs   = 0x00000240;
    vbe   = 0x0000005c;
    hbs   = 0x00000300;
    hbe   = 0x00000050;
        
    // adjust horizontal and vertical position/size
    // low-res modes don't quite use the same timings as their doubles
    switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
    {
        case 200:     // 320x200x16
            hbs   = 0x00000308;
            hbe   = 0x00000068;
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 240:     // 320x240x16
            hbs   = 0x00000308;
            hbe   = 0x00000050;
            break;             
        case 300:     // 400x300x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003d0;
            hbe   = 0x00000088;
            break;             
        case 384:     // 512x384x16
            vbs   = 0x00000230;
            vbe   = 0x00000080;
            hbs   = 0x00000290;
            hbe   = 0x00000090;
            break;             
        case 400:     // 640x400x16
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 480:     // 640x480x16
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            break;
        case 600:     // 800x600x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003a8;
            hbe   = 0x00000088;
            break;
        default:
            break;
    }            
    vbe--;
        
    // Output timing
    REG_WR32(NV_PRAMDAC_TV_VBLANK_START, vbs);   
    REG_WR32(NV_PRAMDAC_TV_VBLANK_END, vbe);    
    REG_WR32(NV_PRAMDAC_TV_HBLANK_START, hbs);     
    REG_WR32(NV_PRAMDAC_TV_HBLANK_END, hbe);    

    // Video scalar
    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
    REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(1), step_y);
    //WritePriv32(scale, NV_PVIDEO_STEP_SIZE);        // scale factor 1:1

    VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);
    //WritePriv32(pitch0, NV_PVIDEO_BUFF0_PITCH);     // pitch buffer 0

    VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);
    //WritePriv32(pitch1, NV_PVIDEO_BUFF1_PITCH);     // pitch buffer 1

    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
    REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);
    //WritePriv32(hw, NV_PVIDEO_WINDOW_SIZE);         // h (26:16), w (10:0)
}


//****************************************************************************************
//
//      Program the video scalar to scan out the framebuffer (desktop) to the TV encoder.
//      Or, turn off the video scalar for TV only or monitor.
VOID class63DualSurfaceDesktop_NV20(PHALHWINFO pHalHwInfo, U032 mode)
{
    U032 coeff=0, setup=0, vbs=0, vbe=0, hbs=0, hbe=0;
    U032 start_buf0=0, start_buf1=0, pitch0=0, pitch1=0, xy_pos=0, hw=0;
    U032 step_x=0, step_y=0;
    U032 fifo0, fifo1, reg32;
    int dualSurface = 0;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    switch (mode)
    {
        case DISPLAY_TYPE_MONITOR:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
            break;
        case DISPLAY_TYPE_TV:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER;
            break;

        case DISPLAY_TYPE_DUALSURFACE:
            dualSurface = 1;
        
            start_buf0 = 0;     // desktop starts at 0
            start_buf1 = 0;
            if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
            {
                // doubled modes
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY) >> 1; // 2:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY) >> 1; // 2:1
                //scale = 0x04000400;     // 2:1
            }
            else                                                            
            {
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY);      // 1:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY);      // 1:1
                //scale = 0x08000800;     // 1:1
            }
            pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;
            // set up timing default values (640x480)
            coeff = 0x10700;
            setup = 0x00001111;     // 565 pixel data, use second surface
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            xy_pos = 0;
            fifo0 = 0x20;           // watermark
            fifo1 = 0x03;
                
            // adjust horizontal and vertical position/size
            // low-res modes don't quite use the same timings as their doubles
            switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
            {
                case 200:     // 320x200x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000068;
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 240:     // 320x240x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000050;
                    break;             
                case 300:     // 400x300x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003d0;
                    hbe   = 0x00000088;
                    break;             
                case 384:     // 512x384x16
                    vbs   = 0x00000230;
                    vbe   = 0x00000080;
                    hbs   = 0x00000290;
                    hbe   = 0x00000090;
                    break;             
                case 400:     // 640x400x16
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 480:     // 640x480x16
                    vbs   = 0x00000240;
                    vbe   = 0x0000005c;
                    hbs   = 0x00000300;
                    hbe   = 0x00000050;
                    break;
                case 600:     // 800x600x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003a8;
                    hbe   = 0x00000088;
                    break;
                default:
                    dualSurface = 0;
                    break;
            }            
            break;
    }

    if (dualSurface)    // DualSurface requested and its a valid mode
    {
        // XXX idle everything??
        REG_WR32(NV_PVIDEO_BUFFER, 0);

        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, coeff);   
        REG_WR32(NV_PRAMDAC_TV_SETUP        , setup);          
        REG_WR32(NV_PRAMDAC_TV_VBLANK_START , vbs);   
        REG_WR32(NV_PRAMDAC_TV_VBLANK_END   , vbe);    
        REG_WR32(NV_PRAMDAC_TV_HBLANK_START , hbs);     
        REG_WR32(NV_PRAMDAC_TV_HBLANK_END   , hbe);    

        // Video scalar
        REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
        REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(1), step_y);

        VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);

        VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
        REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);

#if 0 
        // could set this, but for now lets just use the defaults
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo0);
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo1);
        //WritePriv32(fifo0, NV_PVIDEO_FIFO_THRES);       // fifo fill threshold
        //WritePriv32(fifo1, NV_PVIDEO_FIFO_BURST);       // fifo burst length
#endif

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_POINT_OUT(0), xy_pos);
        REG_WR32(NV_PVIDEO_POINT_OUT(1), xy_pos);
        videoAdjustScalarForTV_NV20(pHalHwInfo, 0);
        videoAdjustScalarForTV_NV20(pHalHwInfo, 1);
        //WritePriv32(xy_pos, NV_PVIDEO_WINDOW_START);    // x,y position within buffer (start display here)

        REG_WR32(NV_PVIDEO_OFFSET(0), start_buf0);
        //WritePriv32(start_buf0, NV_PVIDEO_BUFF0_START); // start address buffer 0

        REG_WR32(NV_PVIDEO_OFFSET(1), start_buf1);
        //WritePriv32(start_buf1, NV_PVIDEO_BUFF1_START); // start address buffer 1
            
        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE);  // enable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);  // enable scalar

        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8); // set format
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);  // set format

        // switch to buffer 0, which will force the scalar to load new values
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
#if 0
        reg32 = REG_RD32(NV_PVIDEO_SU_STATE);
        ////reg32 = ReadPriv32(NV_PVIDEO_SU_STATE);
        reg32 &= ~0x00010000; // NV_PVIDEO_SU_STATE_BUFF0_IN_USE = 0
        REG_WR32(NV_PVIDEO_SU_STATE, reg32); // clear BUFF0_IN_USE
        //WritePriv32(reg32, NV_PVIDEO_SU_STATE); // clear BUFF0_IN_USE
#endif
    }    
    else    // need to set up for either TV only or Monitor only
    {

        reg32 = REG_RD32(NV_PRAMDAC_TV_SETUP);
        //reg32 = ReadPriv32(NV_PRAMDAC_TV_SETUP);
        reg32 &= NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
        reg32 |= setup;
        REG_WR32(0x680700, setup);   // TV SETUP
        //WritePriv32(setup, 0x680700);   // TV SETUP

        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);  // disable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);  // disable scalar
    }
}

//---------------------------------------------------------------------------
//
//  Buffer transfer routines.
//
//---------------------------------------------------------------------------

RM_STATUS class63InitXfer_NV20
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    RM_STATUS       status = RM_OK;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63InitXfer\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV20(pHalHwInfo, NV_VIDEO_FROM_MEMORY);

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_CR8YB8CB8YA8);
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8);

    pVidFromMemHalObj->KickOffProc = class63StartXfer_NV20;

    status = class63StartXfer_NV20(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);

    return (status);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class63StartXfer_NV20
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    RM_STATUS status = RM_OK;
    PHWREG nvAddr = pHalHwInfo->nvBaseAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StartXfer\r\n");

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // XXX (scottl):
    // I've made a *MAJOR* assumption here that we do not use the BBufferXfer
    // proc to handle RGB video.  In looking at the transfer method in 
    // in class63.c (formally c63nv20.c), it looks like it's entirely
    // vblank driven.  By making this assumption, I'm able to avoid having
    // vblank info in the HAL.
    //
#ifdef DEBUG
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class63StartXfer: format is RGB!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // VideoStart, VideoSize and VideoScale are not double buffered.
    // So copy the values into the Buff0 versions to simulate true
    // double buffering.
    //
    pVidFromMemHalObj->Buffer[buffNum].VideoStart = pHalHwInfo->pVideoHalInfo->VideoStart;
    pVidFromMemHalObj->Buffer[buffNum].VideoSize = pHalHwInfo->pVideoHalInfo->VideoSize;
    pVidFromMemHalObj->Buffer[buffNum].VideoScale = pHalHwInfo->pVideoHalInfo->VideoScale;
    pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat = pHalHwInfo->pVideoHalInfo->VideoColorFormat;
    pVidFromMemHalObj->Buffer[buffNum].VideoColor = pHalHwInfo->pVideoHalInfo->VideoColor;

    //
    // Mark the buffer as BUSY. That is all we do here. The hardware
    // registers are programmed in videoService after the current buffer
    // completion.
    //
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_BUSY;

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_CR8YB8CB8YA8);
    }
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_YB8CR8YA8CB8);
    }

    // Write the offset straight away (must be 64byte aligned). If any of the low order
    // 6 bits are set from ImageScan.offset, we'll divide by 2 to convert bytes to texels
    // and shift this value by 4 to get into the integer portion of POINT_IN_S.
    REG_WR32(NV_PVIDEO_OFFSET(buffNum), pVidFromMemHalObj->Buffer[buffNum].Start);
    REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
             (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_S) << DRF_SHIFT(NV_PVIDEO_POINT_IN_S))) |
             DRF_NUM(_PVIDEO, _POINT, _IN_S, ((pVidFromMemHalObj->Buffer[buffNum].Start & 0x3F) >> 1) << 4));

    // Set the pitch (must be 64byte aligned).
    // If the LSB's are 0x2 then we're doing a bob and POINT_IN_T needs to be -1/2.
    //
    VIDEO_FORMAT_FLD_WR_PITCH(buffNum, pVidFromMemHalObj->Buffer[buffNum].Pitch);
    if ((pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x3) == 0x2)
    {
        REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
                 (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_T) << DRF_SHIFT(NV_PVIDEO_POINT_IN_T))) |
                 DRF_NUM(_PVIDEO, _POINT, _IN_T, (0xFFF8 >> 1)));
    }

    REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoStart);
    videoAdjustScalarForTV_NV20(pHalHwInfo, buffNum);
    REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoSize);
    REG_WR32(NV_PVIDEO_DS_DX(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleX);
    REG_WR32(NV_PVIDEO_DT_DY(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleY);

    class63ColorKey_NV20(pHalHwInfo, pVidFromMemHalObj, buffNum);

    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;

    // HW now owns the buffer
    if (buffNum == 0)
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _SET);

#ifdef DEBUG_TIMING
    if (buffNum == 0)
        vmmOutDebugString("\n0B");
    else
        vmmOutDebugString("\n1B");
#endif
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c64nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER object class and its         *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class64Method_NV20(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class64Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class64Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOSCALERHALOBJECT pVidScalerHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF7_SET_DELTA_DU_DX(0):
            pVidScalerHalObj->DeltaDuDx = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleX = videoConvertScaleFactor_NV20(data);
            break;
        case NVFF7_SET_DELTA_DV_DY(0):
            pVidScalerHalObj->DeltaDvDy = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleY = videoConvertScaleFactor_NV20(data);
            break;
        case NVFF7_SET_POINT(0):
            pVidScalerHalObj->xStart = (data & 0xffff);
            pVidScalerHalObj->yStart = (data >> 16);
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidScalerHalObj->xStart) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidScalerHalObj->yStart);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c65nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class65Method_NV20(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class65Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class65Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NVFF6_SET_COLOR_FORMAT(0):
            pVidColorKeyHalObj->ColorFormat = data;
            pHalHwInfo->pVideoHalInfo->VideoColorFormat = data;
            break;
        case NVFF6_SET_COLOR_KEY(0):
            pVidColorKeyHalObj->Color = data;
            pHalHwInfo->pVideoHalInfo->VideoColor = data;
            if (data)
            {
                switch (pVidColorKeyHalObj->ColorFormat)
                {
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0x7FFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
                    case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFFFF);
                        break;
                    default:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data);
                        break;
                }
            }
            break;
        case NVFF6_SET_POINT(0):
            pVidColorKeyHalObj->xClipMin = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMin = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMin) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMin);
            break;
        case NVFF6_SET_SIZE(0):
            pVidColorKeyHalObj->xClipMax = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMax = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoSize =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMax) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMax);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c07anv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: C07ANV20.C                                                        *
*   This module implements the NV10_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class07aMethod_NV20(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class07aMethod
//
// Process all class07a methods.
//
RM_STATUS class07aMethod_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV07A_STOP_OVERLAY(0):
        case NV07A_STOP_OVERLAY(1):
            videoStopOverlay_NV20(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV07A_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV07A_SET_CONTEXT_DMA_OVERLAY(0):
        case NV07A_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV07A_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE(0):
        case NV07A_SET_OVERLAY_LUMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_LUMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_LUMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE(0):
        case NV07A_SET_OVERLAY_CHROMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_CHROMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_CHROMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_COLORKEY(0):
        case NV07A_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV20 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV07A_SET_OVERLAY_OFFSET(0):
        case NV07A_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_IN(0):
        case NV07A_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Check for overflow and limit if necessary
            if ((data & 0xFFFF) > 0x7fe) {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Overlay Warning! Width Overflow.\n\r");
                data = (data & 0xffff0000) | 0x7fe;
            }
            if ((data >> 16) > 0x7fe) {
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Overlay Warning! Height Overflow.\n\r");
                data = (data & 0xffff) | 0x7fe0000;
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASizeIn Invalid Height!!\r\n");
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASizeIn Invalid Height!!\r\n");
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_IN(0):
        case NV07A_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DU_DX(0):
        case NV07A_SET_OVERLAY_DU_DX(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DU_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DV_DY(0):
        case NV07A_SET_OVERLAY_DV_DY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DV_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT(0):
        case NV07A_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);
			videoAdjustScalarForTV_NV20(pHalHwInfo, buffNum);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_OUT(0):
        case NV07A_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_FORMAT(0):
        case NV07A_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV20(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);
            videoAdjustScalarForTV_NV20(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV20(pHalHwInfo, 1);
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_LUMINANCE(0), data);
            REG_WR32(NV_PVIDEO_LUMINANCE(1), data);
            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_CHROMINANCE(0), data);
            REG_WR32(NV_PVIDEO_CHROMINANCE(1), data);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv20\c04fnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: CLASS04F.C                                                        *
*   This module implements the NV_EXTERNAL_PARALLEL_BUS object              *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv20/mpnv20.c.
//
RM_STATUS class04FMethod_NV20(PMPMETHODARG_000);
RM_STATUS class04FGetEventStatus_NV20(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04FServiceEvent_NV20(PMPSERVICEEVENTARG_000);

#define	VIPREG_TIMEOUT_CNT	1000		// XXX arbitrary

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv20/mpnv20.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FMethod_NV20
(
    PMPMETHODARG_000 pMpMethodArg
)
{
    PPARALLELBUSHALOBJECT pPBusHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    PHWREG nvAddr;

    pPBusHalObj = (PPARALLELBUSHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV04F_STOP_TRANSFER:
            //
            // Stop either read or write
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        case NV04F_WRITE_SIZE:
            pPBusHalObj->Write.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Write.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Write.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Write.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_WRITE_ADDRESS:
            pPBusHalObj->Write.Address = data;
            break;
        case NV04F_WRITE_DATA:
        {
            U032 vipCtrl, cnt;

            pPBusHalObj->Write.Data = data;
            
            //
            // Make sure there isn't a write pending
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_WRITE_DATA state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _PENDING) );
            
            //
            // Do the write now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Write.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Write.Address & 0x0000FFFF));
            REG_WR32(NV_PME_VIPREG_DATA, pPBusHalObj->Write.Data);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _START);
            break;
        }
        case NV04F_READ_SIZE:
            pPBusHalObj->Read.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Read.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Read.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Read.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_READ_ADDRESS:
            pPBusHalObj->Read.Address = data;
            break;
        case NV04F_READ_GET_DATA_NOTIFY:
        {
            U032 vipCtrl, cnt, data32;
            
            pPBusHalObj->Read.Notify = data;

            //
            // Make sure there isn't a read pending.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_READ_GET_DATA_NOTIFY state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            //
            // Do the read now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Read.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Read.Address & 0x0000FFFF));
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _START);
            
            //
            // Wait for the read to complete.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                    return(RM_ERROR);
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            data32 = REG_RD32(NV_PME_VIPREG_DATA);
            
            //
            // Save data off so that RM can return it via the notify.
            //
            pPBusHalObj->Read.ReadData = data32;
            break;
        }
        case NV04F_SET_INTERRUPT_NOTIFY:
            //
            // Make sure the interrupt is enabled
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _ENABLED);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

RM_STATUS class04FGetEventStatus_NV20
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    intr0 = REG_RD32(NV_PME_INTR_0);

    // XXX not final (need to finish porting class04F to NV20)

    //
    // Let RM know we've got a pbus event pending.
    //
    if (intr0 & DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _PENDING))
    {
        pMpGetEventStatusArg->events = CLASS04F_PBUS_EVENT;
    }
    else
    {
        pMpGetEventStatusArg->events = 0;
    }

    //
    // This value is given back in the service routine so we know
    // which exceptions we are to clear.
    //
    pMpGetEventStatusArg->intrStatus = intr0;

    return RM_OK;
}

RM_STATUS class04FServiceEvent_NV20
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    //
    // The intrStatus value was saved off in GetEventStatus.
    //
    if (pMpServiceEventArg->event != CLASS04F_PBUS_EVENT)
    {
        pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
        return RM_ERR_BAD_ARGUMENT;
    }

    //
    // Clear the interrupt
    //
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _RESET));

    //
    // This is a single-shot notify.  Disable the interrupt.
    //
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _DISABLED);

    //
    // Clear state in exception data structure.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c047nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class047Method_NV04(PVIDEOMETHODARG_000);
RM_STATUS class047InitXfer_NV04(PHALHWINFO, VOID *, U032);
RM_STATUS class047GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000);
RM_STATUS class047Service_NV04(PVIDEOSERVICEEVENTARG_000);

//
// Statics
//
static RM_STATUS class047StartXfer_NV04(PHALHWINFO, VOID *, U032);
static VOID class047KickoffBuffer_NV04(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

RM_STATUS class047InitXfer_NV04
(
    PHALHWINFO  pHalHwInfo,
    VOID        *pHalObjInfo,
    U032        buffNum
)
{
    RM_STATUS       status = RM_OK;
    V032            stateSU;
    V032            stateOE;
    V032            stateOESU;
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHWREG          nvAddr;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047InitXfer_NV04\r\n");

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pHalObjInfo;

    nvAddr = pHalHwInfo->nvBaseAddr;
        
    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV04(pHalHwInfo, NV04_VIDEO_OVERLAY);

    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);    
    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);    
    if (buffNum == (stateOE >> 24))
    {
        // The current buffer in stateOE is same as the one we want to start.
        // If both buffers are idle in this state, we have to toggle the current
        // buffer to make the overlay engine look at the buffer we are about to
        // setup.
        stateOESU = stateOE ^ stateSU;
        if ((stateOESU & 0x00100000) &&  //buffer 1 is idle
            (stateOESU & 0x00010000))    //buffer 0 is idle
        {
            stateOE ^= 0x01000000;
            REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
        }
    }
        
    status = class047StartXfer_NV04(pHalHwInfo, pOverlayHalObj, buffNum);
    if (status == RM_OK)
    {
    	// Actually kickoff the buffer that was just marked busy by writing the registers.
        // After this, buffers are actually kicked off after we get the completion interrupt.
        if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_BUSY)
        {
            class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 0);
        }
        else
        {
            // Kickoff buffer 1.
            class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 1);
        }

        //
        // Set the enable bit in VBLANK. This is to prevent enabling the video in the middle of
        // the video window. That may cause only the "end window" processing to be done without
        // having done the "start window" processing. Making sure to enable the video pipeline
        // from VBLANK (and not doing it here) fixes 19991220-082127.
        //
        pHalHwInfo->pVideoHalInfo->UpdateFlags |= UPDATE_HWINFO_VIDEO_ENABLE;
        
        //
        // This instance has been initialized.  Call StartXfer for the next
        // buffer updates.
        //
        pOverlayHalObj->KickOffProc = class047StartXfer_NV04;
    }

    return (status);
}

static VOID class047KickoffBuffer_NV04
(
    PHALHWINFO                  pHalHwInfo,
    PVIDEO_OVERLAY_HAL_OBJECT   pOverlayHalObj,
    U032                        buffNum
)
{
    V032 stateSU;
    PHWREG nvAddr;
    U032 data32;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047KickoffBuffer");

    nvAddr = pHalHwInfo->nvBaseAddr;

    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);

    if (buffNum == 0) {
        REG_WR32(NV_PVIDEO_BUFF0_START,  pOverlayHalObj->Overlay[buffNum].OverlayStart);
        REG_WR32(NV_PVIDEO_BUFF0_PITCH,  (pOverlayHalObj->Overlay[buffNum].Pitch & 0x00007FF0));
    } else {
        REG_WR32(NV_PVIDEO_BUFF1_START,  pOverlayHalObj->Overlay[buffNum].OverlayStart);
        REG_WR32(NV_PVIDEO_BUFF1_PITCH,  (pOverlayHalObj->Overlay[buffNum].Pitch & 0x00007FF0));
    }
        
    // this is an NV10 emulator
    // we don't have fractional bobbing abilities
    // we can do 0, -1/4 and -1/2.
    // since we want to keep the bobbing even and can't do -1/4 we'll
    // only use 0 and -1/2.
    // Therefor the system will be to check bit 3 of the 12.4 value
    // if bit 3 is set then we set the bob to -1/2 otherwise 
    if (buffNum == 0) {
        if (pOverlayHalObj->Overlay[buffNum].PointIn_t & 0x8)
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF0_OFFSET, _Y, 2 );
        else
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF0_OFFSET, _Y, 0);
    } else {
        if (pOverlayHalObj->Overlay[buffNum].PointIn_t & 0x8)
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF1_OFFSET, _Y, 2 );
        else
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF1_OFFSET, _Y, 0);
    }

    FLD_WR_DRF_DEF(_PVIDEO, _CONTROL_Y, _LINE, _HALF);

    if (IsNV4_NV04(pHalHwInfo->pMcHalInfo) && 
        (pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_NTSC ||
         pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_PAL))
    {
        // NV4 HW bug, shift position on TV
        pOverlayHalObj->Overlay[buffNum].WindowStart += NV4_TV_DAC_SHIFT; 
    }
    REG_WR32(NV_PVIDEO_WINDOW_START, pOverlayHalObj->Overlay[buffNum].WindowStart);
    REG_WR32(NV_PVIDEO_STEP_SIZE, pOverlayHalObj->Overlay[buffNum].ScaleFactor);
    REG_WR32(NV_PVIDEO_KEY, pOverlayHalObj->Overlay[buffNum].ColorKey);
    if((pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_FLAT_PANEL) &&
        (REG_RD32(NV_PRAMDAC_FP_DEBUG_3) != 0x10001000)) // DFP scaling?
    {
        data32 = pOverlayHalObj->Overlay[buffNum].WindowSize;
        if (data32 != 0) 
            data32 -= 0x00010000;   // subtract 1 from Y
        REG_WR32(NV_PVIDEO_WINDOW_SIZE, data32);
    }
    else
        REG_WR32(NV_PVIDEO_WINDOW_SIZE, pOverlayHalObj->Overlay[buffNum].WindowSize);

    if (pOverlayHalObj->Overlay[buffNum].DisplayWhen == NV047_SET_OVERLAY_FORMAT_DISPLAY_ALWAYS)
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _OFF);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _ON);

    if (pOverlayHalObj->Overlay[buffNum].OverlayFormat == NV047_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8)
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _YUY2);

    // Mark buffer as NOTIFY_PENDING.
    pOverlayHalObj->Overlay[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;
    if (buffNum == 0)
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
    else
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);

#ifdef DEBUG_TIMING
    vmmOutDebugString("0K");
#endif

    REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class047StartXfer_NV04
(
    PHALHWINFO  pHalHwInfo,
    VOID        *pHalObjInfo,
    U032        buffNum
)
{
    U032 overlayStartAddr;
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047StartXfer_NV04\r\n");

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pHalObjInfo;

    // Calculate the offset from the begining of frame buffer where the overlay engine should start
    // scanning out.
#if 0
    overlayStartAddr =
        pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferBase + 
        pOverlayHalObj->Overlay[buffNum].Offset +
        ((pOverlayHalObj->Overlay[buffNum].Pitch * pOverlayObject->Overlay[buffNum].PointIn_t) +
         (pOverlayHalObj->Overlay[buffNum].PointIn_s << 1));
    pOverlayHalObj->Overlay[buffNum].OverlayStart = overlayStartAddr - (U032)pHalHwInfo->fbBaseAddr;
#else
    // remember that the point in specs are in 12.4 fixed point... so shift right by 4
    // and remember that's in pixels so 2 bytes per pixel
    
    if ((pOverlayHalObj->Overlay[buffNum].PointIn_t >>4 ) == 0xFFF ) {
        // for when the offset is ACTUALLY zero or just  -1/2
        overlayStartAddr = pOverlayHalObj->Overlay[buffNum].Offset +
            (pOverlayHalObj->Overlay[buffNum].PointIn_s >> 3);
    } else {
      if (pOverlayHalObj->Overlay[buffNum].PointIn_t & 0x8 ) {
          // there is a negative value in the bob, so add one to
          // the offset here
          overlayStartAddr = pOverlayHalObj->Overlay[buffNum].Offset +
                         ((pOverlayHalObj->Overlay[buffNum].Pitch * ((pOverlayHalObj->Overlay[buffNum].PointIn_t >> 4) + 1)) +
                          (pOverlayHalObj->Overlay[buffNum].PointIn_s >> 3));
      } else {
          overlayStartAddr = pOverlayHalObj->Overlay[buffNum].Offset +
              ((pOverlayHalObj->Overlay[buffNum].Pitch * (pOverlayHalObj->Overlay[buffNum].PointIn_t >> 4)) +
               (pOverlayHalObj->Overlay[buffNum].PointIn_s >> 3));
      }
    }
    
    pOverlayHalObj->Overlay[buffNum].OverlayStart = overlayStartAddr;
#endif

    // Mark the buffer as BUSY. That is all we do here. The hardware registers are
    // programmed in videoService after the current buffer completion.
    pOverlayHalObj->Overlay[buffNum].State = OVERLAY_BUFFER_BUSY;

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class047Method
//
// Process all class047 methods.
//
#define OVERLAY_BUFFER_IS_IDLE(obj,buffer) (obj->Overlay[buffer].State == OVERLAY_BUFFER_IDLE)

RM_STATUS class047Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;
    PHWREG nvAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    switch (offset)
    {
        case NV047_STOP_OVERLAY(0):
        case NV047_STOP_OVERLAY(1):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
                REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pOverlayHalObj->KickOffProc = class047InitXfer_NV04;
            break;
        case NV047_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV047_SET_CONTEXT_DMA_OVERLAY(0):
        case NV047_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pOverlayHalObj->Overlay[buffNum].ColorKey = data;
            break;
        }
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].Offset = data;
            break;
        }
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].SizeIn_width  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_WIDTH)) & 
                       DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_WIDTH));
            pOverlayHalObj->Overlay[buffNum].SizeIn_height = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & 
                       DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT));
            break;
        }
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].PointIn_s  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_IN_S)) & 
                       DRF_MASK(NV047_SET_OVERLAY_POINT_IN_S));
            pOverlayHalObj->Overlay[buffNum].PointIn_t = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_IN_T)) & 
                       DRF_MASK(NV047_SET_OVERLAY_POINT_IN_T));
            break;
        }
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DS_DX(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            pOverlayHalObj->Overlay[buffNum].DsDx = data;

            // Setup ScaleFactor.
            pOverlayHalObj->Overlay[buffNum].ScaleFactor = 
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DsDx))
                | DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DtDy));
            break;
        }
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DT_DY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].DtDy = data;

            // Setup ScaleFactor.
            pOverlayHalObj->Overlay[buffNum].ScaleFactor = 
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DsDx))
                | DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DtDy));

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        {
            U032 x, y;

            buffNum = (offset == NV047_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            x = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_X)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_X);
            y = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_Y)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_Y);

            // Setup the window start. 
            pOverlayHalObj->Overlay[buffNum].WindowStart = 
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, x) | DRF_NUM(_PVIDEO, _WINDOW_START, _Y, y); 

            break;
        }
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
        {
            U032 width, height;

            buffNum = (offset == NV047_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            width  = (data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_OUT_WIDTH)) & 
                     DRF_MASK(NV047_SET_OVERLAY_SIZE_OUT_WIDTH);
            height = (data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_OUT_HEIGHT)) & 
                     DRF_MASK(NV047_SET_OVERLAY_SIZE_OUT_HEIGHT);

            // Setup the window size.
            pOverlayHalObj->Overlay[buffNum].WindowSize = 
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _X, width) | 
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _Y, height);

            break;
        }
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pOverlayHalObj->Overlay[buffNum].Pitch  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_FORMAT_PITCH)) & 
                       DRF_MASK(NV047_SET_OVERLAY_FORMAT_PITCH));
                
            pOverlayHalObj->Overlay[buffNum].OverlayFormat = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_FORMAT_COLOR)) & 
                       DRF_MASK(NV047_SET_OVERLAY_FORMAT_COLOR));
            
            pOverlayHalObj->Overlay[buffNum].DisplayWhen  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_FORMAT_DISPLAY)) & 
                       DRF_MASK(NV047_SET_OVERLAY_FORMAT_DISPLAY));


            // call the kickoff proc
			pOverlayHalObj->KickOffProc(pHalHwInfo, pOverlayHalObj, buffNum);

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT_A:
        {
            U032 x, y;

            x = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_X)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_X);
            y = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_Y)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_Y);
            // Setup the window start in both the overlay buffers. 
            pOverlayHalObj->Overlay[0].WindowStart = 
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, x) |
                DRF_NUM(_PVIDEO, _WINDOW_START, _Y, y); 
            pOverlayHalObj->Overlay[1].WindowStart = 
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, x) |
                DRF_NUM(_PVIDEO, _WINDOW_START, _Y, y); 

            // Actually write these values to the hardware right away.
            // There will not be a  notify method to kick this off.
            REG_WR32(NV_PVIDEO_WINDOW_START, pOverlayHalObj->Overlay[0].WindowStart);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines.
//
//---------------------------------------------------------------------------

//
// class047 exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
RM_STATUS class047GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoGetEventStatusArg->pHalObjInfo;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoServiceEvent handler.
    //    
    pVideoGetEventStatusArg->events = 0;

    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoGetEventStatusArg->intrStatus = intr0;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {

        // Reset the pending bit right away. This way, if another buffer completion becomes pending
        // while we are servicing the current buffer completion, it will not be lost. 
        // This is the best we can do to close this window.
        // We will return intr_notify_pending state so if another interrupt happened, 
        // we will be called again.
        REG_WR32(NV_PVIDEO_INTR_0, NV_PVIDEO_INTR_0_NOTIFY_RESET);
        
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif

        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 0 pending if notify has been setup.
                if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 0);
            }
        }
        
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 1 pending if notify has been setup.
                if (pOverlayHalObj->Overlay[1].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 1);
            }
        }
    }

    return RM_OK;
}

//
// class047 exception handler
//
// This interface relies on values setup by the nvHalVideoGetEventStatus
// interface (i.e. the PVIDEO_INTR_0 register contents).  We go to the
// hardware to get the rest of it.
//
RM_STATUS class047ServiceEvent_NV04(PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    PHWREG nvAddr;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;
    nvAddr = pHalHwInfo->nvBaseAddr;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoServiceEventArg->pHalObjInfo;

    //
    // The pending interrupt register value was saved off by the
    // GetEventStatus entry point.
    //
    intr0 = pVideoServiceEventArg->intrStatus;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif

        //
        // Buffer 0.
        //
        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
                if (pVideoServiceEventArg->events & (1 << 0))
                    pOverlayHalObj->Overlay[0].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING                  


                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pOverlayHalObj->Overlay[1].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 1 is ready. Kick it off.
                    class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 1 /* buffNum */);
                }
                else
                {
                    // Software buffer 1 is not ready.
                    // Program OE and SU so that the hardware flips to 0 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (0 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 0 itself is busy again. Load the new values.
                    if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_BUSY)
                    {
                        class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 0 /* buffNum */);
                    } // buffer 0 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 0 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("0R");
#endif
                    } // redisplay buffer 0 values
                } // Buffer 1 is not busy    
                        
                // Return the current interrupt pending state.
                // intr0 = REG_RD32(NV_PVIDEO_INTR_0);
                // return(intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING));
            } // Hardware says buffer 0 completed.
        }

        //
        // Buffer 1.
        //
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {
                if (pVideoServiceEventArg->events & (1 << 1))
                    pOverlayHalObj->Overlay[1].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING                  

                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 0 is ready. Kick it off.
                    class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 0 /* buffNum */);
                }
                else
                {
                    // Software buffer 0 is not ready.
                    // Program OE and SU so that the hardware flips to 1 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (1 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 1 itself is busy again. Load the new values.
                    if (pOverlayHalObj->Overlay[1].State == OVERLAY_BUFFER_BUSY)
                    {
                        class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 1 /* buffNum */);
                    } // Buffer 1 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 1 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("1R");
#endif
                    } // Redisplay buffer 1 values
                } // Buffer 0 is not busy    
            } // Hardware says buffer 1 completed.
        }

#ifdef DEBUG_TIMING
        // Grab the current states again and print it.
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);

        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateOE = ",stateOE);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateSU = ",stateSU);
        DBG_PRINT_STRING_VALUE (0x10, "                                                   stateRM = ",stateRM);
#endif
    }  // Notify was pending
    
    // Return the current interrupt pending state.
    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoServiceEventArg->intrStatus = intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c04dnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: C04DNV04.C                                                        *
*   This module implements the chip-dependent portion of the                *
*   NV_EXTERNAL_VIDEO_DECODER object class and its corresponding methods.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv4/mpnv04.c.
//
RM_STATUS class04DMethod_NV04(PMPMETHODARG_000);
RM_STATUS class04DGetEventStatus_NV04(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04DServiceEvent_NV04(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv4/mpnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04DFindNearestScaleFactor(
    U032 dwRealDivisor,
    U032 *dwSpecialIndex
)
{
    U032 dwIndex=0;
    U032 X_ScaleFactors[] = { 1,2,3,4,6,8,12,16,24, 0xFFFF };

    //
    // Converts dwRealDivisor into an index which will point to nearest best quality divisor,
    //  will always be greater than RealDivisor if not equal
    //
    *dwSpecialIndex = 0xFFFF;
    
    while (X_ScaleFactors[dwIndex] != 0xFFFF)
    {
        if (dwRealDivisor >= X_ScaleFactors[dwIndex])
                *dwSpecialIndex = dwIndex;
        dwIndex++;
    }   

    // this should never occur
    if (*dwSpecialIndex == 0xFFFF)
        {
        *dwSpecialIndex = 1; // could not find index so just do a verbatim copy
        return (RM_ERROR);
        }

    return (RM_OK);
}
    
static RM_STATUS class04DCalculateScaleIncrement(
    U032 WidthIn,
    U032 HeightIn,
    U032 WidthOut,
    U032 HeightOut,
    U032 *ScaleFactor
)
{
    U032        FittedX, FittedY;
    U032        NearestScaleFactor;
    U032        X_ScaleFactors[]  = { 1,2,3,4,6,8,12,16,24, 0xFFFF };
    U032        X_n0[]            = { 0<<5,1<<5,2<<5,2<<5,3<<5,3<<5,4<<5,4<<5,5<<5, 0xFFFF};
    U032        X_n1[]            = { 0<<8,1<<8,1<<8,2<<8,2<<8,3<<8,3<<8,4<<8,4<<8, 0xFFFF};
    RM_STATUS   status;

    if (WidthOut == 0)
        WidthOut = WidthIn; // if this is too big, should be caught on length boundary

    FittedX = WidthIn / WidthOut;

    if (FittedX > 24)
        FittedX = 24; // max out scale 

    status = class04DFindNearestScaleFactor(FittedX, &NearestScaleFactor);
    if (status)
        return (status);
        
    FittedX = X_ScaleFactors[ NearestScaleFactor ] | X_n0[ NearestScaleFactor ] 
                                | X_n1[ NearestScaleFactor ] ;

    if (HeightOut == 0)
        HeightOut = HeightIn;

    FittedY = ((HeightOut -1 ) << 10) / (HeightIn - 1) ;
                                        
    if (FittedY > 0x400)
        FittedY = 0x400; // check these values (2^11 - 1), bloody small picture!!               

    *ScaleFactor = (FittedY << 16) | FittedX;

    return (RM_OK);
}

        
static RM_STATUS class04DStartVbi
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PMPHALINFO_NV04 pMpHalPvtInfo;
    V032 stateSU, stateME;

    pMpHalPvtInfo = (PMPHALINFO_NV04)pHalHwInfo->pMpHalPvtInfo;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartVbi\r\n");

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old
    // class66 overwrites)
    //
    // only change the bus mode if there isn't a decompressor object
    // using the MPC
    //

    if ( pMpHalPvtInfo->CurrentDecompressor == 0 )
        FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _CCIR656);

    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VBI_MODE, _2);
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _IMAGE, _ENABLED);  // also need to enable image (from Joe Yeun)
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VBI_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetVbi[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_VBI_BUFF0_START, pDecoderHalObj->SetVbi[0].Offset
                                       + (pDecoderHalObj->SetVbi[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_VBI_BUFF0_PITCH, pDecoderHalObj->SetVbi[0].Pitch);
        REG_WR32(NV_PME_VBI_BUFF0_LENGTH, pDecoderHalObj->SetVbi[0].Pitch * pDecoderHalObj->SetVbi[0].Height);
    } 
    else
    {
        REG_WR32(NV_PME_VBI_BUFF1_START, pDecoderHalObj->SetVbi[1].Offset
                                       + (pDecoderHalObj->SetVbi[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_VBI_BUFF1_PITCH, pDecoderHalObj->SetVbi[1].Pitch);
        REG_WR32(NV_PME_VBI_BUFF1_LENGTH, pDecoderHalObj->SetVbi[1].Pitch * pDecoderHalObj->SetVbi[1].Height);
    } 
    
    //
    // Program the global VBI settings
    //
    FLD_WR_DRF_NUM(_PME, _VBI, _START_LINE, pDecoderHalObj->SetVbi[1].FirstLine);
    FLD_WR_DRF_NUM(_PME, _VBI, _NUM_LINES, pDecoderHalObj->SetVbi[1].Height);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_VBI_SU_STATE);
    stateME = REG_RD32(NV_PME_VBI_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_VBI_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF0_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_VBI_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_VBI_SU_STATE, stateSU);
    }

    return(RM_OK);
}


static RM_STATUS class04DStartImage
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PMPHALINFO_NV04 pMpHalPvtInfo;
    V032        stateSU, stateME;
    U032        ScaleFactor;
    RM_STATUS   status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage\r\n");

    pMpHalPvtInfo = (PMPHALINFO_NV04)pHalHwInfo->pMpHalPvtInfo;

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old class66 overwrites)
    //
    if ( pMpHalPvtInfo->CurrentDecompressor == 0 )
        FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _CCIR656);

    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _IMAGE, _ENABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _IMAGE_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetImage[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Calculate the scale factors given the in & out sizes
    //
    status = class04DCalculateScaleIncrement(
                pDecoderHalObj->SetImage[0].WidthIn,
                pDecoderHalObj->SetImage[0].HeightIn,
                pDecoderHalObj->SetImage[0].WidthOut,
                pDecoderHalObj->SetImage[0].HeightOut,
                &ScaleFactor);
    if (status)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04DFindNearestScaleFactor, cannot find nearest scale factor !\r\n");
        return (status);
    }

    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_IMAGE_BUFF0_START, pDecoderHalObj->SetImage[0].Offset
                                         + (pDecoderHalObj->SetImage[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_IMAGE_BUFF0_PITCH, pDecoderHalObj->SetImage[0].Pitch);
        REG_WR32(NV_PME_IMAGE_BUFF0_LENGTH, pDecoderHalObj->SetImage[0].Pitch * pDecoderHalObj->SetImage[0].HeightOut);
        
        REG_WR32(NV_PME_IMAGE_BUFF0_SCALE_INCR, ScaleFactor);
    } 
    else
    {
        REG_WR32(NV_PME_IMAGE_BUFF1_START, pDecoderHalObj->SetImage[1].Offset
                                         + (pDecoderHalObj->SetImage[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_IMAGE_BUFF1_PITCH, pDecoderHalObj->SetImage[1].Pitch);
        REG_WR32(NV_PME_IMAGE_BUFF1_LENGTH, pDecoderHalObj->SetImage[1].Pitch * pDecoderHalObj->SetImage[1].HeightOut);
        
        REG_WR32(NV_PME_IMAGE_BUFF1_SCALE_INCR, ScaleFactor);
    } 
    
    //
    // Program the global image settings
    //
    REG_WR_DRF_NUM(_PME, _IMAGE_Y_CROP, _STARTLINE, pDecoderHalObj->ImageStartLine);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_IMAGE_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_FIELD));
            
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    }
    
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DMethod_NV04(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data, buffNum;

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04D_STOP_TRANSFER_VBI:
            //
            // As per Joe Yuen email comments 10/30/98
            // You can force termination immediately by writing CONFIG_0_IMAGE
            // to DISABLED and CONFIG_0_VBI_MODE to DISABLED. This will stop
            // capture, flush the internal FIFOs, and set the error codes in
            // IMAGE_ME_STATE and VBI_ME_STATE to DISABLED (which you can
            // choose to ignore).
            //
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VBI_MODE, _DISABLED);
    
            // silly us forgetting to disable interrupts before we should
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VBI_NOTIFY, _DISABLED);
    
            // return things to a known state...
            // even though a buffer may STILL be running
            REG_WR32(NV_PME_VBI_ME_STATE, 0);
            REG_WR32(NV_PME_VBI_SU_STATE, 0);
            REG_WR32(NV_PME_VBI_RM_STATE, 0);
            break;
        case NV04D_STOP_TRANSFER_IMAGE:
            //
            // As per Joe Yuen email comments 10/30/98
            // You can force termination immediately by writing CONFIG_0_IMAGE
            // to DISABLED and CONFIG_0_VBI_MODE to DISABLED. This will stop
            // capture, flush the internal FIFOs, and set the error codes
            // in IMAGE_ME_STATE and VBI_ME_STATE to DISABLED (which you
            // can choose to ignore).
            //
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _IMAGE, _DISABLED);
         
            // silly us forgetting to disable interrupts before we should
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _IMAGE_NOTIFY, _DISABLED);
    
            // return things to a known state...
            // even though a buffer may STILL be running
            REG_WR32(NV_PME_IMAGE_ME_STATE, 0);
            REG_WR32(NV_PME_IMAGE_SU_STATE, 0);
            REG_WR32(NV_PME_IMAGE_RM_STATE, 0);
            break;
        case NV04D_SET_IMAGE_START_LINE:
            //
            // Load the local copy, but don't hit the hardware until
            // we actually need it
            //
            pDecoderHalObj->ImageStartLine = data;
            break;
        case NV04D_SET_VBI_SIZE(0):
        case NV04D_SET_VBI_SIZE(1):
            buffNum = (offset == NV04D_SET_VBI_SIZE(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].FirstLine = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Height    = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_VBI_OFFSET(0):
        case NV04D_SET_VBI_OFFSET(1):
            buffNum = (offset == NV04D_SET_VBI_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Offset = data;
            break;
        case NV04D_SET_VBI_FORMAT(0):
        case NV04D_SET_VBI_FORMAT(1):
            buffNum = (offset == NV04D_SET_VBI_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetVbi[buffNum].Notify = ((data >> 24) & 0xFF);
            //
            // Kick it off!!
            //
            class04DStartVbi(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_VBI_OFFSET_NOTIFY(0):
        case NV04D_GET_VBI_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_VBI_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].GetOffsetData = REG_RD32(NV_PME_FIFO_CURRENT);
            break;
        case NV04D_SET_IMAGE_SIZE_IN(0):
        case NV04D_SET_IMAGE_SIZE_IN(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_IN(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthIn  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightIn = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_SIZE_OUT(0):
        case NV04D_SET_IMAGE_SIZE_OUT(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_OUT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthOut  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightOut = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_OFFSET(0):
        case NV04D_SET_IMAGE_OFFSET(1):
            buffNum = (offset == NV04D_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Offset = data;
            break;
        case NV04D_SET_IMAGE_FORMAT(0):
        case NV04D_SET_IMAGE_FORMAT(1):
            buffNum = (offset == NV04D_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetImage[buffNum].Notify = ((data >> 24) & 0xFF);
            
            //
            // Kick it off
            //
            class04DStartImage(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(0):
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_IMAGE_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].GetOffsetData = REG_RD32(NV_PME_FIFO_CURRENT);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04D_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVbiEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _RESET));

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_VBI_ME_STATE);
    stateSU = REG_RD32(NV_PME_VBI_SU_STATE);
    stateRM = REG_RD32(NV_PME_VBI_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_VBI_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_VBI_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_VBI_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_VBI_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVbiEvents\n");

    return;
}

static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
    
        // clear the interrupt, in case another shows up!
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));
        
    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(0))
    {
        pDecoderHalObj->SetImage[0].Info32 = 0;
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(0);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_IMAGE_BUFF0_START );
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(1))
    {
        pDecoderHalObj->SetImage[1].Info32 = 0;
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(1);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_IMAGE_BUFF1_START );
            }
        }
    }   

    *pEventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}

//
// class04DGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04DGetEventStatus_NV04
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending VBI/IMAGE events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // No current decoder object, so treat exception as spurious.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _RESET));
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));
        pMpGetEventStatusArg->events = 0;
        return (RM_ERROR);
    }

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _PENDING))
            GetVbiEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    }
    if (eventsPending & (CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04DServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04DServiceEvent_NV04
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04D_VBI_EVENT(0):
            stateRM = REG_RD32(NV_PME_VBI_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_VBI_RM_STATE, stateRM);
            break;
        case CLASS04D_VBI_EVENT(1):
            stateRM = REG_RD32(NV_PME_VBI_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_VBI_RM_STATE, stateRM);
            break;
        case CLASS04D_IMAGE_EVENT(0):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
        case CLASS04D_IMAGE_EVENT(1):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\modular\nv4\c04env04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DO_INTERRUPT_TIMING
U032 timePrev = 0;
#endif

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv4/mpnv04.c.
//
RM_STATUS class04EMethod_NV04(PMPMETHODARG_000);
RM_STATUS class04EGetEventStatus_NV04(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04EServiceEvent_NV04(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv4/mpnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04EStartVidRead
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif
        
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartVidRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartVidRead detected unexpected interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old class66 overwrites)
    //
    REG_WR32(NV_PME_EXTERNAL(2), 6);    /* disable MPC polling */
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _VMI);
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _ENABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VID_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
#if 0
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace == ADDR_SYSMEM)
    {
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _SYS)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _PCI));

        if (Buffer == 0)
        {
            REG_WR32(NV_PME_VID_BUFF0_START_SYS, pDecompHalObj->ReadData[0].Offset
                                               + (U032)pDecompHalObj->ReadData[0].CtxDma->BufferBase
                                               + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
        } 
        else
        {
            REG_WR32(NV_PME_VID_BUFF1_START_SYS, pDecompHalObj->ReadData[1].Offset
                                               + (U032)pDecompHalObj->ReadData[1].CtxDma->BufferBase
                                               + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
        } 

    }
    else if (pDecompHalObj->ContextDmaData[Buffer]->AddressSpace == ADDR_AGPMEM)
    {
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _SYS)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _AGP));
    }
    else
    {
#endif
        // FB_MEM
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _PNVM)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _PCI));
                            
        if (Buffer == 0)
        {
            REG_WR32(NV_PME_VID_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                                                + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
        } 
        else
        {
            REG_WR32(NV_PME_VID_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                                                + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
        } 
#if 0                                
    }
#endif    
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_VID_SU_STATE);
    stateME = REG_RD32(NV_PME_VID_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_VID_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_VID_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_VID_SU_STATE, stateSU);
    }

    //
    // we also need to enable Audio in order for Video to work (NV4 only)
    //
    if ( IsNV4_NV04(pHalHwInfo->pMcHalInfo) ) {
        REG_WR32(NV_PME_AUD_ME_STATE, 0);
        stateSU = (1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF0_IN_USE)) |
                  (1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF1_IN_USE));
        REG_WR32(NV_PME_AUD_SU_STATE, stateSU);
    }

    //
    // enable MPC polling
    //
    REG_WR32(NV_PME_EXTERNAL(2), 7);
    
    return(RM_OK);
}

static RM_STATUS class04EStartAudRead
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartAudRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartAudRead detected unexpected interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old class66 overwrites)
    //
    REG_WR32(NV_PME_EXTERNAL(2), 0x26); /* disable MPC polling */
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _VMI);
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _AUD_CD, _ENABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _AUD_NOTIFY, _ENABLED);
    
    {
        // FB_MEM
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _PNVM)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _PCI));
                            
        if (Buffer == 0)
        {
            REG_WR32(NV_PME_AUD_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                                                + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

            REG_WR32(NV_PME_AUD_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
        } 
        else
        {
            REG_WR32(NV_PME_AUD_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                                                + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

            REG_WR32(NV_PME_AUD_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
        } 
                                
    }
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_AUD_SU_STATE);
    stateME = REG_RD32(NV_PME_AUD_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_VID_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_AUD_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_AUD_SU_STATE, stateSU);
    }

    //
    // we also need to enable Video in order for Audio to work (NV4 only)
    //
    if ( IsNV4_NV04(pHalHwInfo->pMcHalInfo) ) {
        REG_WR32(NV_PME_VID_ME_STATE, 0);
        stateSU = (1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF0_IN_USE)) |
                  (1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF1_IN_USE));
        REG_WR32(NV_PME_VID_SU_STATE, stateSU);
    }

    //
    // enable MPC polling
    //
    REG_WR32(NV_PME_EXTERNAL(2), 0x27);
    
    return(RM_OK);
}

static RM_STATUS class04EStartWrite
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    U032 stateSU, stateME;
    U032 size;

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //
    //
    // Spend some time to validate all data
    //

    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    // For now, assume we are contiguous and in fb memory
    //
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace == ADDR_FBMEM)
    {
        if (Buffer == 0)
        {
            REG_WR32(NV_PME_IMAGE_BUFF0_START, (U032)(pDecompHalObj->WriteImage[0].Offset
                                               // TO DO: this is a known truncation for IA64
                                             + (SIZE_PTR)pDecompHalObj->WriteImage[0].CtxDma->BufferBase
                                             + pDecompHalObj->WriteImage[0].CtxDma->PteAdjust));

            REG_WR32(NV_PME_IMAGE_BUFF0_PITCH, pDecompHalObj->WriteImage[0].FormatOut & 0xFFFF);

            size = (pDecompHalObj->WriteImage[0].Size & 0xFFFF) * (pDecompHalObj->WriteImage[0].Size >> 16);
            REG_WR32(NV_PME_IMAGE_BUFF0_LENGTH, size);
        } 
        else
        {
            REG_WR32(NV_PME_IMAGE_BUFF1_START, (U032)(pDecompHalObj->WriteImage[1].Offset
                                               // TO DO: this is a known truncation for IA64
                                             + (SIZE_PTR)pDecompHalObj->WriteImage[1].CtxDma->BufferBase
                                             + pDecompHalObj->WriteImage[1].CtxDma->PteAdjust));

            REG_WR32(NV_PME_IMAGE_BUFF1_PITCH, pDecompHalObj->WriteImage[1].FormatOut & 0xFFFF);

            size = (pDecompHalObj->WriteImage[1].Size & 0xFFFF) * (pDecompHalObj->WriteImage[1].Size >> 16);
            REG_WR32(NV_PME_IMAGE_BUFF1_LENGTH, size);
        } 

    }
    else 
        ;// NOT SUPPORTED!!!
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    if (Buffer != (stateME >> 24))
        REG_WR32(NV_PME_IMAGE_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    }

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04EMethod_NV04(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    U032 buffNum;

    pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04E_STOP_TRANSFER:
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VID_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _AUD_CD, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _AUD_NOTIFY, _DISABLED);

            REG_WR32(NV_PME_VID_SU_STATE, 0);
            REG_WR32(NV_PME_VID_ME_STATE, 0);
            REG_WR32(NV_PME_VID_RM_STATE, 0);
            REG_WR32(NV_PME_VID_CURRENT, 0);
            REG_WR32(NV_PME_AUD_SU_STATE, 0);
            REG_WR32(NV_PME_AUD_ME_STATE, 0);
            REG_WR32(NV_PME_AUD_RM_STATE, 0);
            REG_WR32(NV_PME_AUD_CURRENT, 0);

            // XXX make sure the MPC's FIFO's are empty
            REG_WR32(NV_PME_EXTERNAL(2), 6);    /* disable MPC polling */
            break;
        case NV04E_SET_DATA_OFFSET(0):
        case NV04E_SET_DATA_OFFSET(1):
            buffNum = (offset == NV04E_SET_DATA_OFFSET(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Offset = data;
            //
            // Go ahead and write the start address .
            // (write both and aud and vid registers since we
            // don't know which one we'll use yet)
            // 
            if (buffNum == 0) {
                REG_WR32(NV_PME_VID_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                         + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);
                REG_WR32(NV_PME_AUD_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                         + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);
            } 
            else {
                REG_WR32(NV_PME_VID_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                         + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);
                REG_WR32(NV_PME_AUD_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                         + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);
            } 
            break;
        case NV04E_SET_DATA_LENGTH(0):
        case NV04E_SET_DATA_LENGTH(1):
            buffNum = (offset == NV04E_SET_DATA_LENGTH(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Size = data;
            //
            // go ahead and write the length
            // (use audio engine if size < 4K)
            // 
            if (buffNum == 0) {
                if ( data < 4096 ) {
                    REG_WR32(NV_PME_AUD_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
                    REG_WR32(NV_PME_VID_BUFF0_LENGTH, 0);
                }
                else {
                    REG_WR32(NV_PME_AUD_BUFF0_LENGTH, 0);
                    REG_WR32(NV_PME_VID_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
                }
            } 
            else {
                if ( data < 4096 ) {
                    REG_WR32(NV_PME_AUD_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
                    REG_WR32(NV_PME_VID_BUFF1_LENGTH, 0);
                }
                else {
                    REG_WR32(NV_PME_AUD_BUFF1_LENGTH, 0);
                    REG_WR32(NV_PME_VID_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
                }
            }
            break;
        case NV04E_SET_DATA_NOTIFY(0):
        case NV04E_SET_DATA_NOTIFY(1):
            buffNum = (offset == NV04E_SET_DATA_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Notify = data;

            //
            // KICK IT OFF!!
            //
            if (pDecompHalObj->ReadData[buffNum].Size < 4096) {
                class04EStartAudRead(pHalHwInfo, pDecompHalObj, buffNum);
            }
            else {
                class04EStartVidRead(pHalHwInfo, pDecompHalObj, buffNum);
            }
            break;
        case NV04E_SET_IMAGE_FORMAT_IN(0):
        case NV04E_SET_IMAGE_FORMAT_IN(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_IN(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatIn = data;
            break;
        case NV04E_SET_IMAGE_SIZE(0):
        case NV04E_SET_IMAGE_SIZE(1):
            buffNum = (offset == NV04E_SET_IMAGE_SIZE(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Size = data;
            break;
        case NV04E_SET_IMAGE_OFFSET_OUT(0):
        case NV04E_SET_IMAGE_OFFSET_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_OFFSET_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Offset = data;
            break;
        case NV04E_SET_IMAGE_FORMAT_OUT(0):
        case NV04E_SET_IMAGE_FORMAT_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatOut = data;
            break;
        case NV04E_SET_IMAGE_NOTIFY(0):
        case NV04E_SET_IMAGE_NOTIFY(1):
            buffNum = (offset == NV04E_SET_IMAGE_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Notify = data;
            //
            // Kick it off
            //
            class04EStartWrite(pHalHwInfo, pDecompHalObj, buffNum);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVideoEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    // pause any transfers that might be going
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _DISABLED);

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_VID_ME_STATE);
    stateSU = REG_RD32(NV_PME_VID_SU_STATE);
    stateRM = REG_RD32(NV_PME_VID_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _RESET));

#ifdef DEBUG
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EVideoNotify couldn't reset interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    // buffer 0
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVideoEvents\n");

    return;
}

static VOID GetAudioEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    // pause any transfers that might be going
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _AUD_CD, _DISABLED);

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_AUD_ME_STATE);
    stateSU = REG_RD32(NV_PME_AUD_SU_STATE);
    stateRM = REG_RD32(NV_PME_AUD_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _RESET));

#ifdef DEBUG
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EVideoNotify couldn't reset interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    // buffer 0
    if (*pEventsPending & CLASS04E_AUDIO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_AUDIO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_AUDIO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_AUDIO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetAudioEvents\n");

    return;
}

#ifdef NOTYET
static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
        return ;
    }

    //
    // Grab the c