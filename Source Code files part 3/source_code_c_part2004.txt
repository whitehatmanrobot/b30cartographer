-----------------------
void CXdsMain::ConstructReflectionResponse( PacketNode *pNode , BYTE* pbytResp, DWORD *pcResp )
{
    FILETIME *pftCurrent = NULL;
    CEnetHdr* pEHdr = NULL;
    CIpHdr* pIpHdr = NULL;
    CUdpHdr* pUdpHdr = NULL;
    XDS_REFLECTION_REPLY *pRef = NULL;
    XDS_REFLECTION_REQUEST *pReqMsg = NULL;
    BYTE *pPayload = NULL;
    DWORD dwHdrOffset = 0;

    XOMASSERT( pNode );
    XOMASSERT( pbytResp );
    XOMASSERT( pcResp );
    XOMASSERT( *pcResp > c_dwMAX_MTU_ETHERNET );

    dwHdrOffset = PACKET_DATA_OFFSET( pNode->m_Data );

    // set pointers for easier access.
    pIpHdr      = (CIpHdr*)( pbytResp + dwHdrOffset );
    pUdpHdr     = (CUdpHdr*)( pbytResp + dwHdrOffset + sizeof(CIpHdr) );
    pRef        = (XDS_REFLECTION_REPLY*)( pbytResp + dwHdrOffset + sizeof(CIpHdr) + sizeof(CUdpHdr) );
    pPayload    = (BYTE*)( pbytResp + dwHdrOffset + sizeof(CIpHdr) + sizeof(CUdpHdr) + sizeof(XDS_REFLECTION_REPLY) );
    pftCurrent  = (FILETIME*)&(pRef->_qwTimeStamp);
    pReqMsg     = ((XDS_REFLECTION_REQUEST*)(pNode->GetMsg()));

    *pcResp = pReqMsg->_wReturnPacketSize + dwHdrOffset + sizeof(CIpHdr) + sizeof(CUdpHdr);

    // setup the ethernet header.  
    SetupEthernetHeader( pNode, pbytResp, *pcResp );
    
    // get the current time.
    GetSystemTimeAsFileTime( pftCurrent );

    // calculate the SHA1 HMAC
    SHA1HMAC( pNode->GetIPHdr()->_ipaSrc, *((ULONGLONG*)pftCurrent), (BYTE*)(pRef->_abIPTimeStampSig) );

    // set up the ip hdr
    pIpHdr->_bVerHdr        = 0x45;
    pIpHdr->_bTos           = m_bTOS;
    pIpHdr->_wLen           = HTONS( (USHORT)(*pcResp - dwHdrOffset) );
    pIpHdr->_wId            = 0;
    pIpHdr->_wFragOff       = 0;
    pIpHdr->_bTtl           = m_bTTL;
    pIpHdr->_bProtocol      = IPPROTO_UDP;
    pIpHdr->_wChecksum      = 0;
    pIpHdr->_ipaDst         = pNode->GetIPHdr()->_ipaSrc;

    // setup the UDP hdr
    pUdpHdr->_wLen          = HTONS( (WORD)(*pcResp - dwHdrOffset - sizeof(CIpHdr)) );
    pUdpHdr->_wChecksum     = 0;
    pUdpHdr->_ipportDst     = pNode->GetUDPHdr()->_ipportSrc;

    // fill in the reply msg
    pRef->_cReturnPayload   = pReqMsg->_wLengthOfReturnPayload;
    pRef->_dwClientSourceIP = pNode->GetIPHdr()->_ipaSrc;
    pRef->_wClientSourcePort= pNode->GetUDPHdr()->_ipportSrc;

    // add the payload
    memcpy( (void*)pPayload, (void*)( pNode->GetMsg() + sizeof(XDS_REFLECTION_REQUEST)), pReqMsg->_wLengthOfReturnPayload );

    // zero-pad
    ZeroMemory( (void*)(pPayload + pReqMsg->_wLengthOfReturnPayload),
                (pReqMsg->_wReturnPacketSize - sizeof(XDS_REFLECTION_REPLY) - pReqMsg->_wLengthOfReturnPayload ));


    // determine the additional changes we should make.  Including who
    //    we should send it too.
    switch( pReqMsg->_wRequestType )
    {
    case REFLECT_SAMEIPPORT:
        {
            pIpHdr->_ipaSrc = pNode->GetIPHdr()->_ipaDst;
            pUdpHdr->_ipportSrc = pNode->GetUDPHdr()->_ipportDst;
        }
        break;
    case REFLECT_DIFFERENTIP:
        {
            DWORD dwOtherNicId = (pNode->m_dwNicId + 1) % (m_pNicMgr->GetNumOfNics());
            pIpHdr->_ipaSrc = m_pNicMgr->GetIpAddr( dwOtherNicId );
            pUdpHdr->_ipportSrc = pNode->GetUDPHdr()->_ipportDst;
        }
        break;
    case REFLECT_SAMEIP_DIFFERENTPORT:
        {
            pIpHdr->_ipaSrc = pNode->GetIPHdr()->_ipaDst;
            pUdpHdr->_ipportSrc._w = pNode->GetUDPHdr()->_ipportDst._w + 256;
        }
        break;
    default:
        XOMASSERT(FALSE);
    }

    // set the check sums
    CPseudoHeader pseudohdr;

    // ip hdr checksum
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, pIpHdr->GetHdrLen());

    // udp hdr checksum
    pseudohdr._ipaSrc    = pIpHdr->_ipaSrc;
    pseudohdr._ipaDst    = pIpHdr->_ipaDst;
    pseudohdr._bZero     = 0;
    pseudohdr._bProtocol = IPPROTO_UDP;
    pseudohdr._wLen      = pUdpHdr->_wLen;

    UINT uiChecksum     = ~tcpipxsum(tcpipxsum(0, &pseudohdr, sizeof(pseudohdr)), pUdpHdr, (WORD)(*pcResp - dwHdrOffset - sizeof(CIpHdr)));
    pUdpHdr->_wChecksum = uiChecksum - (uiChecksum == 0);

}

//------------------------------------------------------------------
//  ConstructICMPResponse:  builds an ICMP response for the client.
//------------------------------------------------------------------
void CXdsMain::ConstructICMPResponse( PacketNode *pNode , BYTE* pbytResp, DWORD *pcResp )
{
    HRESULT hr = S_OK;
    SYSTEMTIME *pstCurrent = NULL;
    CEnetHdr* pEHdr = NULL;
    CIpHdr* pIpHdr = NULL;
    CIcmpHdr* pIcmpHdr = NULL;
    CIpHdr* pDataPortion = NULL;
    CEnetAddr defaultgatewayEnet;
    DWORD dwHdrOffset = 0;
    
    XOMASSERT( pNode );
    XOMASSERT( pbytResp );
    XOMASSERT( pcResp );
    XOMASSERT( *pcResp > c_dwMAX_MTU_ETHERNET );

    dwHdrOffset = PACKET_DATA_OFFSET( pNode->m_Data );

    // set pointers for easier access.
    pEHdr                   = (CEnetHdr*)pbytResp;
    pIpHdr                  = (CIpHdr*)( pbytResp + dwHdrOffset );
    pIcmpHdr                = (CIcmpHdr*)( pbytResp + dwHdrOffset + sizeof(CIpHdr) );
    pDataPortion            = (CIpHdr*)( pbytResp + dwHdrOffset + sizeof(CIpHdr) + sizeof(CIcmpHdr));

    //  Size of packet
    *pcResp                 = dwHdrOffset + ( 2 * sizeof(CIpHdr) ) + sizeof(CIcmpHdr) + sizeof(CUdpHdr);

    // get the ethernet addr of the default gateway.
    defaultgatewayEnet.SetZero();
    if ( m_bUseArpThread )
    {
        hr = m_pNicMgr->GetDefaultGatewayEnetAddr( pNode->m_dwNicId, &defaultgatewayEnet);
        if ( FAILED(hr) )
        {
            XomNtEvent( XEVENT_XDS_CODE_59, "CXdsMain::ConstructICMPResponse:  Failed to attain the default gateway Ethernet Address from the NicMgr.  Id:  %d", pNode->m_dwNicId);
            XomTrace( Xds, L_ERROR, "CXdsMain::ConstructICMPResponse:  Failed to attain the default gateway Ethernet Address from the NicMgr.  Id:  %d", pNode->m_dwNicId);
        }
    }
    else
    {
        memcpy( defaultgatewayEnet._ab, (BYTE*)(pNode->GetEnetHdr()->_eaSrc._ab), sizeof(defaultgatewayEnet._ab) );
    }

    // setup the ethernet header.  
    SetupEthernetHeader( pNode, pbytResp, *pcResp );

    // set up the ethernet hdr to be the default gateway
    memcpy( &(pEHdr->_eaDst),  &(defaultgatewayEnet), sizeof(CEnetAddr) );

    // set up the ip hdr
    pIpHdr->_bVerHdr        = 0x45;
    pIpHdr->_bTos           = m_bTOS;
    pIpHdr->_wLen           = HTONS( (WORD)(*pcResp - dwHdrOffset) );
    pIpHdr->_wId            = 0;
    pIpHdr->_wFragOff       = 0;
    pIpHdr->_bTtl           = m_bTTL;
    pIpHdr->_bProtocol      = IPPROTO_ICMP;
    pIpHdr->_wChecksum      = 0;
    pIpHdr->_ipaDst         = pNode->GetIPHdr()->_ipaSrc;
    pIpHdr->_ipaSrc         = m_dwICMPReplyAddr;

    // ICMP payload.
    pIcmpHdr->_bType        = (BYTE)(ICMPTYPE_DESTINATION_UNREACHABLE);
    pIcmpHdr->_bCode        = (BYTE)(ICMPCODE_PORT_UNREACHABLE);
    pIcmpHdr->_wChecksum    = 0;
    pIcmpHdr->_dwData       = 0;

    memcpy( (BYTE*)pDataPortion, pNode->GetIPHdr(), sizeof( CIpHdr ) + sizeof(CUdpHdr) );
    pDataPortion->_ipaDst = m_dwICMPReplyAddr;
    pDataPortion->_wChecksum = 0;

    // set the check sums
    // ip hdr checksum
    pIpHdr->_wChecksum      = (WORD)~tcpipxsum(0, pIpHdr, pIpHdr->GetHdrLen());
    pDataPortion->_wChecksum= (WORD)~tcpipxsum(0, pDataPortion, pDataPortion->GetHdrLen());

    // icmp checksum
    pIcmpHdr->_wChecksum    = (WORD)~tcpipxsum(0, pIcmpHdr, sizeof(CIcmpHdr) + sizeof(CIpHdr) + sizeof(CUdpHdr));

}

//------------------------------------------------------------------
//  ConstructLogResponse:  builds a log response for the client.
//------------------------------------------------------------------
void CXdsMain::ConstructLogResponse( PacketNode *pNode , BYTE* pbytResp, DWORD *pcResp )
{
    SYSTEMTIME *pstCurrent = NULL;
    CIpHdr* pIpHdr = NULL;
    CUdpHdr* pUdpHdr = NULL;
    XDS_LOG_REPLY *pRef = NULL;
    XDS_LOG_REQUEST *pReqMsg = NULL;
    DWORD dwHdrOffset = 0;

    XOMASSERT( pNode );
    XOMASSERT( pbytResp );
    XOMASSERT( pcResp );
    XOMASSERT( *pcResp > c_dwMAX_MTU_ETHERNET );

    dwHdrOffset = PACKET_DATA_OFFSET( pNode->m_Data );

    // set pointers for easier access.
    pIpHdr      = (CIpHdr*)( pbytResp + dwHdrOffset );
    pUdpHdr     = (CUdpHdr*)( pbytResp + dwHdrOffset + sizeof(CIpHdr) );
    pRef        = (XDS_LOG_REPLY*)( pbytResp + dwHdrOffset + sizeof(CIpHdr) + sizeof(CUdpHdr) );
    pstCurrent  = (SYSTEMTIME*)&(pRef->_qwTimeStamp);
    pReqMsg     = ((XDS_LOG_REQUEST*)(pNode->GetMsg()));

    *pcResp      = dwHdrOffset + sizeof(CIpHdr) + sizeof(CUdpHdr) + sizeof(XDS_LOG_REPLY);

    // setup the ethernet header.  
    SetupEthernetHeader( pNode, pbytResp, *pcResp );

    // set up the ip hdr
    pIpHdr->_bVerHdr        = 0x45;
    pIpHdr->_bTos           = m_bTOS;
    pIpHdr->_wLen           = HTONS( (USHORT)(*pcResp - dwHdrOffset) );
    pIpHdr->_wId            = 0;
    pIpHdr->_wFragOff       = 0;
    pIpHdr->_bTtl           = m_bTTL;
    pIpHdr->_bProtocol      = IPPROTO_UDP;
    pIpHdr->_wChecksum      = 0;
    pIpHdr->_ipaDst         = pNode->GetIPHdr()->_ipaSrc;
    pIpHdr->_ipaSrc         = pNode->GetIPHdr()->_ipaDst;

    // setup the UDP hdr
    pUdpHdr->_wLen = HTONS((USHORT)(*pcResp - dwHdrOffset - sizeof(CIpHdr)));
    pUdpHdr->_wChecksum = 0;
    pUdpHdr->_ipportDst = pNode->GetUDPHdr()->_ipportSrc;
    pUdpHdr->_ipportSrc = pNode->GetUDPHdr()->_ipportDst;

    // fill in the reply msg
    // SEND BACK THE TIMESTAMP.
    pRef->_qwTimeStamp = pReqMsg->_qwTimeStamp;

    // set the check sums
    CPseudoHeader pseudohdr;

    // ip hdr checksum
    pIpHdr->_wChecksum   = (WORD)~tcpipxsum(0, pIpHdr, pIpHdr->GetHdrLen());

    // udp hdr checksum
    pseudohdr._ipaSrc    = pIpHdr->_ipaSrc;
    pseudohdr._ipaDst    = pIpHdr->_ipaDst;
    pseudohdr._bZero     = 0;
    pseudohdr._bProtocol = IPPROTO_UDP;
    pseudohdr._wLen      = pUdpHdr->_wLen;

    UINT uiChecksum      = ~tcpipxsum(tcpipxsum(0, &pseudohdr, sizeof(pseudohdr)), pUdpHdr, (USHORT)(*pcResp - dwHdrOffset - sizeof(CIpHdr)));
    pUdpHdr->_wChecksum  = uiChecksum - (uiChecksum == 0);

}

//------------------------------------------------------------------
//  ValidateReflectionRequest:  validate the contents of a
//      reflection request.
//------------------------------------------------------------------
HRESULT CXdsMain::ValidateReflectionRequest( XDS_REFLECTION_REQUEST *pReq, DWORD cReq, DWORD dwSrcIP )
{
    HRESULT hr = S_OK;

    if ( cReq < sizeof( XDS_REFLECTION_REQUEST ) )
    {
        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_wReturnPacketSize),
                (pReq->_wLengthOfReturnPayload),
                (cReq),
                XEVENT_XDS_HACK_7
            );

        hr = EventThrottle( dwSrcIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_8, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                pReq->_wProtocolVersion,
                pReq->_wRequestType,
                pReq->_wReturnPacketSize,
                pReq->_wLengthOfReturnPayload,
                cReq);
        }

        hr = E_FAIL;
        goto Exit;
    }

    if ( pReq->_wReturnPacketSize > ( sizeof(CIpHdr) + sizeof(CUdpHdr) + cReq ) )
    {
        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.  Packet too small tro request the required packet size.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_wReturnPacketSize),
                (pReq->_wLengthOfReturnPayload),
                (cReq),
                XEVENT_XDS_HACK_9
            );

        hr = EventThrottle( dwSrcIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_10, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.    Packet too small tro request the required packet size.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                pReq->_wProtocolVersion,
                pReq->_wRequestType,
                pReq->_wReturnPacketSize,
                pReq->_wLengthOfReturnPayload,
                cReq);
        }

        hr = E_FAIL;
        goto Exit;

    }

    // make sure the packet to send back is big enough and not too big.
    if ( pReq->_wReturnPacketSize > ( c_dwMAX_MTU_ETHERNET - sizeof(CIpHdr) - sizeof(CUdpHdr) )
        || pReq->_wReturnPacketSize < sizeof(XDS_REFLECTION_REPLY) )
    {
        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_wReturnPacketSize),
                (pReq->_wLengthOfReturnPayload),
                (cReq),
                XEVENT_XDS_HACK_11
            );

        hr = EventThrottle( dwSrcIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_12, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                pReq->_wProtocolVersion,
                pReq->_wRequestType,
                pReq->_wReturnPacketSize,
                pReq->_wLengthOfReturnPayload,
                cReq);
        }

        hr = E_FAIL;
        goto Exit;

    }

    // check the length of payload... must be less than expected response size.
    if ( pReq->_wLengthOfReturnPayload > pReq->_wReturnPacketSize - sizeof(XDS_REFLECTION_REPLY) )
    {
        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_wReturnPacketSize),
                (pReq->_wLengthOfReturnPayload),
                (cReq),
                XEVENT_XDS_HACK_13
            );

        hr = EventThrottle( dwSrcIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_14, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                pReq->_wProtocolVersion,
                pReq->_wRequestType,
                pReq->_wReturnPacketSize,
                pReq->_wLengthOfReturnPayload,
                cReq);
        }

        hr = E_FAIL;
        goto Exit;
    }

    // check the length of payload.  Must be less than the request size
    if ( pReq->_wLengthOfReturnPayload > (cReq - sizeof(XDS_REFLECTION_REQUEST) ) )
    {
        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_wReturnPacketSize),
                (pReq->_wLengthOfReturnPayload),
                (cReq),
                XEVENT_XDS_HACK_15
            );

        hr = EventThrottle( dwSrcIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_16, "CXdsMain::ValidateReflectionRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, ReturnPacketSize: %hd, LengthOfPayload: %hd, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwSrcIP))[0],
                ((BYTE*)&(dwSrcIP))[1],
                ((BYTE*)&(dwSrcIP))[2],
                ((BYTE*)&(dwSrcIP))[3],
                pReq->_wProtocolVersion,
                pReq->_wRequestType,
                pReq->_wReturnPacketSize,
                pReq->_wLengthOfReturnPayload,
                cReq);
        }

        hr = E_FAIL;
        goto Exit;
    }


Exit:
    return hr;
}

//------------------------------------------------------------------
//  ValidateICMPRequest:  validate the contents of a
//      reflection request.
//------------------------------------------------------------------
HRESULT CXdsMain::ValidateICMPRequest( XDS_ICMP_REQUEST *pReq, DWORD cReq, DWORD dwReqIP)
{
    HRESULT hr = S_OK;
    BYTE abSig[A_SHA_DIGEST_LEN];
    FILETIME ftCurrent = {0};
    FILETIME ftStamp = {0};
    ULONGLONG qwStamp = {0};
    char szHexSignature[ (sizeof(pReq->_abIPTimeStampSig) * 2) + 1] = {0};

    // the packet isn't big enough.
    if ( cReq < m_dwMinICMPRequestLength )
    {
        BinToHex( (char*)(pReq->_abIPTimeStampSig), sizeof(pReq->_abIPTimeStampSig), (char*)szHexSignature );
        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateICMPRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                (cReq),
                XEVENT_XDS_HACK_17
            );

        hr = EventThrottle( dwReqIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_18, "CXdsMain::ValidateICMPRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                (cReq)
            );
        }
        hr = E_FAIL;
        goto Exit;
    }

    GetSystemTimeAsFileTime( &ftCurrent );
    qwStamp = *((ULONGLONG*)&(pReq->_qwTimeStamp));

    // check the skew.
    if ( qwStamp + ( m_dwSkewTimeInMilliSecs * 10000 ) < *((ULONGLONG*)&ftCurrent) )
    {
        BinToHex( (char*)(pReq->_abIPTimeStampSig), sizeof(pReq->_abIPTimeStampSig), (char*)szHexSignature );
        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateICMPRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                (cReq),
                XEVENT_XDS_HACK_19
            );

        hr = EventThrottle( dwReqIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_20, "CXdsMain::ValidateICMPRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                (cReq)
            );
        }

        hr = E_FAIL;
        // perf counter invalid request timeskew
        g_Counters.IncrementValue32( XDS_INVALID_TIMESTAMP_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( XDS_INVALID_TIMESTAMP_COUNTER, 1);

        goto Exit;
    }

    // calculate what the SHAW hash should be.
    SHA1HMAC( dwReqIP, pReq->_qwTimeStamp, (BYTE*)abSig );

    // check the time stamp.
    if ( memcmp( abSig, pReq->_abIPTimeStampSig, sizeof(abSig) ) )
    {
        BinToHex( (char*)(pReq->_abIPTimeStampSig), sizeof(pReq->_abIPTimeStampSig), (char*)szHexSignature );
        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateICMPRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                (cReq),
                XEVENT_XDS_HACK_21
            );

        hr = EventThrottle( dwReqIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_22, "CXdsMain::ValidateICMPRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                (cReq)
            );
        }

        hr = E_FAIL;
        // perf counter invalid request
        g_Counters.IncrementValue32( XDS_INVALID_SIGNATURE_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( XDS_INVALID_SIGNATURE_COUNTER, 1);

        goto Exit;
    }

Exit:
    return hr;
}

//------------------------------------------------------------------
//  ValidateLogRequest:  validate the contents of a
//      log request.
//------------------------------------------------------------------
HRESULT CXdsMain::ValidateLogRequest( XDS_LOG_REQUEST *pReq, DWORD cReq, DWORD dwReqIP )
{
    HRESULT hr = S_OK;
    DWORD dwLogLength = min( pReq->_cLogPayload,  m_dwMaxLogLength );
    char szHexSignature[ (sizeof(pReq->_abIPTimeStampSig) * 2) + 1] = {0};
    char szXboxSerialNumber[ XBOX_SERIAL_NUMBER_LENGTH ] = {0};
    char szPayload[ c_dwMAX_MTU_ETHERNET - sizeof(CIpHdr) - sizeof(CUdpHdr) - sizeof(XDS_LOG_REQUEST)] = {0};

    // the packet isn't big enough.
    if ( cReq < m_dwMinLogRequestLength )
    {                
        BinToHex( (char*)pReq->_abIPTimeStampSig, sizeof(pReq->_abIPTimeStampSig), (char*)szHexSignature );
        MakePresentableOutput( (char*)szXboxSerialNumber, XBOX_SERIAL_NUMBER_LENGTH, pReq->_acXboxSerialNumber);
        MakePresentableOutput( szPayload, dwLogLength, (char*)( ((BYTE*)pReq) + sizeof(XDS_LOG_REQUEST) ));

        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateLogRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Xbox SN: %s, Size of LogData: %hd, LogData: %s, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                szXboxSerialNumber,
                (pReq->_cLogPayload),
                szPayload,
                (cReq),
                XEVENT_XDS_HACK_23
            );

        // throttle this ips events
        hr = EventThrottle( dwReqIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_24, "CXdsMain::ValidateLogRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Xbox SN: %s, Size of LogData: %hd, LogData: %s, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                szXboxSerialNumber,
                (pReq->_cLogPayload),
                szPayload,
                (cReq)
            );
        }

        hr = E_FAIL;
        goto Exit;
    }

    // validate the timeskew and time stamp just like the ICMP request.
    hr = ValidateICMPRequest((XDS_ICMP_REQUEST*) pReq, cReq, dwReqIP);
    if ( FAILED(hr) )
    {
        goto Exit;
    }

    // ensure the payload isn't too big.
    if ( pReq->_cLogPayload > m_dwMaxLogLength )
    {
        BinToHex( (char*)pReq->_abIPTimeStampSig, sizeof(pReq->_abIPTimeStampSig), (char*)szHexSignature );
        MakePresentableOutput( (char*)szXboxSerialNumber, XBOX_SERIAL_NUMBER_LENGTH, pReq->_acXboxSerialNumber);
        MakePresentableOutput( szPayload, dwLogLength, (char*)( ((BYTE*)pReq) + sizeof(XDS_LOG_REQUEST) ));

        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateLogRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Xbox SN: %s, Size of LogData: %hd, LogData: %s, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                szXboxSerialNumber,
                (pReq->_cLogPayload),
                szPayload,
                (cReq),
                XEVENT_XDS_HACK_25
            );

        // throttle this ips events
        hr = EventThrottle( dwReqIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_26, "CXdsMain::ValidateLogRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Xbox SN: %s, Size of LogData: %hd, LogData: %s, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                szXboxSerialNumber,
                (pReq->_cLogPayload),
                szPayload,
                (cReq)
            );
        }
        hr = E_FAIL;

        goto Exit;
    }

    // ensure the Xbox serial number valid.
    if ( !IsNumericASCII( (BYTE*)(pReq->_acXboxSerialNumber), sizeof(pReq->_acXboxSerialNumber)) )
    {
        BinToHex( (char*)pReq->_abIPTimeStampSig, sizeof(pReq->_abIPTimeStampSig), (char*)szHexSignature );
        MakePresentableOutput( (char*)szXboxSerialNumber, XBOX_SERIAL_NUMBER_LENGTH, pReq->_acXboxSerialNumber);
        MakePresentableOutput( szPayload, dwLogLength, (char*)( ((BYTE*)pReq) + sizeof(XDS_LOG_REQUEST) ));

        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateLogRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Xbox SN: %s, Size of LogData: %hd, LogData: %s, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                szXboxSerialNumber,
                (pReq->_cLogPayload),
                szPayload,
                (cReq),
                XEVENT_XDS_HACK_27
            );

        // throttle this ips events
        hr = EventThrottle( dwReqIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_28, "CXdsMain::ValidateLogRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Xbox SN: %s, Size of LogData: %hd, LogData: %s, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                szXboxSerialNumber,
                (pReq->_cLogPayload),
                szPayload,
                (cReq)
            );
        }

        hr = E_FAIL;
        goto Exit;
    }

    // ensure the payload is printable.
    if ( !IsPrintable( ((BYTE*)pReq)+ sizeof(XDS_LOG_REQUEST), pReq->_cLogPayload) )
    {
        BinToHex( (char*)pReq->_abIPTimeStampSig, sizeof(pReq->_abIPTimeStampSig), (char*)szHexSignature );
        MakePresentableOutput( (char*)szXboxSerialNumber, XBOX_SERIAL_NUMBER_LENGTH, pReq->_acXboxSerialNumber);
        MakePresentableOutput( szPayload, dwLogLength, (char*)( ((BYTE*)pReq) + sizeof(XDS_LOG_REQUEST) ));

        XomTrace( Xds, L_ERROR, "CXdsMain::ValidateLogRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Xbox SN: %s, Size of LogData: %hd, LogData: %s, Size of Request: %d, Event Id: 0x%X.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                szXboxSerialNumber,
                (pReq->_cLogPayload),
                szPayload,
                (cReq),
                XEVENT_XDS_HACK_29
            );

        // throttle this ips events
        hr = EventThrottle( dwReqIP );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_30, "CXdsMain::ValidateLogRequest:  Invalid request from %d.%d.%d.%d.  Protocol: %hd, RequestType: %hd, TimeStamp:0x%I64X, Signature: %40.40s, Xbox SN: %s, Size of LogData: %hd, LogData: %s, Size of Request: %d.  Blacklisting events for IP.",
                ((BYTE*)&(dwReqIP))[0],
                ((BYTE*)&(dwReqIP))[1],
                ((BYTE*)&(dwReqIP))[2],
                ((BYTE*)&(dwReqIP))[3],
                (pReq->_wProtocolVersion),
                (pReq->_wRequestType),
                (pReq->_qwTimeStamp),
                szHexSignature,
                szXboxSerialNumber,
                (pReq->_cLogPayload),
                szPayload,
                (cReq)
            );
        }

        hr = E_FAIL;
        goto Exit;
    }


Exit:
    return hr;
}

//------------------------------------------------------------------
//  GetAction:  Gets a action node from the bag.
//------------------------------------------------------------------
CXdsAction* CXdsMain::GetAction()
{
    XOMASSERT( m_pActionBag != NULL );
    return (CXdsAction*)( (BYTE*)(m_pActionBag->Alloc()) + (sizeof(DWORD)));
}

//------------------------------------------------------------------
//  ReleaseAction:  Releases an action node and puts it in the bag
//------------------------------------------------------------------
void CXdsMain::ReleaseAction( CXdsAction *pAction )
{
    XOMASSERT( pAction != NULL );
    pAction->Clean();

    m_pActionBag->Free( ((BYTE*)pAction - ( sizeof(DWORD)) ) );
}

//------------------------------------------------------------------
//  InitializeActionNodes:  Builds all nodes in the action node bag.
//------------------------------------------------------------------
HRESULT CXdsMain::InitializeActionNodes()
{
    HRESULT hr = S_OK;
    LIST_ENTRY tempList = {0};
    LIST_ENTRY *pEntry  = NULL;
    CXdsAction* pItem = NULL;

    // create a new bag of action nodes
    m_pActionBag = new CSNPool();
    if ( m_pActionBag == NULL )
    {
        XomTrace( Xds, L_ERROR, "CXdsMain::InitializeActionNodes:  Failed to get memory for Action node bag." );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // initialize the action bag
    hr = m_pActionBag->Init( sizeof(CXdsAction) + (sizeof(DWORD)) , m_dwPacketBufferSize );
    if ( FAILED(hr) )
    {
        XomTrace( Xds, L_ERROR, "CXdsMain::InitializeActionNodes:  Failed to initialize action node buffer.  RESULT = 0x%X", hr );
        goto Exit;
    }

    // recursively set up this set of nodes.
    CreateActionNode( );

Exit:
    return hr;
}

//------------------------------------------------------------------
// InitializeActionNode:  calls the init on the node.
//------------------------------------------------------------------
void CXdsMain::CreateActionNode()
{
    CXdsAction *pNext = NULL;
    BYTE *pbItem = NULL;
    LIST_ENTRY lh;

    InitializeListHead( &lh );

    // get all the nodes out and initialize.
    while ( ( pbItem = (BYTE*)( m_pActionBag->Alloc()) ) != NULL )
    {
        pNext = (CXdsAction*)( pbItem + (sizeof(DWORD)));
        pNext->CXdsAction::CXdsAction(this);
        InsertHeadList( &lh, (LIST_ENTRY*)pNext );
        pNext = NULL;
        pbItem = NULL;
    }

    while ( !IsListEmpty(&lh) )
    {
        pNext = (CXdsAction*)(lh.Flink);
        RemoveEntryList( (LIST_ENTRY*)pNext );
        m_pActionBag->Free( ((BYTE*)pNext - (sizeof(DWORD)) ) );
        pNext = NULL;
    }

}

//------------------------------------------------------------------
// DeleteActionNode:  calls the init on the node.
//------------------------------------------------------------------
void CXdsMain::DeleteActionNode( )
{
    CXdsAction *pNext = NULL;
    BYTE *pbItem = NULL;

    while ( ( pbItem = (BYTE*)(m_pActionBag->Alloc()) ) != NULL )
    {
        pNext = (CXdsAction*)( pbItem + (sizeof(DWORD)));
        pNext->CXdsAction::~CXdsAction();
    }
}

//------------------------------------------------------------------
//  CleanActionNodes:  calls destructor for all action nodes in bag.
//------------------------------------------------------------------
HRESULT CXdsMain::CleanActionNodes()
{
    HRESULT hr = S_OK;
    LIST_ENTRY *pItem = NULL;

    DeleteActionNode();

    // destroy the aciton bag and its contents.
    delete m_pActionBag;

    return hr;
}

//------------------------------------------------------------------
//  InitializeCallbacks:  Initializes callback with mgmt interface.
//------------------------------------------------------------------
void CXdsMain::InitializeCallbacks()
{
    HRESULT hr = S_OK;
    DWORD   dwX = 0;

    for ( dwX = 0; dwX < c_dwNumOfCommands;  dwX++ )
    {
        hr = m_pMgmtInterface->RegisterCommand( c_aCmdList[dwX] );
        if ( FAILED(hr) )
        {
            XomNtEvent( XEVENT_XDS_CODE_60,"CXdsMain::InitializeCallbacks:  Failed to initialize mgmt interface commands.  RESULT = 0x%X", hr );
            XomTrace( Xds, L_ERROR, "CXdsMain::InitializeCallbacks:  Failed to initialize mgmt interface commands.  RESULT = 0x%X", hr );
        }
    }
}

//-----------------------------------------------------------------------------
//  GetStringSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void CXdsMain::GetStringSetting( LPSTR pch, DWORD cch, CComBSTR bstrSettingName, const char *c_szDefault )
{
    CComBSTR bstrSetting;
    HRESULT hr = S_OK;

    XOMASSERT( pch != NULL );
    XOMASSERT( cch > 0 );
    
    // get the setting
    hr = m_pConfig->GetSetting( bstrSettingName, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        _snprintf( pch, cch, "%s\0", c_szDefault );

        XomTrace( Xds, L_WARNING,  "XDS:(Config)  Name: %ws, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", static_cast<wchar_t *> (bstrSettingName), pch, hr );
        XomNtEvent( XEVENT_XDS_CONFIG_3, "XDS:(Config)  Name: %ws Value (Default): %S.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", static_cast<wchar_t *> (bstrSettingName), pch, hr );
    }
    else
    {
        // copy the setting into the static buffer.
        _snprintf( pch, cch, "%S\0", bstrSetting ); 
        XomTrace( Xds, L_NORMAL,  "XDS:(Config)  Name: %ws, Value: %S.", static_cast<wchar_t *> (bstrSettingName), pch );
    }

    
 }

//-----------------------------------------------------------------------------
//  GetStringSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void CXdsMain::GetStringSetting( LPWSTR pch, DWORD cch, CComBSTR bstrSettingName, const WCHAR *c_wszDefault )
{
    CComBSTR bstrSetting;
    HRESULT hr = S_OK;

    XOMASSERT( pch != NULL );
    XOMASSERT( cch > 0 );
    
    // get the setting
    hr = m_pConfig->GetSetting( bstrSettingName, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        _snwprintf( pch, cch, L"%s\0", c_wszDefault ); 
        XomTrace( Xds, L_WARNING,  "XDS:(Config)  Name: %ws, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", static_cast<wchar_t *> (bstrSettingName), pch, hr );
        XomNtEvent( XEVENT_XDS_CONFIG_4, "XDS:(Config)  Name: %ws, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", static_cast<wchar_t *> (bstrSettingName), pch, hr );
    }
    else
    {
        // copy the setting into the static buffer.
        _snwprintf( pch, cch, L"%s\0", bstrSetting ); 
        XomTrace( Xds, L_LOW,  "XDS:(Config)  Name: %ws, Value: %S.", static_cast<wchar_t *> (bstrSettingName), pch );
    }

    
 }

//-----------------------------------------------------------------------------
//  GetDWORDSetting:  Loads a dword value from config interface.
//-----------------------------------------------------------------------------
DWORD CXdsMain::GetDWORDSetting( CComBSTR bstrSettingName, DWORD dwDefault )
{
    HRESULT hr = S_OK;
    CComBSTR bstrSetting;
    DWORD dwValue = 0;

    // get the setting
    hr = m_pConfig->GetSetting( bstrSettingName, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        dwValue = dwDefault;
        XomTrace( Xds, L_WARNING,  "XDS:(Config)  Name: %ws, Value (Default): 0x%X.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", static_cast<wchar_t *> (bstrSettingName), dwValue, hr );
        XomNtEvent( XEVENT_XDS_CONFIG_5, "XDS:(Config)  Name: %ws, Value (Default): %X.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", static_cast<wchar_t *> (bstrSettingName), dwValue, hr );
    }
    else
    {
        // copy the setting into the static buffer.
        dwValue = _wtoi( bstrSetting );
        XomTrace( Xds, L_LOW,  "XDS:(Config)  Name: %ws, Value: 0x%X.", static_cast<wchar_t *> (bstrSettingName), dwValue );
    }

    return dwValue;    
}


//-----------------------------------------------------------------------------
//  CXDSConfigListener implementation.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  SettingChange:  Calls XDS to let it know it needs to reload settings.
//-----------------------------------------------------------------------------
HRESULT CXDSConfigListener::SettingChange( struct ISettingChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    
    XOMASSERT( CXdsMain::GetInstance() != NULL );

    if ( CXdsMain::GetInstance() == NULL )
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    hr = CXdsMain::GetInstance()->Reload( e );
    
Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  Local function implementations.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  GetXOMSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void GetXOMSetting( char** pszValue, const char *c_szArea, const char *c_szDefault )
{
    CXomSetting *pSet = NULL;

    if(SUCCEEDED(g_xomcentral.GetSetting( c_szArea, &pSet)) && ( pSet != NULL ) )
    {
        *pszValue = (char*)pSet->GetStr();
        XomLog(Xds, "CXdsMain::LoadConfig: %s=%s", c_szArea, *pszValue );
    }
    else
    {
        XomLog(Xds, "CXdsMain::LoadConfig: Failed to attain a value for %s, using default of %s.", c_szArea, c_szDefault );
        *pszValue = (char*)c_szDefault;
    }
 }

//-----------------------------------------------------------------------------
//  GetXOMSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void GetXOMSetting( DWORD* pdwValue, const char *c_szArea, DWORD dwDefault )
{
    CXomSetting *pSet = NULL;

    if(SUCCEEDED(g_xomcentral.GetSetting( c_szArea, &pSet)) && ( pSet != NULL ) )
    {
        *pdwValue = pSet->GetDw();
        XomLog(Xds, "CXdsMain::LoadConfig: %s=%d", c_szArea, *pdwValue );
    }
    else
    {
        XomLog(Xds, "CXdsMain::LoadConfig: Failed to attain a value for %s, using default of %d.", c_szArea, dwDefault );
        *pdwValue = dwDefault;
    }
 }

//------------------------------------------------------------------
// StringToIp:  Converts a hex string to an unsigned int64 value.
//------------------------------------------------------------------
unsigned int StringToIp( char *szValue )
{
    DWORD dwStringSize;
    unsigned int nIp = 0;
    bool fLikeIp = true;
    int nOctets = 1;

    if (! szValue || szValue[0] == 0)
    {
        goto Exit;
    }

    if (szValue[0] == '0' && (szValue[1] == 'x' || szValue[1] == 'X') && ((strlen(szValue) == 10) || (strchr(szValue, ':') - szValue == 10)))
    {
        char szT[9];
        strncpy(szT, szValue+2, 8);
        szT[min(8, strlen(szValue)-2)] = 0;
        // The IP is in Hex form
        nIp = (DWORD)QwordFromHexStr(szT);
        goto Exit;
    }

    dwStringSize = strlen(szValue);
    for (unsigned int i = 0; i < dwStringSize && szValue[i] != ':'; i++)
    {
        if(szValue[i] == '.')
        {
            nOctets++;
        }
        else if ((szValue[i] < '0' || szValue[i] > '9'))
        {
            fLikeIp = false;
            break;
        }
    }

    if (fLikeIp && nOctets == 4)
    {
        // The IP is in decimal dot form
        char *szIp = szValue;
        nIp = atoi(szIp);
        szIp = strchr(szIp, '.') + 1;
        nIp |= szIp ? atoi(szIp) << 8 : 0;
        szIp = strchr(szIp, '.') + 1;
        nIp |= szIp ? atoi(szIp) << 16 : 0;
        szIp = strchr(szIp, '.') + 1;
        nIp |= szIp ? atoi(szIp) << 24 : 0;
    }
    else
    {
        nIp = 0;
    }

Exit:
    return nIp;
}

//------------------------------------------------------------------
// BinToHex:  changes a Bin string into a hex string
//------------------------------------------------------------------
void BinToHex( char *szString, DWORD dwStringSize, char *szHexString )
{
    DWORD dwPos;

    XOMASSERT( szHexString );
    XOMASSERT( szString );

    ZeroMemory( szHexString, (dwStringSize * 2)+1 );

    // loop through the string
    for ( dwPos = 0; dwPos < dwStringSize; dwPos++ )
    {
        sprintf( (char*)((ULONGLONG)(szHexString)+(dwPos*2)), "%2.2X", (BYTE)szString[dwPos] );
    }


}

//------------------------------------------------------------------
// BinToHex:  changes a Bin string into a hex string
//------------------------------------------------------------------
void HexToBin( char *szHexString, DWORD dwStringSize, BYTE **ppBinData )
{
    DWORD dwPos;
    int nSize = ((int)(dwStringSize/2));
    *ppBinData = new BYTE[nSize];

    ZeroMemory( *ppBinData, nSize );

    // loop through the string
    for ( dwPos = 0; dwPos < (DWORD)nSize; dwPos++ )
    {
        int nVal = 0;
        char szPos[3];
        szPos[2] = '\0';
        szPos[0] = *((char*)(((ULONGLONG)(szHexString)) + (dwPos * 2)));
        szPos[1] = *((char*)(((ULONGLONG)(szHexString)) + (dwPos * 2) + 1));
        sscanf( szPos, "%hX", &nVal );
        (*ppBinData)[dwPos] = (BYTE)nVal;
    }


}

//------------------------------------------------------------------
// QwordFromHexStr:  Converts a hex string to an unsigned int64 value.
//------------------------------------------------------------------
unsigned __int64 QwordFromHexStr(char *sz)
{
    char *szHex = sz;
    unsigned __int64 qwResult = 0;

    // don't look at the prefix
    if (strstr(szHex, "0x") == szHex || strstr(szHex, "0X") == szHex)
    {
        szHex += 2;
    }

    // this is a 64 bit integer.
    sscanf(szHex, "%I64x", &qwResult );

    return qwResult;
}

//------------------------------------------------------------------
// TranslateAddr:  Takes a string and turns it into an inaddr
//------------------------------------------------------------------
DWORD TranslateAddr( char * sz )
{
    DWORD dwRes = 0;

    // see if this addr is just a.b.c.d form.
    dwRes = (DWORD)inet_addr(sz);
    if( 0 == dwRes || INADDR_NONE == dwRes )
    {
        // Hmmm, it's not in the IP format or it's an invalid IP. Let's
        // assume that it is a hostname. Now we need to figure out its IP.

        hostent* pHost = gethostbyname(sz);

        if(NULL == pHost)
        {
            // oh well...  can't figure this out.
            dwRes = 0;
            goto Exit;
        }

        dwRes = ((in_addr*)pHost->h_addr_list[0])->s_addr;
    }

Exit:
    return dwRes;
}

//------------------------------------------------------------------
//  ConstructPath: recursively constructs all directories in a path.
//------------------------------------------------------------------
HRESULT ConstructPath( char *szPath, DWORD cPath )
{
    HRESULT hr = S_OK;
    DWORD cModPath = cPath - 1;
    DWORD dwRes = 0;
    char *sz = szPath + cModPath ;

    if ( cPath <= 1 )
    {
        hr = E_FAIL;
        goto Exit;
    }

    // try to create the path.  If failed go down one level and try to create.
    if ( ! CreateDirectoryA( szPath, NULL ) )
    {
        if ( GetLastError() != ERROR_ALREADY_EXISTS )
        {
            // determine the lower level.
            while ( *sz != '\\' && *sz != '/' )
            {
                cModPath--;
                sz--;
                if ( cModPath <= 1 )
                {
                    hr = E_FAIL;
                    goto Exit;
                }
            }
            *sz = '\0';

            // call again at a lower level.
            hr = ConstructPath( szPath, cModPath );
            if ( FAILED(hr) )
            {
                goto Exit;
            }

            // correct the modified string.
            *sz = '\\';

            // create again.
            if ( !CreateDirectoryA( szPath, NULL ) )
            {
                hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError());
                goto Exit;
            }
        }
    }

Exit:
    return hr;
}

//------------------------------------------------------------------
//  IsPrintable:  takes a given byte string and ensure all bytes
//      can be printed.
//------------------------------------------------------------------
BOOL IsPrintable( BYTE *pbArr, DWORD cbArr )
{
    BOOL bRes = TRUE;
    DWORD dwX = 0;

    // scan the entire byte stream.
    for ( dwX = 0; dwX < cbArr; dwX++ )
    {
        if ( !( bRes = isprint( pbArr[dwX] ) ) )
        {
            break;
        }
    }

    return bRes;
}

//------------------------------------------------------------------
//  IsNumericASCII:  takes a given byte string and ensures all bytes
//      are numeric asci.
//------------------------------------------------------------------
BOOL IsNumericASCII( BYTE *pbArr, DWORD cbArr )
{
    BOOL bRes = TRUE;
    DWORD dwX = 0;

    // scan the entire byte stream.
    for ( dwX = 0; dwX < cbArr; dwX++ )
    {
        if ( !( bRes = isdigit( pbArr[dwX] ) ) )
        {
            break;
        }
    }

    return bRes;
}


//------------------------------------------------------------------
//  MakePresentableLogName:  Construct a log-able name from give
//      data.
//------------------------------------------------------------------
void MakePresentableOutput( char *szName, DWORD dwNameSize, char *pszSrc )
{
    DWORD dwX = 0;

    XOMASSERT( szName );
    XOMASSERT( pszSrc );

    ZeroMemory( szName, dwNameSize * sizeof(szName[0]) );
    // scan this name and replace the  '|'
    for ( dwX = 0; dwX < (dwNameSize - 1); dwX++ )
    {
        // check for the end of the string.
        if ( pszSrc[dwX] == L'\0' )
        {
            szName[dwX] = '\0';
            break;
        }

        // validate the character.  If not valid then toss it.
        if ( pszSrc[dwX] > 127 || pszSrc[dwX] == '|' || (isprint(pszSrc[dwX]) == 0) )
        {
            szName[dwX] = '?';
        }
        else
        {
            szName[dwX] = (char)(pszSrc[dwX]);
        }
    }
    szName[dwNameSize] = '\0';
}

//------------------------------------------------------------------
//  SetupEtherNetHeader:  Sets up a ethernet header in a buffer
//------------------------------------------------------------------
void SetupEthernetHeader( PacketNode* pPacket, BYTE* pBuffer, DWORD cBuffer )
{
    XOMASSERT( pBuffer != NULL );
    XOMASSERT( pPacket != NULL );
    
    if ( ISIEEEHDR(pPacket->m_Data) )
    {
        CIeeeHdr* pIeeeHdr = (CIeeeHdr*)pBuffer;

        memcpy( (void*)&(pIeeeHdr->_eaDst),  (void*)&(pPacket->GetEnetHdr()->_eaSrc), sizeof(CEnetAddr) );
        memcpy( (void*)&(pIeeeHdr->_eaSrc),  (void*)&(pPacket->GetEnetHdr()->_eaDst), sizeof(CEnetAddr) );
        
        pIeeeHdr->_wType = HTONS((USHORT)cBuffer);
        pIeeeHdr->_bDsap = 0xAA;
        pIeeeHdr->_bSsap = 0xAA;
        pIeeeHdr->_bControl = 0x03;
        pIeeeHdr->_bOrgCode[0] = pIeeeHdr->_bOrgCode[1] = pIeeeHdr->_bOrgCode[2] = 0x00;
        pIeeeHdr->_wTypeIeee = pPacket->GetIeeeHdr()->_wType;
        
    }
    else       
    {
        CEnetHdr* pEHdr = (CEnetHdr*)pBuffer;
        
        memcpy( (void*)&(pEHdr->_eaDst),  (void*)&(pPacket->GetEnetHdr()->_eaSrc), sizeof(CEnetAddr) );
        memcpy( (void*)&(pEHdr->_eaSrc),  (void*)&(pPacket->GetEnetHdr()->_eaDst), sizeof(CEnetAddr) );
        pEHdr->_wType = pPacket->GetEnetHdr()->_wType;
    }
    
}



//////////////////////////////////////////////////////////////////////////////
//
// Yet another copy of our SHA1-HMAC implementation
//
void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
        ((DWORD*)Kopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\XdsPerfCtrs.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: XdsPerfCtrs.h
//
//  Interface for the perf counter class.
//-----------------------------------------------------------------------------
#pragma once
#include <windows.h>
#include "wmsstd.h"

//////////////////////////////////////////////////////////////////////////////
class CPERFCounters
{
public:
    CPERFCounters();
    ~CPERFCounters();

    HRESULT Init();

    //
    // DWORD counter manipulation routines
    //
    DWORD GetCurrentValue32( DWORD dwCounterID );

    void SetCurrentValue32( DWORD dwCounterID, DWORD dwVal );

    void IncrementValue32( DWORD dwCounterID, DWORD dwAmount );

    void DecrementValue32( DWORD dwCounterID, DWORD dwAmount );

    //
    // QWORD counter manipulation routines
    //
    QWORD GetCurrentValue64( DWORD dwCounterID );

    void SetCurrentValue64( DWORD dwCounterID, QWORD qwVal );

    void IncrementValue64( DWORD dwCounterID, QWORD qwAmount );

    void DecrementValue64( DWORD dwCounterID, QWORD qwAmount );

private:
    HANDLE m_hServerPerfObj;
};

extern CPERFCounters g_Counters;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\XdsMain.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: XdsMain.h
//
//  Interface for the main xds object (singleton)
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include <ntservice.h>
#include <XAlloc.h>

#include "netstructs.h"
#include "snpool.h"

#include <atlbase.h>
#include <atlcom.h>
#include <atlctl.h>
#include <atlsafe.h>
#include <atlconv.h>

#include <sha.h>
#include <wincrypt.h>

using namespace ATL;

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;

#import "XblHealthcheck.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblHealthcheck;


#include <addref.h>
#include <ConfigListener.h>
#include <cutil.h>

//-----------------------------------------------------------------------------
//  Pre-Declared Classes
//-----------------------------------------------------------------------------
class CCompletionPort;
class CMgmtInterface;
class CNicMgr;
class CXdsCache;
class CXdsAction;
class CXDSConfigListener;

// ---------------------------------------------------------------------------------------
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
// ---------------------------------------------------------------------------------------

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//-----------------------------------------------------------------------------
//  Global definitions
//-----------------------------------------------------------------------------

#define SYMMETRIC_KEY_LEN 16


//-----------------------------------------------------------------------------
//  types/structures
//-----------------------------------------------------------------------------
#define PACKET_DATA_OFFSET( pb ) ( ISIEEEHDR(pb) ? sizeof(CIeeeHdr) : sizeof(CEnetHdr) )

struct PacketNode
{
    LIST_ENTRY  m_Link;
    DWORD       m_dwRefCount;
    DWORD       m_dwNicId;
    DWORD       m_cData;

    BYTE        m_Data[ENET_DATA_MAXSIZE + sizeof(CIeeeHdr)];       

    FINLINE CEnetHdr*   GetEnetHdr()    { return ( (CEnetHdr*)(m_Data) ); }
    FINLINE CIeeeHdr*   GetIeeeHdr()    { return ( (CIeeeHdr*)(m_Data) ); }

    FINLINE CArpMsg*    GetArpMsg()     { return (CArpMsg*)(m_Data + ( PACKET_DATA_OFFSET( m_Data ) ) ); }

    FINLINE CIpHdr*     GetIPHdr()      { return (CIpHdr*)(m_Data + ( PACKET_DATA_OFFSET( m_Data ) ) ) ; }
    FINLINE CUdpHdr*    GetUDPHdr()     { return (CUdpHdr*)(m_Data + sizeof(CIpHdr) + ( PACKET_DATA_OFFSET( m_Data ) ) ); }
    FINLINE BYTE*       GetMsg()        { return (BYTE*)(m_Data + sizeof(CIpHdr) + sizeof(CUdpHdr) + ( PACKET_DATA_OFFSET( m_Data ) ) ); }
};

//-----------------------------------------------------------------------------
//  Global functions
//-----------------------------------------------------------------------------
extern unsigned int        StringToIp( char *szValue );
extern void                BinToHex( char *szString, DWORD dwStringSize, char *szHexString );
extern void                HexToBin( char *szHexString, DWORD dwStringSize, BYTE **ppBinData );
extern unsigned __int64    QwordFromHexStr(char *sz);
extern HRESULT             ConstructPath( char *szPath, DWORD cPath );

extern "C" UINT            tcpipxsum(UINT xsum, const void * buf, UINT buflen);


//-----------------------------------------------------------------------------
//  CXdsMain Interface
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  CXdsMain Interface
//-----------------------------------------------------------------------------
class CXdsMain : public CNTService
{
public:
    static CXdsMain*    GetInstance();
    static void         ReleaseInstance();

    // overrides:  Initializes the service.
    virtual HRESULT     InitService( DWORD dwArgc, LPWSTR *pszArgv );

    // overrides:  run the service.
    virtual HRESULT     RunService( BOOL *pfServiceRan );

    // VLan methods
    HRESULT             QueuePacket( PacketNode *pPacket );
    
    // figure out what to do with the packet
    HRESULT             ProcessPacket( PacketNode *pNode );

    // handler for reloading settings
    virtual HRESULT     Reload(struct ISettingChangeEventArgs * pEventArgs );
    
    // handler for reloading a specific setting
    virtual HRESULT     ReloadSetting( CComBSTR SettingChange, CComBSTR bsValueNew );

    // just in case someone needs to post to our completion port.
    CCompletionPort*    GetMasterCompletionPort() { return m_pCompletionPort; }

    // Action node methods
    CXdsAction*         GetAction();
    void                ReleaseAction( CXdsAction *pAction );

    // tells the xds its time to shutdown.
    void                Shutdown() { SetEvent( ShutdownEvent() ); }
    BOOL                IsComplete() { return m_bIsComplete; }

    CXdsCache*          GetCache() { return m_pCache; }

    // gets packet node memory from the pool.
    PacketNode*         GetPacketNode();
    void                ReleasePacketNode( PacketNode *pNode );
    
    // overrides
    void *operator      new(size_t len) { return XAlloc(len); }
    void operator       delete(void *pv) { XFree(pv); }

    // Handle all aspects of service installation
    virtual DWORD Install();

    // Handle all aspects of service uninstallation
    virtual DWORD Uninstall();
    
protected:
    CXdsMain(void);
    virtual ~CXdsMain(void);

    // main program 
    HRESULT             Start();
    HRESULT             Run();
    HRESULT             Term();

    // initialize xds mgmt callbacks
    void                InitializeCallbacks();

    HRESULT             InitializeActionNodes();
    HRESULT             CleanActionNodes();

    // used to keep track of packet nodes.
    void                AddRefPacketNode ( PacketNode *pNode );

    // load the config.
    HRESULT             LoadConfig();
    HRESULT             LoadNicConfig();


    // validate a reflection request.
    HRESULT             ValidateReflectionRequest( XDS_REFLECTION_REQUEST *pReq, DWORD cReq , DWORD dwReqIP );
    HRESULT             ValidateICMPRequest( XDS_ICMP_REQUEST *pReq, DWORD cReq, DWORD dwReqIP );
    HRESULT             ValidateLogRequest( XDS_LOG_REQUEST *pReq, DWORD cReq, DWORD dwReqIP );

    // construct certain packets.
    void                ConstructReflectionResponse( PacketNode *pNode , BYTE* pbytResp, DWORD *pcResp );
    void                ConstructICMPResponse( PacketNode* pPacket, BYTE* pbytResp, DWORD *pcResp );
    void                ConstructLogResponse( PacketNode* pPacket, BYTE* pbytResp, DWORD *pcResp );

    // tools to read from the config.
    DWORD GetDWORDSetting( CComBSTR bstrSettingName, DWORD dwDefault );
    void GetStringSetting( LPWSTR pch, DWORD cch, CComBSTR bstrSettingName, const WCHAR *c_wszDefault );
    void GetStringSetting( LPSTR pch, DWORD cch, CComBSTR bstrSettingName, const char *c_szDefault );


    // IP Cache methods
    HRESULT EventThrottle( DWORD dwIP );

    // calculate the SHAW1-HMAC( KSess, IP | TimeStamp )
    void SHA1HMAC( DWORD dwSrcIP, ULONGLONG qwTimeStamp,  BYTE *pDigest );

    
    // attributes
    CSNPool*            m_pPacketBuffer;
    DWORD               m_dwPacketBufferSize;
    DWORD               m_dwCacheSize;
    DWORD               m_dwCacheHashTableSize;
    DWORD               m_dwCacheLifetime;
    DWORD               m_dwNumOfThreads;
    DWORD               m_dwInfractionLimit;
    DWORD               m_dwPort;
    DWORD               m_dwICMPReplyAddr;
    DWORD               m_dwGatewayLookupInterval;
    DWORD               m_dwARPRetryInterval;
    DWORD               m_dwRetryEventThrottle;
    DWORD               m_dwSkewTimeInMilliSecs;
    BYTE                m_bTOS;    
    BYTE                m_bTTL;
    DWORD               m_dwMaxLogLength;
    DWORD               m_dwMinICMPRequestLength;
    DWORD               m_dwMinLogRequestLength;
    

    CSNPool*            m_pActionBag;

    // config properties
    DWORD               m_dwNumOfNics;
    
    // interface for mgmt stuff
    CMgmtInterface*     m_pMgmtInterface;

    // IP cache
    CXdsCache*          m_pCache;

    BYTE                m_abSessionKey[SYMMETRIC_KEY_LEN];

    // indicates whether the xds service is complete or not.
    BOOL                m_bIsComplete;

    HANDLE              m_hShutdown;                    // xds shutdown handle... fired when shutdown is complete.

    CCompletionPort*    m_pCompletionPort;              // the main completion port.

    CNicMgr*            m_pNicMgr;                      // object to manage Vlan Nics

    // config db interface for the XDS.
    CComPtr<IConfig>    m_pConfig;
    CXDSConfigListener* m_pConfigListener;

    CComPtr<IHealthInterop> m_pHealthInterop;

    BOOL                m_bUseArpThread;
    
private:
    static CXdsMain*    m_pInstance;
    static DWORD        m_dwRefCount;

    // recursive action node initializers/deleters
    void CreateActionNode( );
    void DeleteActionNode( );

};

//-----------------------------------------------------------------------------
// Listener Class for config event changes
//-----------------------------------------------------------------------------
class CXDSConfigListener : public CConfigListenerBase
{

    IMPLEMENT_REFCOUNT_COM

public:

    CXDSConfigListener()
    {
    }

    virtual ~CXDSConfigListener()
    { 
    }

    STDMETHODIMP QueryInterface( REFIID riid, void **ppObj )
    {
        HRESULT hr;

        if (ppObj == NULL)
        {
            return E_POINTER;
        }

        if (riid == IID_IUnknown)
        {
            *ppObj = (void*)(IUnknown*)this;
            AddRef();
            hr = S_OK;
        }
        else if (riid == _uuidof(IConfigListener))
        {
            *ppObj = (void*)(IConfigListener*)this;
            AddRef();
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
        return hr;
    }

    virtual HRESULT __stdcall SettingChange(
        /*[in]*/ struct ISettingChangeEventArgs * e
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\obj\amd64\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=amd64_xds_none_12.4.56.0_none_1106d792d1885409
ASSEMBLY_IDENTITY_XP_KEY_FORM=amd64_xds_no-public-key_12.4.56.0_x-ww_2e1e217d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xds
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=amd64
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=amd64_xds_no-public-key_12.4.56.0_x-ww_2e1e217d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=amd64_xds_no-public-key_12.4.56.0_x-ww_2e1e217d.manifest
XP_MANIFEST_PATH=manifests\amd64_xds_no-public-key_12.4.56.0_x-ww_2e1e217d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=amd64_xds_no-public-key_12.4.56.0_x-ww_2e1e217d.cat
XP_CATALOG_PATH=manifests\amd64_xds_no-public-key_12.4.56.0_x-ww_2e1e217d.cat
XP_PAYLOAD_PATH=amd64_xds_no-public-key_12.4.56.0_x-ww_2e1e217d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xds,processorArchitecture=amd64,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\XdsPerfCtrs.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: XdsPerfCtrs.cpp
//
//  Implementation for the perf counter class.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "XdsPerfCtrs.h"
#include "XdsPerf.h"
#include "perfapi.h"


enum XQPC_TYPES
{
    XQPC_DWORD = 1,
    XQPC_QWORD = 2
};

struct PERFCOUNTER
{
    XQPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwPerfIndex;
    BYTE *pbPerfCtrData;
};

#define NUM_SERVER_PERF_COUNTERS    16

#define DWORD_AVERAGE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, NULL }

#define DWORD_BASE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, NULL }

#define DWORD_COUNTER( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, NULL }

#define DWORD_RATE( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, NULL }

#define QWORD_AVERAGE( INDEX ) \
    { XQPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, NULL }

#define QWORD_COUNTER( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, NULL }

#define QWORD_RATE( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, NULL }


//////////////////////////////////////////////////////////////////////////////
PERFCOUNTER s_ServerPerfCtrs[ NUM_SERVER_PERF_COUNTERS ] =
{
    DWORD_RATE   ( XDS_REQUESTS_PER_SEC_COUNTER             ),
    QWORD_COUNTER( XDS_REQUESTS_COUNTER                     ),
    DWORD_RATE   ( XDS_SUCCESSFUL_REQUESTS_PER_SEC_COUNTER  ),
    QWORD_COUNTER( XDS_SUCCESSFUL_REQUESTS_COUNTER          ),
    DWORD_RATE   ( XDS_REFLECTIONS_REQUESTS_PER_SEC_COUNTER ),
    QWORD_COUNTER( XDS_REFLECTIONS_REQUESTS_COUNTER         ),
    DWORD_RATE   ( XDS_LOG_REQUESTS_PER_SEC_COUNTER         ),
    QWORD_COUNTER( XDS_LOG_REQUESTS_COUNTER                 ),
    DWORD_RATE   ( XDS_ICMP_REQUESTS_PER_SEC_COUNTER        ),
    QWORD_COUNTER( XDS_ICMP_REQUESTS_COUNTER                ),
    DWORD_RATE   ( XDS_INVALID_REQUESTS_PER_SEC_COUNTER     ),
    QWORD_COUNTER( XDS_INVALID_REQUESTS_COUNTER             ),
    DWORD_RATE   ( XDS_INVALID_SIGNATURE_PER_SEC_COUNTER    ),
    QWORD_COUNTER( XDS_INVALID_SIGNATURE_COUNTER            ),
    DWORD_RATE   ( XDS_INVALID_TIMESTAMP_PER_SEC_COUNTER    ),
    QWORD_COUNTER( XDS_INVALID_TIMESTAMP_COUNTER            ),
};


//////////////////////////////////////////////////////////////////////////////
CPERFCounters::CPERFCounters() :
    m_hServerPerfObj( NULL )
{
}


//////////////////////////////////////////////////////////////////////////////
CPERFCounters::~CPERFCounters()
{
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CPERFCounters::Init()
{
    HRESULT hr;
    
    do
    {
        //
        // Create the server perf object and associated counters
        //
        BYTE *pbServCtrsStart = NULL;

        assert( NULL == m_hServerPerfObj );

        m_hServerPerfObj = CreatePerfObject(
                                    XDS_SERVER_OBJECT,
                                    0,
                                    (void **) &pbServCtrsStart );

        if( NULL == m_hServerPerfObj )
        {
            hr = E_UNEXPECTED;
            break;
        }

        for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
        {
            DWORD dwCounterDataOffset = CreatePerfCounter(
                                                s_ServerPerfCtrs[ dwCtr ].dwPerfType,
                                                0,       // dwScale
                                                s_ServerPerfCtrs[ dwCtr ].dwDataSize,
                                                m_hServerPerfObj,
                                                s_ServerPerfCtrs[ dwCtr ].dwPerfIndex,
                                                NULL );

            assert( 0xffffffff != dwCounterDataOffset );

            s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData = pbServCtrsStart + dwCounterDataOffset;

            //
            // Zero every counter on startup
            //
            ZeroMemory(
                s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData,
                s_ServerPerfCtrs[ dwCtr ].dwDataSize );
        }
    
        hr = S_OK;
    }
    while( FALSE );
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CPERFCounters::GetCurrentValue32( DWORD dwCounterID )
{
    DWORD dwCounterIndex = ( ( dwCounterID - XDS_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    return( *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::SetCurrentValue32(
                                    DWORD dwCounterID,
                                    DWORD dwVal )
{
    DWORD dwCounterIndex = ( ( dwCounterID - XDS_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    InterlockedExchange(
        (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
        (LONG) dwVal );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::IncrementValue32(
                                    DWORD dwCounterID,
                                    DWORD dwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - XDS_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    InterlockedExchangeAdd(
        (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
        (LONG) dwAmount );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::DecrementValue32(
                                    DWORD dwCounterID,
                                    DWORD dwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - XDS_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    InterlockedExchangeAdd(
        (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
        - (LONG) dwAmount );
}


//////////////////////////////////////////////////////////////////////////////
QWORD CPERFCounters::GetCurrentValue64( DWORD dwCounterID )
{
    DWORD dwCounterIndex = ( ( dwCounterID - XDS_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    return( *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::SetCurrentValue64(
                                    DWORD dwCounterID,
                                    QWORD qwVal )
{
    DWORD dwCounterIndex = ( ( dwCounterID - XDS_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData = qwVal;
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::IncrementValue64(
                                    DWORD dwCounterID,
                                    QWORD qwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - XDS_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData += qwAmount;
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::DecrementValue64(
                                    DWORD dwCounterID,
                                    QWORD qwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - XDS_SERVER_OBJECT ) / 2 ) - 1;

    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData -= qwAmount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\i386\tcpipxsum.asm ===
title  "Compute TCP/IP Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    tcpipxsum.asm
;
; Abstract:
;
;    This module implements a function to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Revision History:
;
;     Who         When        What
;     --------    --------    ----------------------------------------------
;     mikeab      01-22-94    Pentium optimization
;
;--*/



LOOP_UNROLLING_BITS equ     4
LOOP_UNROLLING      equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
;        include ks386.inc
        .list

XNET    SEGMENT DWORD PUBLIC 'CODE'

;++
;
; ULONG
; tcpipxsum(
;   IN ULONG xsum,
;   IN const VOID* buf,
;   IN UINT len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;    It uses Processor's prefetch instruction.
;
; Arguments:
;
;    xsum - Suppiles the initial checksum value, in 16-bit form,
;           with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

xsum    equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpipxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 32-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:
        ; prefetch the 32-byte cache line from [esi+0]
        db 0fH
        db 18H
        db 46H
        db 00H

        ; prefetch the 32-byte cache line from [esi+20h]
        db 0fH
        db 18H
        db 46H
        db 20H

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax, word ptr [esp + xsum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpipxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM

stdENDP tcpipxsum

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\amd64\tcpipxsum.asm ===
title  "Compute Checksum"
;++
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
; Module Name:
;
;   xsum.amd
;
; Abstract:
;
;   This module implements the platform specific function to compute the
;   checksum of a buffer.
;
; Author:
;
;   David N. Cutler (davec) 6-Jul-2000
;
; Environment:
;
;   Any mode.
;
;--

include ksamd64.inc

;++
;
; ULONG
; tcpipxsum(
;    IN ULONG Checksum,
;    IN PUCHAR Source,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer and combines
;    the computed checksum with the specified checksum.
;
; Arguments:
;
;    Checksum (ecx) - Suppiles the initial checksum value, in 16-bit form,
;            with the high word set to 0.
;
;    Source (rdx) - Supplies a pointer to the checksum buffer.
;
;    Length (r8d) - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum, in 16-bit form, with the high word set to 0.
;
;--

        NESTED_ENTRY tcpipxsum, _TEXT$00

        alloc_stack 8                   ; allocate stack frame
        save_reg rbx, 0                 ; save nonvolatile register

        END_PROLOGUE

        prefetchnta 0[rdx]              ; prefetch first two 64-byte blocks
        prefetchnta 64[rdx]             ;
        prefetchnta 127[rdx]            ;
        mov     r11, rdx                ; save initial buffer address
        mov     bx, cx                  ; save initial checksum
        mov     r10, rdx                ; set checksum buffer address
        mov     ecx, r8d                ; set buffer length
        xor     eax, eax                ; clear computed checksum
        test    ecx, ecx                ; test if any bytes to checksum
        jz      combine                 ; if z, no bytes to checksum

;
; If the checksum buffer is not word aligned, then add the first byte of
; the buffer to the checksum.
;
; N.B. First buffer address check is done using rdx rather than r10 so
;      the register ah can be used.
;

        test    dl, 1                   ; test if buffer word aligned
        jz      short word_aligned      ; if z, buffer word aligned
        mov     ah, [rdx]               ; get first byte of checksum
        inc     r10                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      done                    ; if z set, no more bytes

;
; If the buffer is not an even number of bytes, then add the last byte of
; the buffer to the checksum.
;

word_aligned:                           ;
        shr     ecx, 1                  ; convert to word count
        jnc     short word_count        ; if nc, even number of bytes
        mov     al, [r10][rcx * 2]      ; initialize the computed checksum
        jz      done                    ; if z set, no more bytes

;
; If the buffer is not quadword aligned, then add words to the checksum until
; the buffer is quadword aligned.
;

word_count:                             ;
        test    r10b, 6                 ; test if buffer quadword aligned
        jz      short qword_aligned     ; if z, buffer quadword aligned
qword_align:                            ;
        add     ax, [r10]               ; add next word of checksum
        adc     eax, 0                  ; propagate carry
        add     r10, 2                  ; increment buffer address
        dec     ecx                     ; decrement number of words
        jz      done                    ; if z, no more words
        test    r10b, 6                 ; test if buffer qword aligned
        jnz     short qword_align       ; if nz, buffer not qword aligned

;
; Compute checksum in large blocks of qwords.
;

qword_aligned:                          ;
        mov     edx, ecx                ; copy number or words remaining
        shr     edx, 2                  ; compute number of quadwords
        jz      residual_words          ; if z, no quadwords to checksum
        mov     r8d, edx                ; compute number of loop iterations
        shr     r8d, 4                  ;
        and     edx, 16 - 1             ; isolate partial loop iteration
        jz      short checksum_loop     ; if z, no partial loop iteration
        sub     rdx, 16                 ; compute negative loop top offset
        lea     r10, [r10][rdx * 8]     ; bias initial buffer address
        neg     rdx                     ; compute positive loop top offset
        add     r8d, 1                  ; increment loop iteration count
        lea     r9, checksum_start      ; get address of checksum array
        lea     r9, [r9][rdx * 4]       ; compute initial iteration address
        jmp     r9                      ; start checksum

;
; Checksum quadwords.
;
; N.B. This loop is entered with carry clear.
;

        align   16
checksum_loop:                          ;
        prefetchnta 64[r10]             ; prefetch next 64-byte block
        prefetchnta 127[r10]            ;

;
; N.B. The first 16 of following instructions are exactly 4 bytes long.
;

checksum_start:

;       adc     rax, 0[r10]             ; Compute checksum
                                        ;
        db      049h                    ; Manually encode the 4-byte
        db      013h                    ; version of the instruction
        db      042h                    ;
        db      000h                    ; adc rax, 0[r10]

        adc     rax, 8[r10]             ;
        adc     rax, 16[r10]            ;
        adc     rax, 24[r10]            ;
        adc     rax, 32[r10]            ;
        adc     rax, 40[r10]            ;
        adc     rax, 48[r10]            ;
        adc     rax, 56[r10]            ;
        adc     rax, 64[r10]            ;
        adc     rax, 72[r10]            ;
        adc     rax, 80[r10]            ;
        adc     rax, 88[r10]            ;
        adc     rax, 96[r10]            ;
        adc     rax, 104[r10]           ;
        adc     rax, 112[r10]           ;
        adc     rax, 120[r10]           ;

        .errnz  (($ - checksum_start) - (4 * 16))

        lea     r10, 128[r10]           ; update source address
        dec     r8d                     ; decrement loop count
        jnz     short checksum_loop     ; if nz, more iterations
        adc     rax, 0                  ; propagate last carry

;
; Compute checksum of residual words.
;

residual_words:                         ;
        and     ecx, 3                  ; isolate residual words
        jz      short done              ; if z, no residual words
add_word:                               ;
        add     ax, [r10]               ; add word to checksum
        adc     ax, 0                   ; propagate carry
        add     r10, 2                  ; increment buffer address
        dec     ecx                     ; decrement word count
        jnz     short add_word          ; if nz, more words remaining

;
; Fold the computed checksum to 32-bits and then to 16-bits.
;

done:                                   ;
        mov     rcx, rax                ; fold the checksum to 32-bits
        ror     rcx, 32                 ; swap high and low dwords
        add     rax, rcx                ; produce sum + carry in high 32-bits
        shr     rax, 32                 ; extract 32-bit checksum
        mov     ecx, eax                ; fold the checksum to 16-bits
        ror     ecx, 16                 ; swap high and low words
        add     eax, ecx                ; produce sum + carry in high 16-bits
        shr     eax, 16                 ; extract 16-bit check sum
        test    r11b, 1                 ; test if buffer word aligned
        jz      short combine           ; if z set, buffer word aligned
        ror     ax, 8                   ; swap checksum bytes

;
; Combine the input checksum with the computed checksum.
;

combine:                                ;
        add     ax, bx                  ; combine checksums
        adc     eax, 0                  ; add carry to low 16-bits
        mov     rbx, [rsp]              ; restore nonvolatile register
        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END tcpipxsum, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xds_none_12.4.56.0_none_b4e83c0f192ae2d3
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xds
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d.manifest
XP_MANIFEST_PATH=manifests\x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d.cat
XP_CATALOG_PATH=manifests\x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d.cat
XP_PAYLOAD_PATH=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xds,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\functional\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\stress\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xds_none_12.4.56.0_none_b4e83c0f192ae2d3
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xds
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d.manifest
XP_MANIFEST_PATH=manifests\x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d.cat
XP_CATALOG_PATH=manifests\x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d.cat
XP_PAYLOAD_PATH=x86_xds_no-public-key_12.4.56.0_x-ww_c2474b9d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xds,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\stress\XdsStressClient.cs ===
using System;

namespace xonline.server.download.test.stress 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class XdsStressClient
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            bool bRun = true;
            long suc_ref = 0;
            long suc_log = 0;
            long suc_icmp = 0;
            long suc_total = 0;

            long fail_ref = 0;
            long fail_icmp = 0;
            long fail_log = 0;
            long fail_total = 0;

            long timeout = 0;

            long lifetime = 0;

            long total = 0;

            string output = "";

            StressMgr sm = new StressMgr( args[0] );

            while ( bRun )
            {
                switch( Console.Read() )
                {
                    case 'a':
                    {
                        sm._stats.GetStats( ref suc_ref, ref suc_icmp, ref suc_log, ref fail_ref, ref fail_icmp, ref fail_log, ref timeout, ref lifetime );
                        suc_total = suc_ref + suc_icmp + suc_log;
                        fail_total = fail_ref + fail_icmp + fail_log;

                        total = suc_total + fail_total + timeout;

                        output =  "\nSuccess Reflect    -->  " + (suc_ref/lifetime).ToString() + " per second,  Total:  " + suc_ref.ToString() + "\n";
                        output += "Success ICMP       -->  " + (suc_icmp/lifetime).ToString() + " per second,  Total:  " + suc_icmp.ToString() + "\n";
                        output += "Success LOG        -->  " + (suc_log/lifetime).ToString() + " per second,  Total:  " + suc_log.ToString() + "\n";
                        output += "Success            -->  " + (suc_total/lifetime).ToString() + " per second,  Total:  " + suc_total.ToString() + "\n";
                        output += "Failed  Reflect    -->  " + (fail_ref/lifetime).ToString() + " per second,  Total:  " + fail_ref.ToString() + "\n";
                        output += "Failed  ICMP       -->  " + (fail_icmp/lifetime).ToString() + " per second,  Total:  " + fail_icmp.ToString() + "\n";
                        output += "Failed  LOG        -->  " + (fail_log/lifetime).ToString() + " per second,  Total:  " + fail_log.ToString() + "\n";
                        output += "Failed             -->  " + (fail_total/lifetime).ToString() + " per second,  Total:  " + fail_total.ToString() + "\n";
                        output += "Timeout            -->  " + (timeout/lifetime).ToString() + " per second,  Total:  " + timeout.ToString() + "\n";
                        output += "Total              -->  " + (total/lifetime).ToString() + " per second,  Total:  " + total.ToString() + "\n";

                        Console.Write( output );
                    }
                        break;
                    case 'b':
                    {
                        sm._stats.GetStats( ref suc_ref, ref suc_icmp, ref suc_log, ref fail_ref, ref fail_icmp, ref fail_log, ref timeout, ref lifetime );
                        suc_total = suc_ref + suc_icmp + suc_log;
                        fail_total = fail_ref + fail_icmp + fail_log;

                        total = suc_total + fail_total + timeout;

                        output =  "\nSuccess -->  " + (suc_total/lifetime).ToString() + " per second,  Total:  " + suc_total.ToString() + "\n";
                        output += "Failed  -->  " + (fail_total/lifetime).ToString() + " per second,  Total:  " + fail_total.ToString() + "\n";
                        output += "Timeout -->  " + (timeout/lifetime).ToString() + " per second,  Total:  " + timeout.ToString() + "\n";
                        output += "Total   -->  " + (total/lifetime).ToString() + " per second,  Total:  " + total.ToString() + "\n";


                        Console.Write( output );
                    }
                        break;
                    case 'q':
                    {
                        bRun = false;
                    }
                        break;
                }
            }

            sm.Close();
            sm._stats.GetStats( ref suc_ref, ref suc_icmp, ref suc_log, ref fail_ref, ref fail_icmp, ref fail_log, ref timeout, ref lifetime );

            suc_total = suc_ref + suc_icmp + suc_log;
            fail_total = fail_ref + fail_icmp + fail_log;

            total = suc_total + fail_total + timeout;

            output =  "\nSuccess Reflect    -->  " + (suc_ref/lifetime).ToString() + " per second,  Total:  " + suc_ref.ToString() + "\n";
            output +=  "Success ICMP       -->  " + (suc_icmp/lifetime).ToString() + " per second,  Total:  " + suc_icmp.ToString() + "\n";
            output +=  "Success LOG        -->  " + (suc_log/lifetime).ToString() + " per second,  Total:  " + suc_log.ToString() + "\n";
            output +=  "Success            -->  " + (suc_total/lifetime).ToString() + " per second,  Total:  " + suc_total.ToString() + "\n";
            output += "Failed  Reflect    -->  " + (fail_ref/lifetime).ToString() + " per second,  Total:  " + fail_ref.ToString() + "\n";
            output += "Failed  ICMP       -->  " + (fail_icmp/lifetime).ToString() + " per second,  Total:  " + fail_icmp.ToString() + "\n";
            output += "Failed  LOG        -->  " + (fail_log/lifetime).ToString() + " per second,  Total:  " + fail_log.ToString() + "\n";
            output += "Failed             -->  " + (fail_total/lifetime).ToString() + " per second,  Total:  " + fail_total.ToString() + "\n";
            output += "Timeout            -->  " + (timeout/lifetime).ToString() + " per second,  Total:  " + timeout.ToString() + "\n";
            output += "Total              -->  " + (total/lifetime).ToString() + " per second,  Total:  " + total.ToString() + "\n";

            Console.Write( output );

        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\functional\Form1.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Xml;
using System.Net;
using System.Net.Sockets;



namespace xonline.server.download.test.functional 
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class MainWindow : System.Windows.Forms.Form
	{
        private System.Windows.Forms.MenuItem menuItem1;
        private System.Windows.Forms.ContextMenu MainMenu;
        private System.Windows.Forms.GroupBox ReflectionGroupBox;
        private System.Windows.Forms.Button Start;
        private System.Windows.Forms.Label ProtocolVersionLabel;
        private System.Windows.Forms.TextBox ProtocolVersion;
        private System.Windows.Forms.Label RequestTypeLabel;
        private System.Windows.Forms.ComboBox RequestType;
        private System.Windows.Forms.Label ReturnPacketSizeLabel;
        private System.Windows.Forms.TextBox ReturnPacketSize;
        private System.Windows.Forms.Label PayloadLabel;
        private System.Windows.Forms.TextBox Payload;
        private System.Windows.Forms.GroupBox ResultGB;
        private System.Windows.Forms.TextBox Results;
        private System.Windows.Forms.GroupBox LogDataGB;
        private System.Windows.Forms.Label SerialNumberLabel;
        private System.Windows.Forms.TextBox SerialNumber;
        private System.Windows.Forms.Label PPALabel;
        private System.Windows.Forms.TextBox PPA1;
        private System.Windows.Forms.Label LogDataLabel;
        private System.Windows.Forms.TextBox LogData;
        private System.Windows.Forms.Button Clear;
        private System.Windows.Forms.Label XDSIPLabel;
        private System.Windows.Forms.TextBox IP;
        private System.Windows.Forms.Label PortLabel;
        private System.Windows.Forms.TextBox Port;
        private System.Windows.Forms.Label NoticeLabel;
        private System.Windows.Forms.Label AnyPortLabel;
        private System.Windows.Forms.Label SecondaryPacketSizeLabel;
        private System.Windows.Forms.TextBox SecondaryPacketSize;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public MainWindow()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.MainMenu = new System.Windows.Forms.ContextMenu();
            this.menuItem1 = new System.Windows.Forms.MenuItem();
            this.ReflectionGroupBox = new System.Windows.Forms.GroupBox();
            this.SecondaryPacketSize = new System.Windows.Forms.TextBox();
            this.SecondaryPacketSizeLabel = new System.Windows.Forms.Label();
            this.AnyPortLabel = new System.Windows.Forms.Label();
            this.Port = new System.Windows.Forms.TextBox();
            this.PortLabel = new System.Windows.Forms.Label();
            this.IP = new System.Windows.Forms.TextBox();
            this.XDSIPLabel = new System.Windows.Forms.Label();
            this.Payload = new System.Windows.Forms.TextBox();
            this.PayloadLabel = new System.Windows.Forms.Label();
            this.ReturnPacketSize = new System.Windows.Forms.TextBox();
            this.ReturnPacketSizeLabel = new System.Windows.Forms.Label();
            this.RequestType = new System.Windows.Forms.ComboBox();
            this.RequestTypeLabel = new System.Windows.Forms.Label();
            this.ProtocolVersion = new System.Windows.Forms.TextBox();
            this.ProtocolVersionLabel = new System.Windows.Forms.Label();
            this.Start = new System.Windows.Forms.Button();
            this.ResultGB = new System.Windows.Forms.GroupBox();
            this.Results = new System.Windows.Forms.TextBox();
            this.LogDataGB = new System.Windows.Forms.GroupBox();
            this.LogData = new System.Windows.Forms.TextBox();
            this.LogDataLabel = new System.Windows.Forms.Label();
            this.PPA1 = new System.Windows.Forms.TextBox();
            this.PPALabel = new System.Windows.Forms.Label();
            this.SerialNumber = new System.Windows.Forms.TextBox();
            this.SerialNumberLabel = new System.Windows.Forms.Label();
            this.NoticeLabel = new System.Windows.Forms.Label();
            this.Clear = new System.Windows.Forms.Button();
            this.ReflectionGroupBox.SuspendLayout();
            this.ResultGB.SuspendLayout();
            this.LogDataGB.SuspendLayout();
            this.SuspendLayout();
            // 
            // MainMenu
            // 
            this.MainMenu.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                                     this.menuItem1});
            // 
            // menuItem1
            // 
            this.menuItem1.Index = 0;
            this.menuItem1.Text = "Settings";
            // 
            // ReflectionGroupBox
            // 
            this.ReflectionGroupBox.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                             this.SecondaryPacketSize,
                                                                                             this.SecondaryPacketSizeLabel,
                                                                                             this.AnyPortLabel,
                                                                                             this.Port,
                                                                                             this.PortLabel,
                                                                                             this.IP,
                                                                                             this.XDSIPLabel,
                                                                                             this.Payload,
                                                                                             this.PayloadLabel,
                                                                                             this.ReturnPacketSize,
                                                                                             this.ReturnPacketSizeLabel,
                                                                                             this.RequestType,
                                                                                             this.RequestTypeLabel,
                                                                                             this.ProtocolVersion,
                                                                                             this.ProtocolVersionLabel});
            this.ReflectionGroupBox.Location = new System.Drawing.Point(8, 16);
            this.ReflectionGroupBox.Name = "ReflectionGroupBox";
            this.ReflectionGroupBox.Size = new System.Drawing.Size(616, 168);
            this.ReflectionGroupBox.TabIndex = 0;
            this.ReflectionGroupBox.TabStop = false;
            this.ReflectionGroupBox.Text = "Reflection Request";
            // 
            // SecondaryPacketSize
            // 
            this.SecondaryPacketSize.Enabled = false;
            this.SecondaryPacketSize.Location = new System.Drawing.Point(120, 104);
            this.SecondaryPacketSize.Name = "SecondaryPacketSize";
            this.SecondaryPacketSize.Size = new System.Drawing.Size(40, 20);
            this.SecondaryPacketSize.TabIndex = 14;
            this.SecondaryPacketSize.Text = "128";
            // 
            // SecondaryPacketSizeLabel
            // 
            this.SecondaryPacketSizeLabel.Enabled = false;
            this.SecondaryPacketSizeLabel.Location = new System.Drawing.Point(8, 96);
            this.SecondaryPacketSizeLabel.Name = "SecondaryPacketSizeLabel";
            this.SecondaryPacketSizeLabel.Size = new System.Drawing.Size(104, 32);
            this.SecondaryPacketSizeLabel.TabIndex = 13;
            this.SecondaryPacketSizeLabel.Text = "Secondary Packet Size";
            this.SecondaryPacketSizeLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // AnyPortLabel
            // 
            this.AnyPortLabel.Location = new System.Drawing.Point(464, 80);
            this.AnyPortLabel.Name = "AnyPortLabel";
            this.AnyPortLabel.TabIndex = 12;
            this.AnyPortLabel.Text = "Use 0 for any port";
            // 
            // Port
            // 
            this.Port.Location = new System.Drawing.Point(520, 56);
            this.Port.Name = "Port";
            this.Port.Size = new System.Drawing.Size(88, 20);
            this.Port.TabIndex = 11;
            this.Port.Text = "0";
            // 
            // PortLabel
            // 
            this.PortLabel.Location = new System.Drawing.Point(464, 56);
            this.PortLabel.Name = "PortLabel";
            this.PortLabel.Size = new System.Drawing.Size(56, 24);
            this.PortLabel.TabIndex = 10;
            this.PortLabel.Text = "Port";
            // 
            // IP
            // 
            this.IP.Location = new System.Drawing.Point(288, 56);
            this.IP.Name = "IP";
            this.IP.Size = new System.Drawing.Size(160, 20);
            this.IP.TabIndex = 9;
            this.IP.Text = "192.168.86.173";
            // 
            // XDSIPLabel
            // 
            this.XDSIPLabel.Location = new System.Drawing.Point(208, 56);
            this.XDSIPLabel.Name = "XDSIPLabel";
            this.XDSIPLabel.Size = new System.Drawing.Size(48, 23);
            this.XDSIPLabel.TabIndex = 8;
            this.XDSIPLabel.Text = "XDS IP";
            this.XDSIPLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // Payload
            // 
            this.Payload.Location = new System.Drawing.Point(120, 136);
            this.Payload.Name = "Payload";
            this.Payload.Size = new System.Drawing.Size(488, 20);
            this.Payload.TabIndex = 7;
            this.Payload.Text = "*";
            // 
            // PayloadLabel
            // 
            this.PayloadLabel.Location = new System.Drawing.Point(8, 136);
            this.PayloadLabel.Name = "PayloadLabel";
            this.PayloadLabel.Size = new System.Drawing.Size(96, 16);
            this.PayloadLabel.TabIndex = 6;
            this.PayloadLabel.Text = "Payload";
            this.PayloadLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // ReturnPacketSize
            // 
            this.ReturnPacketSize.Location = new System.Drawing.Point(120, 56);
            this.ReturnPacketSize.Name = "ReturnPacketSize";
            this.ReturnPacketSize.Size = new System.Drawing.Size(40, 20);
            this.ReturnPacketSize.TabIndex = 5;
            this.ReturnPacketSize.Text = "128";
            // 
            // ReturnPacketSizeLabel
            // 
            this.ReturnPacketSizeLabel.Location = new System.Drawing.Point(8, 56);
            this.ReturnPacketSizeLabel.Name = "ReturnPacketSizeLabel";
            this.ReturnPacketSizeLabel.Size = new System.Drawing.Size(104, 16);
            this.ReturnPacketSizeLabel.TabIndex = 4;
            this.ReturnPacketSizeLabel.Text = "Return Packet Size";
            this.ReturnPacketSizeLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // RequestType
            // 
            this.RequestType.Items.AddRange(new object[] {
                                                             "XDS_REQUEST_TYPES.REFLECT_SAMEIPPORT",
                                                             "XDS_REQUEST_TYPES.REFLECT_DIFFERENTIP",
                                                             "XDS_REQUEST_TYPES.REFLECT_SAMEIP_DIFFERENTPORT",
                                                             "XDS_REQUEST_TYPES.REFLECT_ICMP",
                                                             "XDS_REQUEST_TYPES.REFLECT_LOG"});
            this.RequestType.Location = new System.Drawing.Point(288, 24);
            this.RequestType.Name = "RequestType";
            this.RequestType.Size = new System.Drawing.Size(320, 21);
            this.RequestType.TabIndex = 3;
            this.RequestType.Text = "XDS_REQUEST_TYPES.REFLECT_SAMEIPPORT";
            this.RequestType.SelectedIndexChanged += new System.EventHandler(this.RequestType_SelectedIndexChanged);
            // 
            // RequestTypeLabel
            // 
            this.RequestTypeLabel.Location = new System.Drawing.Point(208, 24);
            this.RequestTypeLabel.Name = "RequestTypeLabel";
            this.RequestTypeLabel.Size = new System.Drawing.Size(80, 16);
            this.RequestTypeLabel.TabIndex = 2;
            this.RequestTypeLabel.Text = "Request Type";
            this.RequestTypeLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // ProtocolVersion
            // 
            this.ProtocolVersion.Location = new System.Drawing.Point(120, 24);
            this.ProtocolVersion.Name = "ProtocolVersion";
            this.ProtocolVersion.Size = new System.Drawing.Size(40, 20);
            this.ProtocolVersion.TabIndex = 1;
            this.ProtocolVersion.Text = "1";
            // 
            // ProtocolVersionLabel
            // 
            this.ProtocolVersionLabel.Location = new System.Drawing.Point(8, 24);
            this.ProtocolVersionLabel.Name = "ProtocolVersionLabel";
            this.ProtocolVersionLabel.Size = new System.Drawing.Size(88, 16);
            this.ProtocolVersionLabel.TabIndex = 0;
            this.ProtocolVersionLabel.Text = "Protocol Version";
            this.ProtocolVersionLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // Start
            // 
            this.Start.Location = new System.Drawing.Point(520, 544);
            this.Start.Name = "Start";
            this.Start.Size = new System.Drawing.Size(104, 24);
            this.Start.TabIndex = 1;
            this.Start.Text = "Send";
            this.Start.Click += new System.EventHandler(this.Start_Click);
            // 
            // ResultGB
            // 
            this.ResultGB.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                   this.Results});
            this.ResultGB.Location = new System.Drawing.Point(8, 288);
            this.ResultGB.Name = "ResultGB";
            this.ResultGB.Size = new System.Drawing.Size(616, 248);
            this.ResultGB.TabIndex = 3;
            this.ResultGB.TabStop = false;
            this.ResultGB.Text = "Results";
            // 
            // Results
            // 
            this.Results.AcceptsReturn = true;
            this.Results.AcceptsTab = true;
            this.Results.Location = new System.Drawing.Point(8, 16);
            this.Results.Multiline = true;
            this.Results.Name = "Results";
            this.Results.ReadOnly = true;
            this.Results.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.Results.Size = new System.Drawing.Size(600, 224);
            this.Results.TabIndex = 0;
            this.Results.Text = "";
            // 
            // LogDataGB
            // 
            this.LogDataGB.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                    this.LogData,
                                                                                    this.LogDataLabel,
                                                                                    this.PPA1,
                                                                                    this.PPALabel,
                                                                                    this.SerialNumber,
                                                                                    this.SerialNumberLabel});
            this.LogDataGB.Location = new System.Drawing.Point(8, 192);
            this.LogDataGB.Name = "LogDataGB";
            this.LogDataGB.Size = new System.Drawing.Size(616, 96);
            this.LogDataGB.TabIndex = 4;
            this.LogDataGB.TabStop = false;
            this.LogDataGB.Text = "Log Data";
            // 
            // LogData
            // 
            this.LogData.Enabled = false;
            this.LogData.Location = new System.Drawing.Point(120, 64);
            this.LogData.Name = "LogData";
            this.LogData.Size = new System.Drawing.Size(488, 20);
            this.LogData.TabIndex = 5;
            this.LogData.Text = "Sent to the logs";
            // 
            // LogDataLabel
            // 
            this.LogDataLabel.Enabled = false;
            this.LogDataLabel.Location = new System.Drawing.Point(8, 64);
            this.LogDataLabel.Name = "LogDataLabel";
            this.LogDataLabel.TabIndex = 4;
            this.LogDataLabel.Text = "Log Data";
            this.LogDataLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // PPA1
            // 
            this.PPA1.Enabled = false;
            this.PPA1.Location = new System.Drawing.Point(288, 24);
            this.PPA1.MaxLength = 128;
            this.PPA1.Name = "PPA1";
            this.PPA1.Size = new System.Drawing.Size(320, 20);
            this.PPA1.TabIndex = 3;
            this.PPA1.Text = "*";
            // 
            // PPALabel
            // 
            this.PPALabel.Enabled = false;
            this.PPALabel.Location = new System.Drawing.Point(240, 24);
            this.PPALabel.Name = "PPALabel";
            this.PPALabel.Size = new System.Drawing.Size(40, 16);
            this.PPALabel.TabIndex = 2;
            this.PPALabel.Text = "PPA 1";
            this.PPALabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // SerialNumber
            // 
            this.SerialNumber.Enabled = false;
            this.SerialNumber.Location = new System.Drawing.Point(120, 24);
            this.SerialNumber.Name = "SerialNumber";
            this.SerialNumber.TabIndex = 1;
            this.SerialNumber.Text = "999999999999";
            // 
            // SerialNumberLabel
            // 
            this.SerialNumberLabel.Enabled = false;
            this.SerialNumberLabel.Location = new System.Drawing.Point(8, 24);
            this.SerialNumberLabel.Name = "SerialNumberLabel";
            this.SerialNumberLabel.Size = new System.Drawing.Size(112, 16);
            this.SerialNumberLabel.TabIndex = 0;
            this.SerialNumberLabel.Text = "Xbox Serial Number";
            this.SerialNumberLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // NoticeLabel
            // 
            this.NoticeLabel.Enabled = false;
            this.NoticeLabel.Location = new System.Drawing.Point(8, 544);
            this.NoticeLabel.Name = "NoticeLabel";
            this.NoticeLabel.Size = new System.Drawing.Size(160, 16);
            this.NoticeLabel.TabIndex = 6;
            this.NoticeLabel.Text = "* generates random data.";
            // 
            // Clear
            // 
            this.Clear.Location = new System.Drawing.Point(408, 544);
            this.Clear.Name = "Clear";
            this.Clear.Size = new System.Drawing.Size(104, 24);
            this.Clear.TabIndex = 5;
            this.Clear.Text = "Clear";
            this.Clear.Click += new System.EventHandler(this.Clear_Click);
            // 
            // MainWindow
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(632, 573);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                          this.Clear,
                                                                          this.LogDataGB,
                                                                          this.ResultGB,
                                                                          this.Start,
                                                                          this.ReflectionGroupBox,
                                                                          this.NoticeLabel});
            this.Name = "MainWindow";
            this.Tag = "";
            this.Text = "Form1";
            this.ReflectionGroupBox.ResumeLayout(false);
            this.ResultGB.ResumeLayout(false);
            this.LogDataGB.ResumeLayout(false);
            this.ResumeLayout(false);

        }
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new MainWindow());
		}


        private void Start_Click(object sender, System.EventArgs e)
        {
            uint selected = (uint)RequestType.SelectedIndex;
            CReflectionReply reply = null;

            switch( selected )
            {
                case 0:
                case 1:
                case 2:
                {
                    ReflectionRequest( ref reply );
                }
                    break;
                case 3:
                {
                    if ( ReflectionRequest( ref reply ) )
                    {
                        ICMPRequest( reply );
                    }
                }
                    break;
                case 4:
                {
                    if ( ReflectionRequest( ref reply ) )
                    {
                        LogRequest( reply );
                    }
                }
                    break;
                default:
                    PrintToResults( "Not a valid selection." );
                    break;
            }
                    
        }
        private bool UdpSendAndReceive( string remoteIpAddr, int timeOutInSecs, byte[] sendData, byte[] recvData )
        {
            Socket udp = new Socket( AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );
            System.Net.IPEndPoint remoteIPEP = new IPEndPoint( IPAddress.Parse(remoteIpAddr), 3074 );
            bool bRes = true;
            int bytesSent = 0;
            int bytesRecv = 0;
            string output = "";
                        
            try 
            {
                // bind to the local host.
                IPHostEntry localHE = Dns.GetHostByName(Dns.GetHostName());
				
                //Bind the UDP client to any local port chosen by the kernel.
                IPEndPoint localIpEP = new IPEndPoint( localHE.AddressList[0], 0 );
				
                udp.Bind( localIpEP );
		
                bytesSent = udp.SendTo( sendData,  remoteIPEP );

                // ensure we sent the entire packet.
                if ( bytesSent != sendData.Length )
                {
                    throw new Exception( "The number of bytes sent does not equal the number of bytes in buffer.  bytesSent="
                        + bytesSent.ToString() + " data length=" + sendData.Length.ToString()
                        + " remote IP=" + remoteIpAddr );
                }
                
                // poll for results
                if ( udp.Poll( timeOutInSecs * 100000, SelectMode.SelectRead ) )
                {
                    EndPoint remoteEP = (remoteIPEP);

                    // receive bytes.
                    bytesRecv = udp.ReceiveFrom( recvData, ref remoteEP );

                    // show a little information.
                    output = "RemoteEP = " + remoteEP.ToString() + "  Packet Size= " + bytesRecv;
                    PrintToResults( output );
                }
                else
                {
                    PrintToResults( "Timeout" );
                    bRes = false;
                }
                
                udp.Close();
            }
            catch ( System.Exception exception )
            {
                PrintToResults( exception.Message );
                bRes = false;
            }

            return bRes;
        }

        private bool ReflectionRequest( ref CReflectionReply rreply )
        {
            CReflectionRequest request = null;
            byte[] msg = null;
            byte[] resp = new byte[512];
            string output = "";
            bool bRes = false;
            ushort requesttype = 0;
            string payload = "";
                        
            try 
            {
                if ( RequestType.SelectedIndex == 3 || RequestType.SelectedIndex == 4 )
                {
                    requesttype = (ushort)0;
                }
                else
                {
                    requesttype = (ushort)RequestType.SelectedIndex;
                }

                // set random data for payload test.
                if ( Payload.Text == "*" )
                {
                    payload = GenerateRandomString( (int.Parse(ReturnPacketSize.Text)) - 36 );
                }
                else
                {
                    payload = Payload.Text;
                }

                // gather variables
                request = new CReflectionRequest( ushort.Parse(ProtocolVersion.Text),
                                                  requesttype, 
                                                  ushort.Parse( ReturnPacketSize.Text ),
                                                  payload
                                                );

                // build 
                msg = request.GetPacket();

                if ( UdpSendAndReceive( IP.Text, 5, msg, resp ) )
                {
                    // received response.
                    output += "Received Size=" + resp.Length;

                    CReflectionReply rr = new CReflectionReply( resp );

                    // output results.
                    IPAddress ip = new IPAddress( rr.ClientSrcIP );
                    System.Text.ASCIIEncoding ascii = new System.Text.ASCIIEncoding();

                    output += " TimeStamp=" + rr.TimeStamp.ToString() 
                        + " Signature= " + ascii.GetString( rr.Signature )
                        + " ClientIP=" + ip.ToString()
                        + " ClientPort=0x" + rr.ClientSrcPort.ToString("X")
                        + " LengthOfPayload=" + rr.LengthOfPayload.ToString()
                        + " Payload=" + ascii.GetString( rr.Payload )
                        + "\r\n";
                    
                    rreply = rr;
                    bRes = true;
                }

            }
            catch ( System.Exception exception )
            {
                output = exception.Message;
            }
            PrintToResults( output );

            return bRes;
        }

        private bool ICMPRequest( CReflectionReply rr )
        {
            CICMPRequest request = null;
            byte[] msg = null;
            byte[] resp = new byte[512];
            string output = "";
            bool bRes = true;
                        
            try 
            {
                request = new CICMPRequest( ushort.Parse(ProtocolVersion.Text),
                    (ushort)RequestType.SelectedIndex, 
                    rr.Signature,
                    rr.TimeStamp,
                    uint.Parse(SecondaryPacketSize.Text)
                    );

                // build 
                msg = request.GetPacket();

                if ( UdpSendAndReceive( IP.Text, 5, msg, resp ) )
                {
                    PrintToResults( "This isn't suppose to succeed!");
                    bRes = false;
                }
                else
                {
                    PrintToResults( "Send failed... could be because if ICMP reply.  Please do a netmon to verify.!");
                }
            }
            catch ( SocketException sockexception )
            {
                output = sockexception.Message;
                bRes = true;
            }
            catch ( System.Exception exception )
            {
                output = exception.Message;
                bRes = false;    
            }
            PrintToResults( output );

            return bRes;
        }

        private bool LogRequest( CReflectionReply rr )
        {
            CLogRequest request = null;
            byte[] msg = null;
            byte[] resp = new byte[512];
            string output = "";
            bool bRes = true;
            string PPA = "";
                        
            try 
            {
                // check the PPA field... * for random data.
                if ( PPA1.Text == "*" )
                {
                    PPA = GenerateRandomString( 20 );
                }
                else
                {
                    PPA = PPA1.Text;
                }

                request = new CLogRequest( ushort.Parse(ProtocolVersion.Text),
                    (ushort)RequestType.SelectedIndex, 
                    rr.Signature,
                    rr.TimeStamp,
                    SerialNumber.Text,
                    PPA, 
                    (ushort)LogData.Text.Length,
                    LogData.Text,
                    uint.Parse(SecondaryPacketSize.Text)
                    );

                // build 
                msg = request.GetPacket();

                if ( UdpSendAndReceive( IP.Text, 1, msg, resp ) )
                {
                    // received response.
                    output += "Received Size=" + resp.Length;

                    CLogReply reply = new CLogReply( resp );

                    output += " TimeStamp=" + rr.TimeStamp.ToString();
                }
                else
                {
                    bRes = false;
                }
            }
            catch ( System.Exception exception )
            {
                output = exception.Message;
                bRes = false;    
            }
            PrintToResults( output );

            return bRes;
        }

        private void PrintToResults( string sMsg )
        {
            Results.Text = sMsg + "\r\n" + Results.Text;
        }

        private void RequestType_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            uint selected = (uint)RequestType.SelectedIndex;

            switch( selected )
            {
                case 0:
                case 1:
                case 2:
                {
                    SerialNumberLabel.Enabled = false;
                    LogDataLabel.Enabled = false;
                    SerialNumber.Enabled = false;
                    LogData.Enabled = false;
                    PPALabel.Enabled = false;
                    PPA1.Enabled = false;
                    NoticeLabel.Enabled = false;
                    SecondaryPacketSize.Enabled = false;
                    SecondaryPacketSizeLabel.Enabled = false;
                }
                    break;
                case 3:
                {
                    SerialNumberLabel.Enabled = false;
                    LogDataLabel.Enabled = false;
                    SerialNumber.Enabled = false;
                    LogData.Enabled = false;
                    PPALabel.Enabled = false;
                    PPA1.Enabled = false;
                    NoticeLabel.Enabled = false;
                    SecondaryPacketSize.Enabled = true;
                    SecondaryPacketSizeLabel.Enabled = true;
                }
                    break;
                case 4:
                {
                    SerialNumberLabel.Enabled = true;
                    LogDataLabel.Enabled = true;
                    SerialNumber.Enabled = true;
                    LogData.Enabled = true;
                    PPALabel.Enabled = true;
                    PPA1.Enabled = true;
                    NoticeLabel.Enabled = true;
                    SecondaryPacketSize.Enabled = true;
                    SecondaryPacketSizeLabel.Enabled = true;
                }
                    break;
                default:
                    PrintToResults( "Not a valid selection." );
                    break;
            }

            this.Update();
        }

        private void Clear_Click(object sender, System.EventArgs e)
        {
            Results.Text = "";
            Results.Update();
        }

        private string GenerateRandomString( int size )
        {
            string result = "";
            byte[] randData = new byte[size];
            System.Text.ASCIIEncoding asci = new System.Text.ASCIIEncoding();

            System.Random rand = new System.Random();
            
            rand.NextBytes( randData );
            result = asci.GetString( randData );
            return result;
        }

        private void Stress_Click(object sender, System.EventArgs e)
        {
            // figure this out... start stress mgr.
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\XDSTest\FuncICMP.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Diagnostics;
 
namespace XDSTest
{
    /// <summary>
    /// Test XDS feature: ICMP Port Unreachable Request 
    /// 
    /// Unfortunately, using the UDP/IP stack, it is impossible to distinguish between 
    /// success and failue in our tests.  ICMP Port Unreachable is not passed up to the 
    /// UDP stack, so we can't detect whether we receive one or not.  I'd like to wrap
    /// RawNic in a C# object so we could use it..
    /// 
    /// Currently, this suite of tests will result in:
    /// 3
    /// successful ICMP Port Unreachable packets to be returned.  
    /// Count 'em with PerfMon or NetMon.
    /// </summary>

    [TestGroup, Owner("johnmcp"), TestFrequency("Daily"), TestCasePriority(2), EnvRequirement("XDS")]
    public class FuncICMP : TestNode
    {
        [TestGroupSetup]
        public void Setup()
        {
        }

        // Expected: success
        // Returned ICMP packets: 1
        [TestCase, Description("Simple ICMP request"), TestCasePriority(1)]
        class SimpleICMP_CheckReply : XDSTestBase
        {
            protected override void Execute()
            {
                // Make reflection request first
                CReflectionRequest req1 = new CReflectionRequest(128); 
                if (req1.SendRecvVerify(k_TimeoutLong))
                {
                    // Now we can make the ICMP request
                    CICMPRequest req2 = new CICMPRequest(req1.reply);
                    if (req2.SendRecvVerify(k_TimeoutLong))
                    {
                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        // Expected: success
        // Returned ICMP packets: 2
        [TestCase, Description("Send larger request packets than what is necessary"), TestCasePriority(1)]
        class LargerPacketSize_CheckReply : XDSTestBase
        {
            protected override void Execute()
            {
                // Make reflection request first
                CReflectionRequest req1 = new CReflectionRequest(128); 
                if (req1.SendRecvVerify(k_TimeoutICMP))
                {
                    // Now we can make the ICMP request
                    CICMPRequest req2 = new CICMPRequest(req1.reply);
                    bool bAllPassed = true;

                    req2._packetsize++;
                    bAllPassed &= req2.SendRecvVerify(k_TimeoutICMP);

                    req2._packetsize = (uint)k_MaxUdpPayload;
                    bAllPassed &= req2.SendRecvVerify(k_TimeoutICMP);

                    if (bAllPassed)
                    {
                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        // Expected: failure
        // Returned ICMP packets: 0
        [TestCase, Description("Make requests with invalid signatures")]
        class BadSignature : XDSTestBase
        {
            protected override void Execute()
            {
                // Make reflection request first
                CReflectionRequest req1 = new CReflectionRequest(128); 
                if (req1.SendRecvVerify(k_TimeoutICMP))
                {
                    // Now we can make the ICMP request
                    CICMPRequest req2 = new CICMPRequest(req1.reply);
                    bool bAnyPassed = false;
                    System.Random rand = new System.Random();
                    int i;

                    for (i = 0; i < req2._signature.Length; i++)
                    {
                        req2._signature[i] = 0;
                    }
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    for (i = 0; i < req2._signature.Length; i++)
                    {
                        req2._signature[i] = 255;
                    }
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    rand.NextBytes(req2._signature);
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    rand.NextBytes(req2._signature);
                    req2._timestamp = 0;
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    rand.NextBytes(req2._signature);
                    req2._timestamp = 1;
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    if (!bAnyPassed)
                    {
                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        // Expected: failue
        // Returned ICMP packets: 0
        [TestCase, Description("Make requests with invalid timestamps")]
        class BadTimestamp : XDSTestBase
        {
            protected override void Execute()
            {
                // Make reflection request first
                CReflectionRequest req1 = new CReflectionRequest(128); 
                if (req1.SendRecvVerify(k_TimeoutICMP))
                {
                    // Now we can make the ICMP request
                    CICMPRequest req2 = new CICMPRequest(req1.reply);
                    bool bAnyPassed = false;

                    req2._timestamp = 0;
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    req2._timestamp = 0xFFFFFFFFFFFFFFFF;
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    System.Random rand = new System.Random();
                    req2._timestamp = (ulong)rand.Next();
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    if (!bAnyPassed)
                    {
                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        // Expected: failue
        // Returned ICMP packets: 0
        [TestCase, Description("Make requests with invalid packet sizes")]
        class BadPacketSize : XDSTestBase
        {
            protected override void Execute()
            {
                // Make reflection request first
                CReflectionRequest req1 = new CReflectionRequest(128); 
                if (req1.SendRecvVerify(k_TimeoutICMP))
                {
                    // Now we can make the ICMP request
                    CICMPRequest req2 = new CICMPRequest(req1.reply);
                    bool bAnyPassed = false;

                    req2._packetsize--;
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    req2._packetsize = (uint)(k_MaxUdpPayload + 1);
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    if (!bAnyPassed)
                    {
                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        // Expected: failue
        // Returned ICMP packets: 0
        [TestCase, Description("Make requests with invalid protocol versions")]
        class BadProtocol : XDSTestBase
        {
            protected override void Execute()
            {
                // Make reflection request first
                CReflectionRequest req1 = new CReflectionRequest(128); 
                if (req1.SendRecvVerify(k_TimeoutICMP))
                {
                    // Now we can make the ICMP request
                    CICMPRequest req2 = new CICMPRequest(req1.reply);
                    bool bAnyPassed = false;

                    req2._protocolVersion = 0;
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    req2._protocolVersion = 2;
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    req2._protocolVersion = 0xFFFF;
                    bAnyPassed |= req2.SendRecvVerify(k_TimeoutICMP);

                    if (!bAnyPassed)
                    {
                        this.ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }



        


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\functional\CReflectionRequest.cs ===
using System;
using System.IO;
using System.Text;

namespace xonline.server.download.test.functional 
{
    public enum XDS_REQUEST_TYPES : ushort
    {
        SAMEIPPORT = 0,
        DIFFERENTIP_SAMEPORT = 1,
        SAMEIP_DIFFERENTPORT = 2,
        ICMP,
        LOG
    }

	/// <summary>
	/// Summary description for CReflectionRequest.
	/// </summary>
	public class CReflectionRequest
	{
		public CReflectionRequest( ushort pv, ushort rt, ushort rps, string pl )
		{
            ASCIIEncoding asci = new ASCIIEncoding();

            _protocolVersion    = pv;
            _requestType        = rt;
            _returnPacketSize   = rps;
            _payload            = asci.GetBytes(pl);
		}

        public CReflectionRequest( byte[] msg )
        {
            MemoryStream ms         = new MemoryStream( msg, false );
            BinaryReader br         = new BinaryReader( ms );
            ushort lengthOfPayload  = 0;

            _protocolVersion        = br.ReadUInt16();
            _requestType            = br.ReadUInt16();
            _returnPacketSize       = br.ReadUInt16();
            lengthOfPayload         = br.ReadUInt16();
            _payload                = br.ReadBytes( lengthOfPayload );
        }

        public byte[] GetPacket()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );
            byte[] packet = null;

            ms.SetLength( _returnPacketSize );

            // write the data to the stream.
            bw.Write( _protocolVersion );
            bw.Write( _requestType );
            bw.Write( _returnPacketSize );
            bw.Write( (ushort)(_payload.Length) );
            bw.Write( _payload );

            bw.Close();
           
            packet = ms.ToArray();

            return packet;
        }

        public bool VerifyReply( CReflectionReply reply )
        {
            bool bRes = true;
            
            // ensure the size
            if ( reply.LengthOfPayload != _payload.Length )
            {
                bRes = false;
                goto Exit;
            }

            // ensure the length of the payload.
            for ( int nX = 0; nX < reply.LengthOfPayload; nX++ )
            {
                if ( reply.Payload[nX] != _payload[nX] )
                {
                    bRes = false;
                    goto Exit;
                }
            }

        Exit:
            return bRes;
        }

        public static bool operator ==(CReflectionRequest obj1, CReflectionRequest obj2 )        
        {
            // true if all values are equal.
            return (
                    obj1._requestType       == obj2._requestType &&
                    obj1._protocolVersion   == obj2._protocolVersion &&
                    obj1._returnPacketSize  == obj2._returnPacketSize &&
                    obj1._payload           == obj2._payload 
                    );
        }

        public static bool operator !=(CReflectionRequest obj1, CReflectionRequest obj2 )        
        {
            // true if all values are equal.
            return !( obj1 == obj2 );
        }

        public override bool Equals(object obj)        
        {
            // true if all values are equal.
            return ( this == (CReflectionRequest)obj );
        }

        public override int GetHashCode()        
        {
            // true if all values are equal.
            return ( (int)_protocolVersion * (int)_requestType * (int)_returnPacketSize );
        }

        private ushort  _protocolVersion;
        private ushort  _requestType;
        private ushort  _returnPacketSize;
        private byte[]  _payload;
	}

    /// <summary>
    /// Summary description for CICMPRequest.
    /// </summary>
    public class CICMPRequest
    {
        public CICMPRequest( ushort pv, ushort rt, byte[] signature, ulong ts , uint packetsize )
        {
            _protocolVersion    = pv;
            _requestType        = rt;
            _signature          = signature;
            _timestamp          = ts;
            _packetsize         = packetsize;
        }

        public byte[] GetPacket()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );
            byte[] packet = null;

            ms.SetLength( _packetsize );

            // write the data to the stream.
            bw.Write( _protocolVersion );
            bw.Write( _requestType );
            bw.Write( _signature );
            bw.Write( _timestamp );

            bw.Close();
           
            packet = ms.ToArray();

            return packet;
        }

        private ushort  _protocolVersion;
        private ushort  _requestType;
        private byte[]  _signature;
        private ulong   _timestamp;
        private uint    _packetsize;
    }

    /// <summary>
    /// Summary description for CLogRequest.
    /// </summary>
    public class CLogRequest
    {
        public CLogRequest( ushort pv, ushort rt, byte[] signature, ulong ts , string xsn, string ppa, ushort lenToLog, string logpayload, uint packetsize )
        {
            ASCIIEncoding asci = new ASCIIEncoding();

            _protocolVersion    = pv;
            _requestType        = rt;
            _signature          = signature;
            _timestamp          = ts;
            _xboxSerialNumber   = asci.GetBytes(xsn);
            _PPA1               = asci.GetBytes(ppa);
            _lengthToLog        = lenToLog;
            _payload            = asci.GetBytes(logpayload);
            _packetsize         = packetsize;
        }

        public byte[] GetPacket()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );
            byte[] packet = null;

            ms.SetLength( _packetsize );

            // write the data to the stream.
            bw.Write( _protocolVersion );
            bw.Write( _requestType );
            bw.Write( _signature );
            bw.Write( _timestamp );
            bw.Write( _xboxSerialNumber );
            bw.Write( _PPA1 );
            bw.Write( _lengthToLog );
            bw.Write( _payload );

            bw.Close();
           
            packet = ms.ToArray();

            return packet;
        }

        public bool VerifyReply( CLogReply reply )
        {            
            // ensure the timestamp.
            return ( reply.TimeStamp == _timestamp );
        }

        private ushort  _protocolVersion;
        private ushort  _requestType;
        private byte[]  _signature;
        private ulong   _timestamp;
        private byte[]  _xboxSerialNumber;
        private byte[]  _PPA1;
        private ushort  _lengthToLog;
        private byte[]  _payload;

        private uint    _packetsize;
    }

    public class CReflectionReply
    {
        public CReflectionReply( byte[] reply )
        {
            MemoryStream ms     = new MemoryStream( reply, false );
            BinaryReader br     = new BinaryReader( ms );

            _signature          = br.ReadBytes( 20 );
            _timestamp          = br.ReadUInt64();
            _clientSourceIP     = br.ReadUInt32();
            _clientSourcePort   = br.ReadUInt16();
            _lengthOfPayload    = br.ReadUInt16();
            _payload            = br.ReadBytes( _lengthOfPayload );
        }

        public byte[] Signature
        {
            get { return _signature; }
        }
            
        public ulong TimeStamp
        {
            get { return _timestamp; }
        }

        public uint ClientSrcIP
        {
            get { return _clientSourceIP; }
        }

        public ushort ClientSrcPort
        {
            get { return _clientSourcePort; }
        }

        public ushort LengthOfPayload
        {
            get { return _lengthOfPayload; }
        }

        public byte[] Payload
        {
            get { return _payload; }
        }

        private byte[]  _signature;
        private ulong   _timestamp;
        private uint    _clientSourceIP;
        private ushort  _clientSourcePort;
        private ushort  _lengthOfPayload;
        private byte[]  _payload;
    }

    public class CLogReply
    {
        public CLogReply( byte[] reply )
        {
            MemoryStream ms     = new MemoryStream( reply, false );
            BinaryReader br     = new BinaryReader( ms );

            _timestamp          = br.ReadUInt64();
        }

        public ulong TimeStamp
        {
            get { return _timestamp; }
        }

        private ulong   _timestamp;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\XDSTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\XDSTest\StressXds.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XDSTest
{

    // lohab:
    // says client will send approximately 1 big packet for every 8 small packets
    // big packet: 1364 byte payload
    // small packet: around 86 bytes

    [StressTest(Priority=1)]
    public class Reflection_64byte : XDSStressTestBase
    {
        protected override bool XdsExecute()
        {
            return DoReflection(64);
        }
    } 

    [StressTest(Priority=1)]
    public class Reflection_1394byte : XDSStressTestBase
    {
        protected override bool XdsExecute()
        {
            return DoReflection(1364);
        }
    } 

    [StressTest(Priority=1)]
    public class ICMP : XDSStressTestBase
    {
        protected override bool XdsExecute()
        {
            return DoICMP();
        }
    } 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\XDSTest\FuncReflection.cs ===
using System;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Diagnostics;
using xonline.common.config;

namespace XDSTest
{
    /// <summary>
    /// Test XDS feature: UDP Reflection Request  
    /// 
    /// SimpleReflection    Simple reflection request
    /// MultiPayloadSize    Multiple packet sizes
    /// MinPayloadSize      Minimum payload size (no payload) reflection request
    /// MaxPayloadSize      Maximum payload size (max UDP packet size - headers) reflection request
    /// LargerPacketSize    Larger packet size
    /// TooBigPayloadSize   Too big payload sizes
    /// TooSmallPacketSize  Too small packet size
    /// TooBigPacketSize    Too big payload size
    /// RandomData          Random data
    /// BadProtocol         Bad protocol version
    /// BadRequestType      Bad request type
    ///
    /// </summary>

    [TestGroup, Owner("johnmcp"), TestFrequency("Daily"), TestCasePriority(2), EnvRequirement("XDS")]
    public class FuncReflection : TestNode
    {
        // Expected: success
        [TestCase, Description("Simple reflection request"), TestCasePriority(1)]
        class SimpleReflection : XDSTestBase
        {
            protected override void Execute()
            {
                CReflectionRequest req = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, 128);
                bool bAllPassed = true;
                
                req.SetPayload(1);
                bAllPassed &= req.SendRecvVerify(k_TimeoutLong);
                req.SetPayload(128);
                bAllPassed &= req.SendRecvVerify(k_TimeoutLong);
                req.SetPayload(1000);
                bAllPassed &= req.SendRecvVerify(k_TimeoutLong);

                if (bAllPassed)
                    this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // Expected: success
        [TestCase, Description("Minimum payload size (no payload) reflection request"), TestCasePriority(1)]
        class MinPayloadSize : XDSTestBase
        {
            protected override void Execute()
            {
                CReflectionRequest req = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, 0); 
                if (req.SendRecvVerify(k_TimeoutQuick))
                    this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // Expected: success
        [TestCase, Description("Maximum payload size (max UDP packet size - headers) reflection request"), TestCasePriority(1)]
        class MaxPayloadSize : XDSTestBase
        {
            protected override void Execute()
            {
                // Request and reply packets have to match sizes, so the biggest payload we can send depends on which
                // one of those is larger
                int maxPacketSize = Math.Max(CReflectionRequest.PacketSize, CReflectionReply.PacketSize);
                CReflectionRequest req = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, k_MaxUdpPayload - maxPacketSize); 
                if (req.SendRecvVerify(k_TimeoutQuick))
                    this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // Expected: success
        [TestCase, Description("Larger packet size"), TestCasePriority(1)]
        class LargerPacketSize : XDSTestBase
        {
            protected override void Execute()
            {
                CReflectionRequest req = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, 128);
                bool bAllPassed = true;

                req.SetPayload(128);
                req._returnPacketSize++;
                bAllPassed &= req.SendRecvVerify(k_TimeoutQuick);
                req._returnPacketSize = (ushort)k_MaxUdpPayload;
                bAllPassed &= req.SendRecvVerify(k_TimeoutQuick);

                req.SetPayload(0);
                req._returnPacketSize++;
                bAllPassed &= req.SendRecvVerify(k_TimeoutQuick);
                req._returnPacketSize = (ushort)k_MaxUdpPayload;
                bAllPassed &= req.SendRecvVerify(k_TimeoutQuick);

                if (bAllPassed)
                    this.ResultCode = TEST_RESULTS.PASSED;

            }
        }
        
        // Expected: failure
        [TestCase, Description("Too big payload sizes")]
        class TooBigPayloadSize : XDSTestBase
        {
            protected override void Execute()
            {
                CReflectionRequest req = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, 128);
                int maxPacketSize = Math.Max(CReflectionRequest.PacketSize, CReflectionReply.PacketSize);
                bool bAnyPassed = false;
                
                req.SetPayload(k_MaxUdpPayload - maxPacketSize + 1);
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);
                req.SetPayload(k_MaxUdpPayload);
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);
                req.SetPayload(k_MaxUdpPayload+1);
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);
                //req.SetPayload(100000);
                //bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);
                //req.SetPayload(100000000);
                //bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                if (!bAnyPassed)
                    this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        
        // Expected: failure
        [TestCase, Description("Too small packet size")]
        class TooSmallPacketSize : XDSTestBase
        {
            protected override void Execute()
            {
                CReflectionRequest req = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, 128);
                bool bAnyPassed = false;

                req._returnPacketSize--;
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                req.SetPayload(0);
                req._returnPacketSize--;
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                if (!bAnyPassed)
                    this.ResultCode = TEST_RESULTS.PASSED;

            }
        }

        // Expected: failure
        [TestCase, Description("Too big packet size")]
        class TooBigPacketSize : XDSTestBase
        {
            protected override void Execute()
            {
                CReflectionRequest req = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, 128);
                int maxPacketSize = Math.Max(CReflectionRequest.PacketSize, CReflectionReply.PacketSize);
                bool bAnyPassed = false;
                
                req.SetPayload(k_MaxUdpPayload - maxPacketSize);
                req._returnPacketSize++;
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                req.SetPayload(128);
                req._returnPacketSize = (ushort)(k_MaxUdpPayload + 1);
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                if (!bAnyPassed)
                    this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // Expected: failure
        [TestCase, Description("Random data")]
        class RandomData : XDSTestBase
        {
            protected override void Execute()
            {
                IPEndPoint host = Global.XEnv.GetVirtualInterface(VirtualInterface.xds);
                byte[] packet;
                byte[] reply;
                System.Random rand = new System.Random();
                for (int i = 0; i < 5; i++)
                {
                    packet = new byte[rand.Next(k_MaxUdpPayload)];
                    rand.NextBytes(packet);
                    reply = SimpleUdp.SendRecv(packet, host, k_TimeoutQuick);
                    if (reply != null)
                    {
                        this.ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                }
                this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // Expected: failure
        // It seems XDS will ignore all protocol versions except for 1
        [TestCase, Description("Bad protocol version")]
        class BadProtocol : XDSTestBase
        {
            protected override void Execute()
            {
                CReflectionRequest req = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, 128); 
                bool bAnyPassed = false;

                req._protocolVersion = 0;
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                req._protocolVersion = 2;
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                // Sanity check, make sure this still passes
                req._protocolVersion = 1;
                bAnyPassed |= !req.SendRecvVerify(k_TimeoutQuick);

                if (!bAnyPassed)
                    this.ResultCode = TEST_RESULTS.PASSED;
            }
        }

        // Expected: failure
        // It seems XDS will ignore all request types except SAMEIPPORT.
        [TestCase, Description("Bad request type")]
        class BadRequestType : XDSTestBase
        {
            protected override void Execute()
            {
                CReflectionRequest req = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, 128); 
                bool bAnyPassed = false;

                req._requestType = (ushort)XDS_REQUEST_TYPES.SAMEIP_DIFFERENTPORT;
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                req._requestType = (ushort)XDS_REQUEST_TYPES.DIFFERENTIP_SAMEPORT;
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                req._requestType = (ushort)XDS_REQUEST_TYPES.ICMP;
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);
                
                req._requestType = (ushort)XDS_REQUEST_TYPES.LOG;
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                req._requestType = 5;  // max defined is 4
                bAnyPassed |= req.SendRecvVerify(k_TimeoutQuick);

                // Sanity check, make sure this still passes
                req._requestType = (ushort)XDS_REQUEST_TYPES.SAMEIPPORT;
                bAnyPassed |= !req.SendRecvVerify(k_TimeoutQuick);

                if (!bAnyPassed)
                    this.ResultCode = TEST_RESULTS.PASSED;
            }
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\XDSTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\XDSTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xdstest_none_12.4.56.0_none_e74cd7ef9cf75e20
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xdstest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c.manifest
XP_MANIFEST_PATH=manifests\msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c.cat
XP_CATALOG_PATH=manifests\msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c.cat
XP_PAYLOAD_PATH=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xdstest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\XDSTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xdstest_none_12.4.56.0_none_e74cd7ef9cf75e20
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xdstest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c.manifest
XP_MANIFEST_PATH=manifests\msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c.cat
XP_CATALOG_PATH=manifests\msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c.cat
XP_PAYLOAD_PATH=msil_xdstest_no-public-key_12.4.56.0_x-ww_9813d95c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xdstest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\stress\StressComponent.cs ===
using System;
using System.Threading;
using System.Xml;
using System.Net;
using System.Net.Sockets;
using System.Timers;
using xonline.server.download.test.functional;

namespace xonline.server.download.test.stress 
{

    // used to store data for test cases.
    public struct TestCase
    {
        public ushort  _protocolVersion;
        public ushort  _requestType;
        public ushort  _returnPacketSize;
        public string  _payload;
        public string  _xboxSerialNumber;
        public string  _PPA1;
        public ushort  _lengthToLog;
        public string  _logdata;
        public uint    _packetsize;
    }

    // statistics structure
    public class CStressStats
    {
        protected long _success_Reflect;
        protected long _success_ICMP;
        protected long _success_Log;
        protected long _fail_Reflect;
        protected long _fail_ICMP;
        protected long _fail_Log;
        protected long _timeout;
        protected DateTime _startTime;

        public void GetStats( 
            ref long success_ref, 
            ref long success_icmp, 
            ref long success_log, 
            ref long fail_ref, 
            ref long fail_icmp, 
            ref long fail_log, 
            ref long timeout,
            ref long timeIntervalInSecs)
        {
            DateTime dt;
            TimeSpan tsNow;
            TimeSpan tsStart;

            lock( this )
            {
                // copy out the current values and unlock.
                success_ref = _success_Reflect;
                success_icmp = _success_ICMP;
                success_log = _success_Log;
                fail_ref = _fail_Reflect;
                fail_icmp = _fail_ICMP;
                fail_log = _fail_Log;
                timeout = _timeout;
                dt = DateTime.Now;
            }

            tsNow = new TimeSpan( dt.Ticks );
            tsStart = new TimeSpan( _startTime.Ticks );

            timeIntervalInSecs = (long)((tsNow - tsStart).TotalSeconds);
        }

        public void INC_Successful_Reflect()
        {
            lock( this )
            {
                _success_Reflect++;
            }
            Console.Write("+");
        }

        public void INC_Successful_ICMP()
        {
            lock( this )
            {
                _success_ICMP++;
            }
            Console.Write("+");
        }

        public void INC_Successful_Log()
        {
            lock( this )
            {
                _success_Log++;
            }
            Console.Write("+");
        }

        public void INC_Fail_Reflect()
        {
            lock( this )
            {
                _fail_Reflect++;
            }
            Console.Write("-");
        }

        public void INC_Fail_ICMP()
        {
            lock( this )
            {
                _fail_ICMP++;
            }
            Console.Write("-");
        }

        public void INC_Fail_Log()
        {
            lock( this )
            {
                _fail_Log++;
            }
            Console.Write("-");
        }

        public void INC_Timeout()
        {
            lock( this )
            {
                _timeout++;
            }
            Console.Write("X");
        }

        public void Start_Time()
        {
            lock(this)
            {
                _startTime = DateTime.Now;
            }
        }

    }

    /// <summary>
	/// Summary description for StressComponent.
	/// </summary>
	public class StressMgr
	{
        protected StressThread[]    _aStressThreadList;
        protected int               _numberOfThreads;
        protected int               _numberOfXdsIPs;
        protected CfgIPAddr[]       _xdsIPAddrs;
        protected int               _numberOfTestCases;
        protected TestCase[]        _testcases;

        public CStressStats         _stats;


		public StressMgr( string xmlCfgFileName )
		{
            // load form xml ini file.
            LoadConfig( xmlCfgFileName );

            // create teh statistics.
            _stats = new CStressStats();
            
            // create and start the threads.
            CreateThreads();
		}

        public void Close()
        {
            // start all the threads.
            for ( int nCount = 0; nCount < _numberOfThreads; nCount++ )
            {
                _aStressThreadList[nCount].Close();
            }            
        }

        private void LoadConfig( string xmlCfgFileName )
        {
            XmlDocument cfg = new XmlDocument();
            int nCount = 0;

            //Load the the document with the last book node.
            XmlTextReader reader = new XmlTextReader( xmlCfgFileName );
            reader.WhitespaceHandling = WhitespaceHandling.None;
            reader.MoveToContent();
            cfg.Load(reader);

            XmlElement xdstest = cfg.DocumentElement;
            XmlNodeList nl = xdstest.SelectNodes( "//xdstest/stress/config/threads" );

            // we'll only consider the first setting.
            _numberOfThreads = int.Parse((nl[0].Attributes.GetNamedItem("number")).Value);
            
            // load the xds ip configuration.
            nl = xdstest.SelectNodes( "//xdstest/stress/config/xdsip" );
            _numberOfXdsIPs = nl.Count;

            _xdsIPAddrs = new CfgIPAddr[_numberOfXdsIPs];
            foreach( XmlNode xn in nl )
            {
                _xdsIPAddrs[nCount]._ipAddr     = xn.Attributes.GetNamedItem("ip").Value;
                _xdsIPAddrs[nCount]._port       = ushort.Parse(xn.Attributes.GetNamedItem("port").Value);
                _xdsIPAddrs[nCount]._nUsagePct  = int.Parse(xn.Attributes.GetNamedItem("usagePct").Value);

                nCount++;
            }

            // load the test cases.
            nl = xdstest.SelectNodes( "//xdstest/stress/cases" );
            _numberOfTestCases = nl.Count;

            // reset the counter;
            nCount = 0;

            // setup up the array.
            _testcases = new TestCase[_numberOfTestCases];
            foreach( XmlNode xn in nl )
            {
                _testcases[nCount]._protocolVersion     = ushort.Parse(xn.Attributes.GetNamedItem("protocolversion").Value);
                _testcases[nCount]._requestType         = ushort.Parse(xn.Attributes.GetNamedItem("requesttype").Value);
                _testcases[nCount]._returnPacketSize    = ushort.Parse(xn.Attributes.GetNamedItem("returnpacketsize").Value);
                _testcases[nCount]._payload             = xn.Attributes.GetNamedItem("payload").Value;

                // store extra stuff for the special case.
                if ( _testcases[nCount]._requestType == 4 )
                {
                    _testcases[nCount]._xboxSerialNumber    = xn.Attributes.GetNamedItem("xboxsn").Value;
                    _testcases[nCount]._PPA1                = xn.Attributes.GetNamedItem("ppa1").Value;
                    _testcases[nCount]._logdata             = xn.Attributes.GetNamedItem("log").Value;
                    _testcases[nCount]._packetsize          = uint.Parse(xn.Attributes.GetNamedItem("packetsize").Value);

                }
                else if ( _testcases[nCount]._requestType == 3 )
                {
                    _testcases[nCount]._packetsize = uint.Parse(xn.Attributes.GetNamedItem("packetsize").Value);
                }

                nCount++;
            }
        
        }

        // responsible for setting up the threads and starting them.
        private void CreateThreads()
        {
            int nCount = 0;
            Random rand = new Random();
            int totalPct = 0;

            // create the thread list.
            _aStressThreadList = new StressThread[_numberOfThreads];

            // get the total percentage these amount to.
            foreach( CfgIPAddr cia in _xdsIPAddrs )
            {
                totalPct += cia._nUsagePct;
            }

            // create each thread with different params.
            for ( nCount = 0; nCount < _numberOfThreads; nCount++ )
            {
                string chosenRemoteIp = "";
                int chosenRemotePort = 0;
                int selection = 0;
                int nRange = 0;

                selection = rand.Next( totalPct );

                // check which sector the selection fell into.
                for ( int nX = 0; nX < _numberOfXdsIPs; nX++ )
                {
                    // check the range
                    if ( selection >= nRange && selection <= ( nRange + _xdsIPAddrs[nX]._nUsagePct ))
                    {
                        // set the default values... we're using this one.
                        chosenRemoteIp      = _xdsIPAddrs[nX]._ipAddr;
                        chosenRemotePort    = _xdsIPAddrs[nX]._port;
                        break;
                    }
                    // move to the next sector.
                    nRange += _xdsIPAddrs[nX]._nUsagePct;
                }

                // figure out which test case this thread will run.
                selection = rand.Next( _numberOfTestCases );

                _aStressThreadList[nCount] = new StressThread( chosenRemoteIp, chosenRemotePort, _testcases[selection], _stats );
            }

            // set the starting time stamp.
            _stats.Start_Time();

            // start all the threads.
            for ( nCount = 0; nCount < _numberOfThreads; nCount++ )
            {
                _aStressThreadList[nCount].Start();
            }

        }

        protected struct CfgIPAddr
        {
            public string _ipAddr;
            public ushort _port;
            public int    _nUsagePct;
        }

	}


    public class StressThread
    {
        protected Socket        _udp;
        protected Thread        _internalThread;
        protected string        _remoteIpAddr;
        protected int           _port;
        protected TestCase      _testcase;
        protected CStressStats  _stats;

        public StressThread( string remoteIpAddr, int port, TestCase testcase, CStressStats stats )
        {
            _remoteIpAddr = remoteIpAddr;
            _port = port;

            _testcase = testcase;

            _stats = stats;

            _udp = new Socket( AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );

            // bind to the local host.
            IPHostEntry localHE = Dns.GetHostByName(Dns.GetHostName());
				
            //Bind the UDP client to any local port chosen by the kernel.
            IPEndPoint localIpEP = new IPEndPoint( localHE.AddressList[0], 0 );
				
            _udp.Bind( localIpEP );

            ThreadStart ts = new ThreadStart( Run );
            _internalThread = new Thread(ts);

        }

        public void Start()
        {
            _internalThread.Start();
        }

        public void Close()
        {
            _internalThread.Abort();
            _internalThread = null;
            _udp.Close();
        }

        private void Run()
        {
            // do until told otherwise.
            while (true)
            {
                try
                {
                    uint selected = _testcase._requestType;
                    CReflectionReply reply = null;

                    switch( selected )
                    {
                        case 0:
                        case 1:
                        case 2:
                        {
                            ReflectionRequest( ref reply );
                        }
                            break;
                        case 3:
                        {
                            if ( ReflectionRequest( ref reply ) )
                            {
                                ICMPRequest( reply );
                            }
                        }
                            break;
                        case 4:
                        {
                            if ( ReflectionRequest( ref reply ) )
                            {
                                LogRequest( reply );
                            }
                        }
                            break;
                        default:
                            break;
                    }
                    

                }
                catch ( ThreadAbortException ae )
                {
                    string something = ae.Message;
                    break;
                }
                catch ( Exception e )
                {
                    string something = e.Message;
                    _stats.INC_Timeout();

                    // do something with e.
                }
            }
        }

        private bool ReflectionRequest( ref CReflectionReply rreply )
        {
            CReflectionRequest request = null;
            byte[] msg = null;
            byte[] resp = new byte[_testcase._returnPacketSize];
            string output = "";
            bool bRes = false;
            ushort requesttype = 0;
            string payload = "";

            // see what is being requested.        
            if ( _testcase._requestType == 3 || _testcase._requestType == 4 )
            {
                requesttype = (ushort)0;
            }
            else
            {
                requesttype = (ushort)_testcase._requestType;
            }

            // set random data for payload test.
            if ( _testcase._payload == "*" )
            {
                payload = GenerateRandomString( (_testcase._returnPacketSize) - 37 );
            }
            else
            {
                payload = _testcase._payload;
            }

            // gather variables
            request = new CReflectionRequest( _testcase._protocolVersion,
                requesttype, 
                _testcase._returnPacketSize,
                payload
                );

            // build 
            msg = request.GetPacket();

            if ( UdpSendAndReceive( 5, msg, resp ) )
            {
                // received response.
                output += "Received Size=" + resp.Length;

                CReflectionReply rr = new CReflectionReply( resp );

                if ( request.VerifyReply( rr ) )
                {
                    _stats.INC_Successful_Reflect();

                    // log results.
                    rreply = rr;
                    bRes = true;
                }
                else
                {
                    _stats.INC_Fail_Reflect();
                    bRes = false;
                }
            }
            else
            {
                _stats.INC_Timeout();
                bRes = false;
            }

            return bRes;
        
        }

        private bool ICMPRequest( CReflectionReply rr )
        {
            CICMPRequest request = null;
            byte[] msg = null;
            byte[] resp = new byte[128];
            bool bRes = true;                        
        
            request = new CICMPRequest( _testcase._protocolVersion,
                _testcase._requestType, 
                rr.Signature,
                rr.TimeStamp,
                _testcase._packetsize
                );

            // build 
            msg = request.GetPacket();

            if ( UdpSendAndReceive( 5, msg, resp ) )
            {
                _stats.INC_Fail_ICMP();
                bRes = false;
            }
            else
            {
                _stats.INC_Successful_ICMP();
                bRes = true;
            }

            return bRes;
        
        }

        private bool LogRequest( CReflectionReply rr )
        {
            CLogRequest request = null;
            byte[] msg = null;
            byte[] resp = new byte[128];
            string output = "";
            bool bRes = true;
            string PPA = "";
                        
            // check the PPA field... * for random data.
            if ( _testcase._PPA1 == "*" )
            {
                PPA = GenerateRandomString( 20 );
            }
            else
            {
                PPA = _testcase._PPA1;
            }

            request = new CLogRequest( _testcase._protocolVersion,
                _testcase._requestType, 
                rr.Signature,
                rr.TimeStamp,
                _testcase._xboxSerialNumber,
                PPA, 
                (ushort)_testcase._logdata.Length,
                _testcase._logdata,
                _testcase._packetsize
                );

            // build 
            msg = request.GetPacket();

            if ( UdpSendAndReceive( 5, msg, resp ) )
            {
                // received response.
                output += "Received Size=" + resp.Length;

                CLogReply reply = new CLogReply( resp );
                
                if ( request.VerifyReply( reply ) )
                {
                    _stats.INC_Successful_Log();
                }
                else
                {
                    _stats.INC_Fail_Log();
                    bRes = false;
                }
            }
            else
            {
                _stats.INC_Timeout();
                bRes = false;
            }
        
            return bRes;
        }

        private bool UdpSendAndReceive( int timeOutInSecs, byte[] sendData, byte[] recvData )
        {
            System.Net.IPEndPoint remoteIPEP = null;
            bool bRes = true;
            int bytesSent = 0;
            int bytesRecv = 0;
                        
            try 
            {
                remoteIPEP = new IPEndPoint( IPAddress.Parse(_remoteIpAddr), _port );
		
                bytesSent = _udp.SendTo( sendData,  remoteIPEP );

                // ensure we sent the entire packet.
                if ( bytesSent != sendData.Length )
                {
                    throw new Exception( "The number of bytes sent does not equal the number of bytes in buffer.  bytesSent="
                        + bytesSent.ToString() + " data length=" + sendData.Length.ToString()
                        + " remote IP=" + _remoteIpAddr );
                }
                
                // poll for results
                if ( _udp.Poll( timeOutInSecs * 1000000, SelectMode.SelectRead ) )
                {
                    EndPoint remoteEP = (remoteIPEP);

                    // receive bytes.
                    bytesRecv = _udp.ReceiveFrom( recvData, ref remoteEP );

                }
                else
                {
                    bRes = false;
                }                
            }
            catch ( System.Exception exception )
            {
                string something = exception.Message;
                bRes = false;
            }

            return bRes;
        }

        private string GenerateRandomString( int size )
        {
            string result = "";
            byte[] randData = new byte[size];
            System.Text.ASCIIEncoding asci = new System.Text.ASCIIEncoding();

            System.Random rand = new System.Random();
            
            rand.NextBytes( randData );
            result = asci.GetString( randData );
            return result;
        }

    }
               
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\test\XDSTest\XDSTestBase.cs ===
using System;
using System.Net;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Diagnostics;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XDSTest
{
    /// <summary>
    /// Useful base functions for XDS tests
    /// </summary>
    abstract class XDSTestBase : TestBase
    {
        public static int k_MaxUdpPayload = 1472;
        public static int k_TimeoutQuick = 2000;
        public static int k_TimeoutLong = 5000;
        public static int k_TimeoutICMP = 1000;  // never expecting anything back

        protected string GenerateRandomString( int size )
        {
            string result = "";
            byte[] randData = new byte[size];
            System.Text.ASCIIEncoding asci = new System.Text.ASCIIEncoding();

            System.Random rand = new System.Random();
            
            rand.NextBytes( randData );
            result = asci.GetString( randData );
            return result;
        }
    }

    [StressInstantiate]
    public abstract class XDSStressTestBase : TestBase
    {
        public const int                        NumStoreItems       = 50;

        static public Report                    ro                  = new Report("XdsStress");
        static public Random                    rand                = new Random();
        static public KerbStoreGeneric          storeReflection     = new KerbStoreGeneric(0, NumStoreItems);
        static public KerbStoreGeneric          storeICMP           = new KerbStoreGeneric(0, NumStoreItems);
        static public object                    lockInit            = new object();
        static public bool                      bStoreInitialized   = false;

        // Cached payloads, byte[]
        static public ArrayList                 cachedPayloads      = new ArrayList(16);

//        static XDSStressTestBase()
//        {
//        }

        protected void Initialize()
        {
            lock(lockInit)
            {
                for (int i = 0; i < NumStoreItems; i++)
                {
                    CReflectionRequest refreq = new CReflectionRequest((ushort)XDS_REQUEST_TYPES.SAMEIPPORT, 128);
                    storeReflection.Add(refreq);

                    // signature and timestamp need to be filled in from the CReflectionReply packet
                    CICMPRequest icmpreq = new CICMPRequest(1, (ushort)XDS_REQUEST_TYPES.ICMP, null, 0, (uint)CICMPRequest.PacketSize);
                    storeICMP.Add(icmpreq);
                }

                bStoreInitialized = true;
            }
        }

        protected CReflectionRequest GetReflectionRequest()
        {
            if (storeReflection == null)
            {
                throw new Exception("Reflection store not properly initialized yet, this shouldn't happen");
            }
            object o = storeReflection.Get();
            if (o == null)
            {
                throw new Exception("We just retrieved a null object from storeReflection, this shouldn't happen");
            }
            return (CReflectionRequest)o;
        }        

        protected CICMPRequest GetICMPRequest()
        {
            if (storeICMP == null)
            {
                throw new Exception("ICMP store not properly initialized yet, this shouldn't happen");
            }
            object o = storeICMP.Get();
            if (o == null)
            {
                throw new Exception("We just retrieved a null object from storeICMP, this shouldn't happen");
            }
            return (CICMPRequest)o;
        }        

        protected override void Execute()
        {
            System.DateTime startTime = System.DateTime.Now;
            ResultCode = TEST_RESULTS.PASSED;

            if (!bStoreInitialized)
                Initialize();

            try
            {
                if (!XdsExecute())
                {
                    throw new UnexpectedTestResultException("Verify failed");
                }

            }
            catch (System.TimeoutException e)
            {
                ro.Warn("Timed out in {0}ms: {1}", (System.DateTime.Now-startTime).TotalMilliseconds * 1000, e.Message);
                ResultCode = TEST_RESULTS.FAILED;
            }
            catch (UnexpectedTestResultException e)
            {
                ro.Warn("Unexpected test result: {0}", e.Message);
                System.Threading.Thread.Sleep(100);
                ResultCode = TEST_RESULTS.FAILED;
            }
        }



        public bool DoReflection(int payloadSize)
        {
            bool bRetval;
            CReflectionRequest req = GetReflectionRequest();
            
            // No one else can use this object until we're done with it
            lock (req)
            {
                if (req._payload == null || req._payload.Length != payloadSize)
                {
                    byte[] payload = null;
                    for (int i = 0; i < cachedPayloads.Count; i++)
                    {
                        if (payloadSize == ((byte[])cachedPayloads[i]).Length)
                        {
                            payload = (byte[])cachedPayloads[i];
                            break;
                        }
                    }
                    if (payload == null)
                    {
                        payload = new byte[payloadSize];
                        rand.NextBytes(payload);
                        cachedPayloads.Add(payload);
                        ro.Debug("Added new item to cachedPayloads of size {0}", payloadSize);
                    }
                    req._payload = payload;
                    req._returnPacketSize = (ushort)(payloadSize + CReflectionReply.PacketSize);
                }
                bRetval = req.SendRecvVerify(5000);
            }
            return bRetval;            
        }

        public bool DoICMP()
        {
            bool bRetval;
            CICMPRequest req = GetICMPRequest();
            
            // No one else can use this object until we're done with it
            lock (req)
            {
                // If signature is null then we haven't sent the reflection request yet, so fill
                // it in. This should only need to be done once per ICMP packet.
                // Also, if the packet is too old, we need to do a reflection request to get a
                // fresh timestamp.  In testnet, XDS will ignore packets older than 5 minutes,
                // so we'll set our refresh interval less than that.
                long timediff = System.DateTime.Now.Ticks - req._localtimestamp;
                
                // Our threshold is 2 minutes plus or minus 30 seconds
                // Ticks is in 100-nanosecond intervals
                long randsecs = rand.Next(60) - 30;
                long timediffthresh = (120 + randsecs) * (1000 * 1000 * 10);
                
                if (req._signature == null || timediff >= timediffthresh)
                {
                    // Make reflection request first
                    CReflectionRequest req1 = new CReflectionRequest(128); 

                    if (req1.SendRecvVerify(4000))
                    {
                        // Now we can make the ICMP request
                        req.SetTimestamp(req1.reply.Signature, req1.reply.TimeStamp);
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("Reflection request for ICMP packet failed");
                    }
                }

                // If we're getting UDP Connection Reset events, we should wait for one,
                // which will give us definitive proof that the ICMP packet got through.
                // If we're not getting the reset events, then we can't verify we got
                // a reply, so we shouldn't wait for anything. We'll just fling packets
                // as fast as possible, I suppose.
                bRetval = req.SendRecvVerify(0);

                // If we get no reply, SendRecvVerify returns false. This does not mean it failed
                // necessarily.
                bRetval = true;
            }
            return bRetval;            
        }

        protected abstract bool XdsExecute();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\SAS.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.client
{
    /// <summary>
    /// This class is used to retrieve or upload table data to Azure Storage
    /// </summary>
    public class SAS
    {
        /// <summary>
        /// Single location to use for calculating the Blob Path. If the Blob path changes in design
        /// it only needs to be changed here to avoid massive test updates. All tests should use these
        /// functions rather than calculating the path themselves
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="fileName"></param>
        /// <param name="transactionGuid"></param>
        /// <returns>String BlobPath for BlobStorage</returns>
        public static string GetStoragePath(ulong xuid, string fileName, Guid transactionGuid)
        {
            return GetStoragePath(xuid, fileName, transactionGuid.ToString("N"));
        }

        public static string GetStoragePath(ulong xuid, string fileName, string transactionId)
        {
            return GetStoragePath(xuid.ToString("X16"), fileName, transactionId);
        }

        public static string GetStoragePath(string xuidString, string fileName, string transactionId)
        {
            string storagePath = string.Format("{0}/{1}.{2}", xuidString, fileName, transactionId);

            return storagePath;
        }

        /// <summary>
        /// Generates an SAS query URL that is equivalent to what the Client FrontDoor would return. 
        /// This URL can be used to directly download a file without needing any managed code
        /// </summary>
        /// <param name="storageUri"></param>
        /// <param name="container"></param>
        /// <param name="xuid"></param>
        /// <param name="fileName"></param>
        /// <param name="transactionId"></param>
        /// <param name="signature"></param>
        /// <returns>URL for direct file access using the provided SAS signature</returns>
        public static string GetSASUrl(string storageUri, string container, ulong xuid, string fileName, string transactionId, string signature)
        {
            return GetSASUrl(storageUri, container, xuid.ToString("X16"), fileName, transactionId, signature);
        }

        public static string GetSASUrl(string storageUri, string container, string xuid, string fileName, string transactionId, string signature)
        {
            string storagePath = GetStoragePath(xuid, System.Web.HttpUtility.UrlEncode(fileName), transactionId); 
            string sasFileUrl = String.Format("{0}/{1}/{2}{3}",
                storageUri, container, storagePath, signature);

            return sasFileUrl;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\DownloaderApp.cs ===
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Serialization;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using System.Net;

namespace xonline.server.xlfs.client
{
    /// <summary>
    /// This class is used to retrieve or upload table data to Azure Storage
    /// </summary>
    public class DownloaderApp
    {
        #region Locals and Publics

        public string ConfigFile
        {
            get
            {
                string _AppDirectory = System.IO.Path.GetDirectoryName(Assembly.GetCallingAssembly().Location);
                return System.IO.Path.Combine(_AppDirectory, "XlfsDownloaderConfig.xml");
            }
        }
        #endregion

        private void DownloadMetaData(
            BackgroundWorker bw,
            DoWorkEventArgs e,
            XlfsBackgroundDownloadProgress progress,
            SASInfo entrySAS,
            string saveDirectory
            )
        {
            XlfsFileEntry entry = progress.File;

            // Get the full SAS URL that we will need to download the file
            string entrySASUrl = SAS.GetSASUrl(
                entrySAS.StorageUri.AbsoluteUri,
                entrySAS.Container,
                entry.Xuid,
                entry.Filename,
                entry.TransactionId,
                entrySAS.Signature
                );
            string downloadMetadata = "";

            BlobClient blobClient = null;

            // Create the full and final file name
            downloadMetadata = System.IO.Path.Combine(
                saveDirectory,
                entry.Xuid + "." +
                entry.TitleId.ToString("X8") + "." +
                entry.Filename + ".metadata"
                );

            // Determine the full name of the blob path
            string blobPath = SAS.GetStoragePath(
                entry.Xuid,
                entry.Filename,
                entry.TransactionId
                );

            // Write the metadata
            using (TextWriter metaWriter = System.IO.File.CreateText(downloadMetadata))
            {
                BlobStream blobStream = null;

                // Check to see if the task has been cancelled
                if (bw.CancellationPending == true)
                {
                    e.Cancel = true;
                    return;
                }

                // Make sure that we have an open blob client
                if (blobClient == null)
                {
                    blobClient = new BlobClient(
                        entrySAS.Signature, 
                        entrySAS.StorageUri.AbsoluteUri
                        );
                    blobClient.BlobContainer = entrySAS.Container;

                    // Reset the blob stream as well
                    blobStream = null;
                }

                // Make sure that we have an open blob stream
                if (blobStream == null)
                {
                    blobStream = blobClient.OpenRead(blobPath);
                    blobStream.Seek(0, SeekOrigin.Begin);
                }

                NameValueCollection metaData = blobClient.BlobMetadata;

                // Build an XML document with the NVC
                XDocument metaXmlDocument = new XDocument(
                    new XComment(
                        entry.Xuid + "." +
                        entry.TitleId.ToString("X8") + "." +
                        entry.Filename
                        ));

                // Create the Root Element
                XElement metaXml = new XElement("Metadata");
                metaXmlDocument.Add(metaXml);

                // Build the rest of the xml
                for (int i = 0; i < metaData.Count; i++)
                {
                    metaXml.Add(
                        new XElement(
                            metaData.GetKey(i),
                            metaData.GetValues(i)
                            ));
                }

                // Write the meta data out
                metaWriter.Write(metaXmlDocument.ToString());
            }

            // Let the report UI know that the file is fully downloaded
            bw.ReportProgress(1000, entry);

        }

        private void DownloadFile(
            BackgroundWorker bw, 
            DoWorkEventArgs e, 
            XlfsBackgroundDownloadProgress progress,
            SASInfo entrySAS, 
            string saveDirectory
            )
        {
            XlfsFileEntry entry = progress.File;

            // Get the full SAS URL that we will need to download the file
            string entrySASUrl = SAS.GetSASUrl(
                entrySAS.StorageUri.AbsoluteUri,
                entrySAS.Container,
                entry.Xuid,
                entry.Filename,
                entry.TransactionId,
                entrySAS.Signature
                );
            string downloadTarget = "";
            string downloadMetadata = "";

            BlobClient blobClient = null;

            // Create the full and final file name
            downloadTarget = System.IO.Path.Combine(
                saveDirectory,
                entry.Xuid + "." +
                entry.TitleId.ToString("X8") + "." +
                entry.Filename
                );

            // Create the full and final file name for the metadata
            downloadMetadata = downloadTarget + ".metadata";

            // Determine the full name of the blob path
            string blobPath = SAS.GetStoragePath(
                entry.Xuid, 
                entry.Filename, 
                entry.TransactionId
                );

            // Create the file
            using (FileStream fileStream = File.Create(downloadTarget))
            {
                BlobStream blobStream = null;
                byte[] fileData = new byte[1024 * 1024];
                long dataDownloaded = 0;
                long dataRemaining = (long)entry.Size;
                int dataRead;
                int dataToRead;
                int retries = 0;

                // Start reading from the stream
                while (dataRemaining > 0)
                {
                    // Check to see if the task has been cancelled
                    if (bw.CancellationPending == true)
                    {
                        e.Cancel = true;
                        return;
                    }

                    // Make sure that we have an open blob client
                    if (blobClient == null)
                    {
                        blobClient = new BlobClient(
                            entrySAS.Signature, 
                            entrySAS.StorageUri.AbsoluteUri
                            );
                        blobClient.BlobContainer = entrySAS.Container;

                        // Reset the blob stream as well
                        blobStream = null;
                    }

                    // Make sure that we have an open blob stream
                    if (blobStream == null)
                    {
                        blobStream = blobClient.OpenRead(blobPath);
                        blobStream.Seek(dataDownloaded, SeekOrigin.Begin);
                    }

                    // Determine the number of bytes to read
                    if (dataRemaining > fileData.Length)
                    {
                        dataToRead = fileData.Length;
                    }
                    else
                    {
                        dataToRead = (int)dataRemaining;
                    }

                    // Read some data from the request
                    try
                    {
                        // Read from the stream and write to the disk
                        dataRead = blobStream.Read(fileData, 0, dataToRead);
                        fileStream.Write(fileData, 0, dataRead);

                        // Update the location
                        dataRemaining -= dataRead;
                        dataDownloaded += dataRead;
                        progress.OverallBytesDownloaded += dataRead;
                        progress.FileBytesDownloaded += dataRead;

                        // Let the report UI know that the file is partially downloaded
                        bw.ReportProgress(
                            (int) (dataDownloaded * 1000 / (long) entry.Size), 
                            progress
                            );

                        // Reset our retry count
                        retries = 0;
                    }
                    catch (Exception exception)
                    {

                        // Close our current objects and try again next loop
                        blobClient = null;
                        blobStream = null;

                        // Remember that we failed once
                        retries++;
                        if (retries >= 5)
                        {
                            throw exception;
                        }
                    }
                }
            }

            // Check to make sure we still have a blobclient
            if (blobClient == null)
            {
                return;
            }

            // Write the metadata
            using (TextWriter metaWriter = System.IO.File.CreateText(downloadMetadata))
            {
                NameValueCollection metaData = blobClient.BlobMetadata;

                // Build an XML document with the NVC
                XDocument metaXmlDocument = new XDocument(
                    new XComment(
                        entry.Xuid + "." +
                        entry.TitleId.ToString("X8") + "." +
                        entry.Filename
                        ));

                // Create the Root Element
                XElement metaXml = new XElement("Metadata");
                metaXmlDocument.Add(metaXml);

                // Build the rest of the xml
                for (int i = 0; i < metaData.Count; i++)
                {
                    metaXml.Add(
                        new XElement(
                            metaData.GetKey(i),
                            metaData.GetValues(i)
                            ));
                }

                // Write the meta data out
                metaWriter.Write(metaXmlDocument.ToString());
            }

            // Fully downloaded
            entry.LastDownloaded = DateTime.UtcNow;

            // Let the report UI know that the file is fully downloaded
            bw.ReportProgress(1000, entry);
        }

        public void DownloadFiles(object sender, DoWorkEventArgs e)
        {
            // Do not access the form's BackgroundWorker reference directly.
            // Instead, use the reference provided by the sender parameter.
            BackgroundWorker bw = sender as BackgroundWorker;

            // Extract the argument.
            XlfsBackgroundDownloadArgs args = e.Argument as XlfsBackgroundDownloadArgs;
            if (args == null)
            {
                return;
            }

            // Keep a running total of the number of files downloaded
            int filesDownloaded = 0;

            // Keep an object to track the file download progress
            XlfsBackgroundDownloadProgress progress = new XlfsBackgroundDownloadProgress();

            IEnumerable<XlfsFileEntry> files = null;

            if (String.IsNullOrEmpty(args.Filter))
            {
                files = args.Files;
            }
            else
            {
                // Create a regex from the filter wildcarded filter string.
                String filter = System.Text.RegularExpressions.Regex.Escape(args.Filter);
                filter = '^' + filter.Replace("\\*", ".*") + '$';

                Func<XlfsFileEntry, Boolean> filterMatch =
                    delegate(XlfsFileEntry entry)
                    {
                        return System.Text.RegularExpressions.Regex.IsMatch(entry.Filename, filter);
                    };

                files = args.Files.Where(filterMatch);
            }

            // Do a quick loop throug the code to figure out the total number of bytes to download
            foreach (XlfsFileEntry entry in files)
            {
                progress.OverallBytes += entry.Size;
            }

            // Download each file
            foreach (XlfsFileEntry entry in files)
            {
                if (bw.CancellationPending == true)
                {
                    e.Cancel = true;
                    break;
                }

                // We might have already downloaded this file
                if (entry.LastDownloadAttempt.HasValue == true)
                {
                    continue;
                }

                SASInfo entrySAS;

                // Safely attempt to resolve the storage account in the SAS dictionary
                bool result = args.SAS.TryGetValue(entry.StorageAccount, out entrySAS);
                if (result == false)
                {
                    continue;
                }

                // Check to see if the current SAS entry is expired
                if (entrySAS.Expiry.AddMinutes( -10 ) < DateTime.UtcNow)
                {
                    // Setup the call
                    XlfsAdminGetChangedBlobsContinue getBlobs = new XlfsAdminGetChangedBlobsContinue();
                    getBlobs.TitleId = args.TitleId;
                    getBlobs.XlfsServer = args.ServerAddress;
                    getBlobs.XlfsCertificateName = args.CertificateName;
                    getBlobs.XlfsCertificateThumbprint = args.CertificateThumbprint;

                    // Make the call. If anything goes wrong here, it will be passed back 
                    // to our completion object
                    getBlobs.Execute();

                    // Pick up all of the SAS records
                    args.SAS.Clear();
                    foreach (KeyValuePair<String, SASInfo> sasEntry in getBlobs.SASDictionary)
                    {
                        args.SAS.Add(sasEntry.Key, sasEntry.Value);
                    }

                    // Safely attempt to resolve the storage account in the SAS dictionary
                    result = args.SAS.TryGetValue(entry.StorageAccount, out entrySAS);
                    if (result == false)
                    {
                        continue;
                    }
                }

                // Call the downloader to actually do the work
                progress.File = entry;
                progress.FileBytesDownloaded = 0;

                // Remember when we last attempted to download this file
                entry.LastDownloadAttempt = DateTime.UtcNow;

                if (args.MetaDataOnly == false)
                {
                    DownloadFile(bw, e, progress, entrySAS, args.SaveDirectory);
                }
                else
                {
                    DownloadMetaData(bw, e, progress, entrySAS, args.SaveDirectory);
                }

                // Update the downloaded percentage
                filesDownloaded++;
                bw.ReportProgress((filesDownloaded * 1000) / args.Files.Count);
            }
        }

        public void RefreshFiles(object sender, DoWorkEventArgs e)
        {
            // Do not access the form's BackgroundWorker reference directly.
            // Instead, use the reference provided by the sender parameter.
            BackgroundWorker bw = sender as BackgroundWorker;

            // Extract the argument.
            XlfsBackgroundEnumArgs args = e.Argument as XlfsBackgroundEnumArgs;
            if (args == null)
            {
                return;
            }

            // Remember the current start time
            DateTime startTime = args.StartTime;

            // Remember the progress we have made
            int numEnums = 0;
            int maxEnums = (int) (args.EndTime - args.StartTime).TotalHours;

            // In the case where the enum time is less than a single hour, maxEnums is currently zero, but 
            // we know that we will be doing at least a single enum
            if (maxEnums == 0)
            {
                maxEnums = 1;
            }

            string continuation = null;

            // Loop until we get no more files back
            while (startTime < args.EndTime)
            {
                // Check to see if there is a pending cancel
                if (bw.CancellationPending == true)
                {
                    e.Cancel = true;
                    break;
                }

                // Calculate the end time to be the start of the next hour
                DateTime endTime = new DateTime(
                    startTime.Year,
                    startTime.Month,
                    startTime.Day,
                    startTime.Hour,
                    0,
                    0,
                    startTime.Kind).AddHours(1);
                if (args.EndTime < endTime)
                {
                    endTime = args.EndTime;
                }

                // Setup the call
                XlfsAdminGetChangedBlobs getBlobs = new XlfsAdminGetChangedBlobs();
                getBlobs.StartTime = startTime;
                getBlobs.EndTime = endTime;
                getBlobs.TitleId = args.TitleId;
                getBlobs.XlfsServer = args.ServerAddress;
                getBlobs.XlfsCertificateName = args.CertificateName;
                getBlobs.XlfsCertificateThumbprint = args.CertificateThumbprint;
                getBlobs.Continuation = continuation;

                if (args.UseProxy)
                {
                    getBlobs.Proxy = args.ProxyAddress == null ? WebRequest.GetSystemWebProxy() : new WebProxy(args.ProxyAddress, true);
                }

                // Make the call. If anything goes wrong here, it will be passed back 
                // to our completion object
                getBlobs.Execute();

                // We made a call to the enumerator
                numEnums++;

                // If we have both NextPartitionKey and NextRowKey, then we need to make
                // another request for the current hour.
                if (!string.IsNullOrEmpty(getBlobs.Continuation))
                {
                    // There are still some files left this hour, so make another call,
                    // but remember that total number of calls has increased
                    continuation = getBlobs.Continuation;
                    maxEnums++;
                }
                else
                {
                    // Yes. Move the start time forward to the next hour
                    continuation = null;
                    startTime = endTime;
                }

                // Report to the progress handler
                bw.ReportProgress( (numEnums * 1000 / maxEnums), getBlobs);

                // Sleep for a second
                System.Threading.Thread.Sleep(1000);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\BlobClient.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;
using System.Security.Cryptography;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.client
{
    /// <summary>
    /// This class is used to retrieve or upload a file to Azure Storage
    /// </summary>
    public class BlobClient
    {
        protected string _storageAccountName = "devstoreaccount1";
        protected string _storageKey = "Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==";
        protected StorageCredentials _storageCredentials;
        protected Uri _blobBaseAddress = new Uri("http://127.0.0.1:10000/devstoreaccount1");
        protected CloudBlobContainer _blobContainer;
        protected CloudBlobClient _blobClient;
        protected NameValueCollection _blobMetadata;

        public BlobClient()
        {
            _storageCredentials = new StorageCredentialsAccountAndKey(_storageAccountName, _storageKey);
            InitializeClient();
        }

        public BlobClient(string accessToken, string cloudBaseAddress)
        {
            _storageCredentials = new StorageCredentialsSharedAccessSignature(accessToken);
            _blobBaseAddress = new Uri(cloudBaseAddress);

            try
            {
                InitializeClient();
            }
            catch
            {
                //Access Token may fail to "ListContainers"
                BlobContainer = "fffe07d1";
            }
        }

        protected virtual void InitializeClient()
        {
            _blobClient = new CloudBlobClient(_blobBaseAddress, _storageCredentials);
            if (_blobContainer == null)
            {
                List<CloudBlobContainer> containerList = _blobClient.ListContainers().ToList<CloudBlobContainer>();
                if (containerList.Count > 0)
                {
                    _blobContainer = containerList[0];
                }
            }
            else
            {
                _blobContainer = _blobClient.GetContainerReference(BlobContainer);
            }
        }

        public string StorageAccount
        {
            //get { return _storageAccountName; }
            set
            {
                _storageAccountName = value;
                _storageCredentials = new StorageCredentialsAccountAndKey(_storageAccountName, _storageKey);
                InitializeClient();
            }
        }

        public string StorageKey
        {
            set
            {
                _storageKey = value;
                _storageCredentials = new StorageCredentialsAccountAndKey(_storageAccountName, _storageKey);
                InitializeClient();
            }
        }

        public string AccessToken
        {
            set
            {
                _storageCredentials = new StorageCredentialsSharedAccessSignature(value);
                InitializeClient();
            }
        }

        public string CloudBaseAddress
        {
            get { return _blobBaseAddress.AbsoluteUri; }
            set { _blobBaseAddress = new Uri(value); InitializeClient(); }
        }

        public StorageCredentials Credentials
        {
            get { return _storageCredentials; }
            set { _storageCredentials = value; InitializeClient(); }
        }

        public string BlobContainer
        {
            get { return _blobContainer.Name; }
            set
            {
                _blobContainer = _blobClient.GetContainerReference(value);
            }
        }

        public NameValueCollection BlobMetadata
        {
            get { return _blobMetadata; }
        }

        #region MD5Hash
        public static string GetMD5HashString(byte[] inputBytes)
        {
            byte[] byteMD5 = GetMD5Hash(inputBytes);
            return Convert.ToBase64String(byteMD5);
        }

        public static string GetMD5HashString(string inputString)
        {
            byte[] byteMD5 = GetMD5Hash(inputString);
            return Convert.ToBase64String(byteMD5);
        }

        public static string GetMD5HashString(Stream inputStream)
        {
            byte[] byteMD5 = GetMD5Hash(inputStream);
            return Convert.ToBase64String(byteMD5);
        }

        public static byte[] GetMD5Hash(byte[] inputBytes)
        {
            MD5 md5Hasher = MD5.Create();
            byte[] byteMD5 = md5Hasher.ComputeHash(inputBytes);

            return byteMD5;
        }

        public static byte[] GetMD5Hash(string inputString)
        {
            MD5 md5Hasher = MD5.Create();
            byte[] byteMD5 = md5Hasher.ComputeHash(Encoding.Default.GetBytes(inputString));

            return byteMD5;
        }

        public static byte[] GetMD5Hash(Stream inputStream)
        {
            MD5 md5Hasher = MD5.Create();
            byte[] byteMD5 = md5Hasher.ComputeHash(inputStream);
            inputStream.Position = 0;

            return byteMD5;
        }
        #endregion

        public List<string> GetContainers()
        {
            List<string> containerNameList = new List<string>();

            List<CloudBlobContainer> containerList = _blobClient.ListContainers().ToList<CloudBlobContainer>();
            foreach (CloudBlobContainer blobContainer in containerList)
            {
                containerNameList.Add(blobContainer.Name);
            }

            return containerNameList;
        }

        public CloudBlobContainer CreateContainer(string containerName)
        {
            CloudBlobContainer blobContainer = _blobClient.GetContainerReference(containerName);
            blobContainer.CreateIfNotExist();

            return blobContainer;
        }

        public List<string> GetBlobList()
        {
            return GetBlobList("");
        }

        public List<string> GetBlobList(string container, string rootPath)
        {
            this.BlobContainer = container;
            return GetBlobList(rootPath);
        }

        public List<string> GetBlobList(string rootPath)
        {
            List<string> fileNameList = new List<string>();

            List<IListBlobItem> blobList;
            if (string.IsNullOrEmpty(rootPath))
            {
                blobList = _blobContainer.ListBlobs().ToList<IListBlobItem>();
            }
            else
            {
                CloudBlobDirectory rootDirectory = _blobContainer.GetDirectoryReference(rootPath);
                blobList = rootDirectory.ListBlobs().ToList<IListBlobItem>();
            }
            foreach (IListBlobItem blob in blobList)
            {
                Console.WriteLine(blob.Uri.ToString());
                if (blob.GetType() == typeof(CloudBlockBlob))
                {
                    fileNameList.Add(blob.Uri.LocalPath);
                }
            }

            return fileNameList;
        }

        public List<string> GetFolderList()
        {
            return GetFolderList("");
        }

        public List<string> GetFolderList(string container, string rootPath)
        {
            this.BlobContainer = container;
            return GetFolderList(rootPath);
        }

        public List<string> GetFolderList(string rootPath)
        {
            List<string> folderNameList = new List<string>();

            List<IListBlobItem> blobList;
            if(string.IsNullOrEmpty(rootPath))
            {
                blobList = _blobContainer.ListBlobs().ToList<IListBlobItem>();
            }
            else
            {
                CloudBlobDirectory rootDirectory = _blobContainer.GetDirectoryReference(rootPath);
                blobList = rootDirectory.ListBlobs().ToList<IListBlobItem>();
            }
            foreach (IListBlobItem blob in blobList)
            {
                Console.WriteLine(blob.Uri.ToString());
                if (blob.GetType() == typeof(CloudBlobDirectory))
                {
                    folderNameList.Add(blob.Uri.LocalPath);
                }
            }

            return folderNameList;
        }

        #region GetBlob APIs
        public Stream GetBlobAsStream(string container, string blobPath)
        {
            this.BlobContainer = container;
            return GetBlobAsStream(blobPath);
        }

        public Stream GetBlobAsStream(string blobPath)
        {
            MemoryStream blobStream = null;
            if (!string.IsNullOrEmpty(blobPath))
            {
                blobStream = new MemoryStream();
                CloudBlockBlob blobBlock = _blobContainer.GetBlockBlobReference(blobPath);

                // Read the blob attributes
                blobBlock.FetchAttributes();

                // Read the metadata for future use
                _blobMetadata = blobBlock.Metadata;

                // Download the blob
                blobBlock.DownloadToStream(blobStream);
                blobStream.Seek(0, SeekOrigin.Begin);
            }
            return blobStream;
        }

        public void GetBlobAsFile(string container, string blobPath, string downloadFilename)
        {
            this.BlobContainer = container;
            GetBlobAsFile(blobPath, downloadFilename);
        }

        public void GetBlobAsFile(string blobPath, string downloadFilename)
        {
            if (!string.IsNullOrEmpty(blobPath))
            {
                CloudBlockBlob blobBlock = _blobContainer.GetBlockBlobReference(blobPath);

                // Read the blob attributes
                blobBlock.FetchAttributes();

                // Read the metadata for future use
                _blobMetadata = blobBlock.Metadata;

                // Download the blob
                blobBlock.DownloadToFile(downloadFilename);
            }
        }

        public BlobAttributes GetBlobAttributes(string blobPath)
        {
            BlobAttributes blobAttributes = null;
            if (!string.IsNullOrEmpty(blobPath))
            {
                CloudBlockBlob blobBlock = _blobContainer.GetBlockBlobReference(blobPath);

                // Read the blob attributes
                blobBlock.FetchAttributes();
                blobAttributes = blobBlock.Attributes;

                // Read the metadata for future use
                _blobMetadata = blobBlock.Metadata;

            }
            return blobAttributes;
        }

        public BlobProperties GetBlobProperties(string blobPath)
        {
            BlobProperties blobProperties = null;
            if (!string.IsNullOrEmpty(blobPath))
            {
                CloudBlockBlob blobBlock = _blobContainer.GetBlockBlobReference(blobPath);

                // Read the blob attributes
                blobBlock.FetchAttributes();
                blobProperties = blobBlock.Properties;

                // Read the metadata for future use
                _blobMetadata = blobBlock.Metadata;
            }
            return blobProperties;
        }

        public string GetBlobMD5(string blobPath)
        {
            string blobMD5 = null;
            if (!string.IsNullOrEmpty(blobPath))
            {
                CloudBlockBlob blobBlock = _blobContainer.GetBlockBlobReference(blobPath);

                // Read the blob attributes
                blobBlock.FetchAttributes();
                blobMD5 = blobBlock.Properties.ContentMD5;

                // Read the metadata for future use
                _blobMetadata = blobBlock.Metadata;
            }
            return blobMD5;
        }

        public BlobStream OpenRead(string blobPath)
        {
            BlobStream blobStream = null;

            if (!string.IsNullOrEmpty(blobPath))
            {
                CloudBlockBlob blobBlock = _blobContainer.GetBlockBlobReference(blobPath);

                // Read the blob attributes
                blobBlock.FetchAttributes();

                // Read the metadata for future use
                _blobMetadata = blobBlock.Metadata;

                // Open the blob as a stream
                blobStream = blobBlock.OpenRead();
            }
            return blobStream;

        }

        #endregion

        #region DownloadBlockList APIs
        public List<ListBlockItem> DownloadBlockList(string container, string blobPath)
        {
            this.BlobContainer = container;
            return DownloadBlockList(blobPath, BlockListingFilter.All);
        }

        public List<ListBlockItem> DownloadBlockList(string container, string blobPath, BlockListingFilter blockFilter)
        {
            this.BlobContainer = container;
            return DownloadBlockList(blobPath, blockFilter);
        }

        public List<ListBlockItem> DownloadBlockList(string blobPath)
        {
            return DownloadBlockList(blobPath, BlockListingFilter.All);
        }

        public List<ListBlockItem> DownloadBlockList(string blobPath, BlockListingFilter blockFilter)
        {
            List<ListBlockItem> blockList = new List<ListBlockItem>();
            if (!string.IsNullOrEmpty(blobPath))
            {
                CloudBlockBlob blobBlock = _blobContainer.GetBlockBlobReference(blobPath);
                blockList = blobBlock.DownloadBlockList(blockFilter).ToList<ListBlockItem>();
            }

            return blockList;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\xlfsbackgroundenum.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace xonline.server.xlfs.client
{
    public class XlfsBackgroundEnumArgs
    {
        public Uri ServerAddress { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public int TitleId { get; set; }
        public string CertificateName { get; set; }
        public string CertificateThumbprint { get; set; }
        public Boolean UseProxy { get; set; }
        public Uri ProxyAddress { get; set; }
    }

    public class XlfsBackgroundDownloadArgs : XlfsBackgroundEnumArgs
    {
        public string SaveDirectory { get; set; }
        public List<XlfsFileEntry> Files { get; set; }
        public Dictionary<String, SASInfo> SAS { get; set; }
        public String Filter { get; set; }
        public bool MetaDataOnly { get; set; }
    }

    public class XlfsBackgroundDownloadProgress
    {
        public XlfsFileEntry File { get; set; }
        public long FileBytesDownloaded { get; set; }
        public long OverallBytesDownloaded { get; set; }
        public long OverallBytes { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\HttpParameterAttribute.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;

namespace xonline.server.xlfs.client
{
    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
    public class HttpRequestParameterAttribute : Attribute
    {
        public Boolean Required { get; set; }
        public String Name { get; set; }
        public String FormatString { get; set; }

        public HttpRequestParameterAttribute(String parameterName)
        {
            this.Name = parameterName;
            this.Required = false;
        }

        public String GenerateParamString(Object value)
        {

            // If we were passed a null value, just use an empty string
            if (value == null)
            {
                value = "";
            }

            if (value is Byte[])
            {
                return GenerateParamString(Convert.ToBase64String((Byte[])value));
            }

            String valueString = null;
            if (value is DateTime)
            {
                DateTime temp = (DateTime)value;
                if (FormatString != null)
                {
                    valueString = temp.ToString(FormatString);
                }
                else
                {
                    valueString = temp.ToString();
                }
            }
            else
            {
                if (FormatString != null)
                {
                    valueString = String.Format(FormatString, value);
                }
                else
                {
                    valueString = value.ToString();
                }
            }
            return GenerateParamString(valueString);
        }

        public virtual String GenerateParamString(String value) { return value; }
    }

    public class HttpQueryParameterAttribute : HttpRequestParameterAttribute
    {
        public HttpQueryParameterAttribute(String parameterName) : base(parameterName) { }

        public override string GenerateParamString(string value)
        {
            StringBuilder sb = new StringBuilder();
            if (!String.IsNullOrEmpty(Name))
            {
                sb.Append(Name);
                sb.Append("=");
            }
            sb.Append(HttpUtility.UrlEncode(value));

            return sb.ToString();
        }
    }

    public class HttpHeaderParameterAttribute : HttpRequestParameterAttribute
    {
        public String ValuePrefix { get; set; }

        public HttpHeaderParameterAttribute(String parameterName) : this(parameterName, null) { }
        public HttpHeaderParameterAttribute(String parameterName, String valuePrefix)
            : base(parameterName)
        {
            this.ValuePrefix = valuePrefix;
        }

        public override string GenerateParamString(string value)
        {
            StringBuilder sb = new StringBuilder();
            if (!String.IsNullOrEmpty(ValuePrefix))
            {
                sb.Append(ValuePrefix);
                sb.Append("=");
            }
            sb.Append(value);

            return sb.ToString();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\XlfsTimeSpan.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Threading;
using System.Web;
using System.Collections.Generic;

namespace xonline.server.xlfs.client
{
    // Useful little class to use with AverageTimer counters. Just instantiate
    // one at the begining of the request and increment the counter at the end
    // of the request using the TimeElapsed field.

    [ComVisible(false)]
    public class XlfsRequestTimeElapsed
    {
        // Static constructor.  Gets the system timer frequency.

        static XlfsRequestTimeElapsed()
        {
            QueryPerformanceFrequency(ref _freq);

            _msFreq = _freq / 1000;
        }

        // Constructor. Gets the current time for reference.

        public XlfsRequestTimeElapsed()
        {
            QueryPerformanceCounter(ref _started);
        }

        // Returns the time elapsed since the object was constructed.

        public long TimeElapsed
        {
            get
            {
                long now = 0;
                QueryPerformanceCounter(ref now);

                return now - _started;
            }
        }

        public long SecondsElapsed
        {
            get
            {
                long now = 0;
                QueryPerformanceCounter(ref now);

                return ((now - _started) / _freq);
            }
        }

        public long MillisecondsElapsed
        {
            get
            {
                long now = 0;
                QueryPerformanceCounter(ref now);

                return (long)((now - _started) / _msFreq);
            }
        }

        // Win32 imports

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [DllImport("KERNEL32"), System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        protected static extern int QueryPerformanceCounter(ref long time);

        [SuppressMessage("Microsoft.Security", "CA2118:ReviewSuppressUnmanagedCodeSecurityUsage")]
        [DllImport("KERNEL32"), System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        protected static extern int QueryPerformanceFrequency(ref long freq);

        private long _started;
            // Time when object was instantiated.

        private static long _freq;
            // Nonchanging frequency of the high resolution system counter.

        private static float _msFreq;
            // pre-calculated float divisor
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\XlfsAdminGetChangedBlobs.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Xml;
using System.Xml.XPath;

namespace xonline.server.xlfs.client
{
    public class XlfsAdminGetChangedBlobs : XlfsAdminGetChangedBlobsContinue
    {
        [HttpQueryParameter("start", FormatString="u")]
        public DateTime StartTime { get; set; }

        [HttpQueryParameter("end", FormatString="u")]
        public DateTime EndTime { get; set; }

        [HttpQueryParameter("continuation", Required = false)]
        public string Continuation { get; set; }

        public List<XlfsFileEntry> Files { get; private set; }

        protected override string MethodName { get { return "xlfsAdminGetChangedBlobs.ashx"; } }

        public XlfsAdminGetChangedBlobs()
        {
            Files = new List<XlfsFileEntry>();
        }

        protected override void ProcessResponse(HttpWebResponse response)
        {
            XmlReader reader = XmlReader.Create(response.GetResponseStream());
            reader.MoveToContent();

            XPathDocument docNav = new XPathDocument(reader);
            ProcessResponse(docNav);
        }

        protected override void ProcessResponse(XPathDocument docNav)
        {
            // Assume that we will need to process UTC datetimes

            // Call the base class to make sure the SAS portions are properly parsed
            base.ProcessResponse(docNav);

            // Process the "File" section of the XML document
            XPathNavigator nav = docNav.CreateNavigator();
            XPathExpression fileNavExp = nav.Compile("/Root/Files/File");
            XPathNodeIterator fileNavItr = nav.Select(fileNavExp);

            List<XlfsFileEntry> tempList = new List<XlfsFileEntry>();

            while (fileNavItr.MoveNext())
            {
                bool bHasErrors = false;
                XlfsFileEntry entry = new XlfsFileEntry();
                XPathNavigator navCur = fileNavItr.Current;

                XPathNodeIterator entryItr = navCur.SelectChildren(XPathNodeType.All);

                while (entryItr.MoveNext())
                {
                    if (entryItr.Current.Name == "FileName")
                    {
                        entry.Filename = entryItr.Current.Value;
                    } 
                    else if (entryItr.Current.Name == "Xuid")
                    {
                        ulong userXuid;

                        UInt64.TryParse(entryItr.Current.Value, out userXuid);
                        entry.Xuid = userXuid.ToString("X16");
                    }
                    else if (entryItr.Current.Name == "TransactionId")
                    {
                        entry.TransactionId = entryItr.Current.Value;
                    }
                    else if (entryItr.Current.Name == "StorageAccount")
                    {
                        entry.StorageAccount = entryItr.Current.Value;
                    }
                    else if (entryItr.Current.Name == "LastUpdate")
                    {
                        DateTime date;
                        if (DateTime.TryParse(entryItr.Current.Value, out date) == false)
                        {
                            date = DateTime.UtcNow;
                            bHasErrors = true;
                        }
                        entry.LastUpdate = date.ToUniversalTime();
                    }
                    else if (entryItr.Current.Name == "Created")
                    {
                        DateTime date;
                        DateTime.TryParse(entryItr.Current.Value, out date);
                        if (DateTime.TryParse(entryItr.Current.Value, out date) == false)
                        {
                            date = DateTime.UtcNow;
                            bHasErrors = true;
                        }
                        entry.Created = date.ToUniversalTime();
                    }
                    else if (entryItr.Current.Name == "Size")
                    {
                        int value;
                        if (Int32.TryParse(entryItr.Current.Value, out value) == false)
                        {
                            value = 0;
                            bHasErrors = true;
                        }
                        entry.Size = value;
                    }
                }

                // Make sure we remember the titleId associated with this query
                entry.TitleId = TitleId;

                // If anything went wront ignore the entry
                if (bHasErrors == false)
                {
                    // Store the entry for future use.
                    tempList.Add(entry);
                }
            }

            // Process the Continuation element (optional)
            XPathExpression continuationNavExp = nav.Compile("/Root/Continuation");
            XPathNodeIterator continuationNavItr = nav.Select(continuationNavExp);
            
            // Clear continuation information
            Continuation = null;

            while (continuationNavItr.MoveNext())
            {
                Continuation = continuationNavItr.Current.Value;
            }

            Files = tempList;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\XlfsAdminGetChangedBlobsContinue.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Xml;
using System.Xml.XPath;

namespace xonline.server.xlfs.client
{
    public class XlfsAdminGetChangedBlobsContinue : XlfsWebRequest
    {
        [HttpQueryParameter("titleid", FormatString="{0:X8}")]
        public int TitleId { get; set; }

        Dictionary<String, SASInfo> _SASDictionary =
            new Dictionary<String, SASInfo>();

        public Dictionary<String, SASInfo> SASDictionary
        { get { return _SASDictionary; } }
        
        protected override string MethodName { get { return "xlfsAdminGetChangedBlobsContinue.ashx"; } }

        protected override void ProcessResponse(HttpWebResponse response)
        {
            XmlReader reader = XmlReader.Create(response.GetResponseStream());
            reader.MoveToContent();

            XPathDocument docNav = new XPathDocument(reader);
            ProcessResponse(docNav);
        }

        protected override void ProcessResponse(XPathDocument docNav)
        {
            // Process the "File" section of the XML document
            XPathNavigator nav = docNav.CreateNavigator();
            XPathExpression sasExp = nav.Compile("/Root/StorageAccounts/SAS");
            XPathNodeIterator sasItr = nav.Select(sasExp);

            Dictionary<String, SASInfo> tempSASList = new Dictionary<String, SASInfo>();
            while (sasItr.MoveNext())
            {
                SASInfo sasInfo = new SASInfo();
                XPathNavigator sasCur = sasItr.Current;

                XPathNodeIterator entryItr = sasCur.SelectChildren(XPathNodeType.All);

                while (entryItr.MoveNext())
                {
                    if (entryItr.Current.Name == "StorageAccount")
                    {
                        sasInfo.StorageAccount = entryItr.Current.Value;
                    }
                    else if (entryItr.Current.Name == "URI")
                    {
                        sasInfo.StorageUri = new Uri(entryItr.Current.Value);
                        if (sasInfo.StorageUri.Host == "127.0.0.1")
                        {
                            if (XlfsServer != null & XlfsServer.Host != "127.0.0.1")
                            {
                                sasInfo.StorageUri = new Uri("http://" + XlfsServer.Host + ":" + sasInfo.StorageUri.Port + sasInfo.StorageUri.AbsolutePath); 
                            }
                        }
                    }
                    else if (entryItr.Current.Name == "Container")
                    {
                        sasInfo.Container = entryItr.Current.Value;
                    }
                    else if (entryItr.Current.Name == "Signature")
                    {
                        sasInfo.Signature = entryItr.Current.Value;
                    }
                    else if (entryItr.Current.Name == "Expiry")
                    {
                        DateTime date;
                        DateTime.TryParse(entryItr.Current.Value, out date);
                        sasInfo.Expiry = date;
                    }
                }
                tempSASList.Add(sasInfo.StorageAccount, sasInfo);
            }
            _SASDictionary = tempSASList;
        }
    }

    public class SASInfo
    {
        public String StorageAccount { get; set; }
        public Uri StorageUri { get; set; }
        public String Container { get; set; }
        public String Signature { get; set; }
        public DateTime Expiry { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\XlfsFileEntry.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;

namespace xonline.server.xlfs.client
{
    public class XlfsFileEntry : INotifyPropertyChanged
    {
        // INotifyPropertyChanged Members
        public event PropertyChangedEventHandler PropertyChanged;

        protected void Notify(string propName)
        {
            if (this.PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propName));
            }
        }

        // Xuid.ToString("X16")
        string _Xuid;
        public string Xuid {
            get { return this._Xuid; }
            set
            {
                if (this._Xuid == value) { return; }
                this._Xuid = value;
                Notify("Xuid");
            }
        }

        int _TitleId;
        public int TitleId {
            get { return this._TitleId; }
            set
            {
                if (this._TitleId == value) { return; }
                this._TitleId = value;
                Notify("TitleId");
            }
        }

        public string Filename { get; set; }
        public string TransactionId { get; set; }
        public string StorageAccount { get; set; }
        public DateTime Created { get; set; }
        public DateTime? LastUpdate { get; set; }
        public DateTime? LastDownloadAttempt { get; set; }

        DateTime? _LastDownloaded;
        public DateTime? LastDownloaded {
            get { return this._LastDownloaded; }
            set
            {
                if (this._LastDownloaded == value) { return; }
                this._LastDownloaded = value;
                Notify("LastDownloaded");
            }

        }

        public long Size { get; set; }       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\XlfsConsoleDownloader\Program.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.client
{
    class Program
    {
        public WaitHandle[] waitHandle = new WaitHandle[]
            {
                new AutoResetEvent(false),
                new AutoResetEvent(false)
            };

        public ManualResetEvent refreshBlockEvent = new ManualResetEvent(true);
        public List<XlfsFileEntry> EnumFileCollection = new List<XlfsFileEntry>();
        public Dictionary<String, SASInfo> EnumSASDictionary = new Dictionary<String, SASInfo>();
        
        public DownloaderApp downloaderApp = new DownloaderApp();

        private int RefreshWorkerInstanceCount = 0;
        private SortedDictionary<String, XlfsFileEntry> SortedFileDictionary = new SortedDictionary<string, XlfsFileEntry>();

        static void Help(string ProgramName)
        {
            Console.WriteLine("{0} - Xlfs Admin FD Client Downloader", ProgramName);
            Console.WriteLine();
            Console.WriteLine("    -server <uri>            : Path to the server");
            Console.WriteLine("    -startdate <date>        : First Date to download");
            Console.WriteLine("    -enddate <date>          : Last Date to download. Default is Now");
            Console.WriteLine("    -deltadays <int>         : Number of Days from EndDate to download");
            Console.WriteLine("    -deltaminutes <int>      : Number of Minutes from EndDate to download");
            Console.WriteLine("    -savedirectory <path>    : Location of downloaded data");
            Console.WriteLine("    -titleid <hex>           : Hex TitleId to download eg: FFFE07D1");
            Console.WriteLine("    -certificate <subject>   : Certificate's Distinguished Subject Name");
            Console.WriteLine("    -thumbprint <thumbprint> : Certificate's Thumbprint");
            Console.WriteLine("    -filter <string>         : The filename filter. Wildcards accepted");
            Console.WriteLine("    -enumonly                : Disables downloading the files and metadata");
            Console.WriteLine("    -metadataonly            : Disables downloading the files");
            Console.WriteLine("    -proxy [<uri>]           : Use the specified proxy or machine proxy to download");
        }

        private void BackgroundDownloaderWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            // If we have a user state present, then the progress notification is 
            // for the percent download of that file
            if (e.UserState != null && e.UserState is XlfsBackgroundDownloadProgress)
            {
                XlfsBackgroundDownloadProgress progress = (XlfsBackgroundDownloadProgress)e.UserState;
                XlfsFileEntry entry = progress.File;
                if (e.ProgressPercentage == 1000 &&
                    entry.LastDownloaded.HasValue == false)
                {
                    // Fully downloaded
                    entry.LastDownloaded = DateTime.UtcNow;

                    Console.WriteLine(
                        "Downloaded {0}.{1}.{2}",
                        entry.Xuid,
                        entry.TitleId.ToString("X8"),
                        entry.Filename
                        );
                }
            }
        }

        private void BackgroundDownloaderWorker_WorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            AutoResetEvent successEvent = (AutoResetEvent)waitHandle[0];
            AutoResetEvent failedEvent = (AutoResetEvent)waitHandle[1];

            if (e.Error != null)
            {
                Console.WriteLine("Download Worker Error: {0}", e.Error.Message);
                Console.WriteLine("Exception: {0}", e.Error.InnerException);
                failedEvent.Set();
                return;
            }
            if (e.Cancelled == true)
            {
                Console.WriteLine("Download Worker Cancelled");
                failedEvent.Set();
                return;
            }
            Console.WriteLine("Download Worker Completed");
            successEvent.Set();
        }

        private void BackgroundRefreshWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            // Increment the count of workers here
            Interlocked.Increment(ref RefreshWorkerInstanceCount);

            // Get the arguments
            XlfsAdminGetChangedBlobs getBlobs = (XlfsAdminGetChangedBlobs)e.UserState;

            //
            // Move all the files into the collection
            //
            foreach (XlfsFileEntry entry in getBlobs.Files)
            {
                if (SortedFileDictionary.ContainsKey(entry.TransactionId) == false)
                {
                    SortedFileDictionary.Add(entry.TransactionId, entry);
                }
            }

            //
            // Pick up all of the SAS records
            //
            foreach (KeyValuePair<String, SASInfo> entry in getBlobs.SASDictionary)
            {
                if (EnumSASDictionary.ContainsKey(entry.Key) == true)
                {
                    EnumSASDictionary.Remove(entry.Key);
                }
                EnumSASDictionary.Add(entry.Key, entry.Value);
            }

            //
            // Done this instance of the worker. Anyone else running in parallel?
            //
            int count = Interlocked.Decrement(ref RefreshWorkerInstanceCount);

            //
            // If there is no other worker pending, then we are done
            //
            if (count == 0)
            {
                refreshBlockEvent.Set();
            }
        }

        private void BackgroundRefreshWorker_WorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            AutoResetEvent successEvent = (AutoResetEvent)waitHandle[0];
            AutoResetEvent failedEvent = (AutoResetEvent)waitHandle[1];

            //
            // If an error/exception occured, we can abort right away
            //
            if (e.Error != null)
            {
                Console.WriteLine("Refresh Worker Error: {0}", e.Error.Message);
                Console.WriteLine("Exception: {0}", e.Error.InnerException);
                failedEvent.Set();
                return;
            }

            // 
            // If the work is cancelled, we can abort right away
            //
            if (e.Cancelled == true)
            {
                Console.WriteLine("Refresh Worker Cancelled");
                failedEvent.Set();
                return;
            }

            //
            // Done this instance of the worker. Anyone else running in parallel?
            //
            int count = Interlocked.Decrement(ref RefreshWorkerInstanceCount);

            //
            // If there is no other worker pending, then we are done
            //
            if (count == 0)
            {
                refreshBlockEvent.Set();
            }

            // 
            // Wait for the refresh work progress changed to have reset
            //
            refreshBlockEvent.WaitOne();

            //
            // At this point, there should be no more progress calls made, so move
            // everything from the sorted dictionary to the list
            //
            EnumFileCollection = SortedFileDictionary.Select( entry => entry.Value ).ToList();

            //
            // Signal to the caller that we are done
            //
            successEvent.Set();
        }

        private void DisplayEnumFiles()
        {
            foreach (XlfsFileEntry entry in EnumFileCollection)
            {
                Console.WriteLine(
                    "\"{0}\",\"0x{1}\",\"{2}\",\"{3}\",{4},\"{5}\"",
                    entry.LastUpdate.Value.ToString("s"),
                    entry.TitleId.ToString("X8"),
                    entry.Filename,
                    entry.Xuid,
                    entry.Size,
                    entry.StorageAccount
                    );
            }
        }

        public int Main(string[] args)
        {
            Uri server = new Uri("http://127.0.0.1:8080/");
            DateTime startDate = DateTime.UtcNow.AddDays(-1);
            DateTime endDate = DateTime.UtcNow;
            int titleId = unchecked((int)0xFFFE07D1);
            int deltaDays = 0;
            int deltaMinutes = 0;
            string saveDirectory = System.IO.Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);
            bool passedParsing = false;
            bool enumOnly = false;
            bool metaDataOnly = false;
            string certificateName = "";
            string certificateThumbprint = "";
            string filter = "";
            bool useProxy = false;
            Uri proxyServer = null;
            string arg = "";

            try
            {
                if(args.Length == 0)
                {
                    return -1;
                }

                // Parse the arguments;
                for (int i = 0; i < args.Length; ++i)
                {
                    arg = args[i];
                    if (arg.StartsWith("-") || arg.StartsWith("/"))
                    {
                        arg = arg.Substring(1).ToLower();

                        if (arg == "help" || arg == "?")
                        {
                            return -1;
                        }
                        if (arg == "enumonly")
                        {
                            enumOnly = true;
                            continue;
                        }
                        if (arg == "metadataonly")
                        {
                            metaDataOnly = true;
                            continue;
                        }

                        if (arg == "proxy")
                        {
                            useProxy = true;

                            if (i + 1 < args.Length && !args[i + 1].StartsWith("-"))
                            {
                                ++i;
                                proxyServer = new Uri(args[i]);
                            }
                            continue;
                        }

                        // All the other arguments require 2 options so make
                        // sure that it exists or we will fail
                        ++i;
                        if (i >= args.Length)
                        {
                            Console.WriteLine("Missing argument to -{0}", arg);
                            return 1;
                        }

                        if (arg == "server")
                        {
                            server = new Uri(args[i]);
                            continue;
                        }

                        if (arg == "startdate")
                        {
                            if (DateTime.TryParse(args[i], out startDate) == false)
                            {
                                Console.WriteLine("Could not parse -startdate {0}", args[i]);
                                return 2;
                            }
                            // The server expects UTC.
                            startDate = startDate.ToUniversalTime();
                            continue;
                        }

                        if (arg == "enddate")
                        {
                            if (DateTime.TryParse(args[i], out endDate) == false)
                            {
                                Console.WriteLine("Could not parse -enddate {0}", args[i]);
                                return 3;
                            }
                            // The server expects UTC.
                            endDate = endDate.ToUniversalTime();
                            continue;
                        }

                        if (arg == "savedirectory")
                        {
                            if (System.IO.Directory.Exists(args[i]) == false)
                            {
                                Console.WriteLine("Could not find -savedirectory {0}", args[i]);
                                return 4;
                            }
                            saveDirectory = args[i];
                            continue;
                        }

                        if (arg == "titleid")
                        {
                            string num = args[i];
                            UInt32 value;

                            if (num.StartsWith("0x") == true ||
                                num.StartsWith("0X") == true)
                            {
                                num = num.Substring(2);
                            }
                            if (UInt32.TryParse(num, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out value) == false &&
                                UInt32.TryParse(num, NumberStyles.Integer, CultureInfo.InvariantCulture, out value) == false)
                            {
                                Console.WriteLine("Could not parse -titleid {0}", args[i]);
                                return 5;
                            }
                            titleId = unchecked((int)value);
                            continue;
                        }

                        if (arg == "deltadays")
                        {
                            if (Int32.TryParse(args[i], out deltaDays) == false)
                            {
                                Console.WriteLine("Could not parse -deltadays {0}", args[i]);
                                return 6;
                            }
                            if (deltaDays < 0)
                            {
                                Console.WriteLine("Negative -deltadays not permited: {0}", args[i]);
                                return 12;
                            }
                            continue;
                        }
                        if (arg == "deltaminutes")
                        {
                            if (Int32.TryParse(args[i], out deltaMinutes) == false)
                            {
                                Console.WriteLine("Could not parse -deltaminutes {0}", args[i]);
                                return 9;
                            }
                            if (deltaMinutes < 0)
                            {
                                Console.WriteLine("Negative -deltaminutes not permited: {0}", args[i]);
                                return 13;
                            }
                            continue;
                        }
                        if (arg == "certificate")
                        {
                            certificateName = args[i];
                            continue;
                        }
                        if (arg == "thumbprint")
                        {
                            certificateThumbprint = args[i];
                            continue;
                        }
                        if (arg == "filter")
                        {
                            filter = args[i];
                            continue;
                        }
                    }
                }

                // We parsed everything okay
                passedParsing = true;
            }
            catch (Exception e)
            {
                Console.WriteLine("Error Parsing Argument {0}:\n\r{1}", arg, e.ToString());
                return 10;
            }
            finally
            {
                if (passedParsing == false)
                {
                    Help(Assembly.GetExecutingAssembly().GetName().Name);
                }
            }

            // See if we got a deltadays specifier
            if (deltaDays != 0)
            {
                try
                {
                    startDate = endDate.AddDays(-1 * deltaDays);
                }
                catch
                {
                    Console.WriteLine("DeltaDays {0} is an invalid number of days", deltaDays);
                    return 11;
                }
            }
            else if (deltaMinutes != 0)
            {
                try
                {
                    startDate = endDate.AddMinutes(-1 * deltaMinutes);
                }
                catch
                {
                    Console.WriteLine("DeltaMinutes {0} is an invalid number of minutes", deltaMinutes);
                    return 11;
                }
            }

            // Build the enum file list request
            XlfsBackgroundEnumArgs enumArgs = new XlfsBackgroundEnumArgs();
            enumArgs.CertificateName = certificateName;
            enumArgs.CertificateThumbprint = certificateThumbprint;
            enumArgs.ServerAddress = server;
            enumArgs.TitleId = titleId;
            enumArgs.StartTime = startDate;
            enumArgs.EndTime = endDate;
            enumArgs.UseProxy = useProxy;
            enumArgs.ProxyAddress = proxyServer;

            // Increment the worker refresh count so that we don't signal the event until we are done
            // and clear the event that we will use to block on
            Interlocked.Increment(ref RefreshWorkerInstanceCount);
            refreshBlockEvent.Reset();

            // Create the background worker to the real work
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += new DoWorkEventHandler(downloaderApp.RefreshFiles);
            bw.ProgressChanged += BackgroundRefreshWorker_ProgressChanged;
            bw.RunWorkerCompleted += BackgroundRefreshWorker_WorkerCompleted;
            bw.WorkerReportsProgress = true;
            bw.RunWorkerAsync(enumArgs);

            // Wait here for the enum to be completed
            int signaler = WaitHandle.WaitAny(waitHandle);
            if (signaler != 0)
            {
                Console.WriteLine("Could not obtain a list of files to download.");
                return 7;
            }

            // Are we only doing an enumeration?
            if (enumOnly == true)
            {
                DisplayEnumFiles();
                return 0;
            }

            // Indicate how many files we will download
            Console.WriteLine("Refresh Worker found {0} Files", EnumFileCollection.Count);

            // Remember any failed files
            bool failedAny = false;
            
            // Put a loop around the download task and wait for it to complete
            while (true)
            {
                // Create the arguments that we will pass to the downloader
                XlfsBackgroundDownloadArgs downloadArgs = new XlfsBackgroundDownloadArgs();
                downloadArgs.SAS = EnumSASDictionary;
                downloadArgs.Files = EnumFileCollection;
                downloadArgs.TitleId = titleId;
                downloadArgs.CertificateName = certificateName;
                downloadArgs.CertificateThumbprint = certificateThumbprint;
                downloadArgs.ServerAddress = server;
                downloadArgs.SaveDirectory = saveDirectory;
                downloadArgs.Filter = filter;
                downloadArgs.MetaDataOnly = metaDataOnly;

                // Create a background worker to do the real download
                bw = new BackgroundWorker();
                bw.DoWork += new DoWorkEventHandler(downloaderApp.DownloadFiles);
                bw.ProgressChanged += BackgroundDownloaderWorker_ProgressChanged;
                bw.RunWorkerCompleted += BackgroundDownloaderWorker_WorkerCompleted;
                bw.WorkerReportsProgress = true;
                bw.RunWorkerAsync(downloadArgs);

                // Wait here for the download to be completed
                signaler = WaitHandle.WaitAny(waitHandle);
                if (signaler == 0)
                {
                    // The 0 signaler means that the task completed without error
                    break;
                }

                // If we got here, that means that we failed a file
                failedAny = true;
            }
            if (failedAny == true)
            {
                Console.WriteLine("Could not download all files:");
                foreach (XlfsFileEntry entry in EnumFileCollection)
                {
                    if (entry.LastDownloadAttempt.HasValue == true &&
                        entry.LastDownloaded.HasValue == false)
                    {
                        Console.WriteLine(
                            "Failed: {0}.{1}.{2}",
                            entry.Xuid,
                            entry.TitleId.ToString("X8"),
                            entry.Filename
                            );
                    }
                }
                return 8;
            }
            return 0;
        }
    }

    class ConsoleWrapper
    {
        static int Main(string[] args)
        {
            Program program = new Program();

            return program.Main(args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\XlfsDecryptor\XlfsDecryptor.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml;

namespace Decrypter
{
    enum ErrorValue
    {
        BadCommandLine = 1,
        FileNotFound = 2,
        CertificateError = 3,
        SerialNumberError = 4,
        CryptoError = 5,
        XmlError = 6,
    };

    class XLFSDecryptorException : Exception
    {
        public XLFSDecryptorException(ErrorValue errVal, string message, Exception innerException) : base(message, innerException)
        {
            ErrorValue = errVal;
        }

        public ErrorValue ErrorValue { get; set; }
        public int ReturnCode { get { return (int)ErrorValue; } }
    }

#if TEST_DATA
    class TestData
    {
        public static string m_encodedSessionKey = "NRXBQ2lO1L/Rpecj1bCPSqLorNi1sJIQdDwSW8npWCljzuIztiMv6lKpCSOThvmKtXW2CA27PrfXf7JaMCtYs4h6wcL6YgOBhQSOGVnJo683zRrSSRWY8j3GnYFKsxE5cvXFmyC2lpintCfj9EY9x53jtRLLU5tZaOdEQGTFGCE=";

        public static string m_encodedSerialNumber = "QiXe+wAOAAAATQ==";

        public static byte[] m_sessionKey = 
        {
            0xa8, 0xd8, 0xa6, 0x0d, 0x1b, 0xcd, 0xe6, 0x29, 0x53, 0x77, 0x45, 0x69, 0x27, 0xc3, 0x69, 0xa7
        };

        public static byte[] m_encryptedData = 
        {
            0x85, 0x35, 0xc4, 0xde, 0x93, 0x37, 0xe1, 0x9d, 0xe2, 0x2e, 0x93, 0x2e, 0x2c, 0xcc, 0x43, 0x00, 
            0x4d, 0x03, 0xcb, 0x95, 0x16, 0x47, 0x10, 0x71, 0x3e, 0x4b, 0xac, 0xa8, 0x3f, 0xf6, 0xa8, 0x7c, 
            0xc5, 0xd9, 0x27, 0xb7, 0xf0, 0xc9, 0xa5, 0xad, 0x8a, 0xa4, 0x20, 0x0c, 0x3b, 0x90, 0x43, 0x7d, 
            0x0c, 0xd4, 0x97, 0xc1, 0x32, 0x35, 0xdb, 0x8c, 0x2b, 0x3e, 0xc5, 0xe7, 0x32, 0xe9, 0x37, 0x6a, 
            0xbd, 0x52, 0xe8, 0x4b, 0x0a, 0x67, 0xcb, 0x07, 0x43, 0xcf, 0x7e, 0xc8, 0xaf, 0xf9, 0x65, 0xbc, 
            0xc5, 0xcd, 0xa2, 0xad, 0xfd, 0xce, 0xc5, 0x64, 0x7f, 0xca, 0x29, 0xd0, 0xd1, 0x66, 0x6e, 0xd4, 
            0x4b, 0xac, 0x0c, 0x5d, 0x30, 0xb6, 0x59, 0xa1, 0x90, 0x45, 0xc4, 0x74, 0x6d, 0x28, 0x99, 0x50, 
            0xa8, 0xe3, 0xa9, 0x52, 0x65, 0xa1, 0xdf, 0x24, 0xa6, 0x6f, 0xfb, 0x3b, 0xdc, 0x1e, 0xbb, 0x7d,
        };

        public static string m_InputFilename = @"c:\build\liveclient\private\xlctest\xnet\dev\xonline\xlfs\Encrypted.bin";
        public static string m_OutputFilename = @"c:\build\liveclient\private\xlctest\xnet\dev\xonline\xlfs\Decrypted.bin";
        
    }
#endif

    class Program
    {
        //
        // These will be obtained from the metadata file or the command line.
        //
        static int m_BlockSize = -1;
        static int m_BlockStart = -1;
        static byte[] m_SerialNumber;
        static string m_SerialNumberString = null;        
        static string m_InputFilename = null;
        static string m_OutputFilename = null;
        static byte[] m_EncryptedSessionKey = null;
        static PaddingMode m_lastBlockPadding = PaddingMode.PKCS7;
        
        static void BlockNumberToIV(byte[] IV, int blockNumber)
        {
            IV[0] = (byte)(blockNumber >> 24 & 0xFF);
            IV[1] = (byte)(blockNumber >> 16 & 0xFF);
            IV[2] = (byte)(blockNumber >> 8 & 0xFF);
            IV[3] = (byte)(blockNumber & 0xFF);
        }
       
        private static string SerialNumberToString(byte[] serialNumber)
        {
            string serialString;

            try
            {
                serialString = BitConverter.ToString(serialNumber).Replace("-", "");
            }
            catch (Exception e)
            {
                throw new XLFSDecryptorException(ErrorValue.SerialNumberError, "Error decoding certificate serial number", e);
            }
            return serialString;
        }

        static void Usage()
        {
            Console.WriteLine("Usage: xlfsdecrypt [arguments]");
            Console.WriteLine("\t-input filename\t\t-- Specify input file");
            Console.WriteLine("\t-output filename\t-- Specify output file");
            Console.WriteLine("\t-serial serialnumber\t-- Override certificate serial number from metadata");
            Console.WriteLine("\t-blocksize blocksize\t-- Override block size from metadata");
            Console.WriteLine("\t-blockstart blockstart\t-- Override block start value from metadata");
        }

        static void ParseCommandLine(string[] args)
        {
            int i = 0;
            while (i < args.Length)
            {
                string arg = args[i];
                if (arg.StartsWith("/") || arg.StartsWith("-"))
                {
                    arg = arg.Remove(0, 1);
                    arg = arg.ToLower();

                    i++;

                    if (i >= args.Length)
                    {
                        throw new XLFSDecryptorException(ErrorValue.BadCommandLine, "Missing argument to " + args[i - 1], null);
                    }

                    string param = args[i];

                    if (arg == "output" || arg == "o")
                    {
                        m_OutputFilename = param;
                    }
                    else if (arg == "input" || arg == "i")
                    {
                        m_InputFilename = param;
                    }
                    else if (arg == "serial" || arg == "s")
                    {                        
                        m_SerialNumberString = param;                        
                    }
                    else if (arg == "blocksize" || arg == "bsize")
                    {
                        m_BlockSize = int.Parse(param);
                    }
                    else if (arg == "blockstart" || arg == "bstart")
                    {
                        m_BlockStart = int.Parse(param);
                    }
                    else
                    {
                        throw new XLFSDecryptorException(ErrorValue.BadCommandLine, "Unknown command line option " + args[i - 1], null);
                    }
                }

                i++;
            }
        }

        static int Main(string[] args)
        {
            int returnValue = 0;
            
#if TEST_DATA
            //
            // For testing, hardcoded values
            //
            m_BlockSize = 4 * 1024 * 1024;
            m_BlockStart = 10000001;
            m_SerialNumber = Convert.FromBase64String(TestData.m_encodedSerialNumber);            
            m_EncryptedSessionKey = Convert.FromBase64String(TestData.m_encodedSessionKey);
            m_InputFilename = TestData.m_InputFilename;
            m_OutputFilename = TestData.m_OutputFilename;
#endif

            
            try
            {
                //
                // Get the command line arguments
                //
                ParseCommandLine(args);

                if (String.IsNullOrEmpty(m_InputFilename) ||
                    String.IsNullOrEmpty(m_OutputFilename))
                {
                    throw new XLFSDecryptorException(ErrorValue.BadCommandLine, "", null);
                }

                //
                // Fetch the metadata for the file from the filename specified on the command line
                //
                FetchMetadata();

                //
                // Decode the serial number and convert it into a hex string, unless an
                // override has been specified on the command line.
                //
                if (String.IsNullOrEmpty(m_SerialNumberString))
                {
                    m_SerialNumberString = SerialNumberToString(m_SerialNumber);
                }

                //
                // Lookup the private key in the certificate store
                //
                AsymmetricAlgorithm algPriv = LookupPrivateKey(X509FindType.FindBySerialNumber, m_SerialNumberString);

                //
                // Using the private key, decrypt the session key
                //
                byte[] sessionKey = DecryptSessionKey(algPriv, m_EncryptedSessionKey);

                //
                // Using the session key, decrypt the file
                //
                DecryptFile(sessionKey, m_InputFilename, m_OutputFilename, m_BlockSize, m_BlockStart, m_lastBlockPadding);
            }
            catch (XLFSDecryptorException e)
            {
                returnValue = e.ReturnCode;                
                Console.WriteLine(e.Message);
                if (e.ErrorValue == ErrorValue.BadCommandLine)
                {
                    Usage();
                }
            }
            catch (Exception e)
            {
                returnValue = -1;
                Console.WriteLine(e.ToString());
            }

            return returnValue;
        }

        private static void FetchMetadata()
        {
            string metadataFilename = m_InputFilename + ".metadata";

            try
            {
                using (FileStream fs = new FileStream(metadataFilename, FileMode.Open, FileAccess.Read))
                {

                    XmlDocument doc = new XmlDocument();
                    doc.Load(fs);

                    if (m_BlockSize == -1)
                    {
                        if (doc.DocumentElement["blocksize"] != null)
                        {
                            m_BlockSize = int.Parse(doc.DocumentElement["blocksize"].InnerText);
                        }
                        else
                        {
                            throw new XLFSDecryptorException(ErrorValue.XmlError, "Metadata file for " + m_InputFilename + " malformed, missing blocksize.", null);
                        }
                    }

                    if (m_BlockStart == -1)
                    {
                        if (doc.DocumentElement["blockstart"] != null)
                        {
                            m_BlockStart = int.Parse(doc.DocumentElement["blockstart"].InnerText);
                        }
                        else
                        {
                            throw new XLFSDecryptorException(ErrorValue.XmlError, "Metadata file for " + m_InputFilename + " malformed, missing blockstart.", null);
                        }
                    }

                    if (m_SerialNumberString == null)
                    {
                        if (doc.DocumentElement["certserial"] != null)
                        {
                            m_SerialNumber = Convert.FromBase64String(doc.DocumentElement["certserial"].InnerText);
                        }
                        else
                        {
                            throw new XLFSDecryptorException(ErrorValue.XmlError, "Metadata file for " + m_InputFilename + " malformed, missing certserial.", null);
                        }
                    }

                    if (doc.DocumentElement["sessionkey"] != null)
                    {
                        m_EncryptedSessionKey = Convert.FromBase64String(doc.DocumentElement["sessionkey"].InnerText);
                    }
                    else
                    {
                        throw new XLFSDecryptorException(ErrorValue.XmlError, "Metadata file for " + m_InputFilename + " malformed, missing sessionkey.", null);
                    }

                    if (doc.DocumentElement["padding"] != null)
                    {
                        if (String.Compare(doc.DocumentElement["padding"].InnerText, "None", StringComparison.InvariantCultureIgnoreCase) == 0)
                        {
                            m_lastBlockPadding = PaddingMode.None;
                        }
                    }
                }
            }
            catch (FileNotFoundException e)
            {
                throw new XLFSDecryptorException(ErrorValue.FileNotFound, "Metadata file not found for " + m_InputFilename, e);
            }
            catch (XmlException e)
            {
                throw new XLFSDecryptorException(ErrorValue.XmlError, "Metadata file for " + m_InputFilename + " malformed.", e);
            }
            catch (Exception e)
            {
                throw new XLFSDecryptorException(ErrorValue.XmlError, "Metadata file for " + m_InputFilename + " contains malformed parameter.", e);
            }
        }

        private static byte[] DecryptSessionKey(AsymmetricAlgorithm algPriv, byte[] encryptedData)
        {
            RSAOAEPKeyExchangeDeformatter deformatter = new RSAOAEPKeyExchangeDeformatter(algPriv);
            try
            {
                byte[] sessionKey = deformatter.DecryptKeyExchange(encryptedData.Reverse().ToArray());
                return sessionKey;
            }
            catch (CryptographicException e)
            {
                throw new XLFSDecryptorException(ErrorValue.CryptoError, "Error decrypting session key.", e);
            }            
        }

        private static AsymmetricAlgorithm LookupPrivateKey(X509FindType findType, object findData)
        {            
            X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly);

            X509Certificate2Collection collection = store.Certificates.Find(findType, findData, false);
            store.Close();

            //
            // If this function ever does anything but serial numbers, these messages need to be revisited.
            //
            if (collection.Count == 0)
            {
                string message = null;
                if (findType == X509FindType.FindBySerialNumber)
                {
                    message = "Certificate matching serial number " + findData + " not found in certificate store.";
                }
                else
                {
                    message = "Error looking up certificate: no certificate found.";
                }
                throw new XLFSDecryptorException(ErrorValue.CertificateError, message , null);
            }
            else if (collection.Count > 1)
            {
                string message = null;
                if (findType == X509FindType.FindBySerialNumber)
                {
                    message = "Multiple certificates found for serial number " + findData;
                }
                else
                {
                    message = "Error looking up certificate: multiple certificates found.";
                }
                throw new XLFSDecryptorException(ErrorValue.CertificateError, message , null);
            }            

            return collection[0].PrivateKey;
        }

        

        private static void DecryptFile(byte[] sessionKey, string inputFilename, string outputFilename, int blockSize, int blockStart, PaddingMode lastBlockPadding)
        {
            RijndaelManaged aes = new RijndaelManaged();
            aes.Mode = CipherMode.CBC;
            aes.Key = sessionKey;

            int aesBlockSize = aes.BlockSize / 8;  // aes.BlockSize is a length in bits.  Convert to bytes for usefulness.
            byte[] IV = new byte[aesBlockSize];
            byte[] buffer = new byte[blockSize + aesBlockSize];

            try
            {
                using (FileStream fs = new FileStream(inputFilename, FileMode.Open, FileAccess.Read))
                {
                    using (FileStream output = new FileStream(outputFilename, FileMode.Create))
                    {
                        long length = fs.Length;
                        int block = blockStart;
                        while (length > 0)
                        {
                            int read = fs.Read(buffer, 0, blockSize);
                            length = length - read;                           

                            BlockNumberToIV(IV, block);
                            aes.IV = IV;
                            aes.Padding = PaddingMode.None;
                            if (length == 0)
                            {
                                // Do padding on the last block
                                aes.Padding = lastBlockPadding;
                            }

                            using (ICryptoTransform transform = aes.CreateDecryptor())
                            {
                                if (length != 0)
                                {
                                    int decryptedBytes = transform.TransformBlock(buffer, 0, read, buffer, 0);
                                    output.Write(buffer, 0, decryptedBytes);
                                }
                                else
                                {
                                    //
                                    // BUGBUG: There has to be a way to do this without allocating a new buffer.
                                    //         TransformBlock doesn't appear to handle final blocks correctly.
                                    //
                                    byte[] testOutput = transform.TransformFinalBlock(buffer, 0, read);
                                    output.Write(testOutput, 0, testOutput.Length);
                                }
                            }

                            block++;
                        }
                    }
                }
            }
            catch (FileNotFoundException e)
            {
                throw new XLFSDecryptorException(ErrorValue.FileNotFound, "File " + e.FileName + " not found.", e);
            }
            catch (CryptographicException e)
            {
                throw new XLFSDecryptorException(ErrorValue.CryptoError, "Crypto error: " + e.Message, e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\XlfsDownloader\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.server.xlfs.client.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("xonline.server.xlfs.client.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\XlfsDownloader\MainWindow.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Forms;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace xonline.server.xlfs.client
{
    /// <summary>
    /// Interaction logic for Window1.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        DownloaderApp downloaderApp = new DownloaderApp();

        ObservableCollection<XlfsFileEntry> _EnumFileCollection =
            new ObservableCollection<XlfsFileEntry>();
        public ObservableCollection<XlfsFileEntry> EnumFileCollection
            { get { return _EnumFileCollection; } }

        Dictionary<String, SASInfo> _EnumSASDictionary =
            new Dictionary<String, SASInfo>();
        public Dictionary<String, SASInfo> EnumSASDictionary
            { get { return _EnumSASDictionary; } }

        GridViewColumnHeader _LastHeaderClicked = null;
        ListSortDirection _LastDirection = ListSortDirection.Ascending;

        public string ServerCertificateName { get; set; }

        public MainWindow()
        {
            InitializeComponent();
        }

        private void BackgroundDownloaderWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            // If we have a user state present, then the progress notification is 
            // for the percent download of that file
            if (e.UserState != null && e.UserState is XlfsBackgroundDownloadProgress)
            {
                XlfsBackgroundDownloadProgress progress = (XlfsBackgroundDownloadProgress)e.UserState;
                XlfsFileEntry entry = progress.File;
                if (e.ProgressPercentage == 1000)
                {
                    // Fully downloaded
                    entry.LastDownloaded = DateTime.UtcNow;
                }
                int ProgressPercentage = 1000;

                // Calculate the download percentage
                if (progress.OverallBytes != 0)
                {
                   ProgressPercentage = (int) (progress.OverallBytesDownloaded * 1000 / progress.OverallBytes);

                }
                StatusProgressBar.Value = ProgressPercentage;
                return;
            }
        }

        private void BackgroundDownloaderWorker_WorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            // Hide the progress bar
            StatusProgressBar.Visibility = Visibility.Hidden;
            StatusProgressBar.Value = 0;

            if (e.Error != null)
            {
                StatusTextBlock.Text = "Error";
                System.Windows.Forms.MessageBox.Show(e.Error.Message);
                return;
            }
            if (e.Cancelled == true)
            {
                StatusTextBlock.Text = "Cancelled";
                return;
            }
            StatusTextBlock.Text = "Ready";
        }

        private void BackgroundRefreshWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            StatusProgressBar.Value = e.ProgressPercentage;

            XlfsAdminGetChangedBlobs getBlobs = (XlfsAdminGetChangedBlobs)e.UserState;

            //
            // Move all the files into the collection
            //
            foreach (XlfsFileEntry entry in getBlobs.Files)
            {
                // Make sure that the file isn't already there
                int i = _EnumFileCollection.Count;
                bool duplicate = false;

                while (i > 0)
                {
                    i--;
                    if (_EnumFileCollection[i].TransactionId == entry.TransactionId)
                    {
                        duplicate = true;
                        break;
                    }
                    if (_EnumFileCollection[i].LastUpdate.Value > entry.LastUpdate.Value)
                    {
                        break;
                    }
                }

                // If it wasn't a duplicate then add it to the collection
                if (duplicate == false)
                {
                    _EnumFileCollection.Add(entry);
                }
            }

            // Pick up all of the SAS records
            foreach (KeyValuePair<String, SASInfo> entry in getBlobs.SASDictionary)
            {
                if (_EnumSASDictionary.ContainsKey(entry.Key) == true)
                {
                    _EnumSASDictionary.Remove(entry.Key);
                }
                _EnumSASDictionary.Add(entry.Key, entry.Value);
            }
        }

        private void BackgroundRefreshWorker_WorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            // Hide the progress bar
            StatusProgressBar.Visibility = Visibility.Hidden;
            StatusProgressBar.Value = 0;

            if (e.Error != null)
            {
                StatusTextBlock.Text = "Error";
                System.Windows.Forms.MessageBox.Show(e.Error.Message);
                return;
            }
            if (e.Cancelled == true)
            {
                StatusTextBlock.Text = "Cancelled";
                return;
            }
            StatusTextBlock.Text = "Found " + _EnumFileCollection.Count.ToString() + " Files";
        }

        private void CertificatePickerButton_Click(object sender, RoutedEventArgs e)
        {
            Exception lastException = null;

            try
            {
                X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
                store.Open(OpenFlags.ReadOnly | OpenFlags.OpenExistingOnly);

                X509Certificate2Collection collection = (X509Certificate2Collection)store.Certificates;
                X509Certificate2Collection fcollection = (X509Certificate2Collection)collection.Find(X509FindType.FindByTimeValid, DateTime.Now, true);
                X509Certificate2Collection scollection = X509Certificate2UI.SelectFromCollection(
                    fcollection,
                    "Admin Client Certificate Select",
                    "Select a certificate from the following list in order to communicate to the Xlfs Admin FD",
                    X509SelectionFlag.SingleSelection
                    );

                foreach (X509Certificate2 x509 in scollection)
                {
                    X500DistinguishedName dname = new X500DistinguishedName(x509.SubjectName);

                    CertificateNameTextBox.Text = dname.Name;
                    ServerCertificateName = dname.Name;
                }
            }
            catch (Exception exception)
            {
                lastException = exception;
            }

            if (lastException != null)
            {
                System.Windows.Forms.MessageBox.Show(
                    "Exception Occured: " + lastException.ToString()
                    );
            }
        }

        private void DownloadAllButton_Click(object sender, RoutedEventArgs e)
        {
            string downloadPath = SaveDirectoryTextBox.Text;
            if (string.IsNullOrEmpty(downloadPath) == true)
            {
                System.Windows.Forms.MessageBox.Show(
                    "Please Specify A Download Path"
                    );
                return;
            }

            if (EnumFileCollection.Count == 0 ||
                EnumSASDictionary.Count == 0)
            {
                System.Windows.Forms.MessageBox.Show(
                    "Please refresh the list of available files"
                    );
                return;
            }

            int titleId;
            ComboBoxItem item = (TitleIdRangeComboBox.SelectedItem as ComboBoxItem);
            if (Int32.TryParse((item.Content as String), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out titleId) == false)
            {
                titleId = unchecked((int)0xFFFE07D1);
            }

            // Make a copy to pass to the background worker
            List<XlfsFileEntry> selectedFiles = new List<XlfsFileEntry>();
            foreach (XlfsFileEntry entry in EnumFileCollection)
            {
                entry.LastDownloadAttempt = null;
                selectedFiles.Add(entry);
            }

            // Show the progress bar
            StatusProgressBar.Value = 0;
            StatusProgressBar.Visibility = Visibility.Visible;
            StatusTextBlock.Text = "Downloading";

            // Create the arguments that we will pass to the downloader
            XlfsBackgroundDownloadArgs args = new XlfsBackgroundDownloadArgs();
            args.SAS = _EnumSASDictionary;
            args.Files = selectedFiles;
            args.TitleId = titleId;
            args.CertificateName = ServerCertificateName;
            args.ServerAddress = new Uri(UrlAddressBox.Text);
            args.SaveDirectory = downloadPath;
            args.MetaDataOnly = false;

            // Create a background worker to do the real download
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += new DoWorkEventHandler(downloaderApp.DownloadFiles);
            bw.ProgressChanged += BackgroundDownloaderWorker_ProgressChanged;
            bw.RunWorkerCompleted += BackgroundDownloaderWorker_WorkerCompleted;
            bw.WorkerReportsProgress = true;
            bw.RunWorkerAsync(args);
        }

        private void DownloadSelectedButton_Click(object sender, RoutedEventArgs e)
        {
            string downloadPath = SaveDirectoryTextBox.Text;
            if (string.IsNullOrEmpty(downloadPath) == true)
            {
                System.Windows.Forms.MessageBox.Show(
                    "Please Specify A Download Path"
                    );
                return;
            }

            if (EnumFileCollection.Count == 0 ||
                EnumSASDictionary.Count == 0)
            {
                System.Windows.Forms.MessageBox.Show(
                    "Please refresh the list of available files"
                    );
                return;
            }

            if (EnumFilesListView.SelectedItem == null)
            {
                System.Windows.Forms.MessageBox.Show(
                    "Please select one or more file to download"
                    );
                return;
            }

            int titleId;
            ComboBoxItem item = (TitleIdRangeComboBox.SelectedItem as ComboBoxItem);
            if (Int32.TryParse((item.Content as String), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out titleId) == false)
            {
                titleId = unchecked((int)0xFFFE07D1);
            }

            // Obtain the list of selected files
            System.Collections.IList genericSelectedFiles = EnumFilesListView.SelectedItems;
            List<XlfsFileEntry> selectedFiles = new List<XlfsFileEntry>();

            // Make a copy to pass to the background worker
            foreach (XlfsFileEntry entry in genericSelectedFiles)
            {
                entry.LastDownloadAttempt = null;
                selectedFiles.Add(entry);
            }

            // Show the progress bar
            StatusProgressBar.Value = 0;
            StatusProgressBar.Visibility = Visibility.Visible;
            StatusTextBlock.Text = "Downloading";

            // Create the arguments that we will pass to the downloader
            XlfsBackgroundDownloadArgs args = new XlfsBackgroundDownloadArgs();
            args.SAS = _EnumSASDictionary;
            args.Files = selectedFiles;
            args.TitleId = titleId;
            args.CertificateName = ServerCertificateName;
            args.ServerAddress = new Uri(UrlAddressBox.Text);
            args.SaveDirectory = downloadPath;
            args.MetaDataOnly = false;

            // Create a background worker to do the real download
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += new DoWorkEventHandler(downloaderApp.DownloadFiles);
            bw.ProgressChanged += BackgroundDownloaderWorker_ProgressChanged;
            bw.RunWorkerCompleted += BackgroundDownloaderWorker_WorkerCompleted;
            bw.WorkerReportsProgress = true;
            bw.RunWorkerAsync(args);
        }

        private void EnumFilesListView_Click(object sender, RoutedEventArgs e)
        {
            GridViewColumnHeader headerClicked = e.OriginalSource as GridViewColumnHeader;
            ListSortDirection direction;

            if (headerClicked == null || headerClicked.Role == GridViewColumnHeaderRole.Padding)
            {
                return;
            }
            if (headerClicked != _LastHeaderClicked)
            {
                direction = ListSortDirection.Ascending;
            }
            else
            {
                direction = (_LastDirection == ListSortDirection.Ascending ? ListSortDirection.Descending : ListSortDirection.Ascending);
            }

            System.Windows.Controls.GridViewColumn column = headerClicked.Column;
            string header = ((System.Windows.Data.Binding)(column.DisplayMemberBinding)).Path.Path;

            // Clear the current sort
            ICollectionView dataView = CollectionViewSource.GetDefaultView(EnumFilesListView.ItemsSource);
            dataView.SortDescriptions.Clear();

            // Sort the data using the new column
            SortDescription sd = new SortDescription(header, direction);
            dataView.SortDescriptions.Add(sd);

            // Refresh the display
            dataView.Refresh();

            // Remove the arrow from the last header
            if (_LastHeaderClicked != null)
            {
                _LastHeaderClicked.Column.HeaderTemplate = null;
            }

            // Update the header with an arrow
            if (direction == ListSortDirection.Ascending)
            {
                headerClicked.Column.HeaderTemplate = Resources["HeaderTemplateArrowUp"] as DataTemplate;
            }
            else
            {
                headerClicked.Column.HeaderTemplate = Resources["HeaderTemplateArrowDown"] as DataTemplate;
            }

            // Remember the sorting
            _LastHeaderClicked = headerClicked;
            _LastDirection = direction;
        }

        private void RefreshButton_Click(object sender, RoutedEventArgs e)
        {
            ComboBoxItem item = (DateRangeComboBox.SelectedItem as ComboBoxItem);
            int dateRange;

            if (Int32.TryParse((item.Content as String), out dateRange) == false)
            {
                dateRange = 31;
            }

            int titleId;
            item = (TitleIdRangeComboBox.SelectedItem as ComboBoxItem);
            if (Int32.TryParse((item.Content as String), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out titleId) == false)
            {
                titleId = unchecked((int)0xFFFE07D1);
            }

            // Setup the status bar
            StatusTextBlock.Text = "Refreshing Files";
            StatusProgressBar.Value = 0;
            StatusProgressBar.Visibility = Visibility.Visible;

            // Remove all of the existing files and SAS info links
            _EnumFileCollection.Clear();
            _EnumSASDictionary.Clear();

            // Create the arguments that we will pass to the worker
            XlfsBackgroundEnumArgs args = new XlfsBackgroundEnumArgs();
            args.CertificateName = ServerCertificateName;
            args.ServerAddress = new Uri(UrlAddressBox.Text);
            args.TitleId = titleId;
            args.StartTime = DateTime.UtcNow.AddDays(-1 * dateRange);
            args.EndTime = DateTime.UtcNow;

            // Create a background worker to do the real download
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += new DoWorkEventHandler(downloaderApp.RefreshFiles);
            bw.ProgressChanged += BackgroundRefreshWorker_ProgressChanged;
            bw.RunWorkerCompleted += BackgroundRefreshWorker_WorkerCompleted;
            bw.WorkerReportsProgress = true;
            bw.RunWorkerAsync(args);
        }

        private void SaveDirectoryButton_Click(object sender, RoutedEventArgs e)
        {
            FolderBrowserDialog dlg = new FolderBrowserDialog();
            
            // Is there already a label?
            if (SaveDirectoryTextBox.Text == null || SaveDirectoryTextBox.Text == "")
            {
                dlg.SelectedPath = System.IO.Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            }
            else
            {
                dlg.SelectedPath = SaveDirectoryTextBox.Text;
            }

            if (dlg.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                SaveDirectoryTextBox.Text = dlg.SelectedPath;
            }
        }

        private void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            ComboBoxItem item = null;
            for (int i = 100; i >= 1; i--)
            {
                item = new ComboBoxItem();
                item.Content = i.ToString();
                DateRangeComboBox.Items.Add(item);
            }
            DateRangeComboBox.SelectedItem = item;

            String[] allowedTitles = {
                 "4D5308FB",
                 "4D5308FC",
                 "4D530907",
                 "4D53093A",
                 "4D53891A",
                 "4D538921",
                 "584807DC",
                 "FFFF0072",
                 "FFFF063F",
                 "FFFF0640",
                 "FFFF0641",
                 "FFFF0642",
                 "FFFF0643",
                 "FFFF0644",
                 "FFFF0645",
                 "FFFF0646",
                 "FFFF0647",
                 };
            foreach (string str in allowedTitles)
            {

                item = new ComboBoxItem();
                item.Content = str;
                TitleIdRangeComboBox.Items.Add(item);
            }

            item = new ComboBoxItem();
            item.Content = "FFFE07D1";
            TitleIdRangeComboBox.Items.Add(item);
            TitleIdRangeComboBox.SelectedItem = item;

            StatusTextBlock.Text = "Initialized";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\Common\XlfsWebRequest.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Security;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml;
using System.Xml.XPath;
using System.Web;

namespace xonline.server.xlfs.client
{
    public class XlfsWebRequest
    {
        public HttpWebRequest Request { get; protected set; }
        public HttpWebResponse Response { get; protected set; }

        public HttpStatusCode HttpStatus { get; protected set; }
        public WebExceptionStatus WebStatus { get; protected set; }
        public Exception RequestException { get; protected set; }

        public Uri XlfsServer { get; set; }
        public string XlfsCertificateName { get; set; }
        public string XlfsCertificateThumbprint { get; set; }

        protected virtual String RequestMethod { get { return "GET"; } }
        protected virtual String MethodName { get; set; }
        protected virtual String QueryString { get; set; }

        public IWebProxy Proxy { get; set; }

        private String securityToken;
        [HttpHeaderParameter("X-Authorization", "XBL1.0 x")]
        public String SecurityToken
        {
            get
            {
                return securityToken;
            }
            set { securityToken = value; }
        }

        public virtual bool Execute()
        {
            return Execute(XlfsServer);
        }

        public virtual bool Execute(String baseUri)
        {
            return Execute(new Uri(baseUri));
        }

        public virtual bool Execute(Uri baseUri)
        {
            Dictionary<String, String> headers = new Dictionary<String, String>();
            List<String> queryParameters = new List<String>();

            Type t = this.GetType();
            PropertyInfo[] mis = t.GetProperties(BindingFlags.Public | BindingFlags.Instance);// | BindingFlags.GetField | BindingFlags.GetProperty);
            foreach (PropertyInfo mi in mis)
            {
                // Get the value of the property
                Object value = (mi as PropertyInfo).GetValue(this, null);

                // Check if it's a header
                object[] headerParams = mi.GetCustomAttributes(typeof(HttpHeaderParameterAttribute), true);
                if (headerParams.Length > 0)
                {
                    HttpHeaderParameterAttribute headerParam = (HttpHeaderParameterAttribute)headerParams[0];
                    if (value == null && !headerParam.Required)
                    {
                        continue;
                    }
                    headers.Add(headerParam.Name, headerParam.GenerateParamString(value));
                }

                // Check if it's a query param
                object[] queryParams = mi.GetCustomAttributes(typeof(HttpQueryParameterAttribute), true);
                if (queryParams.Length > 0)
                {
                    HttpQueryParameterAttribute queryParam = (HttpQueryParameterAttribute)queryParams[0];
                    if(value == null && !queryParam.Required)
                    {
                        continue;
                    }
                    queryParameters.Add(queryParam.GenerateParamString(value));
                }
            }

            UriBuilder ub = new UriBuilder(baseUri);
            ub.Path = MethodName;
            ub.Query = String.Join("&", queryParameters.ToArray());

            Request = (HttpWebRequest)HttpWebRequest.Create(ub.Uri);
            Request.Method = RequestMethod;

            foreach (String headerName in headers.Keys)
            {
                Request.Headers.Add(headerName, headers[headerName]);
            }

            if (String.IsNullOrEmpty(XlfsCertificateName) == false)
            {
                X509Certificate2 cert = GetCertificateBySubjectName(XlfsCertificateName, true);
                if (cert != null)
                {
                    Request.UseDefaultCredentials = false;
                    Request.AuthenticationLevel = AuthenticationLevel.MutualAuthRequired;
                    Request.ClientCertificates.Add(cert);
                }
                else
                {
                    throw new Exception(String.Format("XlfsWebRequest: Cannot Find Certificate Named: {0}", XlfsCertificateName));
                }
            }
            else if (String.IsNullOrEmpty(XlfsCertificateThumbprint) == false)
            {
                X509Certificate2 cert = GetCertificateByThumbprint(XlfsCertificateThumbprint, true);
                if (cert != null)
                {
                    Request.UseDefaultCredentials = false;
                    Request.AuthenticationLevel = AuthenticationLevel.MutualAuthRequired;
                    Request.ClientCertificates.Add(cert);
                }
                else
                {
                    throw new Exception(String.Format("XlfsWebRequest: Cannot Find Certificate Thumbprint: {0}", XlfsCertificateThumbprint));
                }
            }

            if (Proxy != null)
            {
                Request.Proxy = Proxy;
            }

            //Request.Headers.Add("X-Authorization", "x=" + securityToken);

            if (Request.Method == "POST")
            {
                // Write the request body
                Stream reqStream = Request.GetRequestStream();
                WriteRequest(reqStream);
            }

            Response = (HttpWebResponse)Request.GetResponse();
            ProcessResponse(Response);

            return true;
        }

        protected X509Certificate2 GetCertificateBySubjectName(string certSubject, bool isPrivateKeyRequired)
        {
            X509Certificate2 certificate = null;

            // Try to find the certificate in the user store
            X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(
                    X509FindType.FindBySubjectDistinguishedName, 
                    certSubject, 
                    false);

                if (matches.Count >= 1)
                {
                    certificate = matches[0];
                    if (isPrivateKeyRequired && certificate.HasPrivateKey == false)
                    {
                        certificate = null;
                    }
                }
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
            if (certificate != null)
            {
                return certificate;
            }

            // Try to find the certificate in the machine store
            store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(
                    X509FindType.FindBySubjectDistinguishedName,
                    certSubject,
                    false);

                if (matches.Count >= 1)
                {
                    certificate = matches[0];
                    if (isPrivateKeyRequired && certificate.HasPrivateKey == false)
                    {
                        certificate = null;
                    }
                }
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
            return certificate;
        }

        protected X509Certificate2 GetCertificateByThumbprint(string certThumbprint, bool isPrivateKeyRequired)
        {
            X509Certificate2 certificate = null;

            // Try to find the certificate in the user store
            X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(
                    X509FindType.FindByThumbprint,
                    certThumbprint,
                    false);

                if (matches.Count >= 1)
                {
                    certificate = matches[0];
                    if (isPrivateKeyRequired && certificate.HasPrivateKey == false)
                    {
                        certificate = null;
                    }
                }
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
            if (certificate != null)
            {
                return certificate;
            }

            // Try to find the certificate in the machine store
            store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(
                    X509FindType.FindByThumbprint,
                    certThumbprint,
                    false);

                if (matches.Count >= 1)
                {
                    certificate = matches[0];
                    if (isPrivateKeyRequired && certificate.HasPrivateKey == false)
                    {
                        certificate = null;
                    }
                }
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
            return certificate;
        }

        protected virtual void WriteRequest(Stream stream) { Request.ContentLength = 0; }

        protected virtual void ProcessResponse(HttpWebResponse response) { }
        protected virtual void ProcessResponse(XPathDocument doc) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\XlfsDownloader\App.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Windows;

namespace xonline.server.xlfs.client
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\BlobTableContext.cs ===
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class BlobTableContext : TableServiceContext
    {
        public BlobTableContext(string baseAddress, StorageCredentials credentials)
            : base(baseAddress, credentials)
        {
        }

        public IQueryable<BlobTableEntry> BlobTableEntry
        {
            get
            {
                return CreateQuery<BlobTableEntry>("BlobTableEntry");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\client\XlfsDownloader\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.server.xlfs.client.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\BlobTableDataSource.cs ===
using System;
using System.Collections.Generic;
using System.Data.Services.Client;
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class BlobTableDataSource
    {
        private static readonly CloudStorageAccount StorageAccount;

        static BlobTableDataSource()
        {
            StorageAccount = CloudStorageAccount.FromConfigurationSetting("StorageConnectionString");

            CloudTableClient.CreateTablesFromModel(
                typeof (BlobTableContext), 
                StorageAccount.TableEndpoint.AbsoluteUri,
                StorageAccount.Credentials);
        }

        private static BlobTableContext GetContext()
        {
            BlobTableContext context = new BlobTableContext(
                StorageAccount.TableEndpoint.AbsoluteUri,
                StorageAccount.Credentials);

            context.RetryPolicy = RetryPolicies.Retry(3, TimeSpan.FromSeconds(1));

            return context;
        }

        public BlobTableEntry SelectBlobTableEntry(BlobTableEntry entry)
        {
            BlobTableContext context = GetContext();
            context.MergeOption = MergeOption.NoTracking;

            var results = (from p in context.BlobTableEntry
                          where p.RowKey == entry.RowKey && p.PartitionKey == entry.PartitionKey
                          select p).AsTableServiceQuery();

            try
            {
                foreach (BlobTableEntry e in results)
                {
                    return e;
                }
            }
            catch
            {
                return null;
            }

            return null;
        }

        public void AddBlobTableEntry(BlobTableEntry entry)
        {
            BlobTableContext context = GetContext();

            context.AddObject("BlobTableEntry", entry);
            context.SaveChanges();
        }

        public void DeleteBlobTableEntry(BlobTableEntry entry)
        {
            BlobTableContext context = GetContext();

            context.AttachTo("BlobTableEntry", entry, "*");
            context.DeleteObject(entry);
            context.SaveChanges();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\BlobTableEntry.cs ===
using System;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class BlobTableEntry : TableServiceEntity
    {
        // Partition Key is XUID
        // RowKey is Transaction GUID
        public int TitleId { get; set; }
        public string Filename { get; set; }
        public string MD5 { get; set; }
        public string StorageAccount { get; set; }

        public static readonly string ContainerBlobFormatString = "x8";
        public static readonly string XuidFormatString = "X16";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\FileTableContext.cs ===
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class FileTableContext : TableServiceContext
    {
        public FileTableContext(string baseAddress, StorageCredentials credentials)
            : base(baseAddress, credentials)
        {
        }

        public IQueryable<FileTableEntry> FileTableEntry
        {
            get
            {
                return CreateQuery<FileTableEntry>("FileTableEntry");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\FileTableDataSource.cs ===
using System;
using System.Collections.Generic;
using System.Data.Services.Client;
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class FileTableDataSource
    {
        private static readonly CloudStorageAccount storageAccount;

        static FileTableDataSource()
        {
            storageAccount = CloudStorageAccount.FromConfigurationSetting("StorageConnectionString");

            CloudTableClient.CreateTablesFromModel(
                typeof (FileTableContext), 
                storageAccount.TableEndpoint.AbsoluteUri,
                storageAccount.Credentials);
        }

        private static FileTableContext GetContext()
        {
            FileTableContext context = new FileTableContext(
                storageAccount.TableEndpoint.AbsoluteUri, 
                storageAccount.Credentials);

            context.RetryPolicy = RetryPolicies.Retry(3, TimeSpan.FromSeconds(1));

            return context;
        }

        public IEnumerable<FileTableEntry> Enum(DateTime startDate, DateTime endDate)
        {
            FileTableContext context = GetContext();
            context.MergeOption = MergeOption.NoTracking;

            var allResults = from p in context.FileTableEntry
                             where p.LastUpdate >= startDate && p.LastUpdate <= endDate
                             select p;

            return allResults;
        }

        public IEnumerable<FileTableEntry> Enum(DateTime startDate, DateTime endDate, int titleId)
        {
            FileTableContext context = GetContext();
            context.MergeOption = MergeOption.NoTracking;

            var allResults = from p in context.FileTableEntry
                             where p.TitleId == titleId && p.LastUpdate >= startDate && p.LastUpdate <= endDate
                             select p;

            return allResults;
        }

        public FileTableEntry SelectFileTableEntry(FileTableEntry entry)
        {
            FileTableContext context = GetContext();
            context.MergeOption = MergeOption.NoTracking;

            var results = from p in context.FileTableEntry
                          where p.RowKey == entry.RowKey && p.PartitionKey == entry.PartitionKey
                          select p;

            foreach (FileTableEntry e in results)
            {
                return e;
            }

            return null;
        }

        public void AddFileTableEntry(FileTableEntry entry)
        {
            FileTableContext context = GetContext();

            context.AddObject("FileTableEntry", entry);
            context.SaveChanges();
        }

        public void UpdateFileTableEntry(FileTableEntry entry)
        {
            FileTableContext context = GetContext();

            context.AttachTo("FileTableEntry", entry, "*");
            context.UpdateObject(entry);
            context.SaveChanges();
        }

        public void DeleteFileTableEntry(FileTableEntry entry)
        {
            FileTableContext context = GetContext();

            context.AttachTo("FileTableEntry", entry, "*");
            context.DeleteObject(entry);
            context.SaveChanges();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\FileTableLastUpdateContext.cs ===
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class FileTableLastUpdateContext : TableServiceContext
    {
        public FileTableLastUpdateContext(string baseAddress, StorageCredentials credentials)
            : base(baseAddress, credentials)
        {
        }

        public IQueryable<FileTableLastUpdateEntry> FileTableLastUpdateEntry
        {
            get
            {
                return CreateQuery<FileTableLastUpdateEntry>("FileTableLastUpdateEntry");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\FileTableEntry.cs ===
using System;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class FileTableEntry : TableServiceEntity
    {
        // PartitionKey is Xuid.ToString("X16")
        // RowKey is string.Format("{0}/{1}.{2}", PartitionKey, TitleId.ToString("X8"), TransactionId)
        public int TitleId { get; set; }
        public string Filename { get; set; }
        public string TransactionId { get; set; }
        public string StorageAccount { get; set; }
        public DateTime Created { get; set; }
        public DateTime? LastUpdate { get; set; }
        public long? Size { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\IXlfsGcMessageHandler.cs ===

namespace xonline.server.xlfs.common
{
    public interface IXlfsGcMessageHandler
    {
        void HandleMessage(XlfsGcMessage msg, IXlfsTrace trace);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\FileTableLastUpdateEntry.cs ===
using System;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class FileTableLastUpdateEntry : TableServiceEntity
    {
        // PartitionKey is LastUpdate.ToString("yyyy:MM:dd:HH")
        // RowKey is string.Format("{0}.{1}.{2}", TitleId.ToString("X8"), Xuid.ToString("X16"), FileName)
        public long UserXuid { get; set; }
        public int TitleId { get; set; }
        public string Filename { get; set; }
        public string TransactionId { get; set; }
        public string StorageAccount { get; set; }
        public DateTime Created { get; set; }
        public DateTime? LastUpdate { get; set; }
        public long? Size { get; set; }

        // Constant String Formatters
        public static readonly string RowKeyFormatString = "{0}:{1}:{2}";
        public static readonly string PartitionKeyFormatString = "yyyy:MM:dd:HH";
        public static readonly string TitleIdFormatString = "X8";
        public static readonly string XuidFormatString = "X16";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\ixlfstrace.cs ===
namespace xonline.server.xlfs.common
{
    /// <summary>
    /// Tracing interface.
    /// </summary>
    public interface IXlfsTrace
    {

        void AddAttribute(string name, string value);
        void Flush();
        void AppendErrorLine(string msg);
        void AppendErrorLine(string msg, params object [] args);
        void AppendWarningLine(string msg);
        void AppendWarningLine(string msg, params object[] args);
        void AppendInfoLine(string msg);
        void AppendInfoLine(string msg, params object[] args);
        void AppendLine(string msg);
        void AppendLine(string msg, params object[] args);
        void WriteEvent(string msg);
        void WriteEvent(string msg, params object[] args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\FileTableLastUpdateDataSource.cs ===
using System;
using System.Collections.Generic;
using System.Data.Services.Client;
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class FileTableLastUpdateDataSource
    {
        public static CloudStorageAccount StorageAccount { get; set; }

        private static FileTableLastUpdateContext GetContext()
        {
            FileTableLastUpdateContext context = new FileTableLastUpdateContext(
                StorageAccount.TableEndpoint.AbsoluteUri, 
                StorageAccount.Credentials);

            context.RetryPolicy = RetryPolicies.Retry(3, TimeSpan.FromSeconds(1));

            return context;
        }

        private static void GetConfiguredStorageAccount()
        {
            StorageAccount = CloudStorageAccount.FromConfigurationSetting("StorageConnectionString");

            CloudTableClient.CreateTablesFromModel(
                typeof(FileTableLastUpdateContext),
                StorageAccount.TableEndpoint.AbsoluteUri,
                StorageAccount.Credentials);
        }

        /// <summary>
        /// Returns all of the files in the specified partition that match the given titleid
        /// </summary>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="titleId"></param>
        /// <param name="maxResults"></param>
        /// <param name="continuationToken"></param>
        /// <returns></returns>
        public List<FileTableLastUpdateEntry> Enum(
            DateTime startDate,
            DateTime endDate,
            int titleId,
            int maxResults,
            ref ResultContinuation continuationToken)
        {
            if(StorageAccount == null)
            {
                GetConfiguredStorageAccount();
            }

            FileTableLastUpdateContext context = GetContext();
            context.MergeOption = MergeOption.NoTracking;

            // Calculate exactly 1 partitions worth of time
            string partitionString = startDate.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString);
            string startTitle = titleId.ToString(FileTableLastUpdateEntry.TitleIdFormatString);
            string endTitle = (titleId + 1).ToString(FileTableLastUpdateEntry.TitleIdFormatString);

            // List object to return to the caller.
            List<FileTableLastUpdateEntry> fileList = new List<FileTableLastUpdateEntry>();

            // Create an enumerator
            var query = (from p in context.FileTableLastUpdateEntry
                         where p.PartitionKey.CompareTo(partitionString) == 0
                               && p.RowKey.CompareTo(startTitle) >= 0
                               && p.RowKey.CompareTo(endTitle) < 0
                         select p)
                .Take(maxResults)
                .AsTableServiceQuery();

            IAsyncResult asyncResult = continuationToken == null
                                           ? query.BeginExecuteSegmented(null, null)
                                           : query.BeginExecuteSegmented(continuationToken, null, null);

            // Wait for the request to complete.
            asyncResult.AsyncWaitHandle.WaitOne();

            // Get back the results.
            var resultSegment = query.EndExecuteSegmented(asyncResult);

            continuationToken = resultSegment.ContinuationToken;

            fileList.AddRange(
                resultSegment.Results.Where(entry => entry.LastUpdate >= startDate && entry.LastUpdate < endDate));

            while (resultSegment.HasMoreResults)
            {
                resultSegment = resultSegment.GetNext();

                fileList.AddRange(
                    resultSegment.Results.Where(entry => entry.LastUpdate >= startDate && entry.LastUpdate < endDate));
            }

            return fileList;
        }

        public FileTableLastUpdateEntry SelectFileTableEntry(FileTableLastUpdateEntry entry)
        {
            if (StorageAccount == null)
            {
                GetConfiguredStorageAccount();
            }

            FileTableLastUpdateContext context = GetContext();
            context.MergeOption = MergeOption.NoTracking;

            var results = (from p in context.FileTableLastUpdateEntry
                          where p.RowKey == entry.RowKey && p.PartitionKey == entry.PartitionKey
                          select p).AsTableServiceQuery();

            try
            {
                foreach (FileTableLastUpdateEntry e in results)
                {
                    return e;
                }
            }
            catch
            {
                return null;
            }

            return null;
        }

        public List<FileTableLastUpdateEntry> SelectPartition(string partition, ref ResultContinuation continuationToken)
        {
            if (StorageAccount == null)
            {
                GetConfiguredStorageAccount();
            }

            FileTableLastUpdateContext context = GetContext();
            context.MergeOption = MergeOption.NoTracking;

            List<FileTableLastUpdateEntry> files = new List<FileTableLastUpdateEntry>();

            var query = (from p in context.FileTableLastUpdateEntry
                           where p.PartitionKey == partition
                           select p).AsTableServiceQuery();

            IAsyncResult asyncResult = continuationToken == null
                               ? query.BeginExecuteSegmented(null, null)
                               : query.BeginExecuteSegmented(continuationToken, null, null);

            // Wait for the request to complete.
            asyncResult.AsyncWaitHandle.WaitOne();

            // Get back the results.
            var resultSegment = query.EndExecuteSegmented(asyncResult);

            continuationToken = resultSegment.ContinuationToken;

            files.AddRange(resultSegment.Results);

            while (resultSegment.HasMoreResults)
            {
                resultSegment = resultSegment.GetNext();

                files.AddRange(resultSegment.Results);
            }

            return files;

        }

        public void AddFileTableEntry(FileTableLastUpdateEntry entry)
        {
            if (StorageAccount == null)
            {
                GetConfiguredStorageAccount();
            }

            FileTableLastUpdateContext context = GetContext();

            context.AddObject("FileTableLastUpdateEntry", entry);
            context.SaveChanges();
        }

        public void UpdateFileTableEntry(FileTableLastUpdateEntry entry)
        {
            if (StorageAccount == null)
            {
                GetConfiguredStorageAccount();
            }

            FileTableLastUpdateContext context = GetContext();

            context.AttachTo("FileTableLastUpdateEntry", entry, "*");
            context.UpdateObject(entry);
            context.SaveChanges();
        }

        public void DeleteFileTableEntry(FileTableLastUpdateEntry entry)
        {
            if (StorageAccount == null)
            {
                GetConfiguredStorageAccount();
            }

            FileTableLastUpdateContext context = GetContext();

            context.AttachTo("FileTableLastUpdateEntry", entry, "*");
            context.DeleteObject(entry);
            context.SaveChanges();
        }

        /// <summary>
        /// Bulk-delete a bunch of rows from the FileTableLastUpdateEntry table.
        /// </summary>
        /// <param name="entries"></param>
        public void DeleteFileTableEntries(IEnumerable<FileTableLastUpdateEntry> entries)
        {
            if (StorageAccount == null)
            {
                GetConfiguredStorageAccount();
            }

            FileTableLastUpdateContext context = GetContext();
            context.MergeOption = MergeOption.OverwriteChanges;

            foreach(var entry in entries)
            {
                context.AttachTo("FileTableLastUpdateEntry", entry, "*");
                context.DeleteObject(entry);
            }

            context.SaveChanges();
        }
    }

    public class FileTableLastUpdateDataSourceComparer : IComparer<FileTableLastUpdateEntry>
    {
        public int Compare(FileTableLastUpdateEntry x, FileTableLastUpdateEntry y)
        {
            if (x == null || x.LastUpdate.HasValue == false)
            {
                if (y == null || y.LastUpdate.HasValue == false)
                {
                    return 0;
                }
                return -1;
            }
            if (y == null || y.LastUpdate.HasValue == false)
            {
                return 1;
            }
            return (x.LastUpdate.Value.CompareTo(y.LastUpdate.Value));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\HttpContextExtensions.cs ===
using System.Web;

namespace xonline.server.xlfs.common
{
    /// <summary>
    /// Extension methods on the System.Web.HttpContext class.
    /// </summary>
    public static class HttpContextExtensions
    {
        #region Tracing Extensions

        private const string TraceItem = "ContextTrace";

        public static void SetTrace(this HttpContext context, XlfsTrace trace)
        {
            context.Items[TraceItem] = trace;

            trace.AddAttribute("remoteAddress", context.Request.ServerVariables["REMOTE_ADDR"]);
            trace.AddAttribute("url", context.Request.Url.ToString());
            trace.AddAttribute("method", context.Request.HttpMethod);

            foreach(string key in context.Request.Headers.Keys)
            {
                if(key == "X-Authorization") continue;
                trace.AddAttribute(key, context.Request.Headers[key]);
            }
        }

        public static IXlfsTrace GetTrace(this HttpContext context)
        {
            return (IXlfsTrace)context.Items[TraceItem];
        }

        public static void AddAttribute(this HttpContext context, string name, string value)
        {
            ((XlfsTrace) context.Items[TraceItem]).AddAttribute(name, value);
        }

        public static void WriteErrorLine(this HttpContext context, string msg)
        {
            ((XlfsTrace) context.Items[TraceItem]).AppendErrorLine(msg);
        }

        public static void WriteWarningLine(this HttpContext context, string msg)
        {
            ((XlfsTrace) context.Items[TraceItem]).AppendWarningLine(msg);
        }

        public static void WriteInfoLine(this HttpContext context, string msg)
        {
            ((XlfsTrace) context.Items[TraceItem]).AppendInfoLine(msg);
        }

        public static void WriteLine(this HttpContext context, string msg)
        {
            ((XlfsTrace) context.Items[TraceItem]).AppendLine(msg);
        }

        public static void WriteEvent(this HttpContext context, string msg)
        {
            ((XlfsTrace) context.Items[TraceItem]).WriteEvent(msg);
        }

        public static void Flush(this HttpContext context)
        {
            ((XlfsTrace) context.Items[TraceItem]).Flush();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\ixlfstracefactory.cs ===
namespace xonline.server.xlfs.common
{
    /// <summary>
    /// Tracing interface.
    /// </summary>
    public interface IXlfsTraceFactory
    {
        IXlfsTrace Create();
        IXlfsTrace Create(string tag);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\StorageAccountManager.cs ===
using System;
using System.Collections.Generic;
using System.Data.Services.Client;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    /// <summary>
    /// This class abstracts operations that use the Storage Account Table, into
    /// the following operations:
    /// 1.  Increment/Decrement the Used number for a specified storage account.
    /// 2.  Round robin amongst available storage accounts.
    /// </summary>
    public class StorageAccountManager : IDisposable
    {
        /// <summary>
        /// Private child class used for tracking changes to the Used value
        /// for a specific blob storage account.
        /// </summary>
        private class UpdateUsedInfo
        {
            /// <summary>
            /// Constructor.
            /// </summary>
            /// <param name="storageAccountName"></param>
            /// <param name="value"></param>
            public UpdateUsedInfo(string storageAccountName, long value)
            {
                StorageAccountName = storageAccountName;
                UpdateUsedValue = value;
            }

            public long AddValue(long value)
            {
                UpdateUsedValue += value;
                return UpdateUsedValue;
            }

            public string StorageAccountName { get; private set; }
            public long UpdateUsedValue { get; private set; }
        }

        private Boolean disposed = false;

        private readonly CloudStorageAccount _cloudStorageAccount;
        private readonly StorageAccountTableDataSource _dataSource;
        private readonly Timer _refreshTimer;
        private readonly IXlfsTraceFactory _traceFactory;
        private int _storageAccountIndex;

        private readonly Thread _updateUsedThread;
        private readonly Queue<UpdateUsedInfo> _updateUsedQueue = new Queue<UpdateUsedInfo>();
        private Boolean _updateUsed = false;
        private Int32 _updateUsedInterval = 0;

        private List<StorageAccountTableEntry> _storageAccounts;
        public List<StorageAccountTableEntry> StorageAccounts
        {
            // Return a copy of the list, not the list itself.
            get { return _storageAccounts.ToList(); }
            private set { _storageAccounts = value; }
        }

        private List<StorageAccountTableEntry> _availableStorageAccounts;
        public List<StorageAccountTableEntry> AvailableStorageAccounts
        {
            // Return a copy of the list, not the list itself.
            get { return _availableStorageAccounts.ToList(); }
            private set { _availableStorageAccounts = value; }
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="cloudStorageAccount"></param>
        /// <param name="refreshInterval"></param>
        /// <param name="updateUsedInterval"></param>
        /// <param name="traceFactory"></param>
        public StorageAccountManager(
            CloudStorageAccount cloudStorageAccount, 
            int refreshInterval, 
            int updateUsedInterval, 
            IXlfsTraceFactory traceFactory)
        {
            _traceFactory = traceFactory;

            _cloudStorageAccount = cloudStorageAccount;
            _dataSource = new StorageAccountTableDataSource(_cloudStorageAccount);
            _storageAccountIndex = 0;

            Refresh(this);

            if(refreshInterval > 0)
            {
                _refreshTimer = new Timer(Refresh, null, refreshInterval, refreshInterval);
            }

            if (updateUsedInterval > 0)
            {
                _updateUsedInterval = updateUsedInterval;
                _updateUsedThread = new Thread(UpdateUsedThreadProc);
                _updateUsed = true;
                _updateUsedThread.Start(_updateUsedInterval);
            }}

        //Implement IDisposable.
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                IXlfsTrace trace = _traceFactory.Create("StorageAccountManager");
                trace.AppendLine("Disposing StorageAccountManager...");

                if (disposing)
                {
                    if (_refreshTimer != null)
                    {
                        trace.AppendLine("Disposing RefreshTimer");
                        _refreshTimer.Dispose();
                    }
                }

                if (_updateUsedThread != null)
                {
                    trace.AppendLine("Disposing UpdateUsedThread");
                    _updateUsed = false;
                    if (_updateUsedThread.ThreadState != ThreadState.Stopped && !_updateUsedThread.Join(_updateUsedInterval))
                    {
                        trace.AppendWarningLine("UpdateUsedThread still not stopped after expected update interval");
                    }
                }

                disposed = true;
            }
        }

        /// <summary>
        /// Destructor.
        /// </summary>
        ~StorageAccountManager()
        {
            Dispose(false);
        }

        #region UpdateUsedThreadProc and Helper Methods

        /// <summary>
        /// Empty the queue, and return a dictionary of the
        /// aggregated update information.
        /// </summary>
        /// <returns></returns>
        private Dictionary<string, UpdateUsedInfo> GetUsedUpdates(IXlfsTrace trace)
        {
            trace.AppendInfoLine("StorageAccountManager.GetUsedUpdates: Enter");

            try
            {
                Dictionary<string, UpdateUsedInfo> updates = new Dictionary<string, UpdateUsedInfo>();

                if (_updateUsedQueue.Count == 0)
                {
                    trace.AppendInfoLine("StorageAccountManager.GetUsedUpdates: Used updates queue is empty.");
                    return updates;
                }

                // Empty the queue.
                ulong updatesProcessed = 0;
                lock (_updateUsedQueue)
                {
                    while (_updateUsedQueue.Count != 0)
                    {
                        UpdateUsedInfo info = _updateUsedQueue.Dequeue();
                        ++updatesProcessed;

                        if (updates.ContainsKey(info.StorageAccountName))
                        {
                            updates[info.StorageAccountName].AddValue(info.UpdateUsedValue);
                        }
                        else
                        {
                            updates.Add(info.StorageAccountName, info);
                        }
                    }
                }

                trace.AppendInfoLine(
                    string.Format("StorageAccountManager.GetUsedUpdates: Processed {0} queued Used updates.",
                                  updatesProcessed));

                return updates;
            }
            finally
            {
                trace.AppendInfoLine("StorageAccountManager.GetUsedUpdates: Exit");
            }
        }

        /// <summary>
        /// Update the Used count for a single storage account.
        /// </summary>
        /// <param name="info"></param>
        /// <param name="trace"></param>
        private void UpdateUsed(UpdateUsedInfo info, IXlfsTrace trace)
        {
            trace.AppendInfoLine(string.Format("StorageAccountManager.UpdateUsed: Enter"));
            trace.AppendInfoLine(
                string.Format(
                    "StorageAccountManager.UpdateUsed: info.StorageAccountName = {0}, info.UpdateUsedValue = {1}",
                    info.StorageAccountName, info.UpdateUsedValue));

            try
            {
                StorageAccountTableContext context = StorageAccountTableContext.GetContext(_cloudStorageAccount);
                StorageAccountTableEntry entry = _dataSource.GetStorageAccount(context, info.StorageAccountName);

                long oldValue = entry.Used;
                entry.Used += info.UpdateUsedValue;

                trace.AppendInfoLine(string.Format("StorageAccountManager.UpdateUsed: Old = {0}, New = {1}", oldValue,
                                                   entry.Used));

                ulong tries = 0;

                while (true)
                {
                    try
                    {
                        ++tries;
                        context.UpdateObject(entry);
                        context.SaveChanges();
                        trace.AppendInfoLine(
                            string.Format("StorageAccountManager.UpdateUsed: New value ({0}) saved after {1} tries.",
                                          entry.Used,
                                          tries));

                        //  NOTE:  In the following blocks, we don't want to add or remove items
                        //  from the active list.  Rather, we want to reconstruct the entire list and then
                        //  replace _availableStorageAccounts.  This prevents issues in GetNextStorageAccount.
                        //  Manually call Refresh to accomplish this.  Occurences of these manual refreshes
                        //  should be exceedingly rare.

                        if (oldValue < entry.Threshold && entry.Used >= entry.Threshold)
                        {
                            Refresh(this);
                            trace.WriteEvent(
                                string.Format(
                                    "StorageAccountManager.UpdateUsed: Storage account \"{0}\" has exceeded it's Threshold and will not be used to store new blobs.",
                                    entry.PartitionKey));
                        }
                        else if (oldValue >= entry.Threshold && entry.Used < entry.Threshold)
                        {
                            Refresh(this);
                            trace.AppendInfoLine(
                                string.Format(
                                    "StorageAccountManager.UpdateUsed: Storage account \"{0}\" is now below Threshold and is available to store new blobs.",
                                    entry.PartitionKey));
                        }

                        return;
                    }
                    catch (DataServiceRequestException)
                    {
                        trace.AppendInfoLine(
                            string.Format(
                                "StorageAccountManager.UpdateUsed: Try {0} failed with DataServiceRequestException.",
                                tries));

                        // Refresh storage account info from the table,
                        // then re-increment and try updating again.
                        entry = _dataSource.GetStorageAccount(context, info.StorageAccountName);
                        oldValue = entry.Used;
                        entry.Used += info.UpdateUsedValue;
                        trace.AppendInfoLine(string.Format("StorageAccountManager.UpdateUsed: Old = {0}, New = {1}", oldValue,
                                   entry.Used));
                        continue;
                    }
                }
            }
            finally
            {
                trace.AppendInfoLine("StorageAccountManager.UpdateUsed: Exit");
            }
        }

        /// <summary>
        /// Background thread used to send batches of Used updates
        /// to table storage.
        /// </summary>
        public void UpdateUsedThreadProc(object o)
        {
            int updateUsedIntervalMs = (int)o;

            while(_updateUsed)
            {
                IXlfsTrace trace = _traceFactory.Create("UpdateUsedThreadProc");

                try
                {
                    // Sleep for a configured period of time between
                    // each iteration of queue processing. Add 10% jitter
                    // as well.
                    Random rng = new Random();
                    int sleepTime = updateUsedIntervalMs + rng.Next(-updateUsedIntervalMs/10, updateUsedIntervalMs/10);
                    trace.AppendInfoLine(string.Format(
                        "StorageAccountManager.UpdateUsedThreadProc: Sleeping for {0}ms.", sleepTime));
                    Thread.Sleep(sleepTime);

                    trace.AppendInfoLine("StorageAccountManager.UpdateUsedThreadProc: Waking up.");

                    //  Process the queue.
                    Dictionary<string, UpdateUsedInfo> updates = GetUsedUpdates(trace);

                    //  The queue has been emptied, now we can update the
                    //  storage accounts, one at a time.
                    foreach(UpdateUsedInfo info in updates.Values)
                    {
                        if(info.UpdateUsedValue == 0)
                        {
                            continue;
                        }

                        UpdateUsed(info, trace);
                    }
                }
                catch(ThreadAbortException)
                {
                    trace.AppendInfoLine("StorageAccountManager.UpdateUsedThreadProc:  Thread terminating.");
                    return;
                }
                catch(Exception e)
                {
                    trace.AppendErrorLine(string.Format("UpdateUsedThreadProc:  Unexpected exception:\r\n{0}", e));
                }
                finally
                {
                    trace.Flush();
                }
            }
        }

        #endregion

        /// <summary>
        /// Determines whether or not a StorageAccountTableEntry should
        /// be included in the list of accounts available for blob storage.
        /// </summary>
        /// <param name="entry"></param>
        /// <returns></returns>
        protected bool CheckAccountAvailable(StorageAccountTableEntry entry)
        {
            IXlfsTrace trace = _traceFactory.Create("StorageAccountManager");

            if(entry.Capacity < 0 || entry.Threshold < 0 || entry.Used < 0)
            {
                trace.WriteEvent(
                    string.Format(
                        "Storage Account {0} is misconfigured.  Negative numbers are not allowed for Capacity({1}), Threshold ({2}), or Used ({3}).  This storage account will not be used for blob storage until its configuration is corrected.",
                        entry.PartitionKey, entry.Capacity, entry.Threshold, entry.Used));
                return false;
            }

            if (entry.Capacity < entry.Threshold)
            {
                trace.WriteEvent(
                    string.Format(
                        "Storage Account {0} is misconfigured.  Threshold ({1}) must be less than or equal to Capacity ({2}).  This storage account will not be used for blob storage until its configuration is corrected.",
                        entry.PartitionKey, entry.Threshold, entry.Capacity));
                return false;
            }

            if (entry.Used >= entry.Capacity || entry.Used >= entry.Threshold)
            {
                return false;
            }

            try
            {
                // Make sure we can connect to the account.
                StorageCredentialsAccountAndKey credentials = new StorageCredentialsAccountAndKey(entry.PartitionKey,
                                                                                                  entry.Key);
                CloudStorageAccount account = new CloudStorageAccount(credentials, false);
                CloudBlobClient blobClient = account.CreateCloudBlobClient();
                CloudBlobContainer pingContainer = blobClient.GetContainerReference("pingcontainer");
                pingContainer.CreateIfNotExist();
                return true;
            }
            catch (Exception e)
            {
                // Something failed trying to use the configured account name and key.
                // Write an event and don't include this account in the list.
                trace.WriteEvent(
                    string.Format(
                        "Unable to connect to storage account {0} using the configured name and key.  This account will not be used to store blobs until this condition is corrected.  Exception:\r\n{1}",
                        entry.PartitionKey,
                        e));
                return false;
            }
        }

        private readonly object _refreshLock = new object();

        /// <summary>
        /// Periodically reload all storage account information from the source.
        /// This is necessary to pick up storage accounts that have been added.
        /// Existing storage accounts naturally get refreshed quite often.
        /// </summary>
        /// <param name="state"></param>
        public void Refresh(object state)
        {
            IXlfsTrace trace = _traceFactory.Create("StorageAccountManager");

            trace.AppendLine("StorageAccountManager.Refresh: Enter");

            // Don't allow multiple threads in Refresh.
            if(!Monitor.TryEnter(_refreshLock)) return;

            try
            {
                StorageAccountTableContext context = StorageAccountTableContext.GetContext(_cloudStorageAccount);
                List<StorageAccountTableEntry> newStorageAccounts =
                    _dataSource.GetAllStorageAccounts(context).ToList();
                List<StorageAccountTableEntry> newAvailableStorageAccounts = new List<StorageAccountTableEntry>();

                foreach(StorageAccountTableEntry entry in newStorageAccounts)
                {
                    bool available = CheckAccountAvailable(entry);

                    if(available)
                    {
                        newAvailableStorageAccounts.Add(entry);
                    }

                    trace.AppendLine(
                        string.Format(
                            "StorageAccountTableEntry name=\"{0}\" capacity=\"{1}\" threshold=\"{2}\" used=\"{3}\" available=\"{4}\"",
                            entry.PartitionKey, entry.Capacity, entry.Threshold, entry.Used, available));
                }

                int oldCount = _availableStorageAccounts == null ? 0 : _availableStorageAccounts.Count;
                _storageAccounts = newStorageAccounts;
                _availableStorageAccounts = newAvailableStorageAccounts;

                //  If the available list has shrunk, we need to make 
                //  sure to reset the index.
                if(_availableStorageAccounts.Count < oldCount)
                {
                    _storageAccountIndex = 0;
                }
            }
            catch (Exception e)
            {
                trace.AppendErrorLine(
                    string.Format(
                        "StorageAccountManager.Refresh: Exception thrown while refreshing storage account list.  Exception:\r\n{0}",
                        e));
            }
            finally
            {
                trace.AppendLine("StorageAccountManager.Refresh: Exit");
                trace.Flush();
                Monitor.Exit(_refreshLock);
            }
        }

        /// <summary>
        /// Lookup a specific storage account and return a
        /// CloudStorageAccount object representing it.
        /// </summary>
        /// <param name="storageAccountName"></param>
        /// <returns></returns>
        public CloudStorageAccount Lookup(string storageAccountName)
        {
            IXlfsTrace trace = _traceFactory.Create("StorageAccountManager");

            // Grab a local reference in case Refresh happens.
            List<StorageAccountTableEntry> storageAccounts = _storageAccounts;

            // Find the storage account we're looking for.
            CloudStorageAccount storageAccount = (from entry in storageAccounts
                    where entry.PartitionKey == storageAccountName
                    select new StorageCredentialsAccountAndKey(entry.PartitionKey, entry.Key)
                    into accountAndKey
                    select new CloudStorageAccount(accountAndKey, true)).FirstOrDefault();
            
            if(storageAccount == null)
            {
                var storageAccountList = new StringBuilder();
                foreach(var entry in storageAccounts)
                {
                    storageAccountList.AppendLine(entry.PartitionKey);
                }

                trace.WriteEvent(
                    string.Format(
                        "StorageAccountManager.Lookup: Storage account {0} not found in the storage account list:\r\n{1}",
                        storageAccountName,
                        storageAccountList));
            }

            return storageAccount;
        }

        /// <summary>
        /// Return the next storage account in the collection.
        /// </summary>
        /// <param name="trace"></param>
        /// <returns></returns>
        public CloudStorageAccount GetNextStorageAccount(IXlfsTrace trace)
        {
            trace.AppendInfoLine("StorageAccountManager.GetNextStorageAccount: Enter");

            try
            {
                if(AvailableStorageAccounts == null)
                {
                    trace.AppendErrorLine("StorageAccountManager.GetNextStorageAccount: The list of storage accounts is empty.  Look for previous log lines generated by StorageAccountManager.Refresh that might indicate why.");
                    return null;
                }

                // Use a local reference to the list, in case Refresh is called
                // while we're in here.  It doesn't matter if we're using an old copy
                // of the list, but it might be bad if the list changed out from underneath
                // us while we're figuring out which one to return.

                List<StorageAccountTableEntry> availableStorageAccounts = _availableStorageAccounts;
                
                if (availableStorageAccounts.Count == 0)
                {
                    trace.WriteEvent(
                        "StorageAccountManager.GetNextStorageAccount: No storage accounts found with available space below Threshold!  More storage accounts are needed.");
                    return null;
                }

                int storageAccountToReturn = Interlocked.Exchange(ref _storageAccountIndex,
                                                                  (_storageAccountIndex + 1) %
                                                                  availableStorageAccounts.Count);
                storageAccountToReturn %= availableStorageAccounts.Count; // The size of the list can shrink at any time

                StorageAccountTableEntry entry = availableStorageAccounts[storageAccountToReturn];

                // Create and return a CloudStorageAccount for the selected storage account.
                StorageCredentialsAccountAndKey accountAndKey =
                    new StorageCredentialsAccountAndKey(entry.PartitionKey,
                                                        entry.Key);
                var storageAccount = new CloudStorageAccount(accountAndKey, true);

                trace.AppendInfoLine(
                    string.Format("StorageAccountManager.GetNextStorageAccount: Selected storage account Name = \"{0}\" Account name = {1}.",
                                  entry.PartitionKey,
                                  storageAccount.Credentials.AccountName ?? "<null>"));

                return storageAccount;
            }
            catch (Exception e)
            {
                trace.AppendErrorLine(
                    string.Format("StorageAccountManager.GetNextStorageAccount: Unexpected exception:\r\n{0}", e));
                return null;
            }
            finally
            {
                trace.AppendInfoLine("StorageAccountManager.GetNextStorageAccount: Exit");
            }
        }

        /// <summary>
        /// Updates the amount of storage used in the specified storage account
        /// by the specified amount.
        /// </summary>
        /// <param name="storageAccountName"></param>
        /// <param name="value"></param>
        /// <param name="trace"></param>
        public void UpdateUsed(string storageAccountName, long value, IXlfsTrace trace)
        {
            trace.AppendInfoLine(string.Format("StorageAccountManger.UpdateUsed(\"{0}\", {1})", storageAccountName,
                                               value));

            try
            {
                lock(_updateUsedQueue)
                {
                    _updateUsedQueue.Enqueue(new UpdateUsedInfo(storageAccountName, value));
                }
            }
            finally
            {
                trace.AppendInfoLine("StorageAccountManager.UpdateUsed: Exit");
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\StorageAccountTableContext.cs ===
using System;
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class StorageAccountTableContext : TableServiceContext
    {
        public static StorageAccountTableContext GetContext(CloudStorageAccount cloudStorageAccount)
        {
            StorageAccountTableContext context = new StorageAccountTableContext(
                cloudStorageAccount.TableEndpoint.AbsoluteUri,
                cloudStorageAccount.Credentials);

            context.RetryPolicy = RetryPolicies.Retry(3, TimeSpan.FromSeconds(1));
            context.MergeOption = System.Data.Services.Client.MergeOption.OverwriteChanges;

            return context;
        }
        
        public StorageAccountTableContext(string baseAddress, StorageCredentials credentials)
            : base(baseAddress, credentials)
        {
        }

        public IQueryable<StorageAccountTableEntry> StorageAccountTableEntry
        {
            get
            {
                return CreateQuery<StorageAccountTableEntry>("StorageAccountTableEntry");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\XlfsGcMessage.cs ===
using System;
using System.Xml;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class XlfsGcMessage
    {
        public static XlfsGcMessage Create(CloudQueueMessage msg)
        {
            return new XlfsGcMessage(msg);
        }

        private XlfsGcMessage()
        {
            throw new ApplicationException("Invalid use of private default constructor of XlfsGcMessage!");
        }

        private XlfsGcMessage(CloudQueueMessage msg)
        {
            if(msg == null)
            {
                throw new ArgumentException("Parameter cannot be null.", "msg");
            }
            _message = msg;

            if(string.IsNullOrEmpty(msg.AsString))
            {
                throw new ArgumentException("Message does not contain a body.", "msg");
            }

            _xml = new XmlDocument();
            _xml.LoadXml(msg.AsString);

            if(Xml.DocumentElement == null)
            {
                throw new ArgumentException("Message body XML did not contain a root element.", "msg");
            }

            _name = Xml.DocumentElement.Name;
        }

        private readonly CloudQueueMessage _message;
        public CloudQueueMessage Message { get { return _message; } }

        private readonly XmlDocument _xml;
        public XmlDocument Xml { get { return _xml; } }

        private readonly string _name;
        public string Name { get { return _name; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\XlfsConstants.cs ===
namespace xonline.server.xlfs.common
{
    public class XlfsConstants
    {
        #region String Constants

        public const string BlobPathFormatString = "{0}/{1}.{2}";

        #region GC Queue-related constants
        
        public const string GcQueueName = "gcqueue";

        // AgeOutGc
        public const string AgeOutGcFormat = "<AgeOutGc partition=\"{0}\" />";
        public const string AgeOutGcMessage = "AgeOutGc";

        // AgeOutGcCommence
        public const string AgeOutGcCommenceFormat = "<AgeOutGcCommence nextStart=\"{0}\" startPartition=\"{1}\" />";
        public const string AgeOutGcCommenceMessage = "AgeOutGcCommence";

        // private const string OrphanedFileGcFormat = "<OrphanedFileGC storageAccount=\"{0}\" container=\"{1}\" continuation=\"{2}\" />";
        // private const string PendingDeleteGcCommence = "<PendingDeleteGcCommence nextStart=\"{0}\" />";
        // private const string PendingDeleteGc = "<PendingDeleteGc partition=\"{0}\" />";
        // private const string DiagnosticsGcCommence = "<DiagnosticsGcCommence table=\"{0}\" nextStart=\"{1}\" />";
        // private const string DiagnosticsGc = "<DiagnosticsGc table=\"{0}\" partition=\"{1}\" />";

        #endregion


        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\RoleEntryPointExtensions.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.ServiceRuntime;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public static class RoleEntryPointExtensions
    {
        private static readonly XlfsTrace EventTrace = new XlfsTrace("WebRole");
        
        public static bool VerifyConnectionString(this RoleEntryPoint roleEntryPoint, string connectionSettingName)
        {
            //
            //  Need to call this before calling CloudStorageAccount.FromConfigurationSetting, which
            //  VerifyConnectionString does.  Otherwise we get InvalidOperationExceptions.
            //

            CloudStorageAccount.SetConfigurationSettingPublisher(
                (configName, configSetter) => configSetter(RoleEnvironment.GetConfigurationSettingValue(configName)));

            try
            {
                string connectionString;

                EventTrace.AppendInfoLine(string.Format("WebRole.VerifyConnectionString: Verifying {0}.",
                                                       connectionSettingName));

                try
                {
                    connectionString =
                        RoleEnvironment.GetConfigurationSettingValue(connectionSettingName);

                    EventTrace.AppendInfoLine(string.Format("WebRole.VerifyConnectionString: Setting {0} = {1}.",
                                                           connectionSettingName, connectionString));
                }
                catch (Exception e)
                {
                    EventTrace.WriteEvent(
                        string.Format(
                            "\"{0}\" setting could not be retrieved.  Make sure that this setting is properly set in ServiceConfiguration.cscfg and redeploy the service.  Exception:\r\n{1}",
                            connectionSettingName, e));
                    return false;
                }

                CloudStorageAccount storageAccount;
                try
                {
                    storageAccount = CloudStorageAccount.FromConfigurationSetting(connectionSettingName);
                    if (storageAccount == null)
                    {
                        EventTrace.WriteEvent(
                            string.Format(
                                "Failed to create storage account from setting {0} using connection string {1}.",
                                connectionSettingName, connectionString));
                        return false;
                    }

                    EventTrace.AppendInfoLine(string.Format("WebRole.VerifyConnectionString:  Created storage account for {0}.", connectionSettingName));
                }
                catch (Exception e)
                {
                    EventTrace.WriteEvent(
                        string.Format("Failed to create storage account from setting {0}.  Exception:\r\n{1}",
                                      connectionSettingName, e));
                    return false;
                }

                try
                {
                    CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
                    CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

                    StringBuilder listString = new StringBuilder();

                    IEnumerable<CloudBlobContainer> containerList = blobClient.ListContainers();
                    foreach(CloudBlobContainer container in containerList)
                    {
                        listString.Append(container.Name);
                    }

                    listString = new StringBuilder();
                    IEnumerable<string> tableList = tableClient.ListTables();
                    foreach(string tableName in tableList)
                    {
                        listString.Append(tableName);
                    }

                    EventTrace.AppendInfoLine(string.Format("WebRole.VerifyConnectionString:  Connection {0} verified.", connectionSettingName));
                }
                catch (Exception e)
                {
                    EventTrace.WriteEvent(
                        string.Format("Blob operation against storage account {0} failed.  Exception:\r\n{1}",
                                      connectionSettingName, e));
                    return false;
                }

                return true;
            }
            finally
            {
                EventTrace.AppendInfoLine("WebRole.VerifyConnectionString: Exit.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\StorageAccountTableEntry.cs ===
using System;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class StorageAccountTableEntry : TableServiceEntity, IEquatable<StorageAccountTableEntry>
    {
        // Partition Key is Storage Account Name.
        // RowKey is not used, and left empty.
        public string Key { get; set; }
        public long Capacity { get; set; }
        public long Threshold { get; set; }
        public long Used { get; set; }

        public bool Equals(StorageAccountTableEntry other)
        {
            return PartitionKey == other.PartitionKey && RowKey == other.RowKey;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\StorageAccountTableDataSource.cs ===
using System;
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    public class StorageAccountTableDataSource
    {
        private readonly CloudStorageAccount _storageAccount;

        public StorageAccountTableDataSource(CloudStorageAccount cloudStorageAccount)
        {
            _storageAccount = cloudStorageAccount;

            CloudTableClient.CreateTablesFromModel(
                typeof(StorageAccountTableContext), 
                _storageAccount.TableEndpoint.AbsoluteUri,
                _storageAccount.Credentials);
        }

        public IQueryable<StorageAccountTableEntry> GetAllStorageAccounts(StorageAccountTableContext context)
        {
            var results = (from p in context.StorageAccountTableEntry select p).AsTableServiceQuery();

            return results;
        }

        public StorageAccountTableEntry GetStorageAccount(StorageAccountTableContext context, string storageAccountName)
        {
            var results =
                (from p in context.StorageAccountTableEntry where p.PartitionKey == storageAccountName select p).
                    AsTableServiceQuery();

            StorageAccountTableEntry entry;

            try
            {
                entry = results.First();
            }
            catch
            {
                entry = null;
            }

            return entry;
        }

        public void AddStorageAccountTableEntry(StorageAccountTableContext context, StorageAccountTableEntry entry)
        {
            if(!string.IsNullOrEmpty(entry.RowKey))
            {
                throw new InvalidOperationException("The RowKey member for StorageAccountTableEntry objects must be empty.");
            }

            context.AddObject("StorageAccountTableEntry", entry);
            context.SaveChanges();
        }

        public void UpdateStorageAccountTableEntry(StorageAccountTableContext context, StorageAccountTableEntry entry)
        {
            context.UpdateObject(entry);
            context.SaveChanges();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\XlfsGcMessageHandlerAttribute.cs ===
using System;

namespace xonline.server.xlfs.common
{
    [AttributeUsage(AttributeTargets.Class)]
    public class XlfsGcMessageHandlerAttribute : Attribute
    {
        public String Message { get; private set; }

        /// <summary>
        /// Message handler constructor.
        /// </summary>
        /// <param name="message"></param>
        public XlfsGcMessageHandlerAttribute(string message)
        {
            if (string.IsNullOrEmpty(message))
            {
                throw new ArgumentException("Null or empty message is not allowed.", "message");
            }

            Message = message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\XlfsPerformanceCounterLib.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Globalization;
using System.ComponentModel;
using Microsoft.Win32;

// This class is basically a copy of the internal PerformanceCounterLib class. Red Gate's 
// .NET Reflector was used to extract this code. There is a significant performance issue 
// with PerformanceCounterCategory.Create() in that it takes around 2 seconds per 
// category. The code below takes about 400ms per category.  
//
// The call to PerformanceCounterLib.CategoryExists() requires a cache to be built of all 
// performance counters in the system. This is what takes a while. 
//
// However, at the end of PerformanceCounterLib.RegisterCategory(), that cache is 
// destroyed. This presumably happens because you just added a new category, and rather 
// than add it to the existing cache, the developer decided to throw away the cache and 
// let it get rebuilt on the next call to CategoryExists().  
//
// This is what our code bypasses.
//
// The other major differences are:
// * We don't do any security checks
// * We don't check that this is an NT environment
// * We don't grab the global mutex "netfxperf.1.0"
// * And of course, we don't throw away the cache
//
// All we really do is add a few registry entries, build a temporary perf .h file and .ini 
// file, then launch lodctr.exe to import those. This is, believe it or not, what .Net 
// does under the hood. These are well-defined, well-documented files, and in fact this 
// process is exactly what you would have to do for native perf counters. Except you'd 
// have to do it by hand. 
//
// --kgoodier and paulram, July, 2009.

namespace xonline.server.xlfs.common
{

    public static class XlfsPerformanceCounterLib
    {
        
        private static bool IsBaseCounter(PerformanceCounterType type)
        {
            if (((type != PerformanceCounterType.AverageBase) &&
              (type != PerformanceCounterType.CounterMultiBase)) &&
              (((int)type != 0x40030403) &&
              (type != PerformanceCounterType.SampleBase)))
            {
                return (type == PerformanceCounterType.SampleBase);
            }
            return true;
        }

        private static void CheckValidCounterLayout(CounterCreationDataCollection counterData)
        {
            Dictionary<String, Object> hashtable = new Dictionary<String, Object>();

            for (int i = 0; i < counterData.Count; i++)
            {
                if ((counterData[i].CounterName == null) || (counterData[i].CounterName.Length == 0))
                {
                    throw new ArgumentException("InvalidCounterName");
                }
                PerformanceCounterType counterType = (PerformanceCounterType)counterData[i].CounterType;
                switch (counterType)
                {
                    case PerformanceCounterType.AverageCount64:
                    case PerformanceCounterType.CounterMultiTimer100Ns:
                    case PerformanceCounterType.CounterMultiTimer100NsInverse:
                    case PerformanceCounterType.CounterMultiTimer:
                    case PerformanceCounterType.CounterMultiTimerInverse:
                    case PerformanceCounterType.RawFraction:
                    case PerformanceCounterType.SampleFraction:
                    case PerformanceCounterType.AverageTimer32:
                        if (counterData.Count <= (i + 1))
                        {
                            throw new InvalidOperationException("CounterLayout");
                        }
                        if (!IsBaseCounter(counterData[i + 1].CounterType))
                        {
                            throw new InvalidOperationException("CounterLayout");
                        }
                        break;

                    default:
                        if (IsBaseCounter(counterType))
                        {
                            if (i == 0)
                            {
                                throw new InvalidOperationException("CounterLayout");
                            }
                            counterType = counterData[i - 1].CounterType;
                            if (((
                                (counterType != PerformanceCounterType.AverageCount64) &&
                                (counterType != PerformanceCounterType.CounterMultiTimer100Ns)) &&
                                ((counterType != PerformanceCounterType.CounterMultiTimer100NsInverse) &&
                                (counterType != PerformanceCounterType.CounterMultiTimer))) &&
                                (((counterType != PerformanceCounterType.CounterMultiTimerInverse) &&
                                (counterType != PerformanceCounterType.RawFraction)) &&
                                ((counterType != PerformanceCounterType.SampleFraction) &&
                                (counterType != PerformanceCounterType.AverageTimer32))))
                            {
                                throw new InvalidOperationException("CounterLayout");
                            }
                        }
                        break;
                }
                if (hashtable.ContainsKey(counterData[i].CounterName))
                {
                    throw new ArgumentException(String.Format("DuplicateCounterName: {0}", counterData[i].CounterName));
                }
                hashtable.Add(counterData[i].CounterName, string.Empty);
                if ((counterData[i].CounterHelp == null) || (counterData[i].CounterHelp.Length == 0))
                {
                    counterData[i].CounterHelp = counterData[i].CounterName;
                }
            }
        }

        private static void CreateRegistryEntry(string categoryName, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection creationData, ref bool iniRegistered)
        {
            RegistryKey key = null;
            RegistryKey key2 = null;
            RegistryKey key3 = null;

            try
            {
                key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Services", true);
                key2 = key.OpenSubKey(categoryName + @"\Performance", true);
                if (key2 == null)
                {
                    key2 = key.CreateSubKey(categoryName + @"\Performance");
                }
                key2.SetValue("Open", "OpenPerformanceData");
                key2.SetValue("Collect", "CollectPerformanceData");
                key2.SetValue("Close", "ClosePerformanceData");
                key2.SetValue("Library", "netfxperf.dll");
                key2.SetValue("IsMultiInstance", (int)categoryType, RegistryValueKind.DWord);
                key2.SetValue("CategoryOptions", 3, RegistryValueKind.DWord);
                string[] strArray = new string[creationData.Count];
                string[] strArray2 = new string[creationData.Count];
                for (int i = 0; i < creationData.Count; i++)
                {
                    strArray[i] = creationData[i].CounterName;
                    strArray2[i] = ((int)creationData[i].CounterType).ToString(CultureInfo.InvariantCulture);
                }
                key3 = key.OpenSubKey(categoryName + @"\Linkage", true);
                if (key3 == null)
                {
                    key3 = key.CreateSubKey(categoryName + @"\Linkage");
                }
                key3.SetValue("Export", new string[] { categoryName });
                key2.SetValue("Counter Types", strArray2);
                key2.SetValue("Counter Names", strArray);
                if (key2.GetValue("First Counter") != null)
                {
                    iniRegistered = true;
                }
                else
                {
                    iniRegistered = false;
                }
            }
            finally
            {
                if (key2 != null)
                {
                    key2.Close();
                }
                if (key3 != null)
                {
                    key3.Close();
                }
                if (key != null)
                {
                    key.Close();
                }
            }
        }

        private static void CreateIniFile(string IniFilePath, string SymbolFilePath, string categoryName, string categoryHelp, CounterCreationDataCollection creationData, string[] languageIds)
        {
            StreamWriter writer = new StreamWriter(IniFilePath, false, Encoding.Unicode);
            try
            {
                writer.WriteLine("");
                writer.WriteLine("[info]");
                writer.Write("drivername");
                writer.Write("=");
                writer.WriteLine(categoryName);
                writer.Write("symbolfile");
                writer.Write("=");
                writer.WriteLine(Path.GetFileName(SymbolFilePath));
                writer.WriteLine("");
                writer.WriteLine("[languages]");
                foreach (string str in languageIds)
                {
                    writer.Write(str);
                    writer.Write("=");
                    writer.Write("language");
                    writer.WriteLine(str);
                }
                writer.WriteLine("");
                writer.WriteLine("[objects]");
                foreach (string str2 in languageIds)
                {
                    writer.Write("OBJECT_");
                    writer.Write("1_");
                    writer.Write(str2);
                    writer.Write("_NAME");
                    writer.Write("=");
                    writer.WriteLine(categoryName);
                }
                writer.WriteLine("");
                writer.WriteLine("[text]");
                foreach (string str3 in languageIds)
                {
                    writer.Write("OBJECT_");
                    writer.Write("1_");
                    writer.Write(str3);
                    writer.Write("_NAME");
                    writer.Write("=");
                    writer.WriteLine(categoryName);
                    writer.Write("OBJECT_");
                    writer.Write("1_");
                    writer.Write(str3);
                    writer.Write("_HELP");
                    writer.Write("=");
                    if ((categoryHelp == null) || (categoryHelp == string.Empty))
                    {
                        writer.WriteLine("HelpNotAvailable");
                    }
                    else
                    {
                        writer.WriteLine(categoryHelp);
                    }
                    int num = 0;
                    foreach (CounterCreationData data in creationData)
                    {
                        num++;
                        writer.WriteLine("");
                        writer.Write("DEVICE_COUNTER_");
                        writer.Write(num.ToString(CultureInfo.InvariantCulture));
                        writer.Write("_");
                        writer.Write(str3);
                        writer.Write("_NAME");
                        writer.Write("=");
                        writer.WriteLine(data.CounterName);
                        writer.Write("DEVICE_COUNTER_");
                        writer.Write(num.ToString(CultureInfo.InvariantCulture));
                        writer.Write("_");
                        writer.Write(str3);
                        writer.Write("_HELP");
                        writer.Write("=");
                        writer.WriteLine(data.CounterHelp);
                    }
                }
                writer.WriteLine("");
            }
            finally
            {
                writer.Close();
            }
        }

        private static void CreateSymbolFile(String SymbolFilePath, CounterCreationDataCollection creationData)
        {
            StreamWriter writer = new StreamWriter(SymbolFilePath);
            try
            {
                writer.Write("#define");
                writer.Write(" ");
                writer.Write("OBJECT_");
                writer.WriteLine("1 0;");
                for (int i = 1; i <= creationData.Count; i++)
                {
                    writer.Write("#define");
                    writer.Write(" ");
                    writer.Write("DEVICE_COUNTER_");
                    writer.Write(i.ToString(CultureInfo.InvariantCulture));
                    writer.Write(" ");
                    writer.Write((i * 2).ToString(CultureInfo.InvariantCulture));
                    writer.WriteLine(";");
                }
                writer.WriteLine("");
            }
            finally
            {
                writer.Close();
            }
        }

        private static string[] GetLanguageIds()
        {
            RegistryKey key = null;
            string[] subKeyNames = new string[0];

            try
            {
                key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib");
                if (key != null)
                {
                    subKeyNames = key.GetSubKeyNames();
                }
            }
            finally
            {
                if (key != null)
                {
                    key.Close();
                }
            }
            return subKeyNames;
        }

        private static void RegisterFiles(string arg0, bool unregister)
        {
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.UseShellExecute = false;
            startInfo.CreateNoWindow = true;
            startInfo.ErrorDialog = false;
            startInfo.WindowStyle = ProcessWindowStyle.Hidden;
            startInfo.WorkingDirectory = Environment.SystemDirectory;
            if (unregister)
            {
                startInfo.FileName = Environment.SystemDirectory + @"\unlodctr.exe";
            }
            else
            {
                startInfo.FileName = Environment.SystemDirectory + @"\lodctr.exe";
            }
            int error = 0;

            startInfo.Arguments = "\"" + arg0 + "\"";
            Process process = Process.Start(startInfo);
            process.WaitForExit();
            error = process.ExitCode;


            if (unregister && (error == 2))
            {
                error = 0;
            }
            if (error != 0)
            {
                throw new Win32Exception(error);
            }
        }

        public static void CreateCategory(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection creationData)
        {
            String tempFileName = Guid.NewGuid().ToString();
            String iniFilePath = Path.Combine(Path.GetTempPath(), tempFileName + ".ini");
            String symbolFilePath = Path.Combine(Path.GetTempPath(), tempFileName + ".h");

            CheckValidCounterLayout(creationData);
            try
            {
                bool iniRegistered = false;
                CreateRegistryEntry(categoryName, categoryType, creationData, ref iniRegistered);
                if (!iniRegistered)
                {
                    string[] languageIds = GetLanguageIds();
                    CreateIniFile(iniFilePath, symbolFilePath, categoryName, categoryHelp, creationData, languageIds);
                    CreateSymbolFile(symbolFilePath, creationData);
                    RegisterFiles(iniFilePath, false);
                }
            }
            finally
            {
                File.Delete(iniFilePath);
                File.Delete(symbolFilePath);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\xlfsperfctrsinstall.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using System.Text;
using System.Security.Cryptography;

namespace xonline.server.xlfs.common
{
    using CounterCategoryDictionary = Dictionary<string, XlfsPerformanceCounterAttr>;

    [ComVisible(false)]
    public class XlfsPerformanceCounterInstall
    {
        private const string XboxLiveRegistryKey = @"SOFTWARE\Microsoft\XboxLive";
        private const string CounterHashRegistryKeyName = "PerfCountersInstalled";
        private const string CounterHashRegistryKey = XboxLiveRegistryKey + @"\" + CounterHashRegistryKeyName;

        // Verifies that the type meets the inheritence and attribute requirements
        // of a XlfsPerformanceCounterCategory

        public static bool IsValidPerformanceCounterCategory(Type t) {
            return 
                t.IsSubclassOf(typeof(XlfsPerformanceCounterCategory)) &&
                t != typeof(XlfsPerformanceCounterCategory) &&
                Attribute.IsDefined(t, typeof(XlfsPerformanceCounterCategoryAttr));
        }

        // Retrieves the performance counter category attribute from the type.
        // It is assumed that the type is a valid performance counter category
        // type.

        public static XlfsPerformanceCounterCategoryAttr GetCategoryAttribute(Type t) {
            return t.GetCustomAttributes(typeof(XlfsPerformanceCounterCategoryAttr), false)[0] 
               as XlfsPerformanceCounterCategoryAttr;
        }
        
        // Called by the installer on install. Builds the counters for all the
        // classes in the local assembly.
    
        public void Install(Type type)
        {
            // Log an event to setup the EventSource for this component. We do this at 
            //  install time since some of the users executing FD code may not have
            //  appropriate permissions to create EventSources. 
            // We don't want to init proper logging here because that is way too 
            //  heavyweight requiring communication with configdb, etc.

            //EventLog.WriteEntry(
            //    xonline.common.config.Config.ComponentName,
            //    "Beginning Install of perfctrs for " + xonline.common.config.Config.ComponentName,
            //    EventLogEntryType.Information,
            //    (int)XEvent.MessageFromId(XEvent.Id.COMMON_INFO_47),
            //    0,
            //    null);

            LogMessage("Beginning Install of perfctrs for " + CounterRegistryName);
    
            // Enumerate through all the XlfsPerformanceCounterCategory derived 
            // classes in the local assembly (except for XlfsPerformanceCounterCategory
            // itself.

            Type[] allTypes = Assembly.GetAssembly(type).GetTypes();

            // Go through all counters and get a hash of the list
            string countersHash = GetHashOnCounters(allTypes);

            // Check if counters hash exists in registry, if it is, we can skip the counters creation
            if (CheckCounterHashExistsInRegistry(countersHash))
            {
                LogMessage("Skipping counter installation, found matching counter hash token in registry for " + CounterRegistryName);
            }
            else
            {                
                foreach( Type t in allTypes )
                {
                    if(IsValidPerformanceCounterCategory(t)) 
                        InstallCategory(t);
                }

                // Drop counters hash token in registry after a successful install of counters.
                WriteCounterHashToRegistry(countersHash);
            }
        }
        
        // Called by the installer on uninstall. Removes all counters associated
        // to the classes of the local assembly.
    
        public void Uninstall(Type type)
        {
            UninstallAllCategories(type); 
        }

        // Called by the installer when this, or another, Install() fails. Try to remove 
        // all perf counters in this assembly.

        //public void Rollback()
        //{
        //    // Try to delete everything, even if we didn't actually install it. We could 
        //    // store this info in savedState, but this is quick and simple.
        //    UninstallAllCategories(); 
        //}
    
        // Uninstall as many catgories as possible

        protected void UninstallAllCategories(Type type)
        {
            // To be safe, remove the registry key hash before attempting to uninstall
            DeleteCounterHashFromRegistry();

            // Enumerate through all the XlfsPerformanceCounterCategory derived classes in 
            // the local assembly (except for XlfsPerformanceCounterCategory
            // itself.                       

            Type[] allTypes = Assembly.GetAssembly(type).GetTypes();

            int numFail = 0;
            int numTotal = 0;
            Exception lastException = null;
            foreach( Type t in allTypes )
            {
                if(IsValidPerformanceCounterCategory(t))
                {
                    try
                    {
                        numTotal++;
                        UninstallCategory(t);
                    }
                    catch (Exception e)
                    {
                        lastException = e;
                        numFail++;
                    }
                }
            }

            if (numFail > 0)
            {
                throw new Exception("Failed to uninstall " + numFail + " performance counter categories out of " + numTotal, lastException);
            }
        }

        // Uninstall logic used by the InstallCategory and UninstallCategory methods
        
        protected void UninstallCategoryHelper(XlfsPerformanceCounterCategoryAttr attr) {
            try {
                PerformanceCounterCategory.Delete(attr.CtgName);
                LogMessage("\t\tsuccessfully removed category.");
            }
            catch (InvalidOperationException e) { // category does not exist
                LogMessage("\t\tsuccessfully removed category. [" + e.Message + "]");
            }
            catch (Exception e) {
                LogMessage("\t\tfailed to remove category\n" + e);
                throw;
            }
        }

        // Given a category name, this function will return the performance counter category
        // associated with it, if that category does not exist null will be returned instead.

        protected PerformanceCounterCategory GetCategoryOrNull(string category) {
            try
            {
                PerformanceCounterCategory pcc = new PerformanceCounterCategory(category);
                pcc.ReadCategory(); //will raise exception if the category does not exist.

                return pcc;
            }
            catch (InvalidOperationException) { // category does not exist
                LogMessage("\t\tcategory is not present");
                return null;
            }
            catch (Exception e) {
                LogMessage("\t\tfailed to load category : " + e);
                throw;
            }
        }
        
        // Uninstall the performance counter category from the system.  In the interest
        // of performance it will be assumed that the performance counters exist.
        
        protected void UninstallCategory(Type categoryType) {
            Stopwatch w = new Stopwatch();

            w.Start();
            XlfsPerformanceCounterCategoryAttr attr = GetCategoryAttribute(categoryType);

            LogMessage("\tUninstall Counter Category Type - " + categoryType.Name);
            LogMessage("\t\tCategory = " + attr.CtgName);
            LogMessage("\t\tHelp     = " + attr.CtgHelp);
            LogMessage("\t\tShared   = " + attr.IsShared);

            if (!attr.IsShared)
                UninstallCategoryHelper(attr);
            else
                LogMessage("\t\tskipping removal of shared category.");

            w.Stop();
            
            LogMessage("\t\toperation completed in " + w.ElapsedMilliseconds + " ms.");
        }

        
        
        // Install the performance counter category to the system.  It is assumed that
        // the performance counters are already installed.  If that is false, or the
        // existing performance counters are wrong they will be re-installed.

        protected void InstallCategory(Type categoryType) {
            Stopwatch                         w = new Stopwatch();

            w.Start();
            
            XlfsPerformanceCounterCategoryAttr attr = GetCategoryAttribute(categoryType);
            
            LogMessage("\t Installing Counter Category Type - " + categoryType.Name);
            LogMessage("\t\tCategory = " + attr.CtgName);
            LogMessage("\t\tHelp     = " + attr.CtgHelp);
            LogMessage("\t\tShared   = " + attr.IsShared);
            
            CounterCreationDataCollection creation;
            CounterCategoryDictionary newCounterSet;

            //Load New Counters for the category 
            LogMessage("\t\tReflecting counter configuration");
            LoadCountersInCategory(categoryType, out creation, out newCounterSet);

            LogMessage("\t\tFetch existing counter group");
            PerformanceCounterCategory category = GetCategoryOrNull(attr.CtgName);
            LogMessage("\t\tDone");

            if (null != category) { // compare the existing
                if (IsCategoryRemovalRequired(category, newCounterSet)) {
                    category = null;
                    LogMessage("\t\tRemoving the group");
                    UninstallCategoryHelper(attr);
                }
            }

            if (null == category) { // create new categories
                try {
                    // perf ctr lib may falsely report that the category is not present
                    PerformanceCounterCategory.Delete(attr.CtgName);                    
                }
                catch (InvalidOperationException) { /* the category really isn't present */ }
                catch (Exception e) {
                    LogMessage("\t\twarning: error encountered deleting category, continuing : " + e);
                }

                try {
                    LogMessage("\t\tCreating category");
                    XlfsPerformanceCounterLib.CreateCategory(
                        attr.CtgName,
                        attr.CtgHelp,
                        PerformanceCounterCategoryType.MultiInstance,
                        creation);

                    LogMessage("\t\tsuccessfully created category.");
                }
                catch (Exception e) { // failed to create category
                    LogMessage("\t\tfailed to created category : " + e);
                    throw;
                }
            }

            // Verify perf category and counters. Throws exception if not valid.

            LogMessage("\t\tVerifying all counters in category");
            try
            {
                VerifyCategory(categoryType);
            }
            catch (Exception e) 
            {
                LogMessage("\t\tError: Failed to verify performance counters in " + attr.CtgName);
                LogMessage("\t\t" + e);
                throw;
            }

            w.Stop();
            LogMessage("\t\toperation completed in " + w.ElapsedMilliseconds + " ms.");


        }

        // Uses .Net libraries to open up each counter in the category. Should ensure 
        // everything exists.

        protected void VerifyCategory(Type categoryType)
        {
            if (!IsValidPerformanceCounterCategory(categoryType)) 
            {
                LogMessage("\t\tNot a valid XlfsPerformanceCounterCategory type: " + categoryType);
                throw new InvalidOperationException("Not a valid category type");
            }

            XlfsPerformanceCounterCategory o = (XlfsPerformanceCounterCategory)Activator.CreateInstance(categoryType);

            // The XlfsPerformanceCounterCategory constructor initializes perf 
            // counters, which reads a value for each one. No exceptions == good to go

        }

        // Examines the old and new counter set for a specific category and reports
        // the differences between them

        protected void CalculateCategoryDifferences(
            PerformanceCounterCategory category,
            Dictionary<string, XlfsPerformanceCounterAttr> newCounters,
            List<string> missingSet /* counters in new set but not old set */,
            List<string> differenceSet /* counters in both sets but are different */,
            List<string> extraSet /* counters in old set but not new set */)
        {
            string[] instances = category.GetInstanceNames();

            PerformanceCounter[] counters = (instances.Length > 0)
                                                ? category.GetCounters(instances[0])
                                                : //get the name instanced
                                            category.GetCounters();

            List<string> allCounters = new List<string>(newCounters.Keys);

            foreach (PerformanceCounter t in counters)
            {
                string name = t.CounterName;
                
                if (!newCounters.ContainsKey(name))
                {
                    extraSet.Add(name);
                }
                else 
                {
                    XlfsPerformanceCounterAttr oldAttr = new XlfsPerformanceCounterAttr(name, t.CounterHelp,
                                                                                        t.CounterType);
                    XlfsPerformanceCounterAttr newAttr = newCounters[name];
                    
                    if (! newAttr.Equals(oldAttr) )
                        differenceSet.Add(name);
                    else
                        allCounters.Remove(name);
                }
            }

            missingSet.AddRange(allCounters);
        }
        
        // This function indicates whether not the perf counter installer should uninstall
        // an existing category.
        
        protected bool IsCategoryRemovalRequired(
            PerformanceCounterCategory category,
            Dictionary<string, XlfsPerformanceCounterAttr> newCounterSet)
        {
            List<string> missingSet = new List<string>();
            List<string> differenceSet = new List<string>();
            List<string> extraSet = new List<string>();

            CalculateCategoryDifferences(category, newCounterSet, missingSet, differenceSet, extraSet);
            
            if (missingSet.Count == 0 && differenceSet.Count == 0 && extraSet.Count == 0) 
            {
               LogMessage("\t\tcategory matches existing definition, no removal neccessary.");
               return false;
            }

            LogMessage("\t\tcategory does not match existing definition.");

            if (missingSet.Count > 0) 
            {
                LogMessage("\t\told category definition missing the following counters:");
                LogMessage("\t\t\t" + string.Join("\n\t\t\t", missingSet.ToArray()));
            }

            if (differenceSet.Count > 0) 
            {
                LogMessage("\t\told and new category defintion differ for the following counters:");
                LogMessage("\t\t\t" + string.Join("\n\t\t\t", differenceSet.ToArray()));
            }

            if (extraSet.Count > 0) 
            {
                LogMessage("\t\tnew category definition missing the following counters:");
                LogMessage("\t\t\t" + string.Join("\n\t\t\t", differenceSet.ToArray()));
            }

            return true;
        }

        protected int LoadCountersInCategory(Type categoryType, out CounterCreationDataCollection counterCollection, out Dictionary<string, XlfsPerformanceCounterAttr> newCounterSet)
        {
            return LoadCountersInCategory(categoryType, out counterCollection, out newCounterSet, true);
        }

        protected int LoadCountersInCategory(Type categoryType, out CounterCreationDataCollection counterCollection, out Dictionary<string, XlfsPerformanceCounterAttr> newCounterSet, bool logMessages)
        {
            int count = 0;
            counterCollection = new CounterCreationDataCollection();
            newCounterSet = new Dictionary<string, XlfsPerformanceCounterAttr>();

            FieldInfo[] newFields = categoryType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

            
            foreach (FieldInfo newField in newFields)
            {
                if (newField.FieldType != typeof (PerformanceCounter)) continue;

                // Get the perf counter's attributes.                    
                XlfsPerformanceCounterAttr[] xomCounterAttributes = ( XlfsPerformanceCounterAttr[]) newField.GetCustomAttributes(typeof(XlfsPerformanceCounterAttr), false);
                if (xomCounterAttributes.Length <= 0)
                {
                    string message = String.Format("Failed to initialize the performance counter. The counter does not have a valid attribute. Counter name = " + newField.Name);

                    //Xom.NtEvent(XEvent.Id.COMMON_CONFIG_265,message);

                    //The field MUST have a XlfsPerformanceCounterAttr attribute to it
                    throw (new ArgumentException(message));
                }

                XlfsPerformanceCounterAttr newCounterAttributes = xomCounterAttributes[0];

                if (logMessages)
                {
                    LogMessage("\t\tCounter {0}:", count++);
                    LogMessage("\t\t\t{0}", newCounterAttributes.CtrName);
                    LogMessage("\t\t\t{0}", newCounterAttributes.CtrHelp);
                    LogMessage("\t\t\t{0}", newCounterAttributes.CtrType);
                }

                newCounterSet.Add(newCounterAttributes.CtrName, newCounterAttributes);
                counterCollection.Add(new CounterCreationData(newCounterAttributes.CtrName, newCounterAttributes.CtrHelp, newCounterAttributes.CtrType));
            }
            return count;
        }

        private string GetHashOnCounters(IEnumerable<Type> allTypes)
        {
            StringBuilder countersString = new StringBuilder();

            // Go through all counters, combine them up into a string list.
            foreach (Type t in allTypes)
            {
                if (IsValidPerformanceCounterCategory(t))
                {
                    string categoryName = GetCategoryAttribute(t).CtgName;
                                        
                    CounterCreationDataCollection creation;
                    CounterCategoryDictionary newCounterSet;
                                        
                    LoadCountersInCategory(t, out creation, out newCounterSet, false /* don't log messages */);

                    foreach (string counterName in newCounterSet.Keys)
                    {
                        countersString.AppendLine(categoryName + "-" + counterName);
                    }
                }
            }

            // Get the MD5 hash from the counter string.
            byte[] hashData = MD5.Create().ComputeHash(Encoding.Default.GetBytes(countersString.ToString()));

            StringBuilder counterHash = new StringBuilder();
            foreach (byte b in hashData)
            {
                counterHash.Append(b.ToString("X2"));
            }

            return counterHash.ToString();
        }

        private bool CheckCounterHashExistsInRegistry(string countersHash)
        {
            using (RegistryKey regKey = Registry.LocalMachine.CreateSubKey(CounterHashRegistryKey))
            {
                if(regKey == null)
                {
                    return false;
                }

                string registryValue = (string)regKey.GetValue(CounterRegistryName);

                return registryValue == null ? false : registryValue.Equals(countersHash);
            }
        }

        private void WriteCounterHashToRegistry(string countersHash)
        {
            using (RegistryKey regKey = Registry.LocalMachine.CreateSubKey(CounterHashRegistryKey))
            {
                if(regKey == null)
                {
                    throw new NullReferenceException(string.Format("Failed to create registry key {0}.", CounterHashRegistryKey));
                }

                regKey.SetValue(CounterRegistryName, countersHash);
            }

            LogMessage("Counter hash written to registry for " + CounterRegistryName);
        }

        private void DeleteCounterHashFromRegistry()
        {
            using (RegistryKey regKey = Registry.LocalMachine.CreateSubKey(CounterHashRegistryKey))
            {
                if(regKey == null)
                {
                    return;
                }

                regKey.DeleteValue(CounterRegistryName);
            }

            LogMessage("Counter hash deleted from registry for " + CounterRegistryName);
        }

        private string CounterRegistryName
        {
            get
            {
                return GetType().AssemblyQualifiedName;
            }
        }

        public void LogMessage(String message)
        {
            String stampedMessage = String.Format("[{0:dd-MM-yyyy HH:mm:ss.fff}] {1}", DateTime.Now, message).
                Replace("\n", "\n                             ");

            Trace.WriteLine(stampedMessage);
        }

        public void LogMessage(String message, params Object[] args)
        {
            String formattedMessage = String.Format(message, args);

            LogMessage(formattedMessage);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\XlfsTraceFactory.cs ===
using System;
using System.Collections.Generic;
namespace xonline.server.xlfs.common
{
    public class XlfsTraceFactory : IXlfsTraceFactory
    {
        public IXlfsTrace Create()
        {
            return new XlfsTrace();
        }

        public IXlfsTrace Create(string tag)
        {
            return new XlfsTrace(tag);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\XlfsGcMessageUtils.cs ===
using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;

namespace xonline.server.xlfs.common
{
    public class XlfsGcMessageUtils
    {
        private static Dictionary<string, Type> handlerTypes;

        static XlfsGcMessageUtils()
        {
            // Find all the message handlers in the assembly
            Type[] assemblyTypes = Assembly.GetExecutingAssembly().GetTypes();
            handlerTypes = (from t in assemblyTypes
                            let attribute = Attribute.GetCustomAttribute(t, typeof(XlfsGcMessageHandlerAttribute)) as XlfsGcMessageHandlerAttribute
                            where attribute != null
                            select new { MessageName = attribute.Message, MessageType = t })
                                .ToDictionary(m => m.MessageName, m => m.MessageType);
            
        }
        public static IXlfsGcMessageHandler GetGcMessageHandler(string message)
        {
            Type handlerType = null;

            if (handlerTypes.TryGetValue(message, out handlerType))
            {
                return (IXlfsGcMessageHandler)Activator.CreateInstance(handlerType);
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\XlfsUtilities.cs ===
using System;
using System.Globalization;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;

namespace xonline.server.xlfs.common
{
    /// <summary>
    /// This class is a collection of static utility functions
    /// of general use across all of Xlfs.
    /// </summary>
    public class XlfsUtilities
    {
        public static CloudBlockBlob GetBlob(CloudStorageAccount storageAccount, string titleId, string xuid, string filename, string transactionId)
        {
            CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
            CloudBlobContainer container = blobClient.GetContainerReference(titleId);
            string blobName = String.Format(XlfsConstants.BlobPathFormatString, xuid, filename, transactionId);
            CloudBlockBlob blob = container.GetBlockBlobReference(blobName);
            return blob;
        }

        /// <summary>
        /// Look up a blob in storage given a BlobTableEntry.
        /// </summary>
        /// <param name="storageAccountManager"></param>
        /// <param name="blobTableEntry"></param>
        /// <returns></returns>
        public static CloudBlockBlob GetBlobFromBlobTableEntry(StorageAccountManager storageAccountManager, BlobTableEntry blobTableEntry)
        {
            return GetBlob(
                storageAccountManager.Lookup(blobTableEntry.StorageAccount),
                blobTableEntry.TitleId.ToString(BlobTableEntry.ContainerBlobFormatString),
                blobTableEntry.PartitionKey,
                blobTableEntry.Filename,
                blobTableEntry.RowKey);
        }

        /// <summary>
        /// Look up a blob in storage given a FileTableEntry.
        /// </summary>
        /// <param name="storageAccountManager"></param>
        /// <param name="fileTableLastUpdateEntry"></param>
        /// <returns></returns>
        public static CloudBlockBlob GetBlobFromFileTableLastUpdateEntry(StorageAccountManager storageAccountManager, FileTableLastUpdateEntry fileTableLastUpdateEntry)
        {
            return GetBlob(
                storageAccountManager.Lookup(fileTableLastUpdateEntry.StorageAccount),
                fileTableLastUpdateEntry.TitleId.ToString(BlobTableEntry.ContainerBlobFormatString),
                fileTableLastUpdateEntry.UserXuid.ToString(BlobTableEntry.XuidFormatString),
                fileTableLastUpdateEntry.Filename,
                fileTableLastUpdateEntry.TransactionId);
        }

        /// <summary>
        /// Simple format string wrapper to enhance readability of calling code.
        /// </summary>
        /// <param name="fileTableEntry"></param>
        /// <returns></returns>
        public static string GetBlobNameFromFileTableEntry(FileTableLastUpdateEntry fileTableEntry)
        {
            return String.Format(
                XlfsConstants.BlobPathFormatString,
                fileTableEntry.UserXuid.ToString(BlobTableEntry.XuidFormatString),
                fileTableEntry.Filename,
                fileTableEntry.TransactionId);
        }

        /// <summary>
        /// Simple format string wrapper to enhance readability of calling code.
        /// </summary>
        /// <param name="blobTableEntry"></param>
        /// <returns></returns>
        public static string GetBlobNameFromBlobTableEntry(BlobTableEntry blobTableEntry)
        {
            return String.Format(
                XlfsConstants.BlobPathFormatString,
                blobTableEntry.PartitionKey,
                blobTableEntry.Filename,
                blobTableEntry.RowKey);
        }

        public static bool TryGetUlong(string str, out ulong result)
        {
            result = 0;

            if (str.StartsWith("0x") == false)
            {
                return false;
            }

            // Remove the leading "0x" and parse as hex
            str = str.Substring(2);
            return UInt64.TryParse(str, NumberStyles.HexNumber, null, out result);
        }

        public static bool TryGetUint(string str, out uint result)
        {
            result = 0;

            if (str.StartsWith("0x") == false)
            {
                return false;
            }

            // Remove the leading "0x" and parse as hex
            str = str.Substring(2);
            return UInt32.TryParse(str, NumberStyles.HexNumber, null, out result);
        }

        /// <summary>
        /// Helper function that parses a partition key in the "YYYY:MM:dd:HH"
        /// format into a DateTime.
        /// </summary>
        /// <param name="partitionKey"></param>
        /// <returns></returns>
        public static DateTime? ParsePartitionKey(string partitionKey)
        {
            if (String.IsNullOrEmpty(partitionKey))
            {
                return null;
            }

            string[] parts = partitionKey.Split(':');
            if (parts.Length != 4)
            {
                return null;
            }

            // Now parse each of the four bits into ints.
            int year;
            int month;
            int day;
            int hour;

            if (!Int32.TryParse(parts[0], out year) ||
                !Int32.TryParse(parts[1], out month) ||
                !Int32.TryParse(parts[2], out day) ||
                !Int32.TryParse(parts[3], out hour))
            {
                return null;
            }

            return new DateTime(year, month, day, hour, 0, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\xlfsperfctrs.cs ===
/*
NT Performance Counters

Declare your own class following like in the example:

    [XlfsPerformanceCounterCategoryAttr(
        "TestApp Counters", 
        "The counters for your nice test app",
        true  //If this is a Shared PerfCategory installed by more than one component
    )]
    public class TestAppCounters : XlfsPerformanceCounterCategory
    {
        [XlfsPerformanceCounterAttr(
            "Operations per second", 
            "Number of operations executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RatingsPerSecond;

        static public TestAppCounters Counters = new TestAppCounters();
    }

Then access the PerformanceCounter fields directly. E.g.:

    TestAppCounters.Counters.RatingsPerSecond.Increment();

For more information look for 'PerformanceCounter class' on MSDN. 

One more thing, if you're using counters then you will first have to install 
your assembly using InstallUtil.exe which is located in the .NET framework
directory: %WINDIR%\Microsoft.NET\Framework\vXXXX\InstallUtil.exe.

*/

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Threading;
using System.Web;
using System.Collections.Generic;

namespace xonline.server.xlfs.common
{
    // Useful little class to use with AverageTimer counters. Just instantiate
    // one at the begining of the request and increment the counter at the end
    // of the request using the TimeElapsed field.

    [ComVisible(false)]
    public class XlfsRequestTimeElapsed
    {
        // Static constructor.  Gets the system timer frequency.
        
        static XlfsRequestTimeElapsed()
        {
            Freq = Stopwatch.Frequency;
            
            MsFreq = (float)Freq / 1000;
        }
        
        // Constructor. Gets the current time for reference.                

        public XlfsRequestTimeElapsed()
        {
            _started = Stopwatch.GetTimestamp();
        }

        // Returns the time elapsed since the object was constructed.

        public long TimeElapsed 
        {
            get
            {
                return Stopwatch.GetTimestamp() - _started;
            }
        }
        
        public long SecondsElapsed
        {
            get
            {
                return ((Stopwatch.GetTimestamp() - _started) / Freq);                
            }
        }
        
        public long MillisecondsElapsed
        {
            get
            {
                return (long)((Stopwatch.GetTimestamp() - _started) / MsFreq); 
            }
        }

        private readonly long _started;
            // Time when object was instantiated.
            
        private static readonly long Freq;
            // Nonchanging frequency of the high resolution system counter.    
            
        private static readonly float MsFreq;
            // pre-calculated float divisor
    }

    // Performance Counter category attribute class used to define the name and 
    // the help text for that category.

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class)]
    public class XlfsPerformanceCounterCategoryAttr : Attribute
    {
        public XlfsPerformanceCounterCategoryAttr(string ctgName, string ctgHelp)
            : this(ctgName, ctgHelp, PerformanceCounterInstanceLifetime.Global , false)
        {
            // "Global" instance lifetime is the .Net default. The instances will be 
            // around forever, especially since this class doesn't support deleting 
            // instances (yet).  Your other choice is "Process", which means when the 
            // process dies, the instances go away.
        }

        public XlfsPerformanceCounterCategoryAttr(string ctgName, string ctgHelp, bool isCommon)
            : this(ctgName, ctgHelp, PerformanceCounterInstanceLifetime.Global , isCommon)
        {
            // "Global" instance lifetime is the .Net default. The instances will be 
            // around forever, especially since this class doesn't support deleting 
            // instances (yet).  Your other choice is "Process", which means when the 
            // process dies, the instances go away.
        }

        public XlfsPerformanceCounterCategoryAttr(string ctgName, string ctgHelp, PerformanceCounterInstanceLifetime ctrInstanceLifetime)
        : this (ctgName , ctgHelp, ctrInstanceLifetime, false)
        {
        }

        public XlfsPerformanceCounterCategoryAttr(string ctgName, string ctgHelp, PerformanceCounterInstanceLifetime ctrInstanceLifetime , bool isCommon)
        {
            _isShared = isCommon;
            _ctgName = ctgName;
            _ctgHelp = ctgHelp;
            _ctrInstanceLifetime = ctrInstanceLifetime;
        }

        public bool IsShared
        {
            get { return _isShared; }
        }

        public string CtgName
        {
            get 
            { 
                return "XBL " + _ctgName; 
            }
        }

        public string CtgHelp
        {
            get { return _ctgHelp; }
        }

        public PerformanceCounterInstanceLifetime CtrInstanceLifetime
        {
            get { return _ctrInstanceLifetime; }
        }

        private readonly bool   _isShared;
        private readonly string _ctgName;
        private readonly string _ctgHelp;
        private readonly PerformanceCounterInstanceLifetime _ctrInstanceLifetime;  // applies to all counters & all instances in this category
        
    }
    // Performance counter attribute class used to define the name, help text
    // and counter type.

    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]
    public class XlfsPerformanceCounterAttr : Attribute
    {
        public XlfsPerformanceCounterAttr(string ctrName, string ctrHelp, PerformanceCounterType ctrType)
        {
            CtrName = ctrName;
            CtrHelp = ctrHelp;
            CtrType = ctrType;
        }

        public string CtrName;
        public string CtrHelp;
        public PerformanceCounterType CtrType;

        public bool Equals(XlfsPerformanceCounterAttr anotherInstance )
        {
            if (anotherInstance.CtrName != CtrName)
            {
                return false;
            }

            if (anotherInstance.CtrHelp != CtrHelp)
            {
                return false;
            }

            return anotherInstance.CtrType == CtrType;
        }
    }
    
    // Performance counter category class. Declare one of this for each counter
    // category that your application needs. Declare counters of the type 
    // PerformanceCounter inside it.

    [ComVisible(false)]
    public class XlfsPerformanceCounterCategory
    {
        public const string DefaultInstance = "_Total_";

        [ThreadStaticAttribute]
        private static string _categoryInstanceName;

        // Gets the instance name associated with the current thread, or the default instance
        // if none is specified.
        
        private static string GetInstanceName() {
            return _categoryInstanceName ?? DefaultInstance;
        }

        private static void SetInstanceName(string instance) {
            _categoryInstanceName = instance;
        }
        
        public XlfsPerformanceCounterCategory() : this(false)
        {
        }

        public XlfsPerformanceCounterCategory(bool fInitToZero)
        {
            // Extract the name and the instanceLifeTime text from the class's custom attribute. 
            XlfsPerformanceCounterCategoryAttr catAttr = XlfsPerformanceCounterInstall.GetCategoryAttribute(GetType());

            string categoryName = catAttr.CtgName;

            _categoryName = categoryName;
            _instanceLifetime = catAttr.CtrInstanceLifetime;

            InitializeCategory(GetInstanceName(), fInitToZero);
        }
        
        // You can use this method to create/access other instances. The first
        // time you access the instance will create it. Since the method returns
        // an XlfsPerformanceCounterCategory object  you will have to cast it
        // to your own class before accessing its counters. One practical way of
        // doing it is to declare your own [] operator. Hmmm, maybe we should 
        // have a method that destroys an instance, huh?

        public XlfsPerformanceCounterCategory GetInstance(string instanceName)
        {
            XlfsPerformanceCounterCategory instance;
            
            // access to instance list must be protected against writes.
            
            _lockInstances.AcquireReaderLock(-1);

            try
            {
                // search for instance
            
                instance = (XlfsPerformanceCounterCategory) _instances[instanceName];

                if(instance == null)
                {
                    try {
                        // object instance will be actived with, the 
                        // XlfsPerformanceCounterCategory::ctor will catch the 
                        // correct counter instance names to initialize with
                        SetInstanceName(instanceName);
                        instance = (XlfsPerformanceCounterCategory)Activator.CreateInstance(GetType());
                    }
                    finally {
                        SetInstanceName(null);
                    }

                    // We need write access to the instance list to add this new
                    // instance
                    
                    LockCookie lockCookie = _lockInstances.UpgradeToWriterLock(-1);

                    try
                    {
                        // Now that we are inside, make sure that no other thread
                        // added the instance before us.

                        if(_instances[instanceName] == null)
                        {
                            // Add instance to instance list
                            
                            _instances[instanceName] = instance;
                        }
                        else
                        {
                            // Some other thread got here first. Well, let's use
                            // the object that is already there, then.
                            
                            instance = (XlfsPerformanceCounterCategory) _instances[instanceName];
                        }
                    }
                    finally
                    {
                        _lockInstances.DowngradeFromWriterLock(ref lockCookie);
                    }
                }
            }
            finally
            {
                _lockInstances.ReleaseReaderLock();
            }

            return instance;
        }

        #region Force Init Perf Counters

        // The goal of this static method is to force the initialization of all
        // perfctrs category objects in the assembly, as opposed to the usual
        // managed code behavior of initializing on demand. This method should 
        // be called upon the initialization of the assembly. In the case of 
        // ASP.NET, when the assembly is loaded by IIS.

        public static void InitPerfCtrs()
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            InitPerfCtrs(assembly);

            foreach (AssemblyName assemblyName in assembly.GetReferencedAssemblies()) {
                try {
                    assembly = Assembly.Load(assemblyName);
                    InitPerfCtrs(assembly);
                }
                catch (FileNotFoundException) {
                    // ignore
                }
            }
        }

        public static void InitPerfCtrs(Assembly asm)
        {
            IEnumerable<FieldInfo> fields = GetAssemblyPerfCounters(asm);

            foreach (FieldInfo t in fields)
            {
                t.GetValue(null);
            }
        }


        // Same thing as InitPerfCtrs(), but initalizes a specific instance 
        public static void InitInstPerfCtrs(string instance)
        {
            InitInstPerfCtrs(Assembly.GetExecutingAssembly(), instance);
        }
        public static void InitInstPerfCtrs(Assembly asm, string instance)
        {
            IEnumerable<FieldInfo> fields = GetAssemblyPerfCounters(asm);

            foreach (FieldInfo t in fields)
            {
                // make sure the default instance is initalized
                ((XlfsPerformanceCounterCategory) t.GetValue(null)).GetInstance(DefaultInstance);
                // as well as the requested instance
                ((XlfsPerformanceCounterCategory) t.GetValue(null)).GetInstance(instance);
            }
        }

        private static IEnumerable<FieldInfo> GetAssemblyPerfCounters(Assembly asm)
        {

            FieldInfo[] fields;
            
            // check for field info in http cache.
            // this is useful as this cache automatically cleans up items that may not be
            // referenced often (like this) if/when necessary.
            //
            if (HttpContext.Current != null)
            {
                fields = (FieldInfo[])HttpContext.Current.Cache[asm.FullName + ":PerfCounterFields"];
                if (fields != null)
                {
                    return fields;
                }
            }
            
            // nothing found in the cache, so build the list
            //
            Type[] allTypes = asm.GetTypes();
            ArrayList fieldList = new ArrayList();
            
            foreach( Type t in allTypes )
            {
                if(XlfsPerformanceCounterInstall.IsValidPerformanceCounterCategory(t))
                {
                    // Query all the static/public fields from this class.
                    fields = t.GetFields(BindingFlags.Static | BindingFlags.Public);
    
                    foreach(FieldInfo field in fields)
                    {
                        // If the field has the same type as the class itself,
                        // then that's what we're looking for.
                        if( field.MemberType == MemberTypes.Field &&
                            field.ReflectedType == t)
                        {
                            fieldList.Add(field);
                        }
                    }
                }
            }
            
            fields = new FieldInfo[fieldList.Count];
            fieldList.CopyTo(fields, 0);
            
            
            if (HttpContext.Current != null)
            {
                HttpContext.Current.Cache[asm.FullName + ":PerfCounterFields"] = fields;
            }
            
            return fields;
        }

        #endregion Force Init Perf Counters

        // Verifies that a field is a valid perform counter field.
        // Validity requires that is the right type, and has the required attribute
        
        private bool IsValidPerformanceCounterField(FieldInfo field) {
            return 
                field.FieldType == typeof(PerformanceCounter) &&
                Attribute.IsDefined(field, typeof(XlfsPerformanceCounterAttr), false);
        }

        // Get the attribute from a performance counter field, it is assumed that
        // the field is valid
        
        private XlfsPerformanceCounterAttr GetPerformanceCounterAttr(FieldInfo field) {
            return field.GetCustomAttributes(
                typeof(XlfsPerformanceCounterAttr), 
                false)[0] as XlfsPerformanceCounterAttr;
        }

        // Enumerate all fields that are valid performance counter fields for this
        // class
        
        private IEnumerable<FieldInfo> EnumerateValidPerformanceCounterFields() 
        {
            FieldInfo[] fields =
                GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
            List<FieldInfo> validFields = new List<FieldInfo>(fields.Length);
            
            for (int c=0; c<fields.Length; c++) {
                if (IsValidPerformanceCounterField(fields[c]))
                    validFields.Add(fields[c]);
            }

            return validFields.ToArray();
        }
        
        // Loads all the performance counters for the valid performance counter fields
        
        private void InitializeCategory(string instanceName, bool fInitToZero) 
        {
            foreach (FieldInfo field in EnumerateValidPerformanceCounterFields()) {
                XlfsPerformanceCounterAttr attr = GetPerformanceCounterAttr(field);

                PerformanceCounter counter = CreateCounter(
                    attr.CtrName,
                    instanceName);

                if (fInitToZero)
                {
                    counter.RawValue = 0;
                }

                field.SetValue(this, counter);
            }
        }

        // Creates a new performance counter object

        private PerformanceCounter CreateCounter(string counterName, string instanceName)
        {
            PerformanceCounter counter = new PerformanceCounter();
            counter.CategoryName = _categoryName;
            counter.CounterName = counterName;
            counter.InstanceName = instanceName;
            counter.ReadOnly = false;
            counter.InstanceLifetime = _instanceLifetime;

            //force initialization of the counter
            long raw = counter.RawValue;

            return counter;
        }

        private readonly string _categoryName; 
            // Name of the performance counter category

        private readonly Hashtable _instances = new Hashtable();
            // Hash table to store the instance objects
            
        private readonly ReaderWriterLock _lockInstances = new ReaderWriterLock();
            // Sync access to the _instances

        private readonly PerformanceCounterInstanceLifetime _instanceLifetime = PerformanceCounterInstanceLifetime.Global;
            // How long do counter instances in this cateogory live?
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsAdminFD\dll\WebRole.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.Diagnostics;
using Microsoft.WindowsAzure.ServiceRuntime;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsadminfd
{
    public class WebRole : RoleEntryPoint
    {
        /// <summary>
        /// Expiry time in minutes that place on SAS URLs.
        /// </summary>
        private static int? _SasExpiryMinutes = null;
        public static int SasExpiryMinutes
        {
            get
            {
                if (_SasExpiryMinutes.HasValue)
                {
                    return _SasExpiryMinutes.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("sasExpiryMinutes");
                int sasExpiryMinutes;

                // Make sure that the setting parses correctly and doesn't 
                // exceed the 1 hour limit normally allowed for SAS handles
                if (int.TryParse(value, out sasExpiryMinutes) == false ||
                    sasExpiryMinutes > 60)
                {
                    EventTrace.WriteEvent(
                        "SasExpiryMinutes: Not Found or not Parseable. Defaulting to 60"
                        );
                    sasExpiryMinutes = 60;
                }
                _SasExpiryMinutes = sasExpiryMinutes;
                return sasExpiryMinutes;
            }
        }

        /// <summary>
        /// Indicates whether or not IP whitelisting is required
        /// </summary>
        private static bool? _AllowedIPAddressesEnabled = null;
        public static bool AllowedIPAddressesEnabled
        {
            get
            {
                if (_AllowedIPAddressesEnabled.HasValue == true)
                {
                    return _AllowedIPAddressesEnabled.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("allowedIPAddressesEnabled");
                bool allowedIpAddressesEnabled;

                if (bool.TryParse(value, out allowedIpAddressesEnabled) == false)
                {
                    EventTrace.WriteEvent(
                        "AllowedIpAddressesEnabled: Not Found or not Parseable. Defaulting to true"
                        );
                    allowedIpAddressesEnabled = true;
                }
                _AllowedIPAddressesEnabled = allowedIpAddressesEnabled;
                return allowedIpAddressesEnabled;
            }
        }

        /// <summary>
        /// Indicates which client IP address are whitelisted
        /// </summary>
        private static string[] _AllowedIPAddresses = null;
        public static string[] AllowedIPAddresses
        {
            get
            {
                if (_AllowedIPAddresses != null)
                {
                    return _AllowedIPAddresses;
                }

                string[] allowedIpAddresses = RoleEnvironment.GetConfigurationSettingValue("allowedIPAddresses").Split(';');
                List<string> allowedIps = new List<string>();

                foreach (string str in allowedIpAddresses)
                {
                    if (allowedIps.Contains(str) == true)
                    {
                        EventTrace.WriteEvent(
                            string.Format(
                            "AllowedIpAddresses: Duplicate Entry {0} Found",
                            str));
                        continue;
                    }
                    if (str.Split('.').Length > 4)
                    {
                        EventTrace.WriteEvent(
                            string.Format(
                            "AllowedIpAddresses: Too many octets in {0}",
                            str));
                        continue;
                    }
                    allowedIps.Add(str);
                }
                _AllowedIPAddresses = allowedIps.ToArray();

                return _AllowedIPAddresses;
            }
        }

        /// <summary>
        /// Indicates whether or not client certificates are required
        /// </summary>
        private static bool? _AllowedClientCertEnabled;
        public static bool AllowedClientCertEnabled
        {
            get
            {
                if (_AllowedClientCertEnabled.HasValue == true)
                {
                    return _AllowedClientCertEnabled.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("allowedClientCertEnabled");
                bool allowedClientCertEnabled;

                if (bool.TryParse(value, out allowedClientCertEnabled) == false)
                {
                    EventTrace.WriteEvent(
                        "allowedClientCertEnabled: Not Found or not Parseable. Defaulting to true"
                        );
                    allowedClientCertEnabled = true;
                }
                _AllowedClientCertEnabled = allowedClientCertEnabled;
                return allowedClientCertEnabled;
            }
        }

        private static Dictionary<string, List<string>> _AllowedClientCertThumbprints = null;
        public static Dictionary<string, List<string>> AllowedClientCertThumbprints
        {
            get
            {
                if (_AllowedClientCertThumbprints != null)
                {
                    return _AllowedClientCertThumbprints;
                }

                Dictionary<string,List<string>> allowedCerts = new Dictionary<string, List<string>>();

                try
                {
                    //
                    //  Each thumbprint mapping is in the form:  <thumbprint>=<api1>,<api2>,...,<apiN>
                    //  Thumbprint mappings are semi-colon separated.
                    //

                    string [] thumbprintMappings = RoleEnvironment.GetConfigurationSettingValue("allowedClientCertThumbprints").ToLower().Split(';');

                    foreach(string thumbprintMapping in thumbprintMappings)
                    {
                        string[] thumbprintSplit = thumbprintMapping.Split('=');
                        if(thumbprintSplit.Length != 2)
                        {
                            EventTrace.WriteEvent(
                                string.Format("Skipping invalid certificate-api mapping in allowedClientCertThumbprints: {0}", thumbprintMapping));

                            continue;
                        }

                        string thumbprint = thumbprintSplit[0];
                        string [] allowedApis = thumbprintSplit[1].Split(',');

                        List<string> apiList = allowedApis.ToList();

                        allowedCerts.Add(thumbprint, apiList);
                    }

                    _AllowedClientCertThumbprints = allowedCerts;

                    return _AllowedClientCertThumbprints;
                }
                catch(Exception e)
                {
                    EventTrace.WriteEvent(
                        string.Format("Failed to initialize AllowedClientCertThumbprints.  Exception:\r\n{0}",
                        e));

                    throw;
                }
            }
        }

        /// <summary>
        /// Configured Value that indicates the maximum number of files to return in a 
        /// single getChangedBlobs file enumeration. Default is 1000
        /// </summary>
        private static int? _EnumResultsMaximum = null;
        public static int EnumResultsMaximum
        {
            get
            {
                if (_EnumResultsMaximum.HasValue == true)
                {
                    return _EnumResultsMaximum.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("enumResultsMaximum");
                int enumResultsMaximum;

                // Make sure that the setting parses correctly and doesn't 
                // exceed the 1 hour limit normally allowed for SAS handles
                if (int.TryParse(value, out enumResultsMaximum) == false)
                {
                    EventTrace.WriteEvent(
                        "EnumResultsMaximum: Not Found or not Parseable. Defaulting to 1000"
                        );
                    enumResultsMaximum = 1000;
                }
                _EnumResultsMaximum = enumResultsMaximum;
                return enumResultsMaximum;
            }
        }

        /// <summary>
        /// Specifies the interval, per storage account, that the
        /// Used value will be updated in storage.  The interval
        /// is just a simple count of value updates, and is 
        /// unrelated to elapsed time or size.
        /// </summary>
        private static int? _updateUsedIntervalMs = null;
        public static int UpdateUsedIntervalMs
        {
            get
            {
                if (_updateUsedIntervalMs.HasValue)
                {
                    return _updateUsedIntervalMs.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("updateUsedIntervalMs");
                int updateUsedInterval;
                if (int.TryParse(value, out updateUsedInterval) == false)
                {
                    EventTrace.WriteEvent(
                        "UpdateUsedIntervalCountMs: Not Found or Parseable. Defaulting to False"
                        );
                    updateUsedInterval = 1000;
                }
                _updateUsedIntervalMs = updateUsedInterval;
                return updateUsedInterval;
            }
        }
        
        /// <summary>
        /// Refresh interval time in milliseconds for reloading information from StorageAccountTable.
        /// </summary>
        private static int? _storageAccountRefreshIntervalMs = null;
        public static int StorageAccountRefreshIntervalMs
        {
            get
            {
                if (_storageAccountRefreshIntervalMs.HasValue)
                {
                    return _storageAccountRefreshIntervalMs.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("storageAccountRefreshIntervalMs");
                int storageAccountRefreshIntervalMs;

                // Make sure that the setting parses correctly.
                if (int.TryParse(value, out storageAccountRefreshIntervalMs) == false)
                {
                    EventTrace.WriteEvent(
                        "storageAccountRefreshIntervalMs: Not Found or not Parseable. Defaulting to 60000"
                        );
                    storageAccountRefreshIntervalMs = 60000;
                }
                _storageAccountRefreshIntervalMs = storageAccountRefreshIntervalMs;
                return storageAccountRefreshIntervalMs;
            }
        }

        /// <summary>
        /// Determines whether or not the default home page for the front door will show additional information
        /// </summary>
        private static bool? _DefaultPageShowDetails = null;
        public static bool DefaultPageShowDetails
        {
            get
            {
                if (_DefaultPageShowDetails.HasValue)
                {
                    return _DefaultPageShowDetails.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("defaultPageShowDetails");
                bool defaultPageShowDetails;
                if (bool.TryParse(value, out defaultPageShowDetails) == false)
                {
                    EventTrace.WriteEvent(
                        "DefaultPageShowDetails: Not Found or Parseable. Defaulting to False"
                        );
                    defaultPageShowDetails = false;
                }
                _DefaultPageShowDetails = defaultPageShowDetails;
                return defaultPageShowDetails;
            }
        }

        /// <summary>
        /// Write an event to the main event trace.  This instance should
        /// only be used for writing events since it's static and can't be
        /// flushed.
        /// </summary>
        /// <param name="msg"></param>
        private static readonly XlfsTrace EventTrace = new XlfsTrace("WebRole");

        /// <summary>
        /// Main Role Entry Point
        /// </summary>
        /// <returns></returns>
        public override bool OnStart()
        {
            XlfsTrace trace = new XlfsTrace("XlfsAdminFd");
            trace.AppendInfoLine("WebRole.OnStart: Enter");

            try
            {
                //
                // Verify that DiagnosticsConnectionString and StorageConnectionString
                // are valid and can be used to talk to storage.  We don't validate
                // PublicStorageConnectionString because by definition this is an
                // outward facing connection string
                //);

                if (!this.VerifyConnectionString("DiagnosticsConnectionString"))
                {
                    return false;
                }

                if (!this.VerifyConnectionString("StorageConnectionString"))
                {
                    return false;
                }

                //
                // Install custom performance counters.
                //

                XlfsPerformanceCounterInstall installer = new XlfsPerformanceCounterInstall();
                installer.Install(GetType());

                // 
                // Now set up diagnostics
                //
                DiagnosticMonitorConfiguration diagConfig = DiagnosticMonitor.GetDefaultInitialConfiguration();

                diagConfig.WindowsEventLog.DataSources.Add("Application!*");
                diagConfig.WindowsEventLog.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);

                diagConfig.Logs.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);
                diagConfig.Logs.ScheduledTransferLogLevelFilter = LogLevel.Information;

                // IIS 7.0 Logs
                diagConfig.Directories.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);

                DiagnosticMonitor.Start("DiagnosticsConnectionString", diagConfig);

                //
                // Now enable crash dumps
                //
                CrashDumps.EnableCollection(true);

                // For information on handling configuration changes
                // see the MSDN topic at http://go.microsoft.com/fwlink/?LinkId=166357.
                RoleEnvironment.Changing += RoleEnvironmentChanging;
                RoleEnvironment.Changed += RoleEnvironmentChanged;

                return base.OnStart();
            }
            finally
            {
                trace.AppendInfoLine("WebRole.OnStart: Exit");
                trace.Flush();
            }
        }

        public override void OnStop()
        {
            XlfsTrace trace = new XlfsTrace("WebRole");
            trace.AppendInfoLine("WebRole.OnStop: Enter");

            try
            {
                //
                // Uninstall custom performance counters.
                //

                XlfsPerformanceCounterInstall installer = new XlfsPerformanceCounterInstall();
                installer.Uninstall(GetType());

                base.OnStop();
            }
            finally
            {
                trace.AppendInfoLine("WebRole.OnStop: Exit");
                trace.Flush();
            }
        }

        private void RoleEnvironmentChanging(object sender, RoleEnvironmentChangingEventArgs e)
        {
            XlfsTrace trace = new XlfsTrace("WebRole");
            trace.AppendInfoLine("WebRole.RoleEnvironmentChanging: Enter");

            try
            {
                // If a configuration setting is not changing);
                if (e.Changes.Any(change => change is RoleEnvironmentConfigurationSettingChange) == false)
                {
                    // Nothing to do
                    return;
                }

                // See what is changing
                foreach (RoleEnvironmentChange change in e.Changes)
                {
                    if ((change is RoleEnvironmentConfigurationSettingChange) == false)
                    {
                        continue;
                    }

                    // See if are going to allow the change. We won't accecept any changes
                    // to anything with the 'ConnectionString' as part of the name
                    RoleEnvironmentConfigurationSettingChange settingChange =
                        (RoleEnvironmentConfigurationSettingChange) change;
                    if (settingChange.ConfigurationSettingName.Contains("ConnectionString") == true)
                    {
                        trace.WriteEvent(
                            string.Format(
                                "RoleEnvironmentChange: Resetting due to change to {0}",
                                settingChange.ConfigurationSettingName
                                ));
                        e.Cancel = true;
                    }
                    else
                    {
                        trace.AppendInfoLine(
                            string.Format(
                                "RoleEnvironmentChange: Changing {0}",
                                settingChange.ConfigurationSettingName
                                ));
                    }
                }
            }
            finally
            {
                trace.AppendInfoLine("WebRole.RoleEnvironmentChanging: Exit");
                trace.Flush();
            }
        }

        private void RoleEnvironmentChanged(object sender, RoleEnvironmentChangedEventArgs e)
        {
            XlfsTrace trace = new XlfsTrace("WebRole");
            trace.AppendInfoLine("WebRole.RoleEnvironmentChanged: Enter");

            try
            {
                // See what changed);
                foreach (RoleEnvironmentChange change in e.Changes)
                {
                    if ((change is RoleEnvironmentConfigurationSettingChange) == false)
                    {
                        continue;
                    }

                    RoleEnvironmentConfigurationSettingChange settingChange =
                        (RoleEnvironmentConfigurationSettingChange) change;
                    trace.AppendInfoLine(
                        string.Format(
                            "RoleEnvironmentChange: Changed {0}",
                            settingChange.ConfigurationSettingName
                            ));
                    switch (settingChange.ConfigurationSettingName)
                    {
                        case "sasExpiryMinutes":
                            _SasExpiryMinutes = null;
                            break;
                        case "allowedIPAddressesEnabled":
                            _AllowedIPAddressesEnabled = null;
                            break;
                        case "allowedIPAddresses":
                            _AllowedIPAddresses = null;
                            break;
                        case "allowedClientCertEnabled":
                            _AllowedClientCertEnabled = null;
                            break;
                        case "allowedClientCertThumbprints":
                            _AllowedClientCertThumbprints = null;
                            break;
                        case "enumResultsMaximum":
                            _EnumResultsMaximum = null;
                            break;
                        case "defaultPageShowDetails":
                            _DefaultPageShowDetails = null;
                            break;
                        case "storageAccountRefreshIntervalMs":
                            _storageAccountRefreshIntervalMs = null;
                            break;
                    }
                }
            }
            finally
            {
                trace.AppendInfoLine("WebRole.RoleEnvironmentChanged: Exit");
                trace.Flush();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsAdminFD\dll\Default.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.server.xlfs.fd.xlfsadminfd {
    
    
    public partial class _Default {
        
        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
        
        /// <summary>
        /// XlfsWelcomeMessage control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsWelcomeMessage;
        
        /// <summary>
        /// XlfsCurrentUserPersonalCertificateTableLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsCurrentUserPersonalCertificateTableLabel;
        
        /// <summary>
        /// XlfsCurrentUserPersonalCertificateTable control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Table XlfsCurrentUserPersonalCertificateTable;
        
        /// <summary>
        /// XlfsCurrentUserRootCertificateTableLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsCurrentUserRootCertificateTableLabel;
        
        /// <summary>
        /// XlfsCurrentUserRootCertificateTable control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Table XlfsCurrentUserRootCertificateTable;
        
        /// <summary>
        /// XlfsLocalMachinePersonalCertificateTableLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsLocalMachinePersonalCertificateTableLabel;
        
        /// <summary>
        /// XlfsLocalMachinePersonalCertificateTable control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Table XlfsLocalMachinePersonalCertificateTable;
        
        /// <summary>
        /// XlfsLocalMachineRootCertificateTableLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsLocalMachineRootCertificateTableLabel;
        
        /// <summary>
        /// XlfsLocalMachineRootCertificateTable control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Table XlfsLocalMachineRootCertificateTable;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\common\XlfsTrace.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using System.Xml;
using Microsoft.WindowsAzure.ServiceRuntime;

namespace xonline.server.xlfs.common
{
    /// <summary>
    /// This class wraps the existing System.Diagnostics.Trace class and 
    /// formats trace information into XML-based log lines.
    /// </summary>
    public class XlfsTrace : IXlfsTrace
    {
        private class TraceLine
        {
            public TraceLine(string traceLevel, string message, long elapsedMs)
            {
                TraceLevel = traceLevel;
                Message = message;
                ElapsedMs = elapsedMs;
            }

            public string TraceLevel { get; private set; }
            public string Message { get; private set; }
            public long ElapsedMs { get; private set; }
        }

        #region Static Members

        public static string AssemblyName { get; private set; }
        public static string AssemblyVersion { get; private set; }
        private static readonly string InstanceId = RoleEnvironment.IsAvailable ? RoleEnvironment.CurrentRoleInstance.Id : RoleEnvironment.DeploymentId;

        static XlfsTrace()
        {
            Assembly currentAssembly = Assembly.GetExecutingAssembly();
            String name = "Unknown";
            String fileVersion = "0.0.0.0";

            if (!String.IsNullOrEmpty(currentAssembly.Location))
            {
                fileVersion = FileVersionInfo.GetVersionInfo(currentAssembly.Location).FileVersion;
            }
            if (!String.IsNullOrEmpty(currentAssembly.FullName))
            {
                name = (new AssemblyName(currentAssembly.FullName)).Name;
            }

            AssemblyName = name;
            AssemblyVersion = fileVersion;
        }

        #endregion

        private const byte Error = 0;
        private const byte Warning = 1;
        private const byte Information = 2;
        private const byte Verbose = 3;

        private static readonly string[] TraceLevelStrings = new[] { "Error", "Warning", "Information", "Verbose"};

        private readonly string _tag;

        private readonly XmlWriterSettings _xmlSettings = new XmlWriterSettings
                                                              {
                                                                  OmitXmlDeclaration = true,
                                                                  Encoding = Encoding.ASCII,
                                                                  Indent = true,
                                                                  NewLineOnAttributes = true
                                                              };
        private readonly Dictionary<string, string> _attributes = new Dictionary<string, string>();
        private readonly List<TraceLine> _traceLines = new List<TraceLine>();
        private byte _traceLevel = Verbose;
        private bool _flushed;
        private readonly XlfsRequestTimeElapsed _elapsed;

        public XlfsTrace()
            : this("", new XlfsRequestTimeElapsed())
        {
        }

        public XlfsTrace(string tag)
            : this(tag, new XlfsRequestTimeElapsed())
        {
        }

        public XlfsTrace(string tag, XlfsRequestTimeElapsed elapsed)
        {
            _tag = tag;

            //
            //  Add boilerplate attributes.
            //

            AddAttribute("assemblyName", AssemblyName);
            AddAttribute("assemblyVersion", AssemblyVersion);
            AddAttribute("instanceId", InstanceId);
            AddAttribute("timestamp", DateTime.UtcNow.ToString("o"));
            AddAttribute("tag", _tag);

            _elapsed = elapsed;
        }

        public void AddAttribute(string name, string value)
        {
            _attributes.Add(name,value);
        }

        public void Flush()
        {
            if(_flushed)
            {
                throw new ApplicationException("This trace object has already been flushed!");
            }

            string output = FormatTrace();

            switch(_traceLevel)
            {
                case Error:
                    Trace.TraceError(output);
                    break;

                case Warning:
                    Trace.TraceWarning(output);
                    break;

                case Information:
                    Trace.TraceInformation(output);
                    break;

                case Verbose:
                    Trace.WriteLine(output);
                    break;
            }

            _flushed = true;
        }

        protected string FormatTrace()
        {
            var output = new StringBuilder();
            XmlWriter traceWriter = XmlWriter.Create(output, _xmlSettings);
            if(traceWriter == null)
            {
                throw new NullReferenceException("Failed to create XmlWriter object.");
            }

            traceWriter.WriteStartElement("XlfsTrace");

            traceWriter.WriteAttributeString("traceLevel", TraceLevelStrings[_traceLevel]);
            traceWriter.WriteAttributeString("elapsedMs", _elapsed.MillisecondsElapsed.ToString());

            foreach (KeyValuePair<string, string> kvp in _attributes)
            {
                traceWriter.WriteAttributeString(kvp.Key, kvp.Value ?? "");
            }

            foreach(TraceLine traceLine in _traceLines)
            {
                traceWriter.WriteStartElement(traceLine.TraceLevel);
                traceWriter.WriteAttributeString("elapsedMs", traceLine.ElapsedMs.ToString());
                traceWriter.WriteString(traceLine.Message);
                traceWriter.WriteEndElement();
            }

            traceWriter.WriteEndElement();
            traceWriter.Flush();

            return output.ToString();
        }

        protected void FormatTraceLine(string elementName, string msg)
        {
            _traceLines.Add(new TraceLine(elementName, msg, _elapsed.MillisecondsElapsed));
        }

        public void AppendErrorLine(string msg)
        {
            _traceLevel = Math.Min(_traceLevel, Error);
            FormatTraceLine("Error", msg);
        }

        public void AppendErrorLine(string msg, params object [] args)
        {
            AppendErrorLine(string.Format(msg, args));
        }

        public void AppendWarningLine(string msg)
        {
            _traceLevel = Math.Min(_traceLevel, Warning);
            FormatTraceLine("Warning", msg);
        }

        public void AppendWarningLine(string msg, params object [] args)
        {
            AppendWarningLine(string.Format(msg, args));
        }

        public void AppendInfoLine(string msg)
        {
            _traceLevel = Math.Min(_traceLevel, Information);
            FormatTraceLine("Information", msg);
        }

        public void AppendInfoLine(string msg, params object [] args)
        {
            AppendInfoLine(string.Format(msg, args));
        }

        public void AppendLine(string msg)
        {
            _traceLevel = Math.Min(_traceLevel, Verbose);
            FormatTraceLine("Verbose", msg);
        }

        public void AppendLine(string msg, params object[] args)
        {
            AppendLine(string.Format(msg, args));
        }

        /// <summary>
        /// Write out an actionable event.  If the message being traced is not actionable,
        /// use TraceError instead.  This one is a special case in that it directly
        /// generates a trace line instead of being put into _traceLines.
        /// </summary>
        /// <param name="msg"></param>
        public void WriteEvent(string msg)
        {
            StringBuilder output  = new StringBuilder();
            XmlWriter traceWriter = XmlWriter.Create(output);
            if(traceWriter == null) return;

            traceWriter.WriteStartElement("Event");
            traceWriter.WriteString(msg);
            traceWriter.WriteEndElement();
            traceWriter.Flush();

            Trace.TraceError(output.ToString());
        }

        public void WriteEvent(string msg, params object [] args)
        {
            WriteEvent(string.Format(msg, args));
        }

        // Add more Trace wrappers as needed...

        #region Properties


        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsAdminFD\dll\Default.aspx.cs ===
using System;
using System.Diagnostics;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace xonline.server.xlfs.fd.xlfsadminfd
{
    public partial class _Default : System.Web.UI.Page
    {
        private void ShowAssemblyInfo()
        {
            Assembly currentAssembly = Assembly.GetExecutingAssembly();
            String name = "Unknown";
            String fileVersion = "0.0.0.0";

            if (!String.IsNullOrEmpty(currentAssembly.Location))
            {
                fileVersion = FileVersionInfo.GetVersionInfo(currentAssembly.Location).FileVersion;
            }
            if (!String.IsNullOrEmpty(currentAssembly.FullName))
            {
                name = (new AssemblyName(currentAssembly.FullName)).Name;
            }

            XlfsWelcomeMessage.Text = String.Format(
                "Welcome to Xbox Live File System Admin ({0} - {1})!",
                name,
                fileVersion
                );
        }

        private void UpdateRow(TableRow row, string Text)
        {
            TableCell tableCell = new TableCell();
            TextBox textBox = new TextBox();

            textBox.Text = Text;
            tableCell.Controls.Add(textBox);

            row.Cells.Add(tableCell);
        }

        private void ShowCertificates(Table table, Label label, string text, StoreName name, StoreLocation location)
        {
            TableRow tableRow;
            X509Certificate2Collection selectedCerts = new X509Certificate2Collection();

            X509Store store = new X509Store(name, location);
            try
            {
                store.Open(OpenFlags.OpenExistingOnly | OpenFlags.ReadOnly);
                if (store.Certificates.Count == 0)
                {
                    return;
                }

                // Set the current label for the section
                label.Text = text;

                // Header row for the table
                tableRow = new TableRow();
                UpdateRow(tableRow, "Friendly Name");
                UpdateRow(tableRow, "Issued By");
                UpdateRow(tableRow, "Issued To");
                UpdateRow(tableRow, "Expiration Date");
                UpdateRow(tableRow, "Has Private Key");
                UpdateRow(tableRow, "Thumbprint");
                table.Rows.Add(tableRow);

                foreach (X509Certificate2 cert in store.Certificates)
                {
                    tableRow = new TableRow();

                    // Friendly Name
                    UpdateRow(tableRow, cert.FriendlyName);

                    // Issuer
                    UpdateRow(tableRow, cert.Issuer);

                    // Subject
                    UpdateRow(tableRow, cert.Subject);

                    // Expiration
                    UpdateRow(tableRow, cert.NotAfter.ToString("d"));

                    // Has Private Key
                    UpdateRow(tableRow, cert.HasPrivateKey.ToString());

                    // Thumbprint
                    UpdateRow(tableRow, cert.Thumbprint);

                    // Add the TableRow to the Table
                    table.Rows.Add(tableRow);
                }
            }
            finally
            {
                store.Close();
            }

        }

        protected void Page_Load(object sender, EventArgs e)
        {
            ShowAssemblyInfo();

            if (WebRole.DefaultPageShowDetails == true)
            {
                ShowCertificates(
                    XlfsCurrentUserPersonalCertificateTable,
                    XlfsCurrentUserPersonalCertificateTableLabel,
                    "Current User Personal Certificates",
                    StoreName.My,
                    StoreLocation.CurrentUser
                    );
                ShowCertificates(
                    XlfsCurrentUserRootCertificateTable,
                    XlfsCurrentUserRootCertificateTableLabel,
                    "Current User Root Certificates",
                    StoreName.Root,
                    StoreLocation.CurrentUser
                    );
                ShowCertificates(
                    XlfsLocalMachinePersonalCertificateTable,
                    XlfsLocalMachinePersonalCertificateTableLabel,
                    "Local Machine Personal Certificates",
                    StoreName.My,
                    StoreLocation.LocalMachine
                    );
                ShowCertificates(
                    XlfsLocalMachineRootCertificateTable,
                    XlfsLocalMachineRootCertificateTableLabel,
                    "Local Machine Root Certificates",
                    StoreName.Root,
                    StoreLocation.LocalMachine
                    );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsAdminFD\dll\xlfsAdminGetChangedBlobs.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;
using System.Web;
using System.Xml.Linq;
using System.Xml.Serialization;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsadminfd
{
    /// <summary>
    /// This handler returns an enumeration of files from file storage
    /// that match the given criteria
    /// </summary>
    public class xlfsAdminGetChangedBlobs : AdminRequest, IHttpHandler
    {
        #region Constructors

        #endregion

        #region IHttpHandler Members

        public bool IsReusable
        {
            // Return false in case your Managed Handler cannot be reused for another request.
            // Usually this would be false in case you have some state information preserved per request.
            get { return true; }
        }

        /// <summary>
        /// Main entry point into the xlfsAdminGetChangedBlobs operation.
        /// </summary>
        /// <param name="context"></param>
        public void ProcessRequest(HttpContext context)
        {
            XlfsRequestTimeElapsed elapsed = new XlfsRequestTimeElapsed();

            DateTime startDate;
            DateTime endDate;
            int maxResults;
            int titleId;

            try
            {
                context.SetTrace(new XlfsTrace("xlfsAdminGetChangedBlobs", elapsed));
                context.WriteInfoLine("ProcessRequest: Enter");

                XlfsAdminFdGetChangedBlobsCounters.Counters.RequestsTotal.Increment();
                XlfsAdminFdGetChangedBlobsCounters.Counters.RequestsPerSecond.Increment();

                context.Response.Headers.Add(XlfsVersionHeader, XlfsTrace.AssemblyVersion);

                if (SecurityCheck(context) == false)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    context.WriteErrorLine("ProcessRequest: Security Check Failed");
                    return;
                }

                // Get the start/end date ranges that we care about
                ResultContinuation continuationToken;
                bool result = GetParametersFromRequest(
                    context,
                    out titleId,
                    out startDate,
                    out endDate,
                    out maxResults,
                    out continuationToken
                    );
                if (result == false)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine("ProcessRequest: GetParametersFromRequest Failed");
                    return;
                }

                // Create the XML document that we will send back
                XDocument enumXml = new XDocument(
                    new XComment(
                        "Enum List for " + startDate.ToShortDateString() +
                        "-" + endDate.ToShortDateString() +
                        " obtained at " + DateTime.UtcNow.ToShortDateString()
                        )
                );

                // Create the Root Element
                XElement enumRoot = new XElement("Root");
                enumXml.Add(enumRoot);

                // Create the Files Node that will hold the entire file enumeration
                XElement enumFiles = new XElement("Files");
                enumRoot.Add(enumFiles);

                // Create the data source object
                FileTableLastUpdateDataSource dataSource = new FileTableLastUpdateDataSource();

                // Get the enum of files
                context.WriteInfoLine("ProcessRequest: Starting Enum");
                List<FileTableLastUpdateEntry> files = dataSource.Enum(startDate, endDate, titleId,
                                                                       maxResults, ref continuationToken);
                
                // If we got back a continuation token, put it into the body.
                if(continuationToken != null)
                {
                    StringBuilder serializedContinuation = new StringBuilder();
                    StringWriter writer = new StringWriter(serializedContinuation);

                    XmlSerializer serializer = new XmlSerializer(typeof(ResultContinuation));
                    serializer.Serialize(writer, continuationToken);

                    XElement continuationElement = XElement.Parse(serializedContinuation.ToString());

                    // Add it to the response.
                    enumRoot.Add(XElement.Parse(string.Format("<Continuation>{0}:{1}</Continuation>",
                                                              continuationElement.Element("NextPartitionKey").Value,
                                                              continuationElement.Element("NextRowKey").Value)));
                }

                // Add each file in the enumeration to the XML output
                foreach(var e in files)
                {
                    enumFiles.Add(
                        new XElement("File",
                            new XElement("FileName", e.Filename),
                            new XElement("Xuid", e.UserXuid),
                            new XElement("LastUpdate", e.LastUpdate),
                            new XElement("Created", e.Created),
                            new XElement("TransactionId", e.TransactionId),
                            new XElement("StorageAccount", e.StorageAccount),
                            new XElement("Size", e.Size)
                            )
                        );
                }
                // context.WriteInfoLine(String.Format("ProcessRequest: Returning {0} Files", numFiles));

                // Create the Shared Policy object for the container
                SharedAccessPolicy policy = new SharedAccessPolicy();
                policy.Permissions = SharedAccessPermissions.Read | SharedAccessPermissions.List;
                policy.SharedAccessExpiryTime = DateTime.UtcNow.AddMinutes(WebRole.SasExpiryMinutes);

                // Add the Storage Account node to the tree
                XElement enumAccount = new XElement("StorageAccounts");
                enumRoot.Add(enumAccount);

                if (PublicStorageAccount != null)
                {
                    // Get a pointer to the blob container
                    CloudBlobClient blobClient = PublicStorageAccount.CreateCloudBlobClient();
                    CloudBlobContainer container =
                        blobClient.GetContainerReference(titleId.ToString(BlobTableEntry.ContainerBlobFormatString));

                    // Build the signature object with the policy for the container
                    string signature = container.GetSharedAccessSignature(policy);

                    // Add the node for each storage account.
                    XElement enumSAS = new XElement("SAS");
                    enumAccount.Add(enumSAS);

                    // Add the individual elements to the account node
                    enumSAS.Add(
                        new XElement("StorageAccount", PublicStorageAccount.Credentials.AccountName),
                        new XElement("URI", PublicStorageAccount.BlobEndpoint.AbsoluteUri),
                        new XElement("Container", container.Name),
                        new XElement("Signature", signature),
                        new XElement("Expiry", policy.SharedAccessExpiryTime.ToString())
                        );
                }
                else
                {
                    foreach(StorageAccountTableEntry entry in StorageAccountManager.StorageAccounts)
                    {
                        var accountAndKey = new StorageCredentialsAccountAndKey(entry.PartitionKey, entry.Key);
                        var cloudStorageAccount = new CloudStorageAccount(accountAndKey, true);
                        CloudBlobClient blobClient = cloudStorageAccount.CreateCloudBlobClient();
                        CloudBlobContainer container;

                        try
                        {
                            container =
                                blobClient.GetContainerReference(
                                    titleId.ToString(BlobTableEntry.ContainerBlobFormatString));
                        }
                        catch(Exception)
                        {
                            // Container does not exit.  Swallow exception and continue.
                            continue;
                        }

                        if(container == null)
                        {
                            continue;
                        }

                        // Build the signature object with the policy for the container
                        string signature = container.GetSharedAccessSignature(policy);

                        // Add the node for each storage account.
                        XElement enumSAS = new XElement("SAS");
                        enumAccount.Add(enumSAS);

                        // Add the individual elements to the account node
                        enumSAS.Add(
                            new XElement("StorageAccount", cloudStorageAccount.Credentials.AccountName),
                            new XElement("URI", cloudStorageAccount.BlobEndpoint.AbsoluteUri),
                            new XElement("Container", container.Name),
                            new XElement("Signature", signature),
                            new XElement("Expiry", policy.SharedAccessExpiryTime.ToString())
                            );
                    }
                }

                // Write the XML back to the response
                context.Response.Write(enumXml);
                context.Response.StatusCode = (int)HttpStatusCode.OK;
            }
            catch (Exception e)
            {
                context.WriteErrorLine(string.Format("ProcessRequest: Unhandled exception:\r\n{0}", e));
                context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
            }
            finally
            {
                //  Any response code 400 and above indicates a failure.
                if (context.Response.StatusCode >= (int)HttpStatusCode.BadRequest)
                {
                    XlfsAdminFdGetChangedBlobsCounters.Counters.FailuresTotal.Increment();
                    XlfsAdminFdGetChangedBlobsCounters.Counters.FailuresPerSecond.Increment();
                }

                context.WriteInfoLine("ProcessRequest: Exit");
                context.Flush();

                XlfsAdminFdGetChangedBlobsCounters.Counters.AverageExecutionTime.IncrementBy(elapsed.TimeElapsed);
                XlfsAdminFdGetChangedBlobsCounters.Counters.AverageExecutionTimeBase.Increment();
            }
        }

       #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsAdminFD\dll\xlfsAdminGetChangedBlobsContinue.cs ===
using System;
using System.Net;
using System.Web;
using System.Xml.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsadminfd
{
    /// <summary>
    /// This handler returns an enumeration of files from file storage
    /// that match the given criteria
    /// </summary>
    public class xlfsAdminGetChangedBlobsContinue : AdminRequest, IHttpHandler
    {
        #region Constructors

        #endregion

        #region IHttpHandler Members

        public bool IsReusable
        {
            // Return false in case your Managed Handler cannot be reused for another request.
            // Usually this would be false in case you have some state information preserved per request.
            get { return true; }
        }

        /// <summary>
        /// Main entry point into the xlfsAdminGetChangedBlobsContinue operation.
        /// </summary>
        /// <param name="context"></param>
        public void ProcessRequest(HttpContext context)
        {
            XlfsRequestTimeElapsed elapsed = new XlfsRequestTimeElapsed();

            int titleId;

            try
            {
                context.SetTrace(new XlfsTrace("xlfsAdminGetChangedBlobsContinue", elapsed));
                context.WriteInfoLine("xlfsAdminGetChangedBlobsContinue.ProcessRequest: Enter");

                XlfsAdminFdGetChangedBlobsContinueCounters.Counters.RequestsTotal.Increment();
                XlfsAdminFdGetChangedBlobsContinueCounters.Counters.RequestsPerSecond.Increment();

                context.Response.Headers.Add(XlfsVersionHeader, XlfsTrace.AssemblyVersion);
                
                if (SecurityCheck(context) == false)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    context.WriteErrorLine(
                        "xlfsAdminGetChangedBlobsContinue.Process Request: Security Check Failed"
                        );
                    return;
                }

                // Get the start/end date ranges that we care about
                bool result = GetParametersFromRequest(
                    context,
                    out titleId
                    );
                if (result == false)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        "xlfsAdminGetChangedBlobsContinue.Process Request: GetParametersFromRequest Failed"
                        );
                    return;
                }

                // Create the XML document that we will send back
                XDocument enumXml = new XDocument(
                    new XComment(
                        "Continue obtained at " + DateTime.UtcNow.ToShortDateString()
                        )
                );

                // Create the Root Element
                XElement enumRoot = new XElement("Root");
                enumXml.Add(enumRoot);

                // Create the Shared Policy object for the container
                SharedAccessPolicy policy = new SharedAccessPolicy();
                policy.Permissions = SharedAccessPermissions.Read | SharedAccessPermissions.List;
                policy.SharedAccessExpiryTime = DateTime.UtcNow.AddMinutes(WebRole.SasExpiryMinutes);

                // Add the Storage Accounts node to the tree
                XElement enumAccount = new XElement("StorageAccounts");
                enumRoot.Add(enumAccount);

                if (PublicStorageAccount != null)
                {
                    // Get a pointer to the blob container
                    CloudBlobClient blobClient = PublicStorageAccount.CreateCloudBlobClient();
                    CloudBlobContainer container =
                        blobClient.GetContainerReference(titleId.ToString(BlobTableEntry.ContainerBlobFormatString));

                    // Build the signature object with the policy for the container
                    string signature = container.GetSharedAccessSignature(policy);

                    // Add the node for each storage account.
                    XElement enumSAS = new XElement("SAS");
                    enumAccount.Add(enumSAS);

                    // Add the individual elements to the account node
                    enumSAS.Add(
                        new XElement("StorageAccount", PublicStorageAccount.Credentials.AccountName),
                        new XElement("URI", PublicStorageAccount.BlobEndpoint.AbsoluteUri),
                        new XElement("Container", container.Name),
                        new XElement("Signature", signature),
                        new XElement("Expiry", policy.SharedAccessExpiryTime.ToString())
                        );
                }
                else
                {
                    foreach (StorageAccountTableEntry entry in StorageAccountManager.StorageAccounts)
                    {
                        var accountAndKey = new StorageCredentialsAccountAndKey(entry.PartitionKey, entry.Key);
                        var cloudStorageAccount = new CloudStorageAccount(accountAndKey, true);
                        CloudBlobClient blobClient = cloudStorageAccount.CreateCloudBlobClient();
                        CloudBlobContainer container;

                        try
                        {
                            container =
                                blobClient.GetContainerReference(
                                    titleId.ToString(BlobTableEntry.ContainerBlobFormatString));
                        }
                        catch (Exception)
                        {
                            // Container does not exit.  Swallow exception and continue.
                            continue;
                        }

                        if (container == null)
                        {
                            continue;
                        }

                        // Build the signature object with the policy for the container
                        string signature = container.GetSharedAccessSignature(policy);

                        // Add the node for each storage account.
                        XElement enumSAS = new XElement("SAS");
                        enumAccount.Add(enumSAS);

                        // Add the individual elements to the account node
                        enumSAS.Add(
                            new XElement("StorageAccount", cloudStorageAccount.Credentials.AccountName),
                            new XElement("URI", cloudStorageAccount.BlobEndpoint.AbsoluteUri),
                            new XElement("Container", container.Name),
                            new XElement("Signature", signature),
                            new XElement("Expiry", policy.SharedAccessExpiryTime.ToString())
                            );
                    }
                }

                // Write the XML back to the response
                context.Response.Write(enumXml);
                context.Response.StatusCode = (int)HttpStatusCode.OK;
            }
            catch (Exception e)
            {
                context.WriteErrorLine(string.Format("xlfsAdminGetChangedBlobsContinue.ProcessRequest: Unhandled exception:\r\n{0}", e));
                context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
            }
            finally
            {
                //  Any response code 400 and above indicates a failure.
                if (context.Response.StatusCode >= (int)HttpStatusCode.BadRequest)
                {
                    XlfsAdminFdGetChangedBlobsContinueCounters.Counters.FailuresTotal.Increment();
                    XlfsAdminFdGetChangedBlobsContinueCounters.Counters.FailuresPerSecond.Increment();
                }

                context.WriteInfoLine("xlfsAdminGetChangedBlobs.ProcessRequest: Exit");
                context.Flush();

                XlfsAdminFdGetChangedBlobsContinueCounters.Counters.AverageExecutionTime.IncrementBy(elapsed.TimeElapsed);
                XlfsAdminFdGetChangedBlobsContinueCounters.Counters.AverageExecutionTimeBase.Increment();
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsAdminFD\dll\XlfsAdminFdPerfCtrs.cs ===
using System.Diagnostics;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsadminfd
{
    public class PerformanceCounterStrings
    {
        public const string GetChangedBlobsCategory = "XlfsAdminFd: GetChangedBlobs";
        public const string GetChangedBlobsRequestsPerSec = "GetChangedBlobs requests/sec";
        public const string GetChangedBlobsTotalRequests = "GetChangedBlobs total";
        public const string GetChangedBlobsFailurePerSec = "GetChangedBlobs failures/sec";
        public const string GetChangedBlobsTotalFailures = "GetChangedBlobs total failures";
        public const string GetChangedBlobsAvgExecTime = "GetChangedBlobs avg. execution time";
        public const string GetChangedBlobsAvgExecBaseTime = "GetChangedBlobs avg. execution time base";

        public const string GetChangedBlobsContinueCategory = "XlfsAdminFd: GetChangedBlobsContinue";
        public const string GetChangedBlobsContinueRequestsPerSec = "GetChangedBlobsContinue requests/sec";
        public const string GetChangedBlobsContinueTotalRequests = "GetChangedBlobsContinue total";
        public const string GetChangedBlobsContinueFailurePerSec = "GetChangedBlobsContinue failures/sec";
        public const string GetChangedBlobsContinueTotalFailures = "GetChangedBlobsContinue total failures";
        public const string GetChangedBlobsContinueAvgExecTime = "GetChangedBlobsContinue avg. execution time";
        public const string GetChangedBlobsContinueAvgExecBaseTime = "GetChangedBlobsContinue avg. execution time base";

        public const string GetStorageAccountCategory = "XlfsAdminFd: GetStorageAccount";
        public const string GetStorageAccountRequestsPerSec = "GetStorageAccount requests/sec";
        public const string GetStorageAccountTotalRequests = "GetStorageAccount total";
        public const string GetStorageAccountFailurePerSec = "GetStorageAccount failures/sec";
        public const string GetStorageAccountTotalFailures = "GetStorageAccount total failures";
        public const string GetStorageAccountAvgExecTime = "GetStorageAccount avg. execution time";
        public const string GetStorageAccountAvgExecBaseTime = "GetStorageAccount avg. execution time base";

        public const string PutStorageAccountCategory = "XlfsAdminFd: PutStorageAccount";
        public const string PutStorageAccountRequestsPerSec = "PutStorageAccount requests/sec";
        public const string PutStorageAccountTotalRequests = "PutStorageAccount total";
        public const string PutStorageAccountFailurePerSec = "PutStorageAccount failures/sec";
        public const string PutStorageAccountTotalFailures = "PutStorageAccount total failures";
        public const string PutStorageAccountAvgExecTime = "PutStorageAccount avg. execution time";
        public const string PutStorageAccountAvgExecBaseTime = "PutStorageAccount avg. execution time base";
    }

    /// <summary>
    /// xlfsAdminGetChangedBlobs performance counters.
    /// </summary>
    [XlfsPerformanceCounterCategoryAttr("XlfsAdminFd: xlfsAdminGetChangedBlobs", "Performance counters related to the XLFS Admin xlfsAdminGetChangedBlobs API.")]
    public class XlfsAdminFdGetChangedBlobsCounters : XlfsPerformanceCounterCategory
    {
        public virtual XlfsAdminFdGetChangedBlobsCounters this[string countryId]
        {
            get
            {
                return (XlfsAdminFdGetChangedBlobsCounters)GetInstance(countryId);
            }
        }

        static public XlfsAdminFdGetChangedBlobsCounters Counters = new XlfsAdminFdGetChangedBlobsCounters();

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobs requests/sec",
            "xlfsAdminGetChangedBlobs requests per second",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobs total",
            "Total xlfsAdminGetChangedBlobs requests recorded in the the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobs failures/sec",
            "Number of unsuccessful results returned by xlfsAdminGetChangedBlobs per second in the current AppDomain.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobs total failures",
            "Total number unsuccessful results returned by xlfsAdminGetChangedBlobs in the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobs avg. execution time",
            "xlfsAdminGetChangedBlobs average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobs avg. execution time base",
            "xlfsAdminGetChangedBlobs base for the average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;
    }

    /// <summary>
    /// xlfsAdminGetChangedBlobsContinue performance counters.
    /// </summary>
    [XlfsPerformanceCounterCategoryAttr("XlfsAdminFd: xlfsAdminGetChangedBlobsContinue", "Performance counters related to the XLFS Admin xlfsAdminGetChangedBlobsContinue API.")]
    public class XlfsAdminFdGetChangedBlobsContinueCounters : XlfsPerformanceCounterCategory
    {
        public virtual XlfsAdminFdGetChangedBlobsContinueCounters this[string countryId]
        {
            get
            {
                return (XlfsAdminFdGetChangedBlobsContinueCounters)GetInstance(countryId);
            }
        }

        static public XlfsAdminFdGetChangedBlobsContinueCounters Counters = new XlfsAdminFdGetChangedBlobsContinueCounters();

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobsContinue requests/sec",
            "xlfsAdminGetChangedBlobsContinue requests per second",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobsContinue total",
            "Total xlfsAdminGetChangedBlobsContinue requests recorded in the the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobsContinue failures/sec",
            "Number of unsuccessful results returned by xlfsAdminGetChangedBlobsContinue per second in the current AppDomain.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobsContinue total failures",
            "Total number unsuccessful results returned by xlfsAdminGetChangedBlobsContinue in the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobsContinue avg. execution time",
            "xlfsAdminGetChangedBlobsContinue average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetChangedBlobsContinue avg. execution time base",
            "xlfsAdminGetChangedBlobsContinue base for the average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;
    }

    /// <summary>
    /// xlfsAdminGetStorageAccount performance counters.
    /// </summary>
    [XlfsPerformanceCounterCategoryAttr("XlfsAdminFd: xlfsAdminGetStorageAccount", "Performance counters related to the XLFS Admin xlfsAdminGetStorageAccount API.")]
    public class XlfsAdminFdGetStorageAccountCounters : XlfsPerformanceCounterCategory
    {
        public virtual XlfsAdminFdGetStorageAccountCounters this[string countryId]
        {
            get
            {
                return (XlfsAdminFdGetStorageAccountCounters)GetInstance(countryId);
            }
        }

        static public XlfsAdminFdGetStorageAccountCounters Counters = new XlfsAdminFdGetStorageAccountCounters();

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetStorageAccount requests/sec",
            "xlfsAdminGetStorageAccount requests per second",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetStorageAccount total",
            "Total xlfsAdminGetStorageAccount requests recorded in the the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetStorageAccount failures/sec",
            "Number of unsuccessful results returned by xlfsAdminGetStorageAccount per second in the current AppDomain.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetStorageAccount total failures",
            "Total number unsuccessful results returned by xlfsAdminGetStorageAccount in the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetStorageAccount avg. execution time",
            "xlfsAdminGetStorageAccount average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminGetStorageAccount avg. execution time base",
            "xlfsAdminGetStorageAccount base for the average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;
    }

    /// <summary>
    /// xlfsAdminPutStorageAccount performance counters.
    /// </summary>
    [XlfsPerformanceCounterCategoryAttr("XlfsAdminFd: xlfsAdminPutStorageAccount", "Performance counters related to the XLFS Admin xlfsAdminPutStorageAccount API.")]
    public class XlfsAdminFdPutStorageAccountCounters : XlfsPerformanceCounterCategory
    {
        public virtual XlfsAdminFdPutStorageAccountCounters this[string countryId]
        {
            get
            {
                return (XlfsAdminFdPutStorageAccountCounters)GetInstance(countryId);
            }
        }

        static public XlfsAdminFdPutStorageAccountCounters Counters = new XlfsAdminFdPutStorageAccountCounters();

        [XlfsPerformanceCounterAttr(
            "xlfsAdminPutStorageAccount requests/sec",
            "xlfsAdminPutStorageAccount requests per second",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminPutStorageAccount total",
            "Total xlfsAdminPutStorageAccount requests recorded in the the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminPutStorageAccount failures/sec",
            "Number of unsuccessful results returned by xlfsAdminPutStorageAccount per second in the current AppDomain.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminPutStorageAccount total failures",
            "Total number unsuccessful results returned by xlfsAdminPutStorageAccount in the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminPutStorageAccount avg. execution time",
            "xlfsAdminPutStorageAccount average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XlfsPerformanceCounterAttr(
            "xlfsAdminPutStorageAccount avg. execution time base",
            "xlfsAdminPutStorageAccount base for the average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsAdminFD\dll\xlfsAdminRequest.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Web;
using System.Xml.Serialization;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.ServiceRuntime;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsadminfd
{
    /// <summary>
    /// This handler returns an enumeration of files from file storage
    /// that match the given criteria
    /// </summary>
    public class AdminRequest
    {
        protected readonly CloudStorageAccount StorageAccount;
        protected readonly CloudStorageAccount PublicStorageAccount;
        protected static StorageAccountManager StorageAccountManager;

        public const string XlfsVersionHeader = "x-ms-xlfs-version";

        public AdminRequest()
        {
            // This code sets up a handler to update CloudStorageAccount instances when their corresponding
            // configuration settings change in the service configuration file.
            CloudStorageAccount.SetConfigurationSettingPublisher((configName, configSetter) =>
            {
                // Provide the configSetter with the initial value
                configSetter(RoleEnvironment.GetConfigurationSettingValue(configName));

                RoleEnvironment.Changed += (sender, arg) =>
                {
                    if (arg.Changes.OfType<RoleEnvironmentConfigurationSettingChange>()
                        .Any(change => (change.ConfigurationSettingName == configName)))
                    {
                        // The corresponding configuration setting has changed, propagate the value
                        if (!configSetter(RoleEnvironment.GetConfigurationSettingValue(configName)))
                        {
                            // In this case, the change to the storage account credentials in the
                            // service configuration is significant enough that the role needs to be
                            // recycled in order to use the latest settings. (for example, the 
                            // endpoint has changed)
                            RoleEnvironment.RequestRecycle();
                        }
                    }
                };
            });

            StorageAccount = CloudStorageAccount.FromConfigurationSetting("StorageConnectionString");
            PublicStorageAccount =
                string.IsNullOrEmpty(RoleEnvironment.GetConfigurationSettingValue("PublicStorageConnectionString"))
                    ? null
                    : CloudStorageAccount.FromConfigurationSetting("PublicStorageConnectionString");

            int refreshInterval = WebRole.StorageAccountRefreshIntervalMs;
            int updateUsedInterval = WebRole.UpdateUsedIntervalMs;

            StorageAccountManager = new StorageAccountManager(StorageAccount, refreshInterval, updateUsedInterval, new XlfsTraceFactory());
        }

        /// <summary>
        /// Determine what the titleid and start/end dates are based upon the request
        /// </summary>
        /// <param name="context"></param>
        /// <param name="titleId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="maxResults"></param>
        /// <param name="continuationToken"></param>
        /// <returns></returns>
        protected static bool GetParametersFromRequest(
            HttpContext context, 
            out int titleId,
            out DateTime startDate, 
            out DateTime endDate,
            out int maxResults,
            out ResultContinuation continuationToken
            )
        {
            context.WriteInfoLine("GetParametersFromRequest: Enter");

            try
            {
                HttpRequest request = context.Request;

                string startString = request.QueryString["start"];
                string endString = request.QueryString["end"];
                string maxResultsString = request.QueryString["maxresults"];

                // Parse the EndDate safely. If an error occured or it wasn't
                // present in the list of arguments, then assume right now.
                if (string.IsNullOrEmpty(endString) == true ||
                    DateTime.TryParse(endString, out endDate) == false)
                {
                    context.WriteWarningLine("GetParametersFromRequest: end parameter not specified, using now");
                    endDate = DateTime.UtcNow;
                }
                else
                {
                    endDate = endDate.ToUniversalTime();
                }

                // Parse the StartDate safely. If an error occured or it wasn't
                // present in the list of arguments, then assume yesterday.
                if (string.IsNullOrEmpty(startString) == true ||
                    DateTime.TryParse(startString, out startDate) == false)
                {
                    context.WriteWarningLine("GetParametersFromRequest: start parameter not specified, using default");
                    startDate = new DateTime(endDate.Year, endDate.Month, endDate.Day, endDate.Hour, 0, 0, endDate.Kind); 
                }
                else
                {
                    startDate = startDate.ToUniversalTime();
                }

                // Parse the maxResults safely.  If an error occured or it wasn't
                // present in the list of arguments, use WebRole.EnumResultsMaximum.
                if( !string.IsNullOrEmpty(maxResultsString) &&
                    int.TryParse(maxResultsString, out maxResults) )
                {
                    maxResults = maxResults <= 0
                                     ? WebRole.EnumResultsMaximum
                                     : Math.Min(maxResults, WebRole.EnumResultsMaximum);
                }
                else
                {
                    maxResults = WebRole.EnumResultsMaximum;
                }

                // Create the continuation token.
                if(!GetContinuationTokenFromQueryString(context, out continuationToken))
                {
                    titleId = 0;
                    return false;
                }

                // Parse the titleid safely. If an error occured or it wasn't
                // present in the list of arguments, then assume the
                // default titleid
                if (GetParametersFromRequest(context, out titleId) == false)
                {
                    return false;
                }

                // Make sure that we don't have reversed start and end dates
                if (startDate > endDate)
                {
                    return false;
                }

                // Informational
                context.WriteInfoLine(
                    string.Format(
                        "GetParametersFromRequest: start:{0} end:{1}",
                        startDate,
                        endDate
                        ) );

                // The rules for the start date and end date are as follows:
                // * There must be less than a single hour of seperation between the two
                // * The end date's hour must either within the same hour as the start hour
                //   or the end date's hour must be exactly the next hour. For example, if
                //   12:12 is the start hour, then the end hour can be any time up to and 
                //   including 13:00
                if ((endDate - startDate).TotalHours > 1)
                {
                    context.WriteErrorLine("GetParametersFromRequest: too many hours requested");
                    return false;
                }
                if ((startDate.Hour != endDate.Hour) &&
                    (endDate.Millisecond != 0 ||
                     endDate.Minute != 0 ||
                     endDate.Second != 0))
                {
                    context.WriteErrorLine("GetParametersFromRequest: End Hour Not on Boundary");
                    return false;
                }

                // Check to see that the end date and start date both occur in 2010 or higher
                if (startDate.Year < 2010 || endDate.Year < 2010)
                {
                    context.WriteErrorLine("GetParametersFromRequest: StartDate or EndDate before 2010");
                    return false;
                }

                // Success
                return true;
            }
            catch
            {
                context.WriteErrorLine("AdminRequest.GetParametersFromRequest: Exception Occured");

                // Fail the call and make the compiler happy
                startDate = DateTime.UtcNow.AddHours(-1);
                endDate = DateTime.UtcNow;
                titleId = unchecked((int)0xFFFE07D1);
                continuationToken = null;
                maxResults = WebRole.EnumResultsMaximum; 
                return false;
            }
            finally
            {
                context.WriteInfoLine("AdminRequest.GetParametersFromRequest: Exit");
            }
        }

        /// <summary>
        /// Construct a ResultContinuation token from the "continuation" query
        /// string parameter, or return null if absent.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="continuation"></param>
        /// <returns></returns>
        protected static bool GetContinuationTokenFromQueryString(HttpContext context, out ResultContinuation continuation)
        {
            context.WriteInfoLine("AdminRequest.GetContinuationTokenFromQueryString: Enter");

            try
            {
                // Get continuation token from query string.
                string continuationString = context.Request.QueryString["continuation"];
                if (string.IsNullOrEmpty(continuationString))
                {
                    context.WriteInfoLine(
                        "AdminRequest.GetContinuationTokenFromQueryString: No continuation token in request.");
                    continuation = null;
                    return true;
                }

                // Split continuation token into next partition key and next row key.
                string[] continuationParts = continuationString.Split(':');
                if (continuationParts.Length != 2)
                {
                    context.WriteErrorLine(
                        "AdminRequest.GetContinuationTokenFromQueryString: After splitting continuation token on ':', the wrong number of components were found, expected 2.");
                    continuation = null;
                    return false;
                }

                // Format the deserialization xml.
                string continuationTokenXml =
                    string.Format(
                        "<ResultContinuation><Version>1.0</Version><Type>Table</Type><NextPartitionKey>{0}</NextPartitionKey><NextRowKey>{1}</NextRowKey></ResultContinuation>",
                        continuationParts[0],
                        continuationParts[1]);
                context.WriteInfoLine(
                    string.Format("AdminRequest.GetContinuationTokenFromQueryString:  Continuation token = \"{0}\".",
                                  continuationTokenXml));

                // Deserialize.
                StringReader reader = new StringReader(continuationTokenXml);
                XmlSerializer serializer = new XmlSerializer(typeof (ResultContinuation));

                try
                {
                    continuation = serializer.Deserialize(reader) as ResultContinuation;
                }
                catch(Exception e)
                {
                    context.WriteErrorLine(
                        string.Format(
                            "AdminRequest.GetContinuationTokenFromQueryString: Failed to deserialize continuation token from xml.  Exception = \r\n{0}",
                            e));
                    continuation = null;
                    return false;
                }
                return true;
            }
            finally
            {
                context.WriteInfoLine("AdminRequest.GetContinuationTokenFromQueryString: Exit");
            }
        }

        /// <summary>
        /// Determine what the titleid and start/end dates are based upon the request
        /// </summary>
        /// <param name="context"></param>
        /// <param name="titleId"></param>
        /// <returns></returns>
        protected static bool GetParametersFromRequest(
            HttpContext context,
            out int titleId
            )
        {
            context.WriteInfoLine("GetParametersFromRequest: Enter");

            try
            {
                HttpRequest request = context.Request;

                string titleString = request.QueryString["titleid"];

                // Parse the titleid safely. If an error occured or it wasn't
                // present in the list of arguments, then assume the
                // default titleid
                if (string.IsNullOrEmpty(titleString) != false ||
                    int.TryParse(titleString, NumberStyles.HexNumber, null, out titleId) == false ||
                    titleId == 0)
                {
                    context.WriteErrorLine("GetParametersFromRequest: title parameter not specified or unparseable");
                    titleId = unchecked((int)0xFFFE07D1);
                    return false;
                }

                // Informational
                context.WriteInfoLine(
                    string.Format(
                        "GetParametersFromRequest: titleid:{0}",
                        titleId
                        ));
                // Success
                return true;
            }
            catch
            {
                context.WriteErrorLine("GetParametersFromRequest: Exception Occured");
                titleId = unchecked((int)0xFFFE07D1);
                return false;
            }
            finally
            {
                context.WriteInfoLine("GetParametersFromRequest: Exit");
            }
        }

        protected static bool SecurityCheckClientCerts(
            HttpContext context
            )
        {
            HttpRequest request = context.Request;

            // Sanity check that the client really has passed us a certificate
            if (request.ClientCertificate.IsPresent == false)
            {
                context.WriteErrorLine(
                    "SecurityCheck: No Client Certificate"
                    );
                return false;
            }

            // Get the client certificate as an X509 certificate
            X509Certificate2 clientCert = new X509Certificate2(request.ClientCertificate.Certificate);
            string clientThumb = clientCert.Thumbprint.ToLower();

            if(!WebRole.AllowedClientCertThumbprints.ContainsKey(clientThumb))
            {
                context.WriteErrorLine(
                    string.Format(
                        "SecurityCheck: Unrecognized Client Certificate: {0}/{1}",
                        clientCert.Subject,
                        clientThumb
                        ));
                return false;
            }

            List<string> apiList = WebRole.AllowedClientCertThumbprints[clientThumb];
            
            foreach (string allowedApi in apiList)
            {
                if (request.Url.PathAndQuery.ToLower().Contains(allowedApi))
                {
                    return true;
                }
            }

            context.WriteErrorLine(
                string.Format(
                    "SecurityCheck: Client Certificate {0}/{1} not allowed access to URL {2}",
                    clientCert.Subject,
                    clientThumb,
                    request.Url
                    ));

            return true;
        }

        protected static bool SecurityCheckIPAddresses(
            HttpContext context
            )
        {
            HttpRequest request = context.Request;

            string[] callerIPAddressAsOctets = request.UserHostAddress.ToLower().Split('.');
            if (callerIPAddressAsOctets.Length != 4)
            {
                context.WriteWarningLine(
                    string.Format(
                        "SecurityCheck: Unrecognized UserHostAddress {0}",
                        request.UserHostAddress
                        ));
                return false;
            }

            // Does the IP address come from an allowed range?
            foreach (string allowedIpAddress in WebRole.AllowedIPAddresses)
            {
                bool matchFound = true;
                string[] allowedIpAddressAsOctets = allowedIpAddress.Split('.');

                for (int i = 0; i < allowedIpAddressAsOctets.Length; i++)
                {
                    // Allow Wildcards
                    if (allowedIpAddressAsOctets[i] == "*")
                    {
                        continue;
                    }
                    if (allowedIpAddressAsOctets[i] != callerIPAddressAsOctets[i])
                    {
                        matchFound = false;
                        break;
                    }
                }

                // Did we get a match?
                if (matchFound == true)
                {
                    return true;
                }
            }
            context.WriteWarningLine(
                string.Format(
                    "SecurityCheck: Unauthoraized UserHostAddress {0}",
                    request.UserHostAddress
                    ));
            return false;
        }
 
        protected static bool SecurityCheck(
            HttpContext context
            )
        {
            context.WriteInfoLine("SecurityCheck: Enter");

            try
            {
                HttpRequest request = context.Request;

                // Do we have to validate the presence of client certificates?
                if (WebRole.AllowedClientCertEnabled == true &&
                    SecurityCheckClientCerts(context) == false)
                {
                    return false;
                }


                // Is the check for requests disabled on this server?
                if (WebRole.AllowedIPAddressesEnabled == true &&
                    SecurityCheckIPAddresses(context) == false)
                {
                    return false;
                }

                // If we got here, we passed all the checks
                return true;
            }
            catch (Exception e)
            {
                context.WriteErrorLine("Security Check: Exception: "+e.ToString());
                return false;
            }
            finally
            {
                context.WriteInfoLine("SecurityCheck: Exit");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsAdminFD\dll\xlfsAdminGetStorageAccount.cs ===
using System;
using System.Data.Services.Client;
using System.Net;
using System.Web;
using Microsoft.WindowsAzure;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsadminfd
{
    public class xlfsAdminGetStorageAccount : AdminRequest, IHttpHandler
    {
        // NOTE:  We don't return the storage key, although it can be updated via xlfsAdminGetStorageAccount.
        private const string GetXmlBodyTemplate = "<StorageAccount name=\"{0}\" key=\"{1}\" capacity=\"{2}\" threshold=\"{3}\" used=\"{4}\" />";

        public void ProcessRequest(HttpContext httpContext)
        {
            XlfsRequestTimeElapsed elapsed = new XlfsRequestTimeElapsed();

            try
            {
                httpContext.SetTrace(new XlfsTrace("xlfsAdminGetStorageAccount", elapsed));
                httpContext.WriteInfoLine("xlfsAdminGetStorageAccount.ProcessRequest: Enter");

                XlfsAdminFdGetStorageAccountCounters.Counters.RequestsTotal.Increment();
                XlfsAdminFdGetStorageAccountCounters.Counters.RequestsPerSecond.Increment();

                httpContext.Response.Headers.Add(XlfsVersionHeader, XlfsTrace.AssemblyVersion);
                
                if (httpContext.Request.QueryString["storageAccount"] == null)
                {
                    httpContext.WriteErrorLine("xlfsAdminGetStorageAccount.ProcessRequest: Missing 'storageAccount' query string parameter.");
                    httpContext.Response.StatusCode = (int) HttpStatusCode.BadRequest;
                    return;
                }

                string storageAccountName = httpContext.Request.QueryString["storageAccount"];
                CloudStorageAccount cloudStorageAccount =
                    CloudStorageAccount.FromConfigurationSetting("StorageConnectionString");
                StorageAccountTableDataSource dataSource = new StorageAccountTableDataSource(cloudStorageAccount);
                StorageAccountTableContext context = StorageAccountTableContext.GetContext(cloudStorageAccount);
                context.MergeOption = MergeOption.NoTracking;

                StorageAccountTableEntry entry = dataSource.GetStorageAccount(context, storageAccountName);
                if (entry == null)
                {
                    httpContext.Response.StatusCode = (int)HttpStatusCode.NotFound;
                    return;
                }

                // Format XML.
                string responseBody = string.Format(
                    GetXmlBodyTemplate,
                    entry.PartitionKey,
                    entry.Key,
                    entry.Capacity,
                    entry.Threshold,
                    entry.Used);
                httpContext.Response.Write(responseBody);
                httpContext.Response.StatusCode = (int) HttpStatusCode.OK;
            }
            catch (Exception e)
            {
                httpContext.WriteErrorLine(string.Format("xlfsAdminGetStorageAccount.ProcessRequest: Unhandled exception:\r\n{0}", e));
                httpContext.Response.StatusCode = (int)HttpStatusCode.BadRequest;
            }
            finally
            {
                //  Any response code 400 and above indicates a failure.
                if (httpContext.Response.StatusCode >= (int)HttpStatusCode.BadRequest)
                {
                    XlfsAdminFdGetStorageAccountCounters.Counters.FailuresTotal.Increment();
                    XlfsAdminFdGetStorageAccountCounters.Counters.FailuresPerSecond.Increment();
                }

                httpContext.WriteInfoLine("xlfsAdminGetStorageAccount.ProcessRequest: Exit");
                httpContext.Flush();

                XlfsAdminFdGetStorageAccountCounters.Counters.AverageExecutionTime.IncrementBy(elapsed.TimeElapsed);
                XlfsAdminFdGetStorageAccountCounters.Counters.AverageExecutionTimeBase.Increment();
            }
        }

        public bool IsReusable
        {
            // Return false in case your Managed Handler cannot be reused for another request.
            // Usually this would be false in case you have some state information preserved per request.
            get { return true; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsFD\dll\Default.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.server.xlfs.fd.xlfsfd {
    
    
    public partial class _Default {
        
        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
        
        /// <summary>
        /// XlfsWelcomeMessage control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsWelcomeMessage;
        
        /// <summary>
        /// XlfsCurrentUserPersonalCertificateTableLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsCurrentUserPersonalCertificateTableLabel;
        
        /// <summary>
        /// XlfsCurrentUserPersonalCertificateTable control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Table XlfsCurrentUserPersonalCertificateTable;
        
        /// <summary>
        /// XlfsCurrentUserRootCertificateTableLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsCurrentUserRootCertificateTableLabel;
        
        /// <summary>
        /// XlfsCurrentUserRootCertificateTable control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Table XlfsCurrentUserRootCertificateTable;
        
        /// <summary>
        /// XlfsLocalMachinePersonalCertificateTableLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsLocalMachinePersonalCertificateTableLabel;
        
        /// <summary>
        /// XlfsLocalMachinePersonalCertificateTable control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Table XlfsLocalMachinePersonalCertificateTable;
        
        /// <summary>
        /// XlfsLocalMachineRootCertificateTableLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label XlfsLocalMachineRootCertificateTableLabel;
        
        /// <summary>
        /// XlfsLocalMachineRootCertificateTable control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Table XlfsLocalMachineRootCertificateTable;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsFD\dll\Default.aspx.cs ===
using System;
using System.Diagnostics;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace xonline.server.xlfs.fd.xlfsfd
{
    public partial class _Default : System.Web.UI.Page
    {
        private void ShowAssemblyInfo()
        {
            Assembly currentAssembly = Assembly.GetExecutingAssembly();
            String name = "Unknown";
            String fileVersion = "0.0.0.0";

            if (!String.IsNullOrEmpty(currentAssembly.Location))
            {
                fileVersion = FileVersionInfo.GetVersionInfo(currentAssembly.Location).FileVersion;
            }
            if (!String.IsNullOrEmpty(currentAssembly.FullName))
            {
                name = (new AssemblyName(currentAssembly.FullName)).Name;
            }

            XlfsWelcomeMessage.Text = String.Format(
                "Welcome to Xbox Live File System ({0} - {1})!",
                name,
                fileVersion
                );
        }

        private void UpdateRow(TableRow row, string Text)
        {
            TableCell tableCell = new TableCell();
            TextBox textBox = new TextBox();

            textBox.Text = Text;
            tableCell.Controls.Add(textBox);

            row.Cells.Add(tableCell);
        }

        private void ShowCertificates(Table table, Label label, string text, StoreName name, StoreLocation location)
        {
            TableRow tableRow;
            X509Certificate2Collection selectedCerts = new X509Certificate2Collection();

            X509Store store = new X509Store(name, location);
            try
            {
                store.Open(OpenFlags.OpenExistingOnly | OpenFlags.ReadOnly);
                if (store.Certificates.Count == 0)
                {
                    return;
                }

                // Set the current label for the section
                label.Text = text;

                // Header row for the table
                tableRow = new TableRow();
                UpdateRow(tableRow, "Friendly Name");
                UpdateRow(tableRow, "Issued By");
                UpdateRow(tableRow, "Issued To");
                UpdateRow(tableRow, "Expiration Date");
                UpdateRow(tableRow, "Has Private Key");
                UpdateRow(tableRow, "Thumbprint");
                table.Rows.Add(tableRow);

                foreach (X509Certificate2 cert in store.Certificates)
                {
                    tableRow = new TableRow();

                    // Friendly Name
                    UpdateRow(tableRow, cert.FriendlyName);

                    // Issuer
                    UpdateRow(tableRow, cert.Issuer);

                    // Subject
                    UpdateRow(tableRow, cert.Subject);

                    // Expiration
                    UpdateRow(tableRow, cert.NotAfter.ToString("d"));

                    // Has Private Key
                    UpdateRow(tableRow, cert.HasPrivateKey.ToString());

                    // Thumbprint
                    UpdateRow(tableRow, cert.Thumbprint);

                    // Add the TableRow to the Table
                    table.Rows.Add(tableRow);
                }
            }
            finally
            {
                store.Close();
            }            

        }

        protected void Page_Load(object sender, EventArgs e)
        {
            ShowAssemblyInfo();

            if (WebRole.DefaultPageShowDetails == true)
            {
                ShowCertificates(
                    XlfsCurrentUserPersonalCertificateTable,
                    XlfsCurrentUserPersonalCertificateTableLabel,
                    "Current User Personal Certificates",
                    StoreName.My,
                    StoreLocation.CurrentUser
                    );
                ShowCertificates(
                    XlfsCurrentUserRootCertificateTable,
                    XlfsCurrentUserRootCertificateTableLabel,
                    "Current User Root Certificates",
                    StoreName.Root,
                    StoreLocation.CurrentUser
                    );
                ShowCertificates(
                    XlfsLocalMachinePersonalCertificateTable,
                    XlfsLocalMachinePersonalCertificateTableLabel,
                    "Local Machine Personal Certificates",
                    StoreName.My,
                    StoreLocation.LocalMachine
                    );
                ShowCertificates(
                    XlfsLocalMachineRootCertificateTable,
                    XlfsLocalMachineRootCertificateTableLabel,
                    "Local Machine Root Certificates",
                    StoreName.Root,
                    StoreLocation.LocalMachine
                    );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsAdminFD\dll\xlfsAdminPutStorageAccount.cs ===
using System;
using System.IO;
using System.Net;
using System.Web;
using System.Xml;
using Microsoft.WindowsAzure;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsadminfd
{
    public class xlfsAdminPutStorageAccount : AdminRequest, IHttpHandler
    {
        public void ProcessRequest(HttpContext httpContext)
        {
            XlfsRequestTimeElapsed elapsed = new XlfsRequestTimeElapsed();

            try
            {
                httpContext.SetTrace(new XlfsTrace("xlfsAdminPutStorageAccount", elapsed));
                httpContext.WriteInfoLine("xlfsAdminPutStorageAccount.ProcessRequest: Enter");

                XlfsAdminFdPutStorageAccountCounters.Counters.RequestsTotal.Increment();
                XlfsAdminFdPutStorageAccountCounters.Counters.RequestsPerSecond.Increment();

                httpContext.Response.Headers.Add(XlfsVersionHeader, XlfsTrace.AssemblyVersion);

                //  Read the request body into an xml document.
                XmlDocument requestBodyDoc = new XmlDocument();

                StreamReader reader = new StreamReader(httpContext.Request.InputStream);
                string body = reader.ReadToEnd();
                httpContext.WriteInfoLine(string.Format("xlfsAdminPutStorageAccount.ProcessRequest: Request body = \"{0}\"", body));

                try
                {
                    requestBodyDoc.LoadXml(body);
                }
                catch (Exception e)
                {
                    httpContext.WriteErrorLine(
                        string.Format(
                            "xlfsAdminPutStorageAccount.ProcessRequest: Failed to load body XML.  Exception:\r\n{0}",
                            e));
                    httpContext.Response.StatusCode = (int) HttpStatusCode.BadRequest;
                    return;
                }

                if(requestBodyDoc.DocumentElement == null)
                {
                    httpContext.WriteErrorLine(
                        "xlfsAdminPutStorageAccount.ProcessRequest: Request XML did not contain a root element.");
                    httpContext.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    return;
                }

                // Validate the xml and parse the numeric fields.
                if (requestBodyDoc.DocumentElement.Attributes["name"] == null ||
                    requestBodyDoc.DocumentElement.Attributes["key"] == null ||
                    requestBodyDoc.DocumentElement.Attributes["capacity"] == null ||
                    requestBodyDoc.DocumentElement.Attributes["threshold"] == null)
                {
                    httpContext.WriteErrorLine(
                        "xlfsAdminPutStorageAccount.ProcessRequest: One or more required attributes were missing.");
                    httpContext.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    return;
                }

                // Make sure that 'key' contains valid base 64.
                try
                {
                    Convert.FromBase64String(requestBodyDoc.DocumentElement.Attributes["key"].Value);
                }
                catch(Exception)
                {
                    httpContext.WriteErrorLine(
                        "xlfsAdminPutStorageAccount.ProcessRequest: The 'key' attribute did not contain a valid base 64 encoded value.");
                    httpContext.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    return;
                }

                long capacity;
                if (!long.TryParse(requestBodyDoc.DocumentElement.Attributes["capacity"].Value, out capacity))
                {
                    httpContext.WriteErrorLine(
                        "xlfsAdminPutStorageAccount.ProcessRequest: The 'capacity' attribute could not be parsed as a 64-bit signed integer.");
                    httpContext.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    return;
                }
                if(capacity < 0)
                {
                    httpContext.WriteErrorLine(
                        "xlfsAdminPutStorageAccount.ProcessRequest: The 'capacity' attribute must be non-negative.");
                    httpContext.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    return;
                }

                long threshold;
                if (!long.TryParse(requestBodyDoc.DocumentElement.Attributes["threshold"].Value, out threshold))
                {
                    httpContext.WriteErrorLine(
                        "xlfsAdminPutStorageAccount.ProcessRequest: The 'threshold' attribute could not be parsed as a 64-bit signed integer.");
                    httpContext.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    return;
                }
                if(threshold < 0)
                {
                    httpContext.WriteErrorLine(
                        "xlfsAdminPutStorageAccount.ProcessRequest: The 'threshold' attribute must be non-negative.");
                    httpContext.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    return;
                }

                StorageAccountTableEntry requestEntry = new StorageAccountTableEntry
                                                            {
                                                                PartitionKey = requestBodyDoc.DocumentElement.Attributes["name"].Value,
                                                                RowKey = "",
                                                                Key = requestBodyDoc.DocumentElement.Attributes["key"].Value,
                                                                Capacity = capacity,
                                                                Threshold = threshold,
                                                                Used = 0
                                                            };

                //  Add or update the storage account information
                CloudStorageAccount cloudStorageAccount =
                    CloudStorageAccount.FromConfigurationSetting("StorageConnectionString");
                StorageAccountTableDataSource dataSource = new StorageAccountTableDataSource(cloudStorageAccount);
                StorageAccountTableContext context = StorageAccountTableContext.GetContext(cloudStorageAccount);
                StorageAccountTableEntry existingEntry = dataSource.GetStorageAccount(context, requestEntry.PartitionKey);

                if (existingEntry == null)
                {
                    dataSource.AddStorageAccountTableEntry(context, requestEntry);

                    httpContext.WriteInfoLine("xlfsAdminPutStorageAccount.ProcessRequest: Storage account added.");
                }
                else
                {
                    existingEntry.Key = requestEntry.Key;
                    existingEntry.Capacity = requestEntry.Capacity;
                    existingEntry.Threshold = requestEntry.Threshold;

                    dataSource.UpdateStorageAccountTableEntry(context, existingEntry);

                    httpContext.WriteInfoLine("xlfsAdminPutStorageAccount.ProcessRequest: Storage account updated.");
                }

                httpContext.Response.StatusCode = (int) HttpStatusCode.OK;
            }
            catch (Exception e)
            {
                httpContext.Response.StatusCode = (int) HttpStatusCode.InternalServerError;
                httpContext.WriteErrorLine(string.Format("xlfsAdminPutStorageAccount.ProcessRequest: Unhandled exception:\r\n{0}", e));
                throw;
            }
            finally
            {
                //  Any response code 400 and above indicates a failure.
                if (httpContext.Response.StatusCode >= (int)HttpStatusCode.BadRequest)
                {
                    XlfsAdminFdPutStorageAccountCounters.Counters.FailuresTotal.Increment();
                    XlfsAdminFdPutStorageAccountCounters.Counters.FailuresPerSecond.Increment();
                }

                httpContext.WriteInfoLine("xlfsAdminPutStorageAccount.ProcessRequest: Exit");
                httpContext.Flush();

                XlfsAdminFdPutStorageAccountCounters.Counters.AverageExecutionTime.IncrementBy(elapsed.TimeElapsed);
                XlfsAdminFdPutStorageAccountCounters.Counters.AverageExecutionTimeBase.Increment();
            }
        }

        public bool IsReusable
        {
            // Return false in case your Managed Handler cannot be reused for another request.
            // Usually this would be false in case you have some state information preserved per request.
            get { return true; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsFD\dll\UploadRequest.cs ===
using System;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Security.Cryptography;
using System.Web;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.ServiceRuntime;
using Microsoft.WindowsAzure.StorageClient;
using xonline.common.service;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsfd
{
    public class UploadRequest
    {
        private static readonly char[] BadChars = new[] {'/', '\\', '#', '?', '&', '+'};
        protected static CloudStorageAccount StorageAccount;
        protected static CloudStorageAccount PublicStorageAccount;
        protected static StorageAccountManager StorageAccountManager;

        #region Constants

        public const string UserXuidHeader = "x-ms-on-behalf-user-xuid";
        public const string TitleIdHeader = "x-ms-on-behalf-titleid";
        public const string AuthorizationHeader = "Authorization";
        public const string XAuthorizationHeader = "X-Authorization";
        public const string ContentMd5Header = "Content-MD5";
        public const string TransactionIdHeader = "x-ms-transaction-id";
        public const string AuthenticateHeader = "WWW-Authenticate";
        public const string FlowTokenHeader = "x-ms-flow-token";
        public const string XlfsVersionHeader = "x-ms-xlfs-version";
        public const string SgNonceHeader = "x-ms-sg-nonce";

        public const string AuthPrefix = "XBL1.0 x=";
        public const string AuthenticateValueFormatString = "XBL1.0 realm=\"XboxLIVE\", fault=\"{0}\", policy=\"TBD\"";

        #endregion

        #region Constructor

        static UploadRequest()
        {
            int refreshInterval = WebRole.StorageAccountRefreshIntervalMs;
            int updateUsedInterval = WebRole.UpdateUsedIntervalMs;

            StorageAccount = CloudStorageAccount.FromConfigurationSetting("StorageConnectionString");
            PublicStorageAccount =
                string.IsNullOrEmpty(RoleEnvironment.GetConfigurationSettingValue("PublicStorageConnectionString"))
                    ? null
                    : CloudStorageAccount.FromConfigurationSetting("PublicStorageConnectionString");

            StorageAccountManager = new StorageAccountManager(StorageAccount, refreshInterval, updateUsedInterval, new XlfsTraceFactory());
        }

        public UploadRequest()
        {
            // This code sets up a handler to update CloudStorageAccount instances when their corresponding
            // configuration settings change in the service configuration file.
            CloudStorageAccount.SetConfigurationSettingPublisher((configName, configSetter) =>
            {
                // Provide the configSetter with the initial value
                configSetter(RoleEnvironment.GetConfigurationSettingValue(configName));

                RoleEnvironment.Changed += (sender, arg) =>
                {
                    if (arg.Changes.OfType<RoleEnvironmentConfigurationSettingChange>()
                        .Any(change => (change.ConfigurationSettingName == configName)))
                    {
                        // The corresponding configuration setting has changed, propagate the value
                        if (!configSetter(RoleEnvironment.GetConfigurationSettingValue(configName)))
                        {
                            // In this case, the change to the storage account credentials in the
                            // service configuration is significant enough that the role needs to be
                            // recycled in order to use the latest settings. (for example, the 
                            // endpoint has changed)
                            RoleEnvironment.RequestRecycle();
                        }
                    }
                };
            });
        }

        #endregion

        #region File information and authorization methods

        /// <summary>
        /// Do all the work to extract all the information we care about
        /// from the specified request object.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="entry"></param>
        /// <returns></returns>
        protected static bool GetFileInfoFromRequest(HttpContext context, BlobTableEntry entry)
        {
            context.WriteInfoLine("UploadRequest.GetFileInfoFromRequest: Enter");

            try
            {
                string authHeader = GetAuthHeaderFromRequest(context.Request);

                if (authHeader == null)
                {
                    if (WebRole.SamlTokenRequired)
                    {
                        context.Response.StatusCode = (int) HttpStatusCode.Unauthorized;
                        context.Response.Headers.Add(AuthenticateHeader,
                                                     string.Format(AuthenticateValueFormatString, "no token in request"));
                        context.WriteErrorLine(
                            string.Format(
                                "UploadRequest.GetFileInfoFromRequest: No SAML token in request but SAML token is required.  Returning status code {0}.",
                                context.Response.StatusCode));
                        return false;
                    }

                    if (!GetFileInfoFromHeaders(context, entry))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!GetFileInfoFromAuthorizationHeader(authHeader, context, entry))
                    {
                        return false;
                    }
                }

                // Get the MD5 from the Content-MD5 header.
                string md5;
                if (!GetFileHashFromHeader(context, out md5))
                {
                    // Status code was already set by GetFileHashFromHeader.
                    return false;
                }

                entry.MD5 = md5;

                return true;
            }
            finally
            {
                context.WriteInfoLine("UploadRequest.GetFileInfoFromRequest: Exit");
            }
        }

        /// <summary>
        /// Retrieve the SAML token from either the Authorization or X-Authorization header.
        /// The header value must be prefixed with "XBL1.0 ".
        /// </summary>
        /// <param name="request"></param>
        /// <returns></returns>
        protected static string GetAuthHeaderFromRequest(HttpRequest request)
        {
            if (request.Headers[AuthorizationHeader] == null &&
                request.Headers[XAuthorizationHeader] == null)
            {
                return null;
            }

            // Use Authorization header first.
            string headerValue = (request.Headers[AuthorizationHeader] ?? request.Headers[XAuthorizationHeader]);

            return headerValue;
        }

        /// <summary>
        /// Read BlobTableEntry data from headers in the request.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="entry"></param>
        /// <returns></returns>
        private static bool GetFileInfoFromHeaders(HttpContext context, BlobTableEntry entry)
        {
            context.WriteInfoLine("UploadRequest.GetFileInfoFromHeaders: Enter");

            try
            {
                ulong xuid = GetUserXuidFromHeader(context);
                if (xuid == 0)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    context.Response.Headers.Add(AuthenticateHeader,
                                 string.Format(AuthenticateValueFormatString, "invalid user xuid in request"));
                    context.WriteErrorLine(
                        string.Format(
                            "UploadRequest.GetFileInfoFromHeaders: Found 0 xuid in header.  Returning status code {0}.",
                            context.Response.StatusCode));
                    return false;
                }

                entry.PartitionKey = xuid.ToString(FileTableLastUpdateEntry.XuidFormatString);

                uint titleId = GetTitleIdFromHeader(context);
                if (!WebRole.AllowedTitles.Contains(titleId))
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    context.Response.Headers.Add(AuthenticateHeader,
                                 string.Format(AuthenticateValueFormatString, "unauthorized titleid in request"));
                    context.WriteErrorLine(
                        string.Format(
                            "UploadRequest.GetFileInfoFromHeaders: Found unauthorized titleid (0x{0:X8}) in header.  Returning status code {1}.",
                            titleId,
                            context.Response.StatusCode));
                    return false;
                }

                entry.TitleId = unchecked((int)titleId);

                //  Get the transaction id.  This can be null, which just indicates the initial request
                //  for a file in which case generate a new one.
                entry.RowKey = context.Request.Headers[TransactionIdHeader];

                return true;
            }
            catch (ApplicationException e)
            {
                context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                context.WriteErrorLine(string.Format(
                                      "UploadRequest.GetFileInfoFromHeaders: ApplicationException caught: {0}", e));
                return false;
            }
            finally
            {
                context.WriteInfoLine("UploadRequest.GetFileInfoFromHeaders: Exit");
            }
        }

        /// <summary>
        /// Create a SAML token from the contents of the X-Authorization header, then extract
        /// the information we care about into a BlobTableEntry.
        /// </summary>
        /// <param name="authHeader"></param>
        /// <param name="context"></param>
        /// <param name="entry"></param>
        /// <returns></returns>
        private static bool GetFileInfoFromAuthorizationHeader(string authHeader, HttpContext context, BlobTableEntry entry)
        {
            try
            {
                context.WriteInfoLine("UploadRequest.GetFileInfoFromAuthorizationHeader: Enter");

                if (!GetFileInfoFromHeaders(context, entry))
                {
                    return false;
                }

                if (!ValidateFileInfoFromSamlToken(authHeader, context, entry))
                {
                    return false;
                }

                return true;
            }
            finally
            {
                context.WriteInfoLine("UploadRequest.GetFileInfoFromAuthorizationHeader: Exit");
            }
        }

        /// <summary>
        /// Get the user xuid as a ulong from the x-ms-user_xuid header.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        protected static ulong GetUserXuidFromHeader(HttpContext context)
        {
            context.WriteInfoLine("UploadRequest.GetUserXuidFromHeader: Enter");

            try
            {
                HttpRequest request = context.Request;

                // Get the header string.
                string xuidString = request.Headers[UserXuidHeader];
                if (string.IsNullOrEmpty(xuidString))
                {
                    throw new ApplicationException("The request did not contain a " + UserXuidHeader + " header.");
                }

                // GetSecurityToken Format: Xuid# 0x<hexnum>
                ulong xuid;
                if (XlfsUtilities.TryGetUlong(xuidString, out xuid) == false)
                {
                    throw new ApplicationException(
                        string.Format(
                            "UploadRequest.GetUserXuidFromHeader: {0} could not be parsed: {1}",
                            UserXuidHeader,
                            xuidString));
                }
                return xuid;

            }
            finally
            {
                context.WriteInfoLine("UploadRequest.GetUserXuidFromHeader: Exit");
            }
        }

        /// <summary>
        /// Get the title id from the x-ms-titleid header.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        protected static uint GetTitleIdFromHeader(HttpContext context)
        {
            context.WriteInfoLine("UploadRequest.GetTitleIdFromHeader: Enter");

            try
            {
                HttpRequest request = context.Request;

                // Get the header string.
                string titleIdString = request.Headers[TitleIdHeader];
                if (string.IsNullOrEmpty(titleIdString))
                {
                    throw new ApplicationException("The request did not contain an " + TitleIdHeader + " header.");
                }

                // GetSecurityToken Format: TitleID 0x<hexnum>
                uint titleId;
                if (XlfsUtilities.TryGetUint(titleIdString, out titleId) == false)
                {
                    throw new ApplicationException("The " + TitleIdHeader + " header did not contain a valid title id.");
                }

                return titleId;
            }
            finally
            {
                context.WriteInfoLine("UploadRequest.GetTitleIdFromHeader: Exit");
            }
        }

        /// <summary>
        /// Validate that the Saml Token's parameter match the contents
        /// the expected contents of the entry
        /// </summary>
        /// <param name="authHeader"></param>
        /// <param name="context"></param>
        /// <param name="entry"></param>
        /// <returns></returns>
        private static bool ValidateFileInfoFromSamlToken(
            string authHeader,
            HttpContext context,
            BlobTableEntry entry)
        {
            context.WriteInfoLine("UploadRequest.ValidateFileInfoFromSamlToken: Enter");

            try
            {
                // Validate that the prefix is correct.
                if (!authHeader.StartsWith(AuthPrefix))
                {
                    context.WriteErrorLine(
                        string.Format(
                            "UploadRequest.ValidateFileInfoFromSamlToken: Authorization header ({0}) did not contain the expected prefix.  Header should start with \"{1}\".",
                            authHeader,
                            AuthPrefix));
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    return false;
                }

                XblSamlToken token;
                try
                {
                    token = new XblSamlToken(authHeader.Substring(AuthPrefix.Length));

                    token.Validate(WebRole.SamlCertificateThumbprints, null);
                }
                catch (Exception e)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    context.Response.Headers.Add(AuthenticateHeader,
                                                 string.Format(AuthenticateValueFormatString, "invalid token in request"));
                    context.WriteErrorLine(
                        string.Format(
                            "UploadRequest.GetFileInfoFromAuthorizationHeader: Exception thrown while constructing and validating the SAML token:\r\n{0}",
                            e));
                    return false;
                }

                string temp;
                bool found = false;

                //
                // XUID - Loop through all users in the SAML token and log them.
                //

                for (int currentUserSlot = 0; currentUserSlot < 4; ++currentUserSlot)
                {
                    string xuidAttributeName = string.Format(XblSamlToken.name_attribute_xuid, currentUserSlot);

                    if (!token.TryGetAttributeValue(xuidAttributeName, out temp))
                    {
                        context.WriteInfoLine(
                            string.Format(
                                "UploadRequest.ValidateFileInfoFromSamlToken: Attribute {0} not found in SAML token.",
                                xuidAttributeName));
                        continue;
                    }

                    // GetSecurityToken Format: Xuid# 0x<hexnum>
                    ulong currentXuid;
                    if (XlfsUtilities.TryGetUlong(temp, out currentXuid) == false)
                    {
                        context.WriteWarningLine(
                            string.Format(
                                "UploadRequest.ValidateFileInfoFromSamlToken: Xuid attribute {0} could not be parsed: {1}",
                                xuidAttributeName, temp));
                        continue;
                    }

                    context.WriteInfoLine(
                        string.Format(
                            "UploadRequest.ValidateFileInfoFromSamlToken: XUID in slot {0} of SAML Token = {1:X16}", 
                            currentUserSlot, currentXuid));

                    if (entry.PartitionKey == currentXuid.ToString(FileTableLastUpdateEntry.XuidFormatString))
                    {
                        found = true;
                    }
                }

                if (found == false)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadRequest.ValidateFileInfoFromSamlToken: Did not find any xuids in the SAML token that matched the xuid in the header ({0}).  Returning status code {1}.",
                            entry.PartitionKey,
                            context.Response.StatusCode));
                    return false;
                }

                //
                // Title ID
                //

                if (!token.TryGetAttributeValue(XblSamlToken.name_attribute_titleid, out temp))
                {
                    context.WriteErrorLine("UploadRequest.ValidateFileInfoFromSamlToken: SAML token did not contain a title id.");
                }
                else
                {
                    // GetSecurityToken Format: TitleID 0x<hexnum>
                    uint titleId;
                    if (XlfsUtilities.TryGetUint(temp, out titleId))
                    {
                        context.WriteInfoLine(string.Format("UploadRequest.ValidateFileInfoFromSamlToken: Title ID in SAML Token = {0:X8}", titleId));
                    }
                    else
                    {
                        context.Response.StatusCode = (int) HttpStatusCode.BadRequest;
                        context.WriteErrorLine(
                            string.Format(
                                "UploadRequest.ValidateFileInfoFromSamlToken: Title Id string from SAML token (\"{0}\") could not be parsed as a hexadecimal number.  Returning status code {1}.",
                                temp,
                                context.Response.StatusCode));
                        return false;
                    }

                }

                return true;
            }
            finally
            {
                context.WriteInfoLine("UploadRequest.ValidateFileInfoFromSamlToken: Exit");
            }
        }

        #endregion

        /// <summary>
        /// Read the filename from the "fn" query string parameter.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        protected static string GetFilenameFromQueryString(HttpContext context)
        {
            context.WriteInfoLine("UploadRequest.GetFilenameFromQueryString: Enter");

            try
            {
                string filename = context.Request.QueryString["fn"];
                if (string.IsNullOrEmpty(filename))
                {
                    context.Response.StatusCode = (int) HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadRequest.GetFilenameFromQueryString: Null or empty filename.  Returning status code {0}.",
                            context.Response.StatusCode));
                    return null;
                }

                if (filename.Length >= 260)
                {
                    context.Response.StatusCode = (int) HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadRequest.GetFilenameFromQueryString: Filename too long.  Returning status code {0}.",
                            context.Response.StatusCode));
                    return null;
                }

                // Does the filename have nested URL encoded characters?  This will cause
                // problems when uploading the blob, so reject it here.
                if(filename != HttpUtility.UrlDecode(filename))
                {
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadRequest.GetFilenameFromQueryString: Filename contained nested URL-encoded characters.  Returning status code {0}.",
                            context.Response.StatusCode));
                    return null;
                }

                int badCharIndex = filename.IndexOfAny(BadChars);
                if(badCharIndex != -1)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadRequest.GetFilenameFromQueryString: Filename contained an invalid character: '{0}'.  Returning status code {1}.",
                            filename[badCharIndex],
                            context.Response.StatusCode));
                    return null;
                }

                context.WriteInfoLine(string.Format("UploadRequest.GetFilenameFromQueryString: Filename = \"{0}\".",
                                                    filename));

                return filename;
            }
            finally
            {
                context.WriteInfoLine("UploadRequest.GetFilenameFromQueryString: Exit");
            }
        }

        /// <summary>
        /// Read and validate the MD5 hash of the file from the Content-MD5 header of the request.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="fileHashEncoded"></param>
        /// <returns></returns>
        protected static bool GetFileHashFromHeader(HttpContext context, out string fileHashEncoded)
        {
            context.WriteInfoLine("UploadRequest.GetFileHashFromHeader: Enter");

            try
            {
                fileHashEncoded = context.Request.Headers[ContentMd5Header];
                if (string.IsNullOrEmpty(fileHashEncoded) && WebRole.Md5Enforced)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "A Content-MD5 was not supplied, but MD5 enforcement is turned on.  Returning status code {0}.",
                            context.Response.StatusCode));
                    fileHashEncoded = null;
                    return false;
                }

                byte[] fileHash;
                try
                {
                    fileHash = Convert.FromBase64String(fileHashEncoded);
                }
                catch (Exception e)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadBegin.ProcessRequest: Failed to convert file hash from base64 string to byte array:\r\n{0}\r\nReturning status code {1}.",
                            e,
                            context.Response.StatusCode));
                    fileHashEncoded = null;
                    return false;
                }

                // MD5.HashSize returns bits, not bytes.
                int expectedHashLength = MD5.Create().HashSize/8;

                if (fileHash.Length != expectedHashLength)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadBegin.ProcessRequest: Expected file hash length = {0}, actual file hash length = {1}.  Returning status code {2}.",
                            expectedHashLength,
                            fileHash.Length,
                            context.Response.StatusCode));
                    fileHashEncoded = null;
                    return false;
                }

                return true;
            }
            finally
            {
                context.WriteInfoLine("UploadRequest.GetFileHashFromHeader: Exit");
            }
        }

        /// <summary>
        /// Look up the FileTableLastUpdateEntry associated with a given BlobTableEntry.
        /// </summary>
        /// <param name="fileTableLastUpdateDataSource"></param>
        /// <param name="blobTableEntry"></param>
        /// <param name="uploadDate"></param>
        /// <returns></returns>
        protected FileTableLastUpdateEntry GetFileTableEntryFromBlobTableEntry(
            FileTableLastUpdateDataSource fileTableLastUpdateDataSource,
            BlobTableEntry blobTableEntry,
            DateTime uploadDate)
        {
            FileTableLastUpdateEntry fileTableEntry = new FileTableLastUpdateEntry();
            fileTableEntry.PartitionKey = uploadDate.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString);
            fileTableEntry.RowKey = string.Format(
                FileTableLastUpdateEntry.RowKeyFormatString,
                blobTableEntry.TitleId.ToString(FileTableLastUpdateEntry.TitleIdFormatString),
                blobTableEntry.PartitionKey,
                blobTableEntry.Filename
                );
            return fileTableLastUpdateDataSource.SelectFileTableEntry(fileTableEntry);
        }

        protected static char[] SlashChar = new [] {'/'};
        protected static char[] QuestionMarkChar = new[] { '?' };

        /// <summary>
        /// Constructs the full Sas URL.
        /// </summary>
        /// <param name="storageEndpointUri"></param>
        /// <param name="container"></param>
        /// <param name="blob"></param>
        /// <param name="signature"></param>
        /// <returns></returns>
        protected static string CreateSasUrl(Uri storageEndpointUri, string container, string blob, string signature)
        {
            UriBuilder sasUrlBuilder = new UriBuilder(storageEndpointUri);

            // In the local dev storage case the storage endpoint will have a path so
            // we can't just set the path directly, we need to append.  We already
            // trimmed off any trailing slash above, so we're safe to append without
            // any other fanciness.  In the cloud storage case, the path should already be
            // empty.
            string path = sasUrlBuilder.Path.TrimEnd(SlashChar);
            sasUrlBuilder.Path = path + string.Format("/{0}/{1}", container, blob);
            sasUrlBuilder.Query = signature.TrimStart(QuestionMarkChar);

            return sasUrlBuilder.ToString();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsFD\dll\WebRole.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.WindowsAzure.Diagnostics;
using Microsoft.WindowsAzure.ServiceRuntime;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsfd
{
    public class WebRole : RoleEntryPoint
    {
        /// <summary>
        /// Configurable value that indicates whether or not we enforce SAML tokens.
        /// If false, then SAML tokens in the request header are optional.
        /// </summary>
        private static bool? _samlTokenRequired = null;
        public static bool SamlTokenRequired
        {
            get
            {
                if (_samlTokenRequired.HasValue)
                {
                    return _samlTokenRequired.Value;
                }

                bool samlTokenRequired;
                string value = RoleEnvironment.GetConfigurationSettingValue("samlTokenRequired");
                if(bool.TryParse(value, out samlTokenRequired) == false)
                {
                    EventTrace.WriteEvent(
                        "SamlTokenRequired: Not Found or not Parseable. Defaulting to true"
                        );
                    samlTokenRequired = true;
                }
                _samlTokenRequired = samlTokenRequired;                
                return samlTokenRequired;
            }
        }

        /// <summary>
        /// Expiry time in minutes that place on SAS URLs.
        /// </summary>
        private static int? _sasExpiryMinutes = null;
        public static int SasExpiryMinutes
        {
            get
            {
                if (_sasExpiryMinutes.HasValue)
                {
                    return _sasExpiryMinutes.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("sasExpiryMinutes");
                int sasExpiryMinutes;

                // Make sure that the setting parses correctly and doesn't 
                // exceed the 1 hour limit normally allowed for SAS handles
                if (int.TryParse(value, out sasExpiryMinutes) == false ||
                    sasExpiryMinutes > 60)
                {
                    EventTrace.WriteEvent(
                        "SasExpiryMinutes: Not Found or not Parseable. Defaulting to 60"
                        );
                    sasExpiryMinutes = 55;
                }
                _sasExpiryMinutes = sasExpiryMinutes;
                return sasExpiryMinutes;
            }
        }

        /// <summary>
        /// Configured value that indicates whether or not we strictly enforce
        /// the MD5 hash of the file contents.
        /// </summary>
        private static bool? _md5Enforced = null;
        public static bool Md5Enforced
        {
            get
            {
                if (_md5Enforced.HasValue)
                {
                    return _md5Enforced.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("md5Enforced");
                bool md5Enforced;
                if (bool.TryParse(value, out md5Enforced) == false)
                {
                    EventTrace.WriteEvent(
                        "Md5Enforced: Not Found or not Parseable. Defaulting to true"
                        );
                    md5Enforced = true;
                }
                _md5Enforced = md5Enforced;                
                return md5Enforced;
            }
        }

        /// <summary>
        /// Returns the list of valid certificate thumbprints that will be
        /// accepted as SAML token signers.
        /// </summary>
        private static string [] _samlCertificateThumbprints = null;
        public static string [] SamlCertificateThumbprints
        {
            get
            {
                if (_samlCertificateThumbprints == null)
                {
                    _samlCertificateThumbprints = RoleEnvironment.GetConfigurationSettingValue("samlCertThumbprints").Split(';');
                }
                return _samlCertificateThumbprints;
            }
        }

        private static uint [] _allowedTitles = null; 
        public static uint [] AllowedTitles
        {
            get
            {
                if (_allowedTitles != null)
                {
                    return _allowedTitles;
                }

                string[] allowedTitleStrings = RoleEnvironment.GetConfigurationSettingValue("allowedTitles").Split(';');
                List<uint> allowedTitlesList = new List<uint>();

                foreach(string allowedTitleString in allowedTitleStrings)
                {
                    uint currentAllowedTitle;

                    if (allowedTitleString.StartsWith("0x"))
                    {
                        if (!uint.TryParse(allowedTitleString.Substring(2), NumberStyles.HexNumber, null,
                                           out currentAllowedTitle))
                        {
                            continue;
                        }
                    }
                    else
                    {
                        if (!uint.TryParse(allowedTitleString, out currentAllowedTitle))
                        {
                            continue;
                        }
                    }

                    allowedTitlesList.Add(currentAllowedTitle);
                }
                _allowedTitles = allowedTitlesList.ToArray();
                return _allowedTitles;
            }
        }

        private static bool? _defaultPageShowDetails = null;
        public static bool DefaultPageShowDetails
        {
            get
            {
                if (_defaultPageShowDetails.HasValue)
                {
                    return _defaultPageShowDetails.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("defaultPageShowDetails");
                bool defaultPageShowDetails;
                if (bool.TryParse(value, out defaultPageShowDetails) == false)
                {
                    EventTrace.WriteEvent(
                        "DefaultPageShowDetails: Not Found or Parseable. Defaulting to False"
                        );
                    defaultPageShowDetails = false;
                }
                _defaultPageShowDetails = defaultPageShowDetails;
                return defaultPageShowDetails;
            }
        }

        /// <summary>
        /// Specifies the interval, per storage account, that the
        /// Used value will be updated in storage.  The interval
        /// is just a simple count of value updates, and is 
        /// unrelated to elapsed time or size.
        /// </summary>
        private static int? _updateUsedIntervalMs = null;
        public static int UpdateUsedIntervalMs
        {
            get
            {
                if(_updateUsedIntervalMs.HasValue)
                {
                    return _updateUsedIntervalMs.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("updateUsedIntervalMs");
                int updateUsedInterval;
                if (int.TryParse(value, out updateUsedInterval) == false)
                {
                    EventTrace.WriteEvent(
                        "UpdateUsedIntervalCountMs: Not Found or Parseable. Defaulting to False"
                        );
                    updateUsedInterval = 1000;
                }
                _updateUsedIntervalMs = updateUsedInterval;
                return updateUsedInterval;
            }
        }
        /// <summary>
        /// Refresh interval time in milliseconds for reloading information from StorageAccountTable.
        /// </summary>
        private static int? _storageAccountRefreshIntervalMs = null;
        public static int StorageAccountRefreshIntervalMs
        {
            get
            {
                if (_storageAccountRefreshIntervalMs.HasValue)
                {
                    return _storageAccountRefreshIntervalMs.Value;
                }

                string value = RoleEnvironment.GetConfigurationSettingValue("storageAccountRefreshIntervalMs");
                EventTrace.AppendInfoLine(
                    string.Format(
                        "WebRole.StorageAccountRefreshIntervalMs: Value of storageAccountRefreshIntervalMs setting = {0}",
                        value));

                // Make sure that the setting parses correctly
                int storageAccountRefreshIntervalMs;
                if (int.TryParse(value, out storageAccountRefreshIntervalMs) == false)
                {
                    EventTrace.WriteEvent(
                        "WebRole.StorageAccountRefreshIntervalMs: Not Found or not Parseable. Defaulting to 60000"
                        );
                    storageAccountRefreshIntervalMs = 60000;
                }

                _storageAccountRefreshIntervalMs = storageAccountRefreshIntervalMs;
                return storageAccountRefreshIntervalMs;
            }
        }

        /// <summary>
        /// Write an event to the main event trace
        /// </summary>
        /// <param name="msg"></param>
        private static XlfsTrace EventTrace = new XlfsTrace("WebRole");

        /// <summary>
        /// Main Role entry point
        /// </summary>
        /// <returns></returns>
        public override bool OnStart()
        {
            XlfsTrace trace = new XlfsTrace("WebRole");
            trace.AppendInfoLine("WebRole.OnStart: Enter");

            try
            {
                //        #region upload begin perf counters
                //        diagConfig.PerformanceCounters.DataSources.Add(new PerformanceCounterConfiguration()
                //        {
                //            CounterSpecifier = String.Format(@"\XBL {0}(*)\{1}", PerformanceCounterStrings.uploadBeginCategory, PerformanceCounterStrings.uploadBeginRequestsPerSec),
                //            SampleRate = TimeSpan.FromSeconds(10)
                //        });

                //
                // Verify that DiagnosticsConnectionString and StorageConnectionString
                // are valid and can be used to talk to storage.  We don't validate
                // PublicStorageConnectionString because by definition this is an
                // outward facing connection string
                //);

                if (!this.VerifyConnectionString("DiagnosticsConnectionString"))
                {
                    return false;
                }

                //
                // Install custom performance counters.
                //

                XlfsPerformanceCounterInstall installer = new XlfsPerformanceCounterInstall();
                installer.Install(GetType());

                //
                // Now set up diagnostics.
                //

                DiagnosticMonitorConfiguration diagConfig = DiagnosticMonitor.GetDefaultInitialConfiguration();

                diagConfig.WindowsEventLog.DataSources.Add("Application!*");
                diagConfig.WindowsEventLog.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);

                diagConfig.Logs.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);
                diagConfig.Logs.ScheduledTransferLogLevelFilter = LogLevel.Information;

                // IIS 7.0 Logs
                diagConfig.Directories.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);

                DiagnosticMonitor.Start("DiagnosticsConnectionString", diagConfig);

                //
                // Now enable crash dumps
                //
                CrashDumps.EnableCollection(true);

                // For information on handling configuration changes
                // see the MSDN topic at http://go.microsoft.com/fwlink/?LinkId=166357.
                RoleEnvironment.Changing += RoleEnvironmentChanging;
                RoleEnvironment.Changed += RoleEnvironmentChanged;

                return base.OnStart();
            }
            finally
            {
                trace.AppendInfoLine("WebRole.OnStart: Exit");
                trace.Flush();
            }
        }

        public override void OnStop()
        {
            XlfsTrace trace = new XlfsTrace("WebRole");
            trace.AppendInfoLine("WebRole.OnStop: Enter");

            try
            {
                //
                // Uninstall custom performance counters.
                //

                XlfsPerformanceCounterInstall installer = new XlfsPerformanceCounterInstall();
                installer.Uninstall(GetType());

                base.OnStop();
            }
            finally
            {
                trace.AppendInfoLine("WebRole.OnStop: Exit");
                trace.Flush();
            }
        }

        private void RoleEnvironmentChanging(object sender, RoleEnvironmentChangingEventArgs e)
        {
            XlfsTrace trace = new XlfsTrace("WebRole");
            trace.AppendInfoLine("WebRole.RoleEnvironmentChanging: Enter");

            try
            {
                // If a configuration setting is not changing
                if (e.Changes.Any(change => change is RoleEnvironmentConfigurationSettingChange) == false)
                {
                    // Nothing to do
                    return;
                }

                // See what is changing
                foreach (RoleEnvironmentChange change in e.Changes)
                {
                    if ((change is RoleEnvironmentConfigurationSettingChange) == false)
                    {
                        continue;
                    }

                    // See if are going to allow the change. We won't accecept any changes
                    // to anything with the 'ConnectionString' as part of the name
                    RoleEnvironmentConfigurationSettingChange settingChange =
                        (RoleEnvironmentConfigurationSettingChange) change;
                    if (settingChange.ConfigurationSettingName.Contains("ConnectionString") == true)
                    {
                        trace.WriteEvent(
                            string.Format(
                                "RoleEnvironmentChange: Resetting due to change to {0}",
                                settingChange.ConfigurationSettingName
                                ));
                        e.Cancel = true;
                    }
                    else
                    {
                        trace.AppendInfoLine(
                            string.Format(
                                "RoleEnvironmentChange: Changing {0}",
                                settingChange.ConfigurationSettingName
                                ));
                    }
                }
            }
            finally
            {
                trace.AppendInfoLine("WebRole.RoleEnvironmentChanging: Exit");
                trace.Flush();
            }
        }

        private void RoleEnvironmentChanged(object sender, RoleEnvironmentChangedEventArgs e)
        {
                        XlfsTrace trace = new XlfsTrace("WebRole");
            trace.AppendInfoLine("WebRole.RoleEnvironmentChanging: Enter");

            try
            {
                // See what changed
                foreach (RoleEnvironmentChange change in e.Changes)
                {
                    if ((change is RoleEnvironmentConfigurationSettingChange) == false)
                    {
                        continue;
                    }

                    RoleEnvironmentConfigurationSettingChange settingChange =
                        (RoleEnvironmentConfigurationSettingChange) change;
                    trace.AppendInfoLine(
                        string.Format(
                            "RoleEnvironmentChange: Changed {0}",
                            settingChange.ConfigurationSettingName
                            ));
                    switch (settingChange.ConfigurationSettingName)
                    {
                        case "sasExpiryMinutes":
                            _sasExpiryMinutes = null;
                            break;
                        case "samlTokenRequired":
                            _samlTokenRequired = null;
                            break;
                        case "md5Enforced":
                            _md5Enforced = null;
                            break;
                        case "samlCertThumbprints":
                            _samlCertificateThumbprints = null;
                            break;
                        case "allowedTitles":
                            _allowedTitles = null;
                            break;
                        case "defaultPageShowDetails":
                            _defaultPageShowDetails = null;
                            break;
                        case "storageAccountRefreshIntervalMs":
                            _storageAccountRefreshIntervalMs = null;
                            break;
                        case "updateUsedIntervalMs":
                            _updateUsedIntervalMs = null;
                            break;
                    }
                }
            }
            finally
            {
                trace.AppendInfoLine("WebRole.RoleEnvironmentChanged: Exit");
                trace.Flush();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsFD\dll\UploadBegin.cs ===
using System;
using System.Net;
using System.Web;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsfd
{
    /// <summary>
    /// This handler moves the input stream into blob storage, and updates
    /// the XUID table to contain information about the blob.
    /// </summary>
    public class UploadBegin : UploadRequest, IHttpHandler
    {
        #region Constructors

        #endregion

        #region IHttpHandler Members

        public bool IsReusable
        {
            // Return false in case your Managed Handler cannot be reused for another request.
            // Usually this would be false in case you have some state information preserved per request.
            get { return true; }
        }

        /// <summary>
        /// Main entry point into the UploadBegin operation.
        /// </summary>
        /// <param name="context"></param>
        public void ProcessRequest(HttpContext context)
        {
            var elapsed = new XlfsRequestTimeElapsed();

            try
            {
                context.SetTrace(new XlfsTrace("UploadBegin", elapsed));
                context.WriteInfoLine("UploadBegin.ProcessRequest: Enter");

                XlfsFdUploadBeginCounters.Counters.RequestsTotal.Increment();
                XlfsFdUploadBeginCounters.Counters.RequestsPerSecond.Increment();

                HttpResponse response = context.Response;
                response.Headers.Add(XlfsVersionHeader, XlfsTrace.AssemblyVersion);

                var blobTableEntryFromRequest = new BlobTableEntry();

                // This block of code should return every piece of data
                // from the request that goes into a blob table entry.
                // All of the SAML token to header verification is done
                // inside here as well.  If we return successfully, we
                // have been authenticated and have all required pieces
                // of information so we can continue on with the request.

                try
                {
                    if (!GetFileInfoFromRequest(context, blobTableEntryFromRequest))
                    {
                        // If GetFileInfoFromRequest returns false, then
                        // something failed and context.Response has been
                        // filled out with status code.
                        context.WriteErrorLine(
                            string.Format(
                                "UploadBegin.ProcessRequest: GetFileInfoFromRequest returned false.  Returning status code {0}.",
                                response.StatusCode));
                        return;
                    }
                }
                catch (Exception e)
                {
                    response.StatusCode = (int) HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadBegin.ProcessRequest: Unhandled exception from GetFileInfoFromRequest():\r\n{0}\r\nReturning status code {1}.",
                            e, response.StatusCode));
                    return;
                }

                // Get the filename from the query string.
                blobTableEntryFromRequest.Filename = GetFilenameFromQueryString(context);
                if (string.IsNullOrEmpty(blobTableEntryFromRequest.Filename))
                {
                    // Status code was already set by GetFilenameFromQueryString.
                    return;
                }

                // Now we examine the FileTable to see if the client is trying to
                // upload a file that has already been commited, in which case we
                // just return a 304 Not Modified.

                CloudStorageAccount blobStorageAccount = null;
                CloudBlobClient blobClient;
                CloudBlobContainer container;

                var fileTableDataSource = new FileTableLastUpdateDataSource();
                FileTableLastUpdateEntry fileTableEntry = GetFileTableEntryFromBlobTableEntry(fileTableDataSource,
                                                                                              blobTableEntryFromRequest,
                                                                                              DateTime.UtcNow);
                if (fileTableEntry != null)
                {
                    context.WriteInfoLine(string.Format(
                                "UploadBegin.ProcessRequest: Found a FileTableEntry for \"{0}\".", blobTableEntryFromRequest.Filename));

                    // Get the storage account and container for the existing file.
                    blobStorageAccount = StorageAccountManager.Lookup(fileTableEntry.StorageAccount);
                    if (blobStorageAccount == null)
                    {
                        // We found a file table entry that specfies a storage account that
                        // isn't currently in the StorageAccountTable.  This is OK because
                        // the replacement file will end up in a valid storage account.
                        // Just write out a warning and move along.
                        context.WriteWarningLine(
                            string.Format(
                                "UploadBegin.ProcessRequest: Found a FileTableEntry for \"{0}\" that referenced an unconfigured storage account.  This is only a warning, and the request was allowed to continue.",
                                fileTableEntry.Filename));
                    }
                    else
                    {
                        blobClient = blobStorageAccount.CreateCloudBlobClient();
                        container =
                            blobClient.GetContainerReference(
                                blobTableEntryFromRequest.TitleId.ToString(BlobTableEntry.ContainerBlobFormatString));

                        // Get the blob associated with the FileTableEntry
                        string blobName = XlfsUtilities.GetBlobNameFromFileTableEntry(fileTableEntry);
                        CloudBlob blob = container.GetBlobReference(blobName);

                        try
                        {
                            blob.FetchAttributes();

                            string md5FromBlob = blob.Properties.ContentMD5;

                            // Now compare.
                            if (blobTableEntryFromRequest.MD5 == md5FromBlob)
                            {
                                response.StatusCode = (int) HttpStatusCode.NotModified;
                                context.WriteInfoLine("UploadBegin.ProcessRequest: File not modified.");
                                return;
                            }
                            else if (blobTableEntryFromRequest.RowKey != null &&
                                     blobTableEntryFromRequest.RowKey == fileTableEntry.TransactionId)
                            {
                                // If the transaction ids are the same but file hash is different, then this is an error
                                response.StatusCode = (int) HttpStatusCode.BadRequest;
                                context.WriteErrorLine(
                                    string.Format(
                                        "UploadBegin.ProcessRequest: The request is trying to reuse a transaction id that has already been committed.  Returning status code {0}.",
                                        response.StatusCode));
                                return;
                            }
                        }
                        catch (StorageClientException)
                        {
                            // If we get here, it means that we have a FileTableEntry without
                            // a corresponding blob, which should never happen.  However, this 
                            // isn't a fatal error, we can just delete the offending
                            // FileTableEntry and continue.

                            fileTableDataSource.DeleteFileTableEntry(fileTableEntry);

                            context.WriteWarningLine(
                                string.Format(
                                    "UploadBegin.ProcessRequest: Found a FileTableEntry for \"{0}\" with no corresponding file in storage.  The FileTableEntry was removed and the request was allowed to continue.",
                                    blobName));
                        }
                    }
                }

                // If we don't have a blob storage account yet, get one.
                if (blobStorageAccount == null || string.IsNullOrEmpty(blobStorageAccount.Credentials.AccountName))
                {
                    // Figure out which storage account this blob will be stored in.
                    blobStorageAccount = StorageAccountManager.GetNextStorageAccount(context.GetTrace());
                    if (blobStorageAccount == null || string.IsNullOrEmpty(blobStorageAccount.Credentials.AccountName))
                    {
                        const string message =
                            "UploadBegin.ProcessRequest: A request is returning Service Unavailable either" +
                            " because there are no configured blob storage accounts, or all configured blob" +
                            " storage accounts are currently exceeding their threshold.  Provision additional" +
                            " storage accounts and then update the storage account configuration via the admin" +
                            " front door's xlfsAdminPutStorageAccount API.";
                        context.WriteEvent(message);
                        context.WriteErrorLine(message);
                        response.StatusCode = (int)HttpStatusCode.ServiceUnavailable;
                        return;
                    }
                }

                blobTableEntryFromRequest.StorageAccount = blobStorageAccount.Credentials.AccountName;

                // Create the data source object.
                var dataSource = new BlobTableDataSource();

                // If there wasn't a transaction id in the request, then this is a 
                // new upload request.
                if (blobTableEntryFromRequest.RowKey == null)
                {
                    // Generate a new transaction id.
                    blobTableEntryFromRequest.RowKey = Guid.NewGuid().ToString("N");
                    context.AddAttribute("transactionId", blobTableEntryFromRequest.RowKey);
                    context.WriteInfoLine("UploadBegin.ProcessRequest:  Generated new transaction id: " + blobTableEntryFromRequest.RowKey);

                    // Populate the row in the blob table.
                    dataSource.AddBlobTableEntry(blobTableEntryFromRequest);
                }
                else
                {
                    context.AddAttribute("transactionId", blobTableEntryFromRequest.RowKey);
                    context.WriteInfoLine("UploadBegin.ProcessRequest:  Using transaction id passed up by the client: " + blobTableEntryFromRequest.RowKey);

                    // The request contained a transaction id.  If this transaction id
                    // is not found in the blob table return an error.
                    BlobTableEntry blobTableEntryFromStorage =
                        dataSource.SelectBlobTableEntry(blobTableEntryFromRequest);
                    if (blobTableEntryFromStorage == null)
                    {
                        response.StatusCode = (int) HttpStatusCode.BadRequest;
                        context.WriteErrorLine(
                            string.Format(
                                "UploadBegin.ProcessRequest: Request contained a transaction id, but the transaction id was not found in the BlobTable.  Returning status code {0}.",
                                response.StatusCode));
                        return;
                    }

                    blobStorageAccount = StorageAccountManager.Lookup(blobTableEntryFromStorage.StorageAccount);
                    if (blobStorageAccount == null)
                    {
                        response.StatusCode = (int) HttpStatusCode.BadRequest;
                        context.WriteErrorLine(
                            string.Format(
                                "UploadBegin.ProcessRequest: Request contained a transaction id, but the request in progress references a storage account that is not configured.  Return status code {0}.",
                                response.StatusCode));
                        return;
                    }

                    // Do the filenames match?)
                    if (blobTableEntryFromStorage.Filename != blobTableEntryFromRequest.Filename)
                    {
                        response.StatusCode = (int) HttpStatusCode.BadRequest;
                        context.WriteErrorLine(
                            string.Format(
                                "UploadBegin.ProcessRequest: Request contained a transaction id, but the filename in the request ({0}) did not match the filename in the BlobTable ({1}).  Returning status code {2}.",
                                blobTableEntryFromRequest.Filename,
                                blobTableEntryFromStorage.Filename,
                                response.StatusCode));
                        return;
                    }

                    // Do the MD5s match?
                    if (blobTableEntryFromStorage.MD5 != blobTableEntryFromRequest.MD5)
                    {
                        response.StatusCode = (int) HttpStatusCode.BadRequest;
                        context.WriteErrorLine(
                            string.Format(
                                "UploadBegin.ProcessRequest: Request contained a transaction id, but the MD5 in the request did not match the MD5 in the BlobTable.  Returning status code {0}.",
                                response.StatusCode));
                        return;
                    }

                    // Do the title ids match?
                    if (blobTableEntryFromStorage.TitleId != blobTableEntryFromRequest.TitleId)
                    {
                        response.StatusCode = (int) HttpStatusCode.BadRequest;
                        context.WriteErrorLine(
                            string.Format(
                                "UploadBegin.ProcessRequest: Request contained a transaction id, but the title id in the request ({0:x8}) did not match the title id in the BlobTable ({1:x8}).  Returning status code {2}.",
                                blobTableEntryFromRequest.TitleId,
                                blobTableEntryFromStorage.TitleId,
                                response.StatusCode));
                        return;
                    }
                }

                // Initialize the blob container
                blobClient = blobStorageAccount.CreateCloudBlobClient();
                container =
                    blobClient.GetContainerReference(
                        blobTableEntryFromRequest.TitleId.ToString(BlobTableEntry.ContainerBlobFormatString));
                container.CreateIfNotExist();

                //  Retrieve the SAS URL to return to the client, and put it in the Location header.
                string fullBlobName = XlfsUtilities.GetBlobNameFromBlobTableEntry(blobTableEntryFromRequest);
                CloudBlockBlob blockBlob = container.GetBlockBlobReference(fullBlobName);
                context.WriteInfoLine("UploadBegin.ProcessRequest:  Blob name = " + fullBlobName);

                var policy = new SharedAccessPolicy();
                policy.Permissions = SharedAccessPermissions.Write;
                policy.SharedAccessExpiryTime = DateTime.UtcNow.AddMinutes(WebRole.SasExpiryMinutes);

                string signature = blockBlob.GetSharedAccessSignature(policy);

                Uri blobEndpoint = PublicStorageAccount == null
                                       ? blobStorageAccount.BlobEndpoint
                                       : PublicStorageAccount.BlobEndpoint;
                string sasUrl = CreateSasUrl(blobEndpoint, container.Name, fullBlobName, signature);
                context.WriteInfoLine(string.Format("UploadBegin.ProcessRequest:  SAS URL = \"{0}\".", sasUrl));

                response.Headers.Add(HttpResponseHeader.Location.ToString(), sasUrl);
                response.Headers.Add(TransactionIdHeader, blobTableEntryFromRequest.RowKey);

                response.StatusCode = (int) HttpStatusCode.NoContent;
            }
            catch (Exception e)
            {
                context.Response.StatusCode = (int) HttpStatusCode.InternalServerError;
                context.WriteErrorLine(string.Format("UploadBegin.ProcessRequest: Unhandled exception:\r\n{0}", e));
                return;
            }
            finally
            {
                //  Any response code 400 and above indicates a failure.
                if(context.Response.StatusCode >= (int)HttpStatusCode.BadRequest)
                {
                    XlfsFdUploadBeginCounters.Counters.FailuresTotal.Increment();
                    XlfsFdUploadBeginCounters.Counters.FailuresPerSecond.Increment();
                }

                context.WriteInfoLine("UploadBegin.ProcessRequest: Exit");
                context.Flush();

                XlfsFdUploadBeginCounters.Counters.AverageExecutionTime.IncrementBy(elapsed.TimeElapsed);
                XlfsFdUploadBeginCounters.Counters.AverageExecutionTimeBase.Increment();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsFD\dll\UploadEnd.cs ===
using System;
using System.Net;
using System.Threading;
using System.Web;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsfd
{
    public class UploadEnd : UploadRequest, IHttpHandler
    {
        #region IHttpHandler Members

        public bool IsReusable
        {
            // Return false in case your Managed Handler cannot be reused for another request.
            // Usually this would be false in case you have some state information preserved per request.
            get { return true; }
        }

        public void ProcessRequest(HttpContext context)
        {
            XlfsRequestTimeElapsed elapsed = new XlfsRequestTimeElapsed();

            context.SetTrace(new XlfsTrace("UploadEnd", elapsed));
            context.WriteInfoLine("UploadEnd.ProcessRequest: Enter");

            try
            {
                XlfsFdUploadEndCounters.Counters.RequestsTotal.Increment();
                XlfsFdUploadEndCounters.Counters.RequestsPerSecond.Increment();

                HttpResponse response = context.Response;
                response.Headers.Add(XlfsVersionHeader, XlfsTrace.AssemblyVersion);
                
                BlobTableEntry blobTableEntryFromRequest = new BlobTableEntry();

                // Pull information out of the request
                try
                {
                    if (!GetFileInfoFromRequest(context, blobTableEntryFromRequest))
                    {
                        // If GetFileInfoFromRequest returns false, then
                        // something failed and context.Response has been
                        // filled out with status code.
                        context.WriteErrorLine(
                            string.Format(
                                "UploadEnd.ProcessRequest: GetFileInfoFromRequest returned false.  Returning status code {0}.",
                                response.StatusCode));
                        return;
                    }
                }
                catch (Exception e)
                {
                    response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadEnd.ProcessRequest: Unhandled exception from GetFileInfoFromRequest():\r\n{0}\r\nReturning status code {1}.",
                            e, response.StatusCode));
                    return;
                }

                // Request must have the transaction id.
                if (string.IsNullOrEmpty(blobTableEntryFromRequest.RowKey))
                {
                    response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadEnd.ProcessRequest:  Empty transaction id header.  Returning status code {0}.",
                            response.StatusCode));
                    return;
                }

                // Fetch the row from blobTableEntry
                BlobTableDataSource blobTableDataSource = new BlobTableDataSource();
                BlobTableEntry blobTableEntryFromTableStorage = blobTableDataSource.SelectBlobTableEntry(blobTableEntryFromRequest);
                if (blobTableEntryFromTableStorage == null)
                {
                    response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadEnd.ProcessRequest: Provided transaction id was not found in the blob table.  Returning status code {0}.",
                            response.StatusCode));
                    return;
                }

                // Make sure the title ids match.
                if (blobTableEntryFromRequest.TitleId != blobTableEntryFromTableStorage.TitleId)
                {
                    response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadEnd.ProcessRequest: The title id specified in the request ({0:x8}) did not equal the title id stored in the blob table during the UploadBegin request ({1:x8}).  Returning status code {2}.",
                            blobTableEntryFromRequest.TitleId,
                            blobTableEntryFromTableStorage.TitleId,
                            response.StatusCode));
                    return;
                }

                // Make sure the blob table entry had a valid storage account.
                if(string.IsNullOrEmpty(blobTableEntryFromTableStorage.StorageAccount))
                {
                    response.StatusCode = (int) HttpStatusCode.InternalServerError;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadEnd.ProcessRequest: The blob table entry retrieved from table storage had a null or empty storage account.  Returning status code {0}.",
                            response.StatusCode));
                    return;
                }

                if(StorageAccountManager.Lookup(blobTableEntryFromTableStorage.StorageAccount) == null)
                {
                    response.StatusCode = (int) HttpStatusCode.InternalServerError;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadEnd.ProcessRequest: The blob table entry retrieved from table storage referenced a storage account ({0}) that is not configured in the storage account table..  Returning status code {1}.",
                            blobTableEntryFromTableStorage.StorageAccount,
                            response.StatusCode));
                    return;
                }

                //  Look up the blob in storage and fetch attributes and properties.
                blobTableEntryFromRequest.Filename = blobTableEntryFromTableStorage.Filename;
                blobTableEntryFromRequest.StorageAccount = blobTableEntryFromTableStorage.StorageAccount;
                CloudBlob blob = XlfsUtilities.GetBlobFromBlobTableEntry(StorageAccountManager,
                                                                         blobTableEntryFromRequest);

                try
                {
                    blob.FetchAttributes();
                }
                catch (StorageClientException)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        string.Format(
                            "UploadEnd.ProcessRequest: Specified blob ({0}) was not found in storage.  Returning status code {1}.",
                            blob.Uri,
                            response.StatusCode));
                    return;
                }

                // Make sure the MD5 is consistent in all locations (header of this request, blob metadata, blob table)
                if (WebRole.Md5Enforced)
                {
                    // Get the MD5 from the Content-MD5 header.
                    string md5FromHeader = blobTableEntryFromRequest.MD5;

                    // Get the MD5 from BlobTableEntry
                    string md5FromTable = blobTableEntryFromRequest.MD5;
                    if (string.IsNullOrEmpty(md5FromTable))
                    {
                        context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                        context.WriteErrorLine(
                            string.Format(
                                "UploadEnd.ProcessRequest: File hash value from blob table was empty.  Returning status code {0}.",
                                response.StatusCode));
                        return;
                    }

                    // Get the MD5 from blob storage metadata
                    string md5FromBlob = blob.Properties.ContentMD5;
                    if (string.IsNullOrEmpty(md5FromBlob))
                    {
                        context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                        context.WriteErrorLine(
                            string.Format(
                                "UploadEnd.ProcessRequest: File hash value from blob was empty.  Returning status code {0}.",
                                response.StatusCode));
                        return;
                    }

                    // Now make sure they all match.
                    if ((md5FromHeader != md5FromBlob) || md5FromHeader != md5FromTable)
                    {
                        context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                        context.WriteErrorLine(
                            string.Format(
                                "UploadEnd.ProcessRequest: File hashes were not equal.\r\n\tFrom header: {0}\r\n\tFrom blob: {1}\r\n\tFrom blob table: {2}\r\nReturning status code {3}.",
                                md5FromHeader,
                                md5FromBlob,
                                md5FromTable,
                                response.StatusCode));
                        return;
                    }
                }

                // Get the final blob size so we can store it in the FileTable.
                long size = blob.Attributes.Properties.Length;

                // We need to serialize this block of code so that we don't get two
                // calls to AddFileTableEntry for the same file table entry.
                Mutex fileTableEntryMutex = new Mutex(false,
                                                      blobTableEntryFromRequest.PartitionKey + 
                                                      blobTableEntryFromRequest.TitleId +
                                                      blobTableEntryFromRequest.Filename);

                CloudBlockBlob blobToDelete = null;

                fileTableEntryMutex.WaitOne();
                try
                {
                    FileTableLastUpdateDataSource fileTableDataSource = new FileTableLastUpdateDataSource();

                    // See if this entry already exists.
                    FileTableLastUpdateEntry fileTableEntryFromStorage =
                        GetFileTableEntryFromBlobTableEntry(fileTableDataSource, blobTableEntryFromRequest,
                                                            blob.Properties.LastModifiedUtc);
                    if (fileTableEntryFromStorage == null)
                    {
                        //  This is an initial upload, populate.
                        FileTableLastUpdateEntry fileTableEntry = new FileTableLastUpdateEntry();

                        // RowKey is string.Format("{0}:{1}.{2}", TitleId.ToString("X8"), Xuid.ToString("X16"), FileName)
                        fileTableEntry.PartitionKey =
                            blob.Properties.LastModifiedUtc.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString);
                        fileTableEntry.RowKey = string.Format(
                            FileTableLastUpdateEntry.RowKeyFormatString,
                            blobTableEntryFromRequest.TitleId.ToString(FileTableLastUpdateEntry.TitleIdFormatString),
                            blobTableEntryFromRequest.PartitionKey,
                            blobTableEntryFromRequest.Filename
                            );

                        fileTableEntry.TitleId = blobTableEntryFromRequest.TitleId;
                        fileTableEntry.Filename = blobTableEntryFromRequest.Filename;
                        fileTableEntry.TransactionId = blobTableEntryFromRequest.RowKey;
                        fileTableEntry.StorageAccount = blobTableEntryFromRequest.StorageAccount;
                        fileTableEntry.Created = blob.Properties.LastModifiedUtc;
                        fileTableEntry.LastUpdate = blob.Properties.LastModifiedUtc;
                        fileTableEntry.Size = size;
                        fileTableEntry.UserXuid = long.Parse(blobTableEntryFromRequest.PartitionKey, System.Globalization.NumberStyles.HexNumber);

                        fileTableDataSource.AddFileTableEntry(fileTableEntry);

                        StorageAccountManager.UpdateUsed(fileTableEntry.StorageAccount, fileTableEntry.Size.Value, context.GetTrace());
                    }
                    else
                    {
                        long oldSize = fileTableEntryFromStorage.Size.HasValue
                                           ? fileTableEntryFromStorage.Size.Value
                                           : 0;

                        // Get a reference to the previous version of the blob, so we can delete it below.
                        blobToDelete = XlfsUtilities.GetBlobFromFileTableLastUpdateEntry(StorageAccountManager,
                                                                                         fileTableEntryFromStorage);

                        fileTableEntryFromStorage.TransactionId = blobTableEntryFromRequest.RowKey;
                        fileTableEntryFromStorage.LastUpdate = blob.Properties.LastModifiedUtc;
                        fileTableEntryFromStorage.Size = size;
                        fileTableEntryFromStorage.StorageAccount = blobTableEntryFromRequest.StorageAccount;

                        fileTableDataSource.UpdateFileTableEntry(fileTableEntryFromStorage);

                        StorageAccountManager.UpdateUsed(fileTableEntryFromStorage.StorageAccount, size - oldSize, context.GetTrace());
                    }
                }
                finally
                {
                    fileTableEntryMutex.ReleaseMutex();
                }

                // If this was an update, remove the previous version of the blob from blob storage.
                if (blobToDelete != null)
                {
                    // Don't block the response on doing this delete.
                    blobToDelete.BeginDeleteIfExists(DeleteBlobCallback, blobToDelete);
                }

                // We can now remove the entry from the blob table.
                blobTableDataSource.DeleteBlobTableEntry(blobTableEntryFromTableStorage);

                response.StatusCode = (int) HttpStatusCode.NoContent;
            }
            catch (Exception e)
            {
                context.Response.StatusCode = (int) HttpStatusCode.InternalServerError;
                context.WriteErrorLine(string.Format("UploadEnd.ProcessRequest: Unhandled exception:\r\n{0}", e));
                return;
            }
            finally
            {
                if(context.Response.StatusCode >= (int)HttpStatusCode.BadRequest)
                {
                    XlfsFdUploadEndCounters.Counters.FailuresTotal.Increment();
                    XlfsFdUploadEndCounters.Counters.FailuresPerSecond.Increment();
                }

                context.WriteInfoLine("UploadEnd.ProcessRequest: Exit");
                context.Flush();

                XlfsFdUploadEndCounters.Counters.AverageExecutionTime.IncrementBy(elapsed.TimeElapsed);
                XlfsFdUploadEndCounters.Counters.AverageExecutionTimeBase.Increment();
            }
        }

        /// <summary>
        /// Cleanup of previous version of blob is done in this
        /// background callback method.
        /// </summary>
        /// <param name="asyncResult"></param>
        static void DeleteBlobCallback(IAsyncResult asyncResult)
        {
            XlfsTrace xlfsTrace = new XlfsTrace("DeleteBlobCallback");
            xlfsTrace.AppendInfoLine("Enter");

            try
            {
                // We don't really need to act here on success or failure.
                // Eventually we will have a worker role to do a better job of cleanup,
                // this is just here to handle the 90% upgrade case.
                CloudBlockBlob blobToDelete = (CloudBlockBlob) asyncResult.AsyncState;
                bool deleted = blobToDelete.EndDeleteIfExists(asyncResult);

                if (deleted)
                {
                    xlfsTrace.AppendInfoLine("Blob deleted on background thread.");
                }
                else
                {
                    xlfsTrace.AppendErrorLine("Blob was not deleted on background thread.");
                }
            }
            catch(Exception e)
            {
                xlfsTrace.AppendErrorLine(string.Format("Unhandled exception:\r\n{0}", e));
            }
            finally
            {
                xlfsTrace.AppendInfoLine("Exit");
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\healthcheckmodule\module\SamlUtil.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.IdentityModel.Tokens;
using System.Xml;
using System.ServiceModel.Security;

namespace xonline.server.xlfs.XLFSClientFDHealthcheck
{

    public class SamlTokenParameters
    {
        public String SubjectFormat;
        public String SubjectQualifier;
        public String SubjectName;

        // Machine Claims
        public Byte? PlatformType;
        public UInt64? MachineID;
        public UInt64? DeviceID;
        public UInt32? ClientVersion;
        public UInt32? TitleID;
        public UInt32? TitleVersion;
        public UInt64? Puid0;
        public UInt64? CID0;
        public UInt64? PartnerId0; // For partner security ticket
        public String Gamertag0; // For partner security ticket

        // User Claims
        public bool GenerateUserClaims;
        public UInt64[] Xuid; // Required
        public String[] Gamertag;
        public Byte?[] Tier;
        public Byte?[] Country;
        public Byte[][] Privileges;

        // Conditions, etc
        public DateTime NotBefore;
        public DateTime NotAfter;
        public String Audience;
        public String AssertionID;
        public String Issuer;

        // Security
        public X509Certificate2 Certificate;
        public SigningCredentials Credentials;

        public static Byte DefaultPlatformType = 0x01;

        public SamlTokenParameters()
        {
            SetDefaults();
        }

        public SamlTokenParameters(byte platformType)
        {
            SetDefaults(platformType);
        }

        public SamlTokenParameters(SamlTokenParameters otherParams)
        {
            this.SubjectFormat = otherParams.SubjectFormat;
            this.SubjectQualifier = otherParams.SubjectQualifier;
            this.SubjectName = otherParams.SubjectName;

            this.PlatformType = otherParams.PlatformType;
            this.MachineID = otherParams.MachineID;
            this.DeviceID = otherParams.DeviceID;
            this.ClientVersion = otherParams.ClientVersion;
            this.TitleID = otherParams.TitleID;
            this.TitleVersion = otherParams.TitleVersion;
            this.Puid0 = otherParams.Puid0;
            this.CID0 = otherParams.CID0;
            this.PartnerId0 = otherParams.PartnerId0; // For partner security ticket
            this.Gamertag0 = otherParams.Gamertag0; // For partner security ticket

            this.GenerateUserClaims = otherParams.GenerateUserClaims;
            this.Xuid = otherParams.Xuid; // Required
            this.Gamertag = otherParams.Gamertag;
            this.Tier = otherParams.Tier;
            this.Country = otherParams.Country;
            this.Privileges = otherParams.Privileges;

            this.NotBefore = otherParams.NotBefore;
            this.NotAfter = otherParams.NotAfter;
            this.Audience = otherParams.Audience;
            this.AssertionID = otherParams.AssertionID;
            this.Issuer = otherParams.Issuer;

            this.Certificate = otherParams.Certificate;
            this.Credentials = otherParams.Credentials;
        }

        public void SetDefaults()
        {
            SetDefaults(DefaultPlatformType);
        }

        public virtual void SetDefaults(byte platformType)
        {
            PlatformType = platformType;
            ulong machineBase = 0;
            switch (platformType)
            {
                case 0x01:
                    machineBase = 0xFA00000000000000;
                    ClientVersion = 8159;
                    TitleID = 0xFFFF063F;
                    TitleVersion = 0xAAC4DC00;
                    break;
                default:
                    throw new ArgumentException("Invalid PlatformType: " + platformType);
            }
            MachineID = (machineBase + 1);

            Xuid = new UInt64[4];
            Gamertag = new String[4];
            Tier = new Byte?[4];
            Country = new Byte?[4];
            Privileges = new Byte[4][];

            NotBefore = DateTime.UtcNow;
            NotAfter = DateTime.UtcNow.AddMinutes(60);
            Audience = "http://liveconnect.xbox.com";
            AssertionID = String.Format("SamlSecurityToken-{0}", Guid.NewGuid().ToString());
            Issuer = "http://sts.xboxlive.com";
        }
    }

    public class GetSecurityTokenParameters : SamlTokenParameters
    {
        public GetSecurityTokenParameters(GetSecurityTokenParameters otherParams) : base(otherParams) { }
        public GetSecurityTokenParameters(byte platformType) : base(platformType) { }

        public override void SetDefaults(byte platformType)
        {
            base.SetDefaults(platformType);

            GenerateUserClaims = true;
            // TODO: OMG! Stupid SecurityTokens actually number users 1->4, so the default here should be 1 to make people happy. :(
            Xuid[0] = 0x0090000000000001;
            Tier[0] = 6;
            Country[0] = 1;  // TODO: Change to US

            SubjectName = String.Format("0x{0:X16}", Xuid[0]);
        }
    }

    public class GetPartnerSecurityTicketParameters : SamlTokenParameters
    {
        public override void SetDefaults(byte platformType)
        {
            base.SetDefaults(platformType);

            SubjectName = XlfsMonSamlToken.subject_name_partner;
        }
    }

    /// <summary>
    /// Utility for cerating SAML Tokens of all types
    /// </summary>
    public static class SamlTokenUtil
    {
        /// <summary>
        /// Generate a SAML Token the same as the ones returned by GetSecurityToken
        /// </summary>
        /// <param name="param">The parameters for the SAML Token</param>
        /// <returns>A string containing the XML representation of the SAML Token</returns>
        /// <remarks>This just delegates directly to GenerateSamlTokenString</remarks>
        public static String GetSecurityToken(GetSecurityTokenParameters param)
        {
            return GenerateSamlTokenString(param);
        }

        public static String GetParternSecurityTicket(GetPartnerSecurityTicketParameters param)
        {
            return GenerateSamlTokenString(param);
        }

        /// <summary>
        /// Generate a SAML Token based on the values in the SamlTokenParameters
        /// </summary>
        /// <param name="param">The parameters for the SAML Token</param>
        /// <returns>A string containing the XML representation of the SAML Token</returns>
        public static String GenerateSamlTokenString(SamlTokenParameters param)
        {
            // Create SAML conditions statement
            SamlConditions samlConditions = new SamlConditions(param.NotBefore, param.NotAfter);

            if (param.Audience != null)
            {
                SamlAudienceRestrictionCondition audienceRestriction = new SamlAudienceRestrictionCondition();
                audienceRestriction.Audiences.Add(new Uri(param.Audience));
                samlConditions.Conditions.Add(audienceRestriction);
            }

            // Create SAML attribute statement 
            SamlAttributeStatement samlAttributeStatement = new SamlAttributeStatement();

            // Add the subject
            GenerateSamlSubject(samlAttributeStatement, param);

            // Add the machine claims
            GenerateMachineClaims(samlAttributeStatement, param);

            // Add the user claims
            if (param.GenerateUserClaims)
            {

                for (int i = 0; i < 4; i++)
                {
                    if (param.Xuid[i] != 0)
                    {
                        GenerateUserClaims(samlAttributeStatement, param, i);
                    }
                }
            }

            // Then create the actual security tokne
            SamlSecurityToken samlToken = GenerateSamlToken(samlAttributeStatement, samlConditions, param);

            // And write it out to a string
            StringBuilder stringSamlToken = new StringBuilder();
            XmlWriter xWriter = XmlWriter.Create(stringSamlToken);
            WSSecurityTokenSerializer.DefaultInstance.WriteToken(xWriter, samlToken);

            return stringSamlToken.ToString();
        }

        /// <summary>
        /// Create a SamlSecurityToken with the attributes and conditions provided
        /// </summary>
        /// <param name="samlAttributeStatement">The SamlAttributes for the SAML Token</param>
        /// <param name="samlConditions">The SamlConditions for the SAML Token</param>
        /// <param name="param">Any additional parameters for the SAML Token</param>
        /// <returns>A new SamlSecurityToken</returns>
        private static SamlSecurityToken GenerateSamlToken(SamlAttributeStatement samlAttributeStatement, SamlConditions samlConditions, SamlTokenParameters param)
        {
            // Create the SAML statement Enumerable with one statement. 
            List<SamlStatement> samlStatements = new List<SamlStatement>();
            samlStatements.Add(samlAttributeStatement);

            SamlAssertion samlAssertion = new SamlAssertion(param.AssertionID, param.Issuer, param.NotBefore, samlConditions, null, samlStatements);

            samlAssertion.SigningCredentials = CreateSigningCredentials(param);

            // Create the SAML Token 
            SamlSecurityToken samlToken = new SamlSecurityToken(samlAssertion);

            return samlToken;
        }

        /// <summary>
        /// Create a set of SigningCredentials used to sign an SAML token
        /// </summary>
        /// <param name="param">The parameters for the credentials</param>
        /// <returns>A SigningCredentials object that can be used to sign a SAML token</returns>
        private static SigningCredentials CreateSigningCredentials(SamlTokenParameters param)
        {
            // The private key contained in the certificate will be used to sign the token.
            X509AsymmetricSecurityKey signingKey = new X509AsymmetricSecurityKey(param.Certificate);
            X509RawDataKeyIdentifierClause keyIdentifier = new X509RawDataKeyIdentifierClause(param.Certificate);

            // Signing credentials consist of private key in the certificate (see above), 
            // the signature algorithm, security algortihm and key identifier. 
            return new SigningCredentials(
                signingKey,
                SecurityAlgorithms.RsaSha1Signature,
                SecurityAlgorithms.Sha1Digest,
                new SecurityKeyIdentifier(keyIdentifier));
        }

        /// <summary>
        /// Add the subject information to the samlAttributeStatement
        /// </summary>
        /// <param name="samlAttributeStatement">The attribute statement to add the subject to</param>
        /// <param name="param">The parameters for the subject</param>
        private static void GenerateSamlSubject(SamlAttributeStatement samlAttributeStatement, SamlTokenParameters param)
        {
            samlAttributeStatement.SamlSubject = new SamlSubject(param.SubjectFormat, param.SubjectQualifier, param.SubjectName);
        }

        /// <summary>
        /// Add a set of of machine claims to the SMAL Attribute Statement
        /// </summary>
        /// <param name="samlAttributeStatement">The statement to add the claims to</param>
        /// <param name="param">The parameters for the claim</param>
        private static void GenerateMachineClaims(SamlAttributeStatement samlAttributeStatement, SamlTokenParameters param)
        {
            // PlatformType 
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_platformtype, XlfsMonSamlToken.ns_attribute_claims, param.PlatformType);

            // MachineID (will be 0 for platformType == XOn.XPLT_WEB_GAMES)
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_machineid, XlfsMonSamlToken.ns_attribute_claims, param.MachineID);

            // DeviceID
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_deviceid, XlfsMonSamlToken.ns_attribute_claims, param.DeviceID);

            // ClientVersion
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_clientversion, XlfsMonSamlToken.ns_attribute_claims, param.ClientVersion);

            // TitleID
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_titleid, XlfsMonSamlToken.ns_attribute_claims, param.TitleID);

            // TitleVersion
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_titleversion, XlfsMonSamlToken.ns_attribute_claims, param.TitleVersion);

            // Puid0
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_puid0, XlfsMonSamlToken.ns_attribute_claims, param.Puid0);

            // CID0
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_cid0, XlfsMonSamlToken.ns_attribute_claims, param.CID0);

            // PartnerID0
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_partnerid0, XlfsMonSamlToken.ns_attribute_claims, param.PartnerId0);

            // Gamertag0
            AddSamlAttribute(samlAttributeStatement, XlfsMonSamlToken.name_attribute_gamertag0, XlfsMonSamlToken.ns_attribute_claims, param.Gamertag0);
        }

        /// <summary>
        /// Add a set of user clams for a specific user to the SAML Attribute Statement
        /// </summary>
        /// <param name="samlAttributeStatement">The statement to add the claims to</param>
        /// <param name="param">The parameters for the claim</param>
        /// <param name="userIndex">The index of the user to add</param>
        private static void GenerateUserClaims(SamlAttributeStatement samlAttributeStatement, SamlTokenParameters param, Int32 userIndex)
        {
            // Xuid
            AddSamlAttribute(
                samlAttributeStatement,
                String.Format(XlfsMonSamlToken.name_attribute_xuid, userIndex),
                XlfsMonSamlToken.ns_attribute_claims,
                param.Xuid[userIndex]);

            // Gamertag
            AddSamlAttribute(
                samlAttributeStatement,
                String.Format(XlfsMonSamlToken.name_attribute_gamertag, userIndex),
                XlfsMonSamlToken.ns_attribute_claims,
                param.Gamertag[userIndex]);

            // Tier
            AddSamlAttribute(
                samlAttributeStatement,
                String.Format(XlfsMonSamlToken.name_attribute_tier, userIndex),
                XlfsMonSamlToken.ns_attribute_claims,
                param.Tier[userIndex]);

            // Country
            AddSamlAttribute(
                samlAttributeStatement,
                String.Format(XlfsMonSamlToken.name_attribute_country, userIndex),
                XlfsMonSamlToken.ns_attribute_claims,
                param.Country[userIndex]);

            // Privileges
            AddSamlAttribute(
                samlAttributeStatement,
                String.Format(XlfsMonSamlToken.name_attribute_privileges, userIndex),
                XlfsMonSamlToken.ns_attribute_claims,
                param.Privileges[userIndex]);
        }

        private static void AddSamlAttribute<T>(SamlAttributeStatement samlAttributeStatement, String attributeName, String attributeNamespace, Nullable<T> attributeValue)
            where T : struct
        {
            if (attributeValue.HasValue)
            {
                AddSamlAttribute(samlAttributeStatement, attributeName, attributeNamespace, attributeValue.Value);
            }
        }

        private static void AddSamlAttribute(SamlAttributeStatement samlAttributeStatement, String attributeName, String attributeNamespace, Object attributeValue)
        {
            if (attributeValue != null)
            {
                String attributeValueString = "";

                Array array = attributeValue as Array;
                if (array != null)
                {
                    if (array.Length > 0)
                    {
                        StringBuilder sb = new StringBuilder();
                        foreach (Object value in array)
                        {
                            sb.Append(value);
                            sb.Append(',');
                        }
                        sb.Remove(sb.Length - 1, 1);
                        attributeValue = sb.ToString();
                    }
                    else
                    {
                        attributeValue = "";
                    }
                }
                else
                {
                    try
                    {
                        attributeValueString = String.Format("0x{0:X}", attributeValue);
                    }
                    catch
                    {
                        // If we caught an exception, just get the ToString value
                        attributeValueString = attributeValue.ToString();
                    }

                }
                SamlAttribute samlAttribute = new SamlAttribute();
                samlAttribute.Name = attributeName;
                samlAttribute.Namespace = attributeNamespace;
                samlAttribute.AttributeValues.Add(attributeValueString);

                samlAttributeStatement.Attributes.Add(samlAttribute);
            }
        }
    }

    public class XlfsMonSamlToken
    {
        public const string name_attribute_cid = "CID{0}";
        public const string name_attribute_cid0 = "CID0";
        public const string name_attribute_clientversion = "ClientVersion";
        public const string name_attribute_country = "Country{0}";
        public const string name_attribute_country0 = "Country0";
        public const string name_attribute_deviceid = "DeviceID";
        public const string name_attribute_gamertag = "Gamertag{0}";
        public const string name_attribute_gamertag0 = "Gamertag0";
        public const string name_attribute_machineid = "MachineID";
        public const string name_attribute_partnerid = "PartnerID{0}";
        public const string name_attribute_partnerid0 = "PartnerID0";
        public const string name_attribute_platformtype = "PlatformType";
        public const string name_attribute_privileges = "Privileges{0}";
        public const string name_attribute_privileges0 = "Privileges0";
        public const string name_attribute_puid = "Puid{0}";
        public const string name_attribute_puid0 = "Puid0";
        public const string name_attribute_tier = "Tier{0}";
        public const string name_attribute_tier0 = "Tier0";
        public const string name_attribute_titleid = "TitleID";
        public const string name_attribute_titleversion = "TitleVersion";
        public const string name_attribute_xuid = "Xuid{0}";
        public const string name_attribute_xuid0 = "Xuid0";
        public const string ns_attribute_claims = "http://xboxlive.com/claims";
        public const string subject_name_machine = "XboxLive Machine security ticket";
        public const string subject_name_partner = "XboxLive Partner security ticket";
        public const string subject_name_user = "XboxLive User security ticket";
        public const string xbl10_samlissuer = "http://sts.xboxlive.com";
        public const int xbl10_samlmajorversion = 1;
        public const int xbl10_samlminorversion = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\healthcheckmodule\module\Config.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Net;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;

namespace xonline.server.xlfs.XLFSClientFDHealthcheck
{
    enum XlfsMonResults
    {
        SUCCESS,
        SAML_FAILED,
        UPLOAD_BEGIN_FAILED,
        XLFS_SYNC_FAILED,
        UPLOAD_END_FAILED,
        XLFS_INTERNAL_FAILURE,
        DOWNLOAD_START_FAILURE,
        DOWNLOAD_FAILED,
        DOWNLOAD_FILE_NOT_FOUND,
        DOWNLOAD_FILE_NOT_DELETED,
        DOWNLOAD_CLIENT_DEFAULT_PAGE_FAILED,
        DOWNLOAD_ADMIN_DEFAULT_PAGE_FAILED
    }

    public static class XlfsMonConfig
    {
        // Configuration settings
        public static X509Certificate2 azureAdminCertificate = null;
        public static string azureFDUri = null;
        public static string azureAdminFDUri = null;
        public static string currentEnvironment = "Prod";
        public static string currentErrorString = null;
        public static string currentSubscription = null;
        public static string samlAudience = "http://sts.xboxlive.com";
        public static UInt32 samlTitleId = 0xFFFF063F;
        public static UInt64 samlXuid = 0x0009000000000001;
        public static bool useRealSAML = false;
        public static bool verbose = false;
        public static WebProxy webProxy = null;
        public static string xlfsConsoleCertificate = null;
        public static string xlfsConsoleDownloaderArgument = null;
        public static string xlfsConsoleDownloaderPath = null;
        public static string xlfsConsolePath = null;
        public static string xlfsConsoleSaveDirectory = null;
        public static string xlfsConsoleThumbprint = null;
        public static string xlfsMonArgument = null;
        public static string xlfsMonConfigSettings = null;
        public static string xlfsTargetName = "XlfsHealthcheckDummyData.txt";

        // Readonly strings
        public static readonly string sSource = "SCOM_XLFS_MONITOR";
        public static readonly string sLog = "Application";
        public static readonly string[] eventStrings = 
        {
            "Xlfs end to end upload test succeeded.",
            "SAML acquisition attempt failed",
            "UploadBegin.ashx call to Azure Client FD failed [Pass1]",
            "File upload to Azure storage failed [Pass2]",
            "UploadEnd.ashx call to Azure Client FD failed [Pass3]",
            "XlfsMon module internal error has occurred",
            "XlfsMon failed to call XlfsConsoleDownloader",
            "XlfsMon failed to download the file from Xlfs",
            "XlfsMon could not find the downloaded healthcheck file",
            "XlfsMon could not delete the downloaded healthcheck file",
            "XlfsMon could not download the default.aspx page from the Client FD",
            "XlfsMon could not download the default.aspx page from the Admin FD"
        };

        public static string EscapeCommandLineArgument(string str)
        {
            // Does the string contain a space character or not?
            if (str.Contains(" ") == false)
            {
                return str;
            }

            // The string contains a space, thus we will need to start and 
            // end the string with " character. The start of the string is
            // easy to create, but the end of the string requires a check
            // to make sure that it doesn't already end in a \ character
            // since that would cause an escape sequence
            str = "\"" + str;
            if (str.EndsWith("\\") == true)
            {
                str += "\\";
            }
            str += "\"";

            return str;
        }

    }

    public class XlfsSortedDictionary : SortedDictionary<string, string>
    {
        public void Update(string key, string value)
        {
            this[key] = value;
        }

        public void Update(string key, int value)
        {
            Update(key, value.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\healthcheckmodule\module\Program.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Security;
using System.Reflection;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Web;
using System.Xml;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;

namespace xonline.server.xlfs.XLFSClientFDHealthcheck
{
    class Program
    {
        static string FindExecutable(string str)
        {
            Process currentProcess = Process.GetCurrentProcess();
            if (currentProcess == null)
            {
                return null;
            }

            ProcessStartInfo currentStartInfo = currentProcess.StartInfo;
            if (currentStartInfo == null)
            {
                return null;
            }

            StringDictionary environmentVariables = currentStartInfo.EnvironmentVariables;
            if (environmentVariables == null)
            {
                return null;
            }

            string path = environmentVariables["Path"];
            if (String.IsNullOrEmpty(path) == true)
            {
                return null;
            }

            // Always make sure that the current path is in the search as well as the
            // location of the executing assembly
            path = path + ";" + System.IO.Path.GetDirectoryName(Assembly.GetEntryAssembly().Location); ;
            path = path + ";.";

            // Look at each of the possible file locations
            string[] explodedPath = path.Split(';');
            foreach (string subPath in explodedPath)
            {
                if (System.IO.File.Exists(System.IO.Path.Combine(subPath, str)) == true)
                {
                    return subPath;
                }
            }
            return null;
        }

        static private X509Certificate2 GetCertificateBySubjectName(string certSubject, bool isPrivateKeyRequired)
        {
            X509Certificate2 certificate = null;

            // Try to find the certificate in the user store
            X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(
                    X509FindType.FindBySubjectDistinguishedName,
                    certSubject,
                    false);

                if (matches.Count >= 1)
                {
                    certificate = matches[0];
                    if (isPrivateKeyRequired && certificate.HasPrivateKey == false)
                    {
                        certificate = null;
                    }
                }
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
            if (certificate != null)
            {
                return certificate;
            }

            // Try to find the certificate in the machine store
            store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(
                    X509FindType.FindBySubjectDistinguishedName,
                    certSubject,
                    false);

                if (matches.Count >= 1)
                {
                    certificate = matches[0];
                    if (isPrivateKeyRequired && certificate.HasPrivateKey == false)
                    {
                        certificate = null;
                    }
                }
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
            return certificate;
        }

        static private X509Certificate2 GetCertificateByThumbprint(string certThumbprint, bool isPrivateKeyRequired)
        {
            X509Certificate2 certificate = null;

            // Try to find the certificate in the user store
            X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(
                    X509FindType.FindByThumbprint,
                    certThumbprint,
                    false);

                if (matches.Count >= 1)
                {
                    certificate = matches[0];
                    if (isPrivateKeyRequired && certificate.HasPrivateKey == false)
                    {
                        certificate = null;
                    }
                }
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
            if (certificate != null)
            {
                return certificate;
            }

            // Try to find the certificate in the machine store
            store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(
                    X509FindType.FindByThumbprint,
                    certThumbprint,
                    false);

                if (matches.Count >= 1)
                {
                    certificate = matches[0];
                    if (isPrivateKeyRequired && certificate.HasPrivateKey == false)
                    {
                        certificate = null;
                    }
                }
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
            return certificate;
        }

        static void LoadDefaultConfig()
        {
            try
            {
                StringBuilder sb = new StringBuilder();
                string temp;

                temp = Config.GetSetting(Setting.xlfsmon_EnvironmentName);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_EnvironmentName, temp);
                    XlfsMonConfig.currentEnvironment = temp;
                }

                temp = Config.GetSetting(Setting.xlfsmon_SubscriptionId);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_SubscriptionId, temp);
                    XlfsMonConfig.currentSubscription = temp;
                }

                temp = Config.GetSetting(Setting.xlfsmon_ClientFdURL);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_ClientFdURL, temp);
                    XlfsMonConfig.azureFDUri = temp;
                }

                temp = Config.GetSetting(Setting.xlfsmon_AdminFdURL);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_AdminFdURL, temp);
                    XlfsMonConfig.azureAdminFDUri = temp;
                }

                temp = Config.GetSetting(Setting.xlfsmon_SaveDirectory);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_SaveDirectory, temp);
                    XlfsMonConfig.xlfsConsoleSaveDirectory = temp;
                }

                temp = Config.GetSetting(Setting.xlfsmon_ClientCertificateName);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_ClientCertificateName, temp);
                    XlfsMonConfig.xlfsConsoleCertificate = temp;
                }

                temp = Config.GetSetting(Setting.xlfsmon_ClientCertificateThumbprint);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_ClientCertificateThumbprint, temp);
                    XlfsMonConfig.xlfsConsoleThumbprint = temp;
                }

                temp = Config.GetSetting(Setting.xlfsmon_DownloaderPath);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_DownloaderPath, temp);
                    XlfsMonConfig.xlfsConsoleDownloaderPath = temp;
                }

                temp = Config.GetSetting(Setting.xlfsmon_ProxyURL);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_ProxyURL, temp);
                    XlfsMonConfig.webProxy = new WebProxy(temp);
                }

                temp = Config.GetSetting(Setting.xlfsmon_UseRealSTS);
                if (String.IsNullOrEmpty(temp) == false)
                {
                    bool b = false;
                    Boolean.TryParse(temp, out b);
 
                    sb.AppendFormat("\n\t{0} : {1}", Setting.xlfsmon_UseRealSTS, b.ToString());
                    XlfsMonConfig.useRealSAML = b;
                }

                XlfsMonConfig.xlfsMonConfigSettings = sb.ToString();
            }
            catch (Exception ex)
            {
                XlfsMonConfig.xlfsMonConfigSettings = ("Exception Occured: " + ex.ToString());
            }
        }

        static void ParseCommandLineArguments(string[] args)
        {
            // Parse the arguments
            int i = 0;
            while (i < args.Length)
            {
                switch (args[i].ToLower())
                {
                    case "-env":
                    case "-environment":
                        if (i + 1 < args.Length) XlfsMonConfig.currentEnvironment = args[++i].Trim();
                        break;
                    case "-sub":
                    case "-subscription":
                        if (i + 1 < args.Length) XlfsMonConfig.currentSubscription = args[++i].Trim();
                        break;
                    case "-clientfd":
                        if (i + 1 < args.Length) XlfsMonConfig.azureFDUri = args[++i].Trim();
                        break;
                    case "-adminfd":
                        if (i + 1 < args.Length) XlfsMonConfig.azureAdminFDUri = args[++i].Trim();
                        break;
                    case "-savedirectory":
                        if (i + 1 < args.Length) XlfsMonConfig.xlfsConsoleSaveDirectory = args[++i].Trim();
                        break;
                    case "-certificate":
                        if (i + 1 < args.Length) XlfsMonConfig.xlfsConsoleCertificate = args[++i].Trim();
                        break;
                    case "-thumbprint":
                        if (i + 1 < args.Length) XlfsMonConfig.xlfsConsoleThumbprint = args[++i].Trim();
                        break;
                    case "-downloaderpath":
                        if (i + 1 < args.Length) XlfsMonConfig.xlfsConsolePath = args[++i].Trim();
                        break;
                    case "-proxy":
                        if (i + 1 < args.Length) XlfsMonConfig.webProxy = new WebProxy(args[++i].Trim(), true);
                        break;
                    case "-machineproxy":
                        XlfsMonConfig.webProxy = new WebProxy();
                        break;
                    case "-verbose":
                        XlfsMonConfig.verbose = true;
                        break;
                    case "-realsaml":
                        XlfsMonConfig.useRealSAML = true;
                        break;
                    default:
                        Help();
                        return;
                }
                i++;
            }

            // Generate the full command line since we may need it in the event logs
            StringBuilder originalArguments = new StringBuilder();
            for (i = 0; i < args.Length; ++i)
            {
                originalArguments.AppendFormat(
                    "\n\t{0}",
                    XlfsMonConfig.EscapeCommandLineArgument(args[i].ToLower())
                    );
            }
            XlfsMonConfig.xlfsMonArgument = originalArguments.ToString();
        }

        static bool ValidateConfig()
        {
            // Sanity check that we have a client Front Dooor
            if (String.IsNullOrEmpty(XlfsMonConfig.azureFDUri) == true)
            {
                Help("\tError: -clientfd <url> must be specified");
                return false;
            }

            // Sanity check that we have an admin Front Door
            if (String.IsNullOrEmpty(XlfsMonConfig.azureAdminFDUri) == true)
            {
                Help("\tError: -adminfd <url> must be specified");
                return false;
            }

            // Sanity check that we have either a ThumbPrint or Certificate Name
            if (String.IsNullOrEmpty(XlfsMonConfig.xlfsConsoleCertificate) == true &&
                String.IsNullOrEmpty(XlfsMonConfig.xlfsConsoleThumbprint) == true)
            {
                Help("\tError: -certificate <name> or -thumbprint <value> must be specified");
                return false;
            }
            if (String.IsNullOrEmpty(XlfsMonConfig.xlfsConsoleCertificate) == false &&
                String.IsNullOrEmpty(XlfsMonConfig.xlfsConsoleThumbprint) == false)
            {
                Help("\tError: -certificate <name> or -thumbprint <value> cannot both be specified");
                return false;
            }
            if (String.IsNullOrEmpty(XlfsMonConfig.xlfsConsoleCertificate) == false)
            {
                XlfsMonConfig.azureAdminCertificate = GetCertificateBySubjectName(XlfsMonConfig.xlfsConsoleCertificate, true);
                if (XlfsMonConfig.azureAdminCertificate == null)
                {
                    Help(string.Format("\tError: -certificate {0} not found", XlfsMonConfig.xlfsConsoleCertificate));
                    return false;
                }
            }
            if (String.IsNullOrEmpty(XlfsMonConfig.xlfsConsoleThumbprint) == false)
            {
                XlfsMonConfig.azureAdminCertificate = GetCertificateByThumbprint(XlfsMonConfig.xlfsConsoleThumbprint, true);
                if (XlfsMonConfig.azureAdminCertificate == null)
                {
                    Help(string.Format("\tError: -thumbprint {0} not found", XlfsMonConfig.xlfsConsoleThumbprint));
                    return false;
                }
            }

            // Sanity check that we have a downloader path and can find the
            // downloader executable
            if (String.IsNullOrEmpty(XlfsMonConfig.xlfsConsolePath) == false)
            {
                if (System.IO.Directory.Exists(XlfsMonConfig.xlfsConsolePath) == false)
                {
                    Help("\tError: -downloaderpath <path> must exist");
                    return false;
                }
            }
            else
            {
                XlfsMonConfig.xlfsConsolePath = FindExecutable("XlfsConsoleDownloader.exe");
            }
            XlfsMonConfig.xlfsConsoleDownloaderPath = System.IO.Path.Combine(
                XlfsMonConfig.xlfsConsolePath,
                "XlfsConsoleDownloader.exe"
                );
            if (System.IO.File.Exists(XlfsMonConfig.xlfsConsoleDownloaderPath) == false)
            {
                Help(
                    String.Format(
                        "\tError: {0} Not Found",
                        XlfsMonConfig.xlfsConsoleDownloaderPath
                        )
                    );
                return false;
            }

            // See if we have an override on the save directory location
            if (String.IsNullOrEmpty(XlfsMonConfig.xlfsConsoleSaveDirectory) == false)
            {
                if (System.IO.Directory.Exists(XlfsMonConfig.xlfsConsoleSaveDirectory) == false)
                {
                    // Try to create the directory.  If it fails, bail.
                    try
                    {
                        Directory.CreateDirectory(XlfsMonConfig.xlfsConsoleSaveDirectory);
                    }
                    catch (Exception)
                    {
                        Help(string.Format("\tError: -savedirectory \"{0}\" does not exist and directory creation failed.", XlfsMonConfig.xlfsConsoleSaveDirectory));
                        return false;
                    }
                }
            }
            else
            {
                XlfsMonConfig.xlfsConsoleSaveDirectory = System.IO.Path.GetDirectoryName(Assembly.GetEntryAssembly().Location); ;
            }

            // Generate a random target name based upon the date/time
            XlfsMonConfig.xlfsTargetName = String.Format(
                "XlfsHealthcheck-{0}.txt",
                DateTime.Now.ToString("yyyy-MM-dd-HHmmssffff"));

            // Build up the default command line to the downloader
            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat(
                "-server {0} ",
                XlfsMonConfig.EscapeCommandLineArgument(XlfsMonConfig.azureAdminFDUri)
                );
            arguments.AppendFormat(
                "-savedirectory {0} ",
                XlfsMonConfig.EscapeCommandLineArgument(XlfsMonConfig.xlfsConsoleSaveDirectory)
                );
            arguments.AppendFormat(
                "-filter {0} ",
                XlfsMonConfig.EscapeCommandLineArgument(XlfsMonConfig.xlfsTargetName)
                );
            if (String.IsNullOrEmpty(XlfsMonConfig.xlfsConsoleCertificate) == false)
            {
                arguments.AppendFormat(
                    "-certificate {0} ",
                    XlfsMonConfig.EscapeCommandLineArgument(XlfsMonConfig.xlfsConsoleCertificate)
                    );
            }
            else
            {
                arguments.AppendFormat(
                    "-thumbprint {0} ",
                    XlfsMonConfig.EscapeCommandLineArgument(XlfsMonConfig.xlfsConsoleThumbprint)
                    );
            }
            arguments.Append("-deltaminutes 10 ");
            arguments.Append("-titleid FFFF063F ");

            if (XlfsMonConfig.webProxy != null)
            {
                arguments.AppendFormat("-proxy {0} ", XlfsMonConfig.webProxy.Address);
            }

            XlfsMonConfig.xlfsConsoleDownloaderArgument = arguments.ToString();

            return true;
        }

        static void Main(string[] args)
        {
            // Load the settings from config first
            LoadDefaultConfig();

            // Parse the command line
            ParseCommandLineArguments(args);

            // See if we are happy with the arguments
            if (ValidateConfig() == false)
            {
                return;
            }

            // Create the Uploader Module and start it
            XlfsUploader upModule = new XlfsUploader();
            upModule.Start();
        }

        static void Help()
        {
            Help(null);
        }

        static void Help(string msg)
        {
            Assembly asm = Assembly.GetExecutingAssembly();
            AssemblyName asmName = new AssemblyName(asm.FullName);

            Console.Out.WriteLine("{0} - {1} - Copyright Microsoft Corp (c) 2010", asmName.Name, asmName.Version);
            Console.Out.WriteLine("");
            Console.Out.WriteLine("\t[-environment <label>]  : Overrides the string to use during eventing");
            Console.Out.WriteLine("\t -subscription <value>  : Overrides the string to use during eventing");
            Console.Out.WriteLine("\t -clienfd <url>         : Specifies the name of the XlfsFd Client URL");
            Console.Out.WriteLine("\t -adminfd <url>         : Specifies the name of the XlfsAdminFd URL");
            Console.Out.WriteLine("\t -certificate <name>    : Specifies the name of the Cert required by the AdminFD");
            Console.Out.WriteLine("\t -thumbprint <value>    : Sepcifies the thumbprint of the Cert required by the AdminFD");
            Console.Out.WriteLine("\t -savedirectory <path>  : Specifies the location of the temporary files");
            Console.Out.WriteLine("\t -downloaderpath <path> : Specifies where to find XlfsConsoleDownloader.exe");
            Console.Out.WriteLine("\t -proxy <url>           : Specifies which proxy server to use");
            Console.Out.WriteLine("\t -machineproxy          : Use the default proxy configured on the machine");
            Console.Out.WriteLine("\t -verbose               : Display more verbose results");
            Console.Out.WriteLine("\t -realsaml              : Obtain an real SAML token from STS");

            if (string.IsNullOrEmpty(msg) == false)
            {
                Console.Out.WriteLine("");
                Console.Out.WriteLine("{0}", msg);
            }
            if (string.IsNullOrEmpty(XlfsMonConfig.xlfsMonArgument) == false)
            {
                Console.Out.WriteLine("");
                Console.Out.WriteLine("Arguments:\n{0}", XlfsMonConfig.xlfsMonArgument);
            }
            if (string.IsNullOrEmpty(XlfsMonConfig.xlfsMonConfigSettings) == false)
            {
                Console.Out.WriteLine("");
                Console.Out.WriteLine("Settings:\n{0}", XlfsMonConfig.xlfsMonConfigSettings);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\fd\XlfsFD\dll\XlfsFdPerfCtrs.cs ===
using System.Diagnostics;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsfd
{
    public class PerformanceCounterStrings
    {
        public const string UploadBeginCategory = "XlfsFd: UploadBegin";
        public const string UploadBeginRequestsPerSec = "UploadBegin requests/sec";
        public const string UploadBeginTotalRequests = "UploadBegin total";
        public const string UploadBeginFailurePerSec = "UploadBegin failures/sec";
        public const string UploadBeginTotalFailures = "UploadBegin total failures";
        public const string UploadBeginAvgExecTime = "UploadBegin avg. execution time";
        public const string UploadBeginAvgExecBaseTime = "UploadBegin avg. execution time base";
        
        public const string UploadEndCategory = "XlfsFd: UploadEnd";
        public const string UploadEndRequestsPerSec = "UploadEnd requests/sec";
        public const string UploadEndTotalRequests = "UploadEnd total";
        public const string UploadEndFailurePerSec = "UploadEnd failures/sec";
        public const string UploadEndTotalFailures = "UploadEnd total failures";
        public const string UploadEndAvgExecTime = "UploadEnd avg. execution time";
        public const string UploadEndAvgExecBaseTime = "UploadEnd avg. execution time base";
    }

    /// <summary>
    /// UploadBegin performance counters.
    /// </summary>
    [XlfsPerformanceCounterCategoryAttr(PerformanceCounterStrings.UploadBeginCategory, "Performance counters related to the XLFS UploadBegin API.")]
    public class XlfsFdUploadBeginCounters : XlfsPerformanceCounterCategory
    {
        public virtual XlfsFdUploadBeginCounters this[string countryID]
        {
            get
            {
                return (XlfsFdUploadBeginCounters)GetInstance(countryID);
            }
        }

        static public XlfsFdUploadBeginCounters Counters = new XlfsFdUploadBeginCounters();

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadBeginRequestsPerSec,
            "UploadBegin requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XlfsPerformanceCounterAttr(
         PerformanceCounterStrings.UploadBeginTotalRequests,
         "Total UploadBegin requests recorded in the the current AppDomain.",
          PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadBeginFailurePerSec,
            "Number of unsuccessful results returned by UploadBegin per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadBeginTotalFailures,
            "Total number unsuccessful results returned by UploadBegin in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadBeginAvgExecTime,
            "UploadBegin average request execution time in the current AppDomain.",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadBeginAvgExecBaseTime,
            "UploadBegin base for the average request execution time in the current AppDomain.",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;
    }

    /// <summary>
    /// UploadEnd performance counters.
    /// </summary>
    [XlfsPerformanceCounterCategoryAttr("XlfsFd: UploadEnd", "Performance counters related to the XLFS UploadEnd API.")]
    public class XlfsFdUploadEndCounters : XlfsPerformanceCounterCategory
    {
        public virtual XlfsFdUploadEndCounters this[string countryID]
        {
            get
            {
                return (XlfsFdUploadEndCounters)GetInstance(countryID);
            }
        }

        static public XlfsFdUploadEndCounters Counters = new XlfsFdUploadEndCounters();

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadEndRequestsPerSec,
            "UploadEnd requests per second",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadEndTotalRequests,
            "Total UploadEnd requests recorded in the the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadEndFailurePerSec,
            "Number of unsuccessful results returned by UploadEnd per second in the current AppDomain.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadEndTotalFailures,
            "Total number unsuccessful results returned by UploadEnd in the current AppDomain.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadEndAvgExecTime,
            "UploadEnd average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XlfsPerformanceCounterAttr(
            PerformanceCounterStrings.UploadEndAvgExecBaseTime,
            "UploadEnd base for the average request execution time in the current AppDomain.",
            PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\healthcheckmodule\module\StsRequest.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Web;
using System.Security.Cryptography;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;

namespace xonline.server.xlfs.XLFSClientFDHealthcheck
{
    /// <summary>
    /// 
    /// </summary>
    public class StsRequest
    {
        public const ulong XenonUser                = 0x0009000000000001;
        public const uint DefaultTitle              = 0xFFFF063F;
        public const string DefaultStsAudience      = "http://sts.xboxlive.com";
        public const string StsGetSecurityTokenPath = "sts/getsecuritytoken.ashx";

        public StsRequest()
        {
            this.Xuid1 = XenonUser;
            this.Audience = DefaultStsAudience;
            this.TitleID = DefaultTitle;
        }

        public StsRequest(ulong xuid1, string audience, uint titleid)
        {
            this.Xuid1 = xuid1;
            this.Audience = audience;
            this.TitleID = titleid;
        }

        public string Audience
        {
            get;
            set;
        }

        public UInt32 TitleID
        {
            get;
            set;
        }

        public UInt64 Xuid1
        {
            get;
            set;
        }

        public string ToRequestUrl()
        {
            return ToRequestUrl(true);
        }

        public string ToRequestUrl(bool escape)
        {
            Dictionary<string, string> queryString = new Dictionary<string, string>(5);

            if (this.Audience != null)
            {
                queryString.Add(
                    "audience", 
                    (escape) ? HttpUtility.UrlEncode(this.Audience) : this.Audience
                    );
            }
            if (this.TitleID != 0)
            {
                queryString.Add(
                    "titleID", 
                    (escape) ? HttpUtility.UrlEncode(GetUInt32Value(this.TitleID)) : 
                               GetUInt32Value(this.TitleID)
                    );
            }           
            if (this.Xuid1 != 0)
            {
                queryString.Add(
                    "xuid1",
                    (escape) ? HttpUtility.UrlEncode(this.Xuid1.ToString("x16")) : 
                               this.Xuid1.ToString("x16"));
            }
            
            StringBuilder stsUrl = new StringBuilder(StsGetSecurityTokenPath);
            if (queryString.Count > 0)
            {
                stsUrl.Append("?");
            }

            foreach (string key in queryString.Keys)
            {
                stsUrl.AppendFormat("{0}={1}&", key, queryString[key]);
            }
            stsUrl.Length -= 1; //trim off the last '&'

            return stsUrl.ToString();
        }

        public static string GetUInt32Value(object value)
        {
            return GetUInt32Value(value, false);
        }

        public static string GetUInt32Value(object value, bool fullHex)
        {
            if (value != null)
            {
                if (value is uint)
                    return ((uint)value).ToString(fullHex ? "X8" : "X");
                else
                    return value.ToString();
            }

            return String.Empty;
        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\healthcheckmodule\module\Uploader.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.Security;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Reflection;
using System.Web;
using System.Xml;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;

namespace xonline.server.xlfs.XLFSClientFDHealthcheck
{
    public class XlfsUploader
    {
        private HttpWebRequest req = null;
        private HttpWebResponse resp = null;
        private string userXuid = null;
        private string titleId = null;
        private string securityToken = null;
        private string sas = null;
        private string xactId = null;
        private string blockIdBase64 = null;
        private MD5 md5Hash = null;
        private string md5HashValue = null;
        private byte[] md5inBytes = null;
        private string data = null;
        private byte[] bData = null;
        private XlfsSortedDictionary info = null;

        public XlfsUploader()
        {
            this.data = string.Format("This is SCOM XLFS healthcheck data @ {0}", DateTime.UtcNow.ToString());
            this.bData = Encoding.ASCII.GetBytes(data.ToCharArray());
            this.md5Hash = MD5.Create();
            this.md5inBytes = this.md5Hash.ComputeHash(bData);
            this.md5HashValue = Convert.ToBase64String(md5inBytes);
            this.info = new XlfsSortedDictionary();
        }

        private XlfsMonResults AcquireSAMLFromFake()
        // Note SAML acquisition here is not hitting the actual STS service, instead we are calling into helper function taken from STF test code.
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;
            try
            {
                Assembly asm = Assembly.GetExecutingAssembly();

                GetSecurityTokenParameters samlParameters = new GetSecurityTokenParameters(0x01);
                BinaryReader certStreamReader = new BinaryReader(asm.GetManifestResourceStream("test-azure.xboxlive.com.pfx"));
                X509Certificate2 SamlCertificate = new X509Certificate2(certStreamReader.ReadBytes((int)certStreamReader.BaseStream.Length), "XblRocks!");
                samlParameters.Certificate = SamlCertificate;

                // Setup the parameters to what we want
                samlParameters.Audience = XlfsMonConfig.samlAudience;
                samlParameters.Xuid[0] = XlfsMonConfig.samlXuid;
                samlParameters.TitleID = XlfsMonConfig.samlTitleId;

                // Remember the user xuid and title id that was used
                userXuid = "0x" + samlParameters.Xuid[0].ToString("X16");
                titleId = "0x" + samlParameters.TitleID.Value.ToString("X8");

                // Get the actual security token
                this.securityToken = string.Concat("XBL1.0 x=", SamlTokenUtil.GetSecurityToken(samlParameters));

            }
            catch (Exception ex)
            {
                XlfsMonConfig.currentErrorString = ex.Message;
                res = XlfsMonResults.SAML_FAILED;
            }

            return res;
        }

        private XlfsMonResults AcquireSAMLFromSTS()
        {
            try
            {
                // Remember the user xuid and title id that was used
                userXuid = "0x" + XlfsMonConfig.samlXuid.ToString("X16");
                titleId = "0x" + XlfsMonConfig.samlTitleId.ToString("X8");

                // Create Authdata for this client
                HTTPAuthData authData = new HTTPAuthData(
                    0,
                    0,
                    0,
                    (ulong)0xFA00000000000000,
                    (ulong)XlfsMonConfig.samlXuid,
                    XlfsMonConfig.samlTitleId,
                    (uint)XOService.Sts,
                    0
                    );

                // Create the STS request object
                StsRequest stsRequest = new StsRequest(
                    XlfsMonConfig.samlXuid,
                    XlfsMonConfig.samlAudience,
                    XlfsMonConfig.samlTitleId
                    );

                // Use an XRL request in order to get the path
                XrlRequest xrlreq = new XrlRequest();
                xrlreq.TargetVirtualInterface = VirtualInterface.sts_int;

                // Build the path
                this.req = (HttpWebRequest)WebRequest.Create(xrlreq.Url + stsRequest.ToRequestUrl());
                this.req.ContentType = "xon/" + ((int)XOService.Sts).ToString("x");
                this.req.UserAgent = ((int)XOService.Sts).ToString("x") + "/1.0.4325";
                this.req.Headers.Add("HTTPAuthData", authData.ConstructBase64String());

                // Note: XLFSMon does not need to use the proxy to hit STS

                // Call the server
                this.resp = (HttpWebResponse)this.req.GetResponse();

                // Always get following fields
                this.info.Update("GetSecurityToken.ashx-status", (int)this.resp.StatusCode);

                // Get the security token
                XmlReader xmlReader = XmlReader.Create(this.resp.GetResponseStream());
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(xmlReader);

                this.securityToken = string.Concat("XBL1.0 x=", xmlDoc.OuterXml);
            }
            catch (Exception ex)
            {
                XlfsMonConfig.currentErrorString = ex.Message;
                return XlfsMonResults.UPLOAD_BEGIN_FAILED;
            }
            finally
            {
                this.req = null;
                if (this.resp != null)
                {
                    this.resp.Close();
                }
                this.resp = null;
            }

            return XlfsMonResults.SUCCESS;
        }

        private XlfsMonResults AcquireSAML()
        {
            if (XlfsMonConfig.useRealSAML == false)
            {
                return AcquireSAMLFromFake();
            }
            else
            {
                return AcquireSAMLFromSTS();
            }
        }

        private XlfsMonResults AcquireSAS()
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;
            string uploadBeginUri = string.Format("{0}/UploadBegin.ashx?fn={1}", XlfsMonConfig.azureFDUri, XlfsMonConfig.xlfsTargetName);
            try
            {
                this.req = (HttpWebRequest)WebRequest.Create(uploadBeginUri);
                this.req.Headers.Add("x-ms-on-behalf-user-xuid", userXuid);
                this.req.Headers.Add("x-ms-on-behalf-titleid", titleId);
                this.req.Headers.Add("Content-MD5", this.md5HashValue);
                this.req.Headers.Add("X-Authorization", this.securityToken);

                // Setup the proxy
                if (XlfsMonConfig.webProxy != null)
                {
                    this.req.Proxy = XlfsMonConfig.webProxy;
                }

                // Call the server
                this.resp = (HttpWebResponse)this.req.GetResponse();

                // Always get following fields
                this.info.Update("UploadBegin.ashx-status", (int)this.resp.StatusCode);

                string reqBody = RequestGetBody(this.resp);
                if (String.IsNullOrEmpty(reqBody) == false)
                {
                    info.Update("UploadBegin.ashx-response", reqBody);
                }

                string xlfsVersion = this.resp.GetResponseHeader("x-ms-xlfs-version");
                if (String.IsNullOrEmpty(xlfsVersion) == false)
                {
                    info.Update("x-ms-xlfs-version", xlfsVersion);
                }

                // See if the request failed
                if (this.resp.StatusCode >= HttpStatusCode.BadRequest)
                {
                    XlfsMonConfig.currentErrorString = string.Format("UploadBegin.ashx returns failed with status code {0}", this.resp.StatusCode);
                    throw new Exception(XlfsMonConfig.currentErrorString);
                }

                this.sas = this.resp.GetResponseHeader("Location");
                if (string.IsNullOrEmpty(this.sas))
                {
                    XlfsMonConfig.currentErrorString = "UploadBegin.ashx didn't return 'Location' field in the response header";
                    throw new Exception(XlfsMonConfig.currentErrorString);
                }
                Uri sasUri = new Uri(this.sas);
                this.info.Update(
                    "UploadBegin.ashx-uri",
                    String.Format(
                        "{0}://{1}:{2}/{3}",
                        sasUri.Scheme,
                        sasUri.Host,
                        sasUri.Port,
                        sasUri.AbsolutePath
                        )
                    );

                this.xactId = this.resp.GetResponseHeader("x-ms-transaction-id");
                if (this.xactId.Equals(string.Empty))
                {
                    XlfsMonConfig.currentErrorString = "UploadBegin.ashx didn't return 'x-ms-transaction-id' in the response header";
                    throw new Exception(XlfsMonConfig.currentErrorString);
                }
            }
            catch (Exception ex)
            {
                XlfsMonConfig.currentErrorString = ex.Message;
                res = XlfsMonResults.UPLOAD_BEGIN_FAILED;
            }
            finally
            {
                this.req = null;
                if (this.resp != null)
                {
                    this.resp.Close();
                }
                this.resp = null;
            }

            return res;
        }

        private XlfsMonResults SyncToCloudPass1()
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;

            res = AcquireSAML();
            if (res != XlfsMonResults.SUCCESS)
            {
                return res;
            }

            res = AcquireSAS();
            if (res != XlfsMonResults.SUCCESS)
            {
                return res;
            }

            return res;
        }

        private XlfsMonResults PutBlock()
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;
            Stream reqStream = null;
            try
            {
                this.blockIdBase64 = Convert.ToBase64String(Encoding.ASCII.GetBytes("10000001"));
                string urlEncodedBlockId = HttpUtility.UrlPathEncode(this.blockIdBase64);
                string putBlockSasUri = string.Format("{0}&comp=block&blockid={1}&timeout=90", this.sas, urlEncodedBlockId);

                this.req = (HttpWebRequest)WebRequest.Create(putBlockSasUri);

                // Setup the proxy
                if (XlfsMonConfig.webProxy != null)
                {
                    this.req.Proxy = XlfsMonConfig.webProxy;
                }

                this.req.UserAgent = XlfsMonConfig.sSource;
                this.req.Method = "PUT";
                this.req.ContentLength = bData.Length;
                reqStream = this.req.GetRequestStream();
                reqStream.Write(bData, 0, bData.Length);

                // Call the server
                this.resp = (HttpWebResponse)this.req.GetResponse();

                // Always get the following fields
                this.info.Update("PutBlock-status", (int)this.resp.StatusCode);

                string reqBody = RequestGetBody(this.resp);
                if (String.IsNullOrEmpty(reqBody) == false)
                {
                    this.info.Update("PutBlock-response", reqBody);
                }

                string reqId = this.resp.GetResponseHeader("x-ms-request-id");
                if (string.IsNullOrEmpty(reqId) == false)
                {
                    this.info.Update("x-ms-request-id", reqId);
                }

                // See if the request failed
                if (this.resp.StatusCode >= HttpStatusCode.BadRequest)
                {
                    XlfsMonConfig.currentErrorString = string.Format("PutBlock failed with status code {0}", this.resp.StatusCode);
                    throw new Exception(XlfsMonConfig.currentErrorString);
                }
            }
            catch (Exception ex)
            {
                XlfsMonConfig.currentErrorString = ex.Message;
                res = XlfsMonResults.XLFS_SYNC_FAILED;
            }
            finally
            {
                if (reqStream != null)
                {
                    reqStream.Close();
                }
                if (this.resp != null)
                {
                    this.resp.Close();
                    this.resp = null;
                }

            }

            return res;
        }

        private XlfsMonResults PutBlockList()
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;
            try
            {
                string putBlockListSasUri = string.Format("{0}&comp=blocklist&timeout=90", this.sas);
                string xmldoc = string.Format("<?xml version=\"1.0\" encoding=\"utf-8\"?><BlockList><Latest>{0}</Latest></BlockList>", this.blockIdBase64);
                byte[] bXmlDoc = Encoding.ASCII.GetBytes(xmldoc.ToCharArray());
                string putblockListMD5Value = Convert.ToBase64String(this.md5Hash.ComputeHash(bXmlDoc));

                Stream reqStream = null;
                this.req = (HttpWebRequest)WebRequest.Create(putBlockListSasUri);

                // Setup the proxy
                if (XlfsMonConfig.webProxy != null)
                {
                    this.req.Proxy = XlfsMonConfig.webProxy;
                }

                this.req.UserAgent = XlfsMonConfig.sSource;
                this.req.Method = "PUT";
                this.req.Headers.Add("x-ms-version", "2009-09-19");
                this.req.Headers.Add("x-ms-blob-content-md5", this.md5HashValue);
                this.req.Headers.Add("Content-MD5", putblockListMD5Value);
                this.req.ContentLength = bXmlDoc.Length;
                reqStream = this.req.GetRequestStream();
                reqStream.Write(bXmlDoc, 0, bXmlDoc.Length);

                // Call the server
                this.resp = (HttpWebResponse)this.req.GetResponse();

                // Always get the following fields
                this.info.Update("PutBlockList-status", (int)this.resp.StatusCode);

                string reqBody = RequestGetBody(this.resp);
                if (String.IsNullOrEmpty(reqBody) == false)
                {
                    this.info.Update("PutBlockList-response", reqBody);
                }

                string reqId = this.resp.GetResponseHeader("x-ms-request-id");
                if (string.IsNullOrEmpty(reqId) == false)
                {
                    this.info.Update("x-ms-request-id", reqId);
                }

                // See if the request failed
                if (this.resp.StatusCode >= HttpStatusCode.BadRequest)
                {
                    XlfsMonConfig.currentErrorString = string.Format("PutBlockList failed with status code {0}", this.resp.StatusCode);
                    throw new Exception(XlfsMonConfig.currentErrorString);
                }
            }
            catch (Exception ex)
            {
                XlfsMonConfig.currentErrorString = ex.Message;
                res = XlfsMonResults.XLFS_SYNC_FAILED;
            }
            finally
            {
                if (this.req != null)
                {
                    this.req.GetRequestStream().Close();
                    this.req = null;
                }
                if (this.resp != null)
                {
                    this.resp.Close();
                    this.resp = null;
                }
            }

            return res;
        }

        private XlfsMonResults SyncToCloudPass2()
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;

            res = this.PutBlock();
            if (res != XlfsMonResults.SUCCESS)
            {
                return res;
            }

            res = this.PutBlockList();
            if (res != XlfsMonResults.SUCCESS)
            {
                return res;
            }

            return res;
        }

        private XlfsMonResults SyncToCloudPass3()
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;
            string uploadEndUri = string.Format("{0}/UploadEnd.ashx", XlfsMonConfig.azureFDUri);
            try
            {
                this.req = (HttpWebRequest)WebRequest.Create(uploadEndUri);
                this.req.Headers.Add("x-ms-on-behalf-user-xuid", userXuid);
                this.req.Headers.Add("x-ms-on-behalf-titleid", titleId);
                this.req.Headers.Add("x-ms-transaction-id", this.xactId);
                this.req.Headers.Add("Content-MD5", this.md5HashValue);
                this.req.Headers.Add("X-Authorization", this.securityToken);

                // Setup the proxy
                if (XlfsMonConfig.webProxy != null)
                {
                    this.req.Proxy = XlfsMonConfig.webProxy;
                }

                // Call the server
                this.resp = (HttpWebResponse)this.req.GetResponse();

                // Always get the following fields
                this.info.Update("UploadEnd.ashx-status", (int)this.resp.StatusCode);

                string reqBody = RequestGetBody(this.resp);
                if (String.IsNullOrEmpty(reqBody) == false)
                {
                    this.info.Update("UploadEnd.ashx-response", reqBody);
                }

                string xlfsVersion = this.resp.GetResponseHeader("x-ms-xlfs-version");
                if (String.IsNullOrEmpty(xlfsVersion) == false)
                {
                    info.Update("x-ms-xlfs-version", xlfsVersion);
                }

                // See if the request failed
                if ((int)this.resp.StatusCode > 400)
                {
                    XlfsMonConfig.currentErrorString = string.Format("UploadEnd.ashx returns failed with status code {0}", this.resp.StatusCode);
                    throw new Exception(XlfsMonConfig.currentErrorString);
                }
            }
            catch (Exception ex)
            {
                XlfsMonConfig.currentErrorString = ex.Message;
                res = XlfsMonResults.UPLOAD_END_FAILED;
            }
            finally
            {
                this.req = null;
                if (this.resp != null)
                {
                    this.resp.Close();
                }
                this.resp = null;
            }
            return res;
        }

        private XlfsMonResults TestAdmindFDPage()
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;
            string pageUri = string.Format("{0}/default.aspx", XlfsMonConfig.azureAdminFDUri);

            try
            {
                this.req = (HttpWebRequest)WebRequest.Create(pageUri);
                this.req.UseDefaultCredentials = false;
                this.req.AuthenticationLevel = AuthenticationLevel.MutualAuthRequired;
                this.req.ClientCertificates.Add(XlfsMonConfig.azureAdminCertificate);

                // Setup the proxy
                if (XlfsMonConfig.webProxy != null)
                {
                    this.req.Proxy = XlfsMonConfig.webProxy;
                }

                // Call the server
                this.resp = (HttpWebResponse)this.req.GetResponse();

                // Always get the following fields
                this.info.Update("adminfd/Default.aspx-status", (int)this.resp.StatusCode);

                string reqBody = RequestGetBody(this.resp);
                if (String.IsNullOrEmpty(reqBody) == false && XlfsMonConfig.verbose == true)
                {
                    this.info.Update(
                        "adminfd/Default.aspx-response",
                        reqBody
                        );
                }

                if ((int)this.resp.StatusCode > 400)
                {
                    XlfsMonConfig.currentErrorString = string.Format(
                        "adminfd/Default.aspx returned failed with status code {1}",
                        this.resp.StatusCode
                        );
                    throw new Exception(XlfsMonConfig.currentErrorString);
                }
            }
            catch (Exception ex)
            {
                XlfsMonConfig.currentErrorString = ex.Message;
                res = XlfsMonResults.DOWNLOAD_ADMIN_DEFAULT_PAGE_FAILED;
            }
            finally
            {
                this.req = null;
                if (this.resp != null)
                {
                    this.resp.Close();
                }
                this.resp = null;
            }
            return res;
        }

        private XlfsMonResults TestClientFDPage()
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;
            string pageUri = string.Format("{0}/default.aspx", XlfsMonConfig.azureFDUri);

            try
            {
                this.req = (HttpWebRequest)WebRequest.Create(pageUri);

                // Setup the proxy
                if (XlfsMonConfig.webProxy != null)
                {
                    this.req.Proxy = XlfsMonConfig.webProxy;
                }

                // Call the server
                this.resp = (HttpWebResponse)this.req.GetResponse();

                // Always get the following fields
                this.info.Update("clientfd/Default.aspx-status", (int)this.resp.StatusCode);

                string reqBody = RequestGetBody(this.resp);
                if (String.IsNullOrEmpty(reqBody) == false && XlfsMonConfig.verbose == true)
                {
                    this.info.Update(
                        "clientfd/Default.aspx-response",
                        reqBody
                        );
                }

                if ((int)this.resp.StatusCode > 400)
                {
                    XlfsMonConfig.currentErrorString = string.Format(
                        "clientfd/Default.aspx returned failed with status code {1}",
                        this.resp.StatusCode
                        );
                    throw new Exception(XlfsMonConfig.currentErrorString);
                }
            }
            catch (Exception ex)
            {
                XlfsMonConfig.currentErrorString = ex.Message;
                res = XlfsMonResults.DOWNLOAD_CLIENT_DEFAULT_PAGE_FAILED;
            }
            finally
            {
                this.req = null;
                if (this.resp != null)
                {
                    this.resp.Close();
                }
                this.resp = null;
            }
            return res;
        }

        private XlfsMonResults DownloadFromCloud()
        {
            // Put in a small delay to make sure that Azure has the file
            System.Threading.Thread.Sleep(10000);

            // Create a new process to run the xlfsconsole downloader
            Process downloadProc = new Process();
            downloadProc.StartInfo = new ProcessStartInfo(
                XlfsMonConfig.xlfsConsoleDownloaderPath,
                XlfsMonConfig.xlfsConsoleDownloaderArgument
                );
            downloadProc.StartInfo.UseShellExecute = false;
            downloadProc.StartInfo.CreateNoWindow = true;
            downloadProc.StartInfo.RedirectStandardOutput = true;
            downloadProc.StartInfo.RedirectStandardError = true;

            // Execute the process
            if (downloadProc.Start() == false)
            {
                XlfsMonConfig.currentErrorString = downloadProc.StandardOutput.ReadToEnd();
                XlfsMonConfig.currentErrorString = XlfsMonConfig.currentErrorString.Trim();
                return XlfsMonResults.DOWNLOAD_START_FAILURE;
            }

            // Grab the output in case we need it later
            string output = downloadProc.StandardOutput.ReadToEnd();
            output = output.Trim();

            // Make sure that the process is done
            if (downloadProc.HasExited == false)
            {
                downloadProc.WaitForExit(5000);
                if (downloadProc.HasExited == false)
                {
                    downloadProc.Kill();
                }
            }

            // Only check for the result code at this point
            if (downloadProc.ExitCode != 0)
            {
                XlfsMonConfig.currentErrorString = output;
                return XlfsMonResults.DOWNLOAD_FAILED;
            }

            return XlfsMonResults.SUCCESS;
        }

        private XlfsMonResults DeleteDummyFile()
        {
            string[] files = null;

            try
            {
                files = Directory.GetFiles(XlfsMonConfig.xlfsConsoleSaveDirectory, "*" + XlfsMonConfig.xlfsTargetName + "*");
            }
            catch (Exception e)
            {
                XlfsMonConfig.currentErrorString = String.Format(
                    "Could not find {0} due to exception: {1}",
                    XlfsMonConfig.xlfsTargetName, e.ToString());
                return XlfsMonResults.DOWNLOAD_FILE_NOT_FOUND;
            }

            if (files.Length == 0)
            {
                XlfsMonConfig.currentErrorString = String.Format("Could not find {0}", XlfsMonConfig.xlfsTargetName);
                return XlfsMonResults.DOWNLOAD_FILE_NOT_FOUND;
            }

            try
            {
                foreach (string file in files)
                {
                    System.IO.File.Delete(file);
                }
            }
            catch (Exception e)
            {
                XlfsMonConfig.currentErrorString = String.Format(
                    "Could not delete {0} due to exception: {1}",
                    XlfsMonConfig.xlfsTargetName, e.ToString());
                return XlfsMonResults.DOWNLOAD_FILE_NOT_DELETED;
            }

            return XlfsMonResults.SUCCESS;
        }

        private void LogEvent(XlfsMonResults res)
        {
            EventLogEntryType type;
            int eventId = unchecked((int)XEvent.Id.XLFS_MON_SUCCEEDED);

            if (!EventLog.SourceExists(XlfsMonConfig.sSource))
            {
                EventLog.CreateEventSource(XlfsMonConfig.sSource, XlfsMonConfig.sLog);
            }

            // Strings to always include
            info.Update("xlfsmon-description", XlfsMonConfig.eventStrings[(int)res]);
            info.Update("xlfsmon-environment", XlfsMonConfig.currentEnvironment);

            // Strings to include if present
            if (String.IsNullOrEmpty(XlfsMonConfig.currentErrorString) == false)
            {
                info.Update("xlfsmon-error", XlfsMonConfig.currentErrorString.Replace("\n", "\n\t"));
            }
            if (String.IsNullOrEmpty(XlfsMonConfig.currentSubscription) == false)
            {
                info.Update("xlfsmon-subscription", XlfsMonConfig.currentSubscription);
            }
            if (res != XlfsMonResults.SUCCESS)
            {
                if (String.IsNullOrEmpty(XlfsMonConfig.xlfsMonArgument) == false)
                {
                    info.Update("xlfsmon-args", XlfsMonConfig.xlfsMonArgument);
                }
                if (String.IsNullOrEmpty(XlfsMonConfig.xlfsMonConfigSettings) == false)
                {
                    info.Update("xlfsmon-settings", XlfsMonConfig.xlfsMonConfigSettings);
                }
            }

            type = (res == XlfsMonResults.SUCCESS) ? EventLogEntryType.Information : EventLogEntryType.Error;
            switch (res)
            {
                case XlfsMonResults.SUCCESS:
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_SUCCEEDED);
                    break;
                case XlfsMonResults.SAML_FAILED:
                    info.Update("x-ms-on-behalf-user-xuid", userXuid);
                    info.Update("x-ms-on-behalf-titleid", titleId);
                    info.Update("Content-MD5", this.md5HashValue);
                    // description.AppendFormat("X-Authorization: {0}\n", this.securityToken);
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_SAML_FAILED);
                    break;
                case XlfsMonResults.UPLOAD_BEGIN_FAILED:
                    info.Update("x-ms-on-behalf-user-xuid", userXuid);
                    info.Update("x-ms-on-behalf-titleid", titleId);
                    info.Update("Content-MD5", this.md5HashValue);
                    if (String.IsNullOrEmpty(this.xactId) == false)
                    {
                        info.Update("x-ms-transaction-id", this.xactId);
                    }
                    // description.AppendFormat("X-Authorization: {0}\n", this.securityToken);
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_UPLOAD_BEGIN_FAILED);
                    break;
                case XlfsMonResults.XLFS_SYNC_FAILED:
                    info.Update("x-ms-on-behalf-user-xuid", userXuid);
                    info.Update("x-ms-on-behalf-titleid", titleId);
                    info.Update("Content-MD5", this.md5HashValue);
                    if (String.IsNullOrEmpty(this.xactId) == false)
                    {
                        info.Update("x-ms-transaction-id", this.xactId);
                    }
                    // description.AppendFormat("X-Authorization: {0}\n", this.securityToken);
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_XLFS_SYNC_FAILED);
                    break;
                case XlfsMonResults.UPLOAD_END_FAILED:
                    info.Update("x-ms-on-behalf-user-xuid", userXuid);
                    info.Update("x-ms-on-behalf-titleid", titleId);
                    info.Update("Content-MD5", this.md5HashValue);
                    if (String.IsNullOrEmpty(this.xactId) == false)
                    {
                        info.Update("x-ms-transaction-id", this.xactId);
                    }
                    // description.AppendFormat("X-Authorization: {0}\n", this.securityToken);
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_UPLOAD_END_FAILED);
                    break;
                case XlfsMonResults.DOWNLOAD_FAILED:
                    info.Update("xlfsconsoledownloader", XlfsMonConfig.xlfsConsoleDownloaderPath);
                    info.Update("xlfsconsoledownloader-args", XlfsMonConfig.xlfsConsoleDownloaderArgument);
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_DOWNLOAD_FAILED);
                    break;
                case XlfsMonResults.DOWNLOAD_START_FAILURE:
                    info.Update("xlfsconsoledownloader", XlfsMonConfig.xlfsConsoleDownloaderPath);
                    info.Update("xlfsconsoledownloader-args", XlfsMonConfig.xlfsConsoleDownloaderArgument);
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_DOWNLOAD_START_FAILED);
                    break;
                case XlfsMonResults.DOWNLOAD_FILE_NOT_FOUND:
                    info.Update("xlfsconsoledownloader", XlfsMonConfig.xlfsConsoleDownloaderPath);
                    info.Update("xlfsconsoledownloader-args", XlfsMonConfig.xlfsConsoleDownloaderArgument);
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_DOWNLOAD_FILE_NOT_FOUND);
                    break;
                case XlfsMonResults.DOWNLOAD_FILE_NOT_DELETED:
                    info.Update("xlfsconsoledownloader", XlfsMonConfig.xlfsConsoleDownloaderPath);
                    info.Update("xlfsconsoledownloader-args", XlfsMonConfig.xlfsConsoleDownloaderArgument);
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_DOWNLOAD_FILE_NOT_DELETED);
                    break;
                case XlfsMonResults.DOWNLOAD_CLIENT_DEFAULT_PAGE_FAILED:
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_DOWNLOAD_CLIENT_DEFAULT_PAGE_FAILED);
                    break;
                case XlfsMonResults.DOWNLOAD_ADMIN_DEFAULT_PAGE_FAILED:
                    eventId = unchecked((int)XEvent.Id.XLFS_MON_DOWNLOAD_ADMIN_DEFAULT_PAGE_FAILED);
                    break;
                default:
                    eventId = unchecked((int)XEvent.Id.XLFS_INTERNAL_FAILURE);
                    break;
            }

            StringBuilder description = new StringBuilder();
            foreach (KeyValuePair<string, string> kvp in info)
            {
                description.AppendFormat("{0}: {1}\n", kvp.Key, kvp.Value);
            }

            EventLog.WriteEntry(XlfsMonConfig.sSource, description.ToString(), type, (eventId & UInt16.MaxValue));
            if (XlfsMonConfig.verbose)
            {
                Console.Out.Write(description.ToString());
            }
        }

        private string RequestGetBody(HttpWebResponse resp)
        {
            Char[] readBuffer = new Char[256];
            Encoding encoding = System.Text.Encoding.GetEncoding("utf-8");
            int count;
            Stream respStream = resp.GetResponseStream();
            StreamReader readStream = new StreamReader(respStream, encoding);
            StringBuilder sb = new StringBuilder();

            // Read the string 256 bytes at a time
            count = readStream.Read(readBuffer, 0, 256);
            while (count > 0)
            {
                sb.Append(readBuffer);
                count = readStream.Read(readBuffer, 0, 256);
            }

            // Done with the stream
            readStream.Close();

            // Return the body
            return sb.ToString();
        }

        public void Start()
        {
            XlfsMonResults res = XlfsMonResults.SUCCESS;
            //if ((res = TestClientFDPage()) != XlfsMonResults.SUCCESS)
            //{

            //} else 
            if ((res = SyncToCloudPass1()) != XlfsMonResults.SUCCESS)
            {

            }
            else if ((res = SyncToCloudPass2()) != XlfsMonResults.SUCCESS)
            {

            }
            else if ((res = SyncToCloudPass3()) != XlfsMonResults.SUCCESS)
            {

            }
            else if ((res = TestAdmindFDPage()) != XlfsMonResults.SUCCESS)
            {

            }
            else if ((res = DownloadFromCloud()) != XlfsMonResults.SUCCESS)
            {

            }
            else if ((res = DeleteDummyFile()) != XlfsMonResults.SUCCESS)
            {

            }

            LogEvent(res);

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\Common.cs ===
using System;
using System.Windows.Forms;
using System.Xml;

using ServerTestFramework;
using xonline.server.xlfs.common;

using PropertyDescription = System.ComponentModel.DescriptionAttribute;
using ServerTestFramework.LiveService.Storage.Azure;
using System.Collections.Generic;
using System.IO;

namespace Xlfs.Test
{
    public class XlfsTestSettings : ICloneable
    {
        public static XlfsTestSettings Current = new XlfsTestSettings();

        /// <summary>
        /// Indicates whether or not tests should automatically
        /// delete files that are uploaded to the service when 
        /// a tests is complete
        /// </summary>
        [PropertyDescription("Indicates whether or not tests should automatically delete files from the cloud that they create")]
        public Boolean AutoDeleteFilesFromCloud { get; set; }

        /// <summary>
        /// The Profile Name for the settings currently used.
        /// </summary>
        public string Profile
        {
            get { return XLFSConfigMgr.CurrentProfile.name; }
            set { XLFSConfigMgr.CurrentProfile.name = value; }
        }

        /// <summary>
        /// The address of the XLFS Client FD
        /// </summary>
        [PropertyDescription("The address of the XlfsClientFD")]
        public Uri XlfsClientServer
        {
            get { return XlfsConfiguration.XlfsFdUri; }
            set { XlfsConfiguration.XlfsFdUri = value; }
        }

        /// <summary>
        /// The address of the XLFS Admin FD
        /// </summary>
        [PropertyDescription("The address of the XlfsAdminFD")]
        public Uri XlfsAdminServer 
        {
            get { return XlfsConfiguration.XlfsAdminFdUri; }
            set { XlfsConfiguration.XlfsAdminFdUri = value; }
        }

        public string XlfsAdminServerCert
        {
            get { return XLFSConfigMgr.Services[XLFSConfigMgr.CurrentProfile.AdminService].cert; }
            set { XLFSConfigMgr.Services[XLFSConfigMgr.CurrentProfile.AdminService].cert = value; }
        }

        /// <summary>
        /// The address of the XLFS Test FD
        /// </summary>
        [PropertyDescription("The address of the XlfsTestFD")]
        public Uri XlfsTestServer
        {
            get { return XlfsConfiguration.XlfsTestFdUri; }
            set { XlfsConfiguration.XlfsTestFdUri = value; }
        }

        public Dictionary<String, XLFSConfigService> XlfsServices
        {
            get { return XLFSConfigMgr.Services; }
        }

        public StorageAccountInformation XlfsTableStorage
        {
            get { return XlfsConfiguration.XlfsTableStorage; }
            set { XlfsConfiguration.XlfsTableStorage = value; }
        }

        public String AdminFdCertCN
        {
            get { return XlfsTests.DefaultAdminFDCert; }
            set { XlfsTests.DefaultAdminFDCert = value; }
        }

        static XlfsTestSettings() { }

        public XlfsTestSettings() { }

        public Object Clone()
        {
            XlfsTestSettings clone = new XlfsTestSettings();

            clone.AutoDeleteFilesFromCloud = this.AutoDeleteFilesFromCloud;

            return clone;
        }
    }

    public class XlfsTestSettingsMenu : STFGui.Plugins.IPluginGui, STFGui.Plugins.IPluginPreferences
    {
        /// <summary>
        /// Convenience accessor for the current settings object
        /// </summary>
        private XlfsTestSettings settings
        {
            get { return XlfsTestSettings.Current; }
            set { XlfsTestSettings.Current = value; }
        }

        public ICloneable PluginPreferences
        {
            get { return settings; }
            set 
            {
                XlfsTestSettings newSettings = value as XlfsTestSettings;
                if (newSettings == null)
                {
                    throw new ArgumentException("Invalid settings object provided for XlfsTestSettings");
                }
                settings = newSettings; 
            }
        }

        public MenuItem GetNewMenu()
        {
            MenuItem baseMenu = new MenuItem("XLFS");

            MenuItem autoDeleteMenuItem = new MenuItem("Auto Delete Uploaded Files", new EventHandler(autoDeleteMenuItem_Click));
            autoDeleteMenuItem.Checked = settings.AutoDeleteFilesFromCloud;
            baseMenu.MenuItems.Add(autoDeleteMenuItem);

            MenuItem deleteAllFilesMenuItem = new MenuItem("Delete All Uploaded Files", new EventHandler(deleteAllFilesMenuItem_Click));
            baseMenu.MenuItems.Add(deleteAllFilesMenuItem);

            List<MenuItem> profileMenuItems = new List<MenuItem>();
            
            foreach (XLFSProfile profile in XLFSConfigMgr.Profiles.Values)
            {
                MenuItem menuItem = new MenuItem(profile.name, new EventHandler(profileSelectMenuItem_Click));
                if (profile.name == XLFSConfigMgr.CurrentProfile.name)
                {
                    menuItem.Checked = true;
                }
                profileMenuItems.Add(menuItem);
            }

            MenuItem profilesMenuItem = new MenuItem("Profiles", profileMenuItems.ToArray());
            baseMenu.MenuItems.Add(profilesMenuItem);

            return baseMenu;
        }

        void autoDeleteMenuItem_Click(object sender, EventArgs e)
        {
            MenuItem menuItem = sender as MenuItem;

            // Swap the checked state and set the setting value
            settings.AutoDeleteFilesFromCloud = menuItem.Checked = !menuItem.Checked;
        }

        void deleteAllFilesMenuItem_Click(object sender, EventArgs e)
        {
            MenuItem menuItem = sender as MenuItem;

            DownloaderTestHelper.ClearCloud(
                new Predicate<FileTableLastUpdateEntry>(
                    x =>
                    {
                        bool del = x.Filename.StartsWith("Xlfs_");
                        if (del) { Global.RO.Info("Deleting " + x.Filename); }
                        return del;
                    }
                ));
        }

        void profileSelectMenuItem_Click(object sender, EventArgs e)
        {
            MenuItem menuItem = sender as MenuItem;
            foreach (MenuItem item in menuItem.Parent.MenuItems)
            {
                item.Checked = false;
            }
            menuItem.Checked = true;
            XLFSConfigMgr.CurrentProfile = XLFSConfigMgr.Profiles[menuItem.Text];
            XLFSConfigMgr.SetProfile(menuItem.Text);
        }

        #region IPluginGui Members

        public STFGui.Plugins.MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public TabPage GetNewTabPage ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }

    public static class StorageAccountTableEntryExtensions
    {
        public static StorageAccountTableEntry Clone(this StorageAccountTableEntry entry)
        {
            StorageAccountTableEntry clone = new StorageAccountTableEntry();
            clone.PartitionKey = entry.PartitionKey;
            clone.RowKey = entry.RowKey;
            clone.Capacity = entry.Capacity;
            clone.Key = entry.Key;
            clone.Threshold = entry.Threshold;
            clone.Used = entry.Used;

            return clone;
        }

        public static void ApplyValues(this StorageAccountTableEntry entry, StorageAccountTableEntry otherEntry)
        {
            entry.PartitionKey = otherEntry.PartitionKey;
            entry.RowKey = otherEntry.RowKey;
            entry.Key = otherEntry.Key;
            entry.Capacity = otherEntry.Capacity;
            entry.Threshold = otherEntry.Threshold;
            entry.Used = otherEntry.Used;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\dummyxlfstrace.cs ===
using System;
using ServerTestFramework;
using xonline.server.xlfs.common;

namespace Xlfs.Test
{
    public class StfXlfsTraceFactory : IXlfsTraceFactory
    {
        public IXlfsTrace Create()
        {
            return new StfXlfsTrace();
        }

        public IXlfsTrace Create(string tag)
        {
            return new StfXlfsTrace(tag);
        }
    }

    /// <summary>
    /// Tracing interface.
    /// </summary>
    public class StfXlfsTrace : IXlfsTrace
    {
        /// <summary>
        /// Causes an exception to be thrown when an error trace is written
        /// This allows us to react when error traces are dumped by service
        /// code even if it handles the error gracefully (i.e. doesn't crash)
        /// </summary>
        public static Boolean ThrowOnError { get; set; }

        private string _tag;

        public StfXlfsTrace() {}
        public StfXlfsTrace(string tag) 
        {
            _tag = tag;
        }

        public void AddAttribute(string name, string value)
        {
            Global.RO.Debug("StfXlfsTrace.AddAttribute(\"{0}\", \"{1}\") tag={2}", name, value, _tag);
        }

        public void Flush()
        {
            Global.RO.Debug("StfXlfsTrace.Flush() tag={0}", _tag);
        }

        public void AppendErrorLine(string msg)
        {
            String errorMsg = String.Format("StfXlfsTrace.AppendErrorLine(\"{0}\") tag={1}", msg, _tag);
            Global.RO.Error(errorMsg);
            if(ThrowOnError)
            {
                throw new UnexpectedTestResultException(errorMsg);
            }
        }

        public void AppendErrorLine(string msg, params object [] args)
        {
            AppendErrorLine(string.Format(msg, args));
        }

        public void AppendWarningLine(string msg)
        {
            Global.RO.Warn("StfXlfsTrace.AppendWarningLine(\"{0}\") tag={1}", msg, _tag);
        }

        public void AppendWarningLine(string msg, params object [] args)
        {
            AppendWarningLine(string.Format(msg, args));
        }

        public void AppendInfoLine(string msg)
        {
            Global.RO.Debug("StfXlfsTrace.AppendInfoLine(\"{0}\") tag={1}", msg, _tag);
        }

        public void AppendInfoLine(string msg, params object[] args)
        {
            AppendInfoLine(string.Format(msg, args));
        }

        public void AppendLine(string msg)
        {
            Global.RO.Debug("StfXlfsTrace.AppendLine(\"{0}\") tag={1}", msg, _tag);
        }

        public void AppendLine(string msg, params object[] args)
        {
            AppendLine(string.Format(msg, args));
        }

        public void WriteEvent(string msg)
        {
            Global.RO.Info("StfXlfsTrace.WriteEvent(\"{0}\") tag={1}", msg, _tag);
        }

        public void WriteEvent(string msg, params object[] args)
        {
            WriteEvent(string.Format(msg, args));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\XLFSConfig.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using ServerTestFramework.LiveService.Storage.Azure;

namespace Xlfs.Test
{
    public static class XLFSConfigMgr
    {
        private static Dictionary<string, XLFSProfile> _profiles;
        private static Dictionary<string, XLFSConfigService> _services;
        private static Dictionary<string, string> _storageAccounts;
        private static XLFSProfile _currentProfile;

        public static Dictionary<string, XLFSProfile> Profiles
        {
            get
            {
                return _profiles;
            }
        }

        public static Dictionary<string, XLFSConfigService> Services
        {
            get
            {
                return _services;
            }
        }

        public static Dictionary<string, string> StorageAccounts
        {
            get
            {
                return _storageAccounts;
            }
        }

        public static XLFSProfile CurrentProfile
        {
            get
            {
                return _currentProfile;
            }
            set
            {
                _currentProfile = value;
            }
        }

        static XLFSConfigMgr()
        {
            // Initialize dictionaries...
            _profiles = new Dictionary<string, XLFSProfile>();
            _services = new Dictionary<string, XLFSConfigService>();
            _storageAccounts = new Dictionary<string, string>();

            string xlfsConfigFile = Path.Combine(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location), @"XLFSConfig.xml");
            XDocument data = XDocument.Load(xlfsConfigFile);
            string activeProfile = (from c in data.Descendants("profiles")
                                    select c.Attribute("active").Value).FirstOrDefault();


            _profiles = (from c in data.Descendants("profile")
                        select new XLFSProfile
                          {
                              name = (string)c.Attribute("name").Value,
                              XLFSService = (string)c.Attribute("xlfs").Value,
                              AdminService = (string)c.Attribute("xlfsAdmin").Value,
                              StorageAccount = (string)c.Attribute("storageAccount").Value
                          }).ToDictionary(p => p.name);

            string defaultCert = (from c in data.Descendants("services")
                                  select c.Attribute("cert").Value).FirstOrDefault();

            _services = (from c in data.Descendants("service")
                         select new XLFSConfigService()
                         {
                             name = c.Attribute("name").Value,
                             address = (c.Attribute("address") != null) ? c.Attribute("address").Value : String.Format("{0}.cloudapp.net", c.Attribute("name").Value),
                             cert = (c.Attribute("cert") != null) ? c.Attribute("cert").Value : defaultCert,
                             scheme = c.Attribute("scheme").Value,
                             port = c.Attribute("port").Value
                         }).ToDictionary(p => p.name);

            _storageAccounts = (from c in data.Descendants("storageAccount")
                                select new 
                                {
                                    key = c.Attribute("name").Value,
                                    value = c.Attribute("key").Value
                                }).ToDictionary(p => p.key, p => p.value);
            
            SetProfile(activeProfile);
        }

        /// <summary>
        /// Map a named profile onto the STFLive's XLFSConfiguration static class
        /// </summary>
        /// <param name="profileName"></param>
        public static void SetProfile(string profileName)
        {
            _currentProfile = Profiles[profileName];
            
            XLFSConfigService service = Services[_currentProfile.XLFSService];

            XlfsConfiguration.XlfsFdUri = new Uri(String.Format("{0}://{1}:{2}/", service.scheme, service.address, service.port));
            
            service = Services[_currentProfile.AdminService];
            XlfsConfiguration.XlfsAdminFdUri = new Uri(String.Format("{0}://{1}:{2}/", service.scheme, service.address, service.port));

            StorageAccountInformation storage = new StorageAccountInformation();
            storage.StorageAccount = _currentProfile.StorageAccount;
            storage.StorageKey = StorageAccounts[_currentProfile.StorageAccount];
            storage.CloudBaseAddress = String.Format("https://{0}.table.core.windows.net/", _currentProfile.StorageAccount);
            XlfsConfiguration.XlfsTableStorage = storage;

            storage = new StorageAccountInformation();
            storage.StorageAccount = _currentProfile.StorageAccount;
            storage.StorageKey = StorageAccounts[_currentProfile.StorageAccount];
            storage.CloudBaseAddress = String.Format("https://{0}.queue.core.windows.net/", _currentProfile.StorageAccount);
            XlfsConfiguration.XlfsQueueStorage = storage;
        }
    }

    /// <summary>
    /// Encapsulates a XLFS Config Profile
    /// </summary>
    public class XLFSProfile
    {
        /// <summary>
        /// Arbitrary name of the profile
        /// </summary>
        public string name
        {
            get;
            set;
        }

        /// <summary>
        /// Service Name for the XLFS FD
        /// </summary>
        public string XLFSService
        {
            get;
            set;
        }

        /// <summary>
        /// Service Name for the Admin Service
        /// </summary>
        public string AdminService
        {
            get;
            set;
        }

        /// <summary>
        /// Name of the Storage Account
        /// </summary>
        public string StorageAccount
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Wraps a XLFS Service in Config
    /// </summary>
    public class XLFSConfigService
    {
        public string name
        {
            get;
            set;
        }

        public string address
        {
            set;
            get;
        }

        public string scheme
        {
            get;
            set;
        }

        public string port
        {
            get;
            set;
        }

        public string cert
        {
            get;
            set;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\FrontDoor\FrontDoorSuite.cs ===
using System;
using System.Collections.Generic;
using ServerTestFramework;
using System.Security.Cryptography.X509Certificates;
using System.IO;
using System.Text;
using System.Xml;
using ServerTestFramework.Utilities;
using ServerTestFramework.STS;
using ServerTestFramework.LiveService;

[assembly: RootNode(typeof(Xlfs.Test.XlfsTests))]

namespace Xlfs.Test
{
    [TestGroup, TestFrequency("Daily")]
    public class XlfsTests: TestNode
    {
        public const long OneTeraByte = 1024L * 1024L * 1024L * 1024L; // 1TB
        public const long StorageAccountCapacity = OneTeraByte * 100L; // 100TB
        public const long StorageAccountThreshold = OneTeraByte * 80L; // 80TB

        public static List<UInt32> AllowedTitlesList = new List<UInt32>(new UInt32[] { 0xFFFE07D1, 0x4D5308FC, 0x4D5308FB, 0x4D530907 });
        public static String DefaultAdminFDCert = "XlfsAdminFDClient";

        // In order to generate the SAML tokens we need a signing certificate
        // Load one here that we can use
        public static X509Certificate2 SamlCertificate = new X509Certificate2(@"SuitesData\Xlfs\test-azure.xboxlive.com.pfx", "XblRocks!");

        private static GetSecurityTokenParameters samlParameters;
        public static GetSecurityTokenParameters SamlParameters
        {
            get { return new GetSecurityTokenParameters(samlParameters); }
        }

        public static String GenerateSecurityToken()
        {
            return GenerateSecurityToken(samlParameters);
        }

        public static String GenerateSecurityToken(GetSecurityTokenParameters samlParams)
        {
            return SamlTokenUtil.GetSecurityToken(samlParams);
        }

        public override void PreRun()
        {
            samlParameters = new GetSecurityTokenParameters(XOn.XPLT_XBOX360);
            samlParameters.Certificate = SamlCertificate;//STSUtil.GetStsSigningCertificate();
            samlParameters.Audience = "http://sts.xboxlive.com";

            //Allow overrided titles list from the stf.xml as a comma or semicolon delimetted list
            // <allowedtitles list="0xFFFE07D1,0x4D5308FC,0x4D5308FB,0x4D530907"
            // if we can't parse it use the default
            XmlNodeList titleNodeList = Global.Config.GetElementsByTagName("allowedtitles");
            if (titleNodeList.Count > 0)
            {
                XmlNode xlfsNode = titleNodeList[0];

                try
                {
                    String titlesString = xlfsNode.Attributes["list"].Value;
                    if (!String.IsNullOrEmpty(titlesString))
                    {
                        List<string> titlestringList = new List<string>(titlesString.Split(new char[] { ',', ';' }));
                        List<uint> titlesList = new List<uint>();
                        foreach (string titleString in titlestringList)
                        {
                            string tempString = titleString;
                            if (tempString.StartsWith("0x"))
                                tempString = tempString.Substring(2);
                            uint titleId = 0;
                            if (UInt32.TryParse(tempString, out titleId))
                            {
                                titlesList.Add(titleId);
                            }
                        }
                        if (titlesList.Count > 0)
                        {
                            AllowedTitlesList = titlesList;
                        }
                    }

                }
                catch(Exception ex)
                {
                    Global.RO.Error("Could not parse allowed titles list from xml, using default.\nEx: {0}", ex);
                }
            }
            //XmlNodeList xlfsNodeList = Global.Config.GetElementsByTagName("xlfsAdmin");
            //if (xlfsNodeList.Count > 0)
            //{
            //    XmlNode xlfsNode = xlfsNodeList[0];

            //    String adminCertName;
            //    try { adminCertName = xlfsNode.Attributes["cert"].Value; }
            //    catch { adminCertName = "XlfsAdminFDClient"; }

            //    DefaultAdminFDCert = adminCertName;
            //}
            String adminCertName;
            try { adminCertName = XLFSConfigMgr.Services[XLFSConfigMgr.CurrentProfile.AdminService].cert; }
            catch { adminCertName = "XlfsAdminFDClient"; }

            DefaultAdminFDCert = adminCertName;
        }

        public static string RandomString(int length, int charIdMin, int charIdMax)
        {
            StringBuilder randomString = new StringBuilder();
            if (charIdMin > charIdMax)
                throw new ArgumentOutOfRangeException("charIdMax", "charIdMax must be greater than charIdMin");
            if((charIdMin > (int)Char.MaxValue)
                ||(charIdMax > (int)Char.MaxValue))
                throw new ArgumentOutOfRangeException("charIdMax", "charIdMin/charIdMax must be less than Char.MaxValue");

            for (int count = 0; count < length; count++)
            {
                char randomChar = unchecked((char)RandomEx.GlobalRandGen.Next(charIdMin, charIdMax));
                randomString.Append(randomChar);
            }

            return randomString.ToString();
        }

        public static byte[] RandomHash()
        {
            byte[] hashArray = new byte[16];
            RandomEx.GlobalRandGen.NextBytes(hashArray);

            return hashArray;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\FrontDoor\xlfsStress.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.LiveService.Storage.Azure;
using ServerTestFramework.Core.Utilities;
using System.IO;
using ServerTestFramework.STS;
using ServerTestFramework.LiveService;

namespace Xlfs.Test
{
    public class StressXlfsUploadBegin
    {
        private byte[] byteArray;
        private XlfsUploadBegin beginReq;

        public StressXlfsUploadBegin(XlfsUploadBegin BeginReq, byte[] ByteArray)
        {
            this.byteArray = ByteArray;
            this.beginReq = BeginReq;
        }

        public XlfsUploadBegin GetXlfsUploadBegin
        {
            get { return this.beginReq; }
        }

        public byte[] GetByteArray
        {
            get { return this.byteArray; }
        }
    }



    [TestGroup]
    public class XlfsStress : TestNode
    {

        static Queue asyncReadyForFileUpload;
        static Queue asyncReadyForUploadContinue;
        static Queue asyncReadyForUploadEnd;
        static Queue readyForFileUpload;
        static Queue readyForUploadContinue;
        static Queue readyForUploadEnd;


        public override void OneTimeSetup()
        {
            asyncReadyForFileUpload = new Queue(); //<StressXlfsUploadBegin>();
            asyncReadyForUploadContinue = new Queue(); //<StressXlfsUploadBegin>();
            asyncReadyForUploadEnd = new Queue(); //<XlfsUploadEnd>();
            readyForFileUpload = Queue.Synchronized(asyncReadyForFileUpload);
            readyForUploadContinue = Queue.Synchronized(asyncReadyForUploadContinue);
            readyForUploadEnd = Queue.Synchronized(asyncReadyForUploadEnd);
        }

        public static XlfsUploadBegin StressUploadBegin(byte[] FileToUpload)
        {
            GetSecurityTokenParameters samlParameters = new GetSecurityTokenParameters(XOn.XPLT_XBOX360);
            samlParameters.Certificate = XlfsTests.SamlCertificate;
            samlParameters.Audience = "http://sts.xboxlive.com";

            XlfsUploadBegin beginReq = new XlfsUploadBegin();
            beginReq.SamlParameters = XlfsTests.SamlParameters;
            beginReq.UserXuid = beginReq.SamlParameters.Xuid[0];
            beginReq.TitleId = beginReq.SamlParameters.TitleID.Value;

            MemoryStream memoryStream = new MemoryStream(FileToUpload);
            memoryStream.Seek(0, SeekOrigin.Begin);
            byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
            String fileName = String.Format("XlfsStress_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

            beginReq.FileHash = memoryHash;
            beginReq.FileName = fileName;

            if (!beginReq.Execute())
            {
                throw beginReq.RequestException;
            }

            return beginReq;
        }

        public static void StressUploadFile(XlfsUploadBegin beginReq, byte[] FileToUpload)
        {
            // Create a BlobClient using the SAS Url returned by the beginReq
            BlobClient blobClient = new BlobClient(beginReq.StorageUri);
            string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
            //Global.RO.Info("Storage Path: " + storagePath);

            MemoryStream memoryStream = new MemoryStream(FileToUpload);
            memoryStream.Seek(0, SeekOrigin.Begin);
            blobClient.PutBlob(storagePath, memoryStream);
            memoryStream.Seek(0, SeekOrigin.Begin);
        }
        
        public static void UploadBegin(Int32 FileSizeKb)
        {
            XlfsPartner partner = XlfsPartner.GetPartner();

            GetSecurityTokenParameters samlParameters = new GetSecurityTokenParameters(XOn.XPLT_XBOX360);
            samlParameters.Certificate = XlfsTests.SamlCertificate;
            samlParameters.Audience = "http://sts.xboxlive.com";
            samlParameters.TitleID = partner.TitleId;

            XlfsUploadBegin beginReq = new XlfsUploadBegin();
            beginReq.SamlParameters = samlParameters;
            beginReq.UserXuid = beginReq.SamlParameters.Xuid[0];
            beginReq.TitleId = beginReq.SamlParameters.TitleID.Value;

            beginReq.FileHash = partner.MD5Hash;
            beginReq.FileName = partner.FileName;

            if (!beginReq.Execute())
            {
                throw new UnexpectedTestResultException("UploadBegin failed.", beginReq.RequestException);
            }

            readyForFileUpload.Enqueue(new StressXlfsUploadBegin(beginReq, partner.File));
        }

        /// <summary>
        /// Calls UploadBegin and saves the XlfsUploadBegin object for future use (during FileUpload and UploadEnd).
        /// </summary>
        [StressTest]
        public class UploadBegin_1K : TestNode
        {
            public override void Run()
            {
                XlfsStress.UploadBegin(1);
            }
        }


        /// <summary>
        ///  1. Dequeue an XlfsUploadBegin request.
        ///  2. Upload the file (which will set the fileName and fileHash)
        ///  3. Create a 
        /// </summary>
        [StressTest]
        public class UploadFile : TestNode
        {
            public override void Run()
            {
                StressXlfsUploadBegin beginReq = null;
                TimeSpan timeSinceUploadBegin = new TimeSpan();

                //Get a current uploadFile off the stack that doesn't have an SAS URL near expiry
                do
                {
                    try
                    {
                        beginReq = (StressXlfsUploadBegin)readyForFileUpload.Dequeue();
                    }
                    catch (InvalidOperationException)
                    {
                        throw new DidNotExecuteException(
                            "Begin request queue is empty so UploadFile cannot run.  Call UploadBegin prior to UploadFile.");
                    }

                    timeSinceUploadBegin = DateTime.UtcNow - beginReq.GetXlfsUploadBegin.DateTimeOfExecute;
                    if (timeSinceUploadBegin.TotalMinutes > 50)
                    {
                        //It's about to expire, throw it on the continue stack
                        readyForUploadContinue.Enqueue(beginReq);
                    }
                } 
                while (timeSinceUploadBegin.TotalMinutes > 50);

                //UploadFile
                try
                {
                    StressUploadFile(beginReq.GetXlfsUploadBegin, beginReq.GetByteArray);
                    readyForUploadEnd.Enqueue(ClientFD.CreateEndReq(beginReq.GetXlfsUploadBegin));
                }
                catch (Exception ex)
                {
                    throw new UnexpectedTestResultException("UploadFile failed.", ex);
                }
            }            
        }

        [StressTest]
        public class UploadEnd : TestNode
        {
            public override void Run()
            {
                XlfsUploadEnd endRequest;
                try
                {
                    endRequest = (XlfsUploadEnd)readyForUploadEnd.Dequeue();
                }
                catch (InvalidOperationException)
                {
                    throw new DidNotExecuteException(
                        "End request queue is empty so UploadEnd cannot run.  Call UploadBegin and UploadFile prior to UploadEnd.");
                }

                if (!endRequest.Execute())
                {
                    throw new UnexpectedTestResultException("UploadEnd failed", endRequest.RequestException);
                }
            }
        }

        [StressTest]
        public class UploadContinue : TestNode
        {
            public override void Run()
            {
                StressXlfsUploadBegin beginReq = null;

                try
                {
                    //Try the continue stack first
                    beginReq = (StressXlfsUploadBegin)readyForUploadContinue.Dequeue();
                }
                catch (InvalidOperationException)
                {
                    try
                    {
                        //Continue is empty, grab one off the begin.
                        beginReq = (StressXlfsUploadBegin)readyForFileUpload.Dequeue();
                    }
                    catch (InvalidOperationException)
                    {
                        throw new DidNotExecuteException(
                            "Begin request queue is empty so UploadContinue cannot run.  Call UploadBegin prior to UploadContinue.");
                    }
                }

                if (!beginReq.GetXlfsUploadBegin.Execute())
                {
                    throw new UnexpectedTestResultException("UploadBegin (Continue flavor) failed.", beginReq.GetXlfsUploadBegin.RequestException);
                }

                readyForFileUpload.Enqueue(beginReq);
            }
        }

        [StressTest]
        [CompoundCase("1KB", 1)]
        [CompoundCase("10KB", 10)]
        [CompoundCase("100KB", 100)]
        [CompoundCase("1MB", 1000)]
        [CompoundCase("10MB", 10000)]
        [CompoundCase("100MB", 100000)]
        [CompoundCase("1GB", 1000000)]
        public class End2End : TestNode
        {
            protected Int32 fileSizeKb = 0;

            public End2End() { }

            public End2End(Int32 FileSize)
            {
                this.fileSizeKb = FileSize;
            }

            public override void PreRun()
            {
                this.fileSizeKb = (Int32)this.MyValues[0];
            }

            public override void Run()
            {
                byte[] byteArray = new byte[1024 * fileSizeKb];  // test
                RandomEx.GlobalRandGen.NextBytes(byteArray);
                MemoryStream memoryStream = new MemoryStream(byteArray);
                memoryStream.Seek(0, SeekOrigin.Begin);
                byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                String fileName = String.Format("XlfsStress_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                //Execute Begin
                XlfsUploadBegin beginReq = new XlfsUploadBegin();
                GetSecurityTokenParameters samlParameters = new GetSecurityTokenParameters(XOn.XPLT_XBOX360);
                samlParameters.Certificate = XlfsTests.SamlCertificate;
                samlParameters.Audience = "http://sts.xboxlive.com";

                beginReq.SamlParameters = XlfsTests.SamlParameters;
                beginReq.UserXuid = beginReq.SamlParameters.Xuid[0];
                beginReq.TitleId = beginReq.SamlParameters.TitleID.Value;
                beginReq.FileName = String.Format("Xlfs_UploadBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                beginReq.FileHash = XlfsTests.RandomHash();
                beginReq.FileName = fileName;
                beginReq.FileHash = memoryHash;

                beginReq.Execute();

                // bug 138127 - attempt to upload within 1500ms of UploadBegin will cause 403 - Forbidden.
                // System.Threading.Thread.Sleep(1500);

                // Create a BlobClient using the SAS Url returned by the beginReq
                BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                Global.RO.Info("Storage Path: " + storagePath);
                blobClient.PutBlob(storagePath, memoryStream);
                memoryStream.Seek(0, SeekOrigin.Begin);

                //System.Threading.Thread.Sleep(5000);

                //Execute End
                XlfsUploadEnd endReq = new XlfsUploadEnd();
                endReq.SamlParameters = new GetSecurityTokenParameters(beginReq.SamlParameters);
                endReq.UserXuid = beginReq.UserXuid;
                endReq.TitleId = beginReq.TitleId;
                endReq.TransactionId = beginReq.TransactionId;
                endReq.FileHash = beginReq.FileHash;
                endReq.FileLength = memoryStream.Length;
                endReq.Execute();                
            }
        }

        [StressTest]
        [CompoundCase("5Minutes", 5)]
        [CompoundCase("15Minutes", 15)]
        [CompoundCase("30Minutes", 30)]
        [CompoundCase("45Minutes", 45)]
        [CompoundCase("60Minutes", 60)]
        public class AdminGetChangedBlobs : TestNode
        {
            protected Int32 timeSpanMinutes = 0;

            public AdminGetChangedBlobs() { }

            public AdminGetChangedBlobs(Int32 Minutes)
            {
                this.timeSpanMinutes = Minutes;
            }

            public override void PreRun()
            {
                this.timeSpanMinutes = (Int32)MyValues[0];
            }

            public override void Run()
            {
                XlfsAdminGetChangedBlobs changedBlobReq = new XlfsAdminGetChangedBlobs();
                changedBlobReq.RequestCertificate = XlfsTests.DefaultAdminFDCert;
                changedBlobReq.TitleId = XlfsPartner.GetRandomTitleId();
                DateTime utcNow = DateTime.UtcNow;
                //Since we can't use DateTime.UtcNow for the base (to avoid caching) since it would go over the hour boundary
                //We'll use a random shift between 0 and 60 - timeSpanMinutes
                int shiftModulo = 60 - timeSpanMinutes;
                int minuteShift = 0;
                if (shiftModulo > 0)
                    minuteShift = RandomEx.GlobalRandGen.Next() % shiftModulo;
                DateTime startTime = new DateTime(utcNow.Year,
                                                    utcNow.Month,
                                                    utcNow.Day,
                                                    utcNow.Hour, minuteShift, 0, utcNow.Kind);
                changedBlobReq.StartTime = startTime.AddHours(-1); // Need to use last hour since this one only has partial data
                changedBlobReq.EndTime = changedBlobReq.StartTime.Value.AddMinutes(timeSpanMinutes);

                if (!changedBlobReq.Execute())
                {
                    throw changedBlobReq.RequestException;
                }
            }
        }

        [StressTest]
        public class AdminGetChangedBlobsContinue : TestNode
        {
            public override void Run()
            {
                XlfsAdminGetChangedBlobsContinue changedBlobContReq = new XlfsAdminGetChangedBlobsContinue();
                changedBlobContReq.RequestCertificate = XlfsTests.DefaultAdminFDCert;
                changedBlobContReq.TitleId = XlfsTests.SamlParameters.TitleID.Value;

                if (!changedBlobContReq.Execute())
                {
                    throw changedBlobContReq.RequestException;
                }
            }
        }

        /// <summary>
        /// Purpose of this class is to allow modelling of different partners during stress - to more accurately reflect prod usage.
        /// </summary>
        public class XlfsPartner
        {
            private const double Megabyte = 1024 * 1024;

            private static Random rnd;
            private static List<uint> titleWeights;
            private static Dictionary<uint, uint> titleFileSize;

            private uint titleId;
            private string fileName;
            private uint fileSize;
            private byte[] file;
            private byte[] md5Hash;

            private XlfsPartner() { } // no objects created via constructor.

            static XlfsPartner()
            {
                rnd = new Random();
                titleFileSize = new Dictionary<uint, uint>();

                // setup weighted array to allow us to randomly select a titleId
                titleWeights = new List<uint>(1000);
                for (int i = 0; i < 772; i++)
                {
                    titleWeights.Add(0xFFFF0640);
                }
                for (int i = 0; i < 216; i++)
                {
                    titleWeights.Add(0xFFFF0641);
                }
                for (int i = 0; i < 5; i++)
                {
                    titleWeights.Add(0x4D53093A);
                }
                for (int i = 0; i < 3; i++)
                {
                    titleWeights.Add(0x4D53891A);
                }
                for (int i = 0; i < 2; i++)
                {
                    titleWeights.Add(0xFFFF063F);
                }
                for (int i = 0; i < 2; i++)
                {
                    titleWeights.Add(0x4D5308FC);
                }

                // TitleId       Avg MB file size.
                //0xFFFF0640	0.097211
                //0x4D5308FC	17.981245
                //0x4D53093A	3.918597
                //0x4D53891A	4.083863
                //0x4D538921	49.433349
                //0x4D530907	30.767445
                //0xFFFF0641	0.015514
                //0x4D5308FB	6.467665
                //0xFFFF063F	0.000054

                titleFileSize.Add(0xFFFF0640, Convert.ToUInt32(0.097211 * Megabyte));
                titleFileSize.Add(0x4D5308FC, Convert.ToUInt32(17.981245 * Megabyte));
                titleFileSize.Add(0x4D53093A, Convert.ToUInt32(3.918597 * Megabyte));
                titleFileSize.Add(0x4D53891A, Convert.ToUInt32(4.083863 * Megabyte));
                titleFileSize.Add(0x4D538921, Convert.ToUInt32(49.433349 * Megabyte));
                titleFileSize.Add(0x4D530907, Convert.ToUInt32(30.767445 * Megabyte));
                titleFileSize.Add(0xFFFF0641, Convert.ToUInt32(0.015514 * Megabyte));
                titleFileSize.Add(0x4D5308FB, Convert.ToUInt32(6.467665 * Megabyte));
                titleFileSize.Add(0xFFFF063F, Convert.ToUInt32(0.000054 * Megabyte));
            }

            public static uint GetRandomTitleId()
            {
                Int32 index = rnd.Next(0, 1000);
                return titleWeights[index];
            }

            /// <summary>
            /// Get a random partner - with appropriate file size, define md5 hash and file name.
            /// </summary>
            /// <returns></returns>
            public static XlfsPartner GetPartner()
            {
                XlfsPartner partner = new XlfsPartner();
                Int32 index = rnd.Next(0, 1000);
                partner.titleId = titleWeights[index];
                partner.file = GetPartnerFile(partner.titleId);
                partner.md5Hash = GetMd5Hash(partner.file);
                partner.fileName = String.Format("XlfsStress_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                return partner;
            }

            private static byte[] GetPartnerFile(uint TitleId)
            {
                uint fileSize = titleFileSize[TitleId];
                byte[] byteArray = new byte[fileSize];
                RandomEx.GlobalRandGen.NextBytes(byteArray);
                return byteArray;
            }

            private static byte[] GetMd5Hash(byte[] ByteArray)
            {
                MemoryStream memoryStream = new MemoryStream(ByteArray);
                memoryStream.Seek(0, SeekOrigin.Begin);
                byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                return memoryHash;
            }

            public string FileName
            {
                get { return this.fileName; }
                set { this.fileName = value; }
            }

            public uint TitleId
            {
                get { return this.titleId; }
                set { this.titleId = value; }
            }

            public uint FileSize
            {
                get { return this.fileSize; }
                set { this.fileSize = value; }
            }

            public byte[] File
            {
                get { return this.file; }
            }

            public byte[] MD5Hash
            {
                get { return this.md5Hash; }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\Storage\Storage.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Storage.Azure;
using ServerTestFramework.Core.Utilities;

namespace Xlfs.Test
{
    [TestGroup, Owner("trevorm"), TestFrequency("Daily"), TestCasePriority(1)]
    public class StorageTests : TestNode
    {
        public override void PreRun()
        {
            FileTableLastUpdateClient fileTable = new FileTableLastUpdateClient();
            fileTable.CreateIfNotExist();
            //fileTable.ReCreate();
            BlobTableClient blobTable = new BlobTableClient();
            blobTable.CreateIfNotExist();
            //blobTable.ReCreate();
        }

        [TestCase, TestFrequency("BVT"), Description("Writes, Reads and Removes a file to FileTable and blob storage"), TestCasePriority(0)]
        class WriteFile : TestBase
        {
            override protected void Execute()
            {
                XLFSClient xlfsClient = new XLFSClient();
                //ulong xuid = RandomEx.GlobalRandGen.NextUlong();
                ulong xuid = 12345;
                uint titleID = 0xfffe07d1;

                byte[] byteArray = new byte[1024];
                RandomEx.GlobalRandGen.NextBytes(byteArray);
                string testFileName = String.Format("Xlfs_WriteFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                DateTime testWriteTime = DateTime.UtcNow;

                try
                {
                    using (MemoryStream memoryStream = new System.IO.MemoryStream(byteArray))
                    {
                        memoryStream.Seek(0, System.IO.SeekOrigin.Begin);
                        Global.RO.Info("Writing File to {0}", xlfsClient.CloudBaseAddress);
                        xlfsClient.WriteFile(xuid, testFileName, titleID, memoryStream);

                        //Using the ReadFile with timestamp to do the more efficient search rather than searching all partitions
                        using (Stream readfs = xlfsClient.ReadFile(xuid, testFileName, titleID, testWriteTime))
                        {
                            if (readfs.Length == memoryStream.Length)
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                        }
                    }
                }
                finally
                {
                    //Using the RemoveFile with timestamp to do the more efficient search rather than searching all partitions
                    bool removeSucceded = xlfsClient.RemoveFile(xuid, testFileName, titleID, testWriteTime);
                    if (!removeSucceded)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, TestFrequency("BVT"), Description("Writes, Reads and Removes a file to BlobTable and blob storage"), TestCasePriority(0)]
        class WriteBlobFile : TestBase
        {
            override protected void Execute()
            {
                XLFSClient xlfsClient = new XLFSClient();
                //ulong xuid = RandomEx.GlobalRandGen.NextUlong();
                ulong xuid = 12345;
                uint titleID = 0xfffe07d1;

                byte[] byteArray = new byte[1024];
                RandomEx.GlobalRandGen.NextBytes(byteArray);
                string testFileName = String.Format("Xlfs_WriteFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                string transactionId = Guid.NewGuid().ToString("N");

                try
                {
                    using (MemoryStream memoryStream = new System.IO.MemoryStream(byteArray))
                    {
                        Global.RO.Info("Writing File to {0}", xlfsClient.CloudBaseAddress);
                        xlfsClient.WriteBlobFile(xuid, transactionId, testFileName, titleID, memoryStream);

                        using (Stream readfs = xlfsClient.ReadBlobFile(xuid, transactionId, testFileName, titleID))
                        {
                            if (readfs.Length == memoryStream.Length)
                            {
                                ResultCode = TEST_RESULTS.PASSED;
                            }
                        }
                    }
                }
                finally
                {
                    bool removeSucceded = xlfsClient.RemoveBlobFile(xuid, transactionId, testFileName, titleID);
                    if (!removeSucceded)
                        ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\FrontDoor\StorageAccountManagerTests.cs ===
using System;
using System.Collections.Generic;
using Microsoft.WindowsAzure;
using ServerTestFramework;
using ServerTestFramework.LiveService.Storage.Azure;
using xonline.server.xlfs.common;

namespace Xlfs.Test
{
    /// <summary>
    /// The purpose of this class is to snapshot the state of the
    /// StorageAccountTableEntry table prior to tests, and restore
    /// after the tests are complete.
    /// </summary>
    public class StorageAccountSnapshot
    {
        private List<StorageAccountTableEntry> _entries;

        public StorageAccountSnapshot()
        {
            Backup();
        }

        public void Backup()
        {
            StorageAccountTableClient client = new StorageAccountTableClient(
                XlfsConfiguration.XlfsTableStorage.StorageAccount,
                XlfsConfiguration.XlfsTableStorage.StorageKey,
                XlfsConfiguration.XlfsTableStorage.CloudBaseAddress);

            _entries = client.Select();
        }

        public void Restore()
        {
            StorageAccountTableClient client = new StorageAccountTableClient(
                XlfsConfiguration.XlfsTableStorage.StorageAccount,
                XlfsConfiguration.XlfsTableStorage.StorageKey,
                XlfsConfiguration.XlfsTableStorage.CloudBaseAddress);

            client.ClearTable();

            foreach (StorageAccountTableEntry entry in _entries)
            {
                client.AddStorageAccountTableEntry(entry);
            }
        }
    }
    
    [TestGroup, Owner("darrenan"), TestFrequency("Daily"), Description("Tests the StorageAccountManager class.")]
    public class StorageAccountManagerTests : TestNode
    {
        private static StorageAccountManager CreateStorageAccountManager()
        {
            return CreateStorageAccountManager(1000, 1000);
        }

        private static StorageAccountManager CreateStorageAccountManager(int refreshInteval, int updateUsedInterval)
        {
            StorageCredentialsAccountAndKey accountAndKey =
                new StorageCredentialsAccountAndKey(XlfsConfiguration.XlfsTableStorage.StorageAccount,
                                                    XlfsConfiguration.XlfsTableStorage.StorageKey);
            CloudStorageAccount tableStorageAccount = new CloudStorageAccount(accountAndKey, true);
            StorageAccountManager manager = new StorageAccountManager(tableStorageAccount, refreshInteval, updateUsedInterval, new StfXlfsTraceFactory());
            return manager;
        }

        [TestGroup, Owner("darrenan"), TestFrequency("Daily"), Description("Tests the StorageAccountManager.GetNextStorageAccount method.")]
        public class GetNextStorageAccount : TestNode
        {
            /// <summary>
            /// This test queries for the list of configured storage accounts, and
            /// verifies that each valid configured account is returned by GetNextStorageAccount.
            /// </summary>
            [TestCase, Owner("darrenan"), TestFrequency("Daily"), Description("Positive tests the storage account round-robin mechanism.")]
            public class P_GetNextStorageAccount : TestNode
            {
                public override void Run()
                {
                    using(StorageAccountManager manager = CreateStorageAccountManager())
                    {
                        List<string> storageAccountsRetrieved = new List<string>();
                        for (int currentAccount = 0; currentAccount < XlfsConfiguration.XlfsBlobStorage.Count; ++currentAccount)
                        {
                            CloudStorageAccount account = manager.GetNextStorageAccount(new StfXlfsTrace());
                            storageAccountsRetrieved.Add(account.Credentials.AccountName);
                        }

                        // Now make sure that every blob storage account configured
                        // was returned by GetNextStorageAccount().
                        foreach (string storageAccountName in XlfsConfiguration.XlfsBlobStorage.Keys)
                        {
                            if (!storageAccountsRetrieved.Contains(storageAccountName))
                            {
                                throw new UnexpectedTestResultException("GetNextStorageAccount did not return all accounts that were added.");
                            }
                        }
                    }
                }
            }

            /// <summary>
            /// This test sets up a single dummy storage account
            /// that has Used > Int32.Max, and then verifies that
            /// it gets utilized.
            /// </summary>
            [TestCase, Owner("darrenan"), TestFrequency("Daily"), Description("Makes sure that accounts with Used > Int32.Max are used.")]
            public class P_GetNextStorageAccountUsedGreaterThanMaxUInt32 : TestNode
            {
                public override void Run()
                {
                    // Create snapshot so we can return the 
                    // storage account table to its previous state.
                    StorageAccountSnapshot snap = new StorageAccountSnapshot();

                    try
                    {
                        StorageAccountTableClient client = new StorageAccountTableClient(
                            XlfsConfiguration.XlfsTableStorage.StorageAccount,
                            XlfsConfiguration.XlfsTableStorage.StorageKey,
                            XlfsConfiguration.XlfsTableStorage.CloudBaseAddress);
                        client.ClearTable();

                        // Initialize the table with a single entry.
                        // Need to use a valid account and key because
                        // storage account manager does a connection test.
                        StorageAccountTableEntry entry = new StorageAccountTableEntry();
                        entry.PartitionKey = XlfsConfiguration.XlfsTableStorage.StorageAccount;
                        entry.RowKey = "";
                        entry.Key = XlfsConfiguration.XlfsTableStorage.StorageKey;
                        entry.Capacity = ((long)UInt32.MaxValue) * 2;
                        entry.Threshold = (entry.Capacity * 80)/100;
                        entry.Used = ((long)UInt32.MaxValue) + 1;
                        client.AddStorageAccountTableEntry(entry);

                        // Create a storage account manager with no refresh tasks.
                        using (StorageAccountManager manager = CreateStorageAccountManager(0, 0))
                        {
                            CloudStorageAccount account = manager.GetNextStorageAccount(new StfXlfsTrace("StorageAccountManagerTests"));
                            if (account == null || account.Credentials.AccountName != XlfsConfiguration.XlfsTableStorage.StorageAccount)
                            {
                                throw new UnexpectedTestResultException("StorageAccountManager returned unexpected storage account info.");
                            }
                        }
                    }
                    finally
                    {
                        snap.Restore();
                    }
                }
            }

            [TestCase, Owner("darrenan"), TestFrequency("Daily"), Description("Positive tests the storage account round-robin mechanism.")]
            public class P_GetNextStorageAccountAllFull : TestNode
            {
                public override void Run()
                {
                    throw new DidNotExecuteException("This test not implemented yet.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\FrontDoor\ClientFD.cs ===
using System;
using System.Linq;
using System.Threading;
using System.Xml;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.LiveService.Storage.Azure;
using ServerTestFramework.Core.Utilities;
using System.Net;
using System.IO;
using ServerTestFramework.STS;
using xonline.server.xlfs.common;
using Microsoft.WindowsAzure;

namespace Xlfs.Test
{
    [TestGroup, Owner("benran"), TestFrequency("Daily"), Description("Tests the functionality of the ClientFD")]
    public class ClientFD : TestNode
    {
        #region CommonTestFunctions
        public static void GetRandomFile(Int32 fileSize, out Stream dataStream, out Byte[] dataHash)
        {
            if (fileSize == 0)
            {
                dataStream = null;
                dataHash = null;
            }
            else
            {
                Byte[] data = RandomEx.GlobalRandGen.GenerateRandomBlob(fileSize);
                dataStream = new MemoryStream(data);
                dataHash = BlobClient.GetMD5Hash(dataStream);
            }
        }

        public static XlfsUploadBegin CreateBeginReq()
        {
            XlfsUploadBegin beginReq = new XlfsUploadBegin();
            beginReq.SamlParameters = XlfsTests.SamlParameters;
            beginReq.UserXuid = beginReq.SamlParameters.Xuid[0];
            beginReq.TitleId = beginReq.SamlParameters.TitleID.Value;
            beginReq.FileName = String.Format("Xlfs_UploadBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
            beginReq.FileHash = XlfsTests.RandomHash();

            return beginReq;
        }

        public static XlfsUploadEnd CreateEndReq(XlfsUploadBegin beginReq)
        {
            XlfsUploadEnd endReq = new XlfsUploadEnd();
            endReq.SamlParameters = null;
            if(beginReq.SamlParameters != null)
                endReq.SamlParameters = new GetSecurityTokenParameters(beginReq.SamlParameters);
            endReq.UserXuid = beginReq.UserXuid;
            endReq.TitleId = beginReq.TitleId;
            endReq.TransactionId = beginReq.TransactionId;
            endReq.FileHash = beginReq.FileHash;
            endReq.FileName = beginReq.FileName;

            return endReq;
        }

        public static void ExecutePositiveBeginReq(XlfsUploadBegin beginReq)
        {
            ExecutePositiveBeginReq(beginReq, true);
        }

        public static void ExecutePositiveBeginReq(XlfsUploadBegin beginReq, Boolean verify)
        {
            if (!beginReq.Execute())
            {
                throw new UnexpectedTestResultException("Unable to perform UploadBegin request." + beginReq.GetExceptionString());
            }
            if (verify && !beginReq.Verify())
            {
                throw new UnexpectedTestResultException("UploadBegin Verify Failed.");
            }
            Global.RO.Success("XlfsUploadBegin Successful");
            //Global.RO.Debug("Storage Location: " + beginReq.StorageUri);
            Global.RO.Debug("Storage Host: " + beginReq.StorageUri.Remove(beginReq.StorageUri.IndexOf('/', 8)));
            Global.RO.Debug("Transaction GUID: " + beginReq.TransactionId);
        }

        public static void ExecuteNegativeBeginReq(XlfsUploadBegin beginReq, HttpStatusCode expectedStatus)
        {
            if (beginReq.Execute())
            {
                throw new UnexpectedTestResultException("Did not expect UploadBegin to succeed.");
            }

            ValueCheck.Test("BeginRequest HttpStatus", expectedStatus, beginReq.HttpStatus);

            Global.RO.Success("XlfsUploadBegin failed as expected.");
        }

        public static XlfsUploadBegin CreateAndExecuteBeginReq()
        {
            XlfsUploadBegin beginReq = CreateBeginReq();

            ExecutePositiveBeginReq(beginReq);

            return beginReq;
        }

        public static void ExecutePositiveEndReq(XlfsUploadEnd endReq)
        {
            ExecutePositiveEndReq(endReq, true);
        }

        public static void ExecutePositiveEndReq(XlfsUploadEnd endReq, Boolean verify)
        {
            if (!endReq.Execute())
            {
                throw new UnexpectedTestResultException("Unable to perform UploadEnd request." + endReq.GetExceptionString());
            }
            if (verify && !endReq.Verify())
            {
                if (endReq.UserXuid.HasValue && endReq.TitleId.HasValue)
                {
                    Global.RO.Error("PartitionKey: {0}, RowKey: {1}",
                        FileTableLastUpdateClient.GetPartitionKey(endReq.UserXuid.Value, endReq.TitleId.Value, "", endReq.DateTimeOfExecute),
                        FileTableLastUpdateClient.GetRowKey(endReq.UserXuid.Value, endReq.TitleId.Value, endReq.FileName));
                }
                throw new UnexpectedTestResultException("UploadEnd Verify Failed.");
            }
            Global.RO.Success("XlfsUploadEnd Successful");
        }

        public static void ExecuteNegativeEndReq(XlfsUploadEnd EndReq, HttpStatusCode expectedStatus)
        {
            if (EndReq.Execute())
            {
                throw new UnexpectedTestResultException("Did not expect UploadEnd to succeed.");
            }

            ValueCheck.Test("UploadEnd HttpStatus", expectedStatus, EndReq.HttpStatus);

            Global.RO.Success("XlfsUploadEnd failed as expected.");
        }

        public static void ExecutePositiveEndToEnd(XlfsUploadBegin beginReq, long fileSize)
        {
            byte[] byteArray = new byte[fileSize];
            RandomEx.GlobalRandGen.NextBytes(byteArray);
            MemoryStream memoryStream = new MemoryStream(byteArray);
            memoryStream.Seek(0, SeekOrigin.Begin);
            byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

            //Execute Begin
            beginReq.FileHash = memoryHash;
            ExecutePositiveBeginReq(beginReq);

            // Create a BlobClient using the SAS Url returned by the beginReq
            BlobClient blobClient = new BlobClient(beginReq.StorageUri);
            string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
            Global.RO.Info("Storage Path: " + storagePath);
            blobClient.PutBlob(storagePath, memoryStream);
            memoryStream.Seek(0, SeekOrigin.Begin);

            //Execute End
            XlfsUploadEnd endReq = CreateEndReq(beginReq);
            endReq.FileLength = memoryStream.Length;
            ExecutePositiveEndReq(endReq);

            //Verify
            XLFSClient xlfsClient = new XLFSClient();
            using (Stream readfs = xlfsClient.ReadFile(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute))
            {
                if (readfs == null)
                {
                    throw new UnexpectedTestResultException("File not returned from Storage");
                }
                if (readfs.Length != memoryStream.Length)
                {
                    throw new UnexpectedTestResultException("Length of uploaded file does not match storage file. 1024 : " + readfs.Length);
                }
            }
            xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute);
        }

        public static StorageAccountInformation GetFirstBlobStorageAccount()
        {
            return XlfsConfiguration.XlfsBlobStorage.Values.FirstOrDefault();
        }

        #endregion

        [TestGroup, Description("Validates that UploadBegin performs as expected.")]
        public class UploadBegin : TestNode
        {
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Performs a simple empty file upload to the XflsService.")]
            public class P_UploadBegin : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();

                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin an upload without specifying a filename.")]
            public class N_UploadBegin_NoFileName : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = null;

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload of a filename that's too long.")]
            public class N_UploadBegin_FileNameTooLong : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    // Maximum filename length is 259 characters.  See documentation for .NET File.Move method:
                    //      "The specified path, file name, or both exceed the system-defined maximum length. 
                    //       For example, on Windows-based platforms, paths must be less than 248 characters, 
                    //       and file names must be less than 260 characters."
                    // Filename is 260 characters long
                    beginReq.FileName = new String('A', 256) + ".bin";

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin with a filename with foreign (unicode) characters.")]
            public class P_UploadBegin_ForeignCharacters : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    //Japanese chars go from 0x3041 - 0xFA6A
                    beginReq.FileName = String.Format("Xlfs_UploadBeginForeign_{0}.bin", XlfsTests.RandomString(8, 0x3041, 0x9FA5));
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);

                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin with a filename with special characters.")]
            public class P_UploadBegin_FileNameSpecialCharacters : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq;

                    // Forward Slash - The filename goes into the RowKey of the FileTable eventually, and this character
                    // is not allowed in the RowKey of any table, so we should reject it early.
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginForwardSlash/{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();

                    // BackSlash - The filename goes into the RowKey of the FileTable eventually, and this character
                    // is not allowed in the RowKey of any table, so we should reject it early.
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginBackslash\\{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();

                    // Double BackSlash
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginDoubleBackslash\\\\{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();

                    // Dash
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginDash-{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();

                    // Spaces
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginSpace {0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();

                    // # - The filename goes into the RowKey of the FileTable eventually, and this character
                    // is not allowed in the RowKey of any table, so we should reject it early.
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginPound#{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();

                    // ? - The filename goes into the RowKey of the FileTable eventually, and this character
                    // is not allowed in the RowKey of any table, so we should reject it early.
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginQuestionMark?{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();

                    // & - The filename goes into the RowKey of the FileTable eventually, and this character
                    // is not allowed in the blob name, so we should reject it early.
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginAmpersand&{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();

                    // + - The filename goes into the RowKey of the FileTable eventually, and this character
                    // is not allowed in the blob name, so we should reject it early.
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginPlus+{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();

                    // Filename containing any URL Encoded characters is not valid.
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginUrlEncoded%31{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();

                    // Other Symbols are ok
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBeginSymbols_!@$%^*()[]<>,.{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload without specifying a UserXuid Param.")]
            public class N_UploadBegin_NoXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.UserXuid = null;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_NoXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload with an all zero UserXuid Param.")]
            public class N_UploadBegin_ZeroXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    samlParameters.Xuid = new ulong[4] { 0x0, 0x0, 0x0, 0x0 };
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_ZeroXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin an upload with an all 0x1 UserXuid Param.")]
            public class P_UploadBegin_OneXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    samlParameters.Xuid = new ulong[4] { 0x1, 0x1, 0x1, 0x1 };
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_OneXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin an upload with a UInt64.MaxValue UserXuid Param.")]
            public class P_UploadBegin_MaxXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    samlParameters.Xuid[0] = ulong.MaxValue;
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_MaxXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin an upload with all allowed TitleId Params.")]
            public class P_UploadBegin_AllowedTitleIds : TestNode
            {
                public override void Run()
                {
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    foreach (UInt32 titleId in XlfsTests.AllowedTitlesList)
                    {
                        XlfsUploadBegin beginReq = new XlfsUploadBegin();
                        samlParameters.TitleID = titleId;
                        beginReq.SamlParameters = samlParameters;
                        beginReq.UserXuid = samlParameters.Xuid[0];
                        beginReq.TitleId = titleId;
                        beginReq.FileName = String.Format("Xlfs_UploadBegin_AllowedTitle{0:X}_{1:X}.bin", titleId, RandomEx.GlobalRandGen.NextUlong());
                        beginReq.FileHash = XlfsTests.RandomHash();

                        ExecutePositiveBeginReq(beginReq);
                        beginReq.CleanUp();
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload without specifying a TitleId Param.")]
            public class N_UploadBegin_NoTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.TitleId = null;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_NoTitle_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload with an all zero TitleId Param.")]
            public class N_UploadBegin_ZeroTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt32 titleId = 0x0;
                    samlParameters.TitleID = titleId;
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_ZeroTitle_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload with a 0x1 TitleId Param.")]
            public class N_UploadBegin_OneTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt32 titleId = 0x1;
                    samlParameters.TitleID = titleId;
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = titleId;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_OneTitle_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload with a UInt32.MaxValue TitleId Param.")]
            public class N_UploadBegin_MaxTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt32 titleId = UInt32.MaxValue;
                    samlParameters.TitleID = titleId;
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_MaxTitle_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload with a Random (non-allowed) TitleId Param.")]
            public class N_UploadBegin_RandomTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt32 titleId;
                    do
                    {
                        titleId = unchecked((uint)RandomEx.GlobalRandGen.Next());
                    } while ((XlfsTests.AllowedTitlesList.Contains(titleId) == true) || (titleId == 0));

                    samlParameters.TitleID = titleId;
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_RandomTitle{0:X}_{1:X}.bin", titleId, RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload without specifying a FileHash Param.")]
            public class N_UploadBegin_NoFileHash : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_NoHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = null;

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin an upload with an all zero FileHash Param.")]
            public class P_UploadBegin_ZeroFileHash : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_ZeroHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin an upload with an all 0xFF FileHash Param.")]
            public class P_UploadBegin_MaxFileHash : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_MaxHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = new byte[] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload with a too long FileHash Param.")]
            public class N_UploadBegin_TooLongFileHash : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_TooLongHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = new byte[256]; //MD5 Hashes are 16 bytes
                    RandomEx.GlobalRandGen.NextBytes(beginReq.FileHash);

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadBegin on an existing file with an Changed FileHash.")]
            public class P_UploadBegin_ChangedFileHash : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_ChangedFileHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Upload the original File with original FileHash
                    XLFSClient xlfsClient = new XLFSClient();
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    DateTime writeFileTime = DateTime.UtcNow;
                    xlfsClient.WriteFile(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TitleId.Value, Guid.NewGuid().ToString("N"), writeFileTime, memoryStream);

                    //Generate a new FileHash
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq);
                    if (beginReq.Response.StatusCode != HttpStatusCode.NoContent)
                        throw new UnexpectedTestResultException("UploadBegin did not detect changed FileHash. StatusCode = " + beginReq.Response.StatusCode);

                    beginReq.CleanUp();
                    xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TitleId.Value, writeFileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadBegin on an existing file with an Unchanged FileHash.")]
            public class P_UploadBegin_SameFileHash : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_SameFileHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Upload the original File with original FileHash
                    XLFSClient xlfsClient = new XLFSClient();
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    DateTime writeFileTime = DateTime.UtcNow;
                    xlfsClient.WriteFile(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TitleId.Value, Guid.NewGuid().ToString("N"), writeFileTime, memoryStream);

                    //Get the existing FileHash
                    beginReq.FileHash = memoryHash;

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.NotModified);

                    //beginReq.CleanUp(); // No BeginRequest will start since the file hasn't "changed"
                    xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TitleId.Value, writeFileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin twice with the same filename.")]
            public class P_UploadBegin_ParallelUploadSameFile : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = String.Format("Xlfs_UploadBegin_ParallelUploadSameFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    XlfsUploadBegin beginReq2 = new XlfsUploadBegin();
                    beginReq2.SamlParameters = new GetSecurityTokenParameters(beginReq1.SamlParameters);
                    beginReq2.UserXuid = beginReq1.UserXuid;
                    beginReq2.TitleId = beginReq1.TitleId;
                    beginReq2.FileName = beginReq1.FileName;
                    beginReq2.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq1);

                    ExecutePositiveBeginReq(beginReq2);

                    if (beginReq1.TransactionId == beginReq2.TransactionId)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a new transaction.");
                    }

                    beginReq1.CleanUp();
                    beginReq2.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin twice with different filenames.")]
            public class P_UploadBegin_ParallelUploadDifferentFile : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = String.Format("Xlfs_UploadBegin_ParallelUploadDifferentFile1_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    XlfsUploadBegin beginReq2 = new XlfsUploadBegin(beginReq1);
                    beginReq2.FileName = String.Format("Xlfs_UploadBegin_ParallelUploadDifferentFile2_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq2.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq1);

                    ExecutePositiveBeginReq(beginReq2);

                    if (beginReq1.TransactionId == beginReq2.TransactionId)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a new transaction.");
                    }

                    beginReq1.CleanUp();
                    beginReq2.CleanUp();
                }
            }

            //Create a file table entry with no corresponding blob
            //Handles the FetchAttributes() error case for UploadBegin()
            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin on a file already in the file table but not in blob storage.")]
            public class P_UploadBegin_FileTableAlreadyExistsNoBlob : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_FileTableAlreadyExistsNoBlob_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Create a file table entry with no corresponding blob
                    FileTableLastUpdateClient fileTableClient = new FileTableLastUpdateClient();
                    FileTableLastUpdateEntry fileEntry = new FileTableLastUpdateEntry();
                    fileEntry.Created = DateTime.UtcNow;
                    fileEntry.LastUpdate = DateTime.UtcNow;
                    fileEntry.PartitionKey = FileTableLastUpdateClient.GetPartitionKey(
                                                            beginReq.UserXuid.Value, beginReq.TitleId.Value,
                                                            beginReq.FileName, fileEntry.LastUpdate.Value);
                    fileEntry.RowKey = FileTableLastUpdateClient.GetRowKey(
                                                            beginReq.UserXuid.Value, beginReq.TitleId.Value,
                                                            beginReq.FileName);
                    fileEntry.Filename = beginReq.FileName;
                    fileEntry.TitleId = unchecked((int)beginReq.TitleId);
                    fileEntry.Size = 1024;
                    fileEntry.TransactionId = BlobTableClient.GetRowKey(Guid.NewGuid());

                    StorageAccountInformation storageAccount = GetFirstBlobStorageAccount();
                    if (storageAccount == null)
                    {
                        throw new UnexpectedTestResultException("No blob storage accounts configured in stf.xml");
                    }
                    fileEntry.StorageAccount = storageAccount.StorageAccount;
                    fileEntry.UserXuid = unchecked((long)beginReq.UserXuid);
                    fileTableClient.AddFileTableEntry(fileEntry);

                    ExecutePositiveBeginReq(beginReq);

                    //UploadBegin should clean up the file table and succeed in creating a new BlobTableEntry
                    List<FileTableLastUpdateEntry> fileList = fileTableClient.SelectFile(beginReq.UserXuid.Value, beginReq.TitleId.Value, beginReq.FileName, fileEntry.LastUpdate.Value);
                    if (fileList.Count > 0)
                        throw new UnexpectedTestResultException("FileTableLastUpdateEntry found that should've been cleaned up by UploadBegin");

                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Write a blob using the SAS Url returned by UploadBegin.")]
            public class P_UploadBegin_SASUrlWrite : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadBegin_SASUrlWrite_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    XLFSClient xlfsClient = new XLFSClient();
                    using (Stream readStream = xlfsClient.ReadBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value))
                    {
                        if ((readStream == null) || (readStream.Length != memoryStream.Length))
                        {
                            throw new UnexpectedTestResultException("Blob was not read from storage.");
                        }
                    }
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Read a blob using the SAS Url returned by UploadBegin.")]
            public class N_UploadBegin_SASUrlRead : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadBegin_SASUrlRead_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    try
                    {
                        Stream readBlobStream = blobClient.GetBlobAsStream(storagePath);
                        if (readBlobStream != null)
                        {
                            throw new UnexpectedTestResultException("Blob successfully read from storage when it should've failed.");
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("Read Blob failed as expected using SAS Url.");
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("List a blob using the SAS Url returned by UploadBegin.")]
            public class N_UploadBegin_SASUrlList : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadBegin_SASUrlList_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    try
                    {
                        List<string> blobList = blobClient.GetBlobList();
                        if (blobList.Count != 0)
                        {
                            Global.RO.Debug("BlobList: {0}", blobList.ToString());
                            throw new UnexpectedTestResultException("Blob successfully listed blobs from storage when it should've failed.");
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("List Blob failed as expected using SAS Url.");
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Remove a blob using the SAS Url returned by UploadBegin.")]
            public class N_UploadBegin_SASUrlRemove : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadBegin_SASUrlRemove_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    try
                    {
                        bool removeSucceeded = blobClient.DeleteBlob(storagePath);
                        if (removeSucceeded)
                        {
                            throw new UnexpectedTestResultException("Blob successfully removed from storage when it should've failed.");
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("Remove Blob failed as expected using SAS Url.");
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Write a different blob from the UploadBegin Request using the SAS Url.")]
            public class N_UploadBegin_SASUrlWriteOther : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadBegin_SASUrlWriteOther_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    String otherFileName = String.Format("Xlfs_UploadBegin_SASUrlWriteOtherFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, otherFileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    try
                    {
                        blobClient.PutBlob(storagePath, memoryStream);
                        memoryStream.Seek(0, SeekOrigin.Begin);
                        XLFSClient xlfsClient = new XLFSClient();
                        Stream readStream = xlfsClient.ReadBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, otherFileName, beginReq.TitleId.Value);
                        if ((readStream != null) && (readStream.Length == memoryStream.Length))
                        {
                            throw new UnexpectedTestResultException("Blob was written to storage when it should've failed.");
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("Writing a different filename failed as expected using SAS Url.");
                    }

                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("List containers using the SAS Url returned by UploadBegin.")]
            public class N_UploadBegin_SASUrlListContainer : TestNode
            {
                public override void Run()
                {

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_SASUrlListContainers_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    try
                    {
                        List<string> containerList = blobClient.GetContainers();
                        if (containerList.Count != 0)
                        {
                            Global.RO.Debug("ContainerList: {0}", containerList.ToString());
                            throw new UnexpectedTestResultException("Blob successfully listed containers from storage when it should've failed.");
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("List Blob failed as expected using SAS Url.");
                    }
                    beginReq.CleanUp();
                }
            }
        }

        [TestGroup, Description("Validates that UploadContinue performs as expected.")]
        public class UploadContinue : TestNode
        {
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Call UploadBegin twice to simulate the continue case.  Should succeed.")]
            public class P_UploadContinue : TestNode
            {
                public override void Run()
                {
                    //  UploadBegin first, to get the transaction id.
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    ExecutePositiveBeginReq(beginReq);

                    // Now call UploadBegin again, this time passing in the transaction id.
                    ExecutePositiveBeginReq(beginReq);

                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call UploadBegin with a transaction id.  Should return a 400.")]
            public class N_UploadContinue_NoBegin : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin continueReq = CreateBeginReq();
                    continueReq.FileName = String.Format("N_UploadContinue_NoBegin_{0}.bin", XlfsTests.RandomString(8, 0x3041, 0x9FA5));
                    continueReq.TransactionId = BlobTableClient.GetRowKey(Guid.NewGuid());

                    ExecuteNegativeBeginReq(continueReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadContinue after UploadEnd called. Should return a 304.")]
            public class N_UploadContinue_AfterEnd : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    //  UploadBegin first, to get the transaction id.
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_AfterEnd_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);

                    //Call UploadBegin on the transaction that has been completed
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.NotModified);
                    beginReq.CleanUp();
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to continue an upload without specifying a UserXuid Param.")]
            public class N_UploadContinue_NoXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_NoXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    ExecutePositiveBeginReq(beginReq);

                    XlfsUploadBegin continueReq = new XlfsUploadBegin(beginReq);
                    continueReq.UserXuid = null;
                    ExecuteNegativeBeginReq(continueReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to begin an upload with an all zero UserXuid Param.")]
            public class N_UploadContinue_ZeroXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin continueReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt64 userXuid = 0x0;
                    samlParameters.Xuid[0] = userXuid;
                    continueReq.SamlParameters = samlParameters;
                    continueReq.UserXuid = samlParameters.Xuid[0];
                    continueReq.TitleId = samlParameters.TitleID.Value;
                    continueReq.TransactionId = BlobTableClient.GetRowKey(Guid.NewGuid());

                    //Create the Row in the Blob Table since a BeginReq would fail
                    BlobTableClient blobTableClient = new BlobTableClient();
                    BlobTableEntry blobEntry = new BlobTableEntry();
                    blobEntry.PartitionKey = continueReq.UserXuid.Value.ToString(BlobTableEntry.XuidFormatString);
                    blobEntry.RowKey = continueReq.TransactionId;
                    blobEntry.TitleId = unchecked((int)continueReq.TitleId);
                    blobEntry.Filename = String.Format("Xlfs_UploadContinue_ZeroXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    blobEntry.MD5 = BlobClient.GetMD5HashString(XlfsTests.RandomHash());
                    blobTableClient.AddBlobTableEntry(blobEntry);

                    ExecuteNegativeBeginReq(continueReq, HttpStatusCode.Unauthorized);

                    blobTableClient.SafeDeleteBlobTableEntry(blobEntry);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin an upload with an all 0x1 UserXuid Param.")]
            public class P_UploadContinue_OneXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    samlParameters.Xuid[0] = 0x1;
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_OneXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq);
                    ExecutePositiveBeginReq(beginReq);

                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin an upload with a UInt64.MaxValue UserXuid Param.")]
            public class P_UploadContinue_MaxXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    ulong userXuid = ulong.MaxValue;
                    samlParameters.Xuid[0] = userXuid;
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = userXuid;
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_MaxXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq);
                    ExecutePositiveBeginReq(beginReq);

                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadContinue with a different Xuid from the UploadBegin.")]
            public class N_UploadContinue_XuidDifferentFromBegin : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt64 userXuid0 = RandomEx.GlobalRandGen.NextPuid();
                    UInt64 userXuid1 = RandomEx.GlobalRandGen.NextPuid();

                    samlParameters.Xuid[0] = userXuid0;
                    samlParameters.Xuid[1] = userXuid1;

                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.SamlParameters = samlParameters;
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_XuidDifferentFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq);

                    // Change the xuid
                    XlfsUploadBegin continueReq = new XlfsUploadBegin(beginReq);
                    continueReq.UserXuid = userXuid1;

                    ExecuteNegativeBeginReq(continueReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadContinue with a different Xuid in the Saml token from the UploadBegin.")]
            public class P_UploadContinue_SamlXuidDifferentFromBegin : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    beginReq.UserXuid = RandomEx.GlobalRandGen.NextPuid();
                    samlParameters.Xuid[0] = beginReq.UserXuid.Value;

                    beginReq.SamlParameters = samlParameters;
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_XuidDifferentFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq);

                    // Change the xuid
                    XlfsUploadBegin continueReq = new XlfsUploadBegin(beginReq);
                    do
                    {
                        continueReq.SamlParameters.Xuid[0] = RandomEx.GlobalRandGen.NextPuid();
                    }
                    while (continueReq.SamlParameters.Xuid[0] == beginReq.SamlParameters.Xuid[0]);

                    // This should fail because the user in the request is not in the SAML token
                    ExecuteNegativeBeginReq(continueReq, HttpStatusCode.Unauthorized);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to continue an upload with all allowed TitleId Params.")]
            public class P_UploadContinue_AllowedTitleIds : TestNode
            {
                public override void Run()
                {
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    foreach (UInt32 titleId in XlfsTests.AllowedTitlesList)
                    {
                        XlfsUploadBegin beginReq = new XlfsUploadBegin();
                        samlParameters.TitleID = titleId;
                        beginReq.SamlParameters = samlParameters;
                        beginReq.UserXuid = samlParameters.Xuid[0];
                        beginReq.TitleId = titleId;
                        beginReq.FileName = String.Format("Xlfs_UploadContinue_AllowedTitle{0:X}_{1:X}.bin", titleId, RandomEx.GlobalRandGen.NextUlong());
                        beginReq.FileHash = XlfsTests.RandomHash();
                        ExecutePositiveBeginReq(beginReq);

                        XlfsUploadBegin continueReq = new XlfsUploadBegin(beginReq);
                        ExecutePositiveBeginReq(continueReq);

                        beginReq.CleanUp();
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to continue an upload without specifying a TitleId Param.")]
            public class N_UploadContinue_NoTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_NoTitleId_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    ExecutePositiveBeginReq(beginReq);

                    XlfsUploadBegin continueReq = new XlfsUploadBegin(beginReq);
                    continueReq.TitleId = null;

                    ExecuteNegativeBeginReq(continueReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Attempt to continue an upload with an all zero TitleId Param.")]
            public class N_UploadContinue_ZeroTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin continueReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt32 titleId = 0x0;
                    samlParameters.TitleID = titleId;
                    continueReq.SamlParameters = samlParameters;
                    continueReq.UserXuid = samlParameters.Xuid[0];
                    continueReq.TitleId = samlParameters.TitleID.Value;
                    continueReq.TransactionId = BlobTableClient.GetRowKey(Guid.NewGuid());

                    //Create the Row in the Blob Table since a BeginReq would fail
                    BlobTableClient blobTableClient = new BlobTableClient();
                    BlobTableEntry blobEntry = new BlobTableEntry();
                    blobEntry.PartitionKey = continueReq.UserXuid.Value.ToString(BlobTableEntry.XuidFormatString);
                    blobEntry.RowKey = continueReq.TransactionId;
                    blobEntry.TitleId = unchecked((int)continueReq.TitleId);
                    blobEntry.Filename = String.Format("Xlfs_UploadContinue_ZeroXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    blobEntry.MD5 = BlobClient.GetMD5HashString(XlfsTests.RandomHash());
                    blobTableClient.AddBlobTableEntry(blobEntry);

                    ExecuteNegativeBeginReq(continueReq, HttpStatusCode.Unauthorized);

                    blobTableClient.SafeDeleteBlobTableEntry(blobEntry);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadContinue with a different TitleId from the UploadBegin.")]
            public class N_UploadContinue_TitleIdDifferentFromBegin : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_TitleIdDifferentFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    ExecutePositiveBeginReq(beginReq);

                    //Create a continue request using the same transaction and all other parameters but different user xuid
                    XlfsUploadBegin continueReq = new XlfsUploadBegin(beginReq);
                    foreach (UInt32 titleId in XlfsTests.AllowedTitlesList)
                    {
                        continueReq.TitleId = titleId;
                        if (titleId != beginReq.TitleId.Value)
                            break;
                    }

                    ExecuteNegativeBeginReq(continueReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadContinue with a different Saml TitleId from the UploadBegin.")]
            public class P_UploadContinue_SamlTitleIdDifferentFromBegin : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_SamlTitleIdDifferentFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    ExecutePositiveBeginReq(beginReq);

                    //Create a continue request using the same transaction and all other parameters but different user xuid
                    XlfsUploadBegin continueReq = new XlfsUploadBegin(beginReq);
                    foreach (UInt32 titleId in XlfsTests.AllowedTitlesList)
                    {
                        continueReq.SamlParameters.TitleID = titleId;
                        if (titleId != beginReq.SamlParameters.TitleID.Value)
                            break;
                    }

                    ExecutePositiveBeginReq(continueReq);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Stand-alone call to UploadContinue with an Invalid TransactionId Param.  Should return a 400.")]
            public class N_UploadContinue_InvalidTransactionId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin continueReq = CreateBeginReq();
                    continueReq.FileName = String.Format("Xlfs_UploadContinue_InvalidTransactionId_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    continueReq.TransactionId = "INVALID";

                    ExecuteNegativeBeginReq(continueReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadContinue twice with the same filename. Continue called in the order begin was called.")]
            public class P_UploadContinue_ParallelUploadSameFileSameOrder : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = String.Format("Xlfs_UploadContinue_ParallelUploadSameFileSameOrder1_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    XlfsUploadBegin beginReq2 = new XlfsUploadBegin(beginReq1);
                    beginReq2.FileName = String.Format("Xlfs_UploadContinue_ParallelUploadSameFileSameOrder2_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    ExecutePositiveBeginReq(beginReq1);
                    ExecutePositiveBeginReq(beginReq2);

                    if (beginReq1.TransactionId == beginReq2.TransactionId)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a new transaction.");
                    }
                    if (beginReq1.StorageUri == beginReq2.StorageUri)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a different URL.");
                    }

                    //Execute 1 then 2
                    ExecutePositiveBeginReq(beginReq1);
                    ExecutePositiveBeginReq(beginReq2);
                    if (beginReq1.StorageUri == beginReq2.StorageUri)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a different URL.");
                    }

                    beginReq1.CleanUp();
                    beginReq2.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadContinue twice with the same filename. Continue called in the reverse order that begin was called.")]
            public class P_UploadContinue_ParallelUploadSameFileOutofOrder : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = String.Format("Xlfs_UploadContinue_ParallelUploadSameFileOutofOrder1_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    XlfsUploadBegin beginReq2 = new XlfsUploadBegin(beginReq1);
                    beginReq2.FileName = String.Format("Xlfs_UploadContinue_ParallelUploadSameFileOutofOrder2_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    ExecutePositiveBeginReq(beginReq1);
                    ExecutePositiveBeginReq(beginReq2);

                    if (beginReq1.TransactionId == beginReq2.TransactionId)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a new transaction.");
                    }
                    if (beginReq1.StorageUri == beginReq2.StorageUri)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a different URL.");
                    }

                    //Execute 2 then 1
                    ExecutePositiveBeginReq(beginReq2);
                    ExecutePositiveBeginReq(beginReq1);
                    if (beginReq1.StorageUri == beginReq2.StorageUri)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a different URL.");
                    }

                    beginReq1.CleanUp();
                    beginReq2.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin twice with different filenames.")]
            public class P_UploadContinue_ParallelUploadDifferentFile : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = String.Format("Xlfs_UploadContinue_ParallelUploadDifferentFile1_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    XlfsUploadBegin beginReq2 = new XlfsUploadBegin(beginReq1);
                    beginReq2.FileName = String.Format("Xlfs_UploadContinue_ParallelUploadDifferentFile2_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    ExecutePositiveBeginReq(beginReq1);
                    ExecutePositiveBeginReq(beginReq2);

                    if (beginReq1.TransactionId == beginReq2.TransactionId)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a new transaction.");
                    }
                    if (beginReq1.StorageUri == beginReq2.StorageUri)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a different URL.");
                    }

                    //Execute 1 then 2
                    ExecutePositiveBeginReq(beginReq1);
                    ExecutePositiveBeginReq(beginReq2);
                    if (beginReq1.StorageUri == beginReq2.StorageUri)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a different URL.");
                    }

                    beginReq1.CleanUp();
                    beginReq2.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin twice with different filenames.")]
            public class P_UploadContinue_ParallelUploadDifferentUserDifferentFile : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = String.Format("Xlfs_UploadContinue_ParallelUploadDifferentUserDifferentFile1_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    XlfsUploadBegin beginReq2 = CreateBeginReq();
                    beginReq2.FileName = String.Format("Xlfs_UploadContinue_ParallelUploadDifferentUserDifferentFile2_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    // Generate a new user xuid and token for the second request.
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt64 userXuid = RandomEx.GlobalRandGen.NextPuid();
                    samlParameters.Xuid[0] = userXuid;

                    samlParameters.Gamertag = new string[] { RandomEx.GlobalRandGen.GenerateRandomName(), null, null, null };
                    beginReq2.SamlParameters = samlParameters;
                    beginReq2.UserXuid = samlParameters.Xuid[0];
                    beginReq2.TitleId = samlParameters.TitleID.Value;

                    ExecutePositiveBeginReq(beginReq1);
                    ExecutePositiveBeginReq(beginReq2);

                    if (beginReq1.TransactionId == beginReq2.TransactionId)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a new transaction.");
                    }
                    if (beginReq1.StorageUri == beginReq2.StorageUri)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a different URL.");
                    }

                    //Execute 1 then 2
                    ExecutePositiveBeginReq(beginReq1);
                    ExecutePositiveBeginReq(beginReq2);
                    if (beginReq1.StorageUri == beginReq2.StorageUri)
                    {
                        throw new UnexpectedTestResultException("Second request did not generate a different URL.");
                    }

                    beginReq1.CleanUp();
                    beginReq2.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Write a blob using the SAS Url returned by UploadContinue.")]
            public class P_UploadContinue_SASUrlWrite : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadContinue_SASUrlWrite_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    //Execute Continue
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the continueReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    XLFSClient xlfsClient = new XLFSClient();
                    using (Stream readStream = xlfsClient.ReadBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value))
                    {
                        if ((readStream == null) || (readStream.Length != memoryStream.Length))
                        {
                            throw new UnexpectedTestResultException("Blob was not read from storage.");
                        }
                    }
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Read a blob using the SAS Url returned by UploadContinue.")]
            public class N_UploadContinue_SASUrlRead : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadContinue_SASUrlRead_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    //Execute Continue
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the continueReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    try
                    {
                        using (Stream readBlobStream = blobClient.GetBlobAsStream(storagePath))
                        {
                            if (readBlobStream != null)
                            {
                                throw new UnexpectedTestResultException("Blob successfully read from storage when it should've failed.");
                            }
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("Read Blob failed as expected using SAS Url.");
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("List a blob using the SAS Url returned by UploadContinue.")]
            public class N_UploadContinue_SASUrlList : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadContinue_SASUrlList_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    //Execute Continue
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the continueReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    try
                    {
                        List<string> blobList = blobClient.GetBlobList();
                        if (blobList.Count != 0)
                        {
                            Global.RO.Debug("BlobList: {0}", blobList.ToString());
                            throw new UnexpectedTestResultException("Blob successfully listed blobs from storage when it should've failed.");
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("List Blob failed as expected using SAS Url.");
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Remove a blob using the SAS Url returned by UploadContinue.")]
            public class N_UploadContinue_SASUrlRemove : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadContinue_SASUrlRemove_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    //Execute Continue
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the continueReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    try
                    {
                        bool removeSucceeded = blobClient.DeleteBlob(storagePath);
                        if (removeSucceeded)
                        {
                            throw new UnexpectedTestResultException("Blob successfully removed from storage when it should've failed.");
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("Remove Blob failed as expected using SAS Url.");
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Write a different blob from the UploadContinue Request using the SAS Url.")]
            public class N_UploadContinue_SASUrlWriteOther : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadContinue_SASUrlWriteOther_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    //Execute Continue
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the continueReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    String otherFileName = String.Format("Xlfs_UploadContinue_SASUrlWriteOtherFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, otherFileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    try
                    {
                        blobClient.PutBlob(storagePath, memoryStream);
                        memoryStream.Seek(0, SeekOrigin.Begin);
                        XLFSClient xlfsClient = new XLFSClient();
                        using (Stream readStream = xlfsClient.ReadBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, otherFileName, beginReq.TitleId.Value))
                        {
                            if ((readStream != null) && (readStream.Length == memoryStream.Length))
                            {
                                throw new UnexpectedTestResultException("Blob was written to storage when it should've failed.");
                            }
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("Writing a different filename failed as expected using SAS Url.");
                    }

                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("List containers using the SAS Url returned by UploadContinue.")]
            public class N_UploadContinue_SASUrlListContainer : TestNode
            {
                public override void Run()
                {
                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadContinue_SASUrlListContainers_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    ExecutePositiveBeginReq(beginReq);

                    //Execute Continue
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the continueReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    try
                    {
                        List<string> containerList = blobClient.GetContainers();
                        if (containerList.Count != 0)
                        {
                            Global.RO.Debug("ContainerList: {0}", containerList.ToString());
                            throw new UnexpectedTestResultException("Blob successfully listed containers from storage when it should've failed.");
                        }
                    }
                    catch (Exception)
                    {
                        Global.RO.Success("List Blob failed as expected using SAS Url.");
                    }
                    beginReq.CleanUp();
                }
            }
        }

        [TestGroup, Description("Validates that UploadEnd performs as expected.")]
        public class UploadEnd : TestNode
        {
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Call UploadBegin followed by UploadEnd.  Should succeed.")]
            public class P_UploadEnd : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    //  UploadBegin first, to get the transaction id.
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;

                    ExecutePositiveEndReq(endReq);
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Stand-alone call to UploadEnd.  Should return a 400.")]
            public class N_UploadEnd_NoBegin : TestNode
            {
                public override void Run()
                {
                    XlfsUploadEnd endReq = new XlfsUploadEnd();
                    endReq.SamlParameters = XlfsTests.SamlParameters;
                    endReq.UserXuid = endReq.SamlParameters.Xuid[0];
                    endReq.TitleId = endReq.SamlParameters.TitleID.Value;
                    endReq.TransactionId = BlobTableClient.GetRowKey(Guid.NewGuid());
                    endReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Stand-alone call to UploadEnd.  Should return a 400.")]
            public class N_UploadEnd_NoBeginNoHash : TestNode
            {
                public override void Run()
                {
                    XlfsUploadEnd endReq = new XlfsUploadEnd();
                    endReq.SamlParameters = XlfsTests.SamlParameters;
                    endReq.UserXuid = endReq.SamlParameters.Xuid[0];
                    endReq.TitleId = endReq.SamlParameters.TitleID.Value;
                    endReq.TransactionId = BlobTableClient.GetRowKey(Guid.NewGuid());
                    endReq.FileHash = null;

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd after UploadEnd called. Should return a 400.")]
            public class N_UploadEnd_AfterEnd : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    //  UploadBegin first, to get the transaction id.
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_AfterEnd_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);

                    //Call UploadEnd on the transaction that has been completed
                    XlfsUploadEnd endReq2 = CreateEndReq(beginReq);
                    endReq2.FileLength = memoryStream.Length;
                    ExecuteNegativeEndReq(endReq2, HttpStatusCode.BadRequest);
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd without specifying a UserXuid Param.")]
            public class N_UploadEnd_NoXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_NoXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    ExecutePositiveBeginReq(beginReq);

                    XlfsUploadEnd endReq = new XlfsUploadEnd();
                    endReq.SamlParameters = beginReq.SamlParameters;
                    endReq.UserXuid = null;
                    endReq.TitleId = beginReq.TitleId;
                    endReq.TransactionId = beginReq.TransactionId;
                    endReq.FileHash = beginReq.FileHash;
                    endReq.FileLength = 0;

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd with an all zero UserXuid Param.")]
            public class N_UploadEnd_ZeroXuid : TestNode
            {
                public override void Run()
                {
                    XlfsUploadEnd endReq = new XlfsUploadEnd();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt64 userXuid = 0x0;
                    samlParameters.Xuid[0] = userXuid;
                    endReq.SamlParameters = samlParameters;
                    endReq.UserXuid = samlParameters.Xuid[0];
                    endReq.TitleId = samlParameters.TitleID.Value;
                    endReq.TransactionId = BlobTableClient.GetRowKey(Guid.NewGuid());
                    endReq.FileHash = XlfsTests.RandomHash();
                    endReq.FileLength = 0;

                    //Create the Row in the Blob Table since a BeginReq would fail
                    BlobTableClient blobTableClient = new BlobTableClient();
                    BlobTableEntry blobEntry = new BlobTableEntry();
                    blobEntry.PartitionKey = endReq.UserXuid.Value.ToString(BlobTableEntry.XuidFormatString);
                    blobEntry.RowKey = endReq.TransactionId;
                    blobEntry.TitleId = unchecked((int)endReq.TitleId);
                    blobEntry.Filename = String.Format("Xlfs_UploadEnd_ZeroXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    blobEntry.MD5 = BlobClient.GetMD5HashString(endReq.FileHash);
                    blobTableClient.AddBlobTableEntry(blobEntry);

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.Unauthorized);

                    blobTableClient.SafeDeleteBlobTableEntry(blobEntry);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadEnd with an all 0x1 UserXuid Param.")]
            public class P_UploadEnd_OneXuid : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt64 userXuid = 0x1;
                    samlParameters.Xuid[0] = userXuid;

                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_OneXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;

                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;

                    ExecutePositiveEndReq(endReq);
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadEnd with a UInt64.MaxValue UserXuid Param.")]
            public class P_UploadEnd_MaxXuid : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    ulong userXuid = ulong.MaxValue;
                    samlParameters.Xuid[0] = userXuid;

                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = userXuid;
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_MaxXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;

                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;

                    ExecutePositiveEndReq(endReq);
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd with a different Xuid from the UploadBegin.")]
            public class N_UploadEnd_XuidDifferentFromBegin : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt64 xuid0 = RandomEx.GlobalRandGen.NextPuid();
                    UInt64 xuid1 = RandomEx.GlobalRandGen.NextPuid();

                    samlParameters.Xuid[0] = xuid0;
                    samlParameters.Xuid[1] = xuid1;
                    beginReq.UserXuid = xuid0;

                    beginReq.SamlParameters = samlParameters;
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_XuidDifferentFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecutePositiveBeginReq(beginReq);

                    //Create an end request using the same transaction and all other parameters but different user xuid
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.UserXuid = xuid1;

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadEnd with a different Saml Xuid from the UploadBegin.")]
            public class P_UploadEnd_SamlXuidDifferentFromBegin : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.UserXuid = RandomEx.GlobalRandGen.NextPuid();
                    beginReq.SamlParameters.Xuid[0] = beginReq.UserXuid.Value;
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_XuidDifferentFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;

                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    //Create an end request using the same transaction and all other parameters but different saml user xuid
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    do
                    {
                        endReq.SamlParameters.Xuid[0] = RandomEx.GlobalRandGen.NextPuid();
                    }
                    while (endReq.SamlParameters.Xuid[0] == beginReq.SamlParameters.Xuid[0]);

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.Unauthorized);
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to end an upload with all allowed TitleId Params.")]
            public class P_UploadEnd_AllowedTitleIds : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    foreach (UInt32 titleId in XlfsTests.AllowedTitlesList)
                    {
                        XlfsUploadBegin beginReq = CreateBeginReq();
                        samlParameters.TitleID = titleId;
                        beginReq.SamlParameters = samlParameters;
                        beginReq.UserXuid = samlParameters.Xuid[0];
                        beginReq.TitleId = titleId;
                        beginReq.FileName = String.Format("Xlfs_UploadEnd_AllowedTitle{0:X}_{1:X}.bin", titleId, RandomEx.GlobalRandGen.NextUlong());
                        beginReq.FileHash = memoryHash;
                        ExecutePositiveBeginReq(beginReq);

                        // Create a BlobClient using the SAS Url returned by the beginReq
                        BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                        string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                        Global.RO.Info("Storage Path: " + storagePath);
                        blobClient.PutBlob(storagePath, memoryStream);
                        memoryStream.Seek(0, SeekOrigin.Begin);

                        // Now call UploadEnd.
                        XlfsUploadEnd endReq = CreateEndReq(beginReq);
                        endReq.FileLength = memoryStream.Length;

                        ExecutePositiveEndReq(endReq);
                        endReq.CleanUp();
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd without specifying a TitleId Param.")]
            public class N_UploadEnd_NoTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_NoTitleId_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    ExecutePositiveBeginReq(beginReq);

                    XlfsUploadEnd endReq = new XlfsUploadEnd();
                    endReq.SamlParameters = beginReq.SamlParameters;
                    endReq.UserXuid = beginReq.UserXuid;
                    endReq.TitleId = null;
                    endReq.TransactionId = beginReq.TransactionId;
                    endReq.FileHash = beginReq.FileHash;
                    endReq.FileLength = 0;

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd with an all zero TitleId Param.")]
            public class N_UploadEnd_ZeroTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadEnd endReq = new XlfsUploadEnd();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt32 titleId = 0x0;
                    samlParameters.TitleID = titleId;
                    endReq.SamlParameters = samlParameters;
                    endReq.UserXuid = samlParameters.Xuid[0];
                    endReq.TitleId = samlParameters.TitleID.Value;
                    endReq.TransactionId = BlobTableClient.GetRowKey(Guid.NewGuid());
                    endReq.FileHash = XlfsTests.RandomHash();
                    endReq.FileLength = 0;

                    //Create the Row in the Blob Table since a BeginReq would fail
                    BlobTableClient blobTableClient = new BlobTableClient();
                    BlobTableEntry blobEntry = new BlobTableEntry();
                    blobEntry.PartitionKey = endReq.UserXuid.Value.ToString(BlobTableEntry.XuidFormatString);
                    blobEntry.RowKey = endReq.TransactionId;
                    blobEntry.TitleId = unchecked((int)endReq.TitleId);
                    blobEntry.Filename = String.Format("Xlfs_UploadEnd_ZeroTitleId_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    blobEntry.MD5 = BlobClient.GetMD5HashString(endReq.FileHash);
                    blobTableClient.AddBlobTableEntry(blobEntry);

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.Unauthorized);

                    blobTableClient.SafeDeleteBlobTableEntry(blobEntry);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd with a different TitleId from the UploadBegin.")]
            public class N_UploadEnd_TitleIdDifferentFromBegin : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_TitleIdDifferentFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;

                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);

                    //Create a continue request using the same transaction and all other parameters but different title id
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    foreach (UInt32 titleId in XlfsTests.AllowedTitlesList)
                    {
                        endReq.TitleId = titleId;
                        if (titleId != beginReq.TitleId.Value)
                            break;
                    }

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadEnd with a different Saml TitleId from the UploadBegin.")]
            public class P_UploadEnd_SamlTitleIdDifferentFromBegin : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_TitleIdDifferentFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;

                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);

                    //Create a continue request using the same transaction and all other parameters but different title id
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    foreach (UInt32 titleId in XlfsTests.AllowedTitlesList)
                    {
                        endReq.SamlParameters.TitleID = titleId;
                        if (titleId != beginReq.SamlParameters.TitleID.Value)
                            break;
                    }

                    ExecutePositiveEndReq(endReq);
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Stand-alone call to UploadEnd without a TransactionId Param.  Should return a 400.")]
            public class N_UploadEnd_NoTransactionId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadEnd endReq = new XlfsUploadEnd();
                    endReq.SamlParameters = XlfsTests.SamlParameters;
                    endReq.UserXuid = endReq.SamlParameters.Xuid[0];
                    endReq.TitleId = endReq.SamlParameters.TitleID.Value;
                    endReq.FileHash = XlfsTests.RandomHash();
                    endReq.FileLength = 0;

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Stand-alone call to UploadEnd with an Invalid TransactionId Param.  Should return a 400.")]
            public class N_UploadEnd_InvalidTransactionId : TestNode
            {
                public override void Run()
                {
                    XlfsUploadEnd endReq = new XlfsUploadEnd();
                    endReq.SamlParameters = XlfsTests.SamlParameters;
                    endReq.UserXuid = endReq.SamlParameters.Xuid[0];
                    endReq.TitleId = endReq.SamlParameters.TitleID.Value;
                    endReq.FileHash = XlfsTests.RandomHash();
                    endReq.FileLength = 0;
                    endReq.TransactionId = "INVALID";

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd and verify the FileLength in the table.")]
            public class P_UploadEnd_VerifyFileLength : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    //  UploadBegin first, to get the transaction id.
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_NoFileHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;

                    ExecutePositiveEndReq(endReq);
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd without a FileHash Param.")]
            public class N_UploadEnd_NoFileHash : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    //  UploadBegin first, to get the transaction id.
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_NoFileHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    endReq.FileHash = null;

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            // TODO: Find a way to generate a valid Azure Blob with all zero and all 0xFF Content-MD5
            //[TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadEnd with an all zeros FileHash Param. ")]
            //public class P_UploadEnd_ZeroFileHash : TestNode
            //{
            //    public override void Run()
            //    {
            //        byte[] byteArray = new byte[1];
            //        RandomEx.GlobalRandGen.NextBytes(byteArray);
            //        MemoryStream memoryStream = new MemoryStream(byteArray);
            //        memoryStream.Seek(0, SeekOrigin.Begin);

            //        //Need to find a way to generate a memory hash of all zeros or blob upload will reject the Hash
            //        //byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
            //        byte[] memoryHash = new byte[16] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            //        //byte[] memoryHash = new byte[16] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

            //        //  UploadBegin first, to get the transaction id.
            //        XlfsUploadBegin beginReq = CreateBeginReq();
            //        beginReq.FileName = String.Format("Xlfs_UploadEnd_ZeroFileHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
            //        beginReq.FileHash = memoryHash;
            //        ExecutePositiveBeginReq(beginReq);

            //        //// Create a BlobClient using the SAS Url returned by the beginReq
            //        //BlobClient blobClient = new BlobClient(beginReq.StorageUri);
            //        //string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid, beginReq.FileName, beginReq.TransactionId);
            //        //Global.RO.Info("Storage Path: " + storagePath);
            //        //blobClient.PutBlob(storagePath, memoryStream);
            //        //memoryStream.Seek(0, SeekOrigin.Begin);

            //        // Now call UploadEnd.
            //        XlfsUploadEnd endReq = CreateEndReq(beginReq);
            //        endReq.FileLength = memoryStream.Length;

            //        ExecutePositiveEndReq(endReq);
            //        endReq.CleanUp();
            //    }
            //}

            //[TestCase, Owner("benran"), TestCasePriority(1), Description("Call to UploadEnd with an all 0xFF FileHash Param. ")]
            //public class P_UploadEnd_MaxFileHash : TestNode
            //{
            //    public override void Run()
            //    {
            //        byte[] byteArray = new byte[1];
            //        RandomEx.GlobalRandGen.NextBytes(byteArray);
            //        MemoryStream memoryStream = new MemoryStream(byteArray);
            //        memoryStream.Seek(0, SeekOrigin.Begin);

            //        //Need to find a way to generate a memory hash of all zeros or blob upload will reject the Hash
            //        //byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
            //        byte[] memoryHash = new byte[16] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

            //        //  UploadBegin first, to get the transaction id.
            //        XlfsUploadBegin beginReq = CreateBeginReq();
            //        beginReq.FileName = String.Format("Xlfs_UploadEnd_MaxFileHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
            //        beginReq.FileHash = memoryHash;
            //        ExecutePositiveBeginReq(beginReq);

            //        //// Create a BlobClient using the SAS Url returned by the beginReq
            //        //BlobClient blobClient = new BlobClient(beginReq.StorageUri);
            //        //string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid, beginReq.FileName, beginReq.TransactionId);
            //        //Global.RO.Info("Storage Path: " + storagePath);
            //        //blobClient.PutBlob(storagePath, memoryStream);
            //        //memoryStream.Seek(0, SeekOrigin.Begin);

            //        // Now call UploadEnd.
            //        XlfsUploadEnd endReq = CreateEndReq(beginReq);
            //        endReq.FileLength = memoryStream.Length;

            //        ExecutePositiveEndReq(endReq);
            //        endReq.CleanUp();
            //    }
            //}

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd with a too long FileHash Param.")]
            public class N_UploadEnd_TooLongFileHash : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    //  UploadBegin first, to get the transaction id.
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_TooLongFileHash_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    endReq.FileHash = new byte[256]; //MD5 Hashes are 16 bytes
                    RandomEx.GlobalRandGen.NextBytes(endReq.FileHash);

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                    //beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd without a different FileHash Param from UploadBegin.")]
            public class N_UploadEnd_DifferentFileHashFromBegin : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    //  UploadBegin first, to get the transaction id.
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_DifferentFileHashFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    endReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.Unauthorized);
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                    //beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call to UploadEnd without a different FileHash Param from the file (matching begin).")]
            public class N_UploadEnd_DifferentFileHashFromFile : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    //byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    //  UploadBegin first, to get the transaction id. using the random hash for both begin and end
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_UploadEnd_DifferentFileHashFromBegin_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    //beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;

                    ExecuteNegativeEndReq(endReq, HttpStatusCode.Unauthorized);
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.RemoveBlobFile(beginReq.UserXuid.Value, beginReq.TransactionId, beginReq.FileName, beginReq.TitleId.Value);
                    //beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadEnd twice with the same filename. End called in the order begin was called.")]
            public class P_UploadEnd_ParallelUploadSameFileSameOrder : TestNode
            {
                public override void Run()
                {
                    //  UploadBegin1 first
                    byte[] byteArray1 = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray1);
                    MemoryStream memoryStream1 = new MemoryStream(byteArray1);
                    memoryStream1.Seek(0, SeekOrigin.Begin);
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = String.Format("Xlfs_UploadEnd_ParallelUploadSameFileSameOrder_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq1.FileHash = BlobClient.GetMD5Hash(memoryStream1);
                    ExecutePositiveBeginReq(beginReq1);

                    //  UploadBegin2 second
                    byte[] byteArray2 = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray2);
                    MemoryStream memoryStream2 = new MemoryStream(byteArray2);
                    memoryStream2.Seek(0, SeekOrigin.Begin);
                    XlfsUploadBegin beginReq2 = new XlfsUploadBegin(beginReq1);
                    beginReq2.TransactionId = null;
                    beginReq2.FileHash = BlobClient.GetMD5Hash(memoryStream2);
                    ExecutePositiveBeginReq(beginReq2);

                    if (beginReq1.TransactionId == beginReq2.TransactionId)
                        throw new UnexpectedTestResultException(
                            String.Format("UploadBegin2 returned the same transactionID as UploadBegin1. {0} : {1}",
                            beginReq1.TransactionId, beginReq2.TransactionId));

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq1.StorageUri);
                    string storagePath1 = BlobTableClient.GetStoragePath(beginReq1.UserXuid.Value, beginReq1.FileName, beginReq1.TransactionId);
                    Global.RO.Info("Storage Path1: " + storagePath1);
                    blobClient.PutBlob(storagePath1, memoryStream1);
                    memoryStream1.Seek(0, SeekOrigin.Begin);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    blobClient = new BlobClient(beginReq2.StorageUri);
                    string storagePath2 = BlobTableClient.GetStoragePath(beginReq2.UserXuid.Value, beginReq2.FileName, beginReq2.TransactionId);
                    Global.RO.Info("Storage Path2: " + storagePath2);
                    blobClient.PutBlob(storagePath2, memoryStream2);
                    memoryStream2.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd1.
                    XlfsUploadEnd endReq1 = CreateEndReq(beginReq1);
                    endReq1.FileLength = memoryStream1.Length;
                    ExecutePositiveEndReq(endReq1);

                    // Now call UploadEnd2.
                    XlfsUploadEnd endReq2 = CreateEndReq(beginReq2);
                    endReq2.FileLength = memoryStream2.Length;
                    ExecutePositiveEndReq(endReq2);

                    try
                    {
                        FileTableLastUpdateClient fileTableClient = new FileTableLastUpdateClient();
                        List<FileTableLastUpdateEntry> fileList =
                            fileTableClient.SelectFile(beginReq1.UserXuid.Value, beginReq1.TitleId.Value, beginReq1.FileName, endReq2.DateTimeOfExecute);
                        if (fileList.Count != 1)
                        {
                            throw new UnexpectedTestResultException("Expected 1 file in the FileTable, got " +
                                                                    fileList.Count);
                        }
                        if (fileList[0].TransactionId != beginReq2.TransactionId)
                        {
                            if (fileList[0].TransactionId == beginReq1.TransactionId)
                            {
                                Global.RO.Error(
                                    "UploadBegin1 transactionId found in the FileTable when UploadBegin2 was expected");
                            }
                            throw new UnexpectedTestResultException(
                                String.Format("TransactionId found in the File Table did not match expected. {0} : {1}",
                                            fileList[0].TransactionId, beginReq2.TransactionId));
                        }

                        // Make sure that only the second blob is in blob storage.
                        blobClient = new BlobClient(beginReq1.StorageUri);
                        blobClient.BlobContainer = beginReq1.TitleId.Value.ToString(BlobTableEntry.ContainerBlobFormatString);
                        Stream fileStream;
                        try
                        {
                            using (fileStream = blobClient.GetBlobAsStream(storagePath1))
                            {
                                if ((fileStream != null) && (fileStream.Length > 0))
                                {
                                    // This blob shouldn't be there, so clean it up manually.
                                    blobClient.DeleteBlob(storagePath1);

                                    throw new UnexpectedTestResultException(string.Format("First uploaded blob ({0})was not deleted from storage after update.", storagePath1));
                                }
                            }
                        }
                        catch
                        {
                            //Expected
                        }

                        blobClient = new BlobClient(XlfsConfiguration.XlfsBlobStorage[fileList[0].StorageAccount]);
                        blobClient.BlobContainer = fileList[0].TitleId.ToString(BlobTableEntry.ContainerBlobFormatString);
                        using (fileStream = blobClient.GetBlobAsStream(storagePath2))
                        {
                            if ((fileStream == null) || (fileStream.Length != memoryStream2.Length))
                            {
                                throw new UnexpectedTestResultException(string.Format("Expected to find updated blob ({0}) in blob storage, but did not.", storagePath2));
                                
                            }
                        }
                    }
                    finally
                    {
                        endReq2.CleanUp();
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadEnd twice with the same filename. Second UploadBegin called UploadEnd before first.")]
            public class P_UploadEnd_ParallelUploadSameFileOutofOrder : TestNode
            {
                public override void Run()
                {
                    //  UploadBegin1 first
                    byte[] byteArray1 = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray1);
                    MemoryStream memoryStream1 = new MemoryStream(byteArray1);
                    memoryStream1.Seek(0, SeekOrigin.Begin);
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = String.Format("Xlfs_UploadEnd_ParallelUploadSameFileOutofOrder_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq1.FileHash = BlobClient.GetMD5Hash(memoryStream1);
                    ExecutePositiveBeginReq(beginReq1);

                    //  UploadBegin2 second
                    byte[] byteArray2 = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray2);
                    MemoryStream memoryStream2 = new MemoryStream(byteArray2);
                    memoryStream2.Seek(0, SeekOrigin.Begin);
                    XlfsUploadBegin beginReq2 = new XlfsUploadBegin(beginReq1);
                    beginReq2.FileHash = BlobClient.GetMD5Hash(memoryStream2);
                    beginReq2.TransactionId = null;
                    ExecutePositiveBeginReq(beginReq2);

                    if (beginReq1.TransactionId == beginReq2.TransactionId)
                        throw new UnexpectedTestResultException(
                            String.Format("UploadBegin2 returned the same transactionID as UploadBegin1. {0} : {1}",
                            beginReq1.TransactionId, beginReq2.TransactionId));

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq1.StorageUri);
                    string storagePath1 = BlobTableClient.GetStoragePath(beginReq1.UserXuid.Value, beginReq1.FileName, beginReq1.TransactionId);
                    Global.RO.Info("Storage Path1: " + storagePath1);
                    blobClient.PutBlob(storagePath1, memoryStream1);
                    memoryStream1.Seek(0, SeekOrigin.Begin);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    blobClient = new BlobClient(beginReq2.StorageUri);
                    string storagePath2 = BlobTableClient.GetStoragePath(beginReq2.UserXuid.Value, beginReq2.FileName, beginReq2.TransactionId);
                    Global.RO.Info("Storage Path2: " + storagePath2);
                    blobClient.PutBlob(storagePath2, memoryStream2);
                    memoryStream2.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd2.
                    XlfsUploadEnd endReq2 = CreateEndReq(beginReq2);
                    endReq2.FileLength = memoryStream2.Length;
                    ExecutePositiveEndReq(endReq2);

                    // Now call UploadEnd1.
                    XlfsUploadEnd endReq1 = CreateEndReq(beginReq1);
                    endReq1.FileLength = memoryStream1.Length;
                    ExecutePositiveEndReq(endReq1);

                    try
                    {
                        FileTableLastUpdateClient fileTableClient = new FileTableLastUpdateClient();
                        List<FileTableLastUpdateEntry> fileList =
                            fileTableClient.SelectFile(beginReq1.UserXuid.Value, beginReq1.TitleId.Value, beginReq1.FileName, endReq2.DateTimeOfExecute);
                        if (fileList.Count != 1)
                        {
                            throw new UnexpectedTestResultException("Expected 1 file in the FileTable, got " +
                                                                    fileList.Count);
                        }
                        if (fileList[0].TransactionId != beginReq1.TransactionId)
                        {
                            if (fileList[0].TransactionId == beginReq2.TransactionId)
                            {
                                Global.RO.Error(
                                    "UploadBegin2 transactionId found in the FileTable when UploadBegin1 was expected");
                            }
                            throw new UnexpectedTestResultException(
                                String.Format(
                                    "TransactionId found in the File Table did not match expected. {0} : {1}",
                                    fileList[0].TransactionId, beginReq1.TransactionId));
                        }

                        // Make sure that only the first blob is in blob storage.
                        blobClient = new BlobClient(beginReq2.StorageUri);
                        blobClient.BlobContainer = beginReq2.TitleId.Value.ToString(BlobTableEntry.ContainerBlobFormatString);
                        Stream fileStream;
                        try
                        {
                            using (fileStream = blobClient.GetBlobAsStream(storagePath2))
                            {
                                if ((fileStream != null) && (fileStream.Length > 0))
                                {
                                    // This blob shouldn't be there, so clean it up manually.
                                    blobClient.DeleteBlob(storagePath2);

                                    Global.RO.Error(string.Format("First uploaded blob ({0})was not deleted from storage after update.", storagePath2));
                                    throw new UnexpectedTestResultException();
                                }
                            }
                        }
                        catch
                        {
                            //Expected
                        }

                        blobClient = new BlobClient(XlfsConfiguration.XlfsBlobStorage[fileList[0].StorageAccount]);
                        blobClient.BlobContainer = fileList[0].TitleId.ToString(BlobTableEntry.ContainerBlobFormatString);
                        using (fileStream = blobClient.GetBlobAsStream(storagePath1))
                        {
                            if ((fileStream == null) || (fileStream.Length != memoryStream1.Length))
                            {
                                Global.RO.Error(string.Format("Expected to find updated blob ({0}) in blob storage, but did not.", storagePath1));
                                throw new UnexpectedTestResultException();
                            }
                        }
                    }
                    finally
                    {
                        endReq1.CleanUp();
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadEnd twice with the same filename. End called in the order begin was called.")]
            public class P_UploadEnd_ParallelUploadDifferentFile : TestNode
            {
                public override void Run()
                {
                    //  UploadBegin1 first
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = String.Format("Xlfs_UploadEnd_ParallelUploadDifferentFile1_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    byte[] byteArray1 = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray1);
                    MemoryStream memoryStream1 = new MemoryStream(byteArray1);
                    memoryStream1.Seek(0, SeekOrigin.Begin);
                    beginReq1.FileHash = BlobClient.GetMD5Hash(memoryStream1);
                    ExecutePositiveBeginReq(beginReq1);

                    //  UploadBegin2 second
                    XlfsUploadBegin beginReq2 = CreateBeginReq();
                    beginReq2.FileName = String.Format("Xlfs_UploadEnd_ParallelUploadDifferentFile2_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    byte[] byteArray2 = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray2);
                    MemoryStream memoryStream2 = new MemoryStream(byteArray2);
                    memoryStream2.Seek(0, SeekOrigin.Begin);
                    beginReq2.FileHash = BlobClient.GetMD5Hash(memoryStream2);
                    ExecutePositiveBeginReq(beginReq2);

                    if (beginReq1.TransactionId == beginReq2.TransactionId)
                        throw new UnexpectedTestResultException(
                            String.Format("UploadBegin2 returned the same transactionID as UploadBegin1. {0} : {1}",
                            beginReq1.TransactionId, beginReq2.TransactionId));

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq1.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq1.UserXuid.Value, beginReq1.FileName, beginReq1.TransactionId);
                    Global.RO.Info("Storage Path1: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream1);
                    memoryStream1.Seek(0, SeekOrigin.Begin);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    blobClient = new BlobClient(beginReq2.StorageUri);
                    storagePath = BlobTableClient.GetStoragePath(beginReq2.UserXuid.Value, beginReq2.FileName, beginReq2.TransactionId);
                    Global.RO.Info("Storage Path2: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream2);
                    memoryStream2.Seek(0, SeekOrigin.Begin);

                    // Now call UploadEnd1.
                    XlfsUploadEnd endReq1 = CreateEndReq(beginReq1);
                    endReq1.FileLength = memoryStream1.Length;
                    ExecutePositiveEndReq(endReq1);

                    // Now call UploadEnd2.
                    XlfsUploadEnd endReq2 = CreateEndReq(beginReq2);
                    endReq2.FileLength = memoryStream2.Length;
                    ExecutePositiveEndReq(endReq2);

                    endReq1.CleanUp();
                    endReq2.CleanUp();
                }
            }
        }

        [TestGroup, Description("Validates ClientFD End-to-end upload functionality.")]
        public class EndToEnd : TestNode
        {
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Simple End-to-end. Begin-Upload-End.")]
            public class P_SimpleUploadFile : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_SimpleUploadFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    //Execute End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);

                    //Verify
                    XLFSClient xlfsClient = new XLFSClient();
                    using (Stream readfs = xlfsClient.ReadFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute))
                    {
                        if (readfs == null)
                        {
                            throw new UnexpectedTestResultException("File not returned from Storage");
                        }
                        if (readfs.Length != memoryStream.Length)
                        {
                            throw new UnexpectedTestResultException("Length of uploaded file does not match storage file. 1024 : " + readfs.Length);
                        }
                    }
                    xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Simple End-to-end. Begin-Upload-Continue-Upload-End.")]
            public class P_UploadFileWithContinue : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadFileWithContinue_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    // Call UploadBegin again to get a new SAS URL.
                    XlfsUploadBegin continueReq = new XlfsUploadBegin(beginReq);
                    ExecutePositiveBeginReq(continueReq);
                    blobClient = new BlobClient(continueReq.StorageUri);

                    // Upload more bytes
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    // Execute End - Both calls to UploadBegin were using the same transaction id so it shouldn't matter which one we
                    // use to call end.
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);

                    //Verify that the blob that was stored matches the second one uploaded.
                    XLFSClient xlfsClient = new XLFSClient();
                    using (Stream readfs = xlfsClient.ReadFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute))
                    {
                        if (readfs == null)
                        {
                            throw new UnexpectedTestResultException("File not returned from Storage");
                        }
                        if (readfs.Length != memoryStream.Length)
                        {
                            throw new UnexpectedTestResultException("Length of uploaded file does not match storage file. 1024 : " + readfs.Length);
                        }
                    }
                    xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Begin and End and upload an empty file.")]
            public class P_UploadEmptyFile : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[0];
                    //RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadEmptyFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    //Execute End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = 0;
                    ExecutePositiveEndReq(endReq);

                    //Verify
                    XLFSClient xlfsClient = new XLFSClient();
                    using (Stream readfs = xlfsClient.ReadFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute))
                    {
                        if (readfs == null)
                        {
                            throw new UnexpectedTestResultException("File not returned from Storage");
                        }
                        if (readfs.Length != memoryStream.Length)
                        {
                            throw new UnexpectedTestResultException("Length of uploaded file does not match storage file. 1024 : " + readfs.Length);
                        }
                    }
                    xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Begin and End and upload but don't upload anything.")]
            public class N_UploadNoFile : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[0];
                    //RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadNoFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    //Execute End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = 0;
                    ExecuteNegativeEndReq(endReq, HttpStatusCode.BadRequest);

                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Begin and End and upload a file already in the file table (but changed).")]
            public class P_UploadFileAlreadyExists : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    String fileName = String.Format("Xlfs_UploadFileAlreadyExists_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;

                    //Write Initial File
                    XLFSClient xlfsClient = new XLFSClient();
                    string originalTransactionId = Guid.NewGuid().ToString("N");
                    DateTime fileWriteTime = DateTime.UtcNow;
                    xlfsClient.WriteFile(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TitleId.Value, originalTransactionId, fileWriteTime, memoryStream);

                    // At this point we want to get the current file table entry and save it off so we can remove the file later.
                    FileTableLastUpdateClient fileTableLastUpdateClient = new FileTableLastUpdateClient();
                    FileTableLastUpdateEntry originalEntry = fileTableLastUpdateClient.SelectFile(
                        FileTableLastUpdateClient.GetPartitionKey(beginReq.UserXuid.Value, beginReq.TitleId.Value, fileName, fileWriteTime),
                        FileTableLastUpdateClient.GetRowKey(beginReq.UserXuid.Value, beginReq.TitleId.Value, fileName))[0];
                    string originalStoragePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, originalTransactionId);

                    //Generate a "new" file
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    beginReq.FileHash = BlobClient.GetMD5Hash(memoryStream);
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    //Execute End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);

                    try
                    {
                        //Verify
                        FileTableLastUpdateClient fileTableClient = new FileTableLastUpdateClient();
                        List<FileTableLastUpdateEntry> fileList = fileTableClient.SelectFile(beginReq.UserXuid.Value,
                                                                                   beginReq.TitleId.Value,
                                                                                   beginReq.FileName, endReq.DateTimeOfExecute);
                        if (fileList.Count != 1)
                            throw new UnexpectedTestResultException("Expected 1 file in FileTable. Got " + fileList.Count);
                        if (fileList[0].TransactionId != beginReq.TransactionId)
                        {
                            Global.RO.Error("Did not find new transaction in FileTable. {0} : {1}",
                                            fileList[0].TransactionId, beginReq.TransactionId);
                            throw new UnexpectedTestResultException();
                        }

                        // Make sure that only the second blob is in blob storage.
                        blobClient = new BlobClient(XlfsConfiguration.XlfsBlobStorage[originalEntry.StorageAccount]);
                        blobClient.BlobContainer = beginReq.TitleId.Value.ToString(BlobTableEntry.ContainerBlobFormatString);
                        Stream fileStream;
                        try
                        {
                            using (fileStream = blobClient.GetBlobAsStream(originalStoragePath))
                            {
                                if ((fileStream != null) && (fileStream.Length > 0))
                                {
                                    // This blob shouldn't be there, so clean it up manually.
                                    blobClient.DeleteBlob(originalStoragePath);

                                    Global.RO.Error(string.Format("First uploaded blob ({0})was not deleted from storage after update.", originalStoragePath));
                                    throw new UnexpectedTestResultException();
                                }
                            }
                        }
                        catch
                        {
                            //Expected
                        }

                        blobClient = new BlobClient(XlfsConfiguration.XlfsBlobStorage[fileList[0].StorageAccount]);
                        blobClient.BlobContainer = beginReq.TitleId.Value.ToString(BlobTableEntry.ContainerBlobFormatString);
                        using (fileStream = blobClient.GetBlobAsStream(storagePath))
                        {
                            if ((fileStream == null) || (fileStream.Length != memoryStream.Length))
                            {
                                Global.RO.Error(string.Format("Expected to find updated blob ({0}) in blob storage, but did not.", storagePath));
                                throw new UnexpectedTestResultException();
                            }
                        }
                    }
                    finally
                    {
                        xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute);
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Begin, upload, and End a file, then update the file the same way.")]
            public class P_UploadThenUpdateFile : TestNode
            {
                public override void Run()
                {
                    String fileName = String.Format("Xlfs_UploadThenUpdateFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Stream fileStream;
                    Byte[] fileHash;
                    Int32 fileLength = 1024;
                    GetRandomFile(fileLength, out fileStream, out fileHash);

                    Global.RO.Info("Uploading file {0}...", fileName);

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = fileHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, fileStream);

                    //Execute End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = fileLength;
                    ExecutePositiveEndReq(endReq);

                    Global.RO.Info("File {0} uploaded successfully.  'Updating' file...", fileName);
                    // Now do it again with a different file, same name
                    GetRandomFile(fileLength, out fileStream, out fileHash);
                    
                    //Execute Begin
                    beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = fileHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    blobClient = new BlobClient(beginReq.StorageUri);
                    storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, fileStream);

                    //Execute End
                    endReq = CreateEndReq(beginReq);
                    endReq.FileLength = fileLength;
                    ExecutePositiveEndReq(endReq);

                    //Verify
                    XLFSClient xlfsClient = new XLFSClient();
                    using (Stream readfs = xlfsClient.ReadFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute))
                    {
                        if (readfs == null)
                        {
                            throw new UnexpectedTestResultException("File not returned from Storage");
                        }
                        if (readfs.Length != fileLength)
                        {
                            throw new UnexpectedTestResultException("Length of uploaded file does not match storage file. 1024 : " + readfs.Length);
                        }
                    }

                    xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call UploadBegin with the same parameters as a completed end to end upload.")]
            public class P_UploadBeginAfterEndToEnd : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    String fileName = String.Format("Xlfs_UploadBeginAfterEndToEnd_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    //Execute End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.NotModified);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Upload a file, and then update it with a new set of bytes.")]
            public class P_FileUpdateAfterEndToEnd : TestNode
            {
                public override void Run()
                {
                    byte[] byteArray1 = new byte[1024];
                    byte[] byteArray2 = new byte[1024];
                    RandomEx.GlobalRandGen.NextBytes(byteArray1);
                    RandomEx.GlobalRandGen.NextBytes(byteArray2);
                    MemoryStream memoryStream1 = new MemoryStream(byteArray1);
                    MemoryStream memoryStream2 = new MemoryStream(byteArray2);
                    memoryStream1.Seek(0, SeekOrigin.Begin);
                    memoryStream2.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash1 = BlobClient.GetMD5Hash(memoryStream1);
                    byte[] memoryHash2 = BlobClient.GetMD5Hash(memoryStream2);
                    String fileName = String.Format("Xlfs_FileUpdateAfterEndToEnd_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq1 = CreateBeginReq();
                    beginReq1.FileName = fileName;
                    beginReq1.FileHash = memoryHash1;
                    ExecutePositiveBeginReq(beginReq1);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq1.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq1.UserXuid.Value, beginReq1.FileName, beginReq1.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream1);
                    memoryStream1.Seek(0, SeekOrigin.Begin);

                    //Execute End
                    XlfsUploadEnd endReq1 = CreateEndReq(beginReq1);
                    endReq1.FileLength = memoryStream1.Length;
                    ExecutePositiveEndReq(endReq1);

                    //Execute Begin
                    XlfsUploadBegin beginReq2 = CreateBeginReq();
                    beginReq2.FileName = fileName;
                    beginReq2.FileHash = memoryHash2;
                    ExecutePositiveBeginReq(beginReq2);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    blobClient = new BlobClient(beginReq2.StorageUri);
                    storagePath = BlobTableClient.GetStoragePath(beginReq2.UserXuid.Value, beginReq2.FileName, beginReq2.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream2);
                    memoryStream2.Seek(0, SeekOrigin.Begin);

                    //Execute End
                    XlfsUploadEnd endReq2 = CreateEndReq(beginReq2);
                    endReq1.FileLength = memoryStream2.Length;
                    ExecutePositiveEndReq(endReq2);

                    // At this point there shouldn't be either row in BlobTableEntry,
                    // and the row in FileTableLastUpdateEntry should refer to the second
                    // file.

                    BlobTableClient blobTableClient = new BlobTableClient(XlfsConfiguration.XlfsTableStorage);
                    List<BlobTableEntry> blobTableEntries = blobTableClient.SelectBlob(beginReq1.UserXuid.Value, beginReq1.TransactionId);
                    if (blobTableEntries.Count != 0)
                    {
                        throw new UnexpectedTestResultException("First BlobTableEntry was not correctly cleaned up.");
                    }

                    blobTableEntries = blobTableClient.SelectBlob(beginReq2.UserXuid.Value, beginReq2.TransactionId);
                    if (blobTableEntries.Count != 0)
                    {
                        throw new UnexpectedTestResultException("Second BlobTableEntry was not correctly cleaned up.");
                    }

                    FileTableLastUpdateClient fileTableLastUpdateClient = new FileTableLastUpdateClient(XlfsConfiguration.XlfsTableStorage);
                    List<FileTableLastUpdateEntry> fileTableEntries =
                        fileTableLastUpdateClient.SelectFile(beginReq1.UserXuid.Value, beginReq1.TitleId.Value,
                                                             beginReq1.FileName);
                    if (fileTableEntries.Count != 1)
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Expected a single row in FileTableLastUpdateEntry for this upload, but found {0}.",
                                          fileTableEntries.Count));
                    }

                    if (fileTableEntries[0].TransactionId != beginReq2.TransactionId)
                    {
                        throw new UnexpectedTestResultException(
                            String.Format(
                                "Expected the single row in FileTableLastUpdateEntry to match the second file upload, but it did not.  Expected {0}, Got {1}.",
                                beginReq2.TransactionId, fileTableEntries[0].TransactionId));
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Complex End-to-end. File upload using blocks and blocklist.")]
            public class P_BlockUploadFile : TestNode
            {
                public override void Run()
                {
                    int numBlocks = 4;
                    int blockLength = 1024;
                    byte[] byteArray = new byte[numBlocks * blockLength];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    byte[] fullMemoryHash = BlobClient.GetMD5Hash(byteArray);
                    String fileName = String.Format("Xlfs_BlockUploadFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = fullMemoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    List<string> blockList = new List<string>();
                    for (int uploadId = 0; uploadId < numBlocks; uploadId++)
                    {
                        using (MemoryStream blockStream = new MemoryStream())
                        {
                            int uploadStart = uploadId * blockLength;
                            string blockIdString = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(uploadId.ToString("X8")));
                            Global.RO.Info("Uploading Block {0}. Offset: {1}, Length: {2}", blockIdString, uploadStart, blockLength);
                            blockStream.Write(byteArray, uploadStart, blockLength);
                            blockStream.Position = 0;
                            blobClient.PutBlock(storagePath, blockIdString, blockStream);
                            blockList.Add(blockIdString);
                            blockStream.Close();
                        }
                    }
                    Global.RO.Info("PutBlockList {0}.", blockList.ToString());
                    blobClient.PutBlockList(storagePath, Convert.ToBase64String(fullMemoryHash), blockList);

                    //Execute End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = byteArray.Length;
                    ExecutePositiveEndReq(endReq);

                    //Verify
                    XLFSClient xlfsClient = new XLFSClient();
                    using (Stream readfs = xlfsClient.ReadFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute))
                    {
                        if (readfs == null)
                        {
                            throw new UnexpectedTestResultException("File not returned from Storage");
                        }
                        if (readfs.Length != byteArray.Length)
                        {
                            throw new UnexpectedTestResultException("Length of uploaded file does not match storage file. 1024 : " + readfs.Length);
                        }
                    }
                    xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Complex End-to-end. File upload using blocks and blocklist with UploadContinue.")]
            public class P_BlockUploadFileWithContinue : TestNode
            {
                public override void Run()
                {
                    int numBlocks = 4;
                    int blockLength = 1024;
                    byte[] byteArray = new byte[numBlocks * blockLength];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    byte[] fullMemoryHash = BlobClient.GetMD5Hash(byteArray);
                    String fileName = String.Format("Xlfs_BlockUploadFile_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Execute Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = fileName;
                    beginReq.FileHash = fullMemoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    List<string> blockList = new List<string>();

                    // Upload Half of the blocks
                    int uploadId = 0;
                    for (uploadId = 0; uploadId < (numBlocks / 2); uploadId++)
                    {
                        using (MemoryStream blockStream = new MemoryStream())
                        {
                            int uploadStart = uploadId * blockLength;
                            string blockIdString = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(uploadId.ToString("X8")));
                            Global.RO.Info("Uploading Block {0}. Offset: {1}, Length: {2}", blockIdString, uploadStart, blockLength);
                            blockStream.Write(byteArray, uploadStart, blockLength);
                            blockStream.Position = 0;
                            blobClient.PutBlock(storagePath, blockIdString, blockStream);
                            blockList.Add(blockIdString);
                            blockStream.Close();
                        }
                    }

                    // Call UploadContinue to get a new SAS URL.
                    ExecutePositiveBeginReq(beginReq);
                    blobClient = new BlobClient(beginReq.StorageUri);

                    // Upload the rest of the blocks
                    for (uploadId = (numBlocks / 2); uploadId < numBlocks; uploadId++)
                    {
                        using (MemoryStream blockStream = new MemoryStream())
                        {
                            int uploadStart = uploadId * blockLength;
                            string blockIdString = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(uploadId.ToString("X8")));
                            Global.RO.Info("Uploading Block {0}. Offset: {1}, Length: {2}", blockIdString, uploadStart, blockLength);
                            blockStream.Write(byteArray, uploadStart, blockLength);
                            blockStream.Position = 0;
                            blobClient.PutBlock(storagePath, blockIdString, blockStream);
                            blockList.Add(blockIdString);
                            blockStream.Close();
                        }
                    }

                    //Commit the full list of blocks
                    Global.RO.Info("PutBlockList {0}.", blockList.ToString());
                    blobClient.PutBlockList(storagePath, Convert.ToBase64String(fullMemoryHash), blockList);

                    //Execute End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = byteArray.Length;
                    ExecutePositiveEndReq(endReq);

                    //Verify
                    XLFSClient xlfsClient = new XLFSClient();
                    using (Stream readfs = xlfsClient.ReadFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute))
                    {
                        if (readfs == null)
                        {
                            throw new UnexpectedTestResultException("File not returned from Storage");
                        }
                        if (readfs.Length != byteArray.Length)
                        {
                            throw new UnexpectedTestResultException("Length of uploaded file does not match storage file. 1024 : " + readfs.Length);
                        }
                    }
                    xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, fileName, beginReq.TitleId.Value, endReq.DateTimeOfExecute);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Begin-Upload-End with a filename with foreign (unicode) characters.")]
            public class P_EndToEnd_ForeignCharacters : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    //Japanese chars go from 0x3041 - 0xFA6A
                    beginReq.FileName = String.Format("Xlfs_EndToEnd_ForeignChars_{0}.bin", XlfsTests.RandomString(8, 0x3041, 0x9FA5)); ;
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);

                    ExecutePositiveEndToEnd(beginReq, 1024);
                }
            }

            [TestCase(136271), Owner("benran"), TestCasePriority(1), Description("Begin-Upload-End with a filename with special characters.")]
            public class P_EndToEnd_FileNameSpecialCharacters : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq;

                    // / \ \\ # & and ? are not allowed and are checked in the UploadBegin test. The rest should work end to end
                    // Dash
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_EndToEnd_Dash-{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecutePositiveEndToEnd(beginReq, 1024);

                    // Symbols not otherwise rejected by UploadBegin.
                    beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_EndToEnd_Symbols_!@$%^*()[]<>,.{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    Global.RO.Info("Storage Filename: " + beginReq.FileName);
                    ExecutePositiveEndToEnd(beginReq, 1024);
                }
            }
        }

        [TestGroup, Description("Validates that the ClientFD properly handles SAML tokens.")]
        public class SamlToken : TestNode
        {
            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin and UploadEnd with no Security SAML token")]
            public class N_SamlTest_NoSamlToken : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    beginReq.SamlParameters = null;
                    beginReq.UserXuid = 0x0009000000000001;
                    beginReq.TitleId = 1234567;
                    beginReq.FileName = String.Format("Xlfs_UploadBegin_NoSaml_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    ExecuteNegativeEndReq(endReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Calls UploadBegin and UploadEnd with an Invalid signature in the SAML token")]
            public class N_SamlTest_InvalidSamlToken : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    beginReq.SamlParameters = null;
                    XmlDocument xmlDoc = new XmlDocument();
                    string origSamlToken = XlfsTests.GenerateSecurityToken();
                    xmlDoc.LoadXml(origSamlToken);
                    //System.Xml.XPath.XPathNavigator xNav = xmlDoc.CreateNavigator();
                    XmlNodeList nodeList = xmlDoc.GetElementsByTagName("SignatureValue");
                    if (nodeList.Count == 1)
                    {
                        byte[] origSigArray = Convert.FromBase64String(nodeList[0].InnerText);
                        byte[] newSigArray = new byte[origSigArray.Length];
                        RandomEx.GlobalRandGen.NextBytes(newSigArray);
                        nodeList[0].InnerText = Convert.ToBase64String(newSigArray);
                        beginReq.SecurityToken = xmlDoc.OuterXml;
                    }
                    else
                    {
                        beginReq.SecurityToken = "INVALID";
                    }
                    beginReq.UserXuid = XlfsTests.SamlParameters.Xuid[0];
                    beginReq.TitleId = XlfsTests.SamlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_SamlTest_InvalidSaml_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    ExecuteNegativeEndReq(endReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Calls UploadBegin and UploadEnd with a No Cert encoded SAML token")]
            public class N_SamlTest_NoCertInSamlToken : TestNode
            {
                public override void Run()
                {
                    System.Security.Cryptography.X509Certificates.X509Certificate2 SamlCertificate =
                        new System.Security.Cryptography.X509Certificates.X509Certificate2(
                            @"SuitesData\Xlfs\test2-azure.xboxlive.com.pfx", "fat99cat");
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;
                    samlParameters.Certificate = SamlCertificate;

                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = samlParameters.Xuid[0];
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_SamlTest_InvalidSaml_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = XlfsTests.RandomHash();

                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    ExecuteNegativeEndReq(endReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin with a XUID that doesn't match the SAML token")]
            public class N_SamlTest_MismatchSamlXuid_UploadBegin : TestNode
            {
                public override void Run()
                {
                    MemoryStream memoryStream = new MemoryStream();
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    memoryStream.Position = 0;

                    //Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.UserXuid = RandomEx.GlobalRandGen.NextPuid();
                    beginReq.FileName = String.Format("Xlfs_SamlTest_MismatchXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadEnd with a XUID that doesn't match the SAML token")]
            public class N_SamlTest_MismatchSamlXuid_UploadEnd : TestNode
            {
                public override void Run()
                {
                    MemoryStream memoryStream = new MemoryStream();
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    memoryStream.Position = 0;

                    //Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.UserXuid = beginReq.SamlParameters.Xuid[0];
                    beginReq.FileName = String.Format("Xlfs_SamlTest_MismatchXuid_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    blobClient.PutBlob(BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId), memoryStream);

                    //End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.UserXuid = RandomEx.GlobalRandGen.NextPuid();
                    endReq.FileLength = memoryStream.Length;
                    ExecuteNegativeEndReq(endReq, HttpStatusCode.Unauthorized);

                    //Cleanup
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Calls UploadBegin and UploadEnd with a TitleId that doesn't match the SAML token")]
            public class P_SamlTest_MismatchSamlTitle : TestNode
            {
                public override void Run()
                {
                    MemoryStream memoryStream = new MemoryStream();
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    memoryStream.Position = 0;

                    //Begin
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    foreach (UInt32 titleId in XlfsTests.AllowedTitlesList)
                    {
                        beginReq.TitleId = titleId;
                        if (titleId != beginReq.SamlParameters.TitleID.Value)
                            break;
                    }
                    beginReq.FileName = String.Format("Xlfs_SamlTest_MismatchSamlTitle_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;
                    ExecutePositiveBeginReq(beginReq);

                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    blobClient.PutBlob(BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId), memoryStream);

                    //End
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);

                    //Cleanup
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Calls UploadBegin and UploadEnd with a Invalid TitleId that doesn't match the SAML token")]
            public class N_SamlTest_MismatchSamlInvalidTitle : TestNode
            {
                public override void Run()
                {
                    XlfsUploadBegin beginReq = CreateBeginReq();
                    do
                    {
                        beginReq.TitleId = (uint)RandomEx.GlobalRandGen.Next();
                    } while (XlfsTests.AllowedTitlesList.Contains(beginReq.TitleId.Value) == true);
                    beginReq.FileName = String.Format("Xlfs_SamlTest_MismatchSamlInvalidTitle_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Invalid TitleId Param
                    ExecuteNegativeBeginReq(beginReq, HttpStatusCode.Unauthorized);

                    beginReq = CreateBeginReq();
                    do
                    {
                        beginReq.SamlParameters.TitleID = (uint)RandomEx.GlobalRandGen.Next();
                    } while (XlfsTests.AllowedTitlesList.Contains(beginReq.SamlParameters.TitleID.Value) == true);
                    beginReq.FileName = String.Format("Xlfs_SamlTest_MismatchSamlInvalidTitle_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    //Invalid Saml TitleID
                    ExecutePositiveBeginReq(beginReq);
                    beginReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to UploadBegin and UploadEnd with a UserXuid in Slot1 of the Saml Token.")]
            public class P_SamlTest_XuidSlot1 : TestNode
            {
                public override void Run()
                {
                    MemoryStream memoryStream = new MemoryStream();
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    memoryStream.Position = 0;

                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;
                    UInt64 userXuid = RandomEx.GlobalRandGen.NextPuid();

                    samlParameters.Xuid[1] = userXuid;
                    samlParameters.Tier[1] = samlParameters.Tier[0];
                    samlParameters.Country[1] = samlParameters.Country[0];

                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = userXuid;
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_SamlTest_XuidSlot1_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;

                    //Begin
                    ExecutePositiveBeginReq(beginReq);
                    //End
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    blobClient.PutBlob(BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId), memoryStream);
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);
                    //Cleanup
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin, continue and end an upload with a UserXuid in Slot2 of the Saml Token.")]
            public class P_SamlTest_XuidSlot2 : TestNode
            {
                public override void Run()
                {
                    MemoryStream memoryStream = new MemoryStream();
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    memoryStream.Position = 0;

                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt64 userXuid = RandomEx.GlobalRandGen.NextPuid();
                    //samlParameters.Xuid[0] = userXuid;
                    samlParameters.Xuid[2] = userXuid;
                    samlParameters.Tier[2] = samlParameters.Tier[0];
                    samlParameters.Country[2] = samlParameters.Country[0];

                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = userXuid;
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_SamlTest_XuidSlot2_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;

                    //Begin
                    ExecutePositiveBeginReq(beginReq);
                    //End
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    blobClient.PutBlob(BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId), memoryStream);
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);
                    //Cleanup
                    endReq.CleanUp();
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Attempt to begin, continue and end an upload with a UserXuid in Slot3 of the Saml Token.")]
            public class P_SamlTest_XuidSlot3 : TestNode
            {
                public override void Run()
                {
                    MemoryStream memoryStream = new MemoryStream();
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);
                    memoryStream.Position = 0;

                    XlfsUploadBegin beginReq = new XlfsUploadBegin();
                    GetSecurityTokenParameters samlParameters = XlfsTests.SamlParameters;

                    UInt64 userXuid = RandomEx.GlobalRandGen.NextPuid();
                    //samlParameters.Xuid[0] = userXuid;
                    samlParameters.Xuid[3] = userXuid;

                    samlParameters.Tier[3] = samlParameters.Tier[0];
                    samlParameters.Country[3] = samlParameters.Country[0];

                    beginReq.SamlParameters = samlParameters;
                    beginReq.UserXuid = userXuid;
                    beginReq.TitleId = samlParameters.TitleID.Value;
                    beginReq.FileName = String.Format("Xlfs_SamlTest_XuidSlot3_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    beginReq.FileHash = memoryHash;

                    //Begin
                    ExecutePositiveBeginReq(beginReq);
                    //End
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    blobClient.PutBlob(BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId), memoryStream);
                    XlfsUploadEnd endReq = CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ExecutePositiveEndReq(endReq);
                    //Cleanup
                    endReq.CleanUp();
                }
            }
        }

        [TestGroup, Description("Validates that Multiple Storage Accounts work properly.")]
        public class MultipleStorageAccounts : TestNode
        {
            public static StorageAccountTableClient AccountTableClient = null;

            public override void PreRun()
            {
                AccountTableClient = new StorageAccountTableClient();

                if (AccountTableClient.Select().Count <= 1)
                {
                    throw new UnexpectedTestResultException(
                        "Unable to test multiple storage accounts with one storage account.  This is expected in single account setups.");
                }

                // Shoot one request at the front door, to make sure that the refresh thread is running.
                XlfsUploadBegin beginReq = CreateBeginReq();
                beginReq.FileName = String.Format("Xlfs_MultipleStorageAccountsPreRun_{0:X}.bin",
                                                  RandomEx.GlobalRandGen.NextUlong());
                ExecutePositiveBeginReq(beginReq);
            }

            public static StorageAccountTableEntry GetRandomStorageAccount()
            {
                Global.RO.Info("Selecting a random storage account...");
                return AccountTableClient.Select().OrderBy(e => Guid.NewGuid()).First();
            }

            /// <summary>
            /// Upload a random test file to each valid storage account at least
            /// once.
            /// </summary>
            /// <param name="unusedAccounts">
            /// This method verifies that none of the accounts in this list 
            /// are used by any of the upload requests.
            /// </param>
            public static void UploadToEachAccount(List<String> unusedAccounts)
            {
                UploadToEachAccount(unusedAccounts, 0, false);
            }

            /// <summary>
            /// Upload a random test file to each valid storage account at least
            /// once.
            /// </summary>
            /// <param name="unusedAccounts">
            /// This method verifies that none of the accounts in this list 
            /// are used by any of the upload requests.
            /// </param>
            /// <param name="fileSize">The size of each file to upload</param>
            public static void UploadToEachAccount(List<String> unusedAccounts, Int32 fileSize)
            {
                UploadToEachAccount(unusedAccounts, fileSize, false);
            }

            /// <summary>
            /// Upload a random test file to each valid storage account at least
            /// once.
            /// </summary>
            /// <param name="unusedAccounts">
            /// This method verifies that none of the accounts in this list 
            /// are used by any of the upload requests.
            /// </param>
            /// <param name="fileSize">The size of each file to upload.  If this is 0, no file upload is attempted</param>
            /// <param name="endUpload">If true, the upload is properly completed with a call to UploadEnd</param>
            public static void UploadToEachAccount(List<String> unusedAccounts, Int32 fileSize, Boolean endUpload)
            {
                Global.RO.Info("Uploading test file to each storage account...");

                List<StorageAccountTableEntry> accounts = AccountTableClient.Select().ToList();
                List<String> usedAccounts = new List<String>();

                // We should round robin over all of the storage accounts.  We'll make more
                // requests than we expect we need, which should hopefully allow each account
                // to be used even if there are other users making requests at the same time.
                int accountsCount = accounts.Count * 2;
                for (int i = 0; i < accountsCount; i++)
                {
                    Stream stream = null;
                    Byte[] hash = null;

                    XlfsUploadBegin beginReq = CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_MultipleStorageAccounts_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());

                    if (fileSize > 0)
                    {
                        GetRandomFile(fileSize, out stream, out hash);
                        beginReq.FileHash = hash;
                    }

                    ExecutePositiveBeginReq(beginReq);

                    // Check the storage account we got
                    Uri storageUri = new Uri(beginReq.StorageUri);
                    String accountName = storageUri.Host.Split('.')[0];
                    Global.RO.Info("Storage Account Name: " + accountName);

                    if (!usedAccounts.Contains(accountName))
                    {
                        usedAccounts.Add(accountName);
                    }

                    if (fileSize > 0)
                    {
                        // Create a BlobClient using the SAS Url returned by the beginReq
                        BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                        string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                        Global.RO.Info("Storage Path: " + storagePath);
                        blobClient.PutBlob(storagePath, stream);

                        // Now call UploadEnd.
                        XlfsUploadEnd endReq = CreateEndReq(beginReq);
                        endReq.FileLength = fileSize;

                        ExecutePositiveEndReq(endReq);
                        endReq.CleanUp();
                    }

                    if (endUpload)
                    {
                        XlfsUploadEnd endReq = CreateEndReq(beginReq);
                        endReq.FileLength = fileSize;

                        ExecutePositiveEndReq(endReq);
                    }
                }

                // Get a list of all the 'valid' accounts based on this simple 
                // capacity and threshold rules
                List<String> validAccounts = accounts
                    .Where(entry => entry.Used < entry.Threshold && entry.Threshold < entry.Capacity)
                    .Select(entry => entry.PartitionKey).ToList();

                // Loop through every account
                foreach (String accountName in accounts.Select(entry => entry.PartitionKey))
                {
                    // An account should have been used if it's in the valid 
                    // accounts list and we aren't expecting it to be excluded
                    // for some other reason (i.e. it's in the unusedAccounts 
                    // list because it has an invalid key or something).
                    Boolean shouldBeUsed = validAccounts.Contains(accountName) && !unusedAccounts.Contains(accountName);

                    // If an account was used, then the list should contain it
                    Boolean wasUsed = usedAccounts.Contains(accountName);

                    if (shouldBeUsed)
                    {
                        if (wasUsed)
                        {
                            Global.RO.Success("Storage account " + accountName + "was used as expected.");
                        }
                        else
                        {
                            throw new UnexpectedTestResultException(
                                "Storage account " + accountName + " should have been used but was not.");
                        }
                    }
                    else
                    {
                        if (wasUsed)
                        {
                            throw new UnexpectedTestResultException(
                                "Storage account " + accountName + " should not have been used but was.");
                        }
                        else
                        {
                            Global.RO.Success("Storage account " + accountName + "was not used as expected.");
                        }
                    }
                }
            }

            [TestCase, Description("Attempts to upload a file to each storage account.")]
            public class MultiAccountBVT : TestNode
            {
                List<String> accountNames;

                public override void PreRun()
                {
                    accountNames = AccountTableClient.Select().Select(e => e.PartitionKey).ToList();
                }

                public override void Run()
                {
                    // We should round robin over all of the storage accounts, 
                    // but just in case, we'll do it twice.
                    for (int i = 0; i < accountNames.Count * 2; i++)
                    {
                        XlfsUploadBegin uploadBegin = CreateBeginReq();
                        ExecutePositiveBeginReq(uploadBegin);

                        // Check the storage account we got
                        Uri storageUri = new Uri(uploadBegin.StorageUri);
                        String accountName = storageUri.Host.Split('.')[0];
                        Global.RO.Info("Storage Account Name: " + accountName);

                        if (accountNames.Contains(accountName))
                        {
                            accountNames.Remove(accountName);
                        }
                    }

                    if (accountNames.Count > 0)
                    {
                        throw new UnexpectedTestResultException("Uh oh, it looks like not all the storage accounts were used. \r\n" +
                            "Unused storage accounts: " + accountNames.Aggregate((a, b) => a + ", " + b));
                    }
                }
            }

            [CompoundCase("10%Threshold",  0.05, true)]
            [CompoundCase("50%Threshold",  0.40, true)]
            [CompoundCase("99%Threshold",  0.79, true)]
            [CompoundCase("100%Threshold", 0.80, false)]
            [CompoundCase("90%Capacity",   0.90, false)]
            [CompoundCase("100%Capacity",  1.00, false)]
            [TestCase, Description("Checks that server selects correct storage accounts at different capacity levels.")]
            public class AccountUsed : TestNode
            {
                StorageAccountTableEntry entry;
                StorageAccountTableEntry backupEntry;

                public override void PreRun()
                {
                    entry = GetRandomStorageAccount();
                    backupEntry = entry.Clone();

                    Double usedPercent = (Double)MyValues[0];
                    entry.Used = (long)(entry.Capacity * usedPercent);
                    Global.RO.Info("Updating account {0} used value to {1}% of capacity.", entry.PartitionKey, usedPercent * 100);
                    AccountTableClient.UpdateStorageAccountTableEntry(entry);

                    // Hmm, we need a way to force the service to reload it's settings from the table
                    // Wait a minute till the settings are refreshed.
                    Thread.Sleep(10000);
                }

                public override void Run()
                {
                    Boolean shouldUsedModifiedAccount = (Boolean)MyValues[1];
                    List<String> unusedAccounts = new List<string>();

                    if(!shouldUsedModifiedAccount)
                    {
                        unusedAccounts.Add(entry.PartitionKey);
                    }

                    Global.RO.Info("Calling upload begin once for each storage account.");
                    UploadToEachAccount(unusedAccounts);
                }

                public override void PostRun()
                {
                    // Restore the values from before
                    entry.ApplyValues(backupEntry);
                    AccountTableClient.UpdateStorageAccountTableEntry(entry);
                }
            }

            [TestCase, Description("")]
            public class DuplicateAccount : TestNode
            {
                StorageAccountTableEntry entry;
                StorageAccountTableEntry entryCopy;

                public override void PreRun()
                {
                    entry = GetRandomStorageAccount();
                    entryCopy = entry.Clone();

                    entryCopy.RowKey = RandomEx.GlobalRandGen.GenerateRandomString("MSATest_", 32);
                    AccountTableClient.AddStorageAccountTableEntry(entryCopy);
                }

                public override void Run()
                {
                    throw new DidNotExecuteException("This test does nothing.");
                }

                public override void PostRun()
                {
                    AccountTableClient.DeleteStorageAccountTableEntry(entryCopy);
                    base.PostRun();
                }
            }


            [CompoundCase("FakeAccountName", @"XlfsFakeStorageAccount001", null, null, null, null, null)]
            [CompoundCase("InvalidKey",        null, null, "0/0/0/0/0/0/0/0/0/0/0/0/", null, null, null)]
            [CompoundCase("NegativeCapacity",  null, null, null, -1 * XlfsTests.OneTeraByte, null, null)]
            [CompoundCase("NegativeThreshold", null, null, null, null, -1 * XlfsTests.OneTeraByte, null)]
            [CompoundCase("NegativeUsed",      null, null, null, null, null, -1 * XlfsTests.OneTeraByte)]
            [CompoundCase("Cap<Threshold",     null, null, null, 1 * XlfsTests.OneTeraByte, 80 * XlfsTests.OneTeraByte, null)]
            [CompoundCase("Cap<Used",          null, null, null, 1 * XlfsTests.OneTeraByte, null, 10 * XlfsTests.OneTeraByte)]
            [TestCase, Description("")]
            public class InvalidStorageAccount : TestNode
            {
                //StorageAccountSnapshot snapshot;
                StorageAccountTableEntry entry;
                StorageAccountTableEntry backupEntry;
                List<String> unusedAccounts;

                public override void PreRun()
                {
                    // The snapshot drops the table and recreates it.
                    // This takes longer than I'd like for each test
                    //snapshot = new StorageAccountSnapshot();

                    backupEntry = null;
                    unusedAccounts = new List<string>();

                    // Get a random storage account
                    entry = GetRandomStorageAccount();

                    String partitionKey = (String)MyValues[0];
                    if (partitionKey != null)
                    {
                        // If we're setting the partition key (i.e. account name),
                        // we need to add it as a new storage account, so we'll 
                        // just clone the one we got for all the default values
                        entry = entry.Clone();
                        entry.PartitionKey = partitionKey;
                    }
                    else
                    {
                        // If we're just changing some values, backup the current
                        // values so we can restore them later.
                        backupEntry = entry.Clone();
                    }

                    unusedAccounts.Add(entry.PartitionKey);

                    String rowKey = (String)MyValues[1];
                    if (rowKey != null)
                    {
                        entry.RowKey = rowKey;
                    }

                    String key = (String)MyValues[2];
                    if (key != null)
                    {
                        entry.Key = key;
                    }

                    Int64? capacity = (Int64?)MyValues[3];
                    if (capacity.HasValue)
                    {
                        entry.Capacity = capacity.Value;
                    }

                    Int64? threshold = (Int64?)MyValues[4];
                    if (threshold.HasValue)
                    {
                        entry.Threshold = threshold.Value;
                    }

                    Int64? used = (Int64?)MyValues[5];
                    if (used.HasValue)
                    {
                        entry.Used = used.Value;
                    }

                    if (backupEntry == null)
                    {
                        Global.RO.Info("Adding new storage account info...");
                        AccountTableClient.AddStorageAccountTableEntry(entry);
                    }
                    else
                    {
                        Global.RO.Info("Updating storage account info...");
                        AccountTableClient.UpdateStorageAccountTableEntry(entry);
                    }
                }

                public override void Run()
                {
                    Global.RO.Info("Waiting (60s) for account info changes to get picked up...");
                    Thread.Sleep(60000);
                    UploadToEachAccount(unusedAccounts);
                }

                public override void PostRun()
                {
                    //snapshot.Restore();

                    Global.RO.Info("Cleaning up Accounts table");
                    if (backupEntry == null)
                    {
                        AccountTableClient.DeleteStorageAccountTableEntry(entry);
                    }
                    else
                    {
                        entry.ApplyValues(backupEntry);
                        AccountTableClient.UpdateStorageAccountTableEntry(entry);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\FrontDoor\AdminFD.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Net;
using System.Xml;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.LiveService.Storage.Azure;
using ServerTestFramework.Core.Utilities;

using xonline.server.xlfs.common;

namespace Xlfs.Test
{
    [TestGroup, Owner("benran"), TestFrequency("Daily"), Description("Tests the functionality of the AdminFD")]
    public class AdminFD : TestNode
    {
        protected static UInt32 DefaultTitleId = 0xFFFE07D1;

        #region CommonTestFunctions
        static AdminFD()
        {
            DefaultTitleId = XlfsTests.AllowedTitlesList[0];
        }

        public static XlfsAdminGetChangedBlobs CreateChangedBlobsReq()
        {
            XlfsAdminGetChangedBlobs changedBlobReq = new XlfsAdminGetChangedBlobs();
            changedBlobReq.RequestCertificate = XlfsTests.DefaultAdminFDCert;
            changedBlobReq.TitleId = DefaultTitleId;
            DateTime utcNow = DateTime.UtcNow;
            changedBlobReq.StartTime = new DateTime(utcNow.Year, utcNow.Month, utcNow.Day,
                                                    utcNow.Hour, 0, 0, utcNow.Kind);
            changedBlobReq.EndTime = changedBlobReq.StartTime.Value.AddHours(1);

            return changedBlobReq;
        }

        public static XlfsAdminGetChangedBlobsContinue CreateChangedBlobsContinueReq()
        {
            XlfsAdminGetChangedBlobsContinue changedBlobContReq = new XlfsAdminGetChangedBlobsContinue();
            changedBlobContReq.RequestCertificate = XlfsTests.DefaultAdminFDCert;
            changedBlobContReq.TitleId = DefaultTitleId;

            return changedBlobContReq;
        }

        public static XlfsAdminGetStorageAccount CreateGetStorageAccountReq()
        {
            XlfsAdminGetStorageAccount getStorageAccountReq = new XlfsAdminGetStorageAccount();
            getStorageAccountReq.RequestCertificate = XlfsTests.DefaultAdminFDCert;

            return getStorageAccountReq;
        }

        public static XlfsAdminPutStorageAccount CreatePutStorageAccountReq()
        {
            XlfsAdminPutStorageAccount putStorageAccountReq = new XlfsAdminPutStorageAccount();
            putStorageAccountReq.RequestCertificate = XlfsTests.DefaultAdminFDCert;

            return putStorageAccountReq;
        }

        public static void ExecutePositiveChangedBlobsReq(XlfsAdminGetChangedBlobs changedBlobReq)
        {
            ExecutePositiveChangedBlobsReq(changedBlobReq, true);
        }

        public static void ExecutePositiveChangedBlobsReq(XlfsAdminGetChangedBlobs changedBlobReq, bool verify)
        {
            if (!changedBlobReq.Execute())
            {
                throw new UnexpectedTestResultException("Unable to perform XlfsAdminGetChangedBlobs request." + changedBlobReq.GetExceptionString());
            }
            if (verify && !changedBlobReq.Verify())
            {
                throw new UnexpectedTestResultException("XlfsAdminGetChangedBlobs Verify Failed.");
            }
            Global.RO.Success("XlfsAdminGetChangedBlobs Successful");
            foreach (SASInfo sasInfo in changedBlobReq.StorageInfo.Values)
            {
                Global.RO.Debug("Storage Account: " + sasInfo.StorageAccount);
                Global.RO.Debug("\tStorage Location: " + sasInfo.StorageUri);
                Global.RO.Debug("\tStorage Container: " + sasInfo.Container);
                Global.RO.Debug("\tStorage Signature: " + sasInfo.Signature);
            }
            //if(changedBlobReq.NextPartitionKey)
        }

        public static void ExecutePositiveGetStorageAccountReq(XlfsAdminGetStorageAccount getStorageAccountReq)
        {
            if(!getStorageAccountReq.Execute())
            {
                throw new UnexpectedTestResultException("Unable to perform XlfsAdminGetStorageAccount request." + getStorageAccountReq.GetExceptionString());
            }
            if(!getStorageAccountReq.Verify())
            {
                throw new UnexpectedTestResultException("XlfsAdminGetStorageAccount Verify Failed.");
            }
            Global.RO.Success("XlfsAdminGetStorageAccount Successful");
            Global.RO.Success("Storage Account Name: " + getStorageAccountReq.StorageAccount.PartitionKey);
            Global.RO.Debug("Storage Account Key: " + getStorageAccountReq.StorageAccount.Key);
            Global.RO.Debug("Storage Account Capacity: " + getStorageAccountReq.StorageAccount.Capacity);
            Global.RO.Debug("Storage Account Threshold: " + getStorageAccountReq.StorageAccount.Threshold);
            Global.RO.Debug("Storage Account Used: " + getStorageAccountReq.StorageAccount.Used);
        }

        public static void ExecutePositivePutStorageAccountReq(XlfsAdminPutStorageAccount putStorageAccountReq)
        {
            if (!putStorageAccountReq.Execute())
            {
                throw new UnexpectedTestResultException("Unable to perform XlfsAdminPutStorageAccount request." + putStorageAccountReq.GetExceptionString());
            }
            if (!putStorageAccountReq.Verify())
            {
                throw new UnexpectedTestResultException("XlfsAdminPutStorageAccount Verify Failed.");
            }
            Global.RO.Success("XlfsAdminPutStorageAccount Successful");
        }

        public static void ExecuteNegativeChangedBlobsReq(XlfsAdminGetChangedBlobs changedBlobReq, HttpStatusCode expectedStatus)
        {
            if (changedBlobReq.Execute())
            {
                throw new UnexpectedTestResultException("Did not expect XlfsAdminGetChangedBlobs to succeed.");
            }

            ValueCheck.Test("XlfsAdminGetChangedBlobs HttpStatus", expectedStatus, changedBlobReq.HttpStatus);

            Global.RO.Success("XlfsAdminGetChangedBlobs failed as expected.");
        }

        public static void ExecutePositiveChangedBlobsContinueReq(XlfsAdminGetChangedBlobsContinue changedBlobReq)
        {
            if (!changedBlobReq.Execute())
            {
                throw new UnexpectedTestResultException("Unable to perform XlfsAdminGetChangedBlobsContinue request." + changedBlobReq.GetExceptionString());
            }
            if (!changedBlobReq.Verify())
            {
                throw new UnexpectedTestResultException("XlfsAdminGetChangedBlobsContinue Verify Failed.");
            }
            Global.RO.Success("XlfsAdminGetChangedBlobsContinue Successful");
            foreach (SASInfo sasInfo in changedBlobReq.StorageInfo.Values)
            {
                Global.RO.Debug("Storage Account: " + sasInfo.StorageAccount);
                Global.RO.Debug("\tStorage Location: " + sasInfo.StorageUri);
                Global.RO.Debug("\tStorage Container: " + sasInfo.Container);
                Global.RO.Debug("\tStorage Signature: " + sasInfo.Signature);
            }
        }

        public static void ExecuteNegativeChangedBlobsContinueReq(XlfsAdminGetChangedBlobsContinue changedBlobReq, HttpStatusCode expectedStatus)
        {
            if (changedBlobReq.Execute())
            {
                throw new UnexpectedTestResultException("Did not expect XlfsAdminGetChangedBlobsContinue to succeed.");
            }

            ValueCheck.Test("XlfsAdminGetChangedBlobsContinue HttpStatus", expectedStatus, changedBlobReq.HttpStatus);

            Global.RO.Success("XlfsAdminGetChangedBlobsContinue failed as expected.");
        }

        public static string WriteTestFile(ulong userXuid, string fileName, uint titleId, long fileSize, DateTime lastUpdate)
        {
            byte[] byteArray = new byte[fileSize];
            RandomEx.GlobalRandGen.NextBytes(byteArray);
            MemoryStream memoryStream = new MemoryStream(byteArray);
            memoryStream.Seek(0, System.IO.SeekOrigin.Begin);
            string rowKey = FileTableLastUpdateClient.GetRowKey(userXuid, titleId, fileName);
            string transactionId = Guid.NewGuid().ToString("N");

            XLFSClient xlfsClient = new XLFSClient();
            xlfsClient.WriteFile(userXuid, rowKey, fileName, titleId, transactionId, fileSize, lastUpdate, memoryStream);
            return transactionId;
        }

        public static bool VerifyFileInResults(XlfsAdminGetChangedBlobs changedBlobReq, ulong userXuid, string fileName, long fileSize)
        {
            bool fileVerified = false;
            bool fileFound = false;
            if (changedBlobReq.Files.Count > 1)
            {
                Global.RO.Warn("More files found in XlfsAdminGetChangedBlobs file list than expected: {0}", changedBlobReq.Files.Count);
            }
            foreach (FileTableLastUpdateEntry fileEntry in changedBlobReq.Files)
            {
                if ((fileEntry.Filename == fileName) && (fileEntry.UserXuid == unchecked((long)userXuid)))
                {
                    fileFound = true;
                    fileVerified = true;
                    Global.RO.Success("Test file found in XlfsAdminGetChangedBlobs File List");
                    if (fileEntry.Size != fileSize)
                    {
                        Global.RO.Error("File Length returned by XlfsAdminGetChangedBlobs did not match expected. {0} : {1}", fileEntry.Size, fileSize);
                        fileVerified = false;
                    }

                    // Try and retrieve the file using the SAS information
                    SASInfo fileSAS = changedBlobReq.StorageInfo[fileEntry.StorageAccount];
                    string sasFileUrl = BlobTableClient.GetSASUrl(fileSAS.StorageUri.AbsoluteUri, fileSAS.Container, 
                        fileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString),
                        fileEntry.Filename, fileEntry.TransactionId, fileSAS.Signature);

                    try
                    {
                        BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                        blobClient.BlobContainer = fileSAS.Container;
                        using (Stream fileStream = blobClient.GetBlobAsStream(
                            BlobTableClient.GetStoragePath(fileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), fileEntry.Filename, fileEntry.TransactionId)))
                        {
                            if ((fileStream == null) || (fileStream.Length != fileEntry.Size))
                            {
                                Global.RO.Error("Unable to download: {0}", sasFileUrl);
                                fileVerified = false;
                            }
                            fileStream.Close();
                        }
                    }
                    catch
                    {
                        Global.RO.Error("Unable to download: {0}", sasFileUrl);
                        fileVerified = false;
                    }
                }
                else
                {
                    Global.RO.Warn("File \"{0}\" found in XlfsAdminGetChangedBlobs file list that was not expected.", fileEntry.Filename);
                }
            }
            if (!fileFound)
            {
                Global.RO.Error("Test file not found in XlfsAdminGetChangedBlobs results.");
            }

            return fileVerified;
        }

        public static bool VerifyFileUsingContinueResults(XlfsAdminGetChangedBlobsContinue changedBlobContinueReq, ulong userXuid, string fileName)
        {
            bool fileVerified = true;
            FileTableLastUpdateClient fileClient = new FileTableLastUpdateClient();
            List<FileTableLastUpdateEntry> fileList =  fileClient.SelectFile(userXuid, changedBlobContinueReq.TitleId.Value, fileName);
            if (fileList.Count == 0)
                throw new UnexpectedTestResultException("Could not find file in FileTable. " + fileName);
            FileTableLastUpdateEntry fileEntry = fileList[0];

            // Try and retrieve the file using the SAS information
            SASInfo fileSAS = changedBlobContinueReq.StorageInfo[fileEntry.StorageAccount];
            string sasFileUrl = BlobTableClient.GetSASUrl(fileSAS.StorageUri.AbsoluteUri, fileSAS.Container, 
                fileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString),
                fileEntry.Filename, fileEntry.TransactionId, fileSAS.Signature);
            Global.RO.Info(sasFileUrl);
            try
            {
                BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                blobClient.BlobContainer = fileSAS.Container;
                using (Stream fileStream = blobClient.GetBlobAsStream(
                    BlobTableClient.GetStoragePath(fileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), fileEntry.Filename, fileEntry.TransactionId)))
                {
                    if ((fileStream == null) || (fileStream.Length != fileEntry.Size))
                    {
                        Global.RO.Error("Unable to download: {0}", sasFileUrl);
                        fileVerified = false;
                    }
                    fileStream.Close();
                }
            }
            catch
            {
                Global.RO.Error("Unable to download: {0}", sasFileUrl);
                fileVerified = false;
            }

            return fileVerified;
        }

        public static bool IsFileInResults(XlfsAdminGetChangedBlobs changedBlobReq, ulong userXuid, string fileName)
        {
            bool fileFound = false;
            foreach (FileTableLastUpdateEntry fileEntry in changedBlobReq.Files)
            {
                if ((fileEntry.Filename == fileName) && (fileEntry.UserXuid == unchecked((long)userXuid)))
                {
                    fileFound = true;
                    Global.RO.Info("Test file found in XlfsAdminGetChangedBlobs File List");
                }
            }

            return fileFound;
        }
        #endregion

        [TestGroup, Description("Functional tests for GetChangedBlobs API")]
        public class GetChangedBlobs_Functional
        {
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Basic Positive case. Should execute and return no files.")]
            public class P_GetChangedBlobsBVT : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobs = CreateChangedBlobsReq();

                    ExecutePositiveChangedBlobsReq(getBlobs);
                    if (getBlobs.Files.Count > 0)
                    {
                        Global.RO.Warn("More files found in XlfsAdminGetChangedBlobs file list than expected: {0}", getBlobs.Files.Count);
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(0), Description("Basic Positive case. Upload One file that should be found and returned.")]
            public class P_GetChangedBlobs : TestNode
            {
                public override void Run()
                {
                    String fileName = String.Format("Xlfs_GetChangedBlobs_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    DateTime fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);
                    getBlobsReq.TitleId = titleId;

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    if (!VerifyFileInResults(getBlobsReq, userXuid, fileName, fileSize))
                    {
                        throw new UnexpectedTestResultException("File Verification failed.");
                    }
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(0), Description("Basic Positive End-toEnd case. Upload One file using the Client Front Door that should be found and returned.")]
            public class P_GetChangedBlobsEndToEnd : TestNode
            {
                public override void Run()
                {   
                    
                    XlfsUploadBegin beginReq = ClientFD.CreateBeginReq();
                    beginReq.FileName = String.Format("Xlfs_GetChangedBlobsEndToEnd_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;

                    byte[] byteArray = new byte[fileSize];
                    RandomEx.GlobalRandGen.NextBytes(byteArray);
                    MemoryStream memoryStream = new MemoryStream(byteArray);
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    byte[] memoryHash = BlobClient.GetMD5Hash(memoryStream);

                    //Execute Begin
                    beginReq.FileHash = memoryHash;
                    ClientFD.ExecutePositiveBeginReq(beginReq);

                    // Create a BlobClient using the SAS Url returned by the beginReq
                    BlobClient blobClient = new BlobClient(beginReq.StorageUri);
                    string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
                    Global.RO.Info("Storage Path: " + storagePath);
                    blobClient.PutBlob(storagePath, memoryStream);
                    memoryStream.Seek(0, SeekOrigin.Begin);

                    //Execute End
                    XlfsUploadEnd endReq = ClientFD.CreateEndReq(beginReq);
                    endReq.FileLength = memoryStream.Length;
                    ClientFD.ExecutePositiveEndReq(endReq);
                    System.Threading.Thread.Sleep(5000);

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = beginReq.TitleId;

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    if (!VerifyFileInResults(getBlobsReq, beginReq.UserXuid.Value, beginReq.FileName, fileSize))
                    {
                        throw new UnexpectedTestResultException("File Verification failed.");
                    }
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TitleId.Value);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with no TitleId parameter.")]
            public class N_GetChangedBlobs_NoTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = null; // Should fail

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with an invalid TitleId.")]
            public class N_GetChangedBlobs_InvalidTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = null;
                    HttpQueryParameterAttribute titleIdQueryParam = new HttpQueryParameterAttribute("titleid");
                    getBlobsReq.CustomQueryParams.Add(titleIdQueryParam.GenerateParamString("INVALID"));

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with a Zero TitleId.")]
            public class N_GetChangedBlobs_ZeroTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = 0;

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a One TitleId.")]
            public class P_GetChangedBlobs_OneTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = 0x1;

                    ExecutePositiveChangedBlobsReq(getBlobsReq);
                    if (getBlobsReq.Files.Count > 0)
                    {
                        Global.RO.Warn("More files found in XlfsAdminGetChangedBlobs file list than expected: {0}", getBlobsReq.Files.Count);
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a Uint32.MaxValue TitleId.")]
            public class P_GetChangedBlobs_MaxTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = UInt32.MaxValue;

                    ExecutePositiveChangedBlobsReq(getBlobsReq);
                    if (getBlobsReq.Files.Count > 0)
                    {
                        Global.RO.Warn("More files found in XlfsAdminGetChangedBlobs file list than expected: {0}", getBlobsReq.Files.Count);
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with a Uint32.MaxValue + 1 TitleId.")]
            public class N_GetChangedBlobs_OverMaxTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = null;
                    UInt64 overMaxTitleId = ((UInt64)UInt32.MaxValue) + 1;
                    HttpQueryParameterAttribute titleIdQueryParam = new HttpQueryParameterAttribute("titleid");
                    getBlobsReq.CustomQueryParams.Add(titleIdQueryParam.GenerateParamString(overMaxTitleId.ToString("X16")));

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a Random (non-zero) TitleId.")]
            public class P_GetChangedBlobs_RandomTitleId : TestNode
            {
                public override void Run()
                {
                    String randomTitleFileName = String.Format("Xlfs_GetChangedBlobs_RandomTitleId_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    String defaultTitleFileName = String.Format("Xlfs_GetChangedBlobs_DefaultTitleId_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId;
                    do
                    {
                        titleId = unchecked((uint)RandomEx.GlobalRandGen.Next());
                    }
                    while ((titleId == 0) || (titleId == DefaultTitleId));

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;

                    //Write two files. One to the random title Id we're using and one to the default. the query should only return the random one
                    DateTime fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, randomTitleFileName, titleId, fileSize, fileTime);
                    WriteTestFile(userXuid, defaultTitleFileName, DefaultTitleId, fileSize, fileTime);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    if (!VerifyFileInResults(getBlobsReq, userXuid, randomTitleFileName, fileSize))
                    {
                        throw new UnexpectedTestResultException("File Verification failed.");
                    }
                    if (IsFileInResults(getBlobsReq, userXuid, defaultTitleFileName)) // This should be caught by the Verify() and may be removed
                    {
                        Global.RO.Error("{0} was found in the GetBlobResults for TitleId {1:X8} when it resides in TitleId {2:X8}", defaultTitleFileName, titleId, DefaultTitleId);
                        throw new UnexpectedTestResultException("Unexpected File Found.");
                    }
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, randomTitleFileName, titleId, fileTime);
                    xlfsClient.SafeRemoveFile(userXuid, defaultTitleFileName, DefaultTitleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with no StartTime parameter (should use Default).")]
            public class P_GetChangedBlobs_NoStartTime : TestNode
            {
                public override void Run()
                {
                    String nowFileName = String.Format("Xlfs_GetChangedBlobs_NoStartTime_Now_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    String olderFileName = String.Format("Xlfs_GetChangedBlobs_NoStartTime_Old_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;
                    getBlobsReq.StartTime = null;
                    getBlobsReq.EndTime = DateTime.UtcNow;

                    //Write two files. One Now and one older than the Default Start Time. the query should only return the Now one
                    DateTime nowFileTime = getBlobsReq.EndTime.Value.AddMinutes(-1);
                    DateTime olderFileTime = getBlobsReq.EndTime.Value.AddHours(-1);
                    WriteTestFile(userXuid, nowFileName, titleId, fileSize, nowFileTime);
                    WriteTestFile(userXuid, olderFileName, titleId, fileSize, olderFileTime); // Enddate.hour (no minute or second)

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, nowFileName, titleId, nowFileTime);
                    xlfsClient.SafeRemoveFile(userXuid, olderFileName, titleId, olderFileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a DateTime.UtcNow StartTime parameter.")]
            public class P_GetChangedBlobs_StartTimeNow : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.StartTime = DateTime.UtcNow;
                    getBlobsReq.EndTime = DateTime.UtcNow;

                    ExecutePositiveChangedBlobsReq(getBlobsReq);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with a DateTime.MinValue StartTime parameter.")]
            public class N_GetChangedBlobs_StartTimeMin : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.StartTime = DateTime.MinValue;

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with a DateTime.MinValue + 10 days StartTime parameter.")]
            public class N_GetChangedBlobs_StartTimeMinPlus10Days : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.StartTime = DateTime.MinValue.AddDays(10);

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a DateTime.MaxValue StartTime parameter.")]
            public class P_GetChangedBlobs_StartTimeMax : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.StartTime = DateTime.MaxValue;
                    getBlobsReq.EndTime = DateTime.MaxValue;

                    ExecutePositiveChangedBlobsReq(getBlobsReq);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a StartTime of DateTime.UtcNow + 1 hour.")]
            public class P_GetChangedBlobs_StartTimeFuture : TestNode
            {
                public override void Run()
                {
                    String nowFileName = String.Format("Xlfs_GetChangedBlobs_StartTimeFuture_Now_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    String futureFileName = String.Format("Xlfs_GetChangedBlobs_StartTimeFuture_Future_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;
                    getBlobsReq.StartTime = getBlobsReq.StartTime.Value.AddHours(1);
                    getBlobsReq.EndTime = getBlobsReq.StartTime.Value.AddHours(1);

                    //Write two files. One Now and one older than the Default Start Time. the query should only return the Now one
                    DateTime nowFileTime = getBlobsReq.StartTime.Value.AddMinutes(-5);
                    DateTime futureFileTime = getBlobsReq.StartTime.Value.AddMinutes(5);
                    WriteTestFile(userXuid, nowFileName, titleId, fileSize, nowFileTime);
                    WriteTestFile(userXuid, futureFileName, titleId, fileSize, futureFileTime);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, nowFileName, titleId, nowFileTime);
                    xlfsClient.SafeRemoveFile(userXuid, futureFileName, titleId, futureFileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with a StartTime after the EndTime.")]
            public class N_GetChangedBlobs_StartTimeAfterEndTime : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.StartTime = DateTime.UtcNow;
                    getBlobsReq.EndTime = new DateTime(getBlobsReq.StartTime.Value.Year, getBlobsReq.StartTime.Value.Month, getBlobsReq.StartTime.Value.Day,
                                                        getBlobsReq.StartTime.Value.Hour, 0, 0, getBlobsReq.StartTime.Value.Kind);

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with a StartTime in a different partition than the EndTime.")]
            public class N_GetChangedBlobs_StartTimeDifferentPartitionThanEndTime : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.EndTime = DateTime.UtcNow;
                    getBlobsReq.StartTime = getBlobsReq.EndTime.Value.AddHours(-1);

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a StartTime and the EndTime on exact 1 hour boundaries.")]
            public class P_GetChangedBlobs_StartTimeAndEndTimeExactHourBoundary : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    DateTime utcNow = DateTime.UtcNow;
                    getBlobsReq.EndTime = new DateTime(utcNow.Year, utcNow.Month, utcNow.Day,
                                                       utcNow.Hour, 0, 0, utcNow.Kind);
                    getBlobsReq.StartTime = getBlobsReq.EndTime.Value.AddHours(-1);


                    ExecutePositiveChangedBlobsReq(getBlobsReq);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with no EndTime parameter (should use Default).")]
            public class P_GetChangedBlobs_NoEndTime : TestNode
            {
                public override void Run()
                {
                    String nowFileName = String.Format("Xlfs_GetChangedBlobs_NoEndTime_Now_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    String futureFileName = String.Format("Xlfs_GetChangedBlobs_StartTimeFuture_Future_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;
                    getBlobsReq.EndTime = null; // should use utcNow

                    //Write two files. One Now and one older than the Default Start Time. the query should only return the Now one
                    DateTime nowFileTime = getBlobsReq.StartTime.Value.AddMinutes(1);
                    DateTime futureFileTime = DateTime.UtcNow.AddMinutes(15);
                    WriteTestFile(userXuid, nowFileName, titleId, fileSize, nowFileTime);
                    WriteTestFile(userXuid, futureFileName, titleId, fileSize, futureFileTime); // Default is this hour

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, nowFileName, titleId, nowFileTime);
                    xlfsClient.SafeRemoveFile(userXuid, futureFileName, titleId, futureFileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a DateTime.UtcNow EndTime parameter.")]
            public class P_GetChangedBlobs_EndTimeNow : TestNode
            {
                public override void Run()
                {
                    String nowFileName = String.Format("Xlfs_GetChangedBlobs_EndTimeNow_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    String olderFileName = String.Format("Xlfs_GetChangedBlobs_EndTimeNow_Old_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    String futureFileName = String.Format("Xlfs_GetChangedBlobs_EndTimeNow_Future_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    DateTime nowTime = DateTime.UtcNow;
                    //Write two files. One Now and one older than the Default Start Time. the query should only return the Now one
                    WriteTestFile(userXuid, nowFileName, titleId, fileSize, nowTime.AddMinutes(-5));
                    WriteTestFile(userXuid, olderFileName, titleId, fileSize, nowTime.AddHours(-2)); // Default is this hour
                    WriteTestFile(userXuid, futureFileName, titleId, fileSize, nowTime.AddMinutes(5)); // after the EndTime but within the hour

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;
                    getBlobsReq.EndTime = nowTime;

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, nowFileName, titleId, nowTime.AddMinutes(-5));
                    xlfsClient.SafeRemoveFile(userXuid, olderFileName, titleId, nowTime.AddHours(-2));
                    xlfsClient.SafeRemoveFile(userXuid, futureFileName, titleId, nowTime.AddMinutes(5));
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with a DateTime.MinValue EndTime parameter.")]
            public class P_GetChangedBlobs_EndTimeMin : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    //getBlobsReq.StartTime = DateTime.MinValue;
                    getBlobsReq.EndTime = DateTime.MinValue;

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with a DateTime.MinValue EndTime parameter.")]
            public class N_GetChangedBlobs_EndTimeMinPlus1Day : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.StartTime = DateTime.MinValue.AddDays(1);
                    getBlobsReq.EndTime = DateTime.MinValue.AddDays(1);

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a DateTime.MaxValue EndTime parameter.")]
            public class P_GetChangedBlobs_EndTimeMax : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.StartTime = DateTime.MaxValue.AddMinutes(-10);
                    getBlobsReq.EndTime = DateTime.MaxValue;

                    ExecutePositiveChangedBlobsReq(getBlobsReq);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with a EndTime of DateTime.UtcNow + 1 hour.")]
            public class P_GetChangedBlobs_EndTimeFuture : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.StartTime = getBlobsReq.StartTime.Value.AddHours(1);
                    getBlobsReq.EndTime = getBlobsReq.StartTime.Value.AddHours(1);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobs with no parameters at all.")]
            public class N_GetChangedBlobs_NoParameters : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = null;
                    getBlobsReq.StartTime = null;
                    getBlobsReq.EndTime = null;

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobs with no StartTime or EndTime parameters (should use Default).")]
            public class P_GetChangedBlobs_NoTimeParameters : TestNode
            {
                public override void Run()
                {
                    String nowFileName = String.Format("Xlfs_GetChangedBlobs_NoTimeParameters_Now_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    String olderFileName = String.Format("Xlfs_GetChangedBlobs_NoTimeParameters_Old_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    //Write two files. One Now and one older than the Default Start Time. the query should only return the Now one
                    DateTime nowFileTime = DateTime.UtcNow.AddMinutes(-5);
                    DateTime olderFileTime = DateTime.UtcNow.AddHours(-1);
                    WriteTestFile(userXuid, nowFileName, titleId, fileSize, nowFileTime);
                    WriteTestFile(userXuid, olderFileName, titleId, fileSize, olderFileTime); // Default is this hour

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;
                    getBlobsReq.StartTime = null;
                    getBlobsReq.EndTime = null;

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, nowFileName, titleId, nowFileTime);
                    xlfsClient.SafeRemoveFile(userXuid, olderFileName, titleId, olderFileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Upload a file with foreign characters in the filename and Call GetChangedBlobs verifying the file is returned correctly.")]
            public class P_GetChangedBlobs_FileNameForeignCharacters : TestNode
            {
                public override void Run()
                {
                    //Japanese chars go from 0x3041 - 0xFA6A
                    String foreignFileName = String.Format("Xlfs_GetChangedBlobs_ForeignChars_{0}.bin", XlfsTests.RandomString(8, 0x3041, 0x9FA5)); ;
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;

                    DateTime fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, foreignFileName, titleId, fileSize, fileTime);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);
                    if (!VerifyFileInResults(getBlobsReq, userXuid, foreignFileName, fileSize))
                    {
                        throw new UnexpectedTestResultException("File Verification failed.");
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, foreignFileName, titleId, fileTime);
                }                
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Pass a valid continuation token.")]
            public class P_GetChangedBlobs_ValidContinuation : TestNode
            {
                public override void Run()
                {
                    String fileName1 = String.Format("P_GetChangedBlobs_ValidContinuation_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    String fileName2 = String.Format("P_GetChangedBlobs_ValidContinuation_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    const long fileSize = 1024;
                    uint titleId = DefaultTitleId;

                    try
                    {
                        //Write two files. One Now and one older than the Default Start Time. the query should only return the Now one
                        WriteTestFile(userXuid, fileName1, titleId, fileSize, DateTime.UtcNow);
                        WriteTestFile(userXuid, fileName2, titleId, fileSize, DateTime.UtcNow); // Default is this hour

                        XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                        getBlobsReq.MaxResults = 1;

                        ExecutePositiveChangedBlobsReq(getBlobsReq);

                        if(getBlobsReq.Continuation == null)
                        {
                            throw new UnexpectedTestResultException("Expected a continuation token from the server, but didn't get one.");
                        }
                        Global.RO.Info("Continuation token = {0}", getBlobsReq.Continuation);

                        if(getBlobsReq.Files.Count != 1)
                        {
                            throw new UnexpectedTestResultException(
                                String.Format("Expected 1 file back, got {0}.", getBlobsReq.Files.Count));
                        }

                        string continuation1 = getBlobsReq.Continuation;
                        string receivedFileName1 = getBlobsReq.Files[0].Filename;

                        ExecutePositiveChangedBlobsReq(getBlobsReq);

                        if (getBlobsReq.Continuation == null)
                        {
                            throw new UnexpectedTestResultException("Expected a continuation token from the server, but didn't get one.");
                        }
                        Global.RO.Info("Continuation token = {0}", getBlobsReq.Continuation);

                        if(continuation1 == getBlobsReq.Continuation)
                        {
                            throw new UnexpectedTestResultException("Expected second request to return a different continuation, but it was the same as the first.");
                        }

                        if (getBlobsReq.Files.Count != 1)
                        {
                            throw new UnexpectedTestResultException(
                                String.Format("Expected 1 file back, got {0}.", getBlobsReq.Files.Count));
                        }

                        if(receivedFileName1 == getBlobsReq.Files[0].Filename)
                        {
                            throw new UnexpectedTestResultException("Second request returned same file as the first request.");
                        }
                    }
                    finally
                    {
                        XLFSClient xlfsClient = new XLFSClient();
                        xlfsClient.SafeRemoveFile(userXuid, fileName1, titleId);
                        xlfsClient.SafeRemoveFile(userXuid, fileName2, titleId);
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Pass a valid continuation token.")]
            public class N_GetChangedBlobs_InvalidContinuation_NoColon : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.Continuation = "tokenwithnocolons";

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Pass a valid continuation token.")]
            public class P_GetChangedBlobs_InvalidContinuation_InvalidTokens : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.Continuation = "badtoken1:badtoken2";

                    // [darrenan]
                    // We expect this case to return an empty file list and
                    // no continuation token.  This is how Azure handles
                    // invalid continuation tokens.  I fully expect this test
                    // to start failing at some point in the future when Azure
                    // decides to change this behavior.
                    ExecutePositiveChangedBlobsReq(getBlobsReq, false);
                    if(getBlobsReq.Files.Count != 0)
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Expected back an empty file list, but got back {0} files.", getBlobsReq.Files.Count));
                    }
                    if(!string.IsNullOrEmpty(getBlobsReq.Continuation))
                    {
                        throw new UnexpectedTestResultException("Got a continuation token when not expected.");
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("MaxResults = 0")]
            public class N_GetChangedBlobs_MaxResultsZero : TestNode
            {
                public override void Run()
                {
                    // Make sure there's at least one file to get back.
                    String fileName = String.Format("N_GetChangedBlobs_MaxResultsZero_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    const long fileSize = 1024;
                    uint titleId = DefaultTitleId;
                    WriteTestFile(userXuid, fileName, titleId, fileSize, DateTime.UtcNow); // Default is this hour

                    try
                    {
                        XlfsAdminGetChangedBlobs getChangedBlobs = CreateChangedBlobsReq();
                        getChangedBlobs.MaxResults = 0;

                        ExecutePositiveChangedBlobsReq(getChangedBlobs);
                        if (getChangedBlobs.Files.Count == 0)
                        {
                            throw new UnexpectedTestResultException("Expected zero value for maxresults to be ignored, but we actually got back zero files.");
                        }
                    }
                    finally
                    {
                        XLFSClient xlfsClient = new XLFSClient();
                        xlfsClient.SafeRemoveFile(userXuid, fileName, titleId);
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("MaxResults < 0")]
            public class N_GetChangedBlobs_MaxResultsLessThanZero : TestNode
            {
                public override void Run()
                {
                    // Make sure there's at least one file to get back.
                    String fileName = String.Format("N_GetChangedBlobs_MaxResultsLessThanZero_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    const long fileSize = 1024;
                    uint titleId = DefaultTitleId;
                    WriteTestFile(userXuid, fileName, titleId, fileSize, DateTime.UtcNow); // Default is this hour

                    try
                    {
                        XlfsAdminGetChangedBlobs getChangedBlobs = CreateChangedBlobsReq();
                        getChangedBlobs.MaxResults = -1;

                        ExecutePositiveChangedBlobsReq(getChangedBlobs);
                        if (getChangedBlobs.Files.Count == 0)
                        {
                            throw new UnexpectedTestResultException("Expected negative value for maxresults to be ignored, but we actually got back zero files.");
                        }
                    }
                    finally
                    {
                        XLFSClient xlfsClient = new XLFSClient();
                        xlfsClient.SafeRemoveFile(userXuid, fileName, titleId);
                    }
                }
            }
        }

        [TestGroup, Description("Tests for GetChangedBlobs API security")]
        public class GetChangedBlobs_Security
        {
            // Depricated now that IP validation is used instead of cert validation
            [TestCase, Owner("benran"), TestCasePriority(2), Description("Calls GetChangedBlobs with no Certificate.")]
            public class N_GetChangedBlobs_NoCertificate : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.RequestCertificate = null;

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.Forbidden);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Calls GetChangedBlobs with an invalid Certificate.")]
            public class N_GetChangedBlobs_InvalidCertificate : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    //All computer stores have a certificate of the computer name. we'll use that since it won't work with the front door
                    string fakeCert = System.Net.Dns.GetHostName();
                    getBlobsReq.RequestCertificate = fakeCert;

                    ExecuteNegativeChangedBlobsReq(getBlobsReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Read a blob returned in the file list using the SAS returned by GetChangedBlobs.")]
            public class P_GetChangedBlobs_SASUrlRead : TestNode
            {
                public override void Run()
                {
                    String fileName = String.Format("Xlfs_GetChangedBlobs_SASUrlRead_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;

                    DateTime fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    FileTableLastUpdateEntry testFileEntry = getBlobsReq.GetFile(userXuid, fileName);
                    SASInfo fileSAS = getBlobsReq.StorageInfo[testFileEntry.StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = fileSAS.Container;
                    string storagePath = BlobTableClient.GetStoragePath(testFileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), testFileEntry.Filename, testFileEntry.TransactionId);
                    using (Stream fileStream = blobClient.GetBlobAsStream(storagePath))
                    {
                        if ((fileStream == null) || (fileStream.Length != testFileEntry.Size))
                        {
                            Global.RO.Error("Unable to download: {0}", storagePath);
                            throw new UnexpectedTestResultException();
                        }
                        fileStream.Close();
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Read a blob from the same container not in the file list using the SAS returned by GetChangedBlobs.")]
            [Ignore("This test case is attempting to do something that's not an intended supported operation.")]
            public class P_GetChangedBlobs_SASUrlReadOtherFile : TestNode
            {
                public override void Run()
                {
                    String fileName = String.Format("Xlfs_GetChangedBlobs_SASUrlRead_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    String otherFileName = String.Format("Xlfs_GetChangedBlobs_SASUrlRead_Other_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;

                    DateTime fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);
                    string otherTransactionId = WriteTestFile(userXuid, otherFileName, titleId, fileSize, fileTime.AddHours(-2));

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    if (IsFileInResults(getBlobsReq, userXuid, otherFileName))
                    {
                        throw new UnexpectedTestResultException("Other file (" + otherFileName + ") was in GetChangedBlobs response.");
                    }
                    else
                    {
                        // Should we list the container and find a file not in the results?
                        FileTableLastUpdateEntry testFileEntry = getBlobsReq.GetFile(userXuid, fileName);
                        SASInfo fileSAS = getBlobsReq.StorageInfo[testFileEntry.StorageAccount];
                        BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                        blobClient.BlobContainer = fileSAS.Container;
                        string storagePath = BlobTableClient.GetStoragePath(testFileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), otherFileName, otherTransactionId);
                        using (Stream fileStream = blobClient.GetBlobAsStream(storagePath))
                        {
                            if ((fileStream == null) || (fileStream.Length != testFileEntry.Size))
                            {
                                throw new UnexpectedTestResultException(String.Format("Unable to download: {0}", storagePath));
                            }
                            fileStream.Close();
                        }
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                    xlfsClient.SafeRemoveFile(userXuid, otherFileName, titleId, fileTime.AddHours(-2));
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("List blobs using the SAS returned by GetChangedBlobs.")]
            public class P_GetChangedBlobs_SASUrlList : TestNode
            {
                public override void Run()
                {
                    String fileName = String.Format("Xlfs_GetChangedBlobs_SASUrlList_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    long fileSize = 1024;
                    ulong userXuid = RandomEx.GlobalRandGen.NextPuid();
                    uint titleId = DefaultTitleId;

                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;

                    DateTime fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    foreach (SASInfo fileSAS in getBlobsReq.StorageInfo.Values)
                    {
                        BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                        blobClient.BlobContainer = fileSAS.Container;
                        List<string> dirList = blobClient.GetFolderList();
                        Global.RO.Info("Container {0} has {1} directories", fileSAS.Container, dirList.Count);
                        List<string> blobList = blobClient.GetBlobList(userXuid.ToString(BlobTableEntry.XuidFormatString));
                        Global.RO.Info("Directory {0:X16} has {1} blobs", userXuid, blobList.Count);
                    }

                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Write a blob returned in the file list using the SAS returned by GetChangedBlobs.")]
            public class N_GetChangedBlobs_SASUrlWrite : TestNode
            {
                String fileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    fileName = String.Format("Xlfs_GetChangedBlobs_SASUrlRead_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    titleId = DefaultTitleId;
                }

                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;

                    fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    FileTableLastUpdateEntry testFileEntry = getBlobsReq.GetFile(userXuid, fileName);
                    SASInfo fileSAS = getBlobsReq.StorageInfo[testFileEntry.StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = fileSAS.Container;
                    string storagePath = BlobTableClient.GetStoragePath(testFileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), testFileEntry.Filename, testFileEntry.TransactionId);
                    byte[] randomBytes = new byte[fileSize];
                    RandomEx.GlobalRandGen.NextBytes(randomBytes);
                    using (MemoryStream memoryStream = new MemoryStream(randomBytes))
                    {
                        try
                        {
                            blobClient.PutBlob(storagePath, memoryStream);
                            throw new UnexpectedTestResultException("Write Succeeded using SAS when it should've failed");
                        }
                        catch (UnexpectedTestResultException)
                        {
                            throw;
                        }
                        catch
                        {
                            Global.RO.Success("Write failed as expected");
                        }
                    }
                }

                public override void PreRun(RUN_TYPE runType)
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Remove a blob returned in the file list using the SAS returned by GetChangedBlobs.")]
            public class N_GetChangedBlobs_SASUrlRemove : TestNode
            {
                String fileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    fileName = String.Format("Xlfs_GetChangedBlobs_SASUrlRemove_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    titleId = DefaultTitleId;
                }

                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = titleId;

                    fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    FileTableLastUpdateEntry testFileEntry = getBlobsReq.GetFile(userXuid, fileName);
                    SASInfo fileSAS = getBlobsReq.StorageInfo[testFileEntry.StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = fileSAS.Container;
                    string storagePath = BlobTableClient.GetStoragePath(
                        testFileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), 
                        testFileEntry.Filename, 
                        testFileEntry.TransactionId);

                    if (blobClient.DeleteBlob(storagePath))
                    {
                        throw new UnexpectedTestResultException("Remove Succeeded using SAS when it should've failed");
                    }
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Read a blob from a different container using the SAS returned by GetChangedBlobs.")]
            public class N_GetChangedBlobs_SASUrlReadOtherContainer : TestNode
            {
                String defaultTitleFileName;
                String otherTitleFileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    defaultTitleFileName = String.Format("Xlfs_GetChangedBlobs_SASUrlReadOtherContainer_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    otherTitleFileName = String.Format("Xlfs_GetChangedBlobs_SASUrlReadOtherContainer_Other_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    
                    do
                    {
                        titleId = unchecked((uint)RandomEx.GlobalRandGen.Next());
                    }
                    while ((titleId == 0) || (titleId == DefaultTitleId));
                }

                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = DefaultTitleId;

                    //Write two files. One to the random title Id we're using and one to the default. the query should only return the random one
                    fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, defaultTitleFileName, DefaultTitleId, fileSize, fileTime);
                    string otherTransactionId = WriteTestFile(userXuid, otherTitleFileName, titleId, fileSize, fileTime);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    // Should we list the container and find a file not in the results?
                    FileTableLastUpdateEntry testFileEntry = getBlobsReq.GetFile(userXuid, defaultTitleFileName);
                    SASInfo fileSAS = getBlobsReq.StorageInfo[testFileEntry.StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = titleId.ToString(BlobTableEntry.ContainerBlobFormatString);
                    string storagePath = BlobTableClient.GetStoragePath(testFileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), otherTitleFileName, otherTransactionId);

                    using (Stream fileStream = blobClient.GetBlobAsStream(storagePath))
                    {
                        if ((fileStream == null) || (fileStream.Length == 0))
                        {
                            Global.RO.Success("Unable to download: {0}", storagePath);
                        }
                        else
                        {
                            throw new UnexpectedTestResultException("Successfully read other container when expected to fail.");
                        }
                    }
                }

                public override void PostRun(RUN_TYPE runType)
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, defaultTitleFileName, DefaultTitleId, fileTime);
                    xlfsClient.SafeRemoveFile(userXuid, otherTitleFileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Read a blob from a different container using the SAS returned by GetChangedBlobs.")]
            public class N_GetChangedBlobs_SASUrlListOtherContainer : TestNode
            {
                String defaultTitleFileName;
                String otherTitleFileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    defaultTitleFileName = String.Format("Xlfs_GetChangedBlobs_SASUrlReadOtherContainer_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    otherTitleFileName = String.Format("Xlfs_GetChangedBlobs_SASUrlReadOtherContainer_Other_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    
                    do
                    {
                        titleId = unchecked((uint)RandomEx.GlobalRandGen.Next());
                    }
                    while ((titleId == 0) || (titleId == DefaultTitleId));
                }

                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                    getBlobsReq.TitleId = DefaultTitleId;

                    //Write two files. One to the random title Id we're using and one to the default. the query should only return the random one
                    fileTime = getBlobsReq.StartTime.Value.AddMinutes(10);
                    WriteTestFile(userXuid, defaultTitleFileName, DefaultTitleId, fileSize, fileTime);
                    WriteTestFile(userXuid, otherTitleFileName, titleId, fileSize, fileTime);

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    // Should we list the container and find a file not in the results?
                    FileTableLastUpdateEntry testFileEntry = getBlobsReq.GetFile(userXuid, defaultTitleFileName);
                    SASInfo fileSAS = getBlobsReq.StorageInfo[testFileEntry.StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = titleId.ToString(BlobTableEntry.ContainerBlobFormatString);

                    try
                    {
                        List<string> blobList = blobClient.GetBlobList();
                        Global.RO.Info("Container {0} has {1} blobs", fileSAS.Container, blobList.Count);
                    }
                    catch
                    {
                        // Benran: I don't know what this is for.  Need to figure out if it's required.
                        //Expected failure
                    }
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, defaultTitleFileName, DefaultTitleId, fileTime);
                    xlfsClient.SafeRemoveFile(userXuid, otherTitleFileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Read a blob from a different container using the SAS returned by GetChangedBlobs.")]
            public class N_GetChangedBlobs_SASUrlListContainers : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();

                    ExecutePositiveChangedBlobsReq(getBlobsReq);

                    foreach (SASInfo fileSAS in getBlobsReq.StorageInfo.Values)
                    {
                        BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                        blobClient.BlobContainer = fileSAS.Container;

                        try
                        {
                            List<string> containerList = blobClient.GetContainers();
                            Global.RO.Info("Account {0} has {1} container(s)", fileSAS.StorageAccount, containerList.Count);
                        }
                        catch
                        {
                            //Expected failure
                        }
                    }
                }
            }
        }

        [TestGroup, Description("Functional tests for GetChangedBlobsContinue API")]
        public class GetChangedBlobsContinue_Functional
        {
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Performs a BVT Continue request against the AdminFD.")]
            public class P_GetChangedBlobsContinueBVT : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobs = CreateChangedBlobsContinueReq();

                    ExecutePositiveChangedBlobsContinueReq(getBlobs);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(0), Description("Basic Positive case. Upload One file that should be retrievalbe with the returned SAS.")]
            public class P_GetChangedBlobsContinue : TestNode
            {
                String fileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    fileName = String.Format("Xlfs_GetChangedBlobsContinue_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    titleId = DefaultTitleId;
                }

                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = titleId;

                    fileTime = DateTime.UtcNow.AddMinutes(-5);
                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);

                    if (!VerifyFileUsingContinueResults(getBlobsReq, userXuid, fileName))
                    {
                        throw new UnexpectedTestResultException("File Verification failed.");
                    }
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobsContinue with no TitleId parameter.")]
            public class N_GetChangedBlobsContinue_NoTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = null; // Should fail

                    ExecuteNegativeChangedBlobsContinueReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobsContinue with an invalid TitleId.")]
            public class N_GetChangedBlobsContinue_InvalidTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = null;
                    HttpQueryParameterAttribute titleIdQueryParam = new HttpQueryParameterAttribute("titleid");
                    getBlobsReq.CustomQueryParams.Add(titleIdQueryParam.GenerateParamString("INVALID"));

                    ExecuteNegativeChangedBlobsContinueReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobsContinue with a Zero TitleId.")]
            public class N_GetChangedBlobsContinue_ZeroTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = 0;

                    ExecuteNegativeChangedBlobsContinueReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobsContinue with a One TitleId.")]
            public class P_GetChangedBlobsContinue_OneTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = 0x1;

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobsContinue with a Uint32.MaxValue TitleId.")]
            public class P_GetChangedBlobsContinue_MaxTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = UInt32.MaxValue;

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Call GetChangedBlobsContinue with a Uint32.MaxValue + 1 TitleId.")]
            public class N_GetChangedBlobsContinue_OverMaxTitleId : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = null;
                    UInt64 overMaxTitleId = ((UInt64)UInt32.MaxValue) + 1;
                    HttpQueryParameterAttribute titleIdQueryParam = new HttpQueryParameterAttribute("titleid");
                    getBlobsReq.CustomQueryParams.Add(titleIdQueryParam.GenerateParamString(overMaxTitleId.ToString("X16")));

                    ExecuteNegativeChangedBlobsContinueReq(getBlobsReq, HttpStatusCode.BadRequest);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Call GetChangedBlobsContinue with a Random (non-zero) TitleId.")]
            public class P_GetChangedBlobsContinue_RandomTitleId : TestNode
            {
                String randomTitleFileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    randomTitleFileName = String.Format("Xlfs_GetChangedBlobsContinue_RandomTitleId_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    
                    do
                    {
                        titleId = unchecked((uint)RandomEx.GlobalRandGen.Next());
                    }
                    while ((titleId == 0) || (titleId == DefaultTitleId));
                }

                public override void Run()
                {
                    //Write two files. One to the random title Id we're using and one to the default. the query should only return the random one
                    fileTime = DateTime.UtcNow.AddMinutes(-5);
                    WriteTestFile(userXuid, randomTitleFileName, titleId, fileSize, fileTime);

                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = titleId;

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);

                    if (!VerifyFileUsingContinueResults(getBlobsReq, userXuid, randomTitleFileName))
                    {
                        throw new UnexpectedTestResultException("File Verification failed.");
                    }
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, randomTitleFileName, titleId, fileTime);
                }
            }
        }

        [TestGroup, Description("Tests for GetChangedBlobsContiue API security")]
        public class GetChangedBlobsContinue_Security
        {
            // Depricated now that IP validation is used instead of cert validation
            [TestCase, Owner("benran"), TestCasePriority(2), Description("Calls GetChangedBlobsContinue with no Certificate.")]
            public class N_GetChangedBlobsContinue_NoCertificate : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.RequestCertificate = null;

                    ExecuteNegativeChangedBlobsContinueReq(getBlobsReq, HttpStatusCode.Forbidden);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Calls GetChangedBlobsContinue with an invalid Certificate.")]
            public class N_GetChangedBlobsContinue_InvalidCertificate : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    //All computer stores have a certificate of the computer name. we'll use that since it won't work with the front door
                    string fakeCert = System.Net.Dns.GetHostName();
                    getBlobsReq.RequestCertificate = fakeCert;

                    ExecuteNegativeChangedBlobsContinueReq(getBlobsReq, HttpStatusCode.Unauthorized);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("Read a blob returned in the file list using the SAS returned by GetChangedBlobsContinue.")]
            public class P_GetChangedBlobsContinue_SASUrlRead : TestNode
            {
                String fileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    fileName = String.Format("Xlfs_GetChangedBlobsContinue_SASUrlRead_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    titleId = DefaultTitleId;
                    fileTime = DateTime.UtcNow.AddMinutes(-5);

                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);
                }

                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = titleId;

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);

                    FileTableLastUpdateClient fileClient = new FileTableLastUpdateClient();
                    List<FileTableLastUpdateEntry> fileList = fileClient.SelectFile(userXuid, titleId, fileName);
                    if (fileList.Count == 0)
                        throw new UnexpectedTestResultException("Could not find file in File Table");
                    SASInfo fileSAS = getBlobsReq.StorageInfo[fileList[0].StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = fileSAS.Container;
                    string storagePath = BlobTableClient.GetStoragePath(fileList[0].UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), fileList[0].Filename, fileList[0].TransactionId);
                    using (Stream fileStream = blobClient.GetBlobAsStream(storagePath))
                    {
                        if ((fileStream == null) || (fileStream.Length != fileList[0].Size))
                        {
                            throw new UnexpectedTestResultException(
                                String.Format("Unable to download: {0}", storagePath));
                        }
                    }
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(1), Description("List blobs using the SAS returned by GetChangedBlobsContinue.")]
            public class P_GetChangedBlobsContinue_SASUrlList : TestNode
            {
                String fileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    fileName = String.Format("Xlfs_GetChangedBlobsContinue_SASUrlList_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    titleId = DefaultTitleId;
                    fileTime = DateTime.UtcNow.AddMinutes(-5);

                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);
                }

                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = titleId;

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);

                    foreach (SASInfo fileSAS in getBlobsReq.StorageInfo.Values)
                    {
                        BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                        blobClient.BlobContainer = fileSAS.Container;
                        List<string> dirList = blobClient.GetFolderList();
                        Global.RO.Info("Container {0} has {1} directories", fileSAS.Container, dirList.Count);
                        List<string> blobList = blobClient.GetBlobList(userXuid.ToString(BlobTableEntry.XuidFormatString));
                        Global.RO.Info("Directory {0:X16} has {1} blobs", userXuid, blobList.Count);
                    }
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Write a blob returned in the file list using the SAS returned by GetChangedBlobsContinue.")]
            public class N_GetChangedBlobsContinue_SASUrlWrite : TestNode
            {
                String fileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    fileName = String.Format("Xlfs_GetChangedBlobsContinue_SASUrlRead_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    titleId = DefaultTitleId;
                }

                public override void Run()
                {
                    fileTime = DateTime.UtcNow.AddMinutes(-5);
                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);

                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = titleId;

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);

                    FileTableLastUpdateClient fileClient = new FileTableLastUpdateClient();
                    List<FileTableLastUpdateEntry> fileList = fileClient.SelectFile(userXuid, titleId, fileName);
                    if (fileList.Count == 0)
                        throw new UnexpectedTestResultException("Could not find file in File Table");
                    SASInfo fileSAS = getBlobsReq.StorageInfo[fileList[0].StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = fileSAS.Container;
                    string storagePath = BlobTableClient.GetStoragePath(fileList[0].UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), fileList[0].Filename, fileList[0].TransactionId);
                    byte[] randomBytes = new byte[fileSize];
                    RandomEx.GlobalRandGen.NextBytes(randomBytes);
                    using (MemoryStream memoryStream = new MemoryStream(randomBytes))
                    {
                        Boolean exceptionCaught = false;
                        try
                        {
                            blobClient.PutBlob(storagePath, memoryStream);
                        }
                        catch
                        {
                            exceptionCaught = true;
                        }

                        if (!exceptionCaught)
                        {
                            throw new UnexpectedTestResultException("Write Succeeded using SAS when it should've failed");
                        }
                    }
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Remove a blob returned in the file list using the SAS returned by GetChangedBlobsContinue.")]
            public class N_GetChangedBlobsContinue_SASUrlRemove : TestNode
            {
                String fileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    fileName = String.Format("Xlfs_GetChangedBlobsContinue_SASUrlRemove_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    titleId = DefaultTitleId;
                }

                public override void Run()
                {
                    fileTime = DateTime.UtcNow.AddMinutes(-5);
                    WriteTestFile(userXuid, fileName, titleId, fileSize, fileTime);

                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = titleId;

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);

                    FileTableLastUpdateClient fileClient = new FileTableLastUpdateClient();
                    List<FileTableLastUpdateEntry> fileList = fileClient.SelectFile(userXuid, titleId, fileName);
                    if (fileList.Count == 0)
                        throw new UnexpectedTestResultException("Could not find file in File Table");
                    SASInfo fileSAS = getBlobsReq.StorageInfo[fileList[0].StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = fileSAS.Container;
                    string storagePath = BlobTableClient.GetStoragePath(fileList[0].UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), fileList[0].Filename, fileList[0].TransactionId);

                    if (blobClient.DeleteBlob(storagePath))
                    {
                        throw new UnexpectedTestResultException("Remove Succeeded using SAS when it should've failed");
                    }
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, fileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Read a blob from a different container using the SAS returned by GetChangedBlobsContinue.")]
            public class N_GetChangedBlobsContinue_SASUrlReadOtherContainer : TestNode
            {
                String defaultTitleFileName;
                String otherTitleFileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    defaultTitleFileName = String.Format("Xlfs_GetChangedBlobsContinue_SASUrlReadOtherContainer_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    otherTitleFileName = String.Format("Xlfs_GetChangedBlobsContinue_SASUrlReadOtherContainer_Other_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();
                    
                    do
                    {
                        titleId = unchecked((uint)RandomEx.GlobalRandGen.Next());
                    }
                    while ((titleId == 0) || (titleId == DefaultTitleId));
                }

                public override void Run()
                {                 
                    //Write two files. One to the random title Id we're using and one to the default. the query should only return the random one
                    fileTime = DateTime.UtcNow.AddMinutes(-5);
                    WriteTestFile(userXuid, defaultTitleFileName, DefaultTitleId, fileSize, fileTime);
                    string otherTransactionId = WriteTestFile(userXuid, otherTitleFileName, titleId, fileSize, fileTime);

                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = DefaultTitleId;

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);

                    // Should we list the container and find a file not in the results?
                    FileTableLastUpdateClient fileClient = new FileTableLastUpdateClient();
                    List<FileTableLastUpdateEntry> fileList = fileClient.SelectFile(userXuid, DefaultTitleId, defaultTitleFileName);
                    if (fileList.Count == 0)
                        throw new UnexpectedTestResultException("Could not find file in File Table");
                    SASInfo fileSAS = getBlobsReq.StorageInfo[fileList[0].StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = titleId.ToString(BlobTableEntry.ContainerBlobFormatString);
                    string storagePath = BlobTableClient.GetStoragePath(fileList[0].UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString), otherTitleFileName, otherTransactionId);
                    try
                    {
                        using (Stream fileStream = blobClient.GetBlobAsStream(storagePath))
                        {
                            //If it fails to read the length will be zero
                            if ((fileStream == null) || (fileStream.Length == 0))
                            {
                                Global.RO.Success("Unable to download: {0}", storagePath);
                            }
                            else
                            {
                                throw new UnexpectedTestResultException();
                            }
                        }
                    }
                    catch (UnexpectedTestResultException)
                    {
                        // An unexpected test result should be forwarded on
                        throw;
                    }
                    catch (Exception)
                    {
                        // We don't care about exceptions being thrown for some reason
                    }

                    
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, defaultTitleFileName, DefaultTitleId, fileTime);
                    xlfsClient.SafeRemoveFile(userXuid, otherTitleFileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Read a blob from a different container using the SAS returned by GetChangedBlobsContinue.")]
            public class N_GetChangedBlobsContinue_SASUrlListOtherContainer : TestNode
            {
                String defaultTitleFileName;
                String otherTitleFileName;
                long fileSize;
                ulong userXuid;
                uint titleId;
                DateTime fileTime;

                public override void PreRun()
                {
                    defaultTitleFileName = String.Format("Xlfs_GetChangedBlobsContinue_SASUrlReadOtherContainer_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    otherTitleFileName = String.Format("Xlfs_GetChangedBlobsContinue_SASUrlReadOtherContainer_Other_{0:X}.bin", RandomEx.GlobalRandGen.NextUlong());
                    fileSize = 1024;
                    userXuid = RandomEx.GlobalRandGen.NextPuid();

                    do
                    {
                        titleId = unchecked((uint)RandomEx.GlobalRandGen.Next());
                    }
                    while ((titleId == 0) || (titleId == DefaultTitleId));

                    fileTime = DateTime.UtcNow.AddMinutes(-5);

                    //Write two files. One to the random title Id we're using and one to the default. the query should only return the random one
                    WriteTestFile(userXuid, defaultTitleFileName, DefaultTitleId, fileSize, fileTime);
                    WriteTestFile(userXuid, otherTitleFileName, titleId, fileSize, fileTime);
                }

                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();
                    getBlobsReq.TitleId = DefaultTitleId;

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);

                    // Should we list the container and find a file not in the results?
                    FileTableLastUpdateClient fileClient = new FileTableLastUpdateClient();
                    List<FileTableLastUpdateEntry> fileList = fileClient.SelectFile(userXuid, DefaultTitleId, defaultTitleFileName);
                    if (fileList.Count == 0)
                        throw new UnexpectedTestResultException("Could not find file in File Table");
                    SASInfo fileSAS = getBlobsReq.StorageInfo[fileList[0].StorageAccount];
                    BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                    blobClient.BlobContainer = titleId.ToString(BlobTableEntry.ContainerBlobFormatString);

                    try
                    {
                        List<string> blobList = blobClient.GetBlobList();
                        Global.RO.Info("Container {0} has {1} blobs", fileSAS.Container, blobList.Count);
                    }
                    catch
                    {
                        //Expected failure
                    }
                }

                public override void PostRun()
                {
                    XLFSClient xlfsClient = new XLFSClient();
                    xlfsClient.SafeRemoveFile(userXuid, defaultTitleFileName, DefaultTitleId, fileTime);
                    xlfsClient.SafeRemoveFile(userXuid, otherTitleFileName, titleId, fileTime);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Read a blob from a different container using the SAS returned by GetChangedBlobsContinue.")]
            public class N_GetChangedBlobsContinue_SASUrlListContainers : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobsContinue getBlobsReq = CreateChangedBlobsContinueReq();

                    ExecutePositiveChangedBlobsContinueReq(getBlobsReq);

                    foreach (SASInfo fileSAS in getBlobsReq.StorageInfo.Values)
                    {
                        BlobClient blobClient = new BlobClient(fileSAS.Signature, fileSAS.StorageUri.AbsoluteUri);
                        blobClient.BlobContainer = fileSAS.Container;

                        try
                        {
                            List<string> containerList = blobClient.GetContainers();
                            Global.RO.Info("Account {0} has {1} container(s)", fileSAS.StorageAccount, containerList.Count);
                        }
                        catch
                        {
                            //Expected failure
                        }
                    }
                }
            }
        }

        [TestGroup, Description("Functional tests for GetStorageAccount API")]
        public class GetStorageAccount
        {
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Basic Positive case. Should execute and return the storage account that we added.")]
            public class P_GetStorageAccountBVT : TestNode
            {
                public override void Run()
                {
                    //  Add a storage account entry for this test.
                    StorageAccountTableEntry entry = new StorageAccountTableEntry();
                    entry.PartitionKey = "GetStorageAccountBVTAccount";
                    entry.RowKey = "";
                    entry.Key = Convert.ToBase64String(new byte[] { 0x00 });
                    entry.Capacity = 1000;
                    entry.Threshold = 800;
                    entry.Used = 0;

                    StorageAccountTableClient storageAccountTableClient = new StorageAccountTableClient();
                    storageAccountTableClient.AddStorageAccountTableEntry(entry);

                    try
                    {
                        XlfsAdminGetStorageAccount getStorageAccount = CreateGetStorageAccountReq();
                        getStorageAccount.StorageAccountName = entry.PartitionKey;
                        ExecutePositiveGetStorageAccountReq(getStorageAccount);
                    }
                    finally
                    {
                        // Cleanup
                        storageAccountTableClient.DeleteStorageAccountTableEntry(entry);
                    }
                }
            }
        }

        [TestGroup, Description("Functional tests for PutStorageAccount API")]
        public class PutStorageAccount
        {
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Basic Positive case. Should add a storage account, and then update it.")]
            public class P_PutStorageAccountBVT : TestNode
            {
                StorageAccountTableClient storageAccountTableClient;
                List<StorageAccountTableEntry> entries;
                StorageAccountTableEntry entry;

                public override void PreRun()
                {
                    storageAccountTableClient = new StorageAccountTableClient();

                    entry = new StorageAccountTableEntry();
                    entry.PartitionKey = "PutStorageAccountBVTAccount";
                    entry.RowKey = "";
                    entry.Key = Convert.ToBase64String(RandomEx.GlobalRandGen.GenerateRandomBlob(16));
                    entry.Capacity = XlfsTests.OneTeraByte * 1000;
                    entry.Threshold = XlfsTests.OneTeraByte * 800;
                    entry.Used = 0;

                    //  Make sure the storage account doesn't exist first.
                    entries = storageAccountTableClient.SelectStorageAccount(entry.PartitionKey);
                    if (entries.Count != 0)
                    {
                        storageAccountTableClient.DeleteStorageAccountTableEntry(entries[0]);
                    }
                }

                public override void Run()
                {
                    //  Add a storage account entry for this test.
                    XlfsAdminPutStorageAccount putStorageAccount = CreatePutStorageAccountReq();
                    putStorageAccount.StorageAccount = entry;
                    ExecutePositivePutStorageAccountReq(putStorageAccount);

                    // Verify that it was added.
                    entries = storageAccountTableClient.SelectStorageAccount(entry.PartitionKey);
                    if (entries.Count != 1)
                    {
                        throw new UnexpectedTestResultException(
                            "Wrong number of storage accounts returned.  Expected 1, got back " + entries.Count);
                    }

                    if (!entry.Equals(entries[0]))
                    {
                        throw new UnexpectedTestResultException(
                            "Storage information returned did not match the information added.");
                    }

                    // Now update the entry and make sure the changes were taken.
                    entry.Key = Convert.ToBase64String(RandomEx.GlobalRandGen.GenerateRandomBlob(16));
                    entry.Capacity = XlfsTests.OneTeraByte * 5;
                    entry.Threshold = XlfsTests.OneTeraByte * 4;
                    entry.Used = 0;

                    putStorageAccount.StorageAccount = entry;
                    ExecutePositivePutStorageAccountReq(putStorageAccount);

                    entries =
                        storageAccountTableClient.SelectStorageAccount(entry.PartitionKey);
                    if (entries.Count != 1)
                    {
                        throw new UnexpectedTestResultException(
                            "Wrong number of storage accounts returned.  Expected 1, got back " + entries.Count);
                    }

                    if (!entry.Equals(entries[0]))
                    {
                        throw new UnexpectedTestResultException(
                            "Storage information returned did not match the information added.");
                    }
                }

                public override void PostRun()
                {
                    // Cleanup
                    entries = storageAccountTableClient.SelectStorageAccount(entry.PartitionKey);
                    if (entries.Count != 0)
                    {
                        storageAccountTableClient.DeleteStorageAccountTableEntry(entries[0]);
                    }
                }
            }
        }

        [TestGroup, Description("Functional to ensure the AdminFD handles multiple storage accounts properly")]
        public class MultipleStorageAccounts
        {
            [TestCase, Owner("benran"), TestCasePriority(1), Description("Checks that all valid storage accounts are returned by GetChangedBlobs")]
            public class P_AllStorageAccountsReturned : TestNode
            {
                public override void Run()
                {
                    XlfsAdminGetChangedBlobs getBlobs = CreateChangedBlobsReq();
                    // Just minimize the probability that we get any files, all 
                    // storage account info should be returned anyway.
                    getBlobs.EndTime = getBlobs.StartTime.Value.AddMilliseconds(1);

                    ExecutePositiveChangedBlobsReq(getBlobs);
                    if (getBlobs.Files.Count > 0)
                    {
                        Global.RO.Warn("More files found in XlfsAdminGetChangedBlobs file list than expected: {0}", getBlobs.Files.Count);
                    }

                    StorageAccountTableClient storageAccountTableClient = new StorageAccountTableClient();
                    List<StorageAccountTableEntry> storageAccountListFromTable = storageAccountTableClient.Select();

                    foreach (StorageAccountTableEntry entry in storageAccountListFromTable)
                    {
                        // Quick and dirty
                        Boolean shouldContainKey = entry.Used < entry.Threshold && entry.Threshold < entry.Capacity;

                        if (getBlobs.StorageInfo.ContainsKey(entry.PartitionKey) != shouldContainKey)
                        {
                            String message = String.Format(
                                "SAS info for account {0} was {1} expected", 
                                entry.PartitionKey,
                                shouldContainKey ? "not found when" : "found when not");

                            throw new UnexpectedTestResultException(message);
                        }
                    }

                }
            }
        }

        [TestGroup, Description("Functional tests for GetChangedBlobs API")]
        public class Performance
        {
            //Perf Test Vars
            protected static bool OneTimePreRunCompleted = false;
            protected static DateTime TestStartTime = new DateTime(2010, 1, 1, 1, 0, 0, DateTimeKind.Utc);
            protected static DateTime CurrentBlockTime = TestStartTime;
            protected static int CurrentTableSize = 0;
            protected static int PerfBlockSize = 500;
            protected static int PerfBlocksPerDay = 2;
            protected static int PerfMeasurementSize = 1000;
            protected static int PerfMeasurementIterations = 5;
            protected static int PerfDBWriteTimeout = 900;
            protected static string PerfLogFileName = "GetChangedBlobsPerf";

            //Common PreRun for Performance Tests
            protected static void OneTimePreRun()
            {
                GetPerfVariables();
                FileTableLastUpdateClient fileClient = new FileTableLastUpdateClient();
                DateTime oldest, newest;
                CurrentTableSize = fileClient.SelectCount(new DateTime(2010, 1, 1, 1, 0, 0, DateTimeKind.Utc), out oldest, out newest);
                TestStartTime = new DateTime(oldest.Year, oldest.Month, oldest.Day, oldest.Hour, 0, 0, oldest.Kind);
                CurrentBlockTime = new DateTime(newest.Year, newest.Month, newest.Day, newest.Hour, 0, 0, newest.Kind);
                if ((newest.Minute != 0) || (newest.Second != 0) || (newest.Millisecond != 0))
                {
                    CurrentBlockTime = CurrentBlockTime.AddHours(1);
                    Global.RO.Debug("Newest time is not on an hour boundary: {0}, setting CurrentBlockTime to {1}.", newest, CurrentBlockTime);
                }
                OneTimePreRunCompleted = true;
                Global.RO.Debug("Current Table Size: {0} - Oldest: {1} - Newest: {2}", CurrentTableSize, TestStartTime, CurrentBlockTime);
            }

            protected static void GetPerfVariables()
            {
                XmlNodeList xlfsNodeList = Global.Config.GetElementsByTagName("xlfsPerf");
                if (xlfsNodeList.Count > 0)
                {
                    XmlNode xlfsNode = xlfsNodeList[0];

                    try { PerfBlockSize = Int32.Parse(xlfsNode.Attributes["blockSize"].Value); }
                    catch { PerfBlockSize = 500; }
                    try { PerfBlocksPerDay = Int32.Parse(xlfsNode.Attributes["blocksPerDay"].Value); }
                    catch { PerfBlocksPerDay = 2; }
                    try { PerfMeasurementSize = Int32.Parse(xlfsNode.Attributes["measurementSize"].Value); }
                    catch { PerfMeasurementSize = 1000; }
                    try { PerfMeasurementIterations = Int32.Parse(xlfsNode.Attributes["measurementIterations"].Value); }
                    catch { PerfMeasurementIterations = 5; }
                    try { PerfDBWriteTimeout = Int32.Parse(xlfsNode.Attributes["dbWriteTimeout"].Value); }
                    catch { PerfDBWriteTimeout = 900; }

                }
            }

            protected static string FormatMetricsString(int tableSize, int querySize, TimeSpan executionTime)
            {
                StringBuilder outputString = new StringBuilder();

                //Global.RO.Info("TableSize\tQuerySize\tTime");
                outputString.AppendFormat("{0}\t{1}\t{2}", tableSize, querySize, executionTime);

                return outputString.ToString();
            }

            protected static void PrintResults(ref Dictionary<int, List<TimeSpan>> timeResultsTable, ref Dictionary<int, List<int>> countResultsTable)
            {
                StringBuilder rowString = new StringBuilder("Size\t");
                for (int resultIter = 1; resultIter <= PerfMeasurementIterations; resultIter++)
                {
                    rowString.AppendFormat("Time{0}\t\t\t", resultIter);
                }
                Global.RO.Info("{0}", rowString.ToString());
                try
                {
                    string timeFileName = String.Format("{0}_time.log", PerfLogFileName);
                    using (StreamWriter fileStream = File.AppendText(timeFileName))
                    {
                        foreach (int tableSize in timeResultsTable.Keys)
                        {
                            List<TimeSpan> timeResults = timeResultsTable[tableSize];
                            rowString = new StringBuilder(tableSize.ToString());
                            foreach (TimeSpan resultValue in timeResults)
                            {
                                rowString.AppendFormat("\t{0}", resultValue);
                            }
                            Global.RO.Info(rowString.ToString());
                            fileStream.WriteLine("{0}", rowString.ToString());
                        }
                    }
                    //Clear the table if we were able to dump it to a file
                    timeResultsTable = new Dictionary<int, List<TimeSpan>>();
                }
                catch
                {
                    foreach (int tableSize in timeResultsTable.Keys)
                    {
                        List<TimeSpan> timeResults = timeResultsTable[tableSize];
                        rowString = new StringBuilder(tableSize.ToString());
                        foreach (TimeSpan resultValue in timeResults)
                        {
                            rowString.AppendFormat("\t{0}", resultValue);
                        }
                        Global.RO.Info(rowString.ToString());
                    }
                }

                rowString = new StringBuilder("Size\t");
                for (int resultIter = 1; resultIter <= PerfMeasurementIterations; resultIter++)
                {
                    rowString.AppendFormat("Count{0}\t", resultIter);
                }
                Global.RO.Info("{0}", rowString.ToString());
                try
                {
                    string timeFileName = String.Format("{0}_count.log", PerfLogFileName);
                    using (StreamWriter fileStream = File.AppendText(timeFileName))
                    {
                        foreach (int tableSize in countResultsTable.Keys)
                        {
                            List<int> countResults = countResultsTable[tableSize];
                            rowString = new StringBuilder(tableSize.ToString());
                            foreach (int resultValue in countResults)
                            {
                                rowString.AppendFormat("\t{0}", resultValue);
                            }
                            Global.RO.Info(rowString.ToString());
                            fileStream.WriteLine("{0}", rowString.ToString());
                        }
                    }
                    //Clear the table if we were able to dump it to a file
                    countResultsTable = new Dictionary<int, List<int>>();
                }
                catch
                {
                    foreach (int tableSize in countResultsTable.Keys)
                    {
                        List<int> countResults = countResultsTable[tableSize];
                        rowString = new StringBuilder(tableSize.ToString());
                        foreach (int resultValue in countResults)
                        {
                            rowString.AppendFormat("\t{0}", resultValue);
                        }
                        Global.RO.Info(rowString.ToString());
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(3), Description("Performance measurements of the GetChangedBlobsAPI."), EnvRequirement("Manual"), TestFrequency("Regression")]
            public class GetChangedBlobs_PerformanceTest : TestNode
            {
                static Dictionary<int, List<TimeSpan>> TimeResultsTable;
                static Dictionary<int, List<int>> CountResultsTable;

                public override void PreRun()
                {
                    base.PreRun();
                    if (TimeResultsTable == null)
                        TimeResultsTable = new Dictionary<int, List<TimeSpan>>();
                    if (CountResultsTable == null)
                        CountResultsTable = new Dictionary<int, List<int>>();
                    if (OneTimePreRunCompleted == false)
                    {
                        OneTimePreRun();
                    }
                }

                public override void Run()
                {
                    Boolean testFailed = false;
                    int hoursPerBlock = 24 / PerfBlocksPerDay;
                    uint titleId = DefaultTitleId;

                    FileTableLastUpdateClient fileClient = new FileTableLastUpdateClient();
                    fileClient.CreateIfNotExist();

                    try
                    {
                        Global.RO.Info("TableSize\tQuerySize\tTime");
                        Global.RO.Info("--------------------------------------------------");
                        //FileTable Loop

                        //-------------Add daily entries-----------
                        //Per Day loop (break down the entries into hour blocks to for query size)
                        XlfsTestWriteFileEntries writeEntriesReq = new XlfsTestWriteFileEntries();
                        writeEntriesReq.TitleId = titleId;
                        writeEntriesReq.StartTime = CurrentBlockTime;
                        writeEntriesReq.EndTime = writeEntriesReq.StartTime.Value.AddHours(hoursPerBlock);
                        writeEntriesReq.UserXuid = null;
                        writeEntriesReq.FileCount = (uint)PerfBlockSize;
                        if (writeEntriesReq.Execute())
                        {
                            CurrentBlockTime = CurrentBlockTime.AddHours(hoursPerBlock);
                            //Poll and wait for it to complete
                            if (writeEntriesReq.WaitForComplete(PerfDBWriteTimeout) == false)
                            {
                                Global.RO.Error("Batch Create Files not complete after {0} seconds.", PerfDBWriteTimeout);
                                testFailed = true;
                                DateTime oldest, newest;
                                CurrentTableSize = fileClient.SelectCount(TestStartTime, out oldest, out newest);
                                //TestStartTime = new DateTime(oldest.Year, oldest.Month, oldest.Day, oldest.Hour, 0, 0, oldest.Kind);
                                CurrentBlockTime = new DateTime(newest.Year, newest.Month, newest.Day, newest.Hour, 0, 0, newest.Kind);
                                if ((newest.Minute != 0) || (newest.Second != 0) || (newest.Millisecond != 0))
                                {
                                    CurrentBlockTime = CurrentBlockTime.AddHours(1);
                                    Global.RO.Debug("newest time is {0}, setting CurrentBlockTime to {1}.", newest, CurrentBlockTime);
                                }
                                Global.RO.Error("New table size {0}.", CurrentTableSize);
                                throw new UnexpectedTestResultException();
                            }
                            else
                            {
                                CurrentTableSize += PerfBlockSize;
                            }
                        }
                        else
                        {
                            Global.RO.Error("Could not Batch Create Files: {0}", writeEntriesReq.RequestException);
                            throw new UnexpectedTestResultException();
                        }

                        //-------------Measure Performance----------
                        //get the number of blocks to measure
                        // measurementSize / blockSize
                        int blockCount = PerfMeasurementSize / PerfBlockSize;
                        //Calculate the number of hours to query
                        // number of blocks * hoursPerBlock
                        int hourCount = blockCount * hoursPerBlock;
                        int totalHours = (int)(CurrentBlockTime - TestStartTime).TotalHours;

                        List<TimeSpan> timeResults = new List<TimeSpan>();
                        List<int> countResults = new List<int>();
                        for (int measurementLoop = 1; measurementLoop <= PerfMeasurementIterations; measurementLoop++)
                        {
                            //We need a number of hours to random in but want to make sure there's still time to get our full query
                            //i.e. random between 0 + hourCount and totalHours
                            int randomHourShift = 0;
                            if (totalHours != 0)
                                randomHourShift = RandomEx.GlobalRandGen.Next() % totalHours;

                            XlfsAdminGetChangedBlobs getBlobsReq = CreateChangedBlobsReq();
                            getBlobsReq.TitleId = titleId;
                            getBlobsReq.StartTime = TestStartTime.AddHours(randomHourShift);
                            getBlobsReq.EndTime = getBlobsReq.StartTime.Value.AddHours(hourCount);
                            //Global.RO.Debug("CurrentBlock: {0}, ReqStart: {1}, ReqEnd: {2}", CurrentBlockTime, getBlobsReq.StartTime.Value, getBlobsReq.EndTime.Value);

                            DateTime executeStartTime = DateTime.Now;
                            try
                            {
                                if (!getBlobsReq.Execute())
                                {
                                    TimeSpan executionTime = DateTime.Now - executeStartTime;
                                    Global.RO.Warn("{0} - Request failed - {1}", FormatMetricsString(CurrentTableSize, PerfMeasurementSize, executionTime), getBlobsReq.HttpStatus);
                                    testFailed = true;
                                }
                                else
                                {
                                    TimeSpan executionTime = DateTime.Now - executeStartTime;
                                    //Get Performance metrics and log them
                                    Global.RO.Info("{0}", FormatMetricsString(CurrentTableSize, getBlobsReq.Files.Count, executionTime));
                                    timeResults.Add(executionTime);
                                    countResults.Add(getBlobsReq.Files.Count);
                                }
                            }
                            catch
                            {
                                TimeSpan executionTime = DateTime.Now - executeStartTime;
                                //Check if it timed out
                                Global.RO.Error("{0} - Request threw exception", FormatMetricsString(CurrentTableSize, PerfMeasurementSize, executionTime));
                                testFailed = true;
                            }
                        }

                        if (TimeResultsTable.Keys.Contains(CurrentTableSize) == true)
                            TimeResultsTable[CurrentTableSize] = timeResults;
                        else
                            TimeResultsTable.Add(CurrentTableSize, timeResults);
                        if (CountResultsTable.Keys.Contains(CurrentTableSize) == true)
                            CountResultsTable[CurrentTableSize] = countResults;
                        else
                            CountResultsTable.Add(CurrentTableSize, countResults);
                        Global.RO.Info("--------------------------------------------------");
                    }
                    catch (Exception ex)
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Global Exception Caught. Ex: {0}", ex));
                    }
                    finally
                    {
                        //Print Results
                        PrintResults(ref TimeResultsTable, ref CountResultsTable);
                    }

                    if (testFailed)
                    {
                        throw new UnexpectedTestResultException("GetChangedBlobs Performance Test failed.  See output for more information.");
                    }
                }
            }

            //// DO NOT RUN this case in a normal scenario. It is only used to clear up storage after a stress run or Performance test run.
            //[TestCase, Owner("benran"), TestCasePriority(3), Description("Clear existing storage for the Performance measurements of the GetChangedBlobsAPI."), EnvRequirement("Manual")]
            //public class GetChangedBlobs_PerformanceTestClearStorage : TestNode
            //{
            //    public override void Run()
            //    {
            //        TEST_RESULTS testResult = TEST_RESULTS.PASSED;
            //        XLFSClient xlfsClient = new XLFSClient();
            //        xlfsClient.ClearStorage();

            //        return testResult;
            //    }
            //}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\Tools\Decrypter.cs ===
using System;
using ServerTestFramework;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;
using System.Xml;
using System.Xml.Linq;
using System.Security.Cryptography.X509Certificates;

namespace Xlfs.Test
{
    public class DecrypterTestHelper
    {
        public static readonly String XlfsDecrypterPath = @".\XlfsDecryptor.exe";
        public static readonly String XlfsEncryptionCertPath = @".\SuitesData\Xlfs\XlfsTestEncryption.pfx";
        public static readonly String XlfsEncryptionCertPassword = "XblRocks!";
        public static readonly String XlfsEncryptionCertSerial = "kPwA+eJafoVEXwG+E4R9Vg==";

        public String InputFile { get; set; }
        public String OutputFile { get; set; }
        public Byte[] SerialNumber { get; set; }
        public Int32? BlockSize { get; set; }
        public Int32? BlockStart { get; set; }

        public Boolean DeleteOutput { get; set; }

        public String Arguments
        {
            get
            {
                // Build arguments string
                StringBuilder sb = new StringBuilder();

                if (InputFile != null)
                {
                    sb.AppendFormat("-input {0} ", InputFile);
                }

                if (OutputFile != null)
                {
                    sb.AppendFormat("-output {0} ", OutputFile);
                }

                if (SerialNumber != null)
                {
                    sb.AppendFormat("-serial {0} ", BitConverter.ToString(SerialNumber).Replace("-", ""));
                }

                if (BlockSize.HasValue)
                {
                    sb.AppendFormat("-blocksize {0} ", BlockSize.Value);
                }

                if (BlockStart.HasValue)
                {
                    sb.AppendFormat("-blockstart {0} ", BlockStart.Value);
                }

                return sb.ToString();
            }
        }

        public DecrypterTestHelper(String inputFile) : this(inputFile, GetOutputFile(inputFile)) { }

        public DecrypterTestHelper(String inputFile, String outputFile)
        {
            InputFile = inputFile;
            OutputFile = outputFile;

            SerialNumber = null;
            BlockSize = null;
            BlockStart = null;

            DeleteOutput = true;
        }

        public void PreRun()
        {
            ValueCheck.IsTrue(File.Exists(InputFile), "InputFile does not exist");

            if (DeleteOutput && File.Exists(OutputFile))
            {
                File.Delete(OutputFile);
            }
        }

        public void Execute()
        {
            Execute(0);
        }

        public void Execute(DecrypterErrorValue expectedError)
        {
            Execute((Int32)expectedError);
        }

        public void Execute(Int32 expectedResult)
        {
            Int32 result = RunDecrypterWithArguments(Arguments);

            ValueCheck.Test<Int32, Int32>("XlfsDecrypter Return Code", expectedResult, result);
            Global.RO.Success("Got expected return code: " + result);

            if (expectedResult == 0)
            {
                ValueCheck.IsTrue(File.Exists(OutputFile), "Decrypted File Exists");
                Global.RO.Success("Output file exists: " + OutputFile);
            }
        }

        public void WriteMetadata()
        {
            XDocument metadataDoc = new XDocument(
                new XElement("Metadata",
                    new XElement("blocksize", BlockSize),
                    new XElement("blockstart", BlockStart),
                    new XElement("sessionkey", "kArBu0sDNGbBvNg2utNfjIM7QqJ1s5r2GeSJrc7GtnqnuF9jJMTgY3KQr0ItAFVqQnhRTlNmeadEUDa/J2UqgMNCj0H8G50jRzeJBn/FPruRgTXoGzeYpVXCkv5dGJSSsY291Oe0JuFr5DJr3yJ9twRGo6FZTrlWAUpfwh6Tj6ffaJsUVE3rKOdoMXOUFQXCyQiOaQ+XSX94yVUFBHwsH7w/J091znhKaKRI3v4U3azCaC8wrEyiI6VNkObQ5G2BxZF7mdKYO1Hl+D8KnXIOxEyXGb9cyPH6sEp/V5siYwSdDjwXUCCvEkLHBsPKTUm4J1szeR2QBgqb+UKhfAEJVA=="),
                    new XElement("certserial", XlfsEncryptionCertSerial)
                    )
                );

            using (XmlWriter writer = XmlWriter.Create(InputFile + ".metadata"))
            {
                metadataDoc.WriteTo(writer);
                writer.Flush();
                writer.Close();
            }
        }

        public static String GetOutputFile(String inputFile)
        {
            return Path.ChangeExtension(inputFile, "decrypted" + Path.GetExtension(inputFile));
        }

        public static Int32 RunDecrypterWithArguments(String arguments)
        {
            String output = "";
            Process decryptProc = new Process();
            decryptProc.StartInfo = new ProcessStartInfo(XlfsDecrypterPath, arguments);
            decryptProc.StartInfo.UseShellExecute = false;
            decryptProc.StartInfo.CreateNoWindow = true;
            decryptProc.StartInfo.RedirectStandardOutput = true;
            //decryptProc.StartInfo.RedirectStandardError = true;

            Global.RO.Info("Running XLFS Decrypter.");
            Global.RO.Debug("Arguments: " + arguments);

            if (!decryptProc.Start())
            {
                output = decryptProc.StandardOutput.ReadToEnd();
                throw new UnexpectedTestResultException("Unable to start XlfsDecrypter. " + output);
            }

            output = decryptProc.StandardOutput.ReadToEnd();
            Global.RO.Info(output.Trim());

            if (!decryptProc.HasExited)
            {
                decryptProc.WaitForExit(5000);
                if (!decryptProc.HasExited)
                {
                    decryptProc.Kill();
                }
            }

            return decryptProc.ExitCode;
        }
    }

    // Copied from decrypter code
    public enum DecrypterErrorValue
    {
        BadCommandLine = 1,
        FileNotFound = 2,
        CertificateError = 3,
        SerialNumberError = 4,
        CryptoError = 5,
        XmlError = 6,
    }

    /// <summary>
    /// This class contains a number of test cases to ensure that the command line
    /// decryption tool for encrypted data stored in Azure is functionally correct.
    /// This depends on their being some encrypted data loaded into the cloud that
    /// can be properly downloaded and decrypted by the client, and that the 
    /// decryption tool is placed in the same location as STFGui.exe.
    /// </summary>
    [TestGroup, Owner("BenRan"), TestFrequency("Regression"), Description("Tests for the command line XLFS file decrypter")]
    public class FileDecrypter : TestNode
    {
        public override void OneTimeSetup()
        {
            if (!File.Exists(DecrypterTestHelper.XlfsDecrypterPath))
            {
                throw new UnexpectedTestResultException("The decrypter executable does not exist at " +
                    DecrypterTestHelper.XlfsDecrypterPath + ", these tests will be unable to run.");
            }

            // Make sure the certificate to decrypt the testdata is installed
            if (!File.Exists(DecrypterTestHelper.XlfsEncryptionCertPath))
            {
                throw new UnexpectedTestResultException("Unable to find certificate file " +
                   DecrypterTestHelper.XlfsEncryptionCertPath + ". These tests will be unable to run.");
            }

            X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadWrite);
            X509Certificate2 decryptionCert = new X509Certificate2(DecrypterTestHelper.XlfsEncryptionCertPath, DecrypterTestHelper.XlfsEncryptionCertPassword, 
                X509KeyStorageFlags.DefaultKeySet | X509KeyStorageFlags.Exportable | X509KeyStorageFlags.PersistKeySet);
            if(!store.Certificates.Contains(decryptionCert))
            {
                Global.RO.Info("Adding certificate {0} to user cert store.", decryptionCert.Subject);
                store.Add(decryptionCert);
            }
            store.Close();
        }

        [TestCase, TestCasePriority(0), Description("Run the decrypter on a single piece of data")]
        public class P_DecryptBVT : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted.txt");

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, TestCasePriority(1), Description("Verify that the output file is overwritten if it exists")]
        public class P_DecryptOverwriteOutput : TestNode
        {
            public static String DefaultFileContent = "__OVERWRITE_ME_TEST_DATA__";
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted.txt");

            public override void OneTimeSetup()
            {
                helper.OutputFile = @".\SuitesData\Xlfs\OverwriteOutput.decrypted.txt";
            }

            public override void PreRun()
            {
                // This will delete the existing output
                helper.PreRun();

                // Then we create a known file in it's place
                File.WriteAllText(helper.OutputFile, DefaultFileContent);
            }

            public override void Run()
            {
                helper.Execute();

                // Ensure that the file data is not what we made it before
                ValueCheck.IsFalse(File.ReadAllText(helper.OutputFile).Contains(DefaultFileContent), "File not properly overwritten");
                Global.RO.Success("Output file properly overwritten.");
            }
        }

        [TestCase, TestCasePriority(2), Description("Run the decrypter without providing an input filename")]
        public class N_NoInputFilename : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(null);

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.BadCommandLine);
            }
        }

        [TestCase, TestCasePriority(2), Description("Run the decrypter without providing an output filename")]
        public class N_NoOutputFilename : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted.txt");

            public override void OneTimeSetup()
            {
                helper.OutputFile = null;
            }

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.BadCommandLine);
            }
        }

        [TestCase, TestCasePriority(2), Description("Run the decrypter with an non-existant input file")]
        public class N_InputFileMissing : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\NonExistantFile.txt");

            public override void PreRun()
            {
                // Skip the pre-run because we already know the file doesn't exist
                //helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.FileNotFound);
            }
        }

        [TestCase, TestCasePriority(2), Description("Run the decrypter on a file with missing metadata")]
        public class N_MetadataFileMissing : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted_NoMetadata.txt");

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.FileNotFound);
            }
        }

        [TestCase, TestCasePriority(2), Description("Run the decrypter on a file with invalid metadata")]
        public class N_InvalidMetadataFile : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted_InvalidMetadata.txt");

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.XmlError);
            }
        }

        [TestCase, TestCasePriority(2), Description("Run the decrypter on a file with an invalid serial number in the metadata")]
        public class N_InvalidSerialNumber : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted_InvalidSerial.txt");

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.XmlError);
            }


        }

        [TestCase, TestCasePriority(1), Description("Verifies that the serial number command line parameter is used for decryption")]
        public class P_OverrideSerialNumber : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted_InvalidSerial.txt");

            public override void OneTimeSetup()
            {
                helper.SerialNumber = Convert.FromBase64String(DecrypterTestHelper.XlfsEncryptionCertSerial);
            }

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, TestCasePriority(2), Description("Run the decrypter on a file with an invalid block size in the metadata")]
        public class N_InvalidBlockSize : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted_InvalidBlockSize.txt");

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.XmlError);
            }
        }

        [TestCase, TestCasePriority(1), Description("Verifies that the block size command line parameter is used for decryption")]
        public class P_OverrideBlockSize : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted_InvalidBlockSize.txt");

            public override void PreRun()
            {
                helper.BlockSize = 4194304;
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, TestCasePriority(2), Description("Run the decrypter on a file with an invalid block start in the metadata")]
        public class N_InvalidBlockStart : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted_InvalidBlockStart.txt");

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.XmlError);
            }
        }

        [TestCase, TestCasePriority(1), Description("Verifies that the block start command line parameter is used for decryption")]
        public class P_OverrideBlockStart : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted_InvalidBlockStart.txt");

            public override void PreRun()
            {
                helper.BlockStart = 00000001;
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, TestCasePriority(2), Description("What happens if there are two certificates in the cert store with the same serial number.  Unlikely, but possible")]
        [Ignore("Don't have any certs that can be used for this test yet.")]
        public class N_MultipleCertsWithSameSerial : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\");

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
            }
        }

        [TestCase, TestCasePriority(2), Description("Verifies that decryption fails if a valid serial number is provided but no certificate exists with that serial number.")]
        public class N_MissingCertificate : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted.txt");

            public override void OneTimeSetup()
            {
                // This is a valid Base64 encoded serial number (10, 10, 10, etc.)
                // For a certificate that does not exist.
                helper.SerialNumber = Convert.FromBase64String("CgoKCgoKCgoKCgo=");
            }

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.CertificateError);
            }
        }

        [TestCase, TestCasePriority(2), Description("Verifies that decryption fails if a serial number for the wrong certificate is provided.")]
        public class N_WrongCertificate : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted.txt");

            public override void OneTimeSetup()
            {
                X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
                store.Open(System.Security.Cryptography.X509Certificates.OpenFlags.ReadOnly);

                Byte[] metadataSerial = Convert.FromBase64String(DecrypterTestHelper.XlfsEncryptionCertSerial);
                Byte[] serial = null;

                bool serialsMatch;
                do
                {
                    serialsMatch = false;
                    // Pick a random cert
                    X509Certificate2 cert = store.Certificates[RandomEx.GlobalRandGen.Next(0, store.Certificates.Count - 1)];

                    serial = new byte[cert.SerialNumber.Length / 2];
                    for (int i = 0; i < cert.SerialNumber.Length; i += 2)
                    {
                        serial[i / 2] = Convert.ToByte(cert.SerialNumber.Substring(i, 2), 16);
                    }

                    if (serial.Length == metadataSerial.Length)
                    {
                        serialsMatch = true;
                        for (int i = 0; i < serial.Length; i++)
                        {
                            if (serial[i] != metadataSerial[i])
                            {
                                serialsMatch = false;
                                break;
                            }
                        }
                    }
                } while (serialsMatch);

                helper.SerialNumber = serial;
            }

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.CryptoError);
            }
        }

        [TestCase, TestCasePriority(2), Description("Run the decrypter on a file with an invalid encrypted session key in the metadata")]
        public class N_InvalidEncryptedSessionKey : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted_InvalidSessionKey.txt");

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute(DecrypterErrorValue.CryptoError);
            }
        }

        [TestCase, TestCasePriority(1), Description("Run the decrypter on a tiny file")]
        public class P_DecryptTinyFile_1KB : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\EncryptedTinyFile.txt");

            public override void PreRun()
            {
                // Create a big file
                using (FileStream file = File.OpenWrite(helper.InputFile))
                {
                    // We need a random file that's a 'valid' encrypted file, so we use a bigger
                    // encrypted file, and just take the last 1KB of it.  We need the last part
                    // because there is padding on the end which must be maintained so that it 
                    // can be properly decrypted
                    Int32 length = 1024;
                    Byte[] bytes = File.ReadAllBytes(@".\SuitesData\Xlfs\SimpleEncrypted.txt");

                    file.Write(bytes, bytes.Length - length, length);
                    file.Flush();
                    file.Close();
                }

                // Create a metadata file
                helper.BlockSize = 256; // 256B Block Size
                helper.BlockStart = 00000001; // I dunno what this is
                helper.WriteMetadata();

                // Generate a file
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                // Let's delete the file for now
                File.Delete(helper.InputFile);
                File.Delete(helper.OutputFile);
                File.Delete(helper.InputFile + ".metadata");
            }
        }

        [TestCase, TestCasePriority(1), Description("Run the decrypter on a large file")]
        public class P_DecryptLargeFile_100MB : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\EncryptedLargeFile.txt");

            public override void PreRun()
            {
                // Create a big file
                using (FileStream file = File.OpenWrite(helper.InputFile))
                {
                    //Int32 length = 100*1024*1024;
                    //Int32 written = 0;
                    //file.Write(RandomEx.GlobalRandGen.GenerateRandomBlob(length), 0, length);
                    Byte[] bytes = File.ReadAllBytes(@".\SuitesData\Xlfs\SimpleEncrypted.txt");
                    for (int i = 0; i < 10; i++)
                    {
                        // 10 * 10 is 100 MB
                        file.Write(bytes, 0, bytes.Length);
                    }
                    file.Flush();
                    file.Close();
                }

                // Create a metadata file
                helper.BlockSize = 4 * 1024 * 1024; // 4MB Block Size
                helper.BlockStart = 00000001; // I dunno what this is
                helper.WriteMetadata();

                // Generate a file
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                // Let's delete the file for now
                File.Delete(helper.InputFile);
                File.Delete(helper.OutputFile);
                File.Delete(helper.InputFile + ".metadata");
            }
        }

        [TestCase, TestCasePriority(3), Description("Run the decrypter on a huge file")]
        public class P_DecryptHugeFile_1GB : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\EncryptedLargeFile.txt");

            public override void PreRun()
            {
                // Create a big file
                using (FileStream file = File.OpenWrite(helper.InputFile))
                {
                    Byte[] bytes = File.ReadAllBytes(@".\SuitesData\Xlfs\SimpleEncrypted.txt");
                    for (int i = 0; i < 100; i++)
                    {
                        // 10 * 100 is 1000 MB
                        file.Write(bytes, 0, bytes.Length);
                    }
                    file.Flush();
                    file.Close();
                }

                // Create a metadata file
                helper.BlockSize = 4 * 1024 * 1024; // 4MB Block Size
                helper.BlockStart = 00000001; // I dunno what this is
                helper.WriteMetadata();

                // Generate a file
                helper.PreRun();
            }

            public override void Run()
            {
                DateTime start = DateTime.UtcNow;
                helper.Execute();
                DateTime end = DateTime.UtcNow;

                Global.RO.Success("Total time: {0} s", (end - start).TotalSeconds);
            }

            public override void PostRun()
            {
                // Let's delete the file for now
                File.Delete(helper.InputFile);
                File.Delete(helper.OutputFile);
                File.Delete(helper.InputFile + ".metadata");
            }
        }

        [TestCase, TestCasePriority(2), Description("Decrypt 1GB of data (in 10MB chunks) and measure the latency")]
        public class P_Decrypt1GBin10MB_LatencyCheck : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\SimpleEncrypted.txt");

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                TimeSpan totalTime = TimeSpan.Zero;
                Int32 iterations = 100;

                for (int i = 0; i < iterations; i++)
                {
                    DateTime start = DateTime.UtcNow;
                    helper.Execute();
                    DateTime end = DateTime.UtcNow;
                    totalTime += end - start;
                    File.Delete(helper.OutputFile);
                }

                Global.RO.Success("Total time (for {0}MB): {1} s", 100 * iterations, totalTime.TotalSeconds);
                Global.RO.Success("Avg Time(per 10MB): {0} s", totalTime.TotalSeconds / iterations);
            }

            public override void PostRun()
            {
                File.Delete(helper.OutputFile);
            }
        }

        [TestCase, TestCasePriority(3), Description("Decrypt 1GB of data (in 100MB chunks) and measure the latency")]
        public class P_Decrypt1GB100MB_LatencyCheck : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\EncryptedLargeFile.txt");

            public override void PreRun()
            {
                // Create a big file
                using (FileStream file = File.OpenWrite(helper.InputFile))
                {
                    Byte[] bytes = File.ReadAllBytes(@".\SuitesData\Xlfs\SimpleEncrypted.txt");
                    for (int i = 0; i < 10; i++)
                    {
                        // 10 * 10 is 100 MB
                        file.Write(bytes, 0, bytes.Length);
                    }
                    file.Flush();
                    file.Close();
                }

                // Create a metadata file
                helper.BlockSize = 4 * 1024 * 1024; // 4MB Block Size
                helper.BlockStart = 00000001; // I dunno what this is
                helper.WriteMetadata();

                // Generate a file
                helper.PreRun();
            }

            public override void Run()
            {
                TimeSpan totalTime = TimeSpan.Zero;
                Int32 iterations = 10;

                for (int i = 0; i < iterations; i++)
                {
                    DateTime start = DateTime.UtcNow;
                    helper.Execute();
                    DateTime end = DateTime.UtcNow;
                    totalTime += end - start;
                    File.Delete(helper.OutputFile);
                }

                Global.RO.Success("Total time (for {0}MB): {1} s", 100 * iterations, totalTime.TotalSeconds);
                Global.RO.Success("Avg Time(per 100MB): {0} s", totalTime.TotalSeconds / iterations);
            }

            public override void PostRun()
            {
                // Let's delete the file for now
                File.Delete(helper.InputFile);
                File.Delete(helper.InputFile + ".metadata");
                File.Delete(helper.OutputFile);
            }
        }

        [TestCase, TestCasePriority(0), Description("Run the decrypter on a single piece of data")]
        public class P_DecryptMultipleOfBlockSize : TestNode
        {
            DecrypterTestHelper helper = new DecrypterTestHelper(@".\SuitesData\Xlfs\...");

            public override void Run()
            {
                for (int i = 0; i < 16; i++)
                {
                    helper.InputFile = String.Format(@".\SuitesData\Xlfs\EncryptedTestFile_16KB_{0}B.txt", i);
                    helper.OutputFile = DecrypterTestHelper.GetOutputFile(helper.InputFile);
                    helper.PreRun();
                    helper.Execute();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\Tools\Downloader.cs ===
using System;
using ServerTestFramework;
using System.Text;
using ServerTestFramework.Core.Utilities;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using ServerTestFramework.LiveService.Storage.Azure;
using xonline.server.xlfs.common;
using System.Threading;
using System.Text.RegularExpressions;

namespace Xlfs.Test
{
    public class RandomFileManager
    {
        private static readonly Int32 OneMB = 1024 * 1024;
        private static Dictionary<Int32, Byte[]> files = new Dictionary<int, byte[]>();

        public static Byte[] GetRandomFile()
        {
            // Get a random file between 1MB and 10MB
            Int32 size = RandomEx.GlobalRandGen.Next(1, 10) * OneMB;
            return GetRandomFile(size, false);
        }

        public static Byte[] GetRandomFile(Int32 length)
        {
            return GetRandomFile(length, false);
        }

        public static Byte[] GetRandomFile(Int32 length, Boolean forceNew)
        {
            if (!forceNew && files.ContainsKey(length))
            {
                return files[length];
            }
            else
            {
                Byte[] bytes = RandomEx.GlobalRandGen.GenerateRandomBlob(length);
                files[length] = bytes;
                return bytes;
            }
        }
    }

    public struct UploadedFileInfo
    {
        public String FileName;
        public Int64 Length;
        public DateTime UploadTime;
        public UInt64 UserXuid;
        public String TransactionId;
        public UInt32 TitleId;

        public override int GetHashCode()
        {
            return FileName.GetHashCode() ^ UploadTime.GetHashCode() ^ Length.GetHashCode();
        }

        public String DownloadedFileName
        {
            get
            {
                return String.Format("{0}.{1}.{2}",
                    UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString),
                    TitleId.ToString(FileTableLastUpdateEntry.TitleIdFormatString),
                    FileName);
            }
        }

        public String DownloadedMetadataName
        {
            get { return DownloadedFileName + ".metadata"; }
        }

        public UploadedFileInfo(String fileName, Int64 length, DateTime uploadTime, UInt64 userXuid, String transactionId)
        {
            this.FileName = fileName;
            this.Length = length;
            this.UploadTime = uploadTime;
            this.UserXuid = userXuid;
            this.TransactionId = transactionId;
            this.TitleId = DownloaderTestHelper.DefaultTitleID;
        }
    }

    public class DownloaderTestHelper
    {
        public static readonly String XlfsConsoleDownloaderPath = @".\XlfsConsoleDownloader.exe";
        public static readonly String XlfsDownloaderPath = @".\XlfsDownloader.exe";

        public static readonly String XlfsDownloaderFilePrefix = "Xlfs_DownloaderTest_";

        public static readonly String DefaultServer = XlfsTestSettings.Current.XlfsAdminServer.ToString();
        public static readonly String DefaultSaveDirectory = @".\SuitesData\Xlfs\DownloadedFiles";
        public static readonly UInt32 DefaultTitleID = 0xFFFE07D1;
        public static readonly String DefaultCertificateSubject =
            @"CN=test-azure.xboxlive.com, OU=LSD, O=Microsoft, L=Redmond, S=WA, C=US";

        /// <summary>
        /// The server to download from.
        /// </summary>
        public String Server = DefaultServer;
        /// <summary>
        /// The first date to request files for.
        /// </summary>
        public DateTime? StartDate;
        /// <summary>
        /// The last date to request files for.
        /// </summary>
        public DateTime? EndDate;
        /// <summary>
        /// The number of days to download files for.  Only needs to be 
        /// provided if a start or end date isn't.
        /// </summary>
        public Int32? DeltaDays;
        /// <summary>
        /// The number of minutes to download files for.  Only needs to be 
        /// provided if a start or end date isn't.
        /// </summary>
        public Int32? DeltaMinutes;
        /// <summary>
        /// The location that the files should be downloaded to.
        /// </summary>
        public String SaveDirectory = DefaultSaveDirectory;
        /// <summary>
        /// The TitleId to be checked for files
        /// </summary>
        public UInt32? TitleID;
        /// <summary>
        /// The subject name of the certificate to provide to the front door
        /// </summary>
        public String CertificateSubject = DefaultCertificateSubject;
        /// <summary>
        /// The thumbprint of the certificate to provide to the front door
        /// </summary>
        public String Thumbprint = null;
        /// <summary>
        /// The filename filter used to determin which files to download
        /// </summary>
        public String FileFilter;
        /// <summary>
        /// Disables downloading of files and metadata.  Just lists files that exist.
        /// </summary>
        public Boolean EnumOnly;
        /// <summary>
        /// Disables downloading of files.  Downloads metadata for all existing files.
        /// </summary>
        public Boolean MetadataOnly;
        /// <summary>
        /// Indicates if the downloader should use a proxy server to communicate with Azure
        /// </summary>
        public Boolean UseProxy;
        /// <summary>
        /// Specifies the proxy server to use if one is requested.  If none is provided
        /// then the default machine proxy will be used.
        /// </summary>
        public String ProxyServer;

        /// <summary>
        /// The format string to be used when creating date strings
        /// </summary>
        public String DateFormat = "s";

        public String Arguments
        {
            get
            {
                StringBuilder sb = new StringBuilder();

                if (Server != null)
                {
                    sb.AppendFormat("-server {0} ", Server);
                }

                if (StartDate.HasValue)
                {
                    sb.AppendFormat("-startdate {0} ", StartDate.Value.ToString(DateFormat));
                }

                if (EndDate.HasValue)
                {
                    sb.AppendFormat("-enddate {0} ", EndDate.Value.ToString(DateFormat));
                }

                if (DeltaDays.HasValue)
                {
                    sb.AppendFormat("-deltadays {0} ", DeltaDays.Value);
                }

                if (DeltaMinutes.HasValue)
                {
                    sb.AppendFormat("-deltaminutes {0} ", DeltaMinutes.Value);
                }

                if (SaveDirectory != null)
                {
                    sb.AppendFormat("-savedirectory {0} ", SaveDirectory);
                }

                if (TitleID.HasValue)
                {
                    sb.AppendFormat("-titleid {0} ", TitleID.Value);
                }

                if (CertificateSubject != null)
                {
                    sb.AppendFormat("-certificate \"{0}\" ", CertificateSubject);
                }

                if (Thumbprint != null)
                {
                    sb.AppendFormat("-thumbprint {0} ", Thumbprint);
                }

                if (FileFilter != null)
                {
                    sb.AppendFormat("-filter {0} ", FileFilter);
                }

                if (EnumOnly)
                {
                    sb.Append("-enumonly ");
                }

                if (MetadataOnly)
                {
                    sb.Append("-metadataonly ");
                }

                if (UseProxy)
                {
                    sb.Append("-proxy ");

                    if (ProxyServer != null)
                    {
                        sb.Append(ProxyServer);
                        sb.Append(" ");
                    }
                }

                return sb.ToString();
            }
        }

        private List<UploadedFileInfo> fileInfoCache = new List<UploadedFileInfo>();

        public void Reset()
        {
            this.Server = XlfsTestSettings.Current.XlfsAdminServer.ToString();
        }

        /// <summary>
        /// Execute the downloader and expect success.
        /// </summary>
        public void Execute()
        {
            Execute(0, Arguments);
        }

        /// <summary>
        /// Execute the downloader and expect a given error.
        /// </summary>
        /// <param name="expectedError">The expected result</param>
        public void Execute(Int32 expectedError)
        {
            Execute((DownloaderErrorValue)expectedError, Arguments);
        }

        /// <summary>
        /// Execute the downloader with a set of arguments and
        /// expect a given error.
        /// </summary>
        /// <param name="expectedError">The expected result</param>
        /// <param name="arguments">The arguments to pass to the downloader</param>
        public void Execute(Int32 expectedError, String arguments)
        {
            Execute((DownloaderErrorValue)expectedError, arguments);
        }

        /// <summary>
        /// Execute the downloader and expect a given error.
        /// </summary>
        /// <param name="expectedResult">The expected result</param>
        public void Execute(DownloaderErrorValue expectedResult)
        {
            Execute(expectedResult, Arguments);
        }

        /// <summary>
        /// Execute the downloader and expect a given error.
        /// </summary>
        /// <param name="expectedResult">The expected result</param>
        /// <param name="arguments">The arguments to pass to the downloader</param>
        public void Execute(DownloaderErrorValue expectedResult, String arguments)
        {
            Thread.Sleep(1000);

            // We need the approximate time that the downloader was run
            // so lets just grab that now, and we can use it later to 
            // calculate the times that we need.  We have to add on a 
            // fudge factor so that we don't miss files because we're so
            // close to the actualy time
            DateTime executeDate = DateTime.UtcNow.AddMilliseconds(500);

            // Run the downloader
            DownloaderErrorValue result = (DownloaderErrorValue)RunDownloader(arguments);

            // Do some basic validation
            ValueCheck.Test("XLFSDownloaderReturnCode", expectedResult, result);
            Global.RO.Success("Got expected return code: {0}({1})", result, (Int32)result);

            // If we're expected success
            if (expectedResult == 0)
            {
                TimeSpan? deltaTimeSpan = null;
                if(DeltaDays.HasValue && DeltaDays != 0)
                {
                    deltaTimeSpan = TimeSpan.FromDays(DeltaDays.Value);
                }
                else if (DeltaMinutes.HasValue && DeltaMinutes != 0)
                {
                    deltaTimeSpan = TimeSpan.FromMinutes(DeltaMinutes.Value);
                }

                // Since it was successful, we grab the start and end date that were 
                // provided, or just use the defaults that we can calculate
                DateTime endDate = EndDate.HasValue ? EndDate.Value : executeDate;
                DateTime startDate = StartDate.HasValue ? StartDate.Value : ((deltaTimeSpan.HasValue) ? (endDate - deltaTimeSpan.Value) : endDate.AddDays(-1));

                Global.RO.Debug("Start Time: {0}, End Time: {1}", startDate.ToUniversalTime(), endDate.ToUniversalTime());

                Global.RO.Info("Validating downloaded files");

                Boolean shouldFilter = !String.IsNullOrEmpty(FileFilter);
                String filterRegex = String.Empty;
                if (shouldFilter)
                {
                    // Escape any special characters
                    filterRegex = Regex.Escape(FileFilter);
                    // Then replace any wildcards with regex wildcards
                    filterRegex = filterRegex.Replace("\\*", ".*");
                    filterRegex = String.Format("^{0}$", filterRegex);
                }

                foreach (UploadedFileInfo file in fileInfoCache)
                {
                    if (file.UploadTime >= startDate && file.UploadTime <= endDate)
                    {
                        // This file should have been returned to the client
                        String filePath = Path.Combine(SaveDirectory, file.DownloadedFileName);

                        if (shouldFilter && !Regex.IsMatch(file.FileName, filterRegex))
                        {
                            // If it doesn't match the filter, it should not be downloaded
                            ValueCheck.IsFalse(File.Exists(filePath), "Unexpected file downloaded: " + file.FileName);
                            Global.RO.Success("{0} Not Downloaded", file.FileName);
                        }
                        else
                        {
                            ValueCheck.IsTrue(File.Exists(filePath), "Expected file not downloaded: " + file.FileName);
                            Global.RO.Success("{0} Exists", file.FileName);
                        }
                    }
                }

                Global.RO.Success("All expected output files exist.");
            }
        }

        public String UploadFile()
        {
            return UploadFile((DateTime?)null);
        }

        public String UploadFile(DateTime? uploadTime)
        {
            // Upload a random file between 1 and 10 MB
            return UploadFile(RandomFileManager.GetRandomFile(), uploadTime);
        }

        public String UploadFile(String filePath)
        {
            return UploadFile(filePath, null);
        }

        public String UploadFile(String filePath, DateTime? uploadTime)
        {
            if (!File.Exists(filePath))
            {
                String msg = String.Format("File {0} does not exist.  Unable to upload to cloud", filePath);
                throw new UnexpectedTestResultException(msg);
            }

            return UploadFile(File.ReadAllBytes(filePath), uploadTime);
        }

        public String UploadFile(Int32 fileLength)
        {
            return UploadFile(fileLength, null);
        }

        public String UploadFile(Int32 fileLength, DateTime? uploadTime)
        {
            return UploadFile(RandomFileManager.GetRandomFile(fileLength), uploadTime);
        }

        public String UploadFile(Byte[] bytes)
        {
            return UploadFile(bytes, null);
        }

        public String UploadFile(Byte[] bytes, DateTime? uploadTime)
        {
            byte[] memoryHash = BlobClient.GetMD5Hash(bytes);
            String fileName = String.Format("{0}{1:X}.bin", XlfsDownloaderFilePrefix, RandomEx.GlobalRandGen.NextUlong());

            //Execute Begin
            XlfsUploadBegin beginReq = ClientFD.CreateBeginReq();
            beginReq.FileName = fileName;
            beginReq.FileHash = memoryHash;
            if (TitleID.HasValue)
            {
                beginReq.TitleId = TitleID.Value;
                ServerTestFramework.STS.GetSecurityTokenParameters parameters = XlfsTests.SamlParameters;
                parameters.TitleID = TitleID;
                beginReq.SamlParameters = parameters;
            }
            ClientFD.ExecutePositiveBeginReq(beginReq, false);

            // Create a BlobClient using the SAS Url returned by the beginReq
            BlobClient blobClient = new BlobClient(beginReq.StorageUri);
            string storagePath = BlobTableClient.GetStoragePath(beginReq.UserXuid.Value, beginReq.FileName, beginReq.TransactionId);
            // And upload the file
            MemoryStream memoryStream = new MemoryStream(bytes);
            blobClient.PutBlob(storagePath, memoryStream);
            //blobClient.GetBlobAsFile(storagePath, "E:\\TempFile.bin");

            //Execute End
            XlfsUploadEnd endReq = ClientFD.CreateEndReq(beginReq);
            endReq.FileLength = memoryStream.Length;
            ClientFD.ExecutePositiveEndReq(endReq, false);

            // If a time was provided, fake that the file was uploaded then
            if (uploadTime.HasValue)
            {
                FileTableLastUpdateClient fileTableClient = new FileTableLastUpdateClient();
                List<FileTableLastUpdateEntry> files = fileTableClient.SelectFile(fileName);
                if (files.Count == 0)
                {
                    String msg = String.Format("Unable to find file {0} in cloud.  Can't update upload time.");
                    throw new UnexpectedTestResultException(msg);
                }

                // We have to delete the file table entry, because we may be updating the partition key
                fileTableClient.DeleteFileTableEntry(files[0]);

                files[0].PartitionKey = uploadTime.Value.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString);
                files[0].Created = uploadTime.Value;
                files[0].LastUpdate = uploadTime.Value;

                // Now add it back in
                fileTableClient.AddFileTableEntry(files[0]);
            }
            else
            {
                uploadTime = DateTime.UtcNow;
            }

            UploadedFileInfo fileInfo = new UploadedFileInfo(fileName, endReq.FileLength.Value, uploadTime.Value, endReq.UserXuid.Value, endReq.TransactionId);
            fileInfo.TitleId = TitleID.HasValue ? TitleID.Value : DefaultTitleID;
            fileInfoCache.Add(fileInfo);

            return fileName;
        }

        /// <summary>
        /// Deletes all files uploaded by this helper if required and then 
        /// deletes the associated downloaded files on disk and clears the 
        /// helper file info cache.
        /// </summary>
        public void ClearFiles()
        {
            ClearFiles(XlfsTestSettings.Current.AutoDeleteFilesFromCloud, true);
        }

        /// <summary>
        /// Deletes all of the files uploaded to the cloud if requested and
        /// then deletes all the associated downloaded files on disk and 
        /// clears the helper file info cache.
        /// </summary>
        /// <param name="deleteFromCloud">
        /// If true, files in the cloud are deleted, otherwise only the 
        /// downloaded files and the file info cache are deleted.
        /// </param>
        public void ClearFiles(Boolean deleteFromCloud, Boolean clearFileInfoCache)
        {
            FileTableLastUpdateClient fileTableClient = new FileTableLastUpdateClient();
            XLFSClient xlfsClient = new XLFSClient();

            foreach (UploadedFileInfo fileInfo in fileInfoCache)
            {
                // Only delete the file from the cloud if the option is set, or
                // we're being forced to delete them (by the test case)
                if (deleteFromCloud)
                {
                    List<FileTableLastUpdateEntry> fileList = fileTableClient.SelectTransaction(fileInfo.UserXuid, fileInfo.TransactionId);
                    if (fileList.Count == 1)
                    {
                        xlfsClient.SafeRemoveFile(fileInfo.UserXuid, fileList[0].Filename, (uint)fileList[0].TitleId);
                    }
                }

                // Always delete the downloaded file so a test doesn't think that it
                // successfully downloaded when it was actually just downloaded before
                String filePath = Path.Combine(SaveDirectory, fileInfo.FileName);
                if (File.Exists(filePath))
                {
                    File.Delete(filePath);
                }
            }

            if (clearFileInfoCache)
            {
                fileInfoCache.Clear();
            }
        }

        public void ClearSaveDirectory()
        {
            ClearDirectory(SaveDirectory);
        }

        public static void ClearDirectory(String directory)
        {
            /*
            foreach (String filePath in Directory.GetFiles(directory))
            {
                try
                {
                    File.Delete(filePath);
                }
                catch (FieldAccessException e)
                {
                    Global.RO.Info("Unable to delete {0}.  {1}", filePath, e.ToString());
                }
            }
             */

            if (Directory.Exists(directory))
            {
                // Just recursively delete
                Directory.Delete(directory, true);
                
                // Give it a second to complete otherwise the create may fail
                Thread.Sleep(1000);
            }

            // Then recreate
            Directory.CreateDirectory(directory);
        }

        /// <summary>
        /// Deletes all test files uploaded to the cloud that
        /// </summary>
        public static void ClearCloud()
        {
            // Go to the cloud, and clear out all files that match our test file names
            ClearCloud(e => e.Filename.StartsWith(XlfsDownloaderFilePrefix));
        }

        public static void ClearCloud(Predicate<FileTableLastUpdateEntry> match)
        {
            // Go to the cloud, and clear out all files that match our test file names
            FileTableLastUpdateClient fileTableClient = new FileTableLastUpdateClient();
            XLFSClient xlfsClient = new XLFSClient();

            foreach (FileTableLastUpdateEntry file in fileTableClient.Select())
            {
                if (match(file))
                {
                    xlfsClient.SafeRemoveFile((ulong)file.UserXuid, file.Filename, (uint)file.TitleId);
                }
            }
        }

        public static Int32 RunDownloader(String arguments)
        {
            String output = "";
            Process downloadProc = new Process();
            downloadProc.StartInfo = new ProcessStartInfo(XlfsConsoleDownloaderPath, arguments);
            downloadProc.StartInfo.UseShellExecute = false;
            downloadProc.StartInfo.CreateNoWindow = true;
            downloadProc.StartInfo.RedirectStandardOutput = true;
            //downloadProc.StartInfo.RedirectStandardError = true;

            Global.RO.Info("Running XLFS Downloader.");
            Global.RO.Debug("Arguments: " + arguments);

            if (!downloadProc.Start())
            {
                output = downloadProc.StandardOutput.ReadToEnd();
                throw new UnexpectedTestResultException("Unable to start XlfsDownloader. " + output);
            }

            output = downloadProc.StandardOutput.ReadToEnd();
            Global.RO.Info(output.Trim());

            if (!downloadProc.HasExited)
            {
                downloadProc.WaitForExit(5000);
                if (!downloadProc.HasExited)
                {
                    downloadProc.Kill();
                }
            }

            return downloadProc.ExitCode;
        }
    }

    public enum DownloaderErrorValue
    {
        Success = 0,
        CommandLineError = 1,
        ArgumentParsingError = 10,
        InvalidStartTime = 2,
        InvalidEndTime = 3,
        InvalidSaveDirectory = 4,
        InvalidTitleId = 5,
        CouldNotParseDeltaDays = 6,
        CouldNotParseDeltaMinutes = 9,
        InvalidDeltaTimeValue = 11,
        NegativeDeltaDays = 12,
        NegativeDeltaMinutes = 13,
        UnableToObtainFileList = 7,
        UnableToDownloadAllFiles = 8,
        Unknown = 100,
    }

    [TestGroup, Owner("BenRan"), TestFrequency("Daily"), Description("Tests for the command line XLFS file downloader")]
    public class FileDownloader : TestNode
    {
        public override void PreRun()
        {
            if (!File.Exists(DownloaderTestHelper.XlfsConsoleDownloaderPath))
            {
                throw new UnexpectedTestResultException("The downloader executable does not exist at " +
                    DownloaderTestHelper.XlfsConsoleDownloaderPath + ", these tests will be unable to run.");
            }

            Global.RO.Info("Clearing Uploaded Files...");
            DownloaderTestHelper.ClearCloud();

            Global.RO.Info("Clearing Downloaded Files...");
            DownloaderTestHelper.ClearDirectory(DownloaderTestHelper.DefaultSaveDirectory);
        }

        [TestCase, TestCasePriority(0), Description("Run the downloader and ensure that we don't get any errors.")]
        public class P_BVTDownload : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void Run()
            {
                // This helps the test run faster because it only makes two 
                // requests, not 24
                helper.Reset();
                helper.DeltaMinutes = 120;
                helper.Execute();
            }
        }

        [TestCase, TestCasePriority(0), Description("Upload a single file then download it.")]
        public class P_Download1File : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UploadFile(100 * 1024);
                // This helps the test run faster because it only makes two 
                // requests, not 24
                helper.DeltaMinutes = 120;
            }

            public override void Run()
            {
                // This test seems to need some time
                // to make sure
                //Thread.Sleep(1500);
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(0), Description("Upload a single file then download it.")]
        public class P_Download_OneOutOfRange : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                // Upload one file now
                helper.UploadFile(100 * 1024);
                // Upload one file 2 days ago
                helper.UploadFile(100 * 1024, DateTime.UtcNow.AddDays(-2));

                // This helps the test run faster because it only makes two 
                // requests, not 24
                helper.DeltaMinutes = 120;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Upload a number of files both in and out of range, and verify only the correct ones are returned")]
        public class P_Download_3InRange2Out : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void  PreRun()
            {
                DateTime start = DateTime.UtcNow.AddHours(-48);
                DateTime end = DateTime.UtcNow.AddHours(-36);
                helper.StartDate = start;
                helper.EndDate = end;

                // Upload one file before the start
                helper.UploadFile(start.AddHours(-2));

                // Three in the valid range
                helper.UploadFile(start.AddHours(1));
                helper.UploadFile(start.AddHours(4));
                helper.UploadFile(start.AddHours(8));

                // And one after the range
                helper.UploadFile(end.AddHours(2));
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Upload a single file on the hour boundary of the start time, then download it.")]
        public class P_Download1FileOnStartBoundary : TestNode
        {
            DateTime fileUploadDate;
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                // Get a random time a few days ago
                DateTime now = DateTime.UtcNow.AddDays(-10);
                fileUploadDate = new DateTime(now.Year, now.Month, now.Day, now.Hour, 0, 0);
                helper.UploadFile(1024, fileUploadDate);
                helper.StartDate = fileUploadDate;
                helper.EndDate = fileUploadDate.AddHours(5);
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Upload a single file on the hour boundary of the start time, then download it.")]
        public class P_Download1FileJustBeforeStartBoundary : TestNode
        {
            DateTime fileUploadDate;
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                // Get a random time a few days ago
                DateTime now = DateTime.UtcNow.AddDays(-10);
                fileUploadDate = new DateTime(now.Year, now.Month, now.Day, now.Hour, 0, 0);
                helper.UploadFile(1024, fileUploadDate.AddSeconds(-1));
                helper.StartDate = fileUploadDate;
                helper.EndDate = fileUploadDate.AddHours(5);
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Upload a single file on the hour boundary of the start time, then download it.")]
        public class P_Download1FileOnEndBoundary : TestNode
        {
            DateTime fileUploadDate;
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                // Get a random time a few days ago
                DateTime now = DateTime.UtcNow.AddDays(-10);
                // This gives us an upload time that's not right on an hour boundary
                fileUploadDate = new DateTime(now.Year, now.Month, now.Day, now.Hour, 0, 5);
                helper.UploadFile(1024, fileUploadDate);
                helper.EndDate = fileUploadDate;
                helper.DeltaMinutes = 120;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Upload a single file on the hour boundary of the start time, then download it.")]
        public class P_Download1FileJustAfterEndBoundary : TestNode
        {
            DateTime fileUploadDate;
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                // Get a random time a few days ago
                DateTime now = DateTime.UtcNow.AddDays(-10);
                // This gives us an upload time that's not right on an hour boundary
                fileUploadDate = new DateTime(now.Year, now.Month, now.Day, now.Hour, 0, 5);
                helper.UploadFile(1024, fileUploadDate.AddSeconds(1));
                helper.StartDate = fileUploadDate.AddHours(-2);
                helper.EndDate = fileUploadDate;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Run the downloader and confirm it got at least 20 files")]
        public class P_Download20Files : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                for (int i = 0; i < 20; i++)
                {
                    // This is going to be the exact same 1KB file every time
                    // Does that matter?  Probably not.
                    helper.UploadFile(1024);
                }
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Run the downloader and confirm that it got 1000 files")]
        [Ignore("This test takes too long.  Would be better as a stress test.")]
        public class P_Download1000Files : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                for (int i = 0; i < 1000; i++)
                {
                    // This is going to be the exact same 1KB file every time
                    // Does that matter?  Probably not.
                    helper.UploadFile(1024);
                }
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Run the downloader and confirm that more than 1000 files (more than 1 page) were downloaded")]
        [Ignore("This test takes too long.  Would be better as a stress test.")]
        public class P_DownloadMoreThan1000Files : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                for (int i = 0; i < 2000; i++)
                {
                    // This is going to be the exact same 1KB file every time
                    // Does that matter?  Probably not.
                    helper.UploadFile(1024);
                }
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(0), Description("Upload a two files then download one based on the filter.")]
        public class P_Download1FileFiltered : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();
            String fileToDownload;

            public override void PreRun()
            {
                helper.Reset();
                fileToDownload = helper.UploadFile(100 * 1024);
                helper.UploadFile(100 * 1024);
                // This helps the test run faster because it only makes two 
                // requests, not 24
                helper.DeltaMinutes = 120;
            }

            public override void Run()
            {
                Int32 prefixLen = DownloaderTestHelper.XlfsDownloaderFilePrefix.Length;

                // Try it one with a filter for a specific file
                Global.RO.Info("Filtering for a specific filename...");
                helper.FileFilter = fileToDownload;
                helper.Execute();
                // We only want to clear the downloaded files
                helper.ClearFiles(false, false);

                // Try it with a single wild card
                Global.RO.Info("Filtering with a single wildcard...");
                helper.FileFilter = String.Format("{0}*", fileToDownload.Remove(prefixLen + 5));
                helper.Execute();
                // We only want to clear the downloaded files
                helper.ClearFiles(false, false);

                // And once more with multiple wildcards
                Global.RO.Info("Filtering with a multiple wildcards...");
                helper.FileFilter = String.Format("*{0}*", fileToDownload.Substring(prefixLen, 5));
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass an invalid server URI")]
        public class N_InvalidServer : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.Server = "YourMomsAnInvalidServerUri";
            }

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.ArgumentParsingError);
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass a URI for a non-existant server")]
        public class N_NonExistantServer : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.Server = "http://nota.valid_serv.er/FakeStorage/";
            }

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.UnableToObtainFileList);
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass an empty value for server")]
        public class N_NoServer : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.CommandLineError, "-server ");
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass an invalid value for start time")]
        public class N_InvalidStartTime : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.InvalidStartTime, "-startdate TwoDaysFromYesterday");
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass the current time for start time")]
        public class P_StartDateNow : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UploadFile();
                helper.StartDate = DateTime.UtcNow.AddSeconds(-10);
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass the current time minus 10 days for start time")]
        public class P_StartDateNowMinus10Days : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.StartDate = DateTime.UtcNow.AddDays(-10);
                helper.UploadFile(DateTime.UtcNow.AddDays(-10).AddHours(2));
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a time in the future for the start time")]
        public class P_StartDateFuture : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.StartDate = DateTime.UtcNow.AddDays(1);
            }

            public override void Run()
            {
                helper.Execute();//DownloaderErrorValue.DownloaderError);
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass an invalid value for end time")]
        public class N_InvalidEndTime : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.InvalidEndTime, "-enddate NotQuiteTheDayFollowingNextMoring");
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass the current time for the end time")]
        public class P_EndDateNow : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UploadFile();
                helper.EndDate = DateTime.UtcNow.AddSeconds(30);
                helper.DeltaMinutes = 120;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a time in the future for the end time")]
        public class P_EndDateFuture : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UploadFile();
                helper.EndDate = DateTime.UtcNow.AddHours(3);
                helper.DeltaMinutes = 240;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a start/end time interval in the future")]
        public class P_FutureTimeInterval : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UploadFile();
                helper.StartDate = DateTime.UtcNow.AddDays(2);
                helper.EndDate = helper.StartDate.Value.AddHours(2);
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a start/end time interval in the future")]
        public class P_TimeIntervalLessThanOneHour : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.StartDate = DateTime.UtcNow.AddMinutes(-200);
                helper.EndDate = helper.StartDate.Value.AddMinutes(40);
                helper.UploadFile(helper.StartDate.Value.AddMinutes(10));
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass an invalid value for delta days")]
        public class N_InvalidDeltaDays : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.CouldNotParseDeltaDays, "-deltadays AHundred!");
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass a negative value for delta days")]
        public class N_NegativeDeltaDays : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.DeltaDays = -10;
            }

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.NegativeDeltaDays);
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a value of zere for delta days")]
        public class P_DeltaDays0 : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UploadFile();
                helper.DeltaDays = 0;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass a value of 2 for delta days")]
        public class P_DeltaDays2 : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UploadFile(DateTime.UtcNow.AddHours(-40));
                helper.UploadFile(DateTime.UtcNow.AddHours(-20));
                helper.UploadFile(DateTime.UtcNow.AddHours(-10));
                helper.StartDate = DateTime.UtcNow.AddDays(-2);
                helper.DeltaDays = 2;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a value of Int32.MaxValue for delta days")]
        public class N_DeltaDaysMax : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.DeltaDays = Int32.MaxValue;
            }

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.InvalidDeltaTimeValue);
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass an invalid value for delta minutes")]
        public class N_InvalidDeltaMinutes : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.CouldNotParseDeltaMinutes, "-deltaminutes ABillion!!!");
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass a negative value for delta minutes")]
        public class N_NegativeDeltaMinutes : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.DeltaMinutes = -10000;
            }

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.NegativeDeltaMinutes);
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a value of zero for delta minutes")]
        public class P_DeltaMinutes0 : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UploadFile();
                helper.DeltaMinutes = 0;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass a value of 50 for delta minutes")]
        public class P_DeltaMinutes50 : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UploadFile(DateTime.UtcNow.AddMinutes(-40));
                helper.UploadFile(DateTime.UtcNow.AddMinutes(-20));
                helper.UploadFile(DateTime.UtcNow.AddMinutes(-10));
                helper.StartDate = DateTime.UtcNow.AddMinutes(-50);
                helper.DeltaMinutes = 50;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a time interval in the past using delta minutes")]
        public class P_DeltaMinutesPastInterval : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                DateTime now = DateTime.UtcNow;
                // Upload a file 3+ hours in the past
                helper.UploadFile(now.AddMinutes(-200));
                // End time 2 hours in the past
                helper.EndDate = DateTime.UtcNow.AddMinutes(-120);
                // Delta time is 2 hours (so start 4 hours in past)
                helper.DeltaMinutes = 120;
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a value of Int32.MaxValue for delta minutes")]
        public class N_DeltaMinutesMax : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.DeltaMinutes = Int32.MaxValue;
            }

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.InvalidDeltaTimeValue);
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a file path other than the current directory")]
        public class P_DifferentSaveDirectory : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.SaveDirectory = @".\SuitesData\Xlfs\TempSaveDirectory\";
                Directory.CreateDirectory(helper.SaveDirectory);
                helper.UploadFile();
                // Limit it to two hours otherwise it'll take a long time
                // because there is a pause between each hours request.
                helper.StartDate = DateTime.UtcNow.AddHours(-2);
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
                Directory.Delete(helper.SaveDirectory, true);
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a non-existant file path for the save directory")]
        public class N_NonExistantSaveDirectory : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.SaveDirectory = @".\SuitesData\Xlfs\NonExistant\Directory\";
            }

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.InvalidSaveDirectory);
            }
        }

        [TestCase, TestCasePriority(2), Description("Pass an invalid value as the TitleId")]
        public class N_InvalidTitleId : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.InvalidTitleId, "-titleid Halo6");
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass a non-default valid TitleId")]
        public class P_TitleIdNonDefault : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.TitleID = 0x4D5308FC;
                helper.UploadFile(DateTime.UtcNow.AddHours(-1));
                // Limit it to two hours otherwise it'll take a long time
                // because there is a pause between each hours request.
                helper.StartDate = DateTime.UtcNow.AddHours(-2);
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.ClearFiles();
            }
        }

        [TestCase, TestCasePriority(1), Description("Pass zero as the TitleId")]
        public class N_TitleIdZero : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.TitleID = 0;
            }

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.UnableToObtainFileList);
            }
        }

        // We can't download any files for this tests, but it should not crash the downloader
        [TestCase, TestCasePriority(1), Description("Pass Int32.Max as the TitleId")]
        public class P_TitleIdMax : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.TitleID = UInt32.MaxValue;
                // Limit it to two hours otherwise it'll take a long time
                // because there is a pause between each hours request.
                helper.StartDate = DateTime.UtcNow.AddHours(-2);
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, TestCasePriority(1), Description("Use the default proxy server to make requests to Azure")]
        public class P_DefaultProxy : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UseProxy = true;
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, TestCasePriority(2), Description("Use a specified proxy server to make requests to Azure")]
        public class P_ValidProxy : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UseProxy = true;
                helper.ProxyServer = System.Net.WebRequest.GetSystemWebProxy().GetProxy(new Uri("http://windows.azure.com")).ToString();
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, TestCasePriority(3), Description("Attempt to use an invalid proxy server to make requests to Azure")]
        public class N_InvalidProxy : TestNode
        {
            DownloaderTestHelper helper = new DownloaderTestHelper();

            public override void PreRun()
            {
                helper.Reset();
                helper.UseProxy = true;
                helper.ProxyServer = "http://notaproxy.server.com:80/";
            }

            public override void Run()
            {
                helper.Execute(DownloaderErrorValue.UnableToObtainFileList);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\Worker\AgeOutGcTest.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using ServerTestFramework.LiveService.Storage.Azure;
using xonline.common.diagnostics;
using xonline.server.xlfs.common;
using xonline.server.xlfs.fd.xlfsgc;
using ServerTestFramework.STS;

namespace Xlfs.Test
{
    public partial class XlfsGc
    {
        [TestGroup, Owner("benran"), TestFrequency("Daily"), Description("Tests the functionality of the AgeOutGc message handler.")]
        public class AgeOutGcHandlerTest : TestNode
        {
            private static readonly String TestFilePrefix = "Test_AgeOutGCHandler";
            private static FileTableLastUpdateClient fileTableClient = null;
            private static GetSecurityTokenParameters samlParameters = null;
            private static readonly Int32 fileSize = 1024;

            public override void PreRun()
            {
                // Give FileTableLastUpdateDataSource the storage account.
                FileTableLastUpdateDataSource.StorageAccount = new CloudStorageAccount(
                        new StorageCredentialsAccountAndKey(XlfsConfiguration.XlfsTableStorage.StorageAccount,
                                                            XlfsConfiguration.XlfsTableStorage.StorageKey), true);
                // Create the storage clients that we need
                fileTableClient = new FileTableLastUpdateClient();

                samlParameters = XlfsTests.SamlParameters;
            }

            /// <summary>
            /// Utility method to add a blob and a row to FileTableLastUpdateEntry.
            /// </summary>
            /// <param name="fileName"></param>
            /// <param name="fileSize"></param>
            /// <param name="lastUpdate"></param>
            /// <param name="userXuid"></param>
            /// <param name="titleId"></param>
            /// <param name="transactionId"></param>
            /// <param name="blobClient"></param>
            /// <param name="entry"></param>
            private static void AddBlob(
                string fileName,
                int fileSize,
                DateTime lastUpdate,
                ulong userXuid,
                uint titleId,
                string transactionId,
                BlobClient blobClient,
                out FileTableLastUpdateEntry entry)
            {
                entry = new FileTableLastUpdateEntry
                {
                    PartitionKey = string.Format("{0}:{1}:{2}:{3}", lastUpdate.Year, lastUpdate.Month, lastUpdate.Day, lastUpdate.Hour),
                    RowKey = FileTableLastUpdateClient.GetRowKey(userXuid, titleId, fileName),
                    LastUpdate = lastUpdate,
                    Size = fileSize,
                    Created = lastUpdate,
                    Filename = fileName,
                    TitleId = unchecked((int)titleId),
                    TransactionId = transactionId,
                    UserXuid = unchecked((long)userXuid),
                    StorageAccount = blobClient.Credentials.AccountName
                };

                var fileTableClient = new FileTableLastUpdateClient();
                fileTableClient.AddFileTableEntry(entry);

                // Create a file stream.
                var byteArray = new byte[fileSize];
                RandomEx.GlobalRandGen.NextBytes(byteArray);
                var fileStream = new MemoryStream(byteArray);

                //containers cannot be uppercase
                blobClient.BlobContainer = titleId.ToString("x8");
                blobClient.CreateContainer(blobClient.BlobContainer);
                string filePath = BlobTableClient.GetStoragePath(userXuid, fileName, transactionId);
                blobClient.PutBlob(filePath, fileStream);
            }

            private static void RemoveBlob(BlobClient blobClient, FileTableLastUpdateEntry entry)
            {
                // First delete the blob from blob storage
                blobClient.BlobContainer = entry.TitleId.ToString("x8");
                blobClient.DeleteBlob(XlfsUtilities.GetBlobNameFromFileTableEntry(entry));

                var fileTableClient = new FileTableLastUpdateClient();
                var fileEntries = fileTableClient.SelectFile(entry.PartitionKey, entry.RowKey);
                foreach (var fileEntry in fileEntries)
                {
                    fileTableClient.DeleteFileTableEntry(fileEntry);
                }
            }

            private static void RemoveBlobOnly(BlobClient blobClient, FileTableLastUpdateEntry entry)
            {
                // First delete the blob from blob storage
                blobClient.BlobContainer = entry.TitleId.ToString("x8");
                blobClient.DeleteBlob(XlfsUtilities.GetBlobNameFromFileTableEntry(entry));
            }

            private static void RemoveBlobs(BlobClient blobClient, UInt32? titleId, UInt64 userXuid, String filePrefix)
            {
                String container = (titleId.HasValue ? titleId.Value : 0).ToString("x8");
                String rootPath = userXuid.ToString("X16");
                String fullPrefix = rootPath + '/' + filePrefix;
                var blobList = blobClient.GetBlobList(container, rootPath);

                foreach (var entry in blobList)
                {
                    if (entry.StartsWith(fullPrefix))
                    {
                        try
                        {
                            blobClient.DeleteBlob(entry);
                        }
                        catch(StorageClientException e)
                        {
                            if (e.Message == "The specified blob does not exist.")
                            {
                                continue;
                            }

                            throw;
                        }
                    }
                }
            }

            private static CloudStorageAccount GetStorageAccount(String tag)
            {
                return GarbageCollector.StorageAccounts.GetNextStorageAccount(GarbageCollector.TraceFactory.Create(tag));
            }

            private static BlobClient GetBlobClient(String tag)
            {
                var storageAccount = GetStorageAccount(tag);
                return new BlobClient(storageAccount.Credentials,
                                      storageAccount.BlobEndpoint.ToString());
            }

            /// <summary>
            /// This positive test verifies that the specified partition is cleaned up
            /// correctly.  Postcondition contents of the queue are not checked in this 
            /// test case.
            /// </summary>
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Simple positive test case for the message handler.")]
            public class P_AgeOutGcHandler : TestNode
            {
                BlobClient blobClient;
                List<FileTableLastUpdateEntry> removedEntries;
                
                public override void PreRun()
                {
                    // Clear out the Garbage Collector Queue
                    GarbageCollector.GcQueue.Clear();

                    blobClient = GetBlobClient("P_AgeOutGcHandler_MultiplePartitions");

                    Global.RO.Info("Adding new blobs to storage...");
                    DateTime lastUpdate = DateTime.UtcNow;
                    removedEntries = new List<FileTableLastUpdateEntry>();

                    for (int i = 0; i < 5; ++i)
                    {
                        var fileName = String.Format("{0}_{1:X}", TestFilePrefix, RandomEx.GlobalRandGen.NextUlong());

                        FileTableLastUpdateEntry entry;
                        var transactionId = Guid.NewGuid().ToString("N");
                        AddBlob(fileName, fileSize, lastUpdate, samlParameters.Xuid[0],
                                samlParameters.TitleID.HasValue ? samlParameters.TitleID.Value : 0,
                                transactionId, blobClient, out entry);

                        removedEntries.Add(entry);
                    }

                    // Verify that all the blobs are present in storage
                    var blobList = blobClient.GetBlobList(samlParameters.TitleID.Value.ToString("x8"),
                                                          samlParameters.Xuid[0].ToString("X16"));

                    foreach (var entry in removedEntries)
                    {
                        String blobName = XlfsUtilities.GetBlobNameFromFileTableEntry(entry);
                        if (!blobList.Contains(blobName))
                        {
                            throw new UnexpectedTestResultException("Unable to find blob " + blobName);
                        }
                    }

                    base.PreRun();
                }

                public override void Run()
                {
                    // Construct the age out message.  All of the entries should have the same partition key
                    // because we used the same value of lastUpdate for all of them.
                    var msg = new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcFormat, removedEntries[0].PartitionKey));
                    GarbageCollector.GcQueue.AddMessage(msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(GarbageCollector.GcQueue.GetMessage());

                    Global.RO.Info("Handling AgeOut message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);

                    // Don't let exceptions in the handler hork the test.
                    try
                    {
                        msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_AgeOutGcHandler_MultiplePartitions"));
                    }
                    catch (Exception e)
                    {
                        throw new UnexpectedTestResultException("AgeOutGcHandler failed.", e);
                    }

                    Global.RO.Info("Verifying that correct blobs were cleaned up...");
                    var blobList = blobClient.GetBlobList(samlParameters.TitleID.Value.ToString("x8"),
                                                          samlParameters.Xuid[0].ToString("X16"));

                    foreach (var entry in removedEntries)
                    {
                        String blobName = XlfsUtilities.GetBlobNameFromFileTableEntry(entry);
                        if (blobList.Contains(blobName))
                        {
                            // The blob still exists, fail the test.
                            throw new UnexpectedTestResultException("The blob was not deleted by the message handler.");
                        }

                        if (fileTableClient.SelectFile(entry.PartitionKey, entry.RowKey).Count != 0)
                        {
                            throw new UnexpectedTestResultException("File table entry was not deleted.");
                        }
                    }

                    msg = GarbageCollector.GcQueue.GetMessage();
                    if (msg == null)
                    {
                        throw new UnexpectedTestResultException("Expected to find a next partition message in the queue, but didn't.");
                    }

                    GarbageCollector.GcQueue.DeleteMessage(msg);
                }

                public override void PostRun()
                {
                    Global.RO.Debug("Cleaning up blobs in storage..");
                    RemoveBlobs(blobClient, samlParameters.TitleID, samlParameters.Xuid[0], TestFilePrefix);
                }
            }

            /// <summary>
            /// This positive test verifies that the specified partition is cleaned up
            /// correctly.  Postcondition contents of the queue are not checked in this 
            /// test case.
            /// </summary>
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Tests that the handler preserves files outside of the specified partition.")]
            public class P_AgeOutGcHandler_MultiplePartitions : TestNode
            {
                BlobClient blobClient;

                List<FileTableLastUpdateEntry> removedEntries;
                List<FileTableLastUpdateEntry> remainEntries;


                public override void PreRun()
                {
                    // Clear out the queue to start the test.
                    GarbageCollector.GcQueue.Clear();

                    blobClient = GetBlobClient("P_AgeOutGcHandler_MultiplePartitions");

                    Global.RO.Info("Adding new blobs to storage...");
                    DateTime lastUpdate = DateTime.UtcNow;
                    removedEntries = new List<FileTableLastUpdateEntry>();

                    for (int i = 0; i < 5; ++i)
                    {
                        var fileName = String.Format("{0}_{1:X}", TestFilePrefix, RandomEx.GlobalRandGen.NextUlong());

                        FileTableLastUpdateEntry entry;
                        var transactionId = Guid.NewGuid().ToString("N");
                        AddBlob(fileName, fileSize, lastUpdate, samlParameters.Xuid[0],
                                samlParameters.TitleID.HasValue ? samlParameters.TitleID.Value : 0,
                                transactionId, blobClient, out entry);

                        removedEntries.Add(entry);
                    }

                    // Add some blobs to leave behind
                    lastUpdate = DateTime.UtcNow.AddHours(2);
                    remainEntries = new List<FileTableLastUpdateEntry>();

                    for (int i = 0; i < 5; i++)
                    {
                        String fileName = String.Format("{0}_{1:X}", TestFilePrefix, RandomEx.GlobalRandGen.NextUlong());

                        FileTableLastUpdateEntry entry;
                        var transactionId = Guid.NewGuid().ToString("N");
                        AddBlob(fileName, fileSize, lastUpdate, samlParameters.Xuid[0],
                                samlParameters.TitleID.HasValue ? samlParameters.TitleID.Value : 0,
                                transactionId, blobClient, out entry);

                        remainEntries.Add(entry);
                    }

                    // Get all the blobs currently in storage to verify they were added properly.
                    var blobList = blobClient.GetBlobList(samlParameters.TitleID.Value.ToString("x8"),
                                                          samlParameters.Xuid[0].ToString("X16"));

                    foreach (var entry in removedEntries)
                    {
                        String blobName = XlfsUtilities.GetBlobNameFromFileTableEntry(entry);
                        if (!blobList.Contains(blobName))
                        {
                            throw new UnexpectedTestResultException("Unable to find blob " + blobName);
                        }
                    }

                    foreach (var entry in remainEntries)
                    {
                        String blobName = XlfsUtilities.GetBlobNameFromFileTableEntry(entry);
                        if (!blobList.Contains(blobName))
                        {
                            throw new UnexpectedTestResultException("Unable to find blob " + blobName);
                        }
                    }

                    base.PreRun();
                }

                public override void Run()
                {
                    // Construct the age out message.  All of the entries should have the same partition key
                    // because we used the same value of lastUpdate for all of them.
                    var msg = new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcFormat, removedEntries[0].PartitionKey));
                    GarbageCollector.GcQueue.AddMessage(msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(GarbageCollector.GcQueue.GetMessage());

                    Global.RO.Info("Handling AgeOut message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);

                    // Don't let exceptions in the handler hork the test.
                    try
                    {
                        msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_AgeOutGcHandler_MultiplePartitions"));
                    }
                    catch (Exception e)
                    {
                        throw new UnexpectedTestResultException("Handler threw an exception:\r\n{0}", e);
                    }

                    Global.RO.Info("Verifying that correct blobs were cleaned up...");
                    var blobList = blobClient.GetBlobList(samlParameters.TitleID.Value.ToString("x8"),
                                                          samlParameters.Xuid[0].ToString("X16"));

                    foreach (var entry in removedEntries)
                    {
                        String blobName = XlfsUtilities.GetBlobNameFromFileTableEntry(entry);
                        if (blobList.Contains(blobName))
                        {
                            // The blob still exists, fail the test.
                            throw new UnexpectedTestResultException("The blob was not deleted by the message handler.");
                        }

                        if (fileTableClient.SelectFile(entry.PartitionKey, entry.RowKey).Count != 0)
                        {
                            throw new UnexpectedTestResultException("File table entry was not deleted.");
                        }
                    }

                    foreach (var entry in remainEntries)
                    {
                        String blobName = XlfsUtilities.GetBlobNameFromFileTableEntry(entry);
                        if (!blobList.Contains(blobName))
                        {
                            // The blob no longer exists, fail the test.
                            throw new UnexpectedTestResultException("The blob was deleted by the message handler.");
                        }

                        if (fileTableClient.SelectFile(entry.PartitionKey, entry.RowKey).Count == 0)
                        {
                            throw new UnexpectedTestResultException("File table entry was deleted.");
                        }
                    }

                    msg = GarbageCollector.GcQueue.GetMessage();
                    if (msg == null)
                    {
                        throw new UnexpectedTestResultException("Expected to find a next partition message in the queue, but didn't.");
                    }

                    GarbageCollector.GcQueue.DeleteMessage(msg);
                }

                public override void PostRun()
                {
                    Global.RO.Debug("Cleaning up blobs in storage..");
                    RemoveBlobs(blobClient, samlParameters.TitleID, samlParameters.Xuid[0], TestFilePrefix);
                }
            }

            /// <summary>
            /// This positive test case verifies that the correct next AgeOutGc message
            /// is enqueued when we're not yet at the AgeOutGcLifetime boundary.
            /// </summary>
            [TestCase, Owner("benran"), TestCasePriority(0), Description("When the next AgeOutGc to be queued would be within the AgeOutGcLifetime window, it should queue an AgeOutGcCommence message instead.")]
            public class P_MiddleOfPass : TestNode
            {
                public override void Run()
                {
                    // Clear out the queue to start the test.
                    GarbageCollector.GcQueue.Clear();

                    var ageOutGcLifeTime = TimeSpan.FromDays(90);
                    var ageOutGcFrequency = TimeSpan.FromDays(1);

                    // Make sure that the messages don't fall right on the ageOutGcLifetime boundary, subtract a ten minute offset.
                    var now = DateTime.UtcNow - TimeSpan.FromMinutes(10);

                    var ageOutLifetimeWindowBoundary = now - ageOutGcLifeTime;
                    var firstMessagePartition =
                        XlfsUtilities.ParsePartitionKey(
                            (ageOutLifetimeWindowBoundary - TimeSpan.FromHours(3)).ToString(
                                FileTableLastUpdateEntry.PartitionKeyFormatString));
                    var secondMessagePartition = firstMessagePartition + TimeSpan.FromHours(1);

                    GarbageCollector.AgeOutGcLifetime = ageOutGcLifeTime;
                    GarbageCollector.AgeOutGcFrequency = ageOutGcFrequency;

                    // Format the message
                    var msg = new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcFormat, 
                        firstMessagePartition.Value.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString)));

                    GarbageCollector.GcQueue.AddMessage(msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(GarbageCollector.GcQueue.GetMessage());

                    Global.RO.Info("Handling AgeOutGc message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);
                    msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_EndOfPass"));

                    // At this point there should be an AgeOutGc message in the queue with
                    // partition == secondMessagePartition.
                    var newMessage = XlfsGcMessage.Create(GarbageCollector.GcQueue.GetMessage());

                    ValueCheck.Test("Message Type", XlfsConstants.AgeOutGcMessage, newMessage.Name);

                    var partitionFromMessage = XlfsUtilities.ParsePartitionKey(newMessage.Xml.DocumentElement.GetAttribute("partition"));

                    if(!partitionFromMessage.HasValue)
                    {
                        throw new UnexpectedTestResultException(
                            String.Format(
                                "Partition in message ({0}) could not be parsed to a DateTime.",
                                newMessage.Xml.DocumentElement.GetAttribute("partition")));
                    }

                    ValueCheck.Test("Message Partition", secondMessagePartition, partitionFromMessage.Value);

                    GarbageCollector.GcQueue.DeleteMessage(newMessage.Message);
                }
            }

            /// <summary>
            /// This positive test case verifies that the correct next AgeOutGcCommence
            /// message is enqueued when we are at the AgeOutGcLifetime boundary.
            /// </summary>
            [TestCase, Owner("benran"), TestCasePriority(0), Description("When the next AgeOutGc to be queued would be within the AgeOutGcLifetime window, it should queue an AgeOutGcCommence message instead.")]
            public class P_EndOfPass : TestNode
            {
                public override void Run()
                {
                    // Clear out the queue to start the test.
                    GarbageCollector.GcQueue.Clear();

                    var ageOutGcLifeTime = TimeSpan.FromDays(90);
                    var ageOutGcFrequency = TimeSpan.FromDays(1);

                    // Make sure that the messages don't fall right on the ageOutGcLifetime boundary, subtract a ten minute offset.
                    var now = DateTime.UtcNow - TimeSpan.FromMinutes(10);

                    var ageOutLifetimeWindowBoundary = now - ageOutGcLifeTime;
                    var nextGc = now + ageOutGcFrequency;

                    GarbageCollector.AgeOutGcLifetime = ageOutGcLifeTime;
                    GarbageCollector.AgeOutGcFrequency = ageOutGcFrequency;

                    // Format the message
                    var msg =
                        new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcFormat,
                                                            ageOutLifetimeWindowBoundary.ToString(
                                                                FileTableLastUpdateEntry.PartitionKeyFormatString)));

                    GarbageCollector.GcQueue.AddMessage(msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(GarbageCollector.GcQueue.GetMessage());

                    Global.RO.Info("Handling AgeOutGc message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);
                    msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_EndOfPass"));

                    // At this point there should be an AgeOutGcCommence message in the queue with
                    // nextStart 1 day from now.
                    var newMessage = XlfsGcMessage.Create(GarbageCollector.GcQueue.GetMessage());

                    ValueCheck.Test("Message Name", XlfsConstants.AgeOutGcCommenceMessage, newMessage.Name);

                    var nextStartFromMessage = DateTime.Parse(newMessage.Xml.DocumentElement.GetAttribute("nextStart"));

                    ValueCheck.TestGreaterThan("Next Collection Time", nextStartFromMessage, nextGc);

                    GarbageCollector.GcQueue.DeleteMessage(newMessage.Message);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(0), Description("Simple negative test case for the message handler.")]
            public class N_BadAgeOutMessage : TestNode
            {
                public override void Run()
                {
                    // Clear out the queue to start the test.
                    GarbageCollector.GcQueue.Clear();

                    // Format the message
                    var msg = new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcFormat, "WTF:NotA:Partition:Key"));

                    GarbageCollector.GcQueue.AddMessage(msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(GarbageCollector.GcQueue.GetMessage());

                    Global.RO.Info("Handling AgeOutGc message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);
                    Global.RO.Info("Attempting to handle invalid AgeOutGc message.  Error output is expected.");

                    try
                    {
                        msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_EndOfPass"));
                    }
                    catch (Exception e)
                    {
                        throw new UnexpectedTestResultException("Message handler threw an exception instead of failing gracefully.", e);
                    }
                }
            }

            /// <summary>
            /// This positive test verifies that the specified partition is cleaned up
            /// correctly.  Postcondition contents of the queue are not checked in this 
            /// test case.
            /// </summary>
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Makes sure that orphaned table entries are cleaned up.")]
            public class P_AgeOutGcHandler_OrphanedTableEntry : TestNode
            {
                BlobClient blobClient;

                List<FileTableLastUpdateEntry> removedEntries;

                public override void PreRun()
                {
                    // Clear out the queue to start the test.
                    GarbageCollector.GcQueue.Clear();

                    blobClient = GetBlobClient("P_AgeOutGcHandler_OrphanedTableEntry");

                    Global.RO.Info("Adding new blobs to storage...");
                    DateTime lastUpdate = DateTime.UtcNow;
                    removedEntries = new List<FileTableLastUpdateEntry>();

                    for (int i = 0; i < 5; ++i)
                    {
                        var fileName = String.Format("{0}_{1:X}", TestFilePrefix, RandomEx.GlobalRandGen.NextUlong());

                        FileTableLastUpdateEntry entry;
                        var transactionId = Guid.NewGuid().ToString("N");
                        AddBlob(fileName, fileSize, lastUpdate, samlParameters.Xuid[0],
                                samlParameters.TitleID.HasValue ? samlParameters.TitleID.Value : 0,
                                transactionId, blobClient, out entry);

                        removedEntries.Add(entry);
                    }

                    // Get all the blobs currently in storage to verify they were added properly.
                    var blobList = blobClient.GetBlobList(samlParameters.TitleID.Value.ToString("x8"),
                                                          samlParameters.Xuid[0].ToString("X16"));

                    foreach (var entry in removedEntries)
                    {
                        String blobName = XlfsUtilities.GetBlobNameFromFileTableEntry(entry);
                        if (!blobList.Contains(blobName))
                        {
                            throw new UnexpectedTestResultException("Unable to find blob " + blobName);
                        }
                    }

                    // Delete one of the blobs without removing it's entry in the table.
                    RemoveBlobOnly(blobClient, removedEntries[0]);

                    base.PreRun();
                }

                public override void Run()
                {
                    // Construct the age out message.  All of the entries should have the same partition key
                    // because we used the same value of lastUpdate for all of them.
                    var msg = new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcFormat, removedEntries[0].PartitionKey));
                    GarbageCollector.GcQueue.AddMessage(msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(GarbageCollector.GcQueue.GetMessage());

                    Global.RO.Info("Handling AgeOut message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);

                    // Don't let exceptions in the handler hork the test.
                    try
                    {
                        msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_AgeOutGcHandler_MultiplePartitions"));
                    }
                    catch (Exception e)
                    {
                        throw new UnexpectedTestResultException("Handler threw an exception:\r\n{0}", e);
                    }

                    Global.RO.Info("Verifying that correct blobs were cleaned up...");
                    var blobList = blobClient.GetBlobList(samlParameters.TitleID.Value.ToString("x8"),
                                                          samlParameters.Xuid[0].ToString("X16"));

                    foreach (var entry in removedEntries)
                    {
                        String blobName = XlfsUtilities.GetBlobNameFromFileTableEntry(entry);
                        if (blobList.Contains(blobName))
                        {
                            // The blob still exists, fail the test.
                            throw new UnexpectedTestResultException("The blob was not deleted by the message handler.");
                        }

                        if (fileTableClient.SelectFile(entry.PartitionKey, entry.RowKey).Count != 0)
                        {
                            throw new UnexpectedTestResultException("File table entry was not deleted.");
                        }
                    }

                    msg = GarbageCollector.GcQueue.GetMessage();
                    if (msg == null)
                    {
                        throw new UnexpectedTestResultException("Expected to find a next partition message in the queue, but didn't.");
                    }

                    GarbageCollector.GcQueue.DeleteMessage(msg);
                }

                public override void PostRun()
                {
                    Global.RO.Debug("Cleaning up blobs in storage..");
                    RemoveBlobs(blobClient, samlParameters.TitleID, samlParameters.Xuid[0], TestFilePrefix);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\Worker\AgeOutGcCommenceTest.cs ===
using System;
using System.Xml;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using ServerTestFramework;
using ServerTestFramework.LiveService.Storage.Azure;
using xonline.server.xlfs.common;
using xonline.server.xlfs.fd.xlfsgc;
using ServerTestFramework.Utilities;

namespace Xlfs.Test
{
    [TestGroup, Owner("benran"), TestFrequency("Daily"), Description("Tests the functionality of the Xlfs Garbage Collector")]
    public partial class XlfsGc : TestNode
    {
        /// <summary>
        /// Pseudo-initialization of the GarbageCollector.  Does not
        /// perform bootstrapping.  Recommend that bootstrapping tests
        /// be put into a separate group.
        /// </summary>
        public override void PreRun()
        {
            // Initialize tracing.
            GarbageCollector.TraceFactory = new StfXlfsTraceFactory();

            // Initialize storage account.
            StorageAccountInformation tableInfo = XlfsConfiguration.XlfsTableStorage;
            var creds = new StorageCredentialsAccountAndKey(
                tableInfo.StorageAccount,
                tableInfo.StorageKey);
            GarbageCollector.StorageAccount = new CloudStorageAccount(creds, true);

            // Initialize the GarbageCollector
            // This basically does nothing because everything is automatically 
            // initialized when you set the StorageAccount
            GarbageCollector.Initialize();

            // Initialize other values.
            GarbageCollector.AgeOutGcFrequency = TimeSpan.FromMinutes(5);

            base.PreRun();
        }

        public override void PostRun()
        {
            // Clear out the storage account manager so
            // that it doesn't continue running after the 
            // tests are complete.
            GarbageCollector.StorageAccount = null;
            GarbageCollector.GcQueue = null;

            base.PostRun();
        }

        [TestGroup, Owner("benran"), TestFrequency("Daily"), Description("Tests the functionality of the AgeOutGcCommence message handler.")]
        public class AgeOutGcCommenceHandlerTest : TestNode
        {
            [TestCase, Owner("benran"), TestCasePriority(0), Description("Simple positive test case for the message handler.")]
            public class P_AgeOutGcCommenceHandler : TestNode
            {
                public override void Run()
                {
                    var queueClient = new QueueClient();

                    // Clear out the queue to start the test.
                    queueClient.CreateIfNotExist(XlfsConstants.GcQueueName);
                    queueClient.Clear(XlfsConstants.GcQueueName);

                    // Construct the age out commence message.
                    var now = DateTime.UtcNow;
                    var twoHoursAgo = now - TimeSpan.FromHours(2);
                    var partitionKey = twoHoursAgo.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString);

                    var msg =
                        new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcCommenceFormat, now.ToString("o"), partitionKey));

                    // We need to queue and dequeue the message so that it has 
                    // valid message id, pop receipt, etc.
                    queueClient.AddMessage(XlfsConstants.GcQueueName, msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(queueClient.GetMessage(XlfsConstants.GcQueueName));

                    Global.RO.Info("Handling AgeOutGcCommence message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);
                    msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_AgeOutGcCommenceHandler"));

                    // Now there should be one message in the queue:
                    // 1.  An AgeOutGc message containing the same partition key as the AgeOutGcCommence message we added.

                    CloudQueueMessage msg1 = queueClient.GetMessage(XlfsConstants.GcQueueName);

                    try
                    {
                        if (msg1 == null)
                        {
                            throw new UnexpectedTestResultException("Expected to find one message in gcqueue, but did not find any.");
                        }

                        XlfsGcMessage xlfsMsg = XlfsGcMessage.Create(msg1);
                        ValueCheck.Test("Message Name", XlfsConstants.AgeOutGcMessage, xlfsMsg.Name);

                        // At this point we know we got the expected message.
                        // Verify the partition in the AgeOutGc message.
                        var partitionFromMessage = xlfsMsg.Xml.DocumentElement.GetAttribute("partition");
                        ValueCheck.Test("Message Partition", partitionKey, partitionFromMessage);
                    }
                    finally
                    {
                        if (msg1 != null)
                        {
                            queueClient.DeleteMessage(XlfsConstants.GcQueueName, msg1);
                        }
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(0), Description("Handle a message that contains an empty nextStart attribute.")]
            public class P_AgeOutGcCommenceHandler_EmptyNextStart : TestNode
            {
                public override void Run()
                {
                    var queueClient = new QueueClient();

                    // Clear out the queue to start the test.
                    queueClient.CreateIfNotExist(XlfsConstants.GcQueueName);
                    queueClient.Clear(XlfsConstants.GcQueueName);

                    // Construct the age out commence message.
                    var now = DateTime.UtcNow;
                    var twoHoursAgo = now - TimeSpan.FromHours(2);
                    var partitionKey = twoHoursAgo.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString);

                    var msg =
                        new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcCommenceFormat, "", partitionKey));

                    // We need to queue and dequeue the message so that it has 
                    // valid message id, pop receipt, etc.
                    queueClient.AddMessage(XlfsConstants.GcQueueName, msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(queueClient.GetMessage(XlfsConstants.GcQueueName));

                    Global.RO.Info("Handling AgeOutGcCommence message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);
                    msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_AgeOutGcCommenceHandler"));

                    // Now there should be one message in the queue:
                    // 1.  An AgeOutGc message.

                    CloudQueueMessage msg1 = queueClient.GetMessage(XlfsConstants.GcQueueName);

                    try
                    {
                        if (msg1 == null)
                        {
                            throw new UnexpectedTestResultException("Expected to find one message in gcqueue, but did not find any.");
                        }

                        XlfsGcMessage xlfsMsg = XlfsGcMessage.Create(msg1);
                        ValueCheck.Test("Message Name", XlfsConstants.AgeOutGcMessage, xlfsMsg.Name);

                        // At this point we know we got the expected message.
                        // Verify the partition in the AgeOutGc message.
                        var partitionFromMessage = xlfsMsg.Xml.DocumentElement.GetAttribute("partition");
                        ValueCheck.Test("Message Partition", partitionKey, partitionFromMessage);
                    }
                    finally
                    {
                        if (msg1 != null)
                        {
                            queueClient.DeleteMessage(XlfsConstants.GcQueueName, msg1);
                        }
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(0), Description("Handle a message that contains an empty startPartition attribute.")]
            public class P_AgeOutGcCommenceHandler_EmptyStartPartition : TestNode
            {
                public override void Run()
                {
                    var queueClient = new QueueClient();

                    // Clear out the queue to start the test.
                    queueClient.CreateIfNotExist(XlfsConstants.GcQueueName);
                    queueClient.Clear(XlfsConstants.GcQueueName);

                    // Set the MinimumPartitionDateTime property on the GarbageCollector.  This is where
                    // the handler will retrieve it from.
                    GarbageCollector.MinimumPartitionDateTime = DateTime.Parse("1/1/2010");

                    // Construct the age out commence message.
                    var now = DateTime.UtcNow;

                    var msg =
                        new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcCommenceFormat, now.ToString("o"), ""));

                    // We need to queue and dequeue the message so that it has 
                    // valid message id, pop receipt, etc.
                    queueClient.AddMessage(XlfsConstants.GcQueueName, msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(queueClient.GetMessage(XlfsConstants.GcQueueName));

                    Global.RO.Info("Handling AgeOutGcCommence message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);
                    msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_AgeOutGcCommenceHandler"));

                    // Now there should be one message in the queue:
                    // 1.  An AgeOutGc message using the configured minimum partition.

                    CloudQueueMessage msg1 = queueClient.GetMessage(XlfsConstants.GcQueueName);

                    try
                    {
                        if (msg1 == null)
                        {
                            throw new UnexpectedTestResultException("Expected to find one message in gcqueue, but did not find any.");
                        }

                        XlfsGcMessage xlfsMsg = XlfsGcMessage.Create(msg1);
                        ValueCheck.Test("Message Name", XlfsConstants.AgeOutGcMessage, xlfsMsg.Name);

                        // At this point we know we got the expected message.
                        // Verify the partition in the AgeOutGc message.
                        var partitionFromMessage = xlfsMsg.Xml.DocumentElement.GetAttribute("partition");
                        string partitionKey =
                            GarbageCollector.MinimumPartitionDateTime.ToString(
                                FileTableLastUpdateEntry.PartitionKeyFormatString);

                        ValueCheck.Test("Message Partition", partitionKey, partitionFromMessage);
                    }
                    finally
                    {
                        if (msg1 != null)
                        {
                            queueClient.DeleteMessage(XlfsConstants.GcQueueName, msg1);
                        }
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(0), Description("Handle an AgeOutGcCommence message that does not have a nextStart attribute.")]
            public class P_AgeOutGcCommenceHandler_NoNextStart : TestNode
            {
                public override void Run()
                {
                    var queueClient = new QueueClient();

                    // Clear out the queue to start the test.
                    queueClient.CreateIfNotExist(XlfsConstants.GcQueueName);
                    queueClient.Clear(XlfsConstants.GcQueueName);

                    // Construct the age out commence message.
                    var now = DateTime.UtcNow;
                    var twoHoursAgo = now - TimeSpan.FromHours(2);
                    var partitionKey = twoHoursAgo.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString);
                    var msg = new CloudQueueMessage(string.Format("<AgeOutGcCommence startPartition=\"{0}\" />", partitionKey));

                    // We need to queue and dequeue the message so that it has 
                    // valid message id, pop receipt, etc.
                    queueClient.AddMessage(XlfsConstants.GcQueueName, msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(queueClient.GetMessage(XlfsConstants.GcQueueName));

                    Global.RO.Info("Handling AgeOutGcCommence message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);
                    msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_AgeOutGcCommenceHandler"));

                    // Now there should be one message in the queue:
                    // 1.  An AgeOutGc message.

                    CloudQueueMessage msg1 = queueClient.GetMessage(XlfsConstants.GcQueueName);

                    try
                    {
                        if (msg1 == null)
                        {
                            throw new UnexpectedTestResultException("Expected to find one message in gcqueue, but did not find any.");
                        }

                        XlfsGcMessage xlfsMsg = XlfsGcMessage.Create(msg1);
                        ValueCheck.Test("Message Name", XlfsConstants.AgeOutGcMessage, xlfsMsg.Name);

                        // At this point we know we got the expected message.
                        // Verify the partition in the AgeOutGc message.
                        var partitionFromMessage = xlfsMsg.Xml.DocumentElement.GetAttribute("partition");
                        ValueCheck.Test("Message Partition", partitionKey, partitionFromMessage);
                    }
                    finally
                    {
                        if (msg1 != null)
                        {
                            queueClient.DeleteMessage(XlfsConstants.GcQueueName, msg1);
                        }
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(0), Description("Handle a message that contains an empty startPartition attribute.")]
            public class P_AgeOutGcCommenceHandler_NoStartPartition : TestNode
            {
                public override void Run()
                {
                    var queueClient = new QueueClient();

                    // Clear out the queue to start the test.
                    queueClient.CreateIfNotExist(XlfsConstants.GcQueueName);
                    queueClient.Clear(XlfsConstants.GcQueueName);

                    // Construct the age out commence message.
                    var now = DateTime.UtcNow;

                    var msg = new CloudQueueMessage(string.Format("<AgeOutGcCommence nextStart=\"{0}\" />", now.ToString("o")));

                    // We need to queue and dequeue the message so that it has 
                    // valid message id, pop receipt, etc.
                    queueClient.AddMessage(XlfsConstants.GcQueueName, msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(queueClient.GetMessage(XlfsConstants.GcQueueName));

                    Global.RO.Info("Handling AgeOutGcCommence message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);
                    msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_AgeOutGcCommenceHandler"));

                    // Now there should be one message in the queue:
                    // 1.  An AgeOutGc message using the configured minimum partition.

                    CloudQueueMessage msg1 = queueClient.GetMessage(XlfsConstants.GcQueueName);

                    try
                    {
                        if (msg1 == null)
                        {
                            throw new UnexpectedTestResultException("Expected to find one message in gcqueue, but did not find any.");
                        }

                        XlfsGcMessage xlfsMsg = XlfsGcMessage.Create(msg1);
                        ValueCheck.Test("Message Name", XlfsConstants.AgeOutGcMessage, xlfsMsg.Name);

                        // At this point we know we got the expected message.
                        // Verify the partition in the AgeOutGc message.
                        var partitionFromMessage = xlfsMsg.Xml.DocumentElement.GetAttribute("partition");
                        string partitionKey =
                            GarbageCollector.MinimumPartitionDateTime.ToString(
                                FileTableLastUpdateEntry.PartitionKeyFormatString);

                        ValueCheck.Test("Message Partition", partitionKey, partitionFromMessage);
                    }
                    finally
                    {
                        if (msg1 != null)
                        {
                            queueClient.DeleteMessage(XlfsConstants.GcQueueName, msg1);
                        }
                    }
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(0), Description("Handle a message with nextStart in the future.")]
            public class P_AgeOutGcCommenceHandler_FutureNextStart : TestNode
            {
                public override void Run()
                {
                    var queueClient = new QueueClient();

                    // Clear out the queue to start the test.
                    queueClient.CreateIfNotExist(XlfsConstants.GcQueueName);
                    queueClient.Clear(XlfsConstants.GcQueueName);

                    // Construct the age out commence message.
                    var now = DateTime.UtcNow + TimeSpan.FromMinutes(5);
                    var twoHoursAgo = DateTime.UtcNow - TimeSpan.FromHours(2);
                    var partitionKey = twoHoursAgo.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString);
                    var nextStart = now.ToString("o");
                    var msg = new CloudQueueMessage(string.Format(XlfsConstants.AgeOutGcCommenceFormat, nextStart, partitionKey));

                    // We need to queue and dequeue the message so that it has 
                    // valid message id, pop receipt, etc.
                    queueClient.AddMessage(XlfsConstants.GcQueueName, msg);
                    var xlfsGcMessage = XlfsGcMessage.Create(queueClient.GetMessage(XlfsConstants.GcQueueName, TimeSpan.FromSeconds(3)));

                    Global.RO.Info("Handling AgeOutGcCommence message...");
                    IXlfsGcMessageHandler msgHandler = XlfsGcMessageUtils.GetGcMessageHandler(xlfsGcMessage.Name);
                    msgHandler.HandleMessage(xlfsGcMessage, GarbageCollector.TraceFactory.Create("P_AgeOutGcCommenceHandler"));

                    // Make sure the queue is still empty.
                    msg = queueClient.GetMessage(XlfsConstants.GcQueueName);

                    if (msg != null)
                    {
                        queueClient.DeleteMessage(XlfsConstants.GcQueueName, msg);
                        throw new UnexpectedTestResultException("Message Queue not empty as expected");
                    }
                    Global.RO.Info("Message queue empty as expected.  Waiting 3s for AgeOutCommenceGc message to be visible again...");
                    // Since we set the visibility time to 5 seconds wait 
                    // until the message should be visible again and check 
                    // that it's the right one
                    System.Threading.Thread.Sleep(3000);

                    XlfsGcMessage xlfsMsg = XlfsGcMessage.Create(queueClient.GetMessage(XlfsConstants.GcQueueName));
                    ValueCheck.Test("Message Name", XlfsConstants.AgeOutGcCommenceMessage, xlfsMsg.Name);
                    ValueCheck.Test("Next Start", nextStart, xlfsMsg.Xml.DocumentElement.Attributes["nextStart"].Value);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\testfd\XlfsTestFD\Default.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace xonline.server.xlfs.fd.xlfstestfd
{
    public partial class _Default : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\Worker\BootstrapTest.cs ===
using System.Collections.Generic;
using System.Linq;
using Microsoft.WindowsAzure.StorageClient;
using ServerTestFramework;
using xonline.server.xlfs.common;
using xonline.server.xlfs.fd.xlfsgc;

namespace Xlfs.Test
{
    public partial class XlfsGc
    {
        [TestGroup, Owner("benran"), TestFrequency("Daily"), Description("Tests the functionality of the garbage collector bootstrap/startup functionality.")]
        public class BootstrapTest : TestNode
        {
            [TestCase, Owner("benran"), TestCasePriority(1), Description("Simple positive test case for the bootstrap process.")]
            public class P_Bootstrap : TestNode
            {
                public override void Run()
                {
                    // Make sure that the queue is empty.
                    GarbageCollector.GcQueue.Clear();

                    // Bootstrap
                    GarbageCollector.BootStrap();

                    // Collect messages until the queue is empty.
                    var messages = new List<XlfsGcMessage>();

                    do
                    {
                        CloudQueueMessage msg = GarbageCollector.GcQueue.GetMessage();
                        if(msg == null) break;

                        XlfsGcMessage xlfsGcMessage = XlfsGcMessage.Create(msg);

                        messages.Add(xlfsGcMessage);
                    } 
                    while (true);

                    // Verify the queue contents.
                    if (messages.Count != 1)
                    {
                        throw new UnexpectedTestResultException("Wrong number of messages found in queue after BootStrap().");
                    }

                    // Make sure one of the messages we got an AgeOutGcCommence.
                    bool found = messages.Any(message => message.Name == XlfsConstants.AgeOutGcCommenceMessage);
                    if(!found)
                    {
                        throw new UnexpectedTestResultException("Did not find an AgeOutGcCommence message in the queue after BootStrap().");
                    }

                    // Delete all messages from the queue.
                    foreach(var message in messages)
                    {
                        GarbageCollector.GcQueue.DeleteMessage(message.Message);
                    }
                }  
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Multiple garbage collectors bootstrapping simultaneously")]
            public class N_InvalidMessage : TestNode
            {
                public override void PreRun()
                {
                    StfXlfsTrace.ThrowOnError = true;
                }

                public override void Run()
                {
                    // Make sure that the queue is empty.
                    GarbageCollector.GcQueue.Clear();

                    // Rogue bootstrapper, posts an invalid message to the queue
                    string ageOutGcCommenceMessage = "This is NOT a valid AgeOutGcCommence message";
                    GarbageCollector.GcQueue.AddMessage(new CloudQueueMessage(ageOutGcCommenceMessage));

                    // Second GC instance attempts to bootstrap
                    // This should succeed, it should catch the invalid message, 
                    // and handle it appropriately
                    GarbageCollector.BootStrap();
                }

                public override void PostRun()
                {
                    StfXlfsTrace.ThrowOnError = false;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\Worker\XlfsGcMessageTests.cs ===
using System;
using System.Xml;
using Microsoft.WindowsAzure.StorageClient;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.server.xlfs.common;

namespace Xlfs.Test
{
    public partial class XlfsGc
    {
        [TestGroup, Owner("benran"), TestFrequency("Daily"), Description("Tests the functionality of the XlfsGcMessage class.")]
        public class XlfsGcMessageTests : TestNode
        {
            [TestCase, Owner("benran"), TestCasePriority(1), Description("Simple positive test case for the message handler.")]
            public class P_XlfsGcMessage : TestNode
            {
                public override void Run()
                {
                    string messageBody = string.Format(XlfsConstants.AgeOutGcFormat, "2010:11:1:0");
                    var msg = new CloudQueueMessage(messageBody);
                    XlfsGcMessage xlfsGcMessage = XlfsGcMessage.Create(msg);

                    ValueCheck.Test("Message Name", XlfsConstants.AgeOutGcMessage, xlfsGcMessage.Name);
                    ValueCheck.Test("Message Body", messageBody, xlfsGcMessage.Message.AsString);
                    ValueCheck.Test("Message Xml", messageBody, xlfsGcMessage.Xml.OuterXml);
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Simple positive test case for the message handler.")]
            public class N_XlfsGcMessage_NullMessage : TestNode
            {
                public override void Run()
                {
                    try
                    {
                        XlfsGcMessage.Create(null);
                    }
                    catch (ArgumentException)
                    {
                        return;
                    }

                    throw new UnexpectedTestResultException("Create message succeeded unexpectedly");
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Simple positive test case for the message handler.")]
            public class N_XlfsGcMessage_NullMessageBody : TestNode
            {
                public override void Run()
                {
                    try
                    {
                        var msg = new CloudQueueMessage((string)null);

                        XlfsGcMessage.Create(msg);
                    }
                    catch (ArgumentException)
                    {
                        return;
                    }

                    throw new UnexpectedTestResultException("Create message succeeded unexpectedly");
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Simple positive test case for the message handler.")]
            public class N_XlfsGcMessage_EmptyMessageBody : TestNode
            {
                public override void Run()
                {
                    try
                    {
                        var msg = new CloudQueueMessage("");
                        XlfsGcMessage.Create(msg);
                    }
                    catch (ArgumentException)
                    {
                        return;
                    }

                    throw new UnexpectedTestResultException("Create message succeeded unexpectedly");
                }
            }

            [TestCase, Owner("benran"), TestCasePriority(2), Description("Simple positive test case for the message handler.")]
            public class N_XlfsGcMessage_NoXmlInMessageBody : TestNode
            {
                public override void Run()
                {
                    try
                    {
                        var msg = new CloudQueueMessage("This is not XML");
                        XlfsGcMessage.Create(msg);
                    }
                    catch (XmlException)
                    {
                        return;
                    }

                    throw new UnexpectedTestResultException("Create message succeeded unexpectedly");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\test\Tools\HealthcheckModule.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework.Utilities;
using ServerTestFramework;
using System.Diagnostics;
using xonline.common.service;
using System.Xml.Linq;
using System.IO;

namespace Xlfs.Test
{
    public class XlfsMonTestHelper
    {
        public static readonly String XlfsMonPath = @".\xlfsmon.exe";
        public static readonly String XlfsMonEventSource = "SCOM_XLFS_MONITOR";

        public static String DefaultClientFd { get { return XlfsTestSettings.Current.XlfsClientServer.ToString(); } }
        public static String DefaultAdminFd { get { return XlfsTestSettings.Current.XlfsAdminServer.ToString(); } }

        public static Dictionary<XEvent.Id, String> eventNameMap = new Dictionary<XEvent.Id, string>();

        static XlfsMonTestHelper()
        {
            // Since multiple events can have the same event ID, this map is 
            // used to print out nice names since the enum names will not match
            // if there is another event with the same value
            eventNameMap[XEvent.Id.XLFS_MON_SUCCEEDED] = "XLFS_MON_SUCCEEDED";
            eventNameMap[XEvent.Id.XLFS_MON_SAML_FAILED] = "XLFS_MON_SAML_FAILED";
            eventNameMap[XEvent.Id.XLFS_MON_UPLOAD_BEGIN_FAILED] = "XLFS_MON_UPLOAD_BEGIN_FAILED";
            eventNameMap[XEvent.Id.XLFS_MON_XLFS_SYNC_FAILED] = "XLFS_MON_XLFS_SYNC_FAILED";
            eventNameMap[XEvent.Id.XLFS_MON_UPLOAD_END_FAILED] = "XLFS_MON_UPLOAD_END_FAILED";
            eventNameMap[XEvent.Id.XLFS_MON_DOWNLOAD_START_FAILED] = "XLFS_MON_DOWNLOAD_START_FAILED";
            eventNameMap[XEvent.Id.XLFS_MON_DOWNLOAD_FAILED] = "XLFS_MON_DOWNLOAD_FAILED";
            eventNameMap[XEvent.Id.XLFS_MON_DOWNLOAD_FILE_NOT_FOUND] = "XLFS_MON_DOWNLOAD_FILE_NOT_FOUND";
            eventNameMap[XEvent.Id.XLFS_MON_DOWNLOAD_FILE_NOT_DELETED] = "XLFS_MON_DOWNLOAD_FILE_NOT_DELETED";
            eventNameMap[XEvent.Id.XLFS_MON_DOWNLOAD_ADMIN_DEFAULT_PAGE_FAILED] = "XLFS_MON_DOWNLOAD_ADMIN_DEFAULT_PAGE_FAILED";
            eventNameMap[XEvent.Id.XLFS_MON_DOWNLOAD_CLIENT_DEFAULT_PAGE_FAILED] = "XLFS_MON_DOWNLOAD_CLIENT_DEFAULT_PAGE_FAILED";
            eventNameMap[XEvent.Id.XLFS_INTERNAL_FAILURE] = "XLFS_INTERNAL_FAILURE";
        }

        private Events eventWatcher;
        public Events EventWatcher { get { return eventWatcher; } }

        private String environment;
        /// <summary>
        /// Overrides the string to use during eventing
        /// </summary>
        public String Environment
        {
            get { return environment; }
            set { environment = value; }
        }

        private String clientFd;
        /// <summary>
        /// Specifies the name of the XlfsFd Client URL
        /// </summary>
        public String ClientFd
        {
            get { return clientFd; }
            set { clientFd = value; }
        }

        private String adminFd;
        /// <summary>
        /// Specifies the name of the XlfsAdminFd URL
        /// </summary>
        public String AdminFd
        {
            get { return adminFd; }
            set { adminFd = value; }
        }

        private String certificate;
        /// <summary>
        /// Specifies the full subject name of the Cert required by the AdminFD
        /// </summary>
        public String Certificate
        {
            get { return certificate; }
            set { certificate = value; }
        }

        private String thumbprint;
        /// <summary>
        /// Specifies the thumbprint of the Cert required by the AdminFD
        /// </summary>
        public String Thumbprint
        {
            get { return thumbprint; }
            set { thumbprint = value; }
        }

        private String saveDirectory;
        /// <summary>
        ///         Specifies the location of the temporary files
        /// </summary>
        public String SaveDirectory
        {
            get { return saveDirectory; }
            set { saveDirectory = value; }
        }

        private String downloaderPath;
        /// <summary>
        /// Specifies where to find XlfsConsoleDownloader.exe
        /// </summary>
        public String DownloaderPath
        {
            get { return downloaderPath; }
            set { downloaderPath = value; }
        }

        /// <summary>
        /// Specifies a proxy server to use for the request
        /// </summary>
        public String Proxy { get; set; }

        /// <summary>
        /// Specifieds if the default proxy on the machine is used
        /// </summary>
        public Boolean MachineProxy { get; set; }

        /// <summary>
        /// Indicates if XlfsMon should dump all it's output to the console
        /// </summary>
        public Boolean Verbose { get; set; }

        /// <summary>
        /// Indicates if XlfsMon should use a real SAML token generated by STS
        /// </summary>
        /// <remarks>If true, REQUIRES working LIVE Service to connect to</remarks>
        public Boolean UseRealSAML { get; set; }

        public String Arguments
        {
            get
            {
                StringBuilder sb = new StringBuilder();

                if (!String.IsNullOrEmpty(environment))
                {
                    sb.AppendFormat("-environment {0} ", environment);
                }

                if (!String.IsNullOrEmpty(clientFd))
                {
                    sb.AppendFormat("-clientfd {0} ", clientFd);
                }

                if (!String.IsNullOrEmpty(adminFd))
                {
                    sb.AppendFormat("-adminfd {0} ", adminFd);
                }

                if (!String.IsNullOrEmpty(certificate))
                {
                    sb.AppendFormat("-certificate \"{0}\" ", certificate);
                }

                if (!String.IsNullOrEmpty(thumbprint))
                {
                    sb.AppendFormat("-thumbprint {0} ", thumbprint);
                }

                if (!String.IsNullOrEmpty(saveDirectory))
                {
                    sb.AppendFormat("-savedirectory \"{0}\" ", saveDirectory);
                }

                if (!String.IsNullOrEmpty(downloaderPath))
                {
                    sb.AppendFormat("-downloaderpath \"{0}\" ", downloaderPath);
                }

                if (!String.IsNullOrEmpty(Proxy))
                {
                    sb.AppendFormat("-proxy \"{0}\" ", Proxy);
                }

                if (MachineProxy)
                {
                    sb.AppendFormat("-machineproxy ");
                }

                if (Verbose)
                {
                    sb.AppendFormat("-verbose ");
                }

                if (UseRealSAML)
                {
                    sb.AppendFormat("-realsaml ");
                }

                return sb.ToString();
            }
        }

        public XlfsMonTestHelper()
        {
            eventWatcher = new Events(new String[] { "Localhost" });
            eventWatcher.Source = XlfsMonEventSource;
        }

        public void PreRun()
        {
            clientFd = DefaultClientFd;
            adminFd = DefaultAdminFd;

            certificate = DownloaderTestHelper.DefaultCertificateSubject;
            saveDirectory = DownloaderTestHelper.DefaultSaveDirectory;
            downloaderPath = "./";//DownloaderTestHelper.XlfsConsoleDownloaderPath;

            eventWatcher.Init();
        }

        public void Execute()
        {
            Execute(XEvent.Id.XLFS_MON_SUCCEEDED, Arguments);
        }

        public void Execute(XEvent.Id expectedEvent)
        {
            Execute(expectedEvent, Arguments);
        }

        public void Execute(XEvent.Id expectedEvent, String arguments)
        {
            Int32 expectedResult = 0;
            Global.RO.Info("Running XlfsMon...");
            Int32 result = RunXlfsMon(arguments);

            // Do some basic validation
            ValueCheck.Test("XlfsMon Return Code", expectedResult, result);
            Global.RO.Success("Got expected return code: " + result);

            if (expectedResult == 0)
            {
                if (!eventWatcher.TestForChange((Int64)expectedEvent, true))
                {
                    throw new UnexpectedTestResultException(
                        String.Format("Unable to find event {0} in event log.", eventNameMap[expectedEvent]));
                }
                else
                {
                    Global.RO.Success("Found expected event {0} in event log.", eventNameMap[expectedEvent]);
                }
            }
        }

        public static Int32 RunXlfsMon(String arguments)
        {
            String output = String.Empty;
            Int32 exitCode = RunXlfsMon(arguments, out output);

            if (!String.IsNullOrEmpty(output))
            {
                Global.RO.Info("Output: {0}", output);
            }

            return exitCode;
        }

        public static Int32 RunXlfsMon(String arguments, out String output)
        {
            Process xlfsMonProc = new Process();
            xlfsMonProc.StartInfo = new ProcessStartInfo(XlfsMonPath, arguments);
            xlfsMonProc.StartInfo.UseShellExecute = false;
            xlfsMonProc.StartInfo.CreateNoWindow = true;
            xlfsMonProc.StartInfo.RedirectStandardOutput = true;
            //downloadProc.StartInfo.RedirectStandardError = true;

            Global.RO.Info("Running XLFS Downloader.");
            Global.RO.Debug("Arguments: " + arguments);

            if (!xlfsMonProc.Start())
            {
                output = xlfsMonProc.StandardOutput.ReadToEnd();
                throw new UnexpectedTestResultException("Unable to start XlfsMon. " + output);
            }

            output = xlfsMonProc.StandardOutput.ReadToEnd().Trim();

            if (!xlfsMonProc.HasExited)
            {
                xlfsMonProc.WaitForExit(5000);
                if (!xlfsMonProc.HasExited)
                {
                    xlfsMonProc.Kill();
                }
            }

            return xlfsMonProc.ExitCode;
        }
    }

    [TestGroup, Description("Test cases to verify the functionality of the XLFS SCOM Healthcheck Module")]
    [Owner("BenRan"), TestFrequency("Regression")]
    public class XlfsMon : TestNode
    {
        public override void PreRun()
        {
            // Let's ensure that the default save directory exists
            if (!Directory.Exists(DownloaderTestHelper.DefaultSaveDirectory))
            {
                Directory.CreateDirectory(DownloaderTestHelper.DefaultSaveDirectory);
            }
        }

        [TestCase, Description("Run the healthcheck module and expect success")]
        [TestCasePriority(0)]
        public class P_BVT : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, Description("Run the healthcheck module against an invalid Client FD")]
        [TestCasePriority(2)]
        public class N_InvalidClientFD : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.ClientFd = "http://not.avalidserv.er";
            }

            public override void Run()
            {
                helper.Execute(XEvent.Id.XLFS_MON_UPLOAD_BEGIN_FAILED);
            }
        }

        [TestCase, Description("Run the healthcheck module and and force the SAML token generation to fail")]
        // This test must be run manually right now because we don't have an easy 
        // method of fault injection
        [EnvRequirement("Manual")]
        [TestCasePriority(1)]
        public class N_GenerateSamlTokenFailed : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                System.Diagnostics.Debugger.Break();
                helper.Execute(XEvent.Id.XLFS_MON_SAML_FAILED);
            }
        }

        [TestCase, Description("Run the healthcheck module and force UploadBegin to fail")]
        // This test must be run manually right now because we don't have an easy 
        // method of fault injection
        [EnvRequirement("Manual")]
        [TestCasePriority(1)]
        public class N_UploadBeginFailed : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                System.Diagnostics.Debugger.Break();
                helper.Execute(XEvent.Id.XLFS_MON_UPLOAD_BEGIN_FAILED);
            }
        }

        [TestCase, Description("Run the healthcheck module and and force the file upload to fail")]
        // This test must be run manually right now because we don't have an easy 
        // method of fault injection
        [EnvRequirement("Manual")]
        [TestCasePriority(1)]
        public class N_UploadFileFailed : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                System.Diagnostics.Debugger.Break();
                helper.Execute(XEvent.Id.XLFS_MON_XLFS_SYNC_FAILED);
            }
        }

        [TestCase, Description("Run the healthcheck module and and force UploadEnd to fail")]
        // This test must be run manually right now because we don't have an easy 
        // method of fault injection
        [EnvRequirement("Manual")]
        [TestCasePriority(1)]
        public class N_UploadEndFailed : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                System.Diagnostics.Debugger.Break();
                helper.Execute(XEvent.Id.XLFS_MON_UPLOAD_END_FAILED);
            }
        }

        [TestCase, Description("Run the healthcheck module against an invalid Server FD")]
        [TestCasePriority(2)]
        public class N_InvalidServerFD : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.AdminFd = "http://not.avalidAdminServ.er";
            }

            public override void Run()
            {
                helper.Execute(XEvent.Id.XLFS_MON_DOWNLOAD_ADMIN_DEFAULT_PAGE_FAILED);
            }
        }
        
        [TestCase, Description("Run the healthcheck module with an invalid downloder path")]
        [TestCasePriority(2)]
        public class N_InvalidXlfsDownloaderPath : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.DownloaderPath = @"X:\XlfsTools\NotTheDownloader.exe";
            }

            public override void Run()
            {
                String output;
                XlfsMonTestHelper.RunXlfsMon(helper.Arguments, out output);

                Global.RO.Debug(output);
                ValueCheck.IsTrue(output.Contains("Error: "), "XlfsMon did not indicate that the path was incorrect.");
                Global.RO.Success("Expected XlfsMon error returned.");
            }
        }

        [TestCase, Description("Run the healthcheck module and provide a certificate thumbprint")]
        [TestCasePriority(2)]
        public class P_CertificateByThumbprint : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.Certificate = null;
                // This is the thumbprint of the same certificate used by default
                helper.Thumbprint = "919117671C40BEC33482E3B292F9875ECDAD27E4";
            }

            public override void Run()
            {
                helper.Execute(XEvent.Id.XLFS_MON_SUCCEEDED);
            }
        }

        [TestCase, Description("Run the healthcheck module and provide and invalid certificate subject")]
        [TestCasePriority(2)]
        public class N_InvalidCertificateSubject : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.Certificate = "CN=MyAwesomeHackingCert OU=ImAwesome A=YourHouse";
            }

            public override void Run()
            {
                String output = null;
                XlfsMonTestHelper.RunXlfsMon(helper.Arguments, out output);

                ValueCheck.IsTrue(output.Contains("Error: -certificate"), "XLFSMon output did not contain expected error");
                //helper.Execute(XEvent.Id.XLFS_MON_DOWNLOAD_FAILED);
            }
        }

        [TestCase, Description("Run the healthcheck module and provide and invalid certificate thumbprint")]
        [TestCasePriority(2)]
        public class N_InvalidCertificateThumbprint : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.Certificate = null;
                helper.Thumbprint = "919117671CBAADFOODDOODFFFFF9875ECDAD27E4";
            }

            public override void Run()
            {
                String output = null;
                XlfsMonTestHelper.RunXlfsMon(helper.Arguments, out output);

                ValueCheck.IsTrue(output.Contains("Error: -thumbprint"), "XLFSMon output did not contain expected error");
            }
        }

        [TestCase, Description("Run the healthcheck module and provide an environment name")]
        [TestCasePriority(2)]
        public class P_EnvironmentName : TestNode
        {
            private static readonly String TestEnvironmentName = "AOEU_TestEnvironment_AOEU";
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                // This will make it fail quickly, then we can just check the 
                helper.ClientFd = "http://invalidserver.example.com";
                helper.Environment = TestEnvironmentName;
            }

            public override void Run()
            {
                DateTime startTime = DateTime.Now;
                helper.Execute(XEvent.Id.XLFS_MON_UPLOAD_BEGIN_FAILED);

                try
                {
                    Global.RO.Info("Searching eventlog for event with environment name...");
                    EventLog eventLog = new EventLog("Application", "localhost", XlfsMonTestHelper.XlfsMonEventSource);
                    EventLogEntry entry = eventLog.Entries.Cast<EventLogEntry>().First(
                        e =>
                            e.TimeGenerated >= startTime &&
                            e.Source == XlfsMonTestHelper.XlfsMonEventSource &&
                            e.InstanceId == XEvent.MessageFromId(XEvent.Id.XLFS_MON_UPLOAD_BEGIN_FAILED) &&
                            e.Message.Contains("xlfsmon-environment: " + TestEnvironmentName));

                    Global.RO.Success("Found event with evironment name.");
                }
                catch(Exception)
                {
                    throw new UnexpectedTestResultException(
                        String.Format("No event found that contains the expected test environment name {0}.", TestEnvironmentName));
                }
            }
        }

        [TestCase, Description("Run the healthcheck module and cause the downloder to fail")]
        [TestCasePriority(2), EnvRequirement("Manual")]
        public class N_DownloadFailed : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
            }

            public override void Run()
            {
                Debugger.Break();
                helper.Execute(XEvent.Id.XLFS_MON_DOWNLOAD_FAILED);
            }
        }

        [TestCase, Description("Run the healthcheck module through a proxy server and expect success")]
        [TestCasePriority(1)]
        public class P_ProxyServer : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                System.Net.WebProxy proxy = new System.Net.WebProxy("http://itgproxy.redmond.corp.microsoft.com:80/");
                helper.Proxy = proxy.Address.ToString();
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, Description("Run the healthcheck module with an invalid proxy")]
        [TestCasePriority(2)]
        public class N_InvalidProxyServer : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.Proxy = "http://proxy.yourmom.org:1234";
            }

            public override void Run()
            {
                helper.Execute(XEvent.Id.XLFS_MON_UPLOAD_BEGIN_FAILED);
            }
        }

        [TestCase, Description("Run the healthcheck module using the machine proxy")]
        [TestCasePriority(1), EnvRequirement("Manual")]
        public class P_MachineProxy : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.MachineProxy = true;
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, Description("Run the healthcheck module and request a real SAML token from STS")]
        [TestCasePriority(1)]
        public class P_RealSamlToken : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.UseRealSAML = true;
            }

            public override void Run()
            {
                helper.Execute();
            }
        }

        [TestCase, Description("Run the healthcheck module with the verbose flag")]
        [TestCasePriority(2)]
        public class P_Verbose : TestNode
        {
            private XlfsMonTestHelper helper = new XlfsMonTestHelper();

            public override void PreRun()
            {
                helper.PreRun();
                helper.Verbose = true;
            }

            public override void Run()
            {
                // This will dump all the output
                helper.Execute();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\testfd\XlfsTestFD\Default.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.server.xlfs.fd.xlfstestfd {
    
    
    public partial class _Default {
        
        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\testfd\XlfsTestFD\xlfsTestRequest.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Web;
using System.Xml.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.ServiceRuntime;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfstestfd
{
    /// <summary>
    /// This handler is used for writing large numbers of entries to the
    /// FileTable for use in Performance/Stress testing the Admin FD APIs
    /// </summary>
    public class TestRequest
    {
        protected readonly CloudStorageAccount storageAccount;
        protected readonly CloudStorageAccount publicStorageAccount;

        public TestRequest()
        {
            // This code sets up a handler to update CloudStorageAccount instances when their corresponding
            // configuration settings change in the service configuration file.
            CloudStorageAccount.SetConfigurationSettingPublisher((configName, configSetter) =>
            {
                // Provide the configSetter with the initial value
                configSetter(RoleEnvironment.GetConfigurationSettingValue(configName));

                RoleEnvironment.Changed += (sender, arg) =>
                {
                    if (arg.Changes.OfType<RoleEnvironmentConfigurationSettingChange>()
                        .Any(change => (change.ConfigurationSettingName == configName)))
                    {
                        // The corresponding configuration setting has changed, propagate the value
                        if (!configSetter(RoleEnvironment.GetConfigurationSettingValue(configName)))
                        {
                            // In this case, the change to the storage account credentials in the
                            // service configuration is significant enough that the role needs to be
                            // recycled in order to use the latest settings. (for example, the 
                            // endpoint has changed)
                            RoleEnvironment.RequestRecycle();
                        }
                    }
                };
            });

            storageAccount = CloudStorageAccount.FromConfigurationSetting("StorageConnectionString");
            publicStorageAccount = CloudStorageAccount.FromConfigurationSetting("PublicStorageConnectionString");
        }

        /// <summary>
        /// Determine what the titleid and start/end dates are based upon the request
        /// </summary>
        /// <param name="request"></param>
        /// <param name="titleId"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <returns></returns>
        protected static bool GetParametersFromRequest(
                HttpContext context, 
            out int         titleId,
            out DateTime    startDate, 
            out DateTime    endDate
            )
        {
            context.WriteInfoLine("TestRequest.GetParametersFromRequest: Enter");

            // Make the compiler happy
            startDate = DateTime.UtcNow.AddDays(-1);
            endDate = DateTime.UtcNow;
            titleId = unchecked((int)0xFFFE07D1);

            try
            {
                HttpRequest request = context.Request;

                string startString = request.QueryString["start"];
                string endString = request.QueryString["end"];

                // Parse the StartDate safely. If an error occured or it wasn't
                // present in the list of arguments, then assume yesterday.
                if (string.IsNullOrEmpty(startString) != false ||
                    DateTime.TryParse(startString, out startDate) == false)
                {
                    context.WriteWarningLine("TestRequest.GetParametersFromRequest: start parameter not specified, using -1 days");
                    startDate = DateTime.UtcNow.AddDays(-1);
                }

                // Parse the EndDate safely. If an error occured or it wasn't
                // present in the list of arguments, then assume right now.
                if (string.IsNullOrEmpty(endString) != false ||
                    DateTime.TryParse(endString, out endDate) == false)
                {
                    context.WriteWarningLine("TestRequest.GetParametersFromRequest: end parameter not specified, using now");
                    endDate = DateTime.UtcNow;
                }

                // Parse the titleid safely. If an error occured or it wasn't
                // present in the list of arguments, then assume the
                // default titleid
                if (GetParametersFromRequest(context, out titleId) == false)
                {
                    return false;
                }

                // Make sure that we don't have reversed start and end dates
                if (startDate > endDate)
                {
                    return false;
                }

                // Check to see that the end date and start date both occur in 2010 or higher
                if (startDate.Year < 2010 || endDate.Year < 2010)
                {
                    context.WriteErrorLine("TestRequest.GetParametersFromRequest: StartDate or EndDate before 2010");
                    return false;
                }

                // Success
                return true;
            }
            catch
            {
                context.WriteErrorLine("TestRequest.GetParametersFromRequest: Exception Occured");

                // Fail the call
                return false;
            }
            finally
            {
                context.WriteInfoLine("TestRequest.GetParametersFromRequest: Exit");
            }
        }

        /// <summary>
        /// Determine what the titleid and start/end dates are based upon the request
        /// </summary>
        /// <param name="request"></param>
        /// <param name="titleId"></param>
        /// <returns></returns>
        protected static bool GetParametersFromRequest(
                HttpContext context,
            out int         titleId
            )
        {
            context.WriteInfoLine("TestRequest.GetParametersFromRequest: Enter");

            try
            {
                HttpRequest request = context.Request;

                string titleString = request.QueryString["titleid"];

                // Parse the titleid safely. If an error occured or it wasn't
                // present in the list of arguments, then assume the
                // default titleid
                if (string.IsNullOrEmpty(titleString) != false ||
                    int.TryParse(titleString, NumberStyles.HexNumber, null, out titleId) == false ||
                    titleId == 0)
                {
                    context.WriteErrorLine("TestRequest.GetParametersFromRequest: title parameter not specified or unparseable");
                    titleId = unchecked((int)0xFFFE07D1);
                    return false;
                }

                // Success
                return true;
            }
            catch
            {
                context.WriteErrorLine("TestRequest.GetParametersFromRequest: Exception Occured");
                titleId = unchecked((int)0xFFFE07D1);
                return false;
            }
            finally
            {
                context.WriteInfoLine("TestRequest.GetParametersFromRequest: Exit");
            }
        }

        protected static bool SecurityCheck(
            HttpContext context
            )
        {
            context.WriteInfoLine("TestRequest.SecurityCheck: Enter");

            try
            {
                HttpRequest request = context.Request;

                // Is the check for requests disabled on this server?
                if (WebRole.ClientCertificateRequired == false)
                {
                    return true;
                }

                // No? Get the client the certificate from the request and
                // make sure that it matches the ones in the allow list
                HttpClientCertificate clientCert = request.ClientCertificate;
                string subject = clientCert.Subject;

                foreach (string s in WebRole.ClientCertificateSubjects)
                {
                    if (s == subject)
                    {
                        return true;
                    }
                }
                context.WriteWarningLine(
                    string.Format(
                        "TestRequest.SecurityCheck: Unrecognized subject {0}",
                        subject
                        ));
                return false;
            }
            catch
            {
                context.WriteErrorLine("TestRequest.Security Check: Exception Occured");
                return false;
            }
            finally
            {
                context.WriteInfoLine("TestRequest.SecurityCheck: Exit");
            }
        }

        /// <summary>
        /// Determine what the file count and xuid are based upon the request
        /// A zero or no xuid indicates a random value should be used.
        /// </summary>
        /// <param name="request"></param>
        /// <param name="fileCount"></param>
        /// <returns></returns>
        protected static bool GetParametersFromRequest(
            HttpContext context,
            out uint        fileCount,
            out ulong       userXuid
            )
        {
            context.WriteInfoLine("TestRequest.GetParametersFromRequest: Enter");

            try
            {
                HttpRequest request = context.Request;

                string fileCountString = request.QueryString["files"];
                string userXuidString = request.QueryString["xuid"];

                // Parse the fileCount safely. If an error occured or it wasn't
                // present in the list of arguments, then assume the
                // default 1
                if (string.IsNullOrEmpty(fileCountString) != false ||
                    uint.TryParse(fileCountString, out fileCount) == false ||
                    fileCount == 0)
                {
                    context.WriteErrorLine("TestRequest.GetParametersFromRequest: fileCount parameter not specified or unparseable");
                    fileCount = 1;
                }

                // Parse the userXuid safely. If an error occured or it wasn't
                // present in the list of arguments, then assume the
                // default 0 (i.e. random userXuids)
                if (string.IsNullOrEmpty(userXuidString) != false ||
                    ulong.TryParse(userXuidString, NumberStyles.HexNumber, null, out userXuid) == false)
                {
                    context.WriteErrorLine("TestRequest.GetParametersFromRequest: userXuid parameter not specified or unparseable");
                    userXuid = 0;
                }

                // Success
                return true;
            }
            catch
            {
                context.WriteErrorLine("TestRequest.GetParametersFromRequest: Exception Occured");
                fileCount = 1;
                userXuid = 0;
                return false;
            }
            finally
            {
                context.WriteInfoLine("TestRequest.GetParametersFromRequest: Exit");
            }
        }

        /// <summary>
        /// Class Wrapper for the Asynchronous writing of large FileTableEntries
        /// to the FileTable. To avoid long response times in the Client front door
        /// a separate thread to do the work. A later call can check the result and
        /// get the ExecutionTime (for debug and performance use).
        /// </summary>
        public class XlfsWriteTestFiles
        {
            //User Creation properties
            public DateTime StartDate;
            public DateTime EndDate;
            public int TitleId;
            public uint FileCount;
            public ulong UserXuid;

            //Tracking properties
            public DateTime WriteStartTime; //Used to track for cleaning up
            public TimeSpan ExecutionTime;
            public bool WriteComplete = false;
            public bool WriteSucceeded = false;
            public string ErrorString = "";

            public void CreateFilesThread()
            {
                WriteStartTime = DateTime.UtcNow;

                try
                {
                    // Create the data source object
                    FileTableLastUpdateDataSource dataSource = new FileTableLastUpdateDataSource();
                    Random randGen = new Random((int)DateTime.Now.Ticks);

                    //Calculate the TimeSpan so we can randomly write the files inside the timespan
                    // by using Random % TimeSpan.TotalMinutes
                    TimeSpan fileTimeRange;
                    DateTime startDate = StartDate; //New StartDate in case the StartDate and EndDate were flipped
                    if (StartDate > EndDate)
                    {
                        startDate = EndDate;
                        fileTimeRange = StartDate - EndDate;
                    }
                    else
                    {
                        fileTimeRange = EndDate - StartDate;
                    }
                    double fileTimeGap = fileTimeRange.TotalMinutes;
                    WriteSucceeded = true;

                    //Write Files
                    for (uint fileIter = 0; fileIter < FileCount; fileIter++)
                    {
                        FileTableLastUpdateEntry fileEntry = new FileTableLastUpdateEntry();
                        fileEntry.UserXuid = unchecked((long)GetUserXuid(randGen));
                        fileEntry.TitleId = TitleId;
                        fileEntry.Filename = String.Format("Xlfs_BulkTestFile_{0:hhmmssffff}.bin", DateTime.UtcNow);
                        fileEntry.TransactionId = Guid.NewGuid().ToString("N");
                        fileEntry.StorageAccount = "fakestorageaccount";
                        fileEntry.Size = 0;
                        double randomTime = System.Math.Abs(randGen.NextDouble()) % fileTimeGap;
                        fileEntry.Created = startDate.AddMinutes(randomTime);
                        fileEntry.LastUpdate = fileEntry.Created;
                        fileEntry.PartitionKey = fileEntry.LastUpdate.Value.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString);
                        fileEntry.RowKey = String.Format(
                            FileTableLastUpdateEntry.RowKeyFormatString,
                            fileEntry.TitleId.ToString(FileTableLastUpdateEntry.TitleIdFormatString),
                            fileEntry.UserXuid.ToString(FileTableLastUpdateEntry.XuidFormatString),
                            fileEntry.Filename);
                        try
                        {
                            dataSource.AddFileTableEntry(fileEntry);
                        }
                        catch(Exception ex)
                        {
                            WriteSucceeded = false;
                            ErrorString = ex.ToString();
                        }
                    }
                }
                catch(Exception ex)
                {
                    ErrorString = ex.ToString();
                }
                ExecutionTime = DateTime.UtcNow - WriteStartTime;
                WriteComplete = true;
            }

            protected ulong GetUserXuid(Random randGen)
            {
                ulong randomXuid = UserXuid;
                if (UserXuid == 0)
                {
                    // Copied from STF.Core.Utilities.RandomEx.NextPuid()
                    randomXuid = (ulong)(randGen.NextDouble() * 5000000000) + (ulong)0x9500000000000; ;
                }
                return randomXuid;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\testfd\XlfsTestFD\xlfsTestIsWriteFileEntriesComplete.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Net;
using System.Web;
using System.Xml.Linq;
using System.Threading;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfstestfd
{
    /// <summary>
    /// This handler returns an enumeration of files from file storage
    /// that match the given criteria
    /// </summary>
    public class xlfsTestIsWriteFileEntriesComplete : TestRequest, IHttpHandler
    {
        #region Constructors

        #endregion

        /// <summary>
        /// You will need to configure this handler in the web.config file of your
        /// web and register it with IIS before being able to use it. For more information
        /// see the following link: http://go.microsoft.com/?linkid=8101007
        /// </summary>
        #region IHttpHandler Members

        public bool IsReusable
        {
            // Return false in case your Managed Handler cannot be reused for another request.
            // Usually this would be false in case you have some state information preserved per request.
            get { return true; }
        }

        /// <summary>
        /// Main entry point into the xlfsTestIsWriteFileEntriesComplete operation.
        /// 
        /// Features:
        /// This API is used to check on the thread (and FileTableEntry creation status) created
        /// by the xlfsTestWriteFileEntries API. If the thread is completed it will return
        /// true and return the amount of time taken to create the records.
        /// </summary>
        /// <param name="context"></param>
        public void ProcessRequest(HttpContext context)
        {
            int          threadId;

            try
            {
                context.SetTrace(new XlfsTrace("xlfsTestIsWriteFileEntriesComplete"));
                context.WriteInfoLine("xlfsTestIsWriteFileEntriesComplete.ProcessRequest: Enter");

                if (!WebRole.EnableTestFrontDoor)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Forbidden;
                    context.WriteErrorLine(
                        "xlfsTestWriteFileEntries.Process Request: Test Front Door Not Enabled"
                        );
                    return;
                }

                if (SecurityCheck(context) == false)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    context.WriteErrorLine(
                        "xlfsTestIsWriteFileEntriesComplete.Process Request: Security Check Failed"
                        );
                    return;
                }

                // Get the ThreadId
                string threadIdString = context.Request.QueryString["threadid"];
                if (int.TryParse(threadIdString, out threadId) == false
                    || threadId == 0)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    context.WriteErrorLine(
                        "xlfsTestIsWriteFileEntriesComplete.Process Request: ThreadId Parse Failed"
                        );
                    return;
                }

                if (!xlfsTestWriteFileEntries.WriteFilesThreadList.ContainsKey(threadId))
                {
                    context.Response.StatusCode = (int)HttpStatusCode.NotFound;
                    context.WriteErrorLine(
                        "xlfsTestIsWriteFileEntriesComplete.Process Request: ThreadId Not Found"
                        );
                    return;
                }

                bool isComplete = xlfsTestWriteFileEntries.WriteFilesThreadList[threadId].WriteComplete;
                if (isComplete == true)
                {
                    context.Response.Headers.Add("succeeded", xlfsTestWriteFileEntries.WriteFilesThreadList[threadId].WriteSucceeded.ToString());
                    context.Response.Headers.Add("executiontime", xlfsTestWriteFileEntries.WriteFilesThreadList[threadId].ExecutionTime.ToString());
                    context.Response.Headers.Add("errorstring", xlfsTestWriteFileEntries.WriteFilesThreadList[threadId].ErrorString);
                    xlfsTestWriteFileEntries.WriteFilesThreadList.Remove(threadId);
                }

                // Write the response
                context.Response.Headers.Add("complete", isComplete.ToString());
                context.Response.StatusCode = (int)HttpStatusCode.OK;
            }
            catch (Exception e)
            {
                context.WriteErrorLine(string.Format("xlfsTestIsWriteFileEntriesComplete.ProcessRequest: Unhandled exception:\r\n{0}", e));
                throw;
            }
            finally
            {
                context.WriteInfoLine("xlfsTestIsWriteFileEntriesComplete.ProcessRequest: Exit");
            }
        }

       #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\worker\xlfsgc\dll\GarbageCollector.cs ===
using System;
using System.Collections.Generic;
using System.Threading;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsgc
{
    public class GarbageCollector
    {
        #region Fields

        //
        // For testability, these configuration values are all
        // pushed in by consumers.  We want avoid reaching out
        // from the GarbageCollector class to the WorkerRole
        // class, because that would then require us to test
        // both of them together.  This way allows us to test
        // GarbageCollector in isolation.  Loose coupling FTW.
        //

        public static IXlfsTraceFactory TraceFactory { get; set; }
        public static CloudQueue GcQueue { get; set; }
        /// <summary>
        /// Indicates how long a message will remain in the 
        /// queue before it's visible again.  This prevents 
        /// thrashing on the same message by multiple garbage
        /// collector instances.
        /// </summary>
        public static TimeSpan MessageTimeoutVisibilitySec { get; set; }
        /// <summary>
        /// The frequency that the garbage collector performs 
        /// a full collection pass through the data store.  
        /// </summary>
        public static TimeSpan AgeOutGcFrequency { get; set; }
        /// <summary>
        /// The maximum lifetime for a blob in storage.  Any 
        /// blob older than this will be garbage collected.
        /// </summary>
        public static TimeSpan AgeOutGcLifetime { get; set; }
        /// <summary>
        /// The lowest partition on which the garbage collector
        /// will start searching for files to collect.  No files
        /// should exist in any partitions smaller than this so
        /// there is no need to search them.
        /// </summary>
        public static DateTime MinimumPartitionDateTime { get; set; }
        /// <summary>
        /// Manages the list of storage accounts that the 
        /// garbage collector will parse.
        /// </summary>
        public static StorageAccountManager StorageAccounts { get; private set; }
        /// <summary>
        /// The interval that the garbage collector updates the 
        /// available storage accounts.
        /// </summary>
        public static int StorageAccountRefreshIntervalMs { get; set; }
        /// <summary>
        /// The interval at which the storage account manager
        /// updates the used value for each storage account
        /// </summary>
        public static int UpdateUsedIntervalMs { get; set; }
        /// <summary>
        /// The amount of time the garbage collector sleeps 
        /// after processing a message in the message queue.
        /// </summary>
        public static int MessageProcessingIntervalMs { get; set; }

        private static Boolean running = false;

        private static CloudStorageAccount _storageAccount;
        public static CloudStorageAccount StorageAccount
        {
            get
            {
                return _storageAccount;
            } 
            set
            {
                if (value != _storageAccount)
                {
                    _storageAccount = value;
                    if (value != null)
                    {
                        StorageAccounts = new StorageAccountManager(
                            _storageAccount,
                            StorageAccountRefreshIntervalMs,
                            UpdateUsedIntervalMs,
                            TraceFactory);

                        CloudQueueClient queueClient = StorageAccount.CreateCloudQueueClient();
                        GcQueue = queueClient.GetQueueReference(XlfsConstants.GcQueueName);
                        GcQueue.CreateIfNotExist();
                    }
                    else
                    {
                        StorageAccounts.Dispose();
                        StorageAccounts = null;
                        _storageAccount = null;
                        GcQueue = null;
                    }
                }
            }
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Constructor initializes anything that does not require
        /// a storage account.
        /// </summary>
        static GarbageCollector()
        {
            TraceFactory = null;
            MessageTimeoutVisibilitySec = TimeSpan.FromMinutes(1);
            AgeOutGcFrequency = TimeSpan.FromDays(1);
            AgeOutGcLifetime = TimeSpan.FromDays(90);
            MinimumPartitionDateTime = new DateTime(2010, 1, 1, 0, 0, 0);
            StorageAccountRefreshIntervalMs = 60000;
            UpdateUsedIntervalMs = 5000;
            MessageProcessingIntervalMs = 1000;
        }

        #endregion

        #region Methods

        /// <summary>
        /// Initialize the garbage collector.  This will not generate
        /// any messages in the message queue.
        /// </summary>
        public static void Initialize()
        {
        }

        /// <summary>
        /// This method pushes the necessary messages into the
        /// GC queue to get the GC system up and rolling.
        /// </summary>
        public static bool BootStrap()
        {
            IXlfsTrace trace = TraceFactory.Create("GarbageCollector");
            trace.AppendInfoLine("GarbageCollector.BootStrap:  Enter");

            try
            {
                bool queueHasAgeOutGcCommence = false;

                if (GcQueue.RetrieveApproximateMessageCount() > 0)
                {
                    //  Peek at the messages currently in the queue, if any.
                    //  Set flags to indicate how much bootstrapping is required.
                    IEnumerable<CloudQueueMessage> messages = GcQueue.PeekMessages(32);
                    foreach (var message in messages)
                    {
                        XlfsGcMessage xlfsGcMessage;

                        try
                        {
                            xlfsGcMessage = XlfsGcMessage.Create(message);
                        }
                        catch(Exception e)
                        {
                            // For whatever reason, the message could not be parsed
                            // as a valid XlfsGC message.  Dump the information to
                            // trace, but continue.
                            trace.AppendInfoLine(
                               "Found invalid message in the queue:\r\n\t{0}\r\nException:\r\n{1}",
                               message.AsString,
                               e);
                            continue;
                        }

                        switch (xlfsGcMessage.Name)
                        {
                            // If either of these messages are in the queue,
                            // then there's no need to bootstrap the age out
                            // process.
                            case XlfsConstants.AgeOutGcCommenceMessage:
                            case XlfsConstants.AgeOutGcMessage:
                                queueHasAgeOutGcCommence = true;
                                break;

                            default:
                                break;
                        }
                    }
                }

                if (!queueHasAgeOutGcCommence)
                {
                    string ageOutGcCommenceMessage = string.Format(XlfsConstants.AgeOutGcCommenceFormat,
                                                                   DateTime.UtcNow.ToString("o"),
                                                                   MinimumPartitionDateTime.ToString(
                                                                       FileTableLastUpdateEntry.PartitionKeyFormatString));
                    GcQueue.AddMessage(new CloudQueueMessage(ageOutGcCommenceMessage));
                    trace.AppendInfoLine("GarbageCollector.BootStrap:  Commenced AgeOut process with message \"{0}\".",
                                         ageOutGcCommenceMessage);
                }
                else
                {
                    trace.AppendInfoLine("GarbageCollector.BootStrap:  GcQueue already contains AgeOut messages in progress, not bootstrapping the age out process.");
                }

                //string orphanedFileGcMessage = string.Format(OrphanedFileGcFormat, string.Empty, string.Empty, string.Empty);
                //CloudQueueMessage msg = new CloudQueueMessage(orphanedFileGcMessage);
                //GcQueue.AddMessage(msg);

                //string pendingDeleteGcCommenceMessage = string.Format(PendingDeleteGcCommence,
                //                                                      DateTime.UtcNow.Add(PendingDeleteGcFrequency)););

                return true;
            }
            catch(Exception e)
            {
                trace.AppendErrorLine("GarbageCollector.BootStrap:  Bootstrapping failed.  Exception:\r\n{0}", e);
                return false;
            }
            finally
            {
                trace.AppendInfoLine("GarbageCollector.BootStrap: Exit");
                trace.Flush();
            }
        }
        
        /// <summary>
        /// Main processing loop.  Read a message, process a message,
        /// ad infinitum.
        /// </summary>
        public static void Run()
        {
            IXlfsTrace trace;
            running = true;

            while (running)
            {
                trace = TraceFactory.Create("GarbageCollector");
                trace.AppendLine("GarbageCollector.Run: Wake up");
                trace.Flush();

                try
                {
                    do
                    {
                        trace = TraceFactory.Create("GarbageCollector");

                        try
                        {
                            CloudQueueMessage msg = GcQueue.GetMessage(MessageTimeoutVisibilitySec);
                            if (msg == null) break;

                            XlfsGcMessage xlfsGcMessage;

                            try
                            {
                                xlfsGcMessage = XlfsGcMessage.Create(msg);
                            }
                            catch (Exception e)
                            {
                                trace.AppendErrorLine("Invalid message retrieved from the queue, skipping and deleting.  Exception:\r\n{0}", e);
                                GcQueue.DeleteMessage(msg);
                                continue;
                            }

                            trace.AppendLine("GarbageCollector.Run:  Processing message \"{0}\".", xlfsGcMessage.Message.AsString);

                            // Process the message.
                            ProcessMessage(xlfsGcMessage, trace);
                        }
                        catch (Exception e)
                        {
                            trace.AppendErrorLine("GarbageCollector.Run:  ProcessMessage() threw an exception:\r\n{0}",
                                                  e);
                        }
                        finally
                        {
                            // Each message gets its own trace log entry.
                            trace.Flush();
                        }
                    } while (true);
                }
                finally
                {
                    trace = TraceFactory.Create("GarbageCollector");
                    trace.AppendLine("GarbageCollector.Run: No more messages in the queue, sleeping.");
                    trace.Flush();

                    Thread.Sleep(MessageProcessingIntervalMs);
                }
            }
        }

        /// <summary>
        /// Causes the processing loop to complete processing the current 
        /// item it's on and then return gracefully.
        /// </summary>
        /// <remarks>
        /// This is unlikely to be used in a production scenario, but provides
        /// a way to cleanly shut down the Garbage Collector if required.
        /// </remarks>
        public static void Stop()
        {
            running = false;
        }

        /// <summary>
        /// Process a message from the GC queue
        /// </summary>
        /// <param name="msg"></param>
        /// <param name="trace"></param>
        private static void ProcessMessage(XlfsGcMessage msg, IXlfsTrace trace)
        {
            trace.AppendInfoLine("GarbageCollector.ProcessMessage: Enter");

            try
            {
                IXlfsGcMessageHandler handler =
                    XlfsGcMessageUtils.GetGcMessageHandler(msg.Name);

                // If there is no handler associated with this message, delete
                // the message and move on.
                if (handler == null)
                {
                    trace.AppendErrorLine(
                        "GarbageCollector.ProcessMessage:  No message handler found for message type {0}, deleting message.",
                        msg.Name);
                    GcQueue.DeleteMessage(msg.Message);
                    return;
                }

                // Pass the message to the handler.
                handler.HandleMessage(msg, trace);
            }
            finally
            {
                trace.AppendInfoLine("GarbageCollector.ProcessMessage: Exit");
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\worker\xlfsgc\dll\OrphanedFileScanThread.cs ===
namespace xonline.server.xlfs.fd.xlfsgc
{
    public class OrphanedFileScanThread
    {
        public static void Start()
        {
            
        }

        public static void Stop()
        {
            
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\testfd\XlfsTestFD\WebRole.cs ===
using System;
using System.Linq;
using Microsoft.WindowsAzure.Diagnostics;
using Microsoft.WindowsAzure.ServiceRuntime;

namespace xonline.server.xlfs.fd.xlfstestfd
{
    public class WebRole : RoleEntryPoint
    {
        /// <summary>
        /// Indicates whether or not client certificates are required
        /// </summary>
        public static bool ClientCertificateRequired
        {
            get
            {
                string value = RoleEnvironment.GetConfigurationSettingValue("clientCertificateRequired");
                bool clientCertificateRequired;

                if (bool.TryParse(value, out clientCertificateRequired) == false)
                {
                    clientCertificateRequired = false;
                }
                return clientCertificateRequired;
            }
        }

        /// <summary>
        /// Indicates which client certificate subjects are valid
        /// </summary>
        public static string[] ClientCertificateSubjects
        {
            get
            {
                return RoleEnvironment.GetConfigurationSettingValue("clientCertificateSubjects").Split(';');
            }
        }

        /// <summary>
        /// Configured value that indicates whether or not to enable the test front door
        /// (xlfsTestWriteFileEntries and xlfsTestIsWriteFileEntriesComplete).
        /// Default to False
        /// </summary>
        public static bool EnableTestFrontDoor
        {
            get
            {
                string value = RoleEnvironment.GetConfigurationSettingValue("enableTestFrontDoor");
                bool enableTestFrontDoor;
                if (!string.IsNullOrEmpty(value) && bool.TryParse(value, out enableTestFrontDoor))
                {
                    return enableTestFrontDoor;
                }

                return false;
            }
        }

        /// <summary>
        /// Main Role Entry Point
        /// </summary>
        /// <returns></returns>
        public override bool OnStart()
        {
            // 
            // Now set up diagnostics
            //
            DiagnosticMonitorConfiguration diagConfig = DiagnosticMonitor.GetDefaultInitialConfiguration();

            //
            // Now setup logging
            //
            diagConfig.WindowsEventLog.DataSources.Add("Application!*");
            diagConfig.WindowsEventLog.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);
            diagConfig.Logs.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);
            diagConfig.Logs.ScheduledTransferLogLevelFilter = LogLevel.Information;
            DiagnosticMonitor.Start("DiagnosticsConnectionString", diagConfig);

            CrashDumps.EnableCollection(true);

            // For information on handling configuration changes
            // see the MSDN topic at http://go.microsoft.com/fwlink/?LinkId=166357.
            RoleEnvironment.Changing += RoleEnvironmentChanging;

            return base.OnStart();
        }


        private void RoleEnvironmentChanging(object sender, RoleEnvironmentChangingEventArgs e)
        {
            // If a configuration setting is changing
            if (e.Changes.Any(change => change is RoleEnvironmentConfigurationSettingChange))
            {
                // Set e.Cancel to true to restart this role instance
                e.Cancel = true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\testfd\XlfsTestFD\xlfsTestWriteFileEntries.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Net;
using System.Web;
using System.Xml.Linq;
using System.Threading;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfstestfd
{
    /// <summary>
    /// This handler returns an enumeration of files from file storage
    /// that match the given criteria
    /// </summary>
    public class xlfsTestWriteFileEntries : TestRequest, IHttpHandler
    {
        public static Dictionary<int, XlfsWriteTestFiles> WriteFilesThreadList = new Dictionary<int, XlfsWriteTestFiles>();
        #region Constructors

        #endregion

        /// <summary>
        /// You will need to configure this handler in the web.config file of your
        /// web and register it with IIS before being able to use it. For more information
        /// see the following link: http://go.microsoft.com/?linkid=8101007
        /// </summary>
        #region IHttpHandler Members

        public bool IsReusable
        {
            // Return false in case your Managed Handler cannot be reused for another request.
            // Usually this would be false in case you have some state information preserved per request.
            get { return true; }
        }

        /// <summary>
        /// Main entry point into the xlfsTestWriteFileEntries operation.
        /// 
        /// Features:
        /// This API is used for performance/stress testing of the front doors
        /// by allowing mass creation of entries in the FileTable. This API
        /// takes a titleId, startDate, endDate and fileCount (and optionally
        /// a userXuid) and will create (fileCount) number of entries in the 
        /// FileTable with random LastUpdate times between startDate and endDate
        /// for the given titleId. Because of the length of time creating
        /// large amounts of entries may take, the API spawns off a thread to
        /// create the entries and another API (xlfsTestIsWriteFileEntriesComplete)
        /// can be called to check on the status of the thread (and clean up if
        /// the thread is finished).
        /// </summary>
        /// <param name="context"></param>
        public void ProcessRequest(HttpContext context)
        {
            DateTime     startDate;
            DateTime     endDate;
            int          titleId;
            uint         fileCount;
            ulong        userXuid;

            try
            {
                context.SetTrace(new XlfsTrace("xlfsTestWriteFileEntries"));
                context.WriteInfoLine("xlfsTestWriteFileEntries.ProcessRequest: Enter");

                if (!WebRole.EnableTestFrontDoor)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Forbidden;
                    context.WriteErrorLine(
                        "xlfsTestWriteFileEntries.Process Request: Test Front Door Not Enabled"
                        );
                    return;
                }

                if (SecurityCheck(context) == false)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    context.WriteErrorLine(
                        "xlfsTestWriteFileEntries.Process Request: Security Check Failed"
                        );
                    return;
                }

                // Get the start/end date ranges that we care about
                bool result = GetParametersFromRequest(
                    context,
                    out titleId,
                    out startDate,
                    out endDate
                    );
                if (result == false)
                {
                    startDate = DateTime.UtcNow;
                    endDate = startDate;
                    titleId = unchecked((int)0xFFFE07D1);
                }
                GetParametersFromRequest(
                    context,
                    out fileCount,
                    out userXuid);

                XlfsWriteTestFiles writeTestFiles = new XlfsWriteTestFiles();
                writeTestFiles.StartDate = startDate;
                writeTestFiles.EndDate = endDate;
                writeTestFiles.TitleId = titleId;
                writeTestFiles.FileCount = fileCount;
                writeTestFiles.UserXuid = userXuid;
                Thread newWriteFilesThread = new Thread(new ThreadStart(writeTestFiles.CreateFilesThread));

                newWriteFilesThread.Start();
                if (WriteFilesThreadList == null)
                {
                    WriteFilesThreadList = new Dictionary<int, XlfsWriteTestFiles>();
                }
                WriteFilesThreadList.Add(newWriteFilesThread.ManagedThreadId, writeTestFiles);

                context.Response.Headers.Add("threadid", newWriteFilesThread.ManagedThreadId.ToString());
                context.Response.StatusCode = (int)HttpStatusCode.OK;

                //Cleanup old entries here so if it fails the request still goes through. Ideally we'd have a worker role do this cleanup
                try
                {
                    context.SetTrace(new XlfsTrace("xlfsTestWriteFileEntries Cleanup"));
                    context.WriteInfoLine("xlfsTestWriteFileEntries.CleanUpWriteTestFilesThread: Enter");
                    CleanUpWriteTestFilesThreads();
                    context.WriteInfoLine("xlfsTestWriteFileEntries.CleanUpWriteTestFilesThread: Exit");
                }
                catch(Exception e)
                {
                    context.WriteErrorLine(string.Format("xlfsTestWriteFileEntries.CleanUpWriteTestFilesThread: Failed - {0}", e));
                }
            }
            catch (Exception e)
            {
                context.WriteErrorLine(string.Format("xlfsTestWriteFileEntries.ProcessRequest: Unhandled exception:\r\n{0}", e));
                throw;
            }
            finally
            {
                context.WriteInfoLine("xlfsTestWriteFileEntries.ProcessRequest: Exit");
            }
        }

        /// <summary>
        /// We need to have a cleanup for the WriteFilesThreadList in case the
        /// writes take long enough that the tests time out waiting and the array
        /// doesn't get cleaned up. By default we'll delete threads that are complete
        /// which are older than 24 hours
        /// </summary>
        protected void CleanUpWriteTestFilesThreads()
        {
            CleanUpWriteTestFilesThreads(24);
        }

        protected void CleanUpWriteTestFilesThreads(int hours)
        {
            foreach (int threadId in WriteFilesThreadList.Keys)
            {
                if ((WriteFilesThreadList[threadId].WriteComplete == true)
                    && WriteFilesThreadList[threadId].WriteStartTime < DateTime.UtcNow.AddHours(-1 * hours))
                {
                    WriteFilesThreadList.Remove(threadId);
                }
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\testfd\XlfsTestFD\xlfsTestPerfCounters.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Net;
using System.Web;
using System.Xml.Linq;
using System.Threading;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;
using System.Diagnostics;
using System.Text;
using System.Xml;

namespace xonline.server.xlfs.fd.xlfstestfd
{
    /// Returns an XML blob of the perf counters on the Azure Instance.
    public class xlfsTestPerfCounters : TestRequest, IHttpHandler
    {
        #region Constructors

        #endregion

        /// <summary>
        /// You will need to configure this handler in the web.config file of your
        /// web and register it with IIS before being able to use it. For more information
        /// see the following link: http://go.microsoft.com/?linkid=8101007
        /// </summary>
        #region IHttpHandler Members

        public bool IsReusable
        {
            // Return false in case your Managed Handler cannot be reused for another request.
            // Usually this would be false in case you have some state information preserved per request.
            get { return true; }
        }

        /// <summary>
        /// Main entry point into the xlfsTestPerfCounters operation.
        /// 
        /// Features:
        /// This API spits out the list of perf counters in the XML format that is being used by the PowerShell Script
        /// that sets the Perf Counters in the Diagnostic Monitor.
        /// </summary>
        /// <param name="context"></param>
        public void ProcessRequest(HttpContext context)
        {
            try
            {
                context.SetTrace(new XlfsTrace("xlfsTestPerfCounters"));
                context.WriteInfoLine("xlfsTestPerfCounters.ProcessRequest: Enter");

                if (!WebRole.EnableTestFrontDoor)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Forbidden;
                    context.WriteErrorLine(
                        "xlfsTestPerfCounters.Process Request: Test Front Door Not Enabled"
                        );
                    return;
                }

                if (SecurityCheck(context) == false)
                {
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    context.WriteErrorLine(
                        "xlfsTestPerfCounters.Process Request: Security Check Failed"
                        );
                    return;
                }
                StringBuilder sb = new StringBuilder();
                XmlWriterSettings settings = new XmlWriterSettings();
                settings.Encoding = System.Text.Encoding.UTF8;
                settings.Indent = true;
                settings.OmitXmlDeclaration = false;
                settings.ConformanceLevel = ConformanceLevel.Document;

                using (XmlWriter xml = XmlWriter.Create(sb, settings))
                {

                    xml.WriteStartDocument(true);
                    xml.WriteStartElement("diagnostics");
                    xml.WriteStartElement("counters");
                    xml.WriteAttributeString("sampleRate", "30");

                    PerformanceCounterCategory[] perfCategories = PerformanceCounterCategory.GetCategories();
                    foreach (PerformanceCounterCategory perfCat in perfCategories)
                    {
                        string[] instanceNames = perfCat.GetInstanceNames();
                        if (instanceNames.Length == 0)  // no instance names so just grab the counters...
                        {
                            //counters.AddRange(perfCat.GetCounters());
                            foreach (PerformanceCounter counter in perfCat.GetCounters())
                            {
                                WriteCounter(xml, perfCat.CategoryName, counter.CounterName);
                            }
                        }
                        else
                        {
                            foreach (string instance in instanceNames)
                            {
                                try
                                {
                                    if (perfCat.InstanceExists(instance))
                                    {
                                        foreach (PerformanceCounter counter in perfCat.GetCounters(instance))
                                        {
                                            WriteCounter(xml, perfCat.CategoryName, counter.CounterName, instance);
                                        }
                                    }
                                }
                                finally { }
                            }

                        }
                    }
                    xml.WriteEndElement(); // counters
                    xml.WriteEndElement(); // diag
                    xml.WriteEndDocument();
                    xml.Flush();
                    xml.Close();
                }
                context.Response.Write(sb.ToString());
                context.Response.StatusCode = (int)HttpStatusCode.OK;
            }
            catch (Exception e)
            {
                context.WriteErrorLine(string.Format("xlfsTestWriteFileEntries.ProcessRequest: Unhandled exception:\r\n{0}", e));
                throw;
            }
            finally
            {
                context.WriteInfoLine("xlfsTestWriteFileEntries.ProcessRequest: Exit");
            }
        }
        #endregion

        private void WriteCounter(XmlWriter xml, string source, string counter, string instance)
        {
            xml.WriteStartElement("counter");
            xml.WriteAttributeString("enabled", "true");
            xml.WriteAttributeString("source", source);
            xml.WriteAttributeString("name", counter);
            if (!String.IsNullOrEmpty(instance))
            {
                xml.WriteAttributeString("instance", instance);
            }
            xml.WriteEndElement(); // counter
        }

        private void WriteCounter(XmlWriter xml, string source, string counter)
        {
            WriteCounter(xml, source, counter, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\worker\xlfsgc\dll\perfctrs.cs ===
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsgc
{
    public class PerformanceCounterStrings
    {
        public const string XlfsGcCategory = "XlfsGc:XlfsGc";
        // Define perf counter names here, eg.
        //public const string uploadBeginRequestsPerSec = "UploadBegin requests/sec";
    }

    /// <summary>
    /// UploadBegin performance counters.
    /// </summary>
    [XlfsPerformanceCounterCategoryAttr(PerformanceCounterStrings.XlfsGcCategory, "Performance counters related to the XLFS Garbage Collector.")]
    public class XlfsGcCounters : XlfsPerformanceCounterCategory
    {
        public virtual XlfsGcCounters this[string countryId]
        {
            get
            {
                return (XlfsGcCounters)GetInstance(countryId);
            }
        }

        static public XlfsGcCounters Counters = new XlfsGcCounters();

        // Define performance counters, eg.
        //[XlfsPerformanceCounterAttr(
        //    PerformanceCounterStrings.uploadBeginRequestsPerSec,
        //    "UploadBegin requests per second",
        //     PerformanceCounterType.RateOfCountsPerSecond32)]
        //public PerformanceCounter RequestsPerSecond;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\worker\xlfsgc\dll\WorkerRole.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.Diagnostics;
using Microsoft.WindowsAzure.ServiceRuntime;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsgc
{
    public class WorkerRole : RoleEntryPoint
    {
        private static readonly XlfsTrace EventTrace = new XlfsTrace("XlfsGc");

        #region RoleEntryPoint Overrides

        public override void Run()
        {
            GarbageCollector.Run();
        }

        public override bool OnStart()
        {
            var trace = new XlfsTrace("WorkerRole");
            trace.AppendInfoLine("WorkerRole.OnStart: Enter");

            try
            {
                // Set the maximum number of concurrent connections 
                ServicePointManager.DefaultConnectionLimit = 12;

                //
                //  Need to call this before calling CloudStorageAccount.FromConfigurationSetting.  
                //  Otherwise we get InvalidOperationExceptions.
                //

                CloudStorageAccount.SetConfigurationSettingPublisher(
                    (configName, configSetter) => configSetter(RoleEnvironment.GetConfigurationSettingValue(configName)));

                //
                // Set up diagnostics.
                //

                DiagnosticMonitorConfiguration diagConfig = DiagnosticMonitor.GetDefaultInitialConfiguration();

                diagConfig.WindowsEventLog.DataSources.Add("Application!*");
                diagConfig.WindowsEventLog.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);

                diagConfig.Logs.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);
                diagConfig.Logs.ScheduledTransferLogLevelFilter = LogLevel.Information;

                // IIS 7.0 Logs
                diagConfig.Directories.ScheduledTransferPeriod = TimeSpan.FromMinutes(1.0);

                DiagnosticMonitor.Start("DiagnosticsConnectionString", diagConfig);

                //
                // Install custom performance counters.
                //

                try
                {
                    var installer = new XlfsPerformanceCounterInstall();
                    installer.Install(GetType());
                    trace.AppendInfoLine("WorkerRole.OnStart:  Performance counters installed successfully.");
                }
                catch(Exception e)
                {
                    trace.AppendErrorLine(
                        "WorkerRole.OnStart:  Failed to install performance counters.  Exception:\r\n{0}", e);
                }

                //
                // Now enable crash dumps
                //

                CrashDumps.EnableCollection(true);

                // For information on handling configuration changes
                // see the MSDN topic at http://go.microsoft.com/fwlink/?LinkId=166357.
                RoleEnvironment.Changing += RoleEnvironmentChanging;

                // Set configuration values into the garbage collector.
                UpdateAgeOutGcFrequencyHours(RoleEnvironment.GetConfigurationSettingValue("AgeOutGcFrequencyHours"));
                UpdateAgeOutGcLifetimeDays(RoleEnvironment.GetConfigurationSettingValue("AgeOutGcLifetimeDays"));
                UpdateStorageAccountRefreshInterval(
                    RoleEnvironment.GetConfigurationSettingValue("StorageAccountRefreshIntervalMs"));
                UpdateUpdateUsedIntervalMs(RoleEnvironment.GetConfigurationSettingValue("UpdateUsedIntervalMs"));
                UpdateMinimumPartitionDateTime(RoleEnvironment.GetConfigurationSettingValue("MinimumPartitionDateTime"));

                // Initialize the garbage collector
                GarbageCollector.TraceFactory = new XlfsTraceFactory();
                GarbageCollector.StorageAccount = CloudStorageAccount.FromConfigurationSetting("StorageConnectionString");

                GarbageCollector.Initialize();
                if (IsTheBootStrapper())
                {
                    if (!GarbageCollector.BootStrap())
                    {
                        return false;
                    }
                }

                return base.OnStart();
            }
            finally
            {
                trace.AppendInfoLine("WorkerRole.OnStart: Exit");
                trace.Flush();
            }
        }

        public override void OnStop()
        {
            var trace = new XlfsTrace("WorkerRole");
            trace.AppendInfoLine("WorkerRole.OnStop: Enter");

            try
            {
                //
                // Uninstall custom performance counters.
                //

                try
                {
                    var installer = new XlfsPerformanceCounterInstall();
                    installer.Uninstall(GetType());
                    trace.AppendInfoLine("WorkerRole.OnStop:  Performance counters uninstalled.");
                }
                catch (Exception e)
                {
                    // When running in dev fabric with multiple instances, all
                    // but one of the instances will throw here.  There doesn't
                    // appear to be any way to determine at run time if we're running
                    // on dev fabric, so we'll just log this exception and move on.
                    trace.AppendErrorLine(
                        "WorkerRole.OnStop:  Uninstalling performance counters threw an exception:\r\n{0}", e);
                }

                base.OnStop();
            }
            finally
            {
                trace.AppendInfoLine("WorkerRole.OnStop: Exit");
                trace.Flush();
            }
        }

        #endregion

        /// <summary>
        /// This method returns the numeric id of the instance.  It supports
        /// both the four part, '.' delimited form in dev fabric, as well as
        /// the three part, '_' delimited form in Azure.
        /// </summary>
        /// <param name="idString"></param>
        /// <param name="trace"></param>
        /// <param name="id"></param>
        /// <returns></returns>
        private static bool IdFromIdString(string idString, IXlfsTrace trace, out int id)
        {
            id = -1;
            string numericPortion;

            if (idString.Contains("."))
            {
                string[] idStringSplit = idString.Split('.');
                if (idStringSplit.Length != 4)
                {
                    trace.AppendErrorLine(
                        "WorkerRole.IdFromIdString: Id String {0} did not correctly split into 4 parts, unable to determine instance id.",
                        idString);
                    return false;
                }

                numericPortion = idStringSplit[3];
            }
            else if(idString.Contains("_"))
            {
                string[] idStringSplit = idString.Split('_');
                if (idStringSplit.Length != 3)
                {
                    trace.AppendErrorLine(
                        "WorkerRole.IdFromIdString: Id String {0} did not correctly split into 3 parts, unable to determine instance id.",
                        idString);
                    return false;
                }

                numericPortion = idStringSplit[2];
            }
            else
            {
                trace.AppendErrorLine(
                    "WorkerRole.IdFromIdString: Id String {0} was not in a recognizable form.  Supported formats are '.' delimited with four parts, or '_' delimited with three parts.",
                    idString);
                return false;
            }

            if (!int.TryParse(numericPortion, out id))
            {
                trace.AppendErrorLine("WorkerRole.IdFromIdString: Failed to parse id out of id string {0}.", numericPortion);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Returns true if this instance will be responsible for
        /// bootstrapping the garbage collection process.
        /// </summary>
        /// <returns></returns>
        private static bool IsTheBootStrapper()
        {
            IXlfsTrace trace = new XlfsTrace("WorkerRole");
            trace.AppendInfoLine("WorkerRole.IsTheBootStrapper: Enter");

            try
            {
                string myIdString = RoleEnvironment.CurrentRoleInstance.Id;
                trace.AppendInfoLine("WorkerRole.IsTheBootStrapper: Id String = {0}", myIdString);

                int myId;
                if(!IdFromIdString(myIdString, trace, out myId))
                {
                    return false;
                }
                trace.AppendInfoLine("WorkerRole.IsTheBootStrapper: myId = {0}", myId);

                var idList = new List<int>();
                var idListString = new StringBuilder();
                //foreach (var entry in RoleEnvironment.CurrentRoleInstance.Role.Instances)
                foreach (var entry in RoleEnvironment.Roles[RoleEnvironment.CurrentRoleInstance.Role.Name].Instances)
                {
                    trace.AppendInfoLine("WorkerRole.IsTheBootStrapper: Id String = {0}", entry.Id);

                    int id;
                    if (!IdFromIdString(entry.Id, trace, out id))
                    {
                        continue;
                    }

                    idList.Add(id);
                    idListString.Append(id + " ");
                }

                trace.AppendInfoLine("WorkerRole.IsTheBootStrapper: All Ids = {0}", idListString.ToString());

                bool isTheBootStrapper = idList.All(id => id >= myId);
                trace.AppendInfoLine("WorkerRole.IsTheBootStrapper: Returning {0}.", isTheBootStrapper);
                return isTheBootStrapper;
            }
            finally
            {
                trace.AppendInfoLine("WorkerRole.IsTheBootStrapper: Exit");
                trace.Flush();
            }
        }

        /// <summary>
        /// Handle configuration changes on the fly.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private static void RoleEnvironmentChanging(object sender, RoleEnvironmentChangingEventArgs e)
        {
            foreach(var change in e.Changes)
            {
                var configChange = change as RoleEnvironmentConfigurationSettingChange;

                if(configChange == null)
                {
                    continue;
                }

                switch(configChange.ConfigurationSettingName)
                {
                    case "AgeOutGcFrequencyHours":
                        UpdateAgeOutGcFrequencyHours(RoleEnvironment.GetConfigurationSettingValue("AgeOutGcFrequencyHours"));
                        break;

                    case "AgeOutGcLifetimeDays":
                        UpdateAgeOutGcLifetimeDays(RoleEnvironment.GetConfigurationSettingValue("AgeOutGcLifetimeDays"));
                        break;

                    case "StorageAccountRefreshIntervalMs":
                        UpdateStorageAccountRefreshInterval(RoleEnvironment.GetConfigurationSettingValue("StorageAccountRefreshIntervalMs"));
                        break;

                    case "UpdateUsedIntervalMs":
                        UpdateUpdateUsedIntervalMs(RoleEnvironment.GetConfigurationSettingValue("UpdateUsedIntervalMs"));
                        break;

                    case "MinimumPartitionDateTime":
                        UpdateMinimumPartitionDateTime(RoleEnvironment.GetConfigurationSettingValue("MinimumPartitionDateTime"));
                        break;

                    default:
                        e.Cancel = true;
                        return;
                }
            }
        }

        /// <summary>
        /// Update age out frequency.
        /// </summary>
        /// <param name="value"></param>
        private static void UpdateAgeOutGcFrequencyHours(string value)
        {
            int ageOutGcFrequencyHours;

            if (!int.TryParse(value, out ageOutGcFrequencyHours))
            {
                EventTrace.WriteEvent(
                    "AgeOutGcFrequencyHours: Not Found or not Parseable. Defaulting to 24 hours."
                    );
                ageOutGcFrequencyHours = 24;
            }

            GarbageCollector.AgeOutGcFrequency = new TimeSpan(0, ageOutGcFrequencyHours, 0, 0);
        }

        /// <summary>
        /// Update age out lifetime.
        /// </summary>
        /// <param name="value"></param>
        private static void UpdateAgeOutGcLifetimeDays(string value)
        {
            int ageOutGcLifetimeDays;

            if (!int.TryParse(value, out ageOutGcLifetimeDays))
            {
                EventTrace.WriteEvent(
                    "AgeOutGcLifetimeDays: Not Found or not Parseable. Defaulting to 90 days."
                    );
                ageOutGcLifetimeDays = 90;
            }

            GarbageCollector.AgeOutGcLifetime = new TimeSpan(ageOutGcLifetimeDays, 0, 0, 0);
        }

        /// <summary>
        /// Storage Account Refresh Interval
        /// </summary>
        /// <param name="value"></param>
        private static void UpdateStorageAccountRefreshInterval(string value)
        {
            int d;

            if (!int.TryParse(value, out d))
            {
                EventTrace.WriteEvent(
                    "StorageAccountRefreshInterval: Not Found or not Parseable. Defaulting to 60 seconds."
                    );
                d = 60000; // 2hr default (2 * 60 * 60) in seconds
            }

            GarbageCollector.StorageAccountRefreshIntervalMs = d;
        }

        /// <summary>
        /// UpdateUsedIntervalMs
        /// </summary>
        /// <param name="value"></param>
        private static void UpdateUpdateUsedIntervalMs(string value)
        {
            int d;

            if (!int.TryParse(value, out d))
            {
                EventTrace.WriteEvent(
                    "UpdateUsedIntervalMs: Not Found or not Parseable. Defaulting to 60 seconds."
                    );
                d = 60000; // 2hr default (2 * 60 * 60) in seconds
            }

            GarbageCollector.UpdateUsedIntervalMs = d;
        }

        /// <summary>
        /// UpdateMinimumPartitionDateTime
        /// </summary>
        /// <param name="value"></param>
        private static void UpdateMinimumPartitionDateTime(string value)
        {
            DateTime d;

            if (!DateTime.TryParse(value, out d))
            {
                EventTrace.WriteEvent(
                    "MinimumPartitionDateTime: Not Found or not Parseable. Defaulting to \"1/1/2010 0:00\"."
                    );
                d = new DateTime(2010, 1, 1, 0, 0, 0);
            }

            GarbageCollector.MinimumPartitionDateTime = d;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\worker\xlfsgc\dll\XlfsGcAgeOutGcHandler.cs ===
using System;
using System.Collections.Generic;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsgc
{
    [XlfsGcMessageHandler(XlfsConstants.AgeOutGcMessage)]
    public class XlfsGcAgeOutGcHandler : IXlfsGcMessageHandler
    {
        public XlfsGcAgeOutGcHandler()
        {
            if(GarbageCollector.StorageAccounts == null)
            {
                throw new ApplicationException(
                    "Cannot process AgeOutGc messages because the GarbageCollector.StorageAccounts " +
                    "collection has not been initialized.  This collection is automatically " + 
                    "initialized when the GarbageCollector.StorageAccount property is set.");
            }
        }

        /// <summary>
        /// Process an AgeOutGc message.  Scan through a single partitions worth
        /// of the FileTableLastUpdateEntry table for files that were last 
        /// updated longer ago than the configured Age-Out interval.
        /// </summary>
        public void HandleMessage(XlfsGcMessage msg, IXlfsTrace trace)
        {
            trace.AppendInfoLine("XlfsGcAgeOutGcHandler.HandleMessage: Enter");

            try
            {
                var ageOutGcLifetimeBoundary = DateTime.UtcNow - GarbageCollector.AgeOutGcLifetime;

                string partitionKey = msg.Xml.DocumentElement.GetAttribute("partition");
                trace.AppendInfoLine("XlfsGcAgeOutGcHandler.HandleMessage: partitionKey = {0}", partitionKey);

                if (string.IsNullOrEmpty(partitionKey))
                {
                    trace.AppendErrorLine(
                        "XlfsGcAgeOutGcHandler.HandleMessage: partition attribute " +
                        "is null or empty, processing of this message has been aborted.");
                    return;
                }

                DateTime? partitionKeyParsed = XlfsUtilities.ParsePartitionKey(partitionKey);
                if (!partitionKeyParsed.HasValue)
                {
                    trace.AppendErrorLine(
                        "XlfsGcAgeOutGcHandler.HandleMessage: partition attribute failed " +
                        "to parse, processing of this message has been aborted.");
                    return;
                }

                // Queue up a new message for the next partition to process.
                var ageOutGcPartitionCurrent = partitionKeyParsed.Value;
                DateTime ageOutGcPartitionNext = ageOutGcPartitionCurrent + TimeSpan.FromHours(1);
                if (ageOutGcPartitionNext < ageOutGcLifetimeBoundary)
                {
                    string nextAgeOutMessage = string.Format(XlfsConstants.AgeOutGcFormat,
                                                             ageOutGcPartitionNext.ToString(
                                                                 FileTableLastUpdateEntry.PartitionKeyFormatString));
                    GarbageCollector.GcQueue.AddMessage(new CloudQueueMessage(nextAgeOutMessage));
                    trace.AppendInfoLine(
                        "XlfsGcAgeOutGcHandler.HandleMessage: New AgeOutGc message enqueued:\r\n{0}",
                        nextAgeOutMessage);
                }
                else
                {
                    string ageOutGcCommenceMessage = string.Format(XlfsConstants.AgeOutGcCommenceFormat,
                                                                   (DateTime.UtcNow + GarbageCollector.AgeOutGcFrequency)
                                                                       .ToString("o"),
                                                                   ageOutGcPartitionNext.ToString(
                                                                       FileTableLastUpdateEntry.PartitionKeyFormatString));
                    GarbageCollector.GcQueue.AddMessage(new CloudQueueMessage(ageOutGcCommenceMessage));
                    trace.AppendInfoLine(
                        "XlfsGcAgeOutGcHandler.HandleMessage: Maximum partition reached, " +
                        "AgeOutGcCommence message enqueued:\r\n{0}", 
                        ageOutGcCommenceMessage);
                }

                // Now start cleaning up the partition...
                ResultContinuation continuation = null;
                var dataSource = new FileTableLastUpdateDataSource();

                List<FileTableLastUpdateEntry> filesToRemove = dataSource.SelectPartition(partitionKey, ref continuation);
                int filesRemoved = filesToRemove.Count;
                while (filesToRemove.Count != 0)
                {
                    foreach (var file in filesToRemove)
                    {
                        try
                        {
                            // Delete the blob.
                            CloudBlockBlob blob =
                                XlfsUtilities.GetBlobFromFileTableLastUpdateEntry(GarbageCollector.StorageAccounts, file);
                            blob.Delete();
                        }
                        catch(StorageClientException e)
                        {
                            if (e.Message == "The specified blob does not exist.")
                            {
                                continue;
                            }

                            throw;
                        }
                    }

                    dataSource.DeleteFileTableEntries(filesToRemove);

                    // Get the next batch.
                    filesToRemove = dataSource.SelectPartition(partitionKey, ref continuation);
                    filesRemoved += filesToRemove.Count;
                }

                trace.AppendInfoLine("XlfsGcAgeOutGcHandler.HandleMessage: {0} files removed from partition {1}.",
                                     filesRemoved,
                                     ageOutGcPartitionCurrent.ToString(FileTableLastUpdateEntry.PartitionKeyFormatString));
            }
            catch (Exception e)
            {
                trace.AppendErrorLine("XlfsGcAgeOutGcHandler.HandleMessage: Unexpected exception:\r\n{0}", e);
            }
            finally
            {
                // Always delete the message from the queue when we're done.
                GarbageCollector.GcQueue.DeleteMessage(msg.Message);

                trace.AppendInfoLine("XlfsGcAgeOutGcHandler.HandleMessage: Exit");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\BanPcTokens.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// BanPcTokens.cs
//
// Implementation of BanPcTokens SOAP API for XMachine FD
//
// Jan-25-2011 - Initial Revision
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Web;
using System.Web.Services;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class PcTokenBanResult
        {
            public Byte[]  VoucherHash;
            public HResult Result;

            public PcTokenBanResult()
            {
            }

            public PcTokenBanResult(Byte[] voucherHash, HResult result)
            {
                VoucherHash = voucherHash;
                Result      = result;  
            }
        }

        [WebMethod]
        public PcTokenBanResult[] BanPcTokens(
            Byte[][] tokens
            )
        {
            PcTokenBanResult[] pcTokenBanResults = new PcTokenBanResult[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( tokens, "pcTokens" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                pcTokenBanResults = BanPcTokensImpl( tokens );
                return pcTokenBanResults;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                throw;
            }
            finally
            {
                foreach (PcTokenBanResult result in pcTokenBanResults)
                {
                    string voucherString = Utilities.ByteArrayToString( 
                        result.VoucherHash 
                        );

                    Xom.Log(
                        XomAreaName.log,
                        string.Join(
                            "|",
                            new string[] {
                                "BanPcTokens",
                                voucherString,
                                result.Result.ToString(),
                                HttpContext.Current.Request.UserHostAddress }
                            )
                        );
                }
            }
        }

        private PcTokenBanResult[] BanPcTokensImpl(
            Byte[][] tokens 
            )
        {
            byte[][]               uniqueTokens     = null;
            HashSet<Puid>          failedPuidsSet   = new HashSet<Puid>();
            HashSet<Puid>          uniquePuidsSet   = new HashSet<Puid>();
            HashSet<string>        failedTokensSet  = new HashSet<string>();
            HashSet<string>        uniqueTokensSet  = new HashSet<string>();
            List<Puid>             uniquePuidsList  = new List<Puid>(); 
            List<PcTokenBanResult> banResultsList   = new List<PcTokenBanResult>();
            List<string>           uniqueTokensList = new List<string>();
            string[]               failedTokens     = null;

            //
            // Make sure that the tokens are all properly formated
            // 
            foreach (byte[] token in tokens)
            {
                if (token.Length != 20)
                {
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "Token Hashes must be 20 bytes long: {0}",
                        Utilities.ByteArrayToString( token )
                        );
                }
            }

            //
            // Generate a duplicate free set of tokens
            // 
            Utilities.UniqueAdd( 
                Array.ConvertAll(
                    tokens, 
                    ( u => (string) Convert.ToBase64String( u ) )
                    ),
                uniqueTokensSet, 
                uniqueTokensList 
                );
            uniqueTokens = Array.ConvertAll(
                uniqueTokensList.ToArray(),
                ( u => (byte[]) Convert.FromBase64String( u ) )
                );

            //
            // Convert the list of tokens into PC Puids.
            // 
            PcTokenInfoInternal[] pcTokenList;
            pcTokenList = LookupMachinePuidsByPcTokensInternal(
                uniqueTokens
                );
            Utilities.UniqueAdd( 
                Array.ConvertAll( pcTokenList, ( u=> (Puid) u.MachinePuid ) ),
                uniquePuidsSet,
                uniquePuidsList
                );

            //
            // Ban the all the machines we have calculated
            // 
            Puid[] failedPuids = BanMachinePuidsInternal(
                uniquePuidsList.ToArray(),
                HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED,
                DateTime.UtcNow,
                DateTime.MaxValue
                );
            Utilities.UniqueAdd( failedPuids, failedPuidsSet );

            //
            // Corrolate failures back to PcTokens
            // 
            foreach (PcTokenInfoInternal info in pcTokenList)
            {
                if (failedTokensSet.Contains(info.EncodedHash) == true)
                {
                    continue;
                }
                if (failedPuidsSet.Contains(info.MachinePuid) == true)
                {
                    failedTokensSet.Add(info.EncodedHash);
                }
            }

            //
            // Ban all the tokens we have
            // 
            failedTokens = BanPcTokensInternal(
                uniqueTokens,
                true
                );
            Utilities.UniqueAdd( failedTokens, failedTokensSet );

            //
            // Build and return the outcome
            //                  
            foreach (string encodedVoucher in uniqueTokensSet)
            {
                HResult result = HResult.S_OK;

                if (failedTokensSet.Contains( encodedVoucher ) == true)
                {
                    result = HResult.E_FAIL;
                }

                PcTokenBanResult banResult = new PcTokenBanResult(
                    Convert.FromBase64String( encodedVoucher ),
                    result
                    );
                banResultsList.Add(banResult);
            }
            return banResultsList.ToArray();
        }

        private
        string[]
        BanPcTokensInternal(
            byte[][] tokens,
            bool     banToken
            )
        {
            List<string> failedEncodedTokens = new List<string>();

            //
            // Use Webstore to update the relevant rows
            //
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                HResult     hr         = HResult.S_OK;
                DataTable[] dataTables = Utilities.TokensToDataTables(ws, tokens, false);

                //
                // Update records across all the partitions
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    // Skip over partitions with no work
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    // Build the parameters
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_set_voucher_status";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_voucher_lookup_list", dataTables[i]);
                    ws.AddParameter(ParamType.INPUT, "@i_voucher_status", (int) (banToken ? 2 : 0) );
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr );

                    // Execute
                    WstDataReader reader = null;
                    bool queryIsFailed = false;
                    try
                    {
                        reader = ws.Execute();

                        // Check the return
                        hr = (uint) ws.GetIntParameter("@RETVAL");
                        if (hr.IsFailure())
                        {
                            queryIsFailed = true;
                        }
                    }
                    catch (Exception e)
                    {
                        queryIsFailed = true;
                        Xom.Trace(
                            XomAreaName.xmachine,
                            LogLevel.L_WARNING,
                            "BanPcTokensInternal Exception: " + e.ToString()
                            );
                    }

                    if (queryIsFailed)
                    {
                        // If the whole query failed, add all of the vouchers to the failed list
                        foreach (DataRow row in dataTables[i].Rows)
                        {
                            failedEncodedTokens.Add( Convert.ToBase64String( (byte[]) row["bin_voucher_hash"] ) );
                        }
                    }

                    if (reader != null)
                    {
                        using (reader)
                        {
                            // First result set is a list of failed vouchers
                            while (reader.Read())
                            {
                                byte[] voucherHash = WSClient.GetBytes(reader, "bin_voucher_hash");
                                string encodedToken = Convert.ToBase64String(voucherHash);
                                if (!failedEncodedTokens.Contains(encodedToken))
                                {
                                    failedEncodedTokens.Add(encodedToken);
                                }
                            }
                        }
                    }
                }
            }
            return failedEncodedTokens.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\BanMachinePuids.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// BanMachinePuids.cs
//
// Implementation of BanMachinesPuids SOAP API for XMachine FD
//
// Jan-13-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod and Internal
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Web;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class MachinePuidResult
        {
            public Puid    MachinePuid;
            public HResult Result;

            public MachinePuidResult()
            {
            }

            public MachinePuidResult(Puid machinePuid, HResult result)
            {
                MachinePuid = machinePuid;
                Result      = result;
            }
        }

        [WebMethod]
        public MachinePuidResult[] BanMachinePuids(
            Puid[]   puids,
            HResult  reasonCode,
            DateTime banStart,
            DateTime banEnd
            )
        {
            MachinePuidResult[] machinePuidResults = new MachinePuidResult[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( puids, "machinePuids" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                machinePuidResults = BanMachinePuidsImpl( puids, reasonCode, banStart, banEnd );
                return machinePuidResults;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                throw;
            }
            finally
            {
                foreach (MachinePuidResult result in machinePuidResults)
                {
                    Xom.Log(
                        XomAreaName.log,
                        string.Join(
                            "|",
                            new string[] {
                                "BanMachinePuids",
                                result.MachinePuid.ToString(),
                                reasonCode.ToString(),
                                banStart.ToString(),
                                banEnd.ToString(),
                                result.Result.ToString(),
                                HttpContext.Current.Request.UserHostAddress }
                            )
                        );
                }
            }
        }

        private MachinePuidResult[] BanMachinePuidsImpl(
            Puid[]   puids,
            HResult  reasonCode,
            DateTime banStart,
            DateTime banEnd
            )
        {
            bool                    hasPcPuids      = false;
            HashSet<Puid>           failedPuidsSet  = new HashSet<Puid>();
            HashSet<Puid>           uniquePuidsSet  = new HashSet<Puid>();
            List<MachinePuidResult> banResultsList  = new List<MachinePuidResult>();
            List<Puid>              uniquePuidsList = new List<Puid>();
            Puid[]                  failedPuids     = new Puid[0];

            //
            // Sanity Checks
            //    1 --- ReasonCode must be an HResult failure code
            //    2 --- BanStart must occur before BanEnd
            //    3 --- BanStart must be convertable to SqlDateTime format
            // 
            if (reasonCode.IsFailure() == false)
            {   
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid ReasonCode: {0}", 
                    reasonCode
                    );    
            }
            if (banEnd < banStart)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "BanEnd:{0} < BanStart:{1}",
                    banEnd,
                    banStart
                    );
            }
            if (banStart < (DateTime) SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid BanStart:{0}",
                    banStart
                    );
            }

            //
            // Unique Puid list 
            // 
            puids = Utilities.UniqueIds<Puid>(puids);

            //
            // Sanity Check Machine Puis and determine if any PC puids are present
            // 
            hasPcPuids = Utilities.CheckForPcMachinePuids( puids, reasonCode, banStart, banEnd );

            //
            // Generate a duplicate free set of puids
            // 
            Utilities.UniqueAdd( puids, uniquePuidsSet, uniquePuidsList );

            //
            // If we have some PC machines, determine
            // the tokens that were used and ban them
            // 
            // This will also ban all machines associated with
            // that token
            // 
            if (hasPcPuids == true)
            {
                byte[][]              pcTokens    = new byte[0][];
                PcTokenInfoInternal[] pcTokenList = new PcTokenInfoInternal[0];

                try
                {
                    //
                    // Convert the list of PC Puids into the complete list of 
                    // puids and tokens
                    // 
                    pcTokenList = LookupPcMachinePuidsByMachinePuidsInternal(
                        uniquePuidsList.ToArray()
                        );

                    //
                    // Determine a unique set of pc tokens (in encoded form)
                    // 
                    HashSet<string> uniqueEncodedPcTokensSet = new HashSet<string>();
                    Utilities.UniqueAdd( 
                        Array.ConvertAll( pcTokenList, ( u => (string) u.EncodedHash ) ),
                        uniqueEncodedPcTokensSet
                        );

                    string[] encodedPcTokens = new string[uniqueEncodedPcTokensSet.Count];
                    uniqueEncodedPcTokensSet.CopyTo( encodedPcTokens );

                    //
                    // Convert back to a byte representation
                    // 
                    pcTokens = Array.ConvertAll(
                        encodedPcTokens,
                        ( u => (byte[]) Convert.FromBase64String( u ) )
                        );

                    //
                    // Look at each PC puid and make sure that it is 
                    // in the list of PCs to ban
                    // 
                    Utilities.UniqueAdd( 
                        Array.ConvertAll( pcTokenList, ( u => (Puid) u.MachinePuid ) ),
                        uniquePuidsSet,
                        uniquePuidsList
                        );
                }
                catch (Exception e)
                {
                    HResult hr = XblException.GetHResult(e);

                    return Array.ConvertAll<Puid,MachinePuidResult>(
                        uniquePuidsList.ToArray(),
                        ( u => new MachinePuidResult( u, hr ) )
                        );
                }

                //
                // Ban the tokens but remember which failed
                // 
                string[] failedEncodedTokens = BanPcTokensInternal(
                    pcTokens,
                    true
                    );

                //
                // Corrolate the failures back to Puids
                // 
                HashSet<string> failedEncodedTokensSet = new HashSet<string>();
                Utilities.UniqueAdd( failedEncodedTokens, failedEncodedTokensSet );

                foreach (PcTokenInfoInternal info in pcTokenList)
                {
                    if (failedPuidsSet.Contains(info.MachinePuid) == true)
                    {
                        continue;
                    }
                    if (failedEncodedTokensSet.Contains(info.EncodedHash) == true)
                    {
                        failedPuidsSet.Add(info.MachinePuid);
                    }
                }
            }

            //
            // Ban the all the machines we have calculated
            // 
            failedPuids = BanMachinePuidsInternal(
                uniquePuidsList.ToArray(),
                reasonCode,
                banStart,
                banEnd
                );
            Utilities.UniqueAdd( failedPuids, failedPuidsSet );

            //
            // Build and return the outcome
            // 
            foreach (Puid puid in uniquePuidsSet)
            {
                MachinePuidResult banResult = new MachinePuidResult(
                    puid,
                    (failedPuidsSet.Contains( puid ) == false ? HResult.S_OK : HResult.E_FAIL)
                    );
                banResultsList.Add(banResult);
            }
            return banResultsList.ToArray();
        }

        private Puid[] BanMachinePuidsInternal(
            Puid[]   puids,
            HResult  reasonCode,
            DateTime banStart,
            DateTime banEnd
        )
        {
            List<Puid> failedPuids = new List<Puid>();

            //
            // Use Webstore to update the relevant rows
            //
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                HResult     hr         = HResult.S_OK;
                DataTable[] dataTables = Utilities.PuidsToDataTables(ws, puids, true); 
                
                //
                // Update records across all the partitions
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    // Skip over partitions with no work
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    // Build the parameters
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_update_machine_ban";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_machine_list", dataTables[i]);
                    ws.AddParameter(ParamType.INPUT, "@i_reason_code", reasonCode);
                    ws.AddParameter(ParamType.INPUT, "@dt_start", banStart);
                    ws.AddParameter(ParamType.INPUT, "@dt_end",   banEnd);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr );

                    // Execute
                    WstDataReader reader = null;
                    bool queryIsFailed = false;
                    try
                    {
                        reader = ws.Execute();

                        // Check the return
                        hr = (uint) ws.GetIntParameter("@RETVAL");
                        if (hr.IsFailure())
                        {
                            queryIsFailed = true;
                        }
                    }
                    catch (Exception e)
                    {
                        queryIsFailed = true;

                        Xom.Trace(
                            XomAreaName.xmachine,
                            LogLevel.L_WARNING,
                            "BanMachinePuidsInternal Exception: " + e.ToString()
                            );
                    }

                    if (queryIsFailed)
                    {
                        // If the whole query failed, add all of the puids to the failed list
                        foreach (DataRow row in dataTables[i].Rows)
                        {
                            failedPuids.Add( (Puid) (long) row["bi_machine_puid"] );
                        }
                    }

                    if (reader != null)
                    {
                        using (reader)
                        {
                            // First result set is a list of failed puids
                            while (reader.Read())
                            {
                                Puid machinePuid = (ulong) WSClient.GetInt64(reader, "bi_machine_puid");
                                if (!failedPuids.Contains(machinePuid))
                                {
                                    failedPuids.Add(machinePuid);
                                }
                            }
                        }
                    }
                }
            }
            return failedPuids.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\BanConsoleIds.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// BanConsoleIds.cs
//
// Implementation of BanConsoleIds SOAP API for XMachine FD
//
// Jan-18-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod and Internal
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Web;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class ConsoleIdResult
        {
            public String  ConsoleId;
            public HResult Result;

            public ConsoleIdResult()
            {
            }

            public ConsoleIdResult(String consoleId, HResult result)
            {
                ConsoleId = consoleId;
                Result    = result;
            }
        }

        [WebMethod]
        public ConsoleIdResult[] BanConsoleIds(
            string[] consoleIds,
            HResult  reasonCode,
            DateTime banStart
        )
        {
            ConsoleIdResult[] consoleIdResults = new ConsoleIdResult[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( consoleIds, "consoleIds" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                consoleIdResults = BanConsoleIdsImpl( consoleIds, reasonCode, banStart );
                return consoleIdResults;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                throw;                
            }
            finally
            {
                foreach (ConsoleIdResult result in consoleIdResults)
                {
                    Xom.Log(
                        XomAreaName.log,
                        string.Join(
                            "|",
                            new string[] {
                                "BanConsoleIds",
                                result.ConsoleId,
                                reasonCode.ToString(),
                                banStart.ToString(),
                                result.Result.ToString(),
                                HttpContext.Current.Request.UserHostAddress }
                            )
                        );
                }
            }

        }

        private ConsoleIdResult[] BanConsoleIdsImpl(
            string[] consoleIds,
            HResult  reasonCode,
            DateTime banStart
            )
        {
            ConsoleIdInfo[]       consoleIdList  = new ConsoleIdInfo[0];
            HashSet<string>       failedIdsSet   = new HashSet<string>();
            List<ConsoleIdResult> banResultsList = new List<ConsoleIdResult>();
       
            //
            // Sanity Checks:
            //    1 --- ReasonCode must be an HResult failure code
            //    2 --- BanStart must be expressable as a SqlDateTime
            // 
            if (reasonCode.IsFailure() == false)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid ReasonCode: {0}", 
                    reasonCode
                    );    
            }
            if (banStart < (DateTime) SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid BanStart:{0}",
                    banStart
                    );
            }

            //
            // Verify that the console ids are correctly formatted Xbox 360
            // console ids. We don't want to populate our database with 
            // invalid entries.
            // 
            consoleIds = ConsoleIds.Validate(consoleIds, true);

            //
            // Convert the console ids into machine puids
            // 
            try 
            {
                consoleIdList = LookupMachinePuidsByConsoleIdsInternal(consoleIds);
            }
            catch (Exception e)
            {
                HResult hr = XblException.GetHResult(e);

                return Array.ConvertAll<string,ConsoleIdResult>(
                    consoleIds,
                    ( u => new ConsoleIdResult( u, hr ) )
                    );
            }

            //
            // If we have any machine puids, attempt to ban them
            // 
            if (consoleIdList.Length > 0)
            {
                HashSet<Puid> machinePuidsSet  = new HashSet<Puid>();
                List<Puid>    machinePuidsList = new List<Puid>();

                Utilities.UniqueAdd(
                    Array.ConvertAll( consoleIdList, ( u => (Puid) u.MachinePuid ) ),
                    machinePuidsSet,
                    machinePuidsList
                    );

                Puid[] failedPuids = BanMachinePuidsInternal(
                    machinePuidsList.ToArray(),
                    reasonCode,
                    banStart,
                    DateTime.MaxValue
                    );

                //
                // Remember failures
                // 
                HashSet<Puid> failedPuidsSet = new HashSet<Puid>();
                Utilities.UniqueAdd( failedPuids, failedPuidsSet );

                //
                // Corrolate to ConsoleId failures
                // 
                foreach (ConsoleIdInfo info in consoleIdList)
                {
                    if (failedIdsSet.Contains(info.ConsoleId) == true)
                    {
                        continue;
                    }
                    if (failedPuidsSet.Contains(info.MachinePuid) == true)
                    {
                        failedIdsSet.Add(info.ConsoleId);
                    }
                }
            }

            //
            // Ban all the console ids we have found
            // 
            string[] tempFailedIdsList;
            tempFailedIdsList = BanConsoleIdsInternal(
                consoleIds,
                reasonCode,
                banStart
                );
            Utilities.UniqueAdd( tempFailedIdsList, failedIdsSet );

            //
            // Build and return the outcome
            // 
            foreach (string id in consoleIds)
            {
                ConsoleIdResult banResult = new ConsoleIdResult(
                    id,
                    (failedIdsSet.Contains( id ) == false ? HResult.S_OK : HResult.E_FAIL)
                    );
                banResultsList.Add( banResult );
            }
            return banResultsList.ToArray();
        }

        private string[] BanConsoleIdsInternal(
            string[] consoleIds,
            HResult  reasonCode,
            DateTime banStart
        )
        {
            List<string> failedIds = new List<string>();

            //
            // Use Webstore to update the relevant rows
            //
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                HResult     hr            = HResult.S_OK;
                DataTable[] consoleTables = Utilities.ConsoleIdsToDataTables(ws, consoleIds, true);

                //
                // Update records across all the partitions for the console ids
                // 
                for (int i = 0; i < consoleTables.Length; ++i)
                {
                    // Skip over partitions with no work
                    if (consoleTables[i] == null)
                    {
                        continue;
                    }

                    // Build the parameters
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_update_console_ban";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_console_list", consoleTables[i]);
                    ws.AddParameter(ParamType.INPUT, "@i_reason_code", reasonCode);
                    ws.AddParameter(ParamType.INPUT, "@dt_start", banStart);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr );

                    // Execute
                    try
                    {
                        ws.ExecuteNonQuery();

                        // Check the return
                        hr = (uint) ws.GetIntParameter("@RETVAL");
                        if (hr.IsFailure())
                        {
                            throw new XRLExceptionWithoutEvent(
                                hr,
                                "p_xmachine_update_console_ban() failed"
                                );
                        }
                    }
                    catch (Exception)
                    {
                        // Remember which console ids we failed on
                        foreach (DataRow row in consoleTables[i].Rows)
                        {
                            failedIds.Add( ( (string) row["vc_console_id"]).ToUpper() );
                        }
                    }
                }
            }
            return failedIds.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\ConsoleIds.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// ConsoleIds.cs
//
// Misc ConsoleId Functions for XMachine FD
//
// Feb-28-2011 - Initial Revision
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public class ConsoleIds
    {
        private const int    DOT_OFFSET     = 2;
        private const int    PREFIX_LENGTH  = 3;
        private const string PREFIX_XBOX360 = "XE.";
        private const int    VALID_LENGTH   = 15;

        public static string Validate(string consoleId, bool xbox360Only)
        {
            bool   isXbox360 = false;
            string id        = consoleId;

            // Basic Sanity Checks
            if (id == null || id.Length != VALID_LENGTH || id[DOT_OFFSET] != '.')
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_LOGON_INVALID_CONSOLE_ID,
                    "Invalid ConsoleId: {0}",
                    id
                    );
            }

            // Upper ConsoleIds
            id = id.ToUpper();

            // Extra checks to require an Xbox 360s console ids
            isXbox360 = HasXbox360Prefix(id);
            if (xbox360Only == true && isXbox360 != true)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_LOGON_INVALID_CONSOLE_ID,
                    "Invalid Non-Xbox360 ConsoleId: {0}",
                    id
                    );
            }
            if (isXbox360 == true && HasXbox360Checksum(id) == false)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_LOGON_INVALID_CONSOLE_ID,
                    "Invalid Checksum for ConsoleId: {0}",
                    id
                    );
            }
            return id;
        }

        public static string[] Validate(string[] consoleIds, bool xbox360Only)
        {
            consoleIds = Utilities.UniqueIds<string>(Array.ConvertAll<string,string>(consoleIds, ( u => u.ToUpper())));

            foreach (string id in consoleIds)
            {
                Validate( id, xbox360Only );
            }
            return consoleIds;
        }

        public static bool HasXbox360Prefix(string id)
        {
            if (id != null && id.Length == VALID_LENGTH && id.StartsWith(PREFIX_XBOX360) == true)
            {
                return true;
            }
            return false;
        }

        public static bool HasXbox360Checksum(string id)
        {
            if (HasXbox360Prefix(id) == false)
            {
                return false;
            }

            // Convert console id to Decimal format
            uint actualChecksum = 0;
            uint reportedCheckSum = 0;
            ulong subConsoleId;

            try
            {
                string temp = id.Substring( PREFIX_LENGTH );

                subConsoleId = ulong.Parse(
                    temp.Substring(
                        0,
                        temp.Length - 1
                        )
                    );
                reportedCheckSum = uint.Parse(
                    temp.Substring(
                        temp.Length - 1
                        )
                    );
            }
            catch (Exception)
            {
                return false;
            }

            // Range check
            if (subConsoleId == 0 || subConsoleId > 0x0FFFFFFFFF)
            {
                return false;
            }

            // Calculate the checksum
            while (subConsoleId != 0)
            {
                actualChecksum += (uint) (subConsoleId % 10);
                subConsoleId /= 10;
            }

            // Validate the checksum
            actualChecksum %= 10;
            if (reportedCheckSum != actualChecksum)
            {
                return false;
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xlfs\worker\xlfsgc\dll\XlfsGcAgeOutGcCommenceHandler.cs ===
using System;
using System.Globalization;
using Microsoft.WindowsAzure.StorageClient;
using xonline.server.xlfs.common;

namespace xonline.server.xlfs.fd.xlfsgc
{
    [XlfsGcMessageHandler(XlfsConstants.AgeOutGcCommenceMessage)]
    public class XlfsGcAgeOutGcCommenceHandler : IXlfsGcMessageHandler
    {
        /// <summary>
        /// Process an AgeOutGcCommence message.  Queue up an AgeOutGc message, and a new
        /// AgeOutGcCommence message for the future.
        /// </summary>
        public void HandleMessage(XlfsGcMessage msg, IXlfsTrace trace)
        {
            trace.AppendInfoLine("XlfsGcAgeOutGcCommenceHandler.HandleMessage: Enter");

            try
            {
                DateTime now = DateTime.UtcNow;
                DateTime nextAgeOutGcCommence;

                string nextStart = msg.Xml.DocumentElement.GetAttribute("nextStart");
                string startPartition = msg.Xml.DocumentElement.GetAttribute("startPartition");

                // If the 'nextStart' attribute is null, or an invalid
                // datetime, just use the current time.
                if (string.IsNullOrEmpty(nextStart) || 
                    !DateTime.TryParseExact(nextStart, "o", null, DateTimeStyles.RoundtripKind, out nextAgeOutGcCommence))
                {
                    trace.AppendInfoLine(
                        "XlfsGcAgeOutGcCommenceHandler.HandleMessage: nextStart attribute ({0}) " +
                        "was invalid or not specified, using the current time.",
                        string.IsNullOrEmpty(nextStart) ? "" : nextStart);
                    nextAgeOutGcCommence = now;
                }

                if (nextAgeOutGcCommence > now)
                {
                    // It's not time to commence another round of age outs yet.
                    // Let this message be processed again next time it becomes
                    // visible.
                    trace.AppendInfoLine(
                        "XlfsGcAgeOutGcCommenceHandler.HandleMessage: The nextStart attribute in this " +
                        "message ({0}) indicated that it is not yet time to commence another round of age outs.",
                        nextStart);
                    return;
                }

                if(string.IsNullOrEmpty(startPartition))
                {
                    startPartition =
                        GarbageCollector.MinimumPartitionDateTime.ToString(
                            FileTableLastUpdateEntry.PartitionKeyFormatString);
                }

                // Add the first age out message to the queue to kick off
                // a round of age outs.
                string nextAgeOutGcMessage = string.Format(XlfsConstants.AgeOutGcFormat, startPartition);
                GarbageCollector.GcQueue.AddMessage(new CloudQueueMessage(nextAgeOutGcMessage));
                trace.AppendInfoLine(
                    "XlfsGcAgeOutGcCommenceHandler.HandleMessage: New AgeOutGcMessage enqueued:\r\n{0}",
                    nextAgeOutGcMessage);

                // Delete the message from the queue when we're done.
                GarbageCollector.GcQueue.DeleteMessage(msg.Message);
                trace.AppendInfoLine(
                    "XlfsGcAgeOutGcCommenceHandler.HandleMessage: Current AgeOutGcCommence message deleted from queue.");
            }
            finally
            {
                trace.AppendInfoLine("XlfsGcAgeOutGcCommenceHandler.HandleMessage: Exit");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\HistoryDetails.cs ===
// HistoryDetails.cs
// Copyright (c) Microsoft Corporation.  All Rights Reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using System.Xml.Serialization;

namespace xonline.server.xmachine.fd
{
    [Serializable]
    public class HistoryParams
    {
        public string StoredProc;
        public string ThresholdSetting;
        public string IntervalSetting;
        public XEvent.Id EventId;
        public string Message;
        public byte[] Reasons;
        public bool UseHash;

        public HistoryParams(string storedProcIn, string thresholdSettingIn, string intervalSettingIn, XEvent.Id eventIdIn, string messageIn, params byte[] reasonsIn)
        {
            StoredProc = storedProcIn;
            ThresholdSetting = thresholdSettingIn;
            IntervalSetting = intervalSettingIn;
            EventId = eventIdIn;
            Message = messageIn;
            Reasons = reasonsIn;
            UseHash = true;
        }

        public HistoryParams(string storedProcIn, string thresholdSettingIn, string intervalSettingIn, XEvent.Id eventIdIn, string messageIn, bool useHash, params byte[] reasonsIn)
        {
            StoredProc = storedProcIn;
            ThresholdSetting = thresholdSettingIn;
            IntervalSetting = intervalSettingIn;
            EventId = eventIdIn;
            Message = messageIn;
            Reasons = reasonsIn;
            UseHash = useHash;
        }

        public int Threshold { get { return Config.GetIntSetting(ThresholdSetting); } }
        public int Interval { get { return Config.GetIntSetting(IntervalSetting); } }
    }

    public abstract class HistoryDetails
    {
        public Puid  UserPuid;
        public Puid  MachinePuid;
        public string IpAddress;
        public DateTime Timestamp;
        public HResult HResult;
        public byte Reason;
        [XmlIgnore]
        public string Details;

        public HistoryDetails()
        {
        }
 
        public HistoryDetails(Puid userPuidIn, Puid machinePuidIn, string ipAddressIn, HResult hrIn, byte reasonIn)
        {
            UserPuid    = userPuidIn;

            MachinePuid = (Puid)machinePuidIn;
            IpAddress   = ipAddressIn;

            Timestamp   = DateTime.UtcNow;
            HResult     = hrIn;
            Reason      = reasonIn;
        }
    }

    public class HistorySummary
    {
        public DateTime? First { get; set; }
        public DateTime? Last { get; set; }
        public int Total { get; set; }
        public int Unique { get; set; }

        public HistorySummary()
        {
        }

        public HistorySummary(HistoryDetails[] historyDetails)
        {
            Unique = Total = historyDetails.Length;

            foreach (HistoryDetails historyDetail in historyDetails)
            {
                if ((First == null) || (historyDetail.Timestamp < First))
                {
                    First = historyDetail.Timestamp;
                }

                if ((Last == null) || (historyDetail.Timestamp > Last))
                {
                    Last = historyDetail.Timestamp;
                }
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\HealthCheck.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// HealthCheck.cs
//
// Implementation of HealthCheck for XMachine FD
//
// Jan-09-2011 - Initial Revision
//

using System;
using System.Collections;
using System.Collections.Specialized;

using xonline.common.health;

namespace xonline.server.xmachine.fd
{
    /// <summary>
    /// XMachine Custom Healthcheck
    /// </summary>
    public class XMachineHealthBlock : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        /// <summary>
        /// Healthcheck Entry Point
        /// </summary>
        /// <param name="blockManager"></param>
        /// <param name="blockParams"></param>
        /// <param name="report"></param>
        public void DoCheck(
            HealthBlockManager  blockManager,
            NameValueCollection blockParams,
            HealthReport        report
            )
        {
            // We don't have an extended report
            report.ExtendedReport = null;

            // Indicate that we are healthy
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }

} // xonline.server.xmachine.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupBanHistoryByMachinePuid.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupBanHistoryByMachinePuids.cs
//
// Implementation of LookupBansByMachinePuids SOAP API for XMachine FD
//
// Feb-28-2011 - Initial Revision


using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class MachineBanHistoryInfo
        {
            public Puid     MachinePuid;
            public DateTime EntryDate;
            public HResult  ReasonCode;
            public DateTime BanStart;
            public DateTime BanEnd;

            public MachineBanHistoryInfo()
            {
            }

            public MachineBanHistoryInfo(
                Puid     machinePuid, 
                DateTime entryDate,
                HResult  reasonCode, 
                DateTime banStart, 
                DateTime banEnd
                )
            {
                MachinePuid = machinePuid;
                EntryDate   = entryDate;
                ReasonCode  = reasonCode;
                BanStart    = banStart;
                BanEnd      = banEnd;
            }
        }

        [WebMethod]
        public MachineBanHistoryInfo[] LookupBanHistoryByMachinePuid(
             Puid puid,
             DateTime? since
            )
        {
            MachineBanHistoryInfo[] machineBanhistory = new MachineBanHistoryInfo[0];
            HResult hr                                = HResult.S_OK;

            if (since.HasValue == true && since.Value < (DateTime) SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid since:{0}",
                    since.Value
                    );
            }

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                machineBanhistory = LookupBanHistoryByMachinePuidInternal(puid, since);

                return machineBanhistory;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                Xom.Log(
                    XomAreaName.log, "LookupBanHistoryByMachinePuid|{0}|{1}|{2}",
                    hr, puid, machineBanhistory.Length
                );
            }
        }

        public MachineBanHistoryInfo[] LookupBanHistoryByMachinePuidInternal(
            Puid puid,
            DateTime? since
            )
        {
            List<MachineBanHistoryInfo> machineBanHistoryList = new List<MachineBanHistoryInfo>();

            //
            // Use webstore to lookup the relevant rows
            // 
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                //
                // Craft the webstore call
                // 
                ws.ClearParameters();
                ws.StoredProc = "dbo.p_xmachine_lookup_ban_history_by_puid";
                ws.SetHashVal(puid);
                ws.Parameters.AddWithValue("@bi_machine_puid", (long) puid);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", (int) HResult.S_OK );

                if (since != null) ws.Parameters.AddWithValue("@dt_since", since);

                //
                // Execute
                // 
                using (WstDataReader reader = ws.Execute())
                {
                    HResult hr = (uint) ws.GetIntParameter("@RETVAL");
                    if (hr.IsFailure())
                    {
                        throw new XRLExceptionWithoutEvent(
                            hr,
                            "Invalid puid:{0}",
                            puid
                            );
                    }

                    while (reader.Read())
                    {
                        //
                        // Read the results
                        // 
                        Puid machinePuid = (ulong)WSClient.GetInt64(reader, "bi_machine_puid");
                        DateTime entryDate = WSClient.GetDateTime(reader, "dt_timestamp");
                        HResult reasonCode = WSClient.GetUInt32(reader, "i_reason_code");
                        DateTime banStart = WSClient.GetDateTime(reader, "dt_start");
                        DateTime banEnd = WSClient.GetDateTime(reader, "dt_end");

                        //
                        // Build the record
                        // 
                        MachineBanHistoryInfo info = new MachineBanHistoryInfo(
                            machinePuid,
                            entryDate,
                            reasonCode,
                            banStart,
                            banEnd
                            );

                        //
                        // Remember the record
                        // 
                        machineBanHistoryList.Add(info);
                    }
                }
            }

            //
            // Return the completed lookups
            //
            return machineBanHistoryList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LogPassportHistory.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Web;
using CORE = xonline.core.history;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class PassportHistoryDetails : HistoryDetails
        {
            public ulong ?OldPassportPuid;
            public ulong ?NewPassportPuid;

            public PassportHistoryDetails()
            {
            }

            public PassportHistoryDetails(
                Puid userPuidIn, Puid machinePuidIn, string ipAddressIn, HResult hrIn, byte reasonIn, Puid? oldPassportPuid, Puid? newPassportPuid
            )
                : base(userPuidIn, machinePuidIn, ipAddressIn, hrIn, reasonIn)
            {
                OldPassportPuid = oldPassportPuid;
                NewPassportPuid = newPassportPuid;

                InitDetails();
            }

            public void InitDetails()
            {
                Details = string.Format(
                     "OldPassportPuid = {0}, NewPassportPuid = {1}",
                     OldPassportPuid == null ? "<none>" : "'" + OldPassportPuid + "'",
                     NewPassportPuid == null ? "<none>" : "'" + NewPassportPuid + "'");
            }
        }

        [WebMethod]
        public void LogPassportHistory(PassportHistoryDetails phd)
        {
            HResult hr = HResult.S_OK;

            if (phd == null)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Null parameter: PassportHistoryDetails"
                    );
            }

            if (phd.Timestamp < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid Timestamp:{0}",
                    phd.Timestamp.ToString()
                    );
            }

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                LogPassportHistoryInternal(phd);
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                Xom.Log(XomAreaName.log, "LogPassportHistory|{0}|{1}|{2}|{3}|{4}",
                         hr, phd.UserPuid, phd.MachinePuid.ToString(), phd.IpAddress, HttpContext.Current.Request.UserHostAddress);

            }

        }

        private void LogPassportHistoryInternal(PassportHistoryDetails phd)
        {
            HResult hr = HResult.S_OK;

            if ((phd.MachinePuid == 0) || (XOn.XboxId.IsMachinePuid((UInt64)phd.MachinePuid)) == false)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "MachinePuid is invalid: {0}",
                    phd.MachinePuid
                    );
            }

            if (phd.NewPassportPuid == phd.OldPassportPuid)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "NewPassportPuid cannot be equal to OldPassportPuid: {0}|{1}",
                    phd.NewPassportPuid, phd.OldPassportPuid
                    );
            }

            if ((phd.NewPassportPuid == null) && (phd.OldPassportPuid == null))
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "NewPassportPuid and OldPassportPuid cannot both be null: {0}|{1}",
                    phd.NewPassportPuid, phd.OldPassportPuid
                    );
            }

            if (Enum.IsDefined(typeof(xonline.core.history.HistoryReason), (int)phd.Reason) == false)
            {
                //we did not find the machine puid, it is not valid
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "HistoryReason is invalid: {0}",
                    phd.Reason
                    );
            }

            //Verify the machinepuid
            MachinePuidInfo[] mPuids = LookupConsoleIdsByMachinePuidsInternal(new Puid[] { phd.MachinePuid });

            if ((mPuids == null) || (mPuids.Length < 1))
            {
                //we did not find the machine puid, it is not valid
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "MachinePuid is invalid on lookup: {0}",
                    phd.MachinePuid
                    );
            }

            LogDetail(phd, _machinePassportParams, ConfigUtil.SecMachineHistoryWebstoreApp);

            if (Config.GetBoolSetting(Setting.xmachine_doubleWriteHistory))
            {
                LogDetail(phd, _machinePassportParamsUODB, ConfigUtil.UodbWebstoreApp);
            }

        }

        private void LogDetail(PassportHistoryDetails phd, HistoryParams historyParams, string databaseName)
        {

            Puid hashVal = (Puid)phd.MachinePuid;

            using (WSClient ws = new WSClient(databaseName, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // parameterized stored procedures  and  hashes
                // allow writes to different  tables/partitions

                ws.StoredProc = historyParams.StoredProc;
                ws.SetHashVal(hashVal);

                // add all of the standard fields to the record

                ws.AddParameter("bi_user_puid", phd.UserPuid);
                ws.AddParameter("dt_timestamp", phd.Timestamp);
                ws.AddParameter("i_hr", phd.HResult);
                ws.AddParameter("ti_reason", (byte)phd.Reason);

                // some common fields can be null.  check  that

                if (phd.MachinePuid != 0) ws.AddParameter("bi_machine_puid", (Puid)phd.MachinePuid);
                if (phd.IpAddress != null) ws.AddParameter("vc_ip_address", phd.IpAddress);
                ws.AddParameter("dt_since", DateTime.UtcNow.AddDays(-historyParams.Interval));

                if (historyParams.UseHash) ws.AddParameter("si_hash_bucket", ws.Partition);

                // finally we add the operation specific params
                // for particular operational details we record

                if (phd.OldPassportPuid != null) ws.AddParameter("bi_old_passport_puid", (Puid)phd.OldPassportPuid);
                if (phd.NewPassportPuid != null) ws.AddParameter("bi_new_passport_puid", (Puid)phd.NewPassportPuid);

                // add return value to receive the return value

                HResult hr = HResult.S_OK;
                ws.AddParameter(ParamType.RETVAL, "@hr", hr);

                // execute and convert result set into  history
                // summary used to test  configured  thresholds

                try
                {
                    using (WstDataReader reader = ws.Execute())
                    {
                        if ((hr = (uint)ws.GetIntParameter("@hr")).IsFailure())
                        {
                            throw new XRLException(
                                hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR, "Error logging history"
                            );
                        }
                    }
                }
                catch (Exception e)
                {
                    if (e.InnerException is SqlException)
                    {
                        SqlException    sqlExcept = (SqlException)e.InnerException;

                        if ((sqlExcept.Number == 2601) || (sqlExcept.Number == 2627))//duplicate key
                        {
                            throw new XRLException(
                                hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR,
                                "Existing log record found"
                            );
                        }
                    }
                }
            }
        }

        private static readonly HistoryParams _machinePassportParams = new HistoryParams(
            "p_xmachine_machine_passport_history_add",
            Setting.xuacs_machinePassportThreshold,
            Setting.xuacs_machinePassportIntervalDays,
            XEvent.Id.ACCOUNTS_MACHINE_PASSPORT_THRESHOLD_EXCEEDED,
            "Machine {0} exceeded passport change threshold of {1} unique users in {2} days",
            (byte)CORE.HistoryReason.SwitchUserPassport, (byte)CORE.HistoryReason.PassportChangePassword
        );

        private static readonly HistoryParams _machinePassportParamsUODB = new HistoryParams(
            "p_xuacs_machine_passport_history_add",
            Setting.xuacs_machinePassportThreshold,
            Setting.xuacs_machinePassportIntervalDays,
            XEvent.Id.ACCOUNTS_MACHINE_PASSPORT_THRESHOLD_EXCEEDED,
            "Machine {0} exceeded passport change threshold of {1} unique users in {2} days",
            false,
            (byte)CORE.HistoryReason.SwitchUserPassport, (byte)CORE.HistoryReason.PassportChangePassword
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\IsConsoleIdAndSCodeBanned.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// IsConsoleIdAndSCodeBanned.cs
//
// Implementation of IsConsoleIdBanned SOAP API for XMachine FD
//
// Feb-18-2011 - Initial Revision

using System;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        [WebMethod]
        public bool IsConsoleIdAndSCodeBanned(
            string consoleId,
            byte[] secondaryId
            )
        {
            ConsoleIdInfo[] consoleInfo = new ConsoleIdInfo[0];
            HResult hr = HResult.S_OK;
            bool isBanned = false;

            try
            {
                // Parameter Validation
                // 
                // Make sure that the finally block is not going to throw
                // an exception because one of the two inputs is malformed
                // 
                if (String.IsNullOrEmpty(consoleId))
                {
                    return isBanned;
                }

                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                try
                {
                    if (secondaryId != null)
                    {
                        Utilities.CheckSCodeFormat(secondaryId);
    
                        // Check if any secondary's match and return 
                        // console/machinepuid information
                        consoleInfo = LookupMachinePuidsByConsoleIdAndSCodeInternal(consoleId, secondaryId);
                    }
                    else
                    {
                        string[] consoleIds = new string[1];
                        consoleIds[0] = consoleId;

                        consoleInfo = LookupMachinePuidsByConsoleIdsInternal(consoleIds);
                    }
                }
                catch  
                {      
                    // If anything goes wrong, the response is going to be false
                    return isBanned;
                }

                // Use returned machinepuid to check if banned
                // Logic:
                // -if no results then we return false not banned
                // -if machinepuid lookup finds banned entry then return true
                // -in unlikely event that two or more were found then
                // check if any of them have been banned and return result
                if (consoleInfo.Length == 0)
                {
                    return isBanned;
                }

                // Grab the current datetime in order to have something to 
                // compare to.
                DateTime current = DateTime.UtcNow;

                // Grab the list of list of unique machine puids.
                Puid[] machinePuids = Utilities.UniqueIds(
                    Array.ConvertAll<ConsoleIdInfo,Puid>(
                        consoleInfo,
                        ( u => (Puid) u.MachinePuid )
                        )
                    );

                // Grab the list of bans associated with those Puids
                MachineBanInfo[] machineBanInfo = LookupBansByMachinePuidsInternal(
                    machinePuids
                    );

                // Check ban results and see if current is in the ban 
                // date range
                foreach (MachineBanInfo banInfo in machineBanInfo)
                {
                    if (banInfo.BanStart < current && banInfo.BanEnd > current)
                    {
                        isBanned = true;
                        return isBanned;
                    }
                }
                return isBanned;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                // Quick Fix Ups for the logs
                if (String.IsNullOrEmpty(consoleId))
                {
                    consoleId = "NULL";
                }

                // Format the Secondary Id string in a consistent manner
                string secondaryIdString = Utilities.ByteArrayToString( 
                    secondaryId 
                    );

                Xom.Log(
                    XomAreaName.log, "IsConsoleIdAndSCodeBanned|{0}|{1}|{2}|{3}|{4}",
                    hr, consoleId, secondaryIdString, consoleInfo.Length, isBanned
                );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupBansByConsoleIds.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupBansByConsoleIds.cs
//
// Implementation of LookupBansByConsoleIds SOAP API for XMachine FD
//
// Jan-22-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod and Internal
// Feb-09-2011 - Split into LookupConsoleBans and LookupMachineBans

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class ConsoleBanInfo
        {
            public String   ConsoleId;
            public HResult  ReasonCode;
            public DateTime BanStart;
            public DateTime BanEnd;

            public ConsoleBanInfo()
            {
            }

            public ConsoleBanInfo(
                String consoleId, 
                HResult reasonCode, 
                DateTime banStart, 
                DateTime banEnd
                )
            {
                ConsoleId  = consoleId;
                ReasonCode = reasonCode;
                BanStart   = banStart;
                BanEnd     = banEnd;
            }
        }

        [WebMethod]
        public ConsoleBanInfo[] LookupConsoleBansByConsoleIds(
            string[] consoleIds
            )
        {
            ConsoleBanInfo[] consoleBans = new ConsoleBanInfo[0];
            HResult          hr          = HResult.S_OK;

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( consoleIds, "consoleIds" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                // Sanity check the console ids (xbox360 only)
                consoleIds = ConsoleIds.Validate(consoleIds, true);

                // ConsoleBans
                consoleBans = LookupBansByConsoleIdsInternal(consoleIds);
                return consoleBans;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                Xom.Log(
                    XomAreaName.log, "LookupBansByConsoleIds|{0}|{1}|{2}|{3}",
                    hr, consoleIds.Length, consoleBans.Length, string.Join("|", consoleIds)
                );
            }
        }

        [WebMethod]
        public MachineBanInfo[] LookupMachineBansByConsoleIds(
            string[] consoleIds
            )
        {
            HResult          hr          = HResult.S_OK;
            MachineBanInfo[] machineBans = new MachineBanInfo[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( consoleIds, "consoleIds" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                // Sanity check the console ids 
                consoleIds = ConsoleIds.Validate(consoleIds, false);

                // Console Ids to Puids
                ConsoleIdInfo[] consoleIdInfo = LookupMachinePuidsByConsoleIdsInternal(consoleIds);

                // Unique Puids
                Puid[] puids = Utilities.UniqueIds(
                    Array.ConvertAll<ConsoleIdInfo, Puid>(
                        consoleIdInfo, 
                        (u => u.MachinePuid)
                        )
                    );

                // Machine Bans
                machineBans = LookupBansByMachinePuidsInternal(puids);
                return machineBans;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                Xom.Log(
                    XomAreaName.log, "LookupMachineBansByConsoleIds|{0}|{1}|{2}|{3}",
                    hr, consoleIds.Length, machineBans.Length, string.Join("|", consoleIds)
                );
            }
        }

        private ConsoleBanInfo[] LookupBansByConsoleIdsInternal(
            string[] consoleIds
            )
        {
            List<ConsoleBanInfo> consoleBanList = new List<ConsoleBanInfo>();

            //
            // Use webstore to lookup the relevant rows
            // 
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                DataTable[] dataTables = Utilities.ConsoleIdsToDataTables(ws, consoleIds, false);

                //
                // Look thru every physical partition
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    //
                    // Skip over partitions with no work
                    // 
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    //
                    // Craft the webstore call
                    // 
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_lookup_console_bans_by_console_ids";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_console_lookup_list", dataTables[i]);

                    //
                    // Execute
                    // 
                    using (WstDataReader reader = ws.Execute())
                    {
                        //
                        // First result set is the console ban information
                        // 
                        while (reader.Read())
                        {
                            //
                            // Read the results
                            // 
                            string consoleId = WSClient.GetString(reader, "vc_console_id").ToUpper();
                            HResult reasonCode = WSClient.GetUInt32(reader, "i_reason_code");
                            DateTime banStart = WSClient.GetDateTime(reader, "dt_since");
                            DateTime banEnd = DateTime.MaxValue;

                            //
                            // Build the record
                            // 
                            ConsoleBanInfo info = new ConsoleBanInfo(
                                consoleId,
                                reasonCode,
                                banStart,
                                banEnd
                                );

                            //
                            // Remember the record
                            // 
                            consoleBanList.Add(info);
                        }
                    }
                }
            }

            return consoleBanList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LogGamertagHistory.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;
using System.Xml;
using System.Xml.Serialization;
using System.Runtime.Serialization;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Web;
using CORE = xonline.core.history;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
       public class GamertagHistoryDetails : HistoryDetails
       {
           public string OldGamertag;
           public string NewGamertag;

           public GamertagHistoryDetails()
           {
           }

           public GamertagHistoryDetails(
               Puid userPuid, Puid machinePuid, string ipAddress, HResult hr, byte reason,
               string oldGamertagIn, string newGamertagIn
           )
               : base(userPuid, machinePuid, ipAddress, hr, reason)
           {
               OldGamertag = oldGamertagIn;
               NewGamertag = newGamertagIn;

               InitDetails();
           }

           public void InitDetails()
           {
                 Details = string.Format("OldGamertag = {0}, NewGamertag = {1}",
                 OldGamertag == null ? "<none>" : "'" + OldGamertag + "'",
                 NewGamertag == null ? "<none>" : "'" + NewGamertag + "'");
           }
        }

        [WebMethod]
        public void LogGamertagHistory(GamertagHistoryDetails gthd)
        {
            HResult hr = HResult.S_OK;

            if (gthd == null)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Null parameter: GamertagHistoryDetails"
                    );
            }

            if (gthd.Timestamp < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid Timestamp:{0}",
                    gthd.Timestamp.ToString()
                    );
            }

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                LogGamertagHistoryInternal(gthd);
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                Xom.Log(
                XomAreaName.log, "LogGamertagHistory|{0}|{1}|{2}|{3}|{4}",
                hr, gthd.UserPuid , gthd.MachinePuid.ToString(), gthd.IpAddress, HttpContext.Current.Request.UserHostAddress);
            }

        }

        private void LogGamertagHistoryInternal(GamertagHistoryDetails gthd)
        {
            HResult hr = HResult.S_OK;

            if ((gthd.NewGamertag == null) && (gthd.OldGamertag == null))
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "NewGamertag and OldGamertag cannot both be null"
                    );
            }

            if (gthd.OldGamertag == gthd.NewGamertag)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "NewGamertag and OldGamertag cannot be equal {0}|{1}",
                    gthd.OldGamertag,
                    gthd.NewGamertag
                    );
            }

            if (((gthd.NewGamertag != null) && (gthd.NewGamertag.Length > 16)) || ((gthd.OldGamertag != null) && (gthd.OldGamertag.Length > 16)))
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Gamertag too long, max length is 16 bytes long: {0}|{1}",
                    gthd.NewGamertag, gthd.OldGamertag
                    );
            }
 
            if ((gthd.MachinePuid == 0) || (XOn.XboxId.IsMachinePuid((UInt64)gthd.MachinePuid)) == false)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "MachinePuid is invalid: {0}",
                    gthd.MachinePuid
                    );
            }

            if (Enum.IsDefined(typeof(xonline.core.history.HistoryReason), (int)gthd.Reason) == false)
            {
                //we did not find the machine puid, it is not valid
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "HistoryReason is invalid: {0}",
                    gthd.Reason
                    );
            }

            //Verify the machinepuid
            MachinePuidInfo[] mPuids = LookupConsoleIdsByMachinePuidsInternal(new Puid[] {gthd.MachinePuid});

            if ((mPuids == null) || (mPuids.Length < 1))
            {
                //we did not find the machine puid, it is not valid
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "MachinePuid is invalid on lookup: {0}",
                    gthd.MachinePuid
                    );
            }

            LogDetail(gthd, _machineGamertagParams, ConfigUtil.SecMachineHistoryWebstoreApp);

            if (Config.GetBoolSetting(Setting.xmachine_doubleWriteHistory))
            {
                LogDetail(gthd, _machineGamertagParamsUODB, ConfigUtil.UodbWebstoreApp);
            }
        }

        private void LogDetail(GamertagHistoryDetails gthd, HistoryParams historyParams, string databaseName)
        {
            Puid hashVal = (Puid)gthd.MachinePuid;

            using (WSClient ws = new WSClient(databaseName, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // parameterized stored procedures  and  hashes
                // allow writes to different  tables/partitions

                ws.StoredProc = historyParams.StoredProc;
                ws.SetHashVal(hashVal);

                // add all of the standard fields to the record

                ws.AddParameter("bi_user_puid", gthd.UserPuid);
                ws.AddParameter("dt_timestamp", gthd.Timestamp);
                ws.AddParameter("i_hr", gthd.HResult);
                ws.AddParameter("ti_reason", (byte)gthd.Reason);

                // some common fields can be null.  check  that

                if (gthd.MachinePuid != 0) ws.AddParameter("bi_machine_puid", (Puid)gthd.MachinePuid);
                if (gthd.IpAddress != null) ws.AddParameter("vc_ip_address", gthd.IpAddress);
                ws.AddParameter("dt_since", DateTime.UtcNow.AddDays(-historyParams.Interval));
                if (historyParams.UseHash) ws.AddParameter("si_hash_bucket", ws.Partition);

                // finally we add the operation specific params
                // for particular operational details we record
                if (gthd.OldGamertag != null) ws.AddParameter("vc_old_gamertag", gthd.OldGamertag);
                if (gthd.NewGamertag != null) ws.AddParameter("vc_new_gamertag", gthd.NewGamertag);

                // add return value to receive the return value

                HResult hr = HResult.S_OK;
                ws.AddParameter(ParamType.RETVAL, "@hr", hr);

                try
                {
                    using (WstDataReader reader = ws.Execute())
                    {
                        if ((hr = (uint)ws.GetIntParameter("@hr")).IsFailure())
                        {
                            throw new XRLException(
                                hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR, "Error logging history"
                            );
                        }
                    }
                }
                catch (Exception e)
                {
                    if (e.InnerException is SqlException)
                    {
                        SqlException    sqlExcept = (SqlException)e.InnerException;

                        if ((sqlExcept.Number == 2601) || (sqlExcept.Number == 2627))//duplicate key
                        {
                            throw new XRLException(
                                hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR,
                                "Existing log record found"
                            );
                        }
                    }
                }

            }
        }
    
        private static readonly HistoryParams _machineGamertagParams = new HistoryParams(
            "p_xmachine_machine_gamertag_history_add",
            Setting.xuacs_machineGamertagThreshold,
            Setting.xuacs_machineGamertagIntervalDays,
            XEvent.Id.ACCOUNTS_MACHINE_GAMERTAG_THRESHOLD_EXCEEDED,
            "Machine {0} exceeded gamertag change threshold of {1} unique users in {2} days",
            (byte)CORE.HistoryReason.PurchaseGamertag
        );

        private static readonly HistoryParams _machineGamertagParamsUODB = new HistoryParams(
            "p_xuacs_machine_gamertag_history_add",
            Setting.xuacs_machineGamertagThreshold,
            Setting.xuacs_machineGamertagIntervalDays,
            XEvent.Id.ACCOUNTS_MACHINE_GAMERTAG_THRESHOLD_EXCEEDED,
            "Machine {0} exceeded gamertag change threshold of {1} unique users in {2} days",
            false,
            (byte)CORE.HistoryReason.PurchaseGamertag
        );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LogRecoveryHistory.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Web;
using CORE = xonline.core.history;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public class RecoveryHistoryDetails : HistoryDetails
    {
        public ulong PassportPuid;

        public RecoveryHistoryDetails()
        {
        }

        public RecoveryHistoryDetails(
            Puid userPuidIn, Puid machinePuidIn, string ipAddressIn, HResult hrIn, byte reasonIn, Puid passportPuid
        )
            : base(userPuidIn, machinePuidIn, ipAddressIn, hrIn, reasonIn)
        {
            PassportPuid = passportPuid;

            InitDetails();
        }

        public void InitDetails()
        {
            Details = string.Format("PassportPuid = {0}", PassportPuid);
        }
    }

    public partial class XMachine
    {
        [WebMethod]
        public void LogRecoveryHistory(RecoveryHistoryDetails rhd)
        {
            HResult hr = HResult.S_OK;

            if (rhd == null)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Null parameter: RecoveryHistoryDetails"
                    );
            }

            if (rhd.Timestamp < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid Timestamp:{0}",
                    rhd.Timestamp.ToString()
                    );
            }

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                LogRecoveryHistoryInternal(rhd);
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                Xom.Log(XomAreaName.log, "LogRecoveryHistory|{0}|{1}|{2}|{3}|{4}",
                         hr, rhd.UserPuid, rhd.MachinePuid.ToString(), rhd.IpAddress, HttpContext.Current.Request.UserHostAddress);
            }

        }

        private void LogRecoveryHistoryInternal(RecoveryHistoryDetails rhd)
        {
            HResult hr = HResult.S_OK;

            if (rhd.PassportPuid == 0)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "PassportPuid is invalid: {0}",
                    rhd.PassportPuid
                    );
            }


            if ((rhd.MachinePuid == 0) || (XOn.XboxId.IsMachinePuid((UInt64)rhd.MachinePuid)) == false)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "MachinePuid is invalid: {0}",
                    rhd.MachinePuid
                    );
            }

            if (Enum.IsDefined(typeof(xonline.core.history.HistoryReason), (int)rhd.Reason) == false)
            {
                //we did not find the machine puid, it is not valid
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "HistoryReason is invalid: {0}",
                    rhd.Reason
                    );
            }

            //Verify the machinepuid
            MachinePuidInfo[] mPuids = LookupConsoleIdsByMachinePuidsInternal(new Puid[] { rhd.MachinePuid });

            if ((mPuids == null) || (mPuids.Length < 1))
            {
                //we did not find the machine puid, it is not valid
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "MachinePuid is invalid on lookup: {0}",
                    rhd.MachinePuid
                    );
            }

            LogDetail(rhd, _machineRecoveryParams, ConfigUtil.SecMachineHistoryWebstoreApp);

            if (Config.GetBoolSetting(Setting.xmachine_doubleWriteHistory))
            {
                LogDetail(rhd, _machineRecoveryParamsUODB, ConfigUtil.UodbWebstoreApp);
            }

        }

        private void LogDetail(RecoveryHistoryDetails rhd, HistoryParams historyParams, string databaseName)
        {

            Puid hashVal = (Puid)rhd.MachinePuid;

            using (WSClient ws = new WSClient(databaseName, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // parameterized stored procedures  and  hashes
                // allow writes to different  tables/partitions

                ws.StoredProc = historyParams.StoredProc;
                ws.SetHashVal(hashVal);

                // add all of the standard fields to the record

                ws.AddParameter("bi_user_puid", rhd.UserPuid);
                ws.AddParameter("dt_timestamp", rhd.Timestamp);
                ws.AddParameter("i_hr", rhd.HResult);
                ws.AddParameter("ti_reason", (byte)rhd.Reason);

                // some common fields can be null.  check  that

                if (rhd.MachinePuid != 0) ws.AddParameter("bi_machine_puid", (Puid)rhd.MachinePuid);
                if (rhd.IpAddress != null) ws.AddParameter("vc_ip_address", rhd.IpAddress);
                ws.AddParameter("dt_since", DateTime.UtcNow.AddDays(-historyParams.Interval));
                ws.AddParameter("si_hash_bucket", ws.Partition);

                // finally we add the operation specific params
                // for particular operational details we record

                ws.AddParameter("bi_user_passport_puid", (Puid)rhd.PassportPuid);

                // add return value to receive the return value

                HResult hr = HResult.S_OK;
                ws.AddParameter(ParamType.RETVAL, "@hr", hr);

                // execute and convert result set into  history
                // summary used to test  configured  thresholds

                try
                {
                    using (WstDataReader reader = ws.Execute())
                    {
                        if ((hr = (uint)ws.GetIntParameter("@hr")).IsFailure())
                        {
                            throw new XRLException(
                                hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR, "Error logging history"
                            );
                        }
                    }
                }
                catch (Exception e)
                {
                    if (e.InnerException is SqlException)
                    {
                        SqlException sqlExcept = (SqlException)e.InnerException;

                        if ((sqlExcept.Number == 2601) || (sqlExcept.Number == 2627))//duplicate key
                        {
                            throw new XRLException(
                                hr, XEvent.Id.ACCOUNTS_HISTORY_LOG_ERROR,
                                "Existing log record found"
                            );
                        }
                    }
                }
            }
        }

        private static readonly HistoryParams _machineRecoveryParams = new HistoryParams(
             "p_xmachine_machine_recovery_history_add",
             Setting.xuacs_machineRecoveryThreshold,
             Setting.xuacs_machineRecoveryIntervalDays,
             XEvent.Id.ACCOUNTS_MACHINE_RECOVERY_THRESHOLD_EXCEEDED,
             "Machine {0} exceeded recovery threshold of {1} unique users in {2} days",
             (byte)CORE.HistoryReason.RecoverAccount
         );

        private static readonly HistoryParams _machineRecoveryParamsUODB = new HistoryParams(
             "p_xuacs_machine_recovery_history_add",
             Setting.xuacs_machineRecoveryThreshold,
             Setting.xuacs_machineRecoveryIntervalDays,
             XEvent.Id.ACCOUNTS_MACHINE_RECOVERY_THRESHOLD_EXCEEDED,
             "Machine {0} exceeded recovery threshold of {1} unique users in {2} days",
             (byte)CORE.HistoryReason.RecoverAccount
         );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupBansByMachinePuids.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupBansByMachinePuids.cs
//
// Implementation of LookupBansByMachinePuids SOAP API for XMachine FD
//
// Jan-22-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod and Internal
// Feb-09-2011 - Split into LookupConsoleBans and LookupMachineBans

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class MachineBanInfo
        {
            public Puid     MachinePuid;
            public String   ConsoleId;
            public HResult  ReasonCode;
            public DateTime BanStart;
            public DateTime BanEnd;

            public MachineBanInfo()
            {
            }

            public MachineBanInfo(
                Puid     machinePuid, 
                String   consoleId, 
                HResult  reasonCode, 
                DateTime banStart, 
                DateTime banEnd
                )
            {
                MachinePuid = machinePuid;
                ConsoleId   = consoleId;
                ReasonCode  = reasonCode;
                BanStart    = banStart;
                BanEnd      = banEnd;
            }
        }

        [WebMethod]
        public ConsoleBanInfo[] LookupConsoleBansByMachinePuids(
            Puid[] puids
            )
        {
            ConsoleBanInfo[] consoleBans = new ConsoleBanInfo[0];
            HResult          hr          = HResult.S_OK;

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( puids, "machinePuids" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                // Unique puids
                puids = Utilities.UniqueIds<Puid>(puids);

                // Puids to console ids
                MachinePuidInfo[] machinePuidInfo = LookupConsoleIdsByMachinePuidsInternal(puids);

                // Unique console ids
                string[] consoleIds  = Utilities.UniqueIds(
                    Array.ConvertAll<MachinePuidInfo, string>(
                        machinePuidInfo, 
                        (u => (string)u.ConsoleId)
                        )
                    );

                // Console Bans
                consoleBans = LookupBansByConsoleIdsInternal(consoleIds);
                return consoleBans;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                string[] puidStrings = Array.ConvertAll<Puid, string>(puids, (u => u.ToString()));

                Xom.Log(
                    XomAreaName.log, "LookupConsoleBansByMachinePuids|{0}|{1}|{2}|{3}",
                    hr, puids.Length, consoleBans.Length, string.Join("|", puidStrings)
                );
            }
        }

        [WebMethod]
        public MachineBanInfo[] LookupMachineBansByMachinePuids(
            Puid[] puids
            )
        {
            HResult          hr          = HResult.S_OK;
            MachineBanInfo[] machineBans = new MachineBanInfo[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( puids, "machinePuids" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                // Unique Puids
                puids = Utilities.UniqueIds<Puid>(puids);

                // Machine Bans
                machineBans = LookupBansByMachinePuidsInternal(puids);
                return machineBans;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                string[] puidStrings = Array.ConvertAll<Puid, string>(puids, (u => u.ToString()));

                Xom.Log(
                    XomAreaName.log, "LookupMachineBansByMachinePuids|{0}|{1}|{2}|{3}",
                    hr, puids.Length, machineBans.Length, string.Join("|", puidStrings)
                );
            }
        }

        private MachineBanInfo[] LookupBansByMachinePuidsInternal(
            Puid[] puids
            )
        {
            List<MachineBanInfo> machineBanList = new List<MachineBanInfo>();

            //
            // Use webstore to lookup the relevant rows
            // 
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                DataTable[] dataTables = Utilities.PuidsToDataTables(ws, puids, false);

                //
                // Look thru every physical partition
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    //
                    // Skip over partitions with no work
                    // 
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    //
                    // Craft the webstore call
                    // 
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_lookup_machine_bans_by_puids";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_machine_lookup_list", dataTables[i]);

                    //
                    // Execute
                    // 
                    using (WstDataReader reader = ws.Execute())
                    {
                        while (reader.Read())
                        {
                            //
                            // Read the results
                            // 
                            string   consoleId  = WSClient.GetString(reader, "vc_serial_num").ToUpper();
                            Puid     puid       = (ulong) WSClient.GetInt64(reader, "bi_machine_puid");
                            HResult  reasonCode = WSClient.GetUInt32(reader, "i_reason_code");
                            DateTime banStart   = WSClient.GetDateTime(reader, "dt_start");
                            DateTime banEnd     = WSClient.GetDateTime(reader, "dt_end");

                            //
                            // Build the record
                            // 
                            MachineBanInfo info = new MachineBanInfo(
                                puid,
                                consoleId,
                                reasonCode,
                                banStart,
                                banEnd
                                );

                            //
                            // Remember the record
                            // 
                            machineBanList.Add( info );
                        }                                
                    }
                }
            }

            //
            // Return the completed lookups
            //
            return machineBanList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupConsoleIdsByMachinePuids.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupConsoleIdByMachinePuids.cs
//
// Implementation of LookupConsoleIdByMachinePuids SOAP API for XMachine FD
//
// Jan-21-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod and Internal
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class MachinePuidInfo
        {
            public Puid   MachinePuid;
            public String ConsoleId;

            public MachinePuidInfo()
            {
            }

            public MachinePuidInfo(Puid machinePuid, String consoleId)
            {
                MachinePuid = machinePuid;
                ConsoleId   = consoleId;
            }
        }

        [WebMethod]
        public MachinePuidInfo[] LookupConsoleIdsByMachinePuids(
            Puid[] puids
        )
        {
            HResult hr = HResult.S_OK;
            MachinePuidInfo[] machinePuidInfo = new MachinePuidInfo[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( puids, "machinePuids" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                // Unique Puids
                puids = Utilities.UniqueIds<Puid>(puids);

                // MachinePuids -> ConsoleIds
                machinePuidInfo = LookupConsoleIdsByMachinePuidsInternal(puids);
                return machinePuidInfo;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                string[] puidStrings = Array.ConvertAll<Puid, string>(puids, (u => u.ToString()));

                Xom.Log(
                    XomAreaName.log, "LookupConsoleIdsByMachinePuids|{0}|{1}|{2}|{3}",
                    hr, puids.Length, machinePuidInfo.Length, string.Join("|", puidStrings)
                );
            }
        }


        private MachinePuidInfo[] LookupConsoleIdsByMachinePuidsInternal(
            Puid[] puids
        )
        {
            List<MachinePuidInfo> machinePuidInfoList = new List<MachinePuidInfo>();

            //
            // Use webstore to lookup the relevant rows
            // 
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                DataTable[] dataTables = Utilities.PuidsToDataTables(ws, puids, false);

                //
                // Look thru every physical partition
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    //
                    // Skip over partitions with no work
                    // 
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    //
                    // Craft the webstore call
                    // 
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_lookup_console_ids_by_puids";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_machine_lookup_list", dataTables[i]);

                    using (WstDataReader reader = ws.Execute())
                    {
                        while (reader.Read())
                        {
                            //
                            // Read the results
                            // 
                            string consoleId = WSClient.GetString(reader, "vc_serial_num");
                            Puid   puid      = (ulong) WSClient.GetInt64(reader, "bi_machine_puid");

                            //
                            // Build and remember the record
                            // 
                            // Note: machinePuidInfoList is a List<> and not a
                            // HashSet<> because puids are partition specific.
                            // 
                            // That is, only a single partition will ever return
                            // data about a particular puid. Thus we don't
                            // need to check the machinePuidInfoList for duplicates.
                            // 
                            MachinePuidInfo info = new MachinePuidInfo( 
                                puid, 
                                consoleId
                                );
                            machinePuidInfoList.Add( info );
                        }
                    }
                }
            }

            //
            // Return the completed lookups
            // 
            return machinePuidInfoList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupGamertagHistoryByMachinePuid.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Data.SqlTypes;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
      public partial class XMachine
      {
        public class GamertagHistory : HistorySummary
        {
           public GamertagHistoryDetails[] Details { get; set; }

           public GamertagHistory()
           {
           }

           public GamertagHistory(GamertagHistoryDetails[] details)
               : base(details)
           {
           }
        }

        [WebMethod]
        public GamertagHistory LookupGamertagHistoryByMachinePuid(ulong machinePuid, ulong? userPuid, DateTime? since, bool details)
        {
            HResult hr = HResult.S_OK;

            if (since.HasValue == true && since.Value < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid since:{0}",
                    since.Value
                    );
            }

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                //We should pull from SecMachineHistory database, but if we are 
                //still in double write mode then we have not migrated
                //completely out of UODB so get from there if the
                //doublewrite setting is still set to true
                string databaseName = ConfigUtil.SecMachineHistoryWebstoreApp;

                string storedProcedureName = "p_xmachine_machine_gamertag_history_get";

                if (Config.GetBoolSetting(Setting.xmachine_doubleWriteHistory))
                {
                    databaseName = ConfigUtil.UodbWebstoreApp;
                    storedProcedureName = "p_xuacs_machine_gamertag_history_get";
                }

                Puid? tempuserPuid = userPuid.HasValue ? (Puid)userPuid : (Puid?)null;
                return LookupGamertagHistoryByMachinePuidInternal(databaseName, storedProcedureName, (Puid)machinePuid, tempuserPuid, since, details);
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                Xom.Log(
                    XomAreaName.log, "LookupGamertagHistoryByMachinePuid|{0}|{1}|{2}",
                    hr, machinePuid.ToString(), userPuid == null ? "<none>" : userPuid.ToString()
                );
            }
        }

        private GamertagHistory LookupGamertagHistoryByMachinePuidInternal(string databaseName, string storedProcedureName, Puid machinePuid, Puid? userPuid, DateTime? since, bool details)
        {
            using (WSClient ws = new WSClient(databaseName, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(machinePuid);
                ws.StoredProc = storedProcedureName;
                ws.AddParameter("@bi_machine_puid", machinePuid);

                if ((userPuid != null) && (userPuid != 0)) ws.AddParameter("@bi_user_puid", (Puid)userPuid);
                
                if (since != null) ws.AddParameter(ParamType.INPUT, "@dt_since", (DateTime)since);
                ws.AddParameter(ParamType.INPUT, "@b_details", details ? 1 : 0);
                ws.AddParameter(ParamType.RETVAL, "@hr", (int)HResult.S_OK);

                using (WstDataReader reader = ws.Execute())
                {
                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (hr.IsSuccess())
                    {
                        if (!reader.Read())
                        {
                            throw new XRLException(
                                    HResult.XONLINE_E_DATABASE_RESULT_ERROR,
                                    XEvent.Id.ACCOUNTS_HISTORY_GET_ERROR,
                                    "Error reading history summary information"
                                );
                        }
                        GamertagHistory gth = new GamertagHistory();

                        gth.Unique = WSClient.IsDBNull(reader, "i_unique") ? 0 : WSClient.GetInt32(reader, "i_unique");
                        gth.Total = WSClient.IsDBNull(reader, "i_total") ? 0 : WSClient.GetInt32(reader, "i_total");
                        gth.First = WSClient.IsDBNull(reader, "dt_first") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_first");
                        gth.Last = WSClient.IsDBNull(reader, "dt_last") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_last");

                        if (details && reader.NextResult())
                        {
                            int i = 0;
                            gth.Details = new GamertagHistoryDetails[gth.Total];

                            while (reader.Read())
                            {
                                gth.Details[i] = new GamertagHistoryDetails();

                                gth.Details[i].UserPuid = WSClient.GetPuid(reader, "bi_user_puid");
                                gth.Details[i].MachinePuid = WSClient.IsDBNull(reader, "bi_machine_puid") ? 0 : WSClient.GetPuid(reader, "bi_machine_puid");
                                gth.Details[i].IpAddress = WSClient.IsDBNull(reader, "vc_ip_address") ? null : WSClient.GetString(reader, "vc_ip_address");
                                gth.Details[i].Timestamp = WSClient.GetDateTime(reader, "dt_timestamp");
                                gth.Details[i].HResult = WSClient.GetHResult(reader, "i_hr");
                                gth.Details[i].Reason = WSClient.GetByte(reader, "ti_reason");

                                gth.Details[i].OldGamertag = WSClient.IsDBNull(reader, "vc_old_gamertag") ? null : WSClient.GetString(reader, "vc_old_gamertag");
                                gth.Details[i].NewGamertag = WSClient.IsDBNull(reader, "vc_new_gamertag") ? null : WSClient.GetString(reader, "vc_new_gamertag");
                                gth.Details[i].InitDetails();
                                i++;
                            }
                        }

                        return gth;
                    }
                    else
                        return null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupMachineInfoByMachinePuids.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupMachineInfoByMachinePuids.cs
//
// Implementation of LookupMachineInfoByMachinePuids SOAP API for XMachine FD
//
// May-12-2011 - Initial Revision
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class MachineInfo
        {
            public Puid     MachinePuid;
            public String   ConsoleId;
            public Byte[]   SecondaryIdentifier;
            public DateTime ResetDate;
            public DateTime CreateDate;
            public String   FlashVersion;
            public DateTime FlashDate;
            public int      ConsoleRegion;
            public String   UpdateVersion;
            public DateTime UpdateDate;

            public MachineInfo()
            {
            }

            public MachineInfo(
                Puid     machinePuid, 
                String   consoleId,
                Byte[]   secondaryIdentifier,
                DateTime resetDate,
                DateTime createDate,
                String   flashVersion,
                DateTime flashDate,
                int      consoleRegion,
                String   updateVersion,
                DateTime updateDate
                )
            {
                MachinePuid         = machinePuid;
                ConsoleId           = consoleId;
                SecondaryIdentifier = secondaryIdentifier;
                ResetDate           = resetDate;
                CreateDate          = createDate;
                FlashVersion        = flashVersion;
                FlashDate           = flashDate;
                ConsoleRegion       = consoleRegion;
                UpdateVersion       = updateVersion;
                UpdateDate          = updateDate;
            }
        }

        [WebMethod]
        public MachineInfo[] LookupMachineInfoByMachinePuids(
            Puid[] puids
            )
        {
            HResult hr = HResult.S_OK;
            MachineInfo[] machineInfo = new MachineInfo[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( puids, "machinePuids" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                // Unique Puids
                puids = Utilities.UniqueIds<Puid>(puids);

                // MachinePuids -> ConsoleIds
                machineInfo = LookupMachineInfoByMachinePuidsImpl(puids);
                return machineInfo;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                string[] puidStrings = Array.ConvertAll<Puid, string>(puids, (u => u.ToString()));

                Xom.Log(
                    XomAreaName.log, "LookupMachineInfoByMachinePuids|{0}|{1}|{2}|{3}",
                    hr, puids.Length, machineInfo.Length, string.Join("|", puidStrings)
                );
            }
        }

        private MachineInfo[] LookupMachineInfoByMachinePuidsImpl(
            Puid[] puids
            )
        {
            ConsoleIdInfo[] consoleIdInfo = null;
            HashSet<string> consoleIdSet = new HashSet<string>();
            List<string>    consoleIdList = new List<string>();
            MachineInfo[]   machineInfo = null;

            //
            // Grab the majority of the machine info call
            // 
            machineInfo = LookupMachineInfoByMachinePuidsInternal( puids );

            //
            // Grab just the console ids from these machines
            // 
            foreach (MachineInfo info in machineInfo)
            {
                if (consoleIdSet.Contains( info.ConsoleId ) == false)
                {
                    consoleIdSet.Add( info.ConsoleId );
                    consoleIdList.Add( info.ConsoleId );
                }
            }

            //
            // Convert the console ids into the consoleidinfo. 
            // This should give us the missing secondary identifier
            // 
            consoleIdInfo = LookupMachinePuidsByConsoleIdsInternal( consoleIdList.ToArray() );

            //
            // Merge the two results set together
            // 
            foreach (MachineInfo info in machineInfo)
            {
                foreach (ConsoleIdInfo cinfo in consoleIdInfo)
                {
                    if (info.MachinePuid == cinfo.MachinePuid)
                    {
                        // These match, so remember the secondary identifier
                        info.SecondaryIdentifier = cinfo.SecondaryIdentifier;
                        break;
                    }
                }
            }

            //
            // Return the combined results
            // 
            return machineInfo;
        }

        private MachineInfo[] LookupMachineInfoByMachinePuidsInternal(
            Puid[] puids
            )
        {
            List<MachineInfo> machineInfoList = new List<MachineInfo>();

            //
            // Use webstore to lookup the relevant rows
            // 
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                DataTable[] dataTables = Utilities.PuidsToDataTables(ws, puids, false);

                //
                // Look thru every physical partition
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    //
                    // Skip over partitions with no work
                    // 
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    //
                    // Craft the webstore call
                    // 
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_lookup_console_ids_by_puids";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_machine_lookup_list", dataTables[i]);

                    using (WstDataReader reader = ws.Execute())
                    {
                        int consoleIdOrdinal     = reader.GetOrdinal("vc_serial_num");
                        int machinePuidOrdinal   = reader.GetOrdinal("bi_machine_puid");
                        int resetDateOrdinal     = reader.GetOrdinal("dt_reset_date");
                        int createDateOrdinal    = reader.GetOrdinal("dt_creation_date");
                        int flashVersionOrdinal  = reader.GetOrdinal("vc_flash_version");
                        int flashDateOrdinal     = reader.GetOrdinal("dt_flash_version_change_datetime");
                        int consoleRegionOrdinal = reader.GetOrdinal("i_console_region");
                        int updateVersionOrdinal = reader.GetOrdinal("vc_update_version");
                        int updateDateOrdinal    = reader.GetOrdinal("dt_update_version_change_datetime");

                        while (reader.Read())
                        {
                            //
                            // Read the results
                            // 
                            string   consoleId     = reader.GetString( consoleIdOrdinal );
                            Puid     puid          = (ulong) reader.GetInt64( machinePuidOrdinal );
                            DateTime resetDate     = DateTime.MinValue;
                            DateTime createDate    = DateTime.MinValue;
                            string   flashVersion  = reader.GetString( flashVersionOrdinal );
                            DateTime flashDate     = DateTime.MinValue; 
                            int      consoleRegion = reader.GetInt32( consoleRegionOrdinal );
                            string   updateVersion = reader.GetString(  updateVersionOrdinal );
                            DateTime updateDate    = DateTime.MinValue;

                            if (reader.IsDBNull( resetDateOrdinal ) == false)
                            {
                                resetDate = reader.GetDateTime( resetDateOrdinal );
                            }
                            if (reader.IsDBNull( createDateOrdinal ) == false)
                            {
                                createDate = reader.GetDateTime( createDateOrdinal );
                            }
                            if (reader.IsDBNull( flashDateOrdinal ) == false)
                            {
                                flashDate = reader.GetDateTime( flashDateOrdinal );
                            }
                            if (reader.IsDBNull( updateDateOrdinal ) == false)
                            {
                                updateDate = reader.GetDateTime( updateDateOrdinal );
                            }

                            //
                            // Build and remember the record
                            // 
                            // Note: machineInfoList is a List<> and not a
                            // HashSet<> because puids are partition specific.
                            // 
                            // That is, only a single partition will ever return
                            // data about a particular puid. Thus we don't
                            // need to check the machineInfoList for duplicates.
                            // 
                            MachineInfo info = new MachineInfo( 
                                puid, 
                                consoleId,
                                null,
                                resetDate,
                                createDate,
                                flashVersion,
                                flashDate,
                                consoleRegion,
                                updateVersion,
                                updateDate
                                );
                            machineInfoList.Add( info );
                        }
                    }
                }
            }

            //
            // Return the completed lookups
            // 
            return machineInfoList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupMachinePuidsByConsoleIdAndSCode.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupMachinePuidsByConsoleIdAndSCode.cs
//
// Implementation of LookupMachinePuidsByConsoleIdAndSCode SOAP API for XMachine FD
//
// Feb-15-2011 - Initial Revision
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using xonline.core.history;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        [WebMethod]
        public ConsoleIdInfo[] LookupMachinePuidsByConsoleIdAndSCode(
            string consoleId,
            byte[] secondaryId
        )
        {
            ConsoleIdInfo[] consoleIdInfo = new ConsoleIdInfo[0];
            HResult         hr            = HResult.S_OK;

            // Validate the console id is non null since the logging code will break otherwise
            if (consoleId == null)
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_INVALID_REQUEST,"Null consoleId");
            }
            // Validate that we have secondary id present
            if (secondaryId == null)
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_INVALID_REQUEST,"Null secondaryId"); 
            }

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                Utilities.CheckSCodeFormat(secondaryId);

                consoleIdInfo = LookupMachinePuidsByConsoleIdAndSCodeInternal(consoleId, secondaryId);

                return consoleIdInfo;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                string secondaryIdString = Utilities.ByteArrayToString(
                    secondaryId
                    );

                // we log the API, the result (an hr), the number of things
                // they asked for, the number they got  back  and  the  ids
                Xom.Log(
                    XomAreaName.log, "LookupMachinePuidsByConsoleIdAndSCode|{0}|1|{1}|{2}|{3}",
                    hr, consoleIdInfo.Length, secondaryIdString, consoleId
                );
            }
        }

        private ConsoleIdInfo[] LookupMachinePuidsByConsoleIdAndSCodeInternal(string consoleId, byte[] secondaryId)
        {
            ConsoleIdInfo[] consoleIdInfo = new ConsoleIdInfo[0];

            // Pull up the details on this console id
            string[] consoleIds = new string[] { consoleId.ToUpper() };

            consoleIds = ConsoleIds.Validate(consoleIds, true);
            consoleIdInfo = LookupMachinePuidsByConsoleIdsInternal(consoleIds);

            // No results means that the answer is obvious
            if (consoleIdInfo.Length < 1)
            {
                return consoleIdInfo;
            }

            // Find any that match
            List<ConsoleIdInfo> consoleIdInfoList = new List<ConsoleIdInfo>();
            foreach (ConsoleIdInfo info in consoleIdInfo)
            {
                bool matched = true;
                for (int i = 0; i < 7; ++i)
                {
                    if (info.SecondaryIdentifier[i] != secondaryId[i])
                    {
                        matched = false;
                        break;
                    }
                }

                if (matched)
                {
                    consoleIdInfoList.Add(info);
                }
            }

            // Return the matching set
            return consoleIdInfoList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupMachinePuidByConsoleIdAndXuid.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupMachinePuidByConsoleIdAndXuid.cs
//
// Implementation of LookupMachinePuidByConsoleIdAndXuid SOAP API for XMachine FD
//
// Feb-01-2011 - Initial Revision
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using xonline.core.history;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        [WebMethod]
        public ConsoleIdInfo[] LookupMachinePuidByConsoleIdAndXuid(
            string consoleId,
            Puid   userId
        )
        {
            ConsoleIdInfo[] consoleIdInfo = new ConsoleIdInfo[0];
            HResult         hr            = HResult.S_OK;

            // Validate the console id is non null since the logging code will break otherwise
            if (consoleId == null)
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_INVALID_REQUEST,"Null consoleId");
            }

            try
            {
                string[] consoleIds = new string[1];

                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                // Pull up the details on this console id
                consoleIds[0] = ConsoleIds.Validate( consoleId, false );
                consoleIdInfo = LookupMachinePuidsByConsoleIdsInternal(consoleIds);

                // If the answer is obvious, then don't bother with the user lookup
                if (consoleIdInfo.Length < 2)
                {
                    return consoleIdInfo;
                }

                // Grab the user - machine history for this user with all the details. This
                // should provide the list of machine puids that this user has been on.
                UserMachineHistory userMachineHistory = new UserMachineHistory( userId, null, null, true );
                List<ConsoleIdInfo> consoleIdInfoList = new List<ConsoleIdInfo>();

                if (userMachineHistory != null && userMachineHistory.Details != null)
                {
                    // Loop thru each of the possible consoles and find the most recently used by the user
                    // The list is sorted in decending order, so it should be an issue of finding
                    // the fist matching entry
                    for (int i = 0; i < userMachineHistory.Details.Length; ++i)
                    {
                        foreach (ConsoleIdInfo info in consoleIdInfo)
                        {
                            if (info.MachinePuid == userMachineHistory.Details[i].MachinePuid)
                            {
                                consoleIdInfoList.Add( info );
                                break;
                            }
                        }
                        if (consoleIdInfoList.Count > 0)
                        {
                            break;
                        }
                    }
                }

                // Return the matching set
                consoleIdInfo = consoleIdInfoList.ToArray();
                return consoleIdInfo;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                // we log the API, the result (an hr), the number of things
                // they asked for, the number they got  back  and  the  ids
                Xom.Log(
                    XomAreaName.log, "LookupMachinePuidByConsoleIdAndXuid|{0}|1|{1}|{2}|{3}",
                    hr, consoleIdInfo.Length, userId, consoleId
                );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupMachinePuidsByConsoleIds.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupMachinePuidsByConsoleIds.cs
//
// Implementation of LookupMachinePuidsByConsoleIds SOAP API for XMachine FD
//
// Jan-21-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod and Internal
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class ConsoleIdInfo
        {
            public Puid   MachinePuid;
            public String ConsoleId;
            public Byte[] SecondaryIdentifier;

            public ConsoleIdInfo()
            {
            }

            public ConsoleIdInfo(Puid machinePuid, String consoleId, Byte[] secondaryIdentifier)
            {
                MachinePuid         = machinePuid;
                ConsoleId           = consoleId;
                SecondaryIdentifier = secondaryIdentifier;
            }
        }

        [WebMethod]
        public ConsoleIdInfo[] LookupMachinePuidsByConsoleIds(
            string[] consoleIds
            )
        {
            ConsoleIdInfo[] consoleIdInfo = new ConsoleIdInfo[0];
            HResult         hr            = HResult.S_OK;

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( consoleIds, "consoleIds" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                // Validate Puids 
                consoleIds = ConsoleIds.Validate(consoleIds, false);

                // ConsoleId -> PUIDs
                consoleIdInfo = LookupMachinePuidsByConsoleIdsInternal(consoleIds);
                return consoleIdInfo;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                // we log the API, the result (an hr), the number of things
                // they asked for, the number they got  back  and  the  ids
                Xom.Log(
                    XomAreaName.log, "LookupMachinePuidsByConsoleIds|{0}|{1}|{2}|{3}",
                    hr, consoleIds.Length, consoleIdInfo.Length, string.Join("|", consoleIds)
                    );
            }
        }

        private ConsoleIdInfo[] LookupMachinePuidsByConsoleIdsInternal(
            string[] consoleIds
            )
        {
            List<ConsoleIdInfo> consoleIdInfoList = new List<ConsoleIdInfo>();

            //
            // Use webstore to lookup the relevant rows
            // 
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                DataTable[] dataTables = Utilities.ConsoleIdsToDataTables(ws, consoleIds, false);

                //
                // Look thru every physical partition
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    //
                    // Skip over partitions with no work
                    // 
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    //
                    // Craft the webstore call
                    // 
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_lookup_puids_by_console_ids";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_console_lookup_list", dataTables[i]);

                    //
                    // Execute
                    // 
                    using (WstDataReader reader = ws.Execute())
                    {
                        while (reader.Read())
                        {
                            //
                            // Read the results
                            // 
                            string consoleId   = WSClient.GetString(reader, "vc_console_id").ToUpper();
                            byte[] secondaryId = WSClient.GetBytes(reader, "bin_cert_hash");
                            Puid   machinePuid = (ulong) WSClient.GetInt64(reader, "bi_machine_puid");

                            //
                            // Build and remember the record.
                            // 
                            // Note consoleIdList is a List<> and not a 
                            // HashSet<> because console ids are partition
                            // specific.
                            // 
                            // That is, only a single partition will
                            // ever return data about a particular console
                            // id. Thus we don't need to check for
                            // duplicates.
                            // 
                            ConsoleIdInfo info = new ConsoleIdInfo( 
                                machinePuid, 
                                consoleId, 
                                secondaryId 
                                );
                            consoleIdInfoList.Add( info );
                        }
                    }
                }
            }

            //
            // Return the completed lookups
            // 
            return consoleIdInfoList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupMachinePuidsByPcTokens.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupMachinePuidsByPcTokens.cs
//
// Implementation of LookupMachinePuidsPcTokens SOAP API for XMachine FD
//
// Jan-20-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod + Internal
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        [WebMethod] public PcTokenInfo[] LookupMachinePuidsByPcTokens(
            byte[][] tokens
            )
        {
            HResult       hr               = HResult.S_OK;
            byte[][]      validTokenIds    = new byte[0][];
            PcTokenInfo[] pcTokenInfo      = new PcTokenInfo[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( tokens, "pcTokens" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                List<string>  validEncodedTokenIdList = new List<string>();
                foreach (Byte[] tokenId in tokens)
                {
                    if (tokenId.Length != 20) 
                    {
                        throw new XRLExceptionWithoutEvent(
                            HResult.XONLINE_E_INVALID_REQUEST,
                            "Token Hashes must be 20 bytes long: {0}",
                            Utilities.ByteArrayToString( tokenId )
                            );
                    }
                    validEncodedTokenIdList.Add( Convert.ToBase64String( tokenId) );
                }

                string[] validEncodedTokenIds = Utilities.UniqueIds( validEncodedTokenIdList.ToArray() );
                validTokenIds = Array.ConvertAll(
                    validEncodedTokenIdList.ToArray(),
                    ( u => (byte[]) Convert.FromBase64String( u ) )
                    );

                PcTokenInfoInternal[] pcTokenInfoInternal = LookupMachinePuidsByPcTokensInternal(validTokenIds);

                pcTokenInfo = Array.ConvertAll(
                    pcTokenInfoInternal,
                    ( u => ( new PcTokenInfo( u ) ) )
                    );
                return pcTokenInfo;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                string[] tokenIdStrings = new string[tokens.Length];

                for (int i = 0; i < tokens.Length; ++i) 
                {
                    tokenIdStrings[i] = Utilities.ByteArrayToString( 
                        tokens[i] 
                        );
                }

                Xom.Log(
                    XomAreaName.log, "LookupBansByMachinePuids|{0}|{1}|{2}|{3}|{4}",
                    hr, tokens.Length, validTokenIds.Length, pcTokenInfo.Length, string.Join("|", tokenIdStrings)
                );
            }
        }


        private PcTokenInfoInternal[] LookupMachinePuidsByPcTokensInternal(
            Byte[][] tokenIds
        )
        {
            List<PcTokenInfoInternal> pcTokenList = new List<PcTokenInfoInternal>();

            //
            // Use webstore to lookup the relevant rows
            // 
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                DataTable[] dataTables = Utilities.TokensToDataTables(ws, tokenIds, false);

                //
                // Look thru every physical partition
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    //
                    // Skip over partitions with no work
                    // 
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    //
                    // Craft the webstore call
                    // 
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_lookup_puids_by_pc_tokens";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_voucher_lookup_list", dataTables[i]);

                    //
                    // Execute
                    // 
                    using (WstDataReader reader = ws.Execute())
                    {
                        while (reader.Read())
                        {
                            //
                            // Read the results
                            // 
                            Puid   puid        = (ulong) WSClient.GetInt64(reader, "bi_machine_puid");
                            byte[] voucherHash = WSClient.GetBytes(reader, "bin_voucher_hash");
                            string encodedHash = Convert.ToBase64String( voucherHash );

                            //
                            // Build the record and remember the record
                            // 
                            // Note: pcTokenList is a List<> and not a HashSet<>
                            // because puids tokens are partition specific.
                            // 
                            // That is, only a single partition will ever 
                            // return data about a particular puid. Thus we
                            // don't need to check the pcTokenList for
                            // duplicates
                            // 
                            PcTokenInfoInternal info = new PcTokenInfoInternal( 
                                puid, 
                                voucherHash,
                                encodedHash
                                );
                            pcTokenList.Add( info );
                        }
                    }
                }
            }

            //
            // Return the completed lookups
            // 
            return pcTokenList.ToArray();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupPcMachinePuidsByMachinePuids.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupPcMachinePuidsByMachinePuids.cs
//
// Implementation of LookupMachinePuidsPcTokens SOAP API for XMachine FD
//
// Feb-09-2011 - Initial Revision
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        private PcTokenInfoInternal[] LookupPcMachinePuidsByMachinePuidsInternal(
            Puid[] puids
            )
        {
            byte[][]              pcTokens;
            HashSet<byte[]>       uniquePcTokensSet = new HashSet<byte[]>();
            PcTokenInfoInternal[] pcTokenInfos      = new PcTokenInfoInternal[0];

            //
            // Convert the list of PC puids into tokens
            // 
            pcTokenInfos = LookupPcTokensByMachinePuidsInternal( puids );

            //
            // Get the unique set of PC tokens
            //
            Utilities.UniqueAdd( 
                Array.ConvertAll( pcTokenInfos, ( u => (byte[]) u.VoucherHash ) ),
                uniquePcTokensSet
                );
            pcTokens = new byte[uniquePcTokensSet.Count][];
            uniquePcTokensSet.CopyTo( pcTokens );

            //
            // Convert the list of pc tokens back to machine puids
            // 
            return LookupMachinePuidsByPcTokensInternal( pcTokens );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupRecoveryHistoryByMachinePuid.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Data.SqlTypes;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
       public partial class XMachine
       {
       public class RecoveryHistory : HistorySummary
       {
           public RecoveryHistoryDetails[] Details { get; set; }

           public RecoveryHistory()
           {
           }

           public RecoveryHistory(RecoveryHistoryDetails[] details)
               : base(details)
           {
           }
        }

        [WebMethod]
        public RecoveryHistory LookupRecoveryHistoryByMachinePuid(ulong machinePuid, ulong? userPuid, DateTime? since, bool details)
        {
            HResult hr = HResult.S_OK;

            if (since.HasValue == true && since.Value < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid since:{0}",
                    since.Value
                    );
            }

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                //We should pull from SecMachineHistory database, but if we are 
                //still in double write mode then we have not migrated
                //completely out of UODB so get from there if the
                //doublewrite setting is still set to true
                string databaseName = ConfigUtil.SecMachineHistoryWebstoreApp;

                string storedProcedureName = "p_xmachine_machine_recovery_history_get";

                if (Config.GetBoolSetting(Setting.xmachine_doubleWriteHistory))
                {
                    databaseName = ConfigUtil.UodbWebstoreApp;
                    storedProcedureName = "p_xuacs_machine_recovery_history_get";
                }

                Puid? tempuserPuid = userPuid.HasValue ? (Puid)userPuid : (Puid?)null;
                return LookupRecoveryHistoryByMachinePuidInternal(databaseName, storedProcedureName, (Puid)machinePuid, tempuserPuid, since, details);
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                Xom.Log(
                    XomAreaName.log, "LookupRecoveryHistoryByMachinePuid|{0}|{1}|{2}",
                    hr, machinePuid.ToString(), userPuid == null ? "<none>" : userPuid.ToString()
                );
            }
        }

        private RecoveryHistory LookupRecoveryHistoryByMachinePuidInternal(string databaseName, string storedProcedureName, Puid machinePuid, Puid? userPuid, DateTime? since, bool details)
        {
            using (WSClient ws = new WSClient(databaseName, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(machinePuid);
                ws.StoredProc = storedProcedureName;
                ws.AddParameter("@bi_machine_puid", machinePuid);

                if ((userPuid != null) && (userPuid != 0)) ws.AddParameter("@bi_user_puid", (Puid)userPuid);
                
                if (since != null) ws.AddParameter(ParamType.INPUT, "@dt_since", (DateTime)since);
                ws.AddParameter(ParamType.INPUT, "@b_details", details ? 1 : 0);
                ws.AddParameter(ParamType.RETVAL, "@hr", (int)HResult.S_OK);

                using (WstDataReader reader = ws.Execute())
                {
                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (hr.IsSuccess())
                    {
                        if (!reader.Read())
                        {
                            throw new XRLException(
                                    HResult.XONLINE_E_DATABASE_RESULT_ERROR,
                                    XEvent.Id.ACCOUNTS_HISTORY_GET_ERROR,
                                    "Error reading history summary information"
                                );
                        }

                        RecoveryHistory rh = new RecoveryHistory();

                        rh.Unique = WSClient.IsDBNull(reader, "i_unique") ? 0 : WSClient.GetInt32(reader, "i_unique");
                        rh.Total = WSClient.IsDBNull(reader, "i_total") ? 0 : WSClient.GetInt32(reader, "i_total");
                        rh.First = WSClient.IsDBNull(reader, "dt_first") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_first");
                        rh.Last = WSClient.IsDBNull(reader, "dt_last") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_last");

                        if (details && reader.NextResult())
                        {
                            int i = 0;
                            rh.Details = new RecoveryHistoryDetails[rh.Total];

                            while (reader.Read())
                            {
                                rh.Details[i] = new RecoveryHistoryDetails();

                                rh.Details[i].UserPuid = WSClient.GetPuid(reader, "bi_user_puid");
                                rh.Details[i].MachinePuid = WSClient.IsDBNull(reader, "bi_machine_puid") ? 0 : WSClient.GetPuid(reader, "bi_machine_puid");
                                rh.Details[i].IpAddress = WSClient.IsDBNull(reader, "vc_ip_address") ? null : WSClient.GetString(reader, "vc_ip_address");
                                rh.Details[i].Timestamp = WSClient.GetDateTime(reader, "dt_timestamp");
                                rh.Details[i].HResult = WSClient.GetHResult(reader, "i_hr");
                                rh.Details[i].Reason = WSClient.GetByte(reader, "ti_reason");

                                rh.Details[i].PassportPuid = WSClient.GetPuid(reader, "bi_user_passport_puid");
                                rh.Details[i].InitDetails();
                                i++;
                            }
                        }

                        return rh;
                    }
                    else
                        return null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupUserHistoryByMachinePuid.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Data.SqlTypes;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class UserMachineHistoryDetails
        {
            public UserMachineHistoryDetails()
            {
            }

            public UserMachineHistoryDetails(
                ulong userPuid,
                ulong machinePuid,
                int daysSeen,
                string ipAddress,
                DateTime firstSignin,
                DateTime lastSignin,
                DateTime lastSignout,
                string friendlyName,
                int trustLevel)
            {
                UserPuid = userPuid;
                MachinePuid = machinePuid;
                DaysSeen = daysSeen;
                IpAddress = ipAddress;
                FirstSignin = firstSignin;
                LastSignin = lastSignin;
                LastSignout = lastSignout;
                FriendlyName = friendlyName;
                TrustLevel = trustLevel;               
            }

            public ulong UserPuid       { get; set; }
            public ulong? MachinePuid   { get; set; }
            public int DaysSeen         { get; set; }
            public string IpAddress     { get; set; }
            public DateTime FirstSignin { get; set; }
            public DateTime LastSignin  { get; set; }
            public DateTime LastSignout { get; set; }
            public string FriendlyName  { get; set; }
            public int TrustLevel       { get; set; }          

            // not real days seen. most days seen before a date.
            // it could be less,  but it is definitely no  more.
            public int DaysSeenBefore(DateTime before)
            {
                TimeSpan timespan = before - (DateTime)FirstSignin;
                if (timespan.TotalDays < 0) return 0;
                if (timespan.TotalDays < DaysSeen) return (int)timespan.TotalDays;
                return DaysSeen;
            }
        }

        /// <summary>
        /// Get the user history based on the machine puid
        /// </summary>
        /// <param name="machinePuid"></param>
        /// <param name="since"></param>
        /// <returns></returns>
        [WebMethod]
        public UserMachineHistoryDetails[] LookupUserHistoryByMachinePuid(ulong machinePuid, DateTime? since)
        {
            HResult hr = HResult.S_OK;

            if (since.HasValue == true && since.Value < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid since:{0}",
                    since.Value
                    );
            }

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                return GetByMachinePuid((Puid)machinePuid, since);
            }

            catch (Exception e)
            {
                hr = XblException.GetHResult(e);

                if (e is ExceptionWithEventId)
                {
                    Xom.Log(
                        XomAreaName.log, "Error in LookupUserHistoryByMachinePuid : {0}|{1}",
                        hr, (Puid)machinePuid
                    );
                }

                throw;
            }

            finally
            {

                Xom.Log(XomAreaName.log, "LookupUserHistoryByMachinePuid|{0}|{1}",
                   hr, (Puid)machinePuid
                );
            }
        }

        private UserMachineHistoryDetails[] GetByMachinePuid(Puid machinePuid, DateTime? since)
        {
            List<UserMachineHistoryDetails> machineHistoryList = new List<UserMachineHistoryDetails>();

            using (WstConnection connection = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                connection.Open();

                //For now we can only request this data from UODB
                string databaseName = ConfigUtil.UodbWebstoreApp;
                string storedProcedureName = "p_xmachine_machine_get";

                for (int i = 0; i < connection.SqlPartitions.Count; i++)
                {
                    using (WSClient ws = new WSClient(databaseName, CmdType.WRITETHENREAD_COMMANDTYPE))
                    {
                        ws.ClearParameters();

                        ws.StoredProc = storedProcedureName;
                        ws.PhysicalPartition = i;

                        ws.AddParameter("@bi_machine_puid", machinePuid);
                        if (since != null) ws.AddParameter("@dt_since", (DateTime)since);

                        using (WstDataReader reader = ws.Execute())
                        {
                            while (reader.Read())
                            {
                                UserMachineHistoryDetails umhd = new UserMachineHistoryDetails();
                                umhd.UserPuid = WSClient.GetPuid(reader, "bi_user_puid");
                                umhd.MachinePuid = WSClient.GetPuid(reader, "bi_machine_puid");
                                umhd.DaysSeen = WSClient.GetInt32(reader, "i_days_seen");
                                umhd.IpAddress = WSClient.IsDBNull(reader, "vc_ip_address") ? null : WSClient.GetString(reader, "vc_ip_address");
                                umhd.FirstSignin = WSClient.GetDateTime(reader, "dt_first_signin");
                                umhd.LastSignin = WSClient.GetDateTime(reader, "dt_last_signin");
                                umhd.LastSignout = WSClient.GetDateTime(reader, "dt_last_signout");
                                umhd.FriendlyName = WSClient.IsDBNull(reader, "vc_friendly_name") ? null : WSClient.GetString(reader, "vc_friendly_name");
                                umhd.TrustLevel = WSClient.GetInt32(reader, "i_trust_level");
                                machineHistoryList.Add(umhd);
                            }
                        }

                    }
                }
            }
            return machineHistoryList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupPassportHistoryByMachinePuid.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Data.SqlTypes;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
       public partial class XMachine
       {
        public class PassportHistory : HistorySummary
        {
            public PassportHistoryDetails[] Details { get; set; }

            public PassportHistory()
            {
            }

            public PassportHistory(PassportHistoryDetails[] details)
                : base(details)
            {
            }
        }

        [WebMethod]
        public PassportHistory LookupPassportHistoryByMachinePuid(ulong machinePuid, ulong? userPuid, DateTime? since, bool details)
        {
            HResult hr = HResult.S_OK;

            if (since.HasValue == true && since.Value < (DateTime)SqlDateTime.MinValue)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid since:{0}",
                    since.Value
                    );
            }

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                //We should pull from SecMachineHistory database, but if we are 
                //still in double write mode then we have not migrated
                //completely out of UODB so get from there if the
                //doublewrite setting is still set to true
                string databaseName = ConfigUtil.SecMachineHistoryWebstoreApp;

                string storedProcedureName = "p_xmachine_machine_passport_history_get";

                if (Config.GetBoolSetting(Setting.xmachine_doubleWriteHistory))
                {
                    databaseName = ConfigUtil.UodbWebstoreApp;
                    storedProcedureName = "p_xuacs_machine_passport_history_get";
                }

                Puid? tempuserPuid = userPuid.HasValue ? (Puid)userPuid : (Puid?)null;
                return LookupPassportHistoryByMachinePuidInternal(databaseName, storedProcedureName, (Puid)machinePuid, tempuserPuid, since, details);
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                Xom.Log(
                    XomAreaName.log, "LookupPassportHistoryByMachinePuid|{0}|{1}|{2}",
                    hr, machinePuid.ToString(), userPuid == null ? "<none>" : userPuid.ToString()
                );
            }
        }

        private PassportHistory LookupPassportHistoryByMachinePuidInternal(string databaseName, string storedProcedureName, Puid machinePuid, Puid? userPuid, DateTime? since, bool details)
        {
            using (WSClient ws = new WSClient(databaseName, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(machinePuid);
                ws.StoredProc = storedProcedureName;
                ws.AddParameter("@bi_machine_puid", machinePuid);

                if ((userPuid != null) && (userPuid != 0)) ws.AddParameter("@bi_user_puid", (Puid)userPuid);
                
                if (since != null) ws.AddParameter(ParamType.INPUT, "@dt_since", (DateTime)since);
                ws.AddParameter(ParamType.INPUT, "@b_details", details ? 1 : 0);
                ws.AddParameter(ParamType.RETVAL, "@hr", (int)HResult.S_OK);

                using (WstDataReader reader = ws.Execute())
                {
                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (hr.IsSuccess())
                    {
                        if (!reader.Read())
                        {
                            throw new XRLException(
                                    HResult.XONLINE_E_DATABASE_RESULT_ERROR,
                                    XEvent.Id.ACCOUNTS_HISTORY_GET_ERROR,
                                    "Error reading history summary information"
                                );
                        }

                        PassportHistory pph = new PassportHistory();

                        pph.Unique = WSClient.IsDBNull(reader, "i_unique") ? 0 : WSClient.GetInt32(reader, "i_unique");
                        pph.Total = WSClient.IsDBNull(reader, "i_total") ? 0 : WSClient.GetInt32(reader, "i_total");
                        pph.First = WSClient.IsDBNull(reader, "dt_first") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_first");
                        pph.Last = WSClient.IsDBNull(reader, "dt_last") ? (DateTime?)null : WSClient.GetDateTime(reader, "dt_last");

                        if (details && reader.NextResult())
                        {
                            int i = 0;
                            pph.Details = new PassportHistoryDetails[pph.Total];

                            while (reader.Read())
                            {
                                pph.Details[i] = new PassportHistoryDetails();

                                pph.Details[i].UserPuid = WSClient.GetPuid(reader, "bi_user_puid");
                                pph.Details[i].MachinePuid = WSClient.IsDBNull(reader, "bi_machine_puid") ? 0 : WSClient.GetPuid(reader, "bi_machine_puid");
                                pph.Details[i].IpAddress = WSClient.IsDBNull(reader, "vc_ip_address") ? null : WSClient.GetString(reader, "vc_ip_address");
                                pph.Details[i].Timestamp = WSClient.GetDateTime(reader, "dt_timestamp");
                                pph.Details[i].HResult = WSClient.GetHResult(reader, "i_hr");
                                pph.Details[i].Reason = WSClient.GetByte(reader, "ti_reason");

                                pph.Details[i].OldPassportPuid = WSClient.IsDBNull(reader, "bi_old_passport_puid") ? (ulong?)null : (ulong?)(ulong)WSClient.GetPuid(reader, "bi_old_passport_puid");
                                pph.Details[i].NewPassportPuid = WSClient.IsDBNull(reader, "bi_new_passport_puid") ? (ulong?)null : (ulong?)(ulong)WSClient.GetPuid(reader, "bi_new_passport_puid");
                                pph.Details[i].InitDetails();
                                i++;
                            }
                        }

                        return pph;
                    }
                    else
                        return null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\TestConnection.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// TestConnection.cs
//
// Implementation of TestConnection SOAP API for XMachine FD
//
// Jan-13-2011 - Initial Revision
//

using System;
using System.Web.Services;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        [WebMethod]
        public string TestConnection(string inputMessage)
        {
            return inputMessage;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\PerfCounters.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// PerfCtrs.cs
//
// Implementation of Performance Counters for XMachine FD
//
// Jan-09-2011 - Initial Revision
//

using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.xmachine.fd
{
    //
    // Note that private\common\core\feapp.cs handles the standard
    // performance counters. These include:
    // * Execution Time
    // * Requests Totals
    // * Requests Per Second
    // * Failures Totals
    // * Failures Per Second
    // * Failure Percentage
    // 
    // So the above performance counters should not be repeated here
    // 

    //
    // A custom performance counter (example)
    // 
    // Category Name Definition
    // [XomPerformanceCounterCategoryAttr( "XMachine FD", "Xbox Online Machine Service" )]
    // Category Class Definition
    // public class XMachineCounters : XomPerformanceCounterCategory
    // {
    //     // Publicly visible static instance
    //     static public XMachineCounters Counters = new XMachineCounters();
    //
    //     // Public visible getter
    //     public virtual XMachineCounters this[string instance]
    //     {
    //         get
    //         {
    //             return (XMachineCounters) GetInstance(instance);
    //         }
    //     }
    //
    //     // Number of Example Events that have occured
    //     [XomPerformanceCounterAttr(
    //         "Total Example Events", 
    //         "Total Example events that have occured", 
    //         PerformanceCounterType.NumberOfItems64)]
    //     public PerformanceCounter TotalExampleEvents;
    //
    //     [XomPerformanceCounterAttr(
    //         "Example Events per Second", 
    //         "Example events that have occured per second", 
    //         PerformanceCounterType.RateOfCountsPerSecond32)]
    //     public PerformanceCounter ExampleEventsPerSecond;
    //
    //    // See various other Front Doors for more examples
    // }

} // namespace xonline.server.xmachine.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\ResetMachinePasswordByConsoleIds.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// ResetMachinePasswordByConsoleIds.cs
//
// Implementation of ResetMachinePasswordByConsoleIds SOAP API for XMachine FD
//
// Jan-30-2011 - Initial Revision
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Web;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        [WebMethod]
        public ConsoleIdResult[] ResetMachinePasswordByConsoleIds(
            string[] consoleIds
            )
        {
            ConsoleIdResult[] consoleIdResults = new ConsoleIdResult[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( consoleIds, "consoleIds" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                consoleIdResults = ResetMachinePasswordByConsoleIdsImpl( consoleIds );
                return consoleIdResults;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                throw;
            }
            finally
            {
                foreach (ConsoleIdResult result in consoleIdResults)
                {
                    Xom.Log(
                        XomAreaName.log,
                        string.Join(
                            "|",
                            new string[] {
                                "ResetMachinePasswordByConsoleIds",
                                result.ConsoleId,
                                result.Result.ToString(),
                                HttpContext.Current.Request.UserHostAddress }
                            )
                        );
                }
            }
        }

        private ConsoleIdResult[] ResetMachinePasswordByConsoleIdsImpl(
            string[] consoleIds
            )
        {
            ConsoleIdInfo[]       consoleIdList    = new ConsoleIdInfo[0];
            HashSet<String>       consoleIdsSet    = new HashSet<String>();
            HashSet<String>       failedIdsSet     = new HashSet<String>();
            List<ConsoleIdResult> resetResultsList = new List<ConsoleIdResult>();
       
            //
            // Verify that the console ids are correctly formatted Xbox 360
            // console ids. We don't want to populate our database with 
            // invalid entries.
            // 
            consoleIds = ConsoleIds.Validate(consoleIds, true);

            //
            // Convert the console ids into machine puids
            // 
            try 
            {
                consoleIdList = LookupMachinePuidsByConsoleIdsInternal(consoleIds);
                if (consoleIdList.Length == 0)
                {
                    throw new XRLExceptionWithoutEvent(
                        HResult.E_FAIL,
                        "Could not convert console ids to machine puids"
                        );
                }
            }
            catch (Exception e)
            {
                HResult hr = XblException.GetHResult(e);

                return Array.ConvertAll<string,ConsoleIdResult>(
                    consoleIds,
                    ( u => new ConsoleIdResult( u, hr ) )
                    );
            }

            //
            // Build a Hashset of the console ids with machine puids. 
            // Any console ids not in the list will be considered to
            // have failed
            // 
            Utilities.UniqueAdd( 
                Array.ConvertAll(
                    consoleIdList,
                    ( u => (string) u.ConsoleId )
                    ), 
                consoleIdsSet 
                );
            foreach (String id in consoleIds)
            {
                if (consoleIdsSet.Contains(id) == true)
                {
                    continue;
                }
                failedIdsSet.Add(id);
            }

            //
            // Reset all the console ids we have found
            // 
            String[] tempFailedIdsList;
            tempFailedIdsList = ResetMachinePasswordByConsoleIdsInternal(
                consoleIds
                );
            Utilities.UniqueAdd( tempFailedIdsList, failedIdsSet );

            //
            // Reset the machine puids
            // 
            Puid[] machinePuids = Array.ConvertAll(
                consoleIdList,
                ( u => (Puid) u.MachinePuid )
                );
            HashSet<Puid> failedPuidsSet = new HashSet<Puid>();

            //
            // Update t_machines.dt_reset_date
            // 
            Puid[] failedPuids = ResetMachinePasswordDateByMachinePuidsInternal(
                machinePuids
                );
            Utilities.UniqueAdd( failedPuids, failedPuidsSet );

            //
            // Corrolate failures back to ConsoleIds
            // 
            foreach (ConsoleIdInfo info in consoleIdList)
            {
                if (failedIdsSet.Contains(info.ConsoleId) == true)
                {
                    continue;
                }
                if (failedPuidsSet.Contains(info.MachinePuid) == true)
                {
                    failedIdsSet.Add(info.ConsoleId);
                }
            }

            //
            // Build and return the outcome
            // 
            foreach (String id in consoleIds)
            {
                ConsoleIdResult resetResult = new ConsoleIdResult(
                    id,
                    (failedIdsSet.Contains( id ) == false ? HResult.S_OK : HResult.E_FAIL)
                    );
                resetResultsList.Add( resetResult );
            }
            return resetResultsList.ToArray();
        }

        private string[] ResetMachinePasswordByConsoleIdsInternal(
            string[] consoleIds
        )
        {
            List<String> failedIds = new List<String>();

            //
            // Use Webstore to update the relevant rows
            //
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                HResult     hr            = HResult.S_OK;
                DataTable[] consoleTables = Utilities.ConsoleIdsToDataTables(ws, consoleIds, false);

                //
                // Determine a random IV and KEY for all of these consoles. It probably is
                // okay if all the consoles share the same IV and KEY since it would be
                // almost impossible to guess one
                // 
                Random rnd = new Random( unchecked((int) DateTime.Now.Ticks) );

                byte[] iv  = new Byte[16];
                byte[] key = new Byte[16];

                rnd.NextBytes( iv );
                rnd.NextBytes( key );

                //
                // Update records across all the partitions for the console ids
                // 
                for (int i = 0; i < consoleTables.Length; ++i)
                {
                    // Skip over partitions with no work
                    if (consoleTables[i] == null)
                    {
                        continue;
                    }

                    // Build the parameters
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_reset_password_machine";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_console_reset_list", consoleTables[i]);
                    ws.AddParameter("@bin_iv", iv );
                    ws.AddParameter("@bin_key", key );
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr );

                    // Execute
                    try
                    {
                        ws.ExecuteNonQuery();

                        // Check the return
                        hr = (uint) ws.GetIntParameter("@RETVAL");
                        if (hr.IsFailure())
                        {
                            throw new XRLExceptionWithoutEvent(
                                hr,
                                "p_xmachine_reset_password_machine() failed"
                                );
                        }
                    }
                    catch (Exception e)
                    {
                        Xom.Trace(
                            XomAreaName.xmachine,
                            LogLevel.L_WARNING,
                            "ResetMachinePasswordByConsoleIdsInternal Exception: " + e.ToString()
                            );

                        // Remember which console ids we failed on
                        foreach (DataRow row in consoleTables[i].Rows)
                        {
                            failedIds.Add( ( (string) row["vc_console_id"]).ToUpper() );
                        }
                    }
                }
            }
            return failedIds.ToArray();
        }

        private Puid[] ResetMachinePasswordDateByMachinePuidsInternal(
            Puid[] puids
            )
        {
            List<Puid> failedPuids = new List<Puid>();

            //
            // Use Webstore to update the relevant rows
            //
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                HResult     hr         = HResult.S_OK;
                DataTable[] dataTables = Utilities.PuidsToDataTables(ws, puids, false);

                //
                // Update records across all the partitions
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    // Skip over partitions with no work
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    // Build the parameters
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_reset_machine";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_machine_reset_list", dataTables[i]);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr );

                    // Execute
                    try
                    {
                        ws.ExecuteNonQuery();

                        // Check the return
                        hr = (uint) ws.GetIntParameter("@RETVAL");
                        if (hr.IsFailure())
                        {
                            throw new XRLExceptionWithoutEvent(
                                hr,
                                "p_xmachine_reset_password() failed"
                                );
                        }
                    }
                    catch (Exception e)
                    {
                        Xom.Trace(
                            XomAreaName.xmachine,
                            LogLevel.L_WARNING,
                            "ResetMachinePasswordDateByMachinePuidsInternal Exception: " + e.ToString()
                            );

                        // Remember which Puids we failed on
                        foreach (DataRow row in dataTables[i].Rows)
                        {
                            failedPuids.Add( (Puid) (long) row["bi_machine_puid"] );
                        }
                    }
                }
            }
            return failedPuids.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\LookupPcTokensByMachinePuids.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// LookupPcTokensByMachinePuids.cs
//
// Implementation of LookupPcTokensByMachinePuids SOAP API for XMachine FD
//
// Jan-21-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod + Internal
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        public class PcTokenInfo
        {
            public Puid   MachinePuid;
            public byte[] VoucherHash;

            public PcTokenInfo()
            {
            }

            public PcTokenInfo(PcTokenInfoInternal info)
            {
                MachinePuid = info.MachinePuid;
                VoucherHash = info.VoucherHash;
            }

            public PcTokenInfo(Puid machinePuid, byte[] voucherHash)
            {
                MachinePuid = machinePuid;
                VoucherHash = voucherHash;
            }
        }

        public class PcTokenInfoInternal
        {
            public Puid   MachinePuid;
            public byte[] VoucherHash;
            public string EncodedHash;

            public PcTokenInfoInternal()
            {
            }

            public PcTokenInfoInternal(Puid machinePuid, byte[] voucherHash, string encodedHash)
            {
                MachinePuid = machinePuid;
                VoucherHash = voucherHash;
                EncodedHash = encodedHash;
            }
        }

        [WebMethod]
        public PcTokenInfo[] LookupPcTokensByMachinePuids(
            Puid[] puids
        )
        {
            HResult hr                  = HResult.S_OK;
            List<Puid>    pcPuidList    = new List<Puid>();
            Puid[]        pcPuids       = new Puid[0];
            PcTokenInfo[] pcTokens      = new PcTokenInfo[0]; 

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( puids, "machinePuids" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                // Unique Puids with PC check
                foreach (Puid puid in puids)
                {
                    if (!XOn.XboxId.IsPcMachinePuid(puid)) continue;
                    pcPuidList.Add(puid);
                }
                pcPuids = Utilities.UniqueIds<Puid>(pcPuidList.ToArray());

                // Call the internal helper function
                PcTokenInfoInternal[] pcTokensInternal = LookupPcTokensByMachinePuidsInternal(pcPuids);

                pcTokens = Array.ConvertAll(
                    pcTokensInternal,
                    ( u => new PcTokenInfo( u ) )
                    );
                return pcTokens;
            }
            catch (Exception e) 
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {
                string[] puidStrings = Array.ConvertAll<Puid, string>(puids, (u => u.ToString()));

                Xom.Log(
                    XomAreaName.log, "LookupPcTokensByMachinePuids|{0}|{1}|{2}|{3}|{4}",
                    hr, puids.Length, pcPuids.Length, pcTokens.Length, string.Join("|", puidStrings)
                );
            }
        }

        private PcTokenInfoInternal[] LookupPcTokensByMachinePuidsInternal(
            Puid[] puids
        )
        {
            List<PcTokenInfoInternal> pcTokenList    = new List<PcTokenInfoInternal>();
            List<Puid>                failedPuidList = new List<Puid>();

            //
            // Use webstore to lookup the relevant rows
            // 
            using (WSClient _ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                //
                // We don't know and cannot calculate which partition the voucher is found on
                // 
                DataTable dataTable = new DataTable();
                dataTable.Columns.Add("bi_machine_puid",typeof(long));

                //
                // Process all console ids once
                // 
                foreach (Puid puid in puids)
                {
                    dataTable.Rows.Add( (long) puid );
                }

                //
                // Look thru every physical partition
                // 
                for (int i = 0; i < _ws.PhysicalPartitions; ++i)
                {
                    //
                    // We keep track of the number of tokens we have
                    // found (non unique). When this is equal to the
                    // number of puids we are searching for, we can
                    // stop. We do this to avoid hitting *every*
                    // partition all the time
                    // 
                    if (puids.Length == pcTokenList.Count)
                    {
                        break;
                    }

                    //
                    // Craft the webstore call
                    // 
                    _ws.ClearParameters();
                    _ws.StoredProc = "dbo.p_xmachine_lookup_pc_tokens_by_puids";
                    _ws.PhysicalPartition = i;
                    _ws.Parameters.AddWithValue("@xmachine_machine_lookup_list", dataTable);

                    //
                    // Execute
                    // 
                    try
                    {
                        using (WstDataReader reader = _ws.Execute())
                        {
                            while (reader.Read())
                            {
                                //
                                // Read the results
                                // 
                                Puid   puid        = (ulong) WSClient.GetInt64(reader, "bi_machine_puid");
                                byte[] voucherHash = WSClient.GetBytes(reader, "bin_voucher_hash");
                                string encodedHash = Convert.ToBase64String( voucherHash );

                                //
                                // Build the record and remember the record.
                                // 
                                // Note: pcTokenList is a List<> and not a HashSet<>
                                // because puids tokens are partition specific.
                                // 
                                // That is, only a single partition will ever
                                // return data about a particular puid. Thus we
                                // don't need to check the pcTokenList for
                                // duplicates.
                                // 
                                PcTokenInfoInternal info = new PcTokenInfoInternal( 
                                    puid, 
                                    voucherHash,
                                    encodedHash
                                    );
                                pcTokenList.Add( info );
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Xom.Trace(
                            XomAreaName.xmachine,
                            LogLevel.L_WARNING,
                            "LookupPcTokensByMachinePuids Exception: " + e.ToString()
                            );
                    }
                }
            }

            //
            // Return the completed lookups
            // 
            return pcTokenList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\Utils.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// Utils.cs
//
// Misc Functions for XMachine FD
//
// Jan-13-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod and Internal
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public class Utilities
    {
        public static DataTable[] ConsoleIdsToDataTables(WSClient ws, string[] consoleIds, bool insert)
        {
            return ToDataTables(ws, "vc_console_id", consoleIds, Array.ConvertAll(consoleIds, (u => ws.CalcPartition(u))), insert);
        }

        public static DataTable[] PuidsToDataTables(WSClient ws, Puid[] puids, bool insert)
        {
            long[] longPuids = Array.ConvertAll(puids, (u => (long) u));
            return ToDataTables(ws, "bi_machine_puid", longPuids, Array.ConvertAll(longPuids, (u => ws.CalcPartition(u))), insert);
        }

        public static DataTable[] TokensToDataTables(WSClient ws, byte[][] tokens, bool insert)
        {
            return ToDataTables(ws, "bin_voucher_hash", tokens, Array.ConvertAll(tokens, (u => ws.CalcPartition(BitConverter.ToInt64(u, 0)))), insert);
        }

        public static DataTable[] ToDataTables<T>(WSClient ws, string columnName, T[] values, int[] logicalPartitions, bool insert)
        {
            DataTable[] dataTables = new DataTable[ws.PhysicalPartitions];

            for (int i = 0; i < values.Length; i++)
            {
                int partition = ws.GetPhysicalPartition(logicalPartitions[i]);

                if (dataTables[partition] == null)
                {
                    dataTables[partition] = new DataTable();
                    dataTables[partition].Columns.Add(columnName, typeof(T));
                    if (insert) dataTables[partition].Columns.Add("si_hash_bucket", typeof(short));
                }

                if (insert)
                    dataTables[partition].Rows.Add(values[i], logicalPartitions[i]);
                else {
                    dataTables[partition].Rows.Add(values[i]);
                }
            }

            return dataTables;
        }


        public static T[] UniqueIds<T>(T[] ids)
        {
            // spin through the ids to eliminate duplicates

            HashSet<T> hashSet = new HashSet<T>();

            foreach (T id in ids)
            {
                if (hashSet.Contains(id)) continue;
                hashSet.Add(id);
            }

            T[] uniqueIds = new T[hashSet.Count];
            hashSet.CopyTo(uniqueIds);
            return uniqueIds;
        }

        public static void UniqueAdd<T>(T[] ids, HashSet<T> hashSet)
        {
            foreach (T id in ids)
            {
                if (hashSet.Contains(id) == true)
                {
                    continue;
                }
                hashSet.Add(id);
            }
        }

        public static void UniqueAdd<T>(T[] ids, HashSet<T> hashSet, List<T> list)
        {
            foreach (T id in ids)
            {
                if (hashSet.Contains(id) == true)
                {
                    continue;
                }
                hashSet.Add(id);
                list.Add(id);
            }
        }

        public static void CheckArray<T>(T[] array, string paramName)
        {
            if (array == null)
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_INVALID_REQUEST, "Null array: {0}", paramName);
            }
            foreach (T element in array)
            {
                if (element == null)
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_INVALID_REQUEST, "Null element in: {0}", paramName);
                }
            }
        }

        public static string ByteArrayToString(byte[] array)
        {
            if (array == null)
            {
                return "NULL";
            }

            string resultString = String.Empty;
            for (int i = 0; i < array.Length; ++i)
            {
                resultString += array[i].ToString("X2");
            }
            return resultString;
        }

        public static bool CheckForPcMachinePuids(Puid[] puids, HResult reasonCode, DateTime banStart, DateTime banEnd)
        {
            bool   hasPcPuids   = false;
            byte[] platformType = Array.ConvertAll( puids, ( u => XOn.XboxId.GetPlatformType( u ) ) );

            for (int i = 0; i < platformType.Length; ++i)
            {
                // Absolutely no xbox 1 or web puids
                if (platformType[i] == XOn.XPLT_XBOX1 ||
                    platformType[i] == XOn.XPLT_WEB)
                {
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "Invalid PlatformType: {0}",
                        puids[i]
                        );
                }

                // Special restrictions for PCs
                if (platformType[i] == XOn.XPLT_PC)
                {
                    hasPcPuids = true;

                    // 1 day buffer to account for clock drift and because it
                    // doesn't really matter --- it is still 7000 years in the
                    // future
                    if (banEnd < DateTime.MaxValue.AddDays(-1))
                    {
                        throw new XRLExceptionWithoutEvent(
                            HResult.XONLINE_E_INVALID_REQUEST,
                            "PC Bans must be permanent: {0} - {1}",
                            puids[i],
                            banEnd
                            );
                    }
                    // 5 minute buffer to account for clock drift
                    if (banStart > DateTime.UtcNow.AddMinutes(5))
                    {
                        throw new XRLExceptionWithoutEvent(
                            HResult.XONLINE_E_INVALID_REQUEST,
                            "PC Bans must start before now: {0} - {1}",
                            puids[i],
                            banStart
                            );
                    }
                    if (reasonCode != HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED)
                    {
                        throw new XRLExceptionWithoutEvent(
                            HResult.XONLINE_E_INVALID_REQUEST,
                            "PC Bans must be for Reason {0}: {1} - {2}",
                            (HResult) HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED,
                            puids[i],
                            reasonCode
                            );
                    }
                }

                // Homogenous puid check
                if (i != 0 && platformType[i-1] != platformType[i])
                {
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "Mixed PlatformType: {0} - {1}",
                        puids[i-1],
                        puids[i]
                        );
                }
            }
            return hasPcPuids;
        }

        public static bool CheckSCodeFormat(byte[] scode)
        {
            // The format for the secondary ID as displayed to a customer:
            //     XXXX-XXXX-XXXX-XXAB
            // Where:
            //     XX - 1st 7 bytes of the Secondary Identifier
            //     A  - Checksum of High Nibble
            //     B  - Checksum of Low Nibble
            // 
            // Note: The two checksum nibbles are *not* the 8th byte of the
            // full secondary identifier.
            //
            // Note: If 1 byte and equal to 0 then it is the acceptable "null" case
            //
            if (scode.Length == 1 && scode[0] == 0)
            {
                return true;
            }

            if (scode.Length != 8)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "scode must be 8 bytes - {0}",
                    scode.Length
                    );
            }

            byte lowNibble = 0;
            byte highNibble = 0;
            for (int i = 0; i < 7; ++i)
            {
                lowNibble += (byte)(scode[i] & 0x0F);
                lowNibble &= 0x0F;

                highNibble += (byte)(scode[i] & 0xF0);
                highNibble &= 0xF0;
            }
            byte checkSum = (byte)(lowNibble | highNibble);
            if (scode[7] != checkSum)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "SecondaryId Failed Checksum - Got {0} Expected {1}",
                    scode[7].ToString("X2"),
                    checkSum.ToString("X2")
                    );
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\UnbanPcTokens.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// UnbanPcTokens.cs
//
// Implementation of UnbanPcTokens SOAP API for XMachine FD
//
// Jan-15-2011 - Initial Revision
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Web;
using System.Web.Services;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        [WebMethod]
        public PcTokenBanResult[] UnbanPcTokens(
            byte[][] tokens
            )
        {
            PcTokenBanResult[] pcTokenBanResults = new PcTokenBanResult[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( tokens, "pcTokens" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                pcTokenBanResults = UnbanPcTokensImpl( tokens );
                return pcTokenBanResults;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                throw;
            }
            finally
            {
                foreach (PcTokenBanResult result in pcTokenBanResults)
                {
                    string voucherString = Utilities.ByteArrayToString(
                        result.VoucherHash
                        );

                    Xom.Log(
                        XomAreaName.log,
                        string.Join(
                            "|",
                            new string[] {
                                "UnbanPcTokens",
                                voucherString,
                                result.Result.ToString(),
                                HttpContext.Current.Request.UserHostAddress }
                            )
                        );
                }
            }
        }

        private PcTokenBanResult[] UnbanPcTokensImpl(
            byte[][] tokens
            )
        {
            byte[][]               uniqueTokens     = null;
            HashSet<Puid>          failedPuidsSet   = new HashSet<Puid>();
            HashSet<Puid>          uniquePuidsSet   = new HashSet<Puid>();
            HashSet<string>        failedTokensSet  = new HashSet<string>();
            HashSet<string>        uniqueTokensSet  = new HashSet<string>();
            List<Puid>             uniquePuidsList  = new List<Puid>(); 
            List<PcTokenBanResult> banResultsList   = new List<PcTokenBanResult>();
            List<string>           uniqueTokensList = new List<string>();
            string[]               failedTokens     = null;

            //
            // Make sure that the tokens are all properly formated
            // 
            foreach (byte[] token in tokens)
            {
                if (token.Length != 20)
                {
                    throw new XRLExceptionWithoutEvent(
                        HResult.XONLINE_E_INVALID_REQUEST,
                        "Token Hashes must be 20 bytes long: {0}",
                        Utilities.ByteArrayToString( token )
                        );
                }
            }

            //
            // Generate a duplicate free set of tokens
            // 
            Utilities.UniqueAdd( 
                Array.ConvertAll(
                    tokens, 
                    ( u => (string) Convert.ToBase64String( u ) )
                    ),
                uniqueTokensSet, 
                uniqueTokensList 
                );
            uniqueTokens = Array.ConvertAll(
                uniqueTokensList.ToArray(),
                ( u => (byte[]) Convert.FromBase64String( u ) )
                );

            //
            // Convert the list of tokens into PC Puids.
            // 
            PcTokenInfoInternal[] pcTokenList;
            pcTokenList = LookupMachinePuidsByPcTokensInternal(
                uniqueTokens
                );
            Utilities.UniqueAdd( 
                Array.ConvertAll( pcTokenList, ( u=> (Puid) u.MachinePuid ) ),
                uniquePuidsSet,
                uniquePuidsList
                );

            //
            // unban the all the machines we have calculated
            // 
            Puid[] failedPuids = UnbanMachinePuidsInternal(
                uniquePuidsList.ToArray(),
                HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED
                );
            Utilities.UniqueAdd( failedPuids, failedPuidsSet );

            //
            // Corrolate failures back to PcTokens
            // 
            foreach (PcTokenInfoInternal info in pcTokenList)
            {
                if (failedTokensSet.Contains(info.EncodedHash) == true)
                {
                    continue;
                }
                if (failedPuidsSet.Contains(info.MachinePuid) == true)
                {
                    failedTokensSet.Add(info.EncodedHash);
                }
            }

            //
            // Ban all the tokens we have
            // 
            failedTokens = BanPcTokensInternal(
                uniqueTokens,
                false
                );
            Utilities.UniqueAdd( failedTokens, failedTokensSet );

            //
            // Build and return the outcome
            //                  
            foreach (string encodedVoucher in uniqueTokensSet)
            {
                HResult result = HResult.S_OK;

                if (failedTokensSet.Contains( encodedVoucher ) == true)
                {
                    result = HResult.E_FAIL;
                }

                PcTokenBanResult banResult = new PcTokenBanResult(
                    Convert.FromBase64String( encodedVoucher ),
                    result
                    );
                banResultsList.Add(banResult);
            }
            return banResultsList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\UnbanConsoleIds.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// UnbanConsoleIds.cs
//
// Implementation of UnbanConsoleIds SOAP API for XMachine FD
//
// Jan-19-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod and Internal

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Web;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        [WebMethod]
        public ConsoleIdResult[] UnbanConsoleIds(
            string[] consoleIds,
            HResult  reasonCode
            )
        {
            ConsoleIdResult[] consoleIdResults = new ConsoleIdResult[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( consoleIds, "consoleIds" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                consoleIdResults = UnbanConsoleIdsImpl( consoleIds, reasonCode );
                return consoleIdResults;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                throw;                
            }
            finally
            {
                foreach (ConsoleIdResult result in consoleIdResults)
                {
                    Xom.Log(
                        XomAreaName.log,
                        string.Join(
                            "|",
                            new string[] {
                                "UnbanConsoleIds",
                                result.ConsoleId,
                                reasonCode.ToString(),
                                result.Result.ToString(),
                                HttpContext.Current.Request.UserHostAddress }
                            )
                        );
                }
            }
        }

        private ConsoleIdResult[] UnbanConsoleIdsImpl(
            string[] consoleIds,
            HResult  reasonCode
            )
        {
            ConsoleIdInfo[]       consoleIdList  = new ConsoleIdInfo[0];
            HashSet<string>       failedIdsSet   = new HashSet<string>();
            List<ConsoleIdResult> banResultsList = new List<ConsoleIdResult>();

            //
            // Sanity Checks:
            //    1 --- ReasonCode must be an HResult failure code or 0
            // 
            if (reasonCode.IsFailure() == false && reasonCode.IsOk() == false)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid ReasonCode: {0}", 
                    reasonCode
                    );    
            }
    
            //
            // Verify that the console ids are correctly formated Xbox 360
            // console ids. We don't want to populate our database with
            // invalid entries
            // 
            consoleIds = ConsoleIds.Validate(consoleIds, true);

            //
            // Convert the console ids into machine puids
            //
            try 
            {
                consoleIdList = LookupMachinePuidsByConsoleIdsInternal(consoleIds);
            }
            catch (Exception e) 
            {
                HResult hr = XblException.GetHResult(e);

                return Array.ConvertAll<string,ConsoleIdResult>(
                    consoleIds,
                    ( u => new ConsoleIdResult( u, hr ) )
                    );
            }

            //
            // If we have any machine puids, attempt to unban them
            // 
            if (consoleIdList.Length > 0)
            {
                HashSet<Puid> machinePuidsSet  = new HashSet<Puid>();
                List<Puid>    machinePuidsList = new List<Puid>();

                Utilities.UniqueAdd(
                    Array.ConvertAll( consoleIdList, ( u => (Puid) u.MachinePuid ) ),
                    machinePuidsSet,
                    machinePuidsList
                    );

                Puid[] failedPuids = UnbanMachinePuidsInternal(
                    machinePuidsList.ToArray(),
                    reasonCode
                    );

                //
                // Remember failures
                // 
                HashSet<Puid> failedPuidsSet = new HashSet<Puid>();
                Utilities.UniqueAdd( failedPuids, failedPuidsSet );

                //
                // Corrolate to ConsoleId failures
                // 
                foreach (ConsoleIdInfo info in consoleIdList)
                {
                    if (failedIdsSet.Contains(info.ConsoleId) == true)
                    {
                        continue;
                    }
                    if (failedPuidsSet.Contains(info.MachinePuid) == true)
                    {
                        failedIdsSet.Add(info.ConsoleId);
                    }
                }
            }

            //
            // Unban all the console ids that we have found
            // 
            string[] tempFailedIdsList = UnbanConsoleIdsInternal(
                consoleIds,
                reasonCode
                );
            Utilities.UniqueAdd( tempFailedIdsList, failedIdsSet );

            //
            // Build and return the outcome
            // 
            foreach (string id in consoleIds)
            {
                ConsoleIdResult banResult = new ConsoleIdResult(
                    id,
                    (failedIdsSet.Contains( id ) == false ? HResult.S_OK : HResult.E_FAIL)
                    );
                banResultsList.Add( banResult );
            }
            return banResultsList.ToArray();
        }

        private
        string[] 
        UnbanConsoleIdsInternal(
            string[] consoleIds,
            HResult  reasonCode
            )
        {
            List<string> failedList = new List<string>();

            //
            // Use Webstore to update the relevant rows
            //
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                HResult     hr            = HResult.S_OK;
                DataTable[] consoleTables = Utilities.ConsoleIdsToDataTables(ws, consoleIds, true);

                //
                // Update records across all the partitions for the console ids
                // 
                for (int i = 0; i < consoleTables.Length; ++i)
                {
                    // Skip over partitions with no work
                    if (consoleTables[i] == null)
                    {
                        continue;
                    }

                    // Build the parameters
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmachine_undo_console_ban";
                    ws.PhysicalPartition = i;
                    ws.Parameters.AddWithValue("@xmachine_console_list", consoleTables[i]);
                    ws.AddParameter(ParamType.INPUT, "@i_reason_code", reasonCode);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr );

                    // Execute
                    try
                    {
                        ws.ExecuteNonQuery();

                        // Check the return
                        hr = (uint) ws.GetIntParameter("@RETVAL");
                        if (hr.IsFailure())
                        {
                            throw new XRLExceptionWithoutEvent(
                                hr,
                                "p_xmachine_undo_console_ban() failed"
                                );
                        }
                    }
                    catch (Exception)
                    {
                        // Remember which console ids we failed on
                        foreach (DataRow row in consoleTables[i].Rows)
                        {
                            failedList.Add( ( (string) row["vc_console_id"]).ToUpper() );
                        }
                    }
                }
            }
            return failedList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\VerifyXbox360ConsoleIds.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// VerifyXbox360ConsoleIds.cs
//
// Implementation of VerifyXbox360ConsoleIds SOAP API for XMachine FD
//
// Jan-23-2011 - Initial Revision
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {

        [WebMethod] 
        public ConsoleIdResult[] VerifyXbox360ConsoleIds(
            string[] consoleIds
            )
        {
            HResult           hr               = HResult.S_OK;
            ConsoleIdResult[] consoleIdResults = new ConsoleIdResult[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( consoleIds, "consoleIds" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                consoleIds = Utilities.UniqueIds<string>(Array.ConvertAll<string,string>(consoleIds, (u => u.ToUpper())));
                consoleIdResults = VerifyXbox360ConsoleIdsInternal( consoleIds );

                return consoleIdResults;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                hr = XblException.GetHResult(e);
                throw;
            }
            finally
            {

                Xom.Log(
                    XomAreaName.log, "VerifyXbox360ConsoleIds|{0}|{1}|{2}|",
                    hr, consoleIds.Length, consoleIdResults.Length, string.Join("|", consoleIds )
                    );
            }
        }

        private static ConsoleIdResult[] VerifyXbox360ConsoleIdsInternal(
            string[] consoleIds
            )
        {
            HashSet<string>       uniqueIds        = new HashSet<string>();
            List<ConsoleIdResult> consoleIdResults = new List<ConsoleIdResult>();

            // Build list of unique console ids
            Utilities.UniqueAdd( consoleIds, uniqueIds );

            // Validate every console id
            foreach (string consoleId in uniqueIds)
            {
                ConsoleIdResult verifyResult = new ConsoleIdResult(
                    consoleId,
                    ConsoleIds.HasXbox360Checksum(consoleId) == true ? HResult.S_OK : HResult.E_FAIL
                    );
                consoleIdResults.Add( verifyResult );
            }
            return consoleIdResults.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\XMachine.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// XMachine.cs
//
// Implementation of XMachine SOAP Class for XMachine FD
//
// Jan-12-2011 - Initial Revision
//

using System;
using System.Web.Services;

namespace xonline.server.xmachine.fd
{
    [WebService(Namespace = "urn:schemas-xbox-com:machine-data")]
    public partial class XMachine
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\UnbanMachinePuids.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// UnbanMachinePuids.cs
//
// Implementation of UnbanMachinesPuids SOAP API for XMachine FD
//
// Jan-19-2011 - Initial Revision
// Jan-24-2011 - Split into WebMethod and Internal
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Web;
using System.Web.Services;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.xmachine.fd
{
    public partial class XMachine
    {
        [WebMethod]
        public MachinePuidResult[] UnbanMachinePuids(
            Puid[]   puids,
            HResult  reasonCode
        )
        {
            MachinePuidResult[] machinePuidResults = new MachinePuidResult[0];

            // Check the array for null or null elements. Can't do this in the 
            // try/finally block since the finally block assumes all the
            // elements are okay
            Utilities.CheckArray( puids, "machinePuids" );

            try
            {
                // Internal - only called on int interface
                CallSource.Check(VirtualInterface.xmachine_int);

                machinePuidResults = UnbanMachinePuidsImpl( puids, reasonCode );
                return machinePuidResults;
            }
            catch (Exception e)
            {
                if ((e is XRLExceptionWithoutEvent) == false)
                {
                    FrontEndApp.LogException(e);
                }
                throw;
            }
            finally
            {
                foreach (MachinePuidResult result in machinePuidResults)
                {
                    Xom.Log(
                        XomAreaName.log,
                        string.Join(
                            "|",
                            new string[] {
                                "UnbanMachinePuids",
                                result.MachinePuid.ToString(),
                                reasonCode.ToString(),
                                result.Result.ToString(),
                                HttpContext.Current.Request.UserHostAddress }
                            )
                        );
                }
            }
        }

        private MachinePuidResult[] UnbanMachinePuidsImpl(
            Puid[]   puids,
            HResult  reasonCode
            )
        {
            bool                    hasPcPuids      = false;
            HashSet<string>         failedIdsSet    = new HashSet<string>();
            HashSet<Puid>           failedPuidsSet  = new HashSet<Puid>();
            HashSet<Puid>           uniquePuidsSet  = new HashSet<Puid>();
            List<MachinePuidResult> banResultsList  = new List<MachinePuidResult>();
            List<Puid>              uniquePuidsList = new List<Puid>();
            MachinePuidInfo[]       machinePuidInfo = new MachinePuidInfo[0];
            Puid[]                  failedPuids     = new Puid[0];
            string[]                failedIds       = new string[0];

            //
            // Sanity Checks
            //    1 --- ReasonCode must be an HResult failure code or 0
            // 
            if (reasonCode.IsFailure() == false && reasonCode.IsOk() == false)
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_INVALID_REQUEST,
                    "Invalid ReasonCode: {0}", 
                    reasonCode
                    );    
            }

            //
            // Unique Puid list
            //                 
            puids = Utilities.UniqueIds<Puid>(puids);

            //
            // Sanity Check Machine Puids and determine if any PC puids are present
            // 
            hasPcPuids = Utilities.CheckForPcMachinePuids( puids, reasonCode, DateTime.MinValue, DateTime.MaxValue );

            //
            // Generate a duplicate free set of puids
            // 
            Utilities.UniqueAdd(puids, uniquePuidsSet, uniquePuidsList);

            //
            // Generate a list of of console ids. We will need
            // this when we reset the machine accounts
            // 
            try
            {
                machinePuidInfo = LookupConsoleIdsByMachinePuidsInternal( 
                    uniquePuidsList.ToArray() 
                    );
            }
            catch (Exception e)
            {
                HResult hr = XblException.GetHResult(e);

                return Array.ConvertAll<Puid,MachinePuidResult>(
                    puids,
                    ( u => new MachinePuidResult( u, hr ) )
                    );
            }

            //
            // If we have some PC machines, determine
            // the tokens that were used and unban them.
            // 
            // This will also unban all machines associated
            // with that token
            // 
            if (hasPcPuids == true)
            {
                byte[][]              pcTokens    = new byte[0][];
                PcTokenInfoInternal[] pcTokenList = new PcTokenInfoInternal[0];

                try
                {
                    //
                    // Convert the list of PC Puids into the complete list of 
                    // puids and tokens
                    // 
                    pcTokenList = LookupPcMachinePuidsByMachinePuidsInternal(
                        uniquePuidsList.ToArray()
                        );

                    //
                    // Determine a unique set of pc tokens
                    // 
                    HashSet<string> uniqueEncodedPcTokensSet = new HashSet<string>();
                    Utilities.UniqueAdd( 
                        Array.ConvertAll( pcTokenList, ( u => (string) u.EncodedHash ) ),
                        uniqueEncodedPcTokensSet
                        );

                    string[] encodedPcTokens = new string[uniqueEncodedPcTokensSet.Count];
                    uniqueEncodedPcTokensSet.CopyTo( encodedPcTokens );

                    //
                    // Convert back to a byte representation
                    // 
                    pcTokens = Array.ConvertAll(
                        encodedPcTokens,
                        ( u => (byte[]) Convert.FromBase64String( u ) )
                        );

                    //
                    // Look at each PC puid and make sure that it is 
                    // in the list of PCs to unban
                    // 
                    Utilities.UniqueAdd( 
                        Array.ConvertAll( pcTokenList, ( u => (Puid) u.MachinePuid ) ),
                        uniquePuidsSet,
                        uniquePuidsList
                        );
                }
                catch (Exception e)
                {
                    HResult hr = XblException.GetHResult(e);

                    return Array.ConvertAll<Puid,MachinePuidResult>(
                        uniquePuidsList.ToArray(),
                        ( u => new MachinePuidResult( u, hr ) )
                        );
                }

                //
                // Unban the tokens but remember which failed
                // 
                string[] failedEncodedTokens = BanPcTokensInternal(
                    pcTokens,
                    false
                    );

                //
                // Corrolate the failures back to Puids
                // 
                HashSet<string> failedEncodedTokensSet = new HashSet<string>();
                Utilities.UniqueAdd( failedEncodedTokens, failedEncodedTokensSet );

                foreach (PcTokenInfoInternal info in pcTokenList)
                {
                    if (failedPuidsSet.Contains(info.MachinePuid) == true)
                    {
                        continue;
                    }
                    if (failedEncodedTokensSet.Contains(info.EncodedHash) == true)
                    {
                        failedPuidsSet.Add(info.MachinePuid);
                    }
                }
            }

            //
            // Unban all the machines
            // 
            failedPuids = UnbanMachinePuidsInternal(
                uniquePuidsList.ToArray(),
                reasonCode
                );
            Utilities.UniqueAdd( failedPuids, failedPuidsSet );

            //
            // In order to deal with the possibility that an unbanned
            // machine also has a console ban against it, we need to 
            // reset all of the machine accounts as well
            // 
            failedPuids = ResetMachinePasswordDateByMachinePuidsInternal(
                uniquePuidsList.ToArray()
                );
            Utilities.UniqueAdd( failedPuids, failedPuidsSet );

            failedIds = ResetMachinePasswordByConsoleIdsInternal(
                Array.ConvertAll(
                    machinePuidInfo,
                    ( u => (string) u.ConsoleId )
                    )
                );
            Utilities.UniqueAdd( failedIds, failedIdsSet );

            //
            // Convert all the failed console ids back to machine puids
            // 
            foreach (MachinePuidInfo info in machinePuidInfo)
            {
                if (failedIdsSet.Contains(info.ConsoleId) == false)
                {
                    continue;
                }
                if (failedPuidsSet.Contains(info.MachinePuid) == false)
                {
                    failedPuidsSet.Add( info.MachinePuid );
                }
            }

            //
            // Build and return the outcome
            // 
            foreach (Puid puid in uniquePuidsSet)
            {
                MachinePuidResult banResult = new MachinePuidResult(
                    puid,
                    (failedPuidsSet.Contains( puid ) == false ? HResult.S_OK : HResult.E_FAIL)
                    );
                banResultsList.Add(banResult);
            }
            return banResultsList.ToArray();
        }

        private Puid[] UnbanMachinePuidsInternal(
            Puid[]   puids,
            HResult  reasonCode
            )
        {
            List<Puid> failedPuids = new List<Puid>();

            //
            // Use Webstore to update the relevant rows
            //
            using (WSClient _ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                HResult     hr         = HResult.S_OK;
                DataTable[] dataTables = Utilities.PuidsToDataTables(_ws, puids, true);

                //
                // Update records across all the partitions
                // 
                for (int i = 0; i < dataTables.Length; ++i)
                {
                    // Skip over partitions with no work
                    if (dataTables[i] == null)
                    {
                        continue;
                    }

                    // Build the parameters
                    _ws.ClearParameters();
                    _ws.StoredProc = "dbo.p_xmachine_undo_machine_ban";
                    _ws.PhysicalPartition = i;
                    _ws.Parameters.AddWithValue("@xmachine_machine_list", dataTables[i]);
                    _ws.AddParameter(ParamType.INPUT, "@i_reason_code", reasonCode);
                    _ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr );

                    // Execute
                    WstDataReader reader = null;
                    bool queryIsFailed = false;
                    try
                    {
                        reader = _ws.Execute();

                        // Check the return
                        hr = (uint) _ws.GetIntParameter("@RETVAL");
                        if (hr.IsFailure())
                        {
                            queryIsFailed = true;
                        }
                    }
                    catch (Exception e)
                    {
                        queryIsFailed = true;
                        Xom.Trace(
                            XomAreaName.xmachine,
                            LogLevel.L_WARNING,
                            "UnBanMachinePuidsInternal Exception: " + e.ToString()
                            );
                    }

                    if (queryIsFailed)
                    {
                        // If the whole query failed, add all of the puids to the failed list
                        foreach (DataRow row in dataTables[i].Rows)
                        {
                            failedPuids.Add( (Puid) (long) row["bi_machine_puid"] );
                        }
                    }

                    if (reader != null)
                    {
                        using (reader)
                        {
                            // First result set is a list of failed puids
                            while (reader.Read())
                            {
                                Puid machinePuid = (ulong) WSClient.GetInt64(reader, "bi_machine_puid");
                                if (!failedPuids.Contains(machinePuid))
                                {
                                    failedPuids.Add(machinePuid);
                                }
                            }
                        }
                    }
                }
            }
            return failedPuids.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\General.cs ===
using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1), Description("General tests for XMachine not particuraly related to any API.")]
    public class General: TestNode
    {
        [TestCase]
        public void UseClientForMultipleCalls()
        {
            ulong puid=MachineEditor.CreateNew(MachineType.Xbox360).Id;
            XMachineSoapClient client=new XMachineSoapClient();
            client.TestConnection("Hello");
            client.LookupConsoleIdsByMachinePuids(new ulong[]{puid});

            string ret=client.TestConnection("World");
            ValueCheck.Test("Second TestConnection call return", "World", ret);
        }
    } //class General
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\XMachineApp.cs ===
//
// Copyright (c) 2011 Microsoft Corporation
//
// XMachine FD Service
//
// XMachineApp.cs
//
// Implementation of XMachineApp Class for XMachine FD
//
// Jan-09-2011 - Initial Revision
//

using System;
using System.Web;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomIisInstallerAttribute( Interface.xmachine )]
[assembly: XomIisInstallerAttribute( Interface.xmachine_int )]
[assembly: ConfigAttribute(Component.xmachine)]

[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.xmachine)]

namespace xonline.server.xmachine.fd
{
    /// <summary>
    /// XMachine FD FrontEndApp Implementation
    /// </summary>
    public class XMachineApp : FrontEndApp
    {
        ///
        /// OnApplicationStart - called once when the front door starts up
        /// 
        protected override void OnApplicationStart()
        {
            Xom.Trace(
                XomAreaName.xmachine, 
                LogLevel.L_NORMAL, 
                "XMachine Front Door Started"
                );
        }

        ///
        /// Application_BeginRequest - called at the beginning of every request
        ///
        public override void Application_BeginRequest( object sender, EventArgs e )
        {
            Xom.Trace(
                XomAreaName.xmachine, 
                LogLevel.L_NORMAL, 
                "BeginRequest(" + HttpContext.Current.Request.RawUrl + ")"
                );

            // Call the base class
            base.Application_BeginRequest( sender, e );
        }

        ///
        /// Application_EndRequest - called at the end of every request
        /// 
        public override void Application_EndRequest( object sender, EventArgs e )
        {
            Xom.Trace(
                XomAreaName.xmachine, 
                LogLevel.L_NORMAL, 
                "EndRequest(" + HttpContext.Current.Request.RawUrl + "), " +
                MillisecondsElapsed.ToString() + " ms"
                );

            // Call the base class
            base.Application_EndRequest( sender, e);
        }

        ///
        /// Application_End - Called when application is shutting down.
        /// 
        public override void Application_End( object sender, EventArgs e )
        {
            Xom.Trace(
                XomAreaName.xmachine,
                LogLevel.L_NORMAL,
                "XMachine Front Door Terminated"
                );
            base.Application_End( sender, e );
        }
    }
} // xonline.server.xmachine.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\fd\XMachineMgmt.cs ===
/*
 * Copyright (c) 2011 Microsoft Corporation
 *
 * Xbox Machine Front-Door (xmachine)
 *
 * XMachineMgmt.cs
 *
 * Implementation of XMGMT apis
 *
 */

using System;

using xonline.common.mgmt;
using xonline.common.service;

[assembly: FrontEndAppInitialization(typeof(xonline.server.xmachine.fd.XMachineMgmt), "Init")]

namespace xonline.server.xmachine.fd
{
    public class XMachineMgmt
    {
        private static void Init()
        {
            // Register XMGMT
            XomControl.ControlRequestEvent += new
                XomControl.ControlRequestEventHandler(
                    XMachineMgmt.OnControlRequest
                    );
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            string cmd = args.Command.ToLower();
            switch (args.Command)
            {
            case "help":
                XomControlConnection.SendMessage(
                    "XMachine Server Help\r\n"+
                    "  <None Implemented>\r\n",
                    args.RequestId
                    );
                args.Handled = true;
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\BanConsoleIds.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Test for calling the BanConsoleIds. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class BanConsoleIds: TestNode
    {
        public static ConsoleIdResult MakeConsoleIdResult(string consoleId, uint result)
        {
            ConsoleIdResult r=new ConsoleIdResult();
            r.ConsoleId = consoleId;
            r.Result    = result;
            return r;
        }

        public static string ConsoleIdResultStringer(ConsoleIdResult result)
        {
            return "ConsoleIdResult(ConsoleId="+result.ConsoleId+" Result="+string.Format("0x{0:X}", result.Result)+")";
        }

        public static string ConsoleIdResultStringer(object result)
        {
            if (result is ConsoleIdResult)
            {
                return ConsoleIdResultStringer((ConsoleIdResult)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static bool ConsoleIdResultEquals(ConsoleIdResult left, ConsoleIdResult right)
        {
            return left.ConsoleId==right.ConsoleId &&
                left.Result==right.Result;
        }

        public static bool MachineBanHistoryEquals2S(MachineEditor.MachineBanHistory left, MachineEditor.MachineBanHistory right)
        {
            return left.MachineId==right.MachineId &&
                System.Math.Abs((left.ChangeTime-right.ChangeTime).TotalMilliseconds)<2000 &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<2000 &&
                (System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<2000 || (left.EndDate.Year==9999 && System.Math.Abs((left.EndDate-right.EndDate).TotalHours)<=24)) &&
                left.HashBucket==right.HashBucket;
        }

        public static bool ConsoleBanHistoryEquals2S(ConsoleBanEditor.ConsoleBanHistory left, ConsoleBanEditor.ConsoleBanHistory right)
        {
            return left.ConsoleId==right.ConsoleId &&
                System.Math.Abs((left.ChangeTime-right.ChangeTime).TotalMilliseconds)<2000 &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<2000 &&
                (System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<2000 || (left.EndDate.Year==9999 && System.Math.Abs((left.EndDate-right.EndDate).TotalHours)<=24)) &&
                left.HashBucket==right.HashBucket;
        }

        public static void VerifyOneMachineOneConsoleBanRow(string cid, ulong puid, uint reason, System.DateTime startDate)
        {
            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[]{new ConsoleBanEditor.ConsoleBanStatus(cid, unchecked((int)reason), startDate)};
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);

            MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)reason), startDate, System.DateTime.MaxValue)};
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
        }

        public static ConsoleIdResult[] BanConsoleIdsVerbose(string []consoleList, uint reasonCode, DateTime banStart)
        {
            Global.RO.Debug("Calling BanConsoleIds: ConsoleList={"+StringUtils.MakeCommaSeparatedList(consoleList)+"}, ReasonCode="+string.Format("0x{0:X}",reasonCode)+" BanStart="+banStart);
            ConsoleIdResult[] ret=new XMachineSoapClient().BanConsoleIds(consoleList, reasonCode, banStart);
            Global.RO.Debug("BanConsoleIds returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", ConsoleIdResultStringer));
            return ret;
        }

        // -----

        [TestGroup]
        public class Xbox360: TestNode
        {
            [TestCase, Description("Creates a console, calls ban on it, then verifies the tables."), BVT]
            public void BanOneExisting()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call API and verify return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, now);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, now);
            }

            [TestCase, Description("Calls ban for a valid console id that hasn't been created yet, then verifies the tables."), BVT]
            public void BanOneNotExisting()
            {
                //create machine
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                //call API and verify return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{cid}, 0x80000001, now);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(cid, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[]{new ConsoleBanEditor.ConsoleBanStatus(cid, unchecked((int)0x80000001), now)};
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);

                ValueCheck.Test("MachinePuid exists", 0, UodbWS.ExecuteSQLSelectCount("select count(*) from t_machines where vc_serial_num='"+cid+"'"));
            }

            [TestCase, Description("Creates a console, calls ban on it explicitely as uppercase, then verifies the tables.")]
            public void BanOneUppercase()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call API and verify return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId.ToUpper()}, 0x80000001, now);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId.ToUpper(), 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, now);
            }

            [TestCase, Description("Creates a console, calls ban on it explicitely as lowercase, then verifies the tables.")]
            public void BanOneLowercase()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call API and verify return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId.ToLower()}, 0x80000001, now);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId.ToUpper(), 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer); //NOTE: We expect all return values to be upper case.

                //verify DB
                VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, now);
            }

            [TestCase, Description("Creates a console, calls ban on it and a non-existing but valid one, then verifies the tables.")]
            public void MixedExistingAndNonExisting()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

                //call API and verify return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId, cid}, 0x80000001, now);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0), MakeConsoleIdResult(cid, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, now);

                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[]{new ConsoleBanEditor.ConsoleBanStatus(cid, unchecked((int)0x80000001), now)};
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);
            }

            [TestCase, Description("Creates multiple machines, calls ban on them, then verifies the tables.")]
            [CompoundCase("7", 7)]
            [CompoundCase("Max", 100)]
            public void BanMany(TestNode self)
            {
                int numberToBan=(int)self.MyValues[0];

                //create machines
                List<MachineEditor> machsToBan=new List<MachineEditor>();
                List<string> cidsToBan=new List<string>();

                for (int i=0; i<numberToBan; ++i)
                {
                    machsToBan.Add(MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()));
                    cidsToBan.Add(machsToBan[i].ConsoleId);
                }

                MachineEditor machNotBanned=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the ban api and verify the return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(cidsToBan.ToArray(), 0x80000001, now);

                ConsoleIdResult []expectedRet=new ConsoleIdResult[machsToBan.Count];
                for (int i=0; i<machsToBan.Count; ++i)
                {
                    expectedRet[i]=MakeConsoleIdResult(machsToBan[i].ConsoleId, 0);
                }

                ValueCheck.TestAllUnordered("BanConsoleIds return", expectedRet, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify the db
                foreach (MachineEditor machBanned in machsToBan)
                {
                    VerifyOneMachineOneConsoleBanRow(machBanned.ConsoleId, machBanned.Id, 0x80000001, now);
                }

                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBansForNotBanned=ConsoleBanEditor.FromConsoleId(machNotBanned.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBansForNotBanned=new ConsoleBanEditor.ConsoleBanStatus[0];
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBansForNotBanned, actualConsoleBansForNotBanned);

                MachineEditor.MachineBanStatus []machineBansForNotBanned=machNotBanned.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBansForNotBanned=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB for a NOT banned machine", expectedMachineBansForNotBanned, machineBansForNotBanned);
            }

            [TestCase, Description("Attempt to ban more consoles than the API can handle at once.")]
            public void BanTooMany()
            {
                //create machines
                List<string> cidsToBan=new List<string>();

                Global.RO.Debug("Creating 500 machines...");
                for (int i=0; i<500; ++i)
                {
                    MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
                    cidsToBan.Add(mach.ConsoleId);
                }

                //call the api and verify the return
                System.DateTime now=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpecting404(delegate{BanConsoleIdsVerbose(cidsToBan.ToArray(), 0x80000001, now);});

                //verify the db
                foreach (string cid in cidsToBan)
                {
                    ConsoleBanEditor.ConsoleBanStatus []actualConsoleBans=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
                    ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans=new ConsoleBanEditor.ConsoleBanStatus[0];
                    ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans, actualConsoleBans);
                }
            }

            [TestCase, Description("Calls ban on no consoles.")]
            public void BanNone()
            {
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[0], 0x80000001, now);

                ValueCheck.TestAllUnordered("Values returned", new ConsoleIdResult[0], ret, ConsoleIdResultEquals, ConsoleIdResultStringer);
            }

            [TestCase, Description("Calls ban passing null for console ID.")]
            public void BanNullConsoleIDsParameter()
            {
                System.DateTime now=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanConsoleIdsVerbose(null, 0x80000001, now);}, "Null array: consoleIds");
            }

            [TestCase, Description("Valid console IDs, but one entry in array is null.")]
            public void BanNullConsoleIdInArray()
            {
                //create machine
                MachineEditor mach0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the api and verify the return
                System.DateTime now=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanConsoleIdsVerbose(new string[]{mach0.ConsoleId, null, mach1.ConsoleId}, 0x80000001, now);}, "Null element in: consoleIds");

                //verify the db
                foreach (MachineEditor mach in new MachineEditor[]{mach0, mach1})
                {
                    ConsoleBanEditor.ConsoleBanStatus []actualConsoleBans=ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
                    ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans=new ConsoleBanEditor.ConsoleBanStatus[0];
                    ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans, actualConsoleBans);
                }
            }

            [TestCase, Description("Ban a list of mostly invalid console IDs with one valid one mixed in.")]
            public void InvalidConsoleIDs()
            {
                //create one valid machine and some invalid strings for others
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                string totallyInvalid0="";
                string totallyInvalid1=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomString(15);
                string totallyInvalid2=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomString(25);
                string totallyInvalid3="';drop table t_machine_banned_console_id; select '";
                string almostValid0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()).ConsoleId;
                almostValid0=almostValid0.Substring(0, 14)+(almostValid0[14]=='0'?"9":"0"); // F@$%ing C# doesn't allow this: almostValid0[15]=(almostValid0[15]=='0'?'9':'0');
                string almostValid1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()).ConsoleId+"X";
                string almostValid2=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine()).ConsoleId;
                almostValid2=almostValid2.Substring(0, 2)+" "+almostValid2.Substring(3,12); //F@$%ing C# doesn't allow this: almostValid2[2]=' ';
                string []cids=new string[]{totallyInvalid0, totallyInvalid1, totallyInvalid2, totallyInvalid3, mach.ConsoleId, almostValid0, almostValid1, almostValid2};

                //call the api and verify the return
                System.DateTime now=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanConsoleIdsVerbose(cids, 0x80000001, now);}, "Invalid ConsoleId");

                //verify the db
                string []expectedNoEntries=new string[]{totallyInvalid0, totallyInvalid1, totallyInvalid2, totallyInvalid3, almostValid0, almostValid1, almostValid2, mach.ConsoleId};
                foreach (string cid in expectedNoEntries)
                {
                    ConsoleBanEditor.ConsoleBanStatus []actualConsoleBans0=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
                    ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans0=new ConsoleBanEditor.ConsoleBanStatus[0];
                    ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans0, actualConsoleBans0);
                }
            }

            [TestCase, Description("Creates a machine, calls ban on it with an invalid code.")]
            public void InvalidBanCode()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 13, banStart);}, "Invalid ReasonCode");

                //verify the db
                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBans=ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans=new ConsoleBanEditor.ConsoleBanStatus[0];
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans, actualConsoleBans);
            }

            [TestCase, Description("Same console ID is passed twice in the parameter.")]
            public void DuplicateConsoleIDsInParameter()
            {
                //create machine
                MachineEditor mach0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the api and verify the return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach0.ConsoleId, mach0.ConsoleId.ToUpper(), mach0.ConsoleId.ToLower(), mach1.ConsoleId}, 0x80000001, now);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach0.ConsoleId, 0), MakeConsoleIdResult(mach1.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify the db
                foreach (MachineEditor mach in new MachineEditor[]{mach0, mach1})
                {
                    VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, now);
                }
            }

            [TestCase, Description("Re-ban a machine for the same reason but various different time spans.")]
            [CompoundCase("Past",    -5)]
            [CompoundCase("Present", 0)]
            [CompoundCase("Future",  +5)]
            public void BanOneTwiceSameReasonVariousTimes(TestNode self)
            {
                //figure out the dates
                int offset=(int)self.MyValues[0];
                System.DateTime ban1Start=System.DateTime.UtcNow;
                System.DateTime ban2Start=ban1Start+new System.TimeSpan(offset, 0, 0, 0);

                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the API with the first time
                BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, ban1Start);

                //call the API with the second time and verify return
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, ban2Start);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify the db
                System.DateTime expectedStartTime=ban1Start;
                if (ban2Start<ban1Start)
                {
                    expectedStartTime=ban2Start;
                }

                VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, expectedStartTime);
            }

            [TestCase, Description("Re-ban a batch of machines for the same reason but different times than their original ban.")]
            public void BanSeveralTwiceSameReasonDifferentTimes()
            {
                //create machines
                MachineEditor mach0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach2=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //ban them the first time
                System.DateTime now=System.DateTime.UtcNow;
                BanConsoleIdsVerbose(new string[]{mach0.ConsoleId}, 0x80000001, now-new System.TimeSpan(5, 0, 0, 0));
                BanConsoleIdsVerbose(new string[]{mach1.ConsoleId}, 0x80000001, now);
                BanConsoleIdsVerbose(new string[]{mach2.ConsoleId}, 0x80000001, now+new System.TimeSpan(5, 0, 0, 0));

                //ban them the second time and verify the return
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach0.ConsoleId, mach1.ConsoleId, mach2.ConsoleId}, 0x80000001, now);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach0.ConsoleId, 0), MakeConsoleIdResult(mach1.ConsoleId, 0), MakeConsoleIdResult(mach2.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify console bans in the db
                ConsoleBanEditor.ConsoleBanStatus []consoleBans0=ConsoleBanEditor.FromConsoleId(mach0.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []consoleBans1=ConsoleBanEditor.FromConsoleId(mach1.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []consoleBans2=ConsoleBanEditor.FromConsoleId(mach2.ConsoleId).GetAllConsoleBans();

                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans0=new ConsoleBanEditor.ConsoleBanStatus[]{new ConsoleBanEditor.ConsoleBanStatus(mach0.ConsoleId, unchecked((int)0x80000001), now-new System.TimeSpan(5, 0, 0, 0))};
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans1=new ConsoleBanEditor.ConsoleBanStatus[]{new ConsoleBanEditor.ConsoleBanStatus(mach1.ConsoleId, unchecked((int)0x80000001), now)};
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans2=new ConsoleBanEditor.ConsoleBanStatus[]{new ConsoleBanEditor.ConsoleBanStatus(mach2.ConsoleId, unchecked((int)0x80000001), now)};

                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans0, consoleBans0);
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans1, consoleBans1);
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans2, consoleBans2);

                //verify machine bans in the db
                MachineEditor.MachineBanStatus []machineBans0=mach0.GetAllMachineBans();
                MachineEditor.MachineBanStatus []machineBans1=mach1.GetAllMachineBans();
                MachineEditor.MachineBanStatus []machineBans2=mach2.GetAllMachineBans();

                MachineEditor.MachineBanStatus []expectedMachineBans0=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach0.Id, unchecked((int)0x80000001), now-new System.TimeSpan(5, 0, 0, 0), System.DateTime.MaxValue)};
                MachineEditor.MachineBanStatus []expectedMachineBans1=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach1.Id, unchecked((int)0x80000001), now, System.DateTime.MaxValue)};
                MachineEditor.MachineBanStatus []expectedMachineBans2=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach2.Id, unchecked((int)0x80000001), now, System.DateTime.MaxValue)};

                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans0, machineBans0);
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans1, machineBans1);
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans2, machineBans2);
            }

            [TestCase, Description("Creates a machine, calls ban on it with a past date, then verifies the tables.")]
            public void BanPast()
            {
                System.DateTime startDate=System.DateTime.UtcNow+new System.TimeSpan(-10, 0, 0, 0);

                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the ban api and verify the return
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, startDate);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify the db
                VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, startDate);
            }

            [TestCase, Description("Creates a machine, calls ban on it with an invalid date.")]
            public void InvalidDate()
            {
                System.DateTime banStart=System.DateTime.MinValue; //not convertible to a SQL time

                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the ban api and verify the return
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, banStart);}, "Invalid BanStart");

                //verify the db
                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBans0=ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans0=new ConsoleBanEditor.ConsoleBanStatus[0];
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans0, actualConsoleBans0);

                MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Calls ban on one console several times with different reasons.")]
            public void BanOneDifferentReasons()
            {
                //create machine
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call API several times
                System.DateTime ban0Start=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0xFFFF0001, ban0Start);
                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                System.DateTime ban1Start=System.DateTime.UtcNow;
                ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0xFFFF0002, ban1Start);
                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                System.DateTime ban2Start=System.DateTime.UtcNow;
                ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0xFFFF0003, ban2Start);
                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBans=ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans=new ConsoleBanEditor.ConsoleBanStatus[]{
                    new ConsoleBanEditor.ConsoleBanStatus(mach.ConsoleId, unchecked((int)0xFFFF0001), ban0Start),
                    new ConsoleBanEditor.ConsoleBanStatus(mach.ConsoleId, unchecked((int)0xFFFF0002), ban1Start),
                    new ConsoleBanEditor.ConsoleBanStatus(mach.ConsoleId, unchecked((int)0xFFFF0003), ban2Start)};
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans, actualConsoleBans);

                MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0xFFFF0001), ban0Start, System.DateTime.MaxValue),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0xFFFF0002), ban1Start, System.DateTime.MaxValue),
                    new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0xFFFF0003), ban2Start, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Creates several machines, calls ban on them a couple times for different reasons, then verifies the tables.")]
            public void BanSeveralDifferentReasons()
            {
                //create machines
                MachineEditor mach0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach2=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //call the ban the first time on the machines
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach0.ConsoleId}, 0xFFFF0001, now+new System.TimeSpan(5, 0, 0, 0));
                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach0.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                ret=BanConsoleIdsVerbose(new string[]{mach1.ConsoleId}, 0xFFFF0002, now);
                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach1.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //call the ban api on all the machines and verify return
                ret=BanConsoleIdsVerbose(new string[]{mach0.ConsoleId, mach1.ConsoleId, mach2.ConsoleId}, 0xFFFF0003, now);
                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach0.ConsoleId, 0), MakeConsoleIdResult(mach1.ConsoleId, 0), MakeConsoleIdResult(mach2.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify the db for console bans
                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBans0=ConsoleBanEditor.FromConsoleId(mach0.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBans1=ConsoleBanEditor.FromConsoleId(mach1.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBans2=ConsoleBanEditor.FromConsoleId(mach2.ConsoleId).GetAllConsoleBans();

                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans0=new ConsoleBanEditor.ConsoleBanStatus[]{
                    new ConsoleBanEditor.ConsoleBanStatus(mach0.ConsoleId, unchecked((int)0xFFFF0001), now+new System.TimeSpan(5, 0, 0, 0)),
                    new ConsoleBanEditor.ConsoleBanStatus(mach0.ConsoleId, unchecked((int)0xFFFF0003), now)};
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans1=new ConsoleBanEditor.ConsoleBanStatus[]{
                    new ConsoleBanEditor.ConsoleBanStatus(mach1.ConsoleId, unchecked((int)0xFFFF0002), now),
                    new ConsoleBanEditor.ConsoleBanStatus(mach1.ConsoleId, unchecked((int)0xFFFF0003), now)};
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBans2=new ConsoleBanEditor.ConsoleBanStatus[]{
                    new ConsoleBanEditor.ConsoleBanStatus(mach2.ConsoleId, unchecked((int)0xFFFF0003), now)};

                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans0, actualConsoleBans0);
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans1, actualConsoleBans1);
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBans2, actualConsoleBans2);

                //verify the db for machine bans
                MachineEditor.MachineBanStatus []actualMachineBans0=mach0.GetAllMachineBans();
                MachineEditor.MachineBanStatus []actualMachineBans1=mach1.GetAllMachineBans();
                MachineEditor.MachineBanStatus []actualMachineBans2=mach2.GetAllMachineBans();

                MachineEditor.MachineBanStatus []expectedMachineBans0=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach0.Id, unchecked((int)0xFFFF0001), now+new System.TimeSpan(5, 0, 0, 0), System.DateTime.MaxValue),
                    new MachineEditor.MachineBanStatus(mach0.Id, unchecked((int)0xFFFF0003), now, System.DateTime.MaxValue)};
                MachineEditor.MachineBanStatus []expectedMachineBans1=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach1.Id, unchecked((int)0xFFFF0002), now, System.DateTime.MaxValue),
                    new MachineEditor.MachineBanStatus(mach1.Id, unchecked((int)0xFFFF0003), now, System.DateTime.MaxValue)};
                MachineEditor.MachineBanStatus []expectedMachineBans2=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach2.Id, unchecked((int)0xFFFF0003), now, System.DateTime.MaxValue)};

                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans0, actualMachineBans0);
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans1, actualMachineBans1);
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans2, actualMachineBans2);
            }

            [TestCase, Description("Ban an old-style xbox360 machine that has not yet been migrated to the new name lookup table.")]
            public void LegacyMachine()
            {
                //create machine
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();

                //call the api and verify the return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, now);
                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify the db
                VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, now);
            }

            [TestCase, Description("Creates two consoles that share the same console id then call ban on the console id, then verifies the tables.")]
            public void BanDuplicateConsole()
            {
                //create machines
                MachineEditor machA=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor machB=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(machA.ConsoleId));

                //call API and verify return
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{machA.ConsoleId}, 0x80000001, now);
                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(machA.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyOneMachineOneConsoleBanRow(machA.ConsoleId, machA.Id, 0x80000001, now);
                VerifyOneMachineOneConsoleBanRow(machB.ConsoleId, machB.Id, 0x80000001, now);
            }

            [TestCase, Description("Creates a console, adds a console ban row but not a machine ban row, then calls ban on it.")]
            public void BanOneWithExistingConsoleBanRow()
            {
                //create machine and add the row
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime now=System.DateTime.UtcNow;
                ConsoleBanEditor.FromConsoleId(mach.ConsoleId).BanConsole(unchecked((int)0x80000001), now);

                //call API and verify return
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, now);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, now);
            }

            [TestCase, Description("Creates a console, adds a machine ban row but not a console ban row, then calls ban on it.")]
            public void BanOneWithExistingMachineBanRow()
            {
                //create machine and add the row
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime now=System.DateTime.UtcNow;
                mach.BanMachine(unchecked((int)0x80000001), now, System.DateTime.MaxValue);

                //call API and verify return
                ConsoleIdResult []ret=BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, now);

                ValueCheck.TestAllUnordered("BanConsoleIds return", new ConsoleIdResult[]{MakeConsoleIdResult(mach.ConsoleId, 0)}, ret, ConsoleIdResultEquals, ConsoleIdResultStringer);

                //verify DB
                VerifyOneMachineOneConsoleBanRow(mach.ConsoleId, mach.Id, 0x80000001, now);
            }

            [TestCase, Description("Verify the history tables are being written to correctly.")]
            public void History()
            {
                //create machine
                ulong puid0=XMachineTestUtil.CreateXbox360Machine();
                string cid0=MachineEditor.FromId(puid0).ConsoleId;
                ulong puid1=XMachineTestUtil.CreateXbox360Machine();
                string cid1=MachineEditor.FromId(puid1).ConsoleId;

                //call the ban api on both for reason 1
                System.DateTime ban0Start=System.DateTime.UtcNow;
                System.DateTime ban0End=System.DateTime.MaxValue;
                BanConsoleIdsVerbose(new string[]{cid0, cid1}, 0x80000001, ban0Start);
                System.DateTime ban0ChangeTime=System.DateTime.UtcNow;
                System.Threading.Thread.Sleep(3000);

                //call the ban api on one again for reason 1, later date
                System.DateTime ban1Start=System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0);
                System.DateTime ban1End=System.DateTime.MaxValue;
                BanConsoleIdsVerbose(new string[]{cid0}, 0x80000001, ban1Start);
                System.DateTime ban1ChangeTime=System.DateTime.UtcNow;
                System.Threading.Thread.Sleep(3000);

                //call the ban api on the other for reason 2
                System.DateTime ban2Start=System.DateTime.UtcNow;
                System.DateTime ban2End=System.DateTime.MaxValue;
                BanConsoleIdsVerbose(new string[]{cid1}, 0x80000002, ban2Start);
                System.DateTime ban2ChangeTime=System.DateTime.UtcNow;

                //verify the db for machine0
                MachineEditor.MachineBanHistory []actualMachineHistories0=MachineEditor.FromId(puid0).GetAllMachineBanHistories();
                MachineEditor.MachineBanHistory []expectedMachineHistories0=new MachineEditor.MachineBanHistory[]{
                    new MachineEditor.MachineBanHistory(puid0, ban0ChangeTime, unchecked((int)0x80000001), ban0Start, ban0End),
                    new MachineEditor.MachineBanHistory(puid0, ban1ChangeTime, unchecked((int)0x80000001), ban1Start, ban1End)};
                ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedMachineHistories0, actualMachineHistories0, MachineBanHistoryEquals2S);

                ConsoleBanEditor.ConsoleBanHistory []actualConsoleHistories0=ConsoleBanEditor.FromConsoleId(cid0).GetAllConsoleBanHistories();
                ConsoleBanEditor.ConsoleBanHistory []expectedConsoleHistories0=new ConsoleBanEditor.ConsoleBanHistory[]{
                    new ConsoleBanEditor.ConsoleBanHistory(cid0, ban0ChangeTime, unchecked((int)0x80000001), ban0Start, ban0End),
                    new ConsoleBanEditor.ConsoleBanHistory(cid0, ban1ChangeTime, unchecked((int)0x80000001), ban1Start, ban1End)};
                ValueCheck.TestAllUnordered("ConsoleBanHistory rows", expectedConsoleHistories0, actualConsoleHistories0, ConsoleBanHistoryEquals2S);

                //verify the db for machine1
                MachineEditor.MachineBanHistory []actualMachineHistories1=MachineEditor.FromId(puid1).GetAllMachineBanHistories();
                MachineEditor.MachineBanHistory []expectedMachineHistories1=new MachineEditor.MachineBanHistory[]{
                    new MachineEditor.MachineBanHistory(puid1, ban0ChangeTime, unchecked((int)0x80000001), ban0Start, ban0End),
                    new MachineEditor.MachineBanHistory(puid1, ban2ChangeTime, unchecked((int)0x80000002), ban2Start, ban2End)};
                ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedMachineHistories1, actualMachineHistories1, MachineBanHistoryEquals2S);

                ConsoleBanEditor.ConsoleBanHistory []actualConsoleHistories1=ConsoleBanEditor.FromConsoleId(cid1).GetAllConsoleBanHistories();
                ConsoleBanEditor.ConsoleBanHistory []expectedConsoleHistories1=new ConsoleBanEditor.ConsoleBanHistory[]{
                    new ConsoleBanEditor.ConsoleBanHistory(cid1, ban0ChangeTime, unchecked((int)0x80000001), ban0Start, ban0End),
                    new ConsoleBanEditor.ConsoleBanHistory(cid1, ban2ChangeTime, unchecked((int)0x80000002), ban2Start, ban2End)};
                ValueCheck.TestAllUnordered("ConsoleBanHistory rows", expectedConsoleHistories1, actualConsoleHistories1, ConsoleBanHistoryEquals2S);
            }
        }; //class Xbox360

        [TestCase, Description("Attempt to ban a PC console ID.  It should not work.")]
        public void PcConsoleId()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);
            string cid=MachineEditor.FromId(puid).ConsoleId;

            //call the ban api and verify the return
            System.DateTime banStart=System.DateTime.UtcNow;
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanConsoleIdsVerbose(new string[]{cid}, 0x8015190D, banStart);}, "Invalid Non-Xbox360 ConsoleId: PC.");

            //verify the db
            BanPcTokens.VerifyNotBanned(puid, voucherHash);
        }

        [TestCase, Description("Attempt to ban a Phone console ID.  It should not work.")]
        public void PhoneConsoleId()
        {
            //create machine
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            string cid=MachineEditor.FromId(puid).ConsoleId;

            //call the ban api and verify the return
            System.DateTime banStart=System.DateTime.UtcNow;
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanConsoleIdsVerbose(new string[]{cid}, 0x8015190D, banStart);}, "Invalid Non-Xbox360 ConsoleId: WM.");

            //verify the db
            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);

            MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\BanPcTokens.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Test for calling the BanPcTokens. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class BanPcTokens: TestNode
    {
        public static PcTokenBanResult MakePcTokenBanResult(byte []voucherHash, uint result)
        {
            PcTokenBanResult r=new PcTokenBanResult();
            r.VoucherHash=voucherHash;
            r.Result=result;
            return r;
        }

        public static string PcTokenBanResultStringer(PcTokenBanResult result)
        {
            return "PcTokenBanResult(VoucherHash=0x"+Hexer.tohex(result.VoucherHash)+" Result="+string.Format("0x{0:X}", result.Result)+")";
        }

        public static string PcTokenBanResultStringer(object result)
        {
            if (result is PcTokenBanResult)
            {
                return PcTokenBanResultStringer((PcTokenBanResult)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static string ByteArrayStringer(byte[] ba)
        {
            return "0x"+Hexer.tohex(ba);
        }

        public static string ByteArrayStringer(object ba)
        {
            if (ba is byte[])
            {
                return ByteArrayStringer((byte[])ba);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(ba);
            }
        }

        public static bool PcTokenBanResultEquals(PcTokenBanResult left, PcTokenBanResult right)
        {
            if (left.Result!=right.Result)
            {
                return false;
            }

            if (left.VoucherHash.Length!=right.VoucherHash.Length)
            {
                return false;
            }

            for (int i=0; i<left.VoucherHash.Length; ++i)
            {
                if (left.VoucherHash[i]!=right.VoucherHash[i])
                {
                    return false;
                }
            }

            return true;
        }

        public static bool MachineBanHistoryEquals2S(MachineEditor.MachineBanHistory left, MachineEditor.MachineBanHistory right)
        {
            return left.MachineId==right.MachineId &&
                System.Math.Abs((left.ChangeTime-right.ChangeTime).TotalMilliseconds)<2000 &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<2000 &&
                (System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<2000 || (left.EndDate.Year==9999 && System.Math.Abs((left.EndDate-right.EndDate).TotalHours)<=24)) &&
                left.HashBucket==right.HashBucket;
        }

        public static void VerifyNotBanned(ulong puid, byte []voucherHash)
        {
            MachineEditor mach=MachineEditor.FromId(puid);

            MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);

            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);

            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucher hash 0x"+Hexer.tohex(voucherHash), 0, ve.Status); //0=active, 1=disabled, 2=banned
        }

        public static void VerifySimpleBanRows(ulong puid, byte []voucherHash)
        {
            MachineEditor mach=MachineEditor.FromId(puid);

            //there should be one machine ban row, no console ban row, and the voucher status should be banned
            MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue)};
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);

            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);

            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucher hash 0x"+Hexer.tohex(voucherHash), 2, ve.Status); //0=active, 1=disabled, 2=banned
        }

        //same as default .Equals, but this allows for 5 second time differences rather than 10ms.
        public static bool MachineBanStatusEqualsLeniently(MachineEditor.MachineBanStatus left, MachineEditor.MachineBanStatus right)
        {
            return left.MachineId==right.MachineId &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<DATE_COMPARISON_LENIENCY_MS &&
                System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<DATE_COMPARISON_LENIENCY_MS &&
                left.HashBucket==right.HashBucket;
        }

        const int DATE_COMPARISON_LENIENCY_MS=5000;
        const ulong PANORAMA_VOUCHER_OFFER_ID=0x585207D10FF00001;
        const string LIMITED_PC_VOUCHER="#############################";

        public static PcTokenBanResult[] BanPcTokensVerbose(byte [][]tokenHashes)
        {
            Global.RO.Debug("Calling BanPcTokens: VoucherHashes={"+StringUtils.MakeDeliminatorSeparatedList(tokenHashes, ", ", ByteArrayStringer)+"}");
            PcTokenBanResult[] ret=new XMachineSoapClient().BanPcTokens(tokenHashes);
            Global.RO.Debug("BanPcTokens returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", PcTokenBanResultStringer));
            return ret;
        }

        // -----

        [TestCase, Description("Ban a PC voucher that has one machine created from it."), BVT]
        public void BanOne()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify return
            PcTokenBanResult []ret=BanPcTokensVerbose(new byte[][]{voucherHash});

            ValueCheck.TestAllUnordered("BanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VerifySimpleBanRows(puid, voucherHash);
        }

        [TestCase, Description("Ban a PC token that doesn't have any machines created from it.")]
        public void BanTokenWithoutMachines()
        {
            //create voucher
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);

            //call api and verify return
            PcTokenBanResult []ret=BanPcTokensVerbose(new byte[][]{voucherHash});

            ValueCheck.TestAllUnordered("BanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucher hash 0x"+Hexer.tohex(voucherHash), 2, ve.Status); //0=active, 1=disabled, 2=banned
        }

        [TestCase, Description("Ban a PC voucher that has several machines created from it.")]
        public void BanTokenWithSeveralMachines()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid0=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puid1=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puid2=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify return
            PcTokenBanResult []ret=BanPcTokensVerbose(new byte[][]{voucherHash});

            ValueCheck.TestAllUnordered("BanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VerifySimpleBanRows(puid0, voucherHash);
            VerifySimpleBanRows(puid1, voucherHash);
            VerifySimpleBanRows(puid2, voucherHash);
        }

        [TestCase, Description("Ban a PC voucher that has already been banned.")]
        public void BanTwice()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            //first ban
            BanPcTokensVerbose(new byte[][]{voucherHash});

            //call api to ban again and verify return
            PcTokenBanResult []ret=BanPcTokensVerbose(new byte[][]{voucherHash});

            ValueCheck.TestAllUnordered("BanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VerifySimpleBanRows(puid, voucherHash);
        }

        [TestCase, Description("Ban multiple voucher hashes at once.")]
        [CompoundCase("7", 7)]
        [CompoundCase("Max", 100)]
        public void BanMultiple(TestNode self)
        {
            //create vouchers and machines.  we do this directly here because hitting passport for 100 tickets is not desirable.
            int createCount=(int)self.MyValues[0];

            string []vouchers=new string[createCount];
            byte [][]voucherHashes=new byte [createCount][];
            ulong []puids=new ulong[createCount];

            for (int i=0; i<createCount; ++i)
            {
                vouchers[i]=XMachineTestUtil.CreateUnlimitedPCVoucher();
                voucherHashes[i]=TokendbWS.GetHashForPanoramaVoucher(vouchers[i]);
                puids[i]=MachineEditor.CreateOrUseExistingPCName(vouchers[i], (ulong)i, MachineEditor.GetCachedPassportId()).Id;
            }

            //call api and verify
            PcTokenBanResult []ret=BanPcTokensVerbose(voucherHashes);

            PcTokenBanResult []expectedRet=new PcTokenBanResult[createCount];
            for (int i=0; i<createCount; ++i)
            {
                expectedRet[i]=MakePcTokenBanResult(voucherHashes[i], 0);
            }

            ValueCheck.TestAllUnordered("BanPcTokens return", expectedRet, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            for (int i=0; i<createCount; ++i)
            {
                VerifySimpleBanRows(puids[i], voucherHashes[i]);
            }
        }

        [TestCase, Description("Attempt to ban more than the API can handle at once.")]
        public void BanTooMany()
        {
            //create vouchers
            string []vouchers=new string[500];
            byte [][]voucherHashes=new byte [500][];

            Global.RO.Debug("Creating 500 machines...");
            for (int i=0; i<500; ++i)
            {
                vouchers[i]=XMachineTestUtil.CreateUnlimitedPCVoucher();
                voucherHashes[i]=TokendbWS.GetHashForPanoramaVoucher(vouchers[i]);
            }

            //call the ban api and verify the return
            XMachineTestUtil.ExecuteCallExpecting404(delegate{BanPcTokensVerbose(voucherHashes);});
        }

        [TestCase, Description("Ban no PC vouchers.")]
        public void BanNone()
        {
            //call api and verify return
            PcTokenBanResult []ret=BanPcTokensVerbose(new byte[][]{});

            ValueCheck.TestAllUnordered("BanPcTokens return", new PcTokenBanResult[0], ret, PcTokenBanResultEquals, PcTokenBanResultStringer);
        }

        [TestCase, Description("Attempt to ban a voucher that doesn't exist.")]
        public void VoucherDoesNotExist()
        {
            //create voucher
            string voucher="XXYYZ-12345-WOOPS-NOTTT-EXIST";
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);

            //call api and verify return
            PcTokenBanResult []ret=BanPcTokensVerbose(new byte[][]{voucherHash});

            ValueCheck.TestAllUnordered("BanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0x80004005)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Voucher exists now", false, ve.Exists);
        }

        [TestCase, Description("Ban a PC voucher with one byte missing that has one machine created from it.")]
        public void VoucherTooShort()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify return
            byte []badVoucherHash=new byte[19];
            System.Array.Copy(voucherHash, badVoucherHash, 19);

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanPcTokensVerbose(new byte[][]{badVoucherHash});}, "Token Hashes must be 20 bytes long");

            //verify db
            VerifyNotBanned(puid, voucherHash);
        }

        [TestCase, Description("Ban a PC voucher with one byte extra that has one machine created from it.")]
        public void VoucherTooLong()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify return
            byte []badVoucherHash=new byte[21];
            System.Array.Copy(voucherHash, badVoucherHash, 20);

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanPcTokensVerbose(new byte[][]{badVoucherHash});}, "Token Hashes must be 20 bytes long");

            //verify db
            VerifyNotBanned(puid, voucherHash);
        }

        [TestCase, Description("Ban a PC voucher with one byte wrong that has one machine created from it.")]
        [CompoundCase("Start", 0)]
        [CompoundCase("End", 19)]
        public void VoucherBadByte(TestNode self)
        {
            int byteToTwiddle=(int)self.MyValues[0];

            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify return
            byte []badVoucherHash=new byte[20];
            System.Array.Copy(voucherHash, badVoucherHash, 20);
            badVoucherHash[byteToTwiddle]=(byte)~badVoucherHash[byteToTwiddle];

            PcTokenBanResult []ret=BanPcTokensVerbose(new byte[][]{badVoucherHash});

            ValueCheck.TestAllUnordered("BanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(badVoucherHash, 0x80004005)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VerifyNotBanned(puid, voucherHash);
        }

        [TestCase, Description("Some vouchers are valid, others are not.")]
        public void MixedValidInvalid()
        {
            //create vouchers and machines
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);

            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashB=TokendbWS.GetHashForPanoramaVoucher(voucherB);
            ulong puidB0=XMachineTestUtil.CreatePCMachine(voucherB);

            string voucherC=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashC=TokendbWS.GetHashForPanoramaVoucher(voucherC);
            ulong puidC0=XMachineTestUtil.CreatePCMachine(voucherC);
            ulong puidC1=XMachineTestUtil.CreatePCMachine(voucherC);

            string voucherInvalidD="QXYYZ-12345-WOOPS-NOTTT-EXIST";
            byte []voucherInvalidHashD=TokendbWS.GetHashForPanoramaVoucher(voucherInvalidD);
            string voucherInvalidE="QXVVK-12345-WOOPS-NOTTT-EXIST";
            byte []voucherInvalidHashE=TokendbWS.GetHashForPanoramaVoucher(voucherInvalidE);

            //call api and verify return
            PcTokenBanResult []ret=BanPcTokensVerbose(new byte[][]{voucherInvalidHashD, voucherHashA, voucherHashB, voucherHashC, voucherInvalidHashE});

            PcTokenBanResult []expectedRet=new PcTokenBanResult[]{
                MakePcTokenBanResult(voucherHashA, 0),
                MakePcTokenBanResult(voucherHashB, 0),
                MakePcTokenBanResult(voucherHashC, 0),
                MakePcTokenBanResult(voucherInvalidHashD, 0x80004005),
                MakePcTokenBanResult(voucherInvalidHashE, 0x80004005)};

            ValueCheck.TestAllUnordered("BanPcTokens return", expectedRet, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db
            VoucherEditor veA=VoucherEditor.FromHash(voucherHashA, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucherA", 2, veA.Status); //0=active, 1=disabled, 2=banned

            VerifySimpleBanRows(puidB0, voucherHashB);

            VerifySimpleBanRows(puidC0, voucherHashC);
            VerifySimpleBanRows(puidC1, voucherHashC);

            VoucherEditor veD=VoucherEditor.FromHash(voucherInvalidHashD, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("VoucherD exists now", false, veD.Exists);

            VoucherEditor veE=VoucherEditor.FromHash(voucherInvalidHashE, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("VoucherE exists now", false, veE.Exists);
        }

        [TestCase, Description("Pass null to the voucher hash list parameter.")]
        public void NullParameter()
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanPcTokensVerbose(null);}, "Null array: pcTokens");
        }

        [TestCase, Description("Pass null for one of the vouchers in the list, the others are valid.")]
        public void NullVoucherInArray()
        {
            //create vouchers and machines
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);

            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashB=TokendbWS.GetHashForPanoramaVoucher(voucherB);
            ulong puidB0=XMachineTestUtil.CreatePCMachine(voucherB);

            //call api and verify return
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanPcTokensVerbose(new byte[][]{voucherHashA, null, voucherHashB});}, "Null element in: pcTokens");

            //verify db
            VoucherEditor veA=VoucherEditor.FromHash(voucherHashA, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucherA", 0, veA.Status); //0=active, 1=disabled, 2=banned

            VoucherEditor veB=VoucherEditor.FromHash(voucherHashB, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucherB", 0, veB.Status); //0=active, 1=disabled, 2=banned
        }

        [TestCase, Description("We should not be allowed to ban the limited PC voucher.")]
        public void BanLimitedPCVoucher()
        {
            //create voucher and machine
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(LIMITED_PC_VOUCHER); //Note that Xmacs uses something completely different for the voucher hash stored in t_pc_accounts.
            ulong puid=XMachineTestUtil.CreatePCMachine(LIMITED_PC_VOUCHER);

            //call api and verify return.  We'll treat this just like trying to ban a voucher that doesn't exist.
            PcTokenBanResult []ret=BanPcTokensVerbose(new byte[][]{voucherHash});

            ValueCheck.TestAllUnordered("BanPcTokens return", new PcTokenBanResult[]{MakePcTokenBanResult(voucherHash, 0x80004005)}, ret, PcTokenBanResultEquals, PcTokenBanResultStringer);

            //verify db.  Note that there is no real voucher associated with this machine.
            MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(puid).GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEqualsLeniently);

            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puid).ConsoleId).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);
        }

        [TestCase, Description("Verify the history tables are being written to correctly.")]
        public void History()
        {
            //create vouchers and machines
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);
            ulong puidA0=XMachineTestUtil.CreatePCMachine(voucherA);
            ulong puidA1=XMachineTestUtil.CreatePCMachine(voucherA);

            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashB=TokendbWS.GetHashForPanoramaVoucher(voucherB);
            ulong puidB0=XMachineTestUtil.CreatePCMachine(voucherB);

            //call the ban api on both vouchers
            BanPcTokensVerbose(new byte[][]{voucherHashA, voucherHashB});
            System.DateTime ban0Time=System.DateTime.UtcNow;
            System.Threading.Thread.Sleep(3000);

            //call the ban api again on only the second voucher
            BanPcTokensVerbose(new byte[][]{voucherHashB});
            System.DateTime ban1Time=System.DateTime.UtcNow;

            //verify the db for machineA0
            MachineEditor.MachineBanHistory []actualHistoriesA0=MachineEditor.FromId(puidA0).GetAllMachineBanHistories();
            MachineEditor.MachineBanHistory []expectedHistoriesA0=new MachineEditor.MachineBanHistory[]{
                new MachineEditor.MachineBanHistory(puidA0, ban0Time, unchecked((int)0x8015190D), ban0Time, System.DateTime.MaxValue)};
            ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistoriesA0, actualHistoriesA0, MachineBanHistoryEquals2S);
            ValueCheck.Test("ConsoleBanHistory rows for machineA0", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puidA0).ConsoleId).GetAllConsoleBanHistories().Length);

            //verify the db for machineA1
            MachineEditor.MachineBanHistory []actualHistoriesA1=MachineEditor.FromId(puidA1).GetAllMachineBanHistories();
            MachineEditor.MachineBanHistory []expectedHistoriesA1=new MachineEditor.MachineBanHistory[]{
                new MachineEditor.MachineBanHistory(puidA1, ban0Time, unchecked((int)0x8015190D), ban0Time, System.DateTime.MaxValue)};
            ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistoriesA1, actualHistoriesA1, MachineBanHistoryEquals2S);
            ValueCheck.Test("ConsoleBanHistory rows for machineA1", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puidA1).ConsoleId).GetAllConsoleBanHistories().Length);

            //verify the db for machineB0
            MachineEditor.MachineBanHistory []actualHistoriesB0=MachineEditor.FromId(puidB0).GetAllMachineBanHistories();
            MachineEditor.MachineBanHistory []expectedHistoriesB0=new MachineEditor.MachineBanHistory[]{
                new MachineEditor.MachineBanHistory(puidB0, ban0Time, unchecked((int)0x8015190D), ban0Time, System.DateTime.MaxValue),
                new MachineEditor.MachineBanHistory(puidB0, ban1Time, unchecked((int)0x8015190D), ban1Time, System.DateTime.MaxValue)};
            ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistoriesB0, actualHistoriesB0, MachineBanHistoryEquals2S);
            ValueCheck.Test("ConsoleBanHistory rows for machineB0", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puidB0).ConsoleId).GetAllConsoleBanHistories().Length);
        }
    }; //class BanPcTokens
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\HistoryCommon.cs ===
using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Represents a group of tests than need to be tested with the database double write enabled/disabled.  Sets the xmachine double write setting and then reloads the config on the service. </summary>
    public class DoubleWriteTestGroup: TestNode
    {
        private bool enabled;
        private SettingState doubleWriteSetting=null;

        public override void PreRun()
        {
            enabled=(bool)MyValues[0];
            doubleWriteSetting=Global.XEnv.OverrideSetting("ALL", "ALL", xonline.common.config.Setting.xmachine_doubleWriteHistory, enabled.ToString());

            CreateContextData();
            SetContextData("DoubleWriteEnabled", enabled);

            XMachineTestUtil.ReloadConfig();
        }

        public override void PostRun()
        {
            if (doubleWriteSetting!=null)
            {
                Global.XEnv.RestoreOverrideSettingState(doubleWriteSetting);
                doubleWriteSetting=null;

                XMachineTestUtil.ReloadConfig();
            }
        }

        protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
        {
            instances.Add(new CompoundCaseAttribute("DoubleWriteEnabled", true));
            instances.Add(new CompoundCaseAttribute("DoubleWriteDisabled", false));
        }

        public static bool IsDoubleWrite(TestNode node)
        {
            return (bool)node.GetContextData("DoubleWriteEnabled");
        }
    }

    // --

    public class HistoryCommon: TestNode
    {
        public static bool NullableDatetimeEquals(System.DateTime ?left, System.DateTime ?right, int tolleranceInMs)
        {
            if (left==null || right==null)
            {
                return (left==right);
            }
            else
            {
                return System.Math.Abs(((System.DateTime)left-(System.DateTime)right).TotalMilliseconds)<=tolleranceInMs;
            }
        }

        // --

        public static string HistorySummaryStringer(HistorySummary hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "HistorySummary(First="+hist.First+" Last="+hist.Last+" Total="+hist.Total+" Unique="+hist.Unique+")";
        }

        public static string HistorySummaryStringer(object hist)
        {
            if (hist is HistorySummary)
            {
                return HistorySummaryStringer((HistorySummary)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool HistorySummaryEquals(HistorySummary left, HistorySummary right)
        {
            return NullableDatetimeEquals(left.First, right.First, 1) &&
                NullableDatetimeEquals(left.Last, right.Last, 1) &&
                left.Total==right.Total &&
                left.Unique==right.Unique;
        }

        // --

        public static string HistoryDetailsStringer(HistoryDetails hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "HistoryDetails(UserPuid="+string.Format("0x{0:X}", hist.UserPuid)+" MachinePuid="+string.Format("0x{0:X}", hist.MachinePuid)+" IpAddress="+hist.IpAddress+" Timestamp="+hist.Timestamp+" HResult="+string.Format("0x{0:X}", hist.HResult)+" Reason="+(int)hist.Reason+/*" Details="+hist.Details+*/")";
        }

        public static string HistoryDetailsStringer(object hist)
        {
            if (hist is HistoryDetails)
            {
                return HistoryDetailsStringer((HistoryDetails)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool HistoryDetailsEquals(HistoryDetails left, HistoryDetails right)
        {
            return left.UserPuid==right.UserPuid &&
                left.MachinePuid==right.MachinePuid &&
                left.IpAddress==right.IpAddress &&
                NullableDatetimeEquals(left.Timestamp, right.Timestamp, 1) &&
                left.HResult==right.HResult &&
                left.Reason==right.Reason; // &&
                //left.Details==right.Details;
        }

        // --

        public static string GamertagHistoryDetailsStringer(GamertagHistoryDetails hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "GamertagHistoryDetails(OldGamertag="+hist.OldGamertag+" NewGamertag="+hist.NewGamertag+" "+HistoryDetailsStringer(hist)+")";
        }

        public static string GamertagHistoryDetailsStringer(object hist)
        {
            if (hist is GamertagHistoryDetails)
            {
                return GamertagHistoryDetailsStringer((GamertagHistoryDetails)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool GamertagHistoryDetailsEquals(GamertagHistoryDetails left, GamertagHistoryDetails right)
        {
            return left.OldGamertag==right.OldGamertag &&
                left.NewGamertag==right.NewGamertag &&
                HistoryDetailsEquals(left, right);
        }

        // --

        public static string GamertagHistoryStringer(GamertagHistory hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "GamertagHistory("+HistorySummaryStringer(hist)+" Details=("+StringUtils.MakeDeliminatorSeparatedList(hist.Details, ", ", GamertagHistoryDetailsStringer)+"))";
        }

        public static string GamertagHistoryStringer(object hist)
        {
            if (hist is GamertagHistory)
            {
                return GamertagHistoryStringer((GamertagHistory)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static void VerifyGamertagHistory(GamertagHistory expect, GamertagHistory got)
        {
            ValueCheck.TestAllUnordered("GamertagHistory.HistorySummary", new HistorySummary[]{expect}, new HistorySummary[]{got}, HistoryCommon.HistorySummaryEquals, HistoryCommon.HistorySummaryStringer);
            ValueCheck.TestAllUnordered("GamertagHistory.Details", expect.Details, got.Details, HistoryCommon.GamertagHistoryDetailsEquals, HistoryCommon.GamertagHistoryDetailsStringer);
        }

        // --

        public static string PassportHistoryDetailsStringer(PassportHistoryDetails hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "PassportHistoryDetails(OldPassportPuid="+string.Format("0x{0:X}", hist.OldPassportPuid)+" NewPassportPuid="+string.Format("0x{0:X}", hist.NewPassportPuid)+" "+HistoryDetailsStringer(hist)+")";
        }

        public static string PassportHistoryDetailsStringer(object hist)
        {
            if (hist is PassportHistoryDetails)
            {
                return PassportHistoryDetailsStringer((PassportHistoryDetails)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool PassportHistoryDetailsEquals(PassportHistoryDetails left, PassportHistoryDetails right)
        {
            return left.OldPassportPuid==right.OldPassportPuid &&
                left.NewPassportPuid==right.NewPassportPuid &&
                HistoryDetailsEquals(left, right);
        }

        // --

        public static string PassportHistoryStringer(PassportHistory hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "PassportHistory("+HistorySummaryStringer(hist)+" Details=("+StringUtils.MakeDeliminatorSeparatedList(hist.Details, ", ", PassportHistoryDetailsStringer)+"))";
        }

        public static string PassportHistoryStringer(object hist)
        {
            if (hist is PassportHistory)
            {
                return PassportHistoryStringer((PassportHistory)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static void VerifyPassportHistory(PassportHistory expect, PassportHistory got)
        {
            ValueCheck.TestAllUnordered("PassportHistory.HistorySummary", new HistorySummary[]{expect}, new HistorySummary[]{got}, HistoryCommon.HistorySummaryEquals, HistoryCommon.HistorySummaryStringer);
            ValueCheck.TestAllUnordered("PassportHistory.Details", expect.Details, got.Details, HistoryCommon.PassportHistoryDetailsEquals, HistoryCommon.PassportHistoryDetailsStringer);
        }

        // --

        public static string RecoveryHistoryDetailsStringer(RecoveryHistoryDetails hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "RecoveryHistoryDetails(PassportPuid="+string.Format("0x{0:X}", hist.PassportPuid)+" "+HistoryDetailsStringer(hist)+")";
        }

        public static string RecoveryHistoryDetailsStringer(object hist)
        {
            if (hist is RecoveryHistoryDetails)
            {
                return RecoveryHistoryDetailsStringer((RecoveryHistoryDetails)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static bool RecoveryHistoryDetailsEquals(RecoveryHistoryDetails left, RecoveryHistoryDetails right)
        {
            return left.PassportPuid==right.PassportPuid &&
                HistoryDetailsEquals(left, right);
        }

        // --

        public static string RecoveryHistoryStringer(RecoveryHistory hist)
        {
            if (hist==null)
            {
                return "";
            }

            return "RecoveryHistory("+HistorySummaryStringer(hist)+" Details=("+StringUtils.MakeDeliminatorSeparatedList(hist.Details, ", ", RecoveryHistoryDetailsStringer)+"))";
        }

        public static string RecoveryHistoryStringer(object hist)
        {
            if (hist is RecoveryHistory)
            {
                return RecoveryHistoryStringer((RecoveryHistory)hist);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(hist);
            }
        }

        public static void VerifyRecoveryHistory(RecoveryHistory expect, RecoveryHistory got)
        {
            ValueCheck.TestAllUnordered("RecoveryHistory.HistorySummary", new HistorySummary[]{expect}, new HistorySummary[]{got}, HistoryCommon.HistorySummaryEquals, HistoryCommon.HistorySummaryStringer);
            ValueCheck.TestAllUnordered("RecoveryHistory.Details", expect.Details, got.Details, HistoryCommon.RecoveryHistoryDetailsEquals, HistoryCommon.RecoveryHistoryDetailsStringer);
        }

        // --

        public static string UserMachineHistoryDetailsStringer(UserMachineHistoryDetails umh)
        {
            return "UserMachineHistoryDetails(UserPuid="+string.Format("0x{0:X}", umh.UserPuid)+" MachinePuid="+string.Format("0x{0:X}", umh.MachinePuid)+" IpAddress="+umh.IpAddress+" DaysSeen="+umh.DaysSeen+" FriendlyName="+umh.FriendlyName+" TrustLevel="+umh.TrustLevel+" FirstSignin="+umh.FirstSignin+" LastSignin="+umh.LastSignin+" LastSignout="+umh.LastSignout+")";
        }

        public static string UserMachineHistoryDetailsStringer(object umh)
        {
            if (umh is UserMachineHistoryDetails)
            {
                return UserMachineHistoryDetailsStringer((UserMachineHistoryDetails)umh);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(umh);
            }
        }

        public static bool UserMachineHistoryDetailsEquals(UserMachineHistoryDetails left, UserMachineHistoryDetails right)
        {
            return left.MachinePuid==right.MachinePuid &&
                left.UserPuid==right.UserPuid &&
                left.IpAddress==right.IpAddress &&
                left.DaysSeen==right.DaysSeen &&
                left.FriendlyName==right.FriendlyName &&
                left.TrustLevel==right.TrustLevel &&
                NullableDatetimeEquals(left.FirstSignin, right.FirstSignin, 1) &&
                NullableDatetimeEquals(left.LastSignin, right.LastSignin, 1) &&
                NullableDatetimeEquals(left.LastSignout, right.LastSignout, 1);
        }

        public static void VerifyUserMachineHistoryDetails(UserMachineHistoryDetails []expect, UserMachineHistoryDetails []got)
        {
            ValueCheck.TestAllUnordered("UserMachineHistoryDetails", expect, got, UserMachineHistoryDetailsEquals, UserMachineHistoryDetailsStringer);
        }
    }

    // --

    public abstract class LogAccumulatorAndCaller<CallType, DbType>
    {
        private System.Collections.Generic.Dictionary<ulong, System.Collections.Generic.List<DbType>> expectedLogs=new System.Collections.Generic.Dictionary<ulong, System.Collections.Generic.List<DbType>>();

        public abstract DbType ConvertCallTypeToDbType(CallType log);
        public abstract DbType[] GetActualRowsFromDb(ulong machinePuid, bool hitSecHistoryDbInsteadOfUodb);
        public abstract ulong GetMachinePuid(CallType log);
        public abstract ulong GetMachinePuid(DbType log);
        public abstract void SetHashBucket(DbType log, short bucket);

        public delegate void CallDelegate(CallType data);
        public void CallAndAccumulate(CallDelegate method, CallType data)
        {
            ulong machinePuid=0;
            if (data!=null)
            {
                machinePuid=GetMachinePuid(data);

                if (!expectedLogs.ContainsKey(machinePuid))
                {
                    expectedLogs.Add(machinePuid, new System.Collections.Generic.List<DbType>());
                }
            }

            method(data);

            //db should only be written to if the call succeeded

            if (data!=null)
            {
                expectedLogs[machinePuid].Add(ConvertCallTypeToDbType(data));
            }
        }

        public void Verify(bool isDoubleWriteEnabled)
        {
            foreach (ulong machinePuid in expectedLogs.Keys)
            {
                DbType []actualLogsInUodb=GetActualRowsFromDb(machinePuid, false);
                DbType []actualLogsInSecHistoryDb=GetActualRowsFromDb(machinePuid, true);

                Global.RO.Debug("Rows for machine 0x"+string.Format("{0:X}", machinePuid)+" in Uodb: "+actualLogsInUodb.Length);
                Global.RO.Debug("Rows for machine 0x"+string.Format("{0:X}", machinePuid)+" in SecMachineHistoryDb: "+actualLogsInSecHistoryDb.Length);

                if (isDoubleWriteEnabled)
                {
                    FixHashBucket(expectedLogs[machinePuid], false);
                    ValueCheck.TestAllUnordered<DbType>("Rows in Uodb for machine 0x"+string.Format("{0:X}", machinePuid), expectedLogs[machinePuid], actualLogsInUodb);
                    FixHashBucket(expectedLogs[machinePuid], true);
                    ValueCheck.TestAllUnordered<DbType>("Rows in SecMachineHistoryDb for machine 0x"+string.Format("{0:X}", machinePuid), expectedLogs[machinePuid], actualLogsInSecHistoryDb);
                }
                else
                {
                    FixHashBucket(expectedLogs[machinePuid], false);
                    ValueCheck.TestAllUnordered<DbType>("Rows in Uodb for machine 0x"+string.Format("{0:X}", machinePuid), new DbType[0], actualLogsInUodb);
                    FixHashBucket(expectedLogs[machinePuid], true);
                    ValueCheck.TestAllUnordered<DbType>("Rows in SecMachineHistoryDb for machine 0x"+string.Format("{0:X}", machinePuid), expectedLogs[machinePuid], actualLogsInSecHistoryDb);
                }
            }
        }

        private void FixHashBucket(System.Collections.Generic.IEnumerable<DbType> entries, bool forSecHistoryDbInsteadOfUodb)
        {
            foreach (DbType dbt in entries)
            {
                ulong machinePuid=GetMachinePuid(dbt);
                if (forSecHistoryDbInsteadOfUodb)
                {
                    SetHashBucket(dbt, (short)WebstoreDB.GetHashBucket(xonline.common.config.ConfigUtil.SecMachineHistoryWebstoreApp, machinePuid));
                }
                else
                {
                    SetHashBucket(dbt, (short)UodbWS.GetHashBucket(machinePuid));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\BanMachinePuids.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Test for calling the BanMachinePuids. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class BanMachinePuids : TestNode
    {
        public static MachinePuidResult MakeMachinePuidResult(ulong machinePuid, UInt32 result)
        {
            MachinePuidResult r=new MachinePuidResult();
            r.MachinePuid = machinePuid;
            r.Result      = result;
            return r;
        }

        public static string MachinePuidResultStringer(MachinePuidResult result)
        {
            return "MachinePuidResult(MachinePuid="+string.Format("0x{0:X}", result.MachinePuid)+" Result="+string.Format("0x{0:X}", result.Result)+")";
        }

        public static string MachinePuidResultStringer(object result)
        {
            if (result is MachinePuidResult)
            {
                return MachinePuidResultStringer((MachinePuidResult)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static bool MachinePuidResultEquals(MachinePuidResult left, MachinePuidResult right)
        {
            return left.MachinePuid==right.MachinePuid &&
                left.Result==right.Result;
        }

        public static bool MachineBanHistoryEquals2S(MachineEditor.MachineBanHistory left, MachineEditor.MachineBanHistory right)
        {
            return left.MachineId==right.MachineId &&
                System.Math.Abs((left.ChangeTime-right.ChangeTime).TotalMilliseconds)<2000 &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalMilliseconds)<2000 &&
                (System.Math.Abs((left.EndDate-right.EndDate).TotalMilliseconds)<2000 || (left.EndDate.Year==9999 && System.Math.Abs((left.EndDate-right.EndDate).TotalHours)<=24)) &&
                left.HashBucket==right.HashBucket;
        }

        public static MachinePuidResult[] BanMachinePuidsVerbose(Puid []machineList, uint reasonCode, DateTime banStart, DateTime banEnd)
        {
            Global.RO.Debug("Calling BanMachinePuids: MachineList={"+StringUtils.MakeCommaSeparatedList(machineList)+"}, ReasonCode="+reasonCode+" BanStart="+banStart+" BanEnd="+banEnd);
            MachinePuidResult[] ret;
            if (machineList!=null)
            {
                ret=new XMachineSoapClient().BanMachinePuids(System.Array.ConvertAll(machineList, u=>(ulong)(u)), reasonCode, banStart, banEnd);
            }
            else
            {
                ret=new XMachineSoapClient().BanMachinePuids(null, reasonCode, banStart, banEnd);
            }
            Global.RO.Debug("BanMachinePuids returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", MachinePuidResultStringer));
            return ret;
        }

        public static MachinePuidResult[] BanMachinePuidsVerbose(ulong []machineList, uint reasonCode, DateTime banStart, DateTime banEnd)
        {
            return BanMachinePuidsVerbose(System.Array.ConvertAll(machineList, u=>(Puid)(u)), reasonCode, banStart, banEnd);
        }

        // -----

        [TestGroup]
        public class Xbox360: TestNode
        {
            [TestCase, Description("Creates a machine, calls ban on it, then verifies the tables."), BVT]
            public void BanOne()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, banStart, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(puid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);

                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(machineEdit.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);
            }

            [TestCase, Description("Creates multiple machines, calls ban on them, then verifies the tables.")]
            [CompoundCase("7", 7)]
            [CompoundCase("Max", 100)]
            public void BanMany(TestNode self)
            {
                int numberToBan=(int)self.MyValues[0];

                //create machines
                List<MachinePuidResult> expectedRet=new List<MachinePuidResult>();
                List<ulong> puidsToBan=new List<ulong>();

                for (int i=0; i<numberToBan; ++i)
                {
                    puidsToBan.Add(XMachineTestUtil.CreateXbox360Machine());
                    expectedRet.Add(MakeMachinePuidResult(puidsToBan[i], 0));
                }

                ulong puidNotBanned=XMachineTestUtil.CreateXbox360Machine();

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(puidsToBan.ToArray(), 0x80000001, banStart, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", expectedRet, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                foreach (ulong puidBanned in puidsToBan)
                {
                    MachineEditor machineEditBanned=MachineEditor.FromId(puidBanned);
                    MachineEditor.MachineBanStatus []machineBansForBanned=machineEditBanned.GetAllMachineBans();
                    MachineEditor.MachineBanStatus []expectedMachineBansForBanned=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puidBanned, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                    ValueCheck.TestAllUnordered("MachineBan rows in DB for a banned machine", expectedMachineBansForBanned, machineBansForBanned);
                }

                MachineEditor machineEditNotBanned=MachineEditor.FromId(puidNotBanned);
                MachineEditor.MachineBanStatus []machineBansForNotBanned=machineEditNotBanned.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBansForNotBanned=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB for a NOT banned machine", expectedMachineBansForNotBanned, machineBansForNotBanned);
            }

            [TestCase, Description("Attempt to ban more machines than the API can handle at once.")]
            public void BanTooMany()
            {
                //create machines
                List<ulong> puidsToBan=new List<ulong>();

                Global.RO.Debug("Creating 500 machines...");
                for (int i=0; i<500; ++i)
                {
                    MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
                    puidsToBan.Add(mach.Id);
                }

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpecting404(delegate{BanMachinePuidsVerbose(puidsToBan.ToArray(), 0x80000001, banStart, System.DateTime.MaxValue);});

                //verify the db
                foreach (ulong puidBanned in puidsToBan)
                {
                    MachineEditor machineEditBanned=MachineEditor.FromId(puidBanned);
                    MachineEditor.MachineBanStatus []actualMachineBans=machineEditBanned.GetAllMachineBans();
                    MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                    ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
                }
            }

            [TestCase, Description("Calls ban on no machines.")]
            public void BanNone()
            {
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[0], 0x80000001, banStart, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[0], ret, MachinePuidResultEquals, MachinePuidResultStringer);
            }

            [TestCase, Description("Calls ban on on puid in the valid range but for a machine that doesn't exist.")]
            public void MachineDoesNotExist()
            {
                //create machine
                ulong validPuid=0xfa0010108080ffff;

                //call the ban api and verify the return
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{validPuid}, 0x80000001, System.DateTime.UtcNow, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(validPuid, 0x80004005)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(validPuid).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Creates a machine, calls ban on it along with some invalid ones, then verifies the tables.")]
            public void MixedValidInvalidPlatform()
            {
                //create machine
                ulong validPuid=XMachineTestUtil.CreateXbox360Machine();
                ulong []puids=new ulong[]{0x12345, validPuid, 0xffffffedcba98765};

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose(puids, 0x80000001, banStart, System.DateTime.MaxValue);}, "Invalid platform type");

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(validPuid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);

                actualMachineBans=MachineEditor.FromId(0x12345).GetAllMachineBans();
                expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);

                actualMachineBans=MachineEditor.FromId(0xffffffedcba98765).GetAllMachineBans();
                expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Creates a machine, calls ban on it along with some invalid ones, then verifies the tables.")]
            public void MixedValidInvalidPuids()
            {
                //create machine
                ulong validPuid=XMachineTestUtil.CreateXbox360Machine();
                ulong []puids=new ulong[]{0xfa00ffedcba98764, validPuid, 0xfa00ffedcba98765};

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(puids, 0x80000001, banStart, System.DateTime.MaxValue);

                MachinePuidResult []expectedReturn=new MachinePuidResult[]{MakeMachinePuidResult(0xfa00ffedcba98764, 0x80004005), MakeMachinePuidResult(validPuid, 0), MakeMachinePuidResult(0xfa00ffedcba98765, 0x80004005)};
                ValueCheck.TestAllUnordered("Puid errors returned", expectedReturn, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(validPuid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(validPuid, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);

                actualMachineBans=MachineEditor.FromId(0x12345).GetAllMachineBans();
                expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);

                actualMachineBans=MachineEditor.FromId(0xfa00ffedcba98765).GetAllMachineBans();
                expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Pass null for the machine puids paramater.")]
            public void NullPuidsParameter()
            {
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose((Puid[])null, 0x80000001, banStart, System.DateTime.MaxValue);}, "Null array: machinePuids");
            }

            [TestCase, Description("Creates a couple machines, calls ban with duplicate puids, then verifies the tables.")]
            public void DuplicatePuidsInParameter()
            {
                //create machine
                ulong validPuid0=XMachineTestUtil.CreateXbox360Machine();
                ulong validPuid1=XMachineTestUtil.CreateXbox360Machine();
                ulong []puids=new ulong[]{validPuid0, validPuid0, validPuid1};

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(puids, 0x80000001, banStart, System.DateTime.MaxValue);

                MachinePuidResult []expectedReturn=new MachinePuidResult[]{MakeMachinePuidResult(validPuid0, 0), MakeMachinePuidResult(validPuid1, 0)};
                ValueCheck.TestAllUnordered("Puid errors returned", expectedReturn, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(validPuid0).GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(validPuid0, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);

                actualMachineBans=MachineEditor.FromId(validPuid1).GetAllMachineBans();
                expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(validPuid1, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Re-ban machines for the same reason but various different time spans for the two different bans in conjuction with the current time.")]
            //                                                 Ban1     Ban2     Expect
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -7, -3,  -9, -8,  -9, -8)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -7, -3,  -9, -6,  -9, -6)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -7, -3,  -7, -3,  -7, -3)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -7, -3,  -6, -4,  -6, -4)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -7, -3,  -4, -2,  -4, -2)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -7, -3,  -2, -1,  -2, -1)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -7, -3,  -1, +1,  -1, +1)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -7, -3,  +1, +2,  +1, +2)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -5, -5,  -5, -5,  -5, -5)]

            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -5, +5,  -9, -8,  -9, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -5, +5,  -6, -4,  -6, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -5, +5,  -5, +5,  -5, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -5, +5,  -4, -3,  -5, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -5, +5,  -1, +1,  -5, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -5, +5,  +3, +4,  -5, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -5, +5,  +4, +6,  -5, +6)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -5, +5,  +8, +9,  -5, +9)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +0, +0,  +0, +0,  +0, +0)] //timing will make this impossible to really pull off, but leaving the case here regardless

            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +7,  -2, -1,  -2, +7)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +7,  -1, +1,  -1, +7)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +7,  +1, +2,  +1, +7)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +7,  +2, +4,  +2, +7)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +7,  +3, +7,  +3, +7)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +7,  +4, +6,  +3, +7)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +7,  +6, +9,  +3, +9)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +7,  +8, +9,  +3, +9)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +7,  +5, +5,  +3, +7)]

            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -9, -8,  -5, +5,  -5, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -6, -4,  -5, +5,  -5, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -4, -3,  -5, +5,  -5, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  -1, +1,  -5, +5,  -5, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +3, +4,  -5, +5,  -5, +5)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +4, +6,  -5, +5,  -5, +6)]
            [CompoundCase("Ban1={0} to {1}, Ban2={2} to {3}",  +8, +9,  -5, +5,  -5, +9)]
            public void BanOneMachineTwiceSameReasonVariousTimes(TestNode self)
            {
                //figure out the date ranges
                int ban1StartOffset=(int)self.MyValues[0];
                int ban1EndOffset=(int)self.MyValues[1];
                int ban2StartOffset=(int)self.MyValues[2];
                int ban2EndOffset=(int)self.MyValues[3];
                int expectedBanStartOffset=(int)self.MyValues[4];
                int expectedBanEndOffset=(int)self.MyValues[5];

                System.DateTime now=System.DateTime.UtcNow;
                System.DateTime ban1Start=now+new System.TimeSpan(ban1StartOffset, 0, 0, 0);
                System.DateTime ban1End=now+new System.TimeSpan(ban1EndOffset, 0, 0, 0);
                System.DateTime ban2Start=now+new System.TimeSpan(ban2StartOffset, 0, 0, 0);
                System.DateTime ban2End=now+new System.TimeSpan(ban2EndOffset, 0, 0, 0);
                System.DateTime expectedBanStart=now+new System.TimeSpan(expectedBanStartOffset, 0, 0, 0);
                System.DateTime expectedBanEnd=now+new System.TimeSpan(expectedBanEndOffset, 0, 0, 0);

                //create machine and set up the initial ban row for it
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                Global.RO.Debug("Adding machine puid ban to db: 0x80000001, "+ban1Start+" through "+ban1End);
                mach.BanMachine(unchecked((int)0x80000001), ban1Start, ban1End);

                //call the ban api and verify the return
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001, ban2Start, ban2End);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(mach.Id, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000001), expectedBanStart, expectedBanEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Bans several machines with different times for the same reason, then ban them all in a batch for a the same reason and a different range.")]
            public void BanSeveralTwiceSameReasonDifferentTimes()
            {
                //create machines
                MachineEditor mach0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach2=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                //ban them the first time
                System.DateTime now=System.DateTime.UtcNow;
                BanMachinePuidsVerbose(new ulong[]{mach0.Id}, 0x80000001, now-new System.TimeSpan(5, 0, 0, 0), System.DateTime.MaxValue);
                BanMachinePuidsVerbose(new ulong[]{mach1.Id}, 0x80000001, now, now+new System.TimeSpan(50, 0, 0, 0));
                BanMachinePuidsVerbose(new ulong[]{mach2.Id}, 0x80000001, now, now+new System.TimeSpan(5, 0, 0, 0));

                //ban them the second time and verify the return
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{mach0.Id, mach1.Id, mach2.Id}, 0x80000001, now, now+new System.TimeSpan(10, 0, 0, 0));

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(mach0.Id, 0), MakeMachinePuidResult(mach1.Id, 0), MakeMachinePuidResult(mach2.Id, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []machineBans0=mach0.GetAllMachineBans();
                MachineEditor.MachineBanStatus []machineBans1=mach1.GetAllMachineBans();
                MachineEditor.MachineBanStatus []machineBans2=mach2.GetAllMachineBans();

                MachineEditor.MachineBanStatus []expectedMachineBans0=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach0.Id, unchecked((int)0x80000001), now-new System.TimeSpan(5, 0, 0, 0), System.DateTime.MaxValue)};
                MachineEditor.MachineBanStatus []expectedMachineBans1=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach1.Id, unchecked((int)0x80000001), now, now+new System.TimeSpan(50, 0, 0, 0))};
                MachineEditor.MachineBanStatus []expectedMachineBans2=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach2.Id, unchecked((int)0x80000001), now, now+new System.TimeSpan(10, 0, 0, 0))};

                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans0, machineBans0);
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans1, machineBans1);
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans2, machineBans2);
            }

            [TestCase, Description("Creates a machine, calls ban on it with a past date, then verifies the tables.")]
            [CompoundCase("StartPast", 3)]
            [CompoundCase("StartAndEndPast", -1)]
            public void BanPast(TestNode self)
            {
                System.DateTime startDate=System.DateTime.UtcNow+new System.TimeSpan(-10, 0, 0, 0);
                System.DateTime endDate=System.DateTime.UtcNow+new System.TimeSpan((int)self.MyValues[0], 0, 0, 0);

                //create machine
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                //call the ban api and verify the return
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, startDate, endDate);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(puid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x80000001), startDate, endDate)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Creates a machine, calls ban on it with a date.")]
            [CompoundCase("BadStart",       1,    9999, "Invalid BanStart")]
            [CompoundCase("BadEnd",         9999, 1,    "BanEnd:1/1/0001 12:00:00 AM < BanStart:1/1/9999 12:00:00 AM")]
            [CompoundCase("BadStartBadEnd", 1,    2,    "Invalid BanStart")]
            [CompoundCase("EndBeforeStart", 2110, 2100, "BanEnd:1/1/2100 12:00:00 AM < BanStart:1/1/2110 12:00:00 AM")]
            public void InvalidDates(TestNode self)
            {
                System.DateTime banStart=new System.DateTime((int)self.MyValues[0], 1, 1);
                System.DateTime banEnd=new System.DateTime((int)self.MyValues[1], 1, 1);
                string expectedError=(string)self.MyValues[2];

                //create machine
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                //call the ban api and verify the return
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, banStart, banEnd);}, expectedError);

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(puid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Creates a machine, calls ban on it with an invalid code.")]
            public void InvalidBanCode()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose(new ulong[]{puid}, 13, banStart, System.DateTime.MaxValue);}, "Invalid ReasonCode");

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(puid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Creates a machine, calls ban on it several times with different reasons each time, then verifies the tables.")]
            public void BanOneDifferentReasons()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                //call the ban api and verify return
                System.DateTime now=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{puid}, 0xFFFF0001, now-new System.TimeSpan(10, 0, 0, 0), now+new System.TimeSpan(20, 0, 0, 0));
                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //call the ban api and verify return
                ret=BanMachinePuidsVerbose(new ulong[]{puid}, 0xFFFF0002, now+new System.TimeSpan(10, 0, 0, 0), System.DateTime.MaxValue);
                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //call the ban api and verify return
                ret=BanMachinePuidsVerbose(new ulong[]{puid}, 0xFFFF0003, now, now+new System.TimeSpan(10, 0, 0, 0));
                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(puid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();

                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(puid, unchecked((int)0xFFFF0001), now-new System.TimeSpan(10, 0, 0, 0), now+new System.TimeSpan(20, 0, 0, 0)),
                    new MachineEditor.MachineBanStatus(puid, unchecked((int)0xFFFF0002), now+new System.TimeSpan(10, 0, 0, 0), System.DateTime.MaxValue),
                    new MachineEditor.MachineBanStatus(puid, unchecked((int)0xFFFF0003), now, now+new System.TimeSpan(10, 0, 0, 0))};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Creates several machines, calls ban on them a couple times for different reasons, then verifies the tables.")]
            public void BanSeveralDifferentReasons()
            {
                //create machines and set up initial ban rows
                MachineEditor mach0=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach1=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor mach2=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

                System.DateTime now=System.DateTime.UtcNow;
                Global.RO.Debug("Adding machine puid ban to db: 0xFFFF0001, "+now+" through "+(now+new System.TimeSpan(5, 0, 0, 0)));
                mach0.BanMachine(unchecked((int)0xFFFF0001), now, now+new System.TimeSpan(5, 0, 0, 0));
                Global.RO.Debug("Adding machine puid ban to db: 0xFFFF0002, "+now+" through "+System.DateTime.MaxValue);
                mach1.BanMachine(unchecked((int)0xFFFF0002), now, System.DateTime.MaxValue);

                //call the ban api on all the machines and verify return
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{mach0.Id, mach1.Id, mach2.Id}, 0xFFFF0003, now, now+new System.TimeSpan(20, 0, 0, 0));

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(mach0.Id, 0), MakeMachinePuidResult(mach1.Id, 0), MakeMachinePuidResult(mach2.Id, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []machineBans0=mach0.GetAllMachineBans();
                MachineEditor.MachineBanStatus []machineBans1=mach1.GetAllMachineBans();
                MachineEditor.MachineBanStatus []machineBans2=mach2.GetAllMachineBans();

                MachineEditor.MachineBanStatus []expectedMachineBans0=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach0.Id, unchecked((int)0xFFFF0001), now, now+new System.TimeSpan(5, 0, 0, 0)),
                    new MachineEditor.MachineBanStatus(mach0.Id, unchecked((int)0xFFFF0003), now, now+new System.TimeSpan(20, 0, 0, 0))};
                MachineEditor.MachineBanStatus []expectedMachineBans1=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach1.Id, unchecked((int)0xFFFF0002), now, System.DateTime.MaxValue),
                    new MachineEditor.MachineBanStatus(mach1.Id, unchecked((int)0xFFFF0003), now, now+new System.TimeSpan(20, 0, 0, 0))};
                MachineEditor.MachineBanStatus []expectedMachineBans2=new MachineEditor.MachineBanStatus[]{
                    new MachineEditor.MachineBanStatus(mach2.Id, unchecked((int)0xFFFF0003), now, now+new System.TimeSpan(20, 0, 0, 0))};

                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans0, machineBans0);
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans1, machineBans1);
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans2, machineBans2);
            }

            [TestCase, Description("Ban an old-style xbox360 machine that has not yet been migrated to the new name lookup table.")]
            public void LegacyMachine()
            {
                //create machine
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();

                //call the api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001, banStart, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(mach.Id, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor.MachineBanStatus []actualMachineBans=mach.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(mach.Id, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Creates two consoles that share the same console id, calls ban on the puid for one, then verifies the tables.")]
            public void BanOneDuplicateConsole()
            {
                //create machines
                MachineEditor machA=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                MachineEditor machB=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(machA.ConsoleId));

                //call API and verify return
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{machA.Id}, 0x80000001, banStart, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(machA.Id, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify DB
                MachineEditor.MachineBanStatus []actualMachineBans=machA.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(machA.Id, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);

                actualMachineBans=machB.GetAllMachineBans();
                expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Verify the history tables are being written to correctly.")]
            public void History()
            {
                //create machine
                ulong puid0=XMachineTestUtil.CreateXbox360Machine();
                ulong puid1=XMachineTestUtil.CreateXbox360Machine();

                //call the ban api on both for reason 1
                System.DateTime ban0Start=System.DateTime.UtcNow;
                System.DateTime ban0End=System.DateTime.UtcNow+new System.TimeSpan(5, 0, 0, 0);
                BanMachinePuidsVerbose(new ulong[]{puid0, puid1}, 0x80000001, ban0Start, ban0End);
                System.DateTime ban0ChangeTime=System.DateTime.UtcNow;
                System.Threading.Thread.Sleep(3000);

                //call the ban api on one again for reason 1, later date
                System.DateTime ban1Start=System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0);
                System.DateTime ban1End=System.DateTime.MaxValue;
                BanMachinePuidsVerbose(new ulong[]{puid0}, 0x80000001, ban1Start, ban1End);
                System.DateTime ban1ChangeTime=System.DateTime.UtcNow;
                System.Threading.Thread.Sleep(3000);

                //call the ban api on the other for reason 2
                System.DateTime ban2Start=System.DateTime.UtcNow;
                System.DateTime ban2End=System.DateTime.MaxValue;
                BanMachinePuidsVerbose(new ulong[]{puid1}, 0x80000002, ban2Start, ban2End);
                System.DateTime ban2ChangeTime=System.DateTime.UtcNow;

                //verify the db for machine0
                MachineEditor.MachineBanHistory []actualHistories0=MachineEditor.FromId(puid0).GetAllMachineBanHistories();
                MachineEditor.MachineBanHistory []expectedHistories0=new MachineEditor.MachineBanHistory[]{
                    new MachineEditor.MachineBanHistory(puid0, ban0ChangeTime, unchecked((int)0x80000001), ban0Start, ban0End),
                    new MachineEditor.MachineBanHistory(puid0, ban1ChangeTime, unchecked((int)0x80000001), ban1Start, ban1End)};
                ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistories0, actualHistories0, MachineBanHistoryEquals2S);
                ValueCheck.Test("ConsoleBanHistory rows for machine0", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puid0).ConsoleId).GetAllConsoleBanHistories().Length);

                //verify the db for machine1
                MachineEditor.MachineBanHistory []actualHistories1=MachineEditor.FromId(puid1).GetAllMachineBanHistories();
                MachineEditor.MachineBanHistory []expectedHistories1=new MachineEditor.MachineBanHistory[]{
                    new MachineEditor.MachineBanHistory(puid1, ban0ChangeTime, unchecked((int)0x80000001), ban0Start, ban0End),
                    new MachineEditor.MachineBanHistory(puid1, ban2ChangeTime, unchecked((int)0x80000002), ban2Start, ban2End)};
                ValueCheck.TestAllUnordered("MachineBanHistory rows", expectedHistories1, actualHistories1, MachineBanHistoryEquals2S);
                ValueCheck.Test("ConsoleBanHistory rows for machine1", 0, ConsoleBanEditor.FromConsoleId(MachineEditor.FromId(puid1).ConsoleId).GetAllConsoleBanHistories().Length);
            }
        }; //class Xbox360


        [TestGroup]
        public class PC
        {
            [TestCase, Description("Creates a machine, calls ban on it, then verifies the tables."), BVT]
            public void BanOne()
            {
                //create voucher and machine
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{puid}, 0x8015190D, banStart, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                BanPcTokens.VerifySimpleBanRows(puid, voucherHash);
            }

            [TestCase, Description("Creates several machines, calls ban on them, then verifies the tables.")]
            public void BanMultiple()
            {
                int createCount=5;

                //create vouchers and machines.  we do this directly here because hitting passport for 100 tickets is not desirable.
                string []vouchers=new string[createCount];
                byte [][]voucherHashes=new byte [createCount][];
                ulong []puids=new ulong[createCount];

                for (int i=0; i<createCount; ++i)
                {
                    vouchers[i]=XMachineTestUtil.CreateUnlimitedPCVoucher();
                    voucherHashes[i]=TokendbWS.GetHashForPanoramaVoucher(vouchers[i]);
                    puids[i]=MachineEditor.CreateOrUseExistingPCName(vouchers[i], (ulong)i, MachineEditor.GetCachedPassportId()).Id;
                }

                //call api and verify
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(puids, 0x8015190D, banStart, System.DateTime.MaxValue);

                MachinePuidResult []expectedRet=new MachinePuidResult[createCount];
                for (int i=0; i<createCount; ++i)
                {
                    expectedRet[i]=MakeMachinePuidResult(puids[i], 0);
                }

                ValueCheck.TestAllUnordered("Puid errors returned", expectedRet, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify db
                for (int i=0; i<createCount; ++i)
                {
                    BanPcTokens.VerifySimpleBanRows(puids[i], voucherHashes[i]);
                }
            }

            [TestCase, Description("Creates multiple machines from the same voucher, calls ban on one machine (which should ban the voucher and all other machines), then verifies the tables.")]
            public void OneVoucherMultipleMachines()
            {
                //create voucher and machines
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid0=XMachineTestUtil.CreatePCMachine(voucher);
                ulong puid1=XMachineTestUtil.CreatePCMachine(voucher);
                ulong puid2=XMachineTestUtil.CreatePCMachine(voucher);

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{puid0}, 0x8015190D, banStart, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid0, 0), MakeMachinePuidResult(puid1, 0), MakeMachinePuidResult(puid2, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                BanPcTokens.VerifySimpleBanRows(puid0, voucherHash);
                BanPcTokens.VerifySimpleBanRows(puid1, voucherHash);
                BanPcTokens.VerifySimpleBanRows(puid2, voucherHash);
            }

            [TestCase, Description("Creates a machine, calls ban on it with a reason other than the only reason PC may currently be banned for, then verifies the tables.")]
            public void BadPcBanReason()
            {
                //create voucher and machine
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose(new ulong[]{puid}, 0x80151337, banStart, System.DateTime.MaxValue);}, "PC Bans must be for Reason 0x8015190D");

                //verify the db
                BanPcTokens.VerifyNotBanned(puid, voucherHash);
            }

            [TestCase, Description("Creates a machine, calls ban on it with a start time in the future which is not allowed for PCs, then verifies the tables.")]
            public void FutureBan()
            {
                //create voucher and machine
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow+new System.TimeSpan(7, 0, 0, 0);
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose(new ulong[]{puid}, 0x8015190D, banStart, System.DateTime.MaxValue);}, "PC Bans must start before now");

                //verify the db
                BanPcTokens.VerifyNotBanned(puid, voucherHash);
            }

            [TestCase, Description("Creates a machine, calls ban on it with an end time that is not the end of time which is not allowed for PCs, then verifies the tables.")]
            public void TemporaryBan()
            {
                //create voucher and machine
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose(new ulong[]{puid}, 0x8015190D, banStart, banStart+new System.TimeSpan(5, 0, 0, 0));}, "PC Bans must be permanent");

                //verify the db
                BanPcTokens.VerifyNotBanned(puid, voucherHash);
            }
        }; //class PC


        [TestGroup]
        public class Phone
        {
            [TestCase, Description("Creates a machine, calls ban on it, then verifies the tables."), BVT]
            public void BanOne()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreatePhoneMachine();

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, banStart, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(puid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);

                ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(machineEdit.ConsoleId).GetAllConsoleBans();
                ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
                ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus);
            }

            [TestCase, Description("Creates several machines, calls ban on them, then verifies the tables.")]
            public void BanMultiple()
            {
                int createCount=5;

                //create machines
                ulong []puids=new ulong[createCount];

                for (int i=0; i<createCount; ++i)
                {
                    puids[i]=XMachineTestUtil.CreatePhoneMachine();
                }

                //call api and verify
                System.DateTime banStart=System.DateTime.UtcNow;
                MachinePuidResult []ret=BanMachinePuidsVerbose(puids, 0x80000001, banStart, System.DateTime.MaxValue);

                MachinePuidResult []expectedRet=new MachinePuidResult[createCount];
                for (int i=0; i<createCount; ++i)
                {
                    expectedRet[i]=MakeMachinePuidResult(puids[i], 0);
                }

                ValueCheck.TestAllUnordered("Puid errors returned", expectedRet, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify db
                for (int i=0; i<createCount; ++i)
                {
                    MachineEditor machineEdit=MachineEditor.FromId(puids[i]);
                    MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                    MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puids[i], unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                    ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
                }
            }

            [TestCase, Description("Creates a machine, calls ban on it with a start time in the future, then verifies the tables.")]
            public void FutureBan()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreatePhoneMachine();

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow+new System.TimeSpan(7, 0, 0, 0);
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, banStart, System.DateTime.MaxValue);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(puid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x80000001), banStart, System.DateTime.MaxValue)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase, Description("Creates a machine, calls ban on it with a start and end date in the past, then verifies the tables.")]
            public void ExpiredBan()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreatePhoneMachine();

                //call the ban api and verify the return
                System.DateTime banStart=System.DateTime.UtcNow-new System.TimeSpan(7, 0, 0, 0);
                System.DateTime banEnd=System.DateTime.UtcNow-new System.TimeSpan(5, 0, 0, 0);
                MachinePuidResult []ret=BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, banStart, banEnd);

                ValueCheck.TestAllUnordered("Puid errors returned", new MachinePuidResult[]{MakeMachinePuidResult(puid, 0)}, ret, MachinePuidResultEquals, MachinePuidResultStringer);

                //verify the db
                MachineEditor machineEdit=MachineEditor.FromId(puid);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(puid, unchecked((int)0x80000001), banStart, banEnd)};
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }
        }; //class Phone


        [TestGroup]
        public class Mixed
        {
            [TestCase]
            public void Xbox360AndPC()
            {
                //create machines
                ulong puid0=XMachineTestUtil.CreateXbox360Machine();

                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid1=XMachineTestUtil.CreatePCMachine(voucher);

                //call api
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose(new ulong[]{puid0, puid1}, 0x8015190D, banStart, System.DateTime.MaxValue);}, "Mixed PlatformType");

                //verify the db
                BanPcTokens.VerifyNotBanned(puid1, voucherHash);

                MachineEditor machineEdit0=MachineEditor.FromId(puid0);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit0.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }

            [TestCase]
            public void Xbox360AndPhone()
            {
                //create machines
                ulong puid0=XMachineTestUtil.CreateXbox360Machine();
                ulong puid1=XMachineTestUtil.CreatePhoneMachine();

                //call api
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose(new ulong[]{puid0, puid1}, 0x8015190D, banStart, System.DateTime.MaxValue);}, "Mixed PlatformType");

                //verify the db
                foreach (ulong puid in new ulong[]{puid0, puid1})
                {
                    MachineEditor machineEdit=MachineEditor.FromId(puid);
                    MachineEditor.MachineBanStatus []actualMachineBans=machineEdit.GetAllMachineBans();
                    MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                    ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
                }
            }

            [TestCase]
            public void PCAndPhone()
            {
                //create machines
                ulong puid0=XMachineTestUtil.CreatePhoneMachine();

                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
                ulong puid1=XMachineTestUtil.CreatePCMachine(voucher);

                //call api
                System.DateTime banStart=System.DateTime.UtcNow;
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{BanMachinePuidsVerbose(new ulong[]{puid0, puid1}, 0x8015190D, banStart, System.DateTime.MaxValue);}, "Mixed PlatformType");

                //verify the db
                BanPcTokens.VerifyNotBanned(puid1, voucherHash);

                MachineEditor machineEdit0=MachineEditor.FromId(puid0);
                MachineEditor.MachineBanStatus []actualMachineBans=machineEdit0.GetAllMachineBans();
                MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
                ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans);
            }
        }; //class Mixed
    } //class BanMachinePuids
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\IsConsoleIdAndSCodeBanned.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the IsConsoleIdAndSCodeBanned API. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class IsConsoleIdAndSCodeBanned: TestNode
    {
        /// <summary> Calls the IsConsoleIdAndSCodeBanned API and returns its result. </summary>
        public static bool IsConsoleIdAndSCodeBannedVerbose(string consoleId, byte[] secondaryIdentifier)
        {
            Global.RO.Debug("Calling IsConsoleIdAndSCodeBanned: ConsoleId{"+consoleId+"} SecondaryIdentifier{"+((xonline.common.utilities2.Blob)secondaryIdentifier).ToString()+"}");
            bool ret=new XMachineSoapClient().IsConsoleIdAndSCodeBanned(consoleId, secondaryIdentifier);
            Global.RO.Debug("IsConsoleIdAndSCodeBanned returned: "+ret.ToString());
            return ret;
        }

        /// <summary> This returns a bool indicating whether or not a console is expected to be banned depending on what the method set up for testing. </summary>
        public static bool CreateMachine(bool ban, bool dupe, bool unban, DateTime banStart, uint reason, out string consoleId, out byte[] secondaryId)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            if (dupe)
            {
                XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId);
            }

            if (ban)
            {
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{mach.Id}, reason, banStart.AddHours(-1), DateTime.MaxValue);
            }

            if (unban)
            {
                UnbanMachinePuids.UnbanMachinePuidsVerbose(new ulong[]{mach.Id}, 0);
            }

            consoleId=mach.ConsoleId;
            secondaryId=mach.CertHash;
            DateTime now=DateTime.UtcNow;

            if (unban)
            {
                System.Threading.Thread.Sleep(5000); //avoid clock skew causing server to report that it's still banned when it's not
            }

            //Banned, not unbanned, within the correct time range (not in the future), and without an outstanding dupe.
            return (ban && !unban && banStart<now);
        }

        [TestCase, Description("Checking for some bans. Different combinations of duped, existing, banned and unbanned states."), TestCasePriority(1)]
        [CompoundCase("NotExists_NotBanned_NotDuped_NotUnbanned", false, false, false, false)]
        [CompoundCase("Exists_NotBanned_NotDuped_NotUnbanned", true, false, false, false)]
        [CompoundCase("Exists_NotBanned_Duped_NotUnbanned", true, false, true, false)]
        [CompoundCase("Exists_Banned_NotDuped_NotUnbanned", true, true, false, false)]
        [CompoundCase("Exists_Banned_NotDuped_Unbanned", true, true, false, true)]
        [CompoundCase("Exists_Banned_Duped_NotUnbanned", true, true, true, false)]
        [CompoundCase("Exists_Banned_Duped_Unbanned", true, true, true, true)]
        public void IsConsoleBanned(TestNode self)
        {
            bool consoleExists=(bool)self.MyValues[0];
            bool consoleBanned=(bool)self.MyValues[1];
            bool consoleDuped=(bool)self.MyValues[2];
            bool consoleUnbanned=(bool)self.MyValues[3];
            string consoleId;
            byte[] secondaryId;

            DateTime now=DateTime.UtcNow;
            bool expectedResult=CreateMachine(consoleBanned, consoleDuped, consoleUnbanned, now, 0x80000001, out consoleId, out secondaryId);

            if (!consoleExists)
            {
                consoleId="XE.019194218869";
            }

            bool res=IsConsoleIdAndSCodeBannedVerbose(consoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(secondaryId));

            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", expectedResult, res);
        }

        [TestCase, Description("Invalid console ids"), TestCasePriority(2)]
        [CompoundCase("InvalidString", "!@!@#@!#")]
        [CompoundCase("LongString", "aaaaaaaaaaaaaaaaa")]
        [CompoundCase("360Zero", "XE.0")]
        [CompoundCase("360Negative", "XE.-01111111119")]
        [CompoundCase("PCZero", "PC.0")]
        [CompoundCase("PCNegative", "PC.-01111111119")]
        [CompoundCase("X1Zero", "SN.0")]
        [CompoundCase("X1Negative", "SN.-01111111119")]
        [CompoundCase("Zero", "0")]
        [CompoundCase("Negative", "-1")]
        public void LookupBansInvalidConsoleIds(TestNode self)
        {
            string id=(string)self.MyValues[0];
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            bool res=IsConsoleIdAndSCodeBannedVerbose(id, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);            
        }

        [TestCase, Description("Expired ban"), TestCasePriority(1)]
        public void LookupFutureBan()
        {
            bool expectedResult=false; //Has not yet happened.
            DateTime banStart=DateTime.UtcNow.AddDays(300);
            DateTime banEnd=DateTime.UtcNow.AddDays(600);

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            bool res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash));

            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", expectedResult, res);
        }

        [TestCase, Description("Null console id array"), TestCasePriority(2)]        
        public void NullConsoleId(TestNode self)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            bool res=IsConsoleIdAndSCodeBannedVerbose(null, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash));

            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);
        }

        [TestCase, Description("Hash too long."), TestCasePriority(2)]
        public void LookupMachineIdHashTooLong(TestNode self)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            //Full certhash is too long and wrong.
            bool res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, mach.CertHash);
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);
        }

        [TestCase, Description("Invalid hash."), TestCasePriority(1)]
        public void LookupMachineIdInvalidHash(TestNode self)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            byte[] truncatedIdReversed=LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash);
            Array.Reverse(truncatedIdReversed); //Unlikely that we'll just happen to get a checksum on the reverse.

            bool res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, truncatedIdReversed);
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);
        }

        [TestCase, Description("Ask for a valid console id but a non-existent hash."), TestCasePriority(1)]
        public void LookupMachineIdsNonExistingHash(TestNode self)
        {
            //Create 2 machines
            DateTime banStart=DateTime.UtcNow.AddHours(-1);
            DateTime banEnd=DateTime.MaxValue;

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            MachineEditor mach2=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);

            //Send console id 1 and cert hash 2 which should fail to find anything.
            bool res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach2.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);
        }

        [TestCase, Description("Send a null cert hash and expect true because at least one in a pile is banned."), TestCasePriority(1)]
        public void LookupMachineIdsNullHash(TestNode self)
        {
            //Create 2 machines, ban 1
            DateTime banStart=DateTime.UtcNow.AddHours(-1);
            DateTime banEnd=DateTime.MaxValue;

            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            MachineEditor mach2=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId));

            //Let's check all cases before banning.
            bool res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);

            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach2.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);

            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, null);
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);

            //Let's ban one now.
            BanMachinePuids.BanMachinePuidsVerbose(new ulong[] { mach.Id }, 0x80000001, banStart, banEnd); //1 year ban.

            //And now try again. Now only the explicit case on the unbanned certhash should return false
            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", true, res);

            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach2.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);

            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, null);
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", true, res);
        }

        [TestCase, Description("Various invalid zeros."), TestCasePriority(1)]
        public void LookupMachineIdsZeroHash(TestNode self)
        {
            //Create 2 machines, ban 1
            DateTime banStart=DateTime.UtcNow.AddHours(-1);
            DateTime banEnd=DateTime.MaxValue;

            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            MachineEditor mach2=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId));

            //Let's check all cases before banning.
            bool res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);

            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach2.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);

            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, new byte[] { 0x00 });
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);

            //Let's ban one now.
            BanMachinePuids.BanMachinePuidsVerbose(new ulong[] { mach.Id }, 0x80000001, banStart, banEnd); //1 year ban.

            //And now try again. Now only the explicit case on the unbanned certhash should return false
            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", true, res);

            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach2.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);

            //this one used to work.  it was a nasty hack that never should have made it out the door.  that condition has since been corrected.
            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, new byte[] { 0x00 });
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);

            //this should not work either
            res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, new byte[] { 0x00, 0x00 });
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);
        }

        [TestCase, Description("Look for a PC machine puid through its console id."), TestCasePriority(2)]
        public void IsPCBanned(TestNode self)
        {
            //Voucher A is 1:1 voucher->Machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte[] voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            MachineEditor mach=MachineEditor.FromId(puid);

            bool res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);
        }

        [TestCase, Description("Phone test case"), TestCasePriority(2)]
        public void IsPhoneBanned(TestNode self)
        {
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            MachineEditor mach=MachineEditor.FromId(puid);

            bool res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, LookupMachinePuidsByConsoleIdAndSCode.GetTruncatedSecondaryID(mach.CertHash));
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);
        }

        [TestCase, Description("All FF bytes in the hash."), TestCasePriority(2)]
        public void LookupIdsMaxCertHash(TestNode self)
        {
            byte[] max=new byte[8];

            for (int k=0; k < max.Length; k++)
                max[k]=Byte.MaxValue;

            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            bool res=IsConsoleIdAndSCodeBannedVerbose(mach.ConsoleId, max);
            ValueCheck.Test("Obtained different results from IsConsoleIdAndSCodeBanned:", false, res);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupConsoleBansByConsoleIds.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the LookupBansByConsoleIds API. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupConsoleBansByConsoleIds: TestNode
    {
        /// <summary> Calls the LookupConsoleBansByConsoleIds API and returns its BanInfo object. </summary>
        public static ConsoleBanInfo[] LookupConsoleBansByConsoleIdsVerbose(string[] consoleIdList)
        {
            Global.RO.Debug("Calling LookupConsoleBansByConsoleIds: ConsoleIdList={"+StringUtils.MakeCommaSeparatedList(consoleIdList)+"}");
            ConsoleBanInfo[] ret=new XMachineSoapClient().LookupConsoleBansByConsoleIds(consoleIdList);

            Global.RO.Debug("ConsoleBanInfos returned: ");
            foreach (ConsoleBanInfo cbi in ret)
            {
                Global.RO.Debug("  ConsoleId={0} BanStart={1} BanEnd={2} Reason={3}",
                                    cbi.ConsoleId,
                                    cbi.BanStart,
                                    cbi.BanEnd,
                                    cbi.ReasonCode
                                    );
            }
            return ret;
        }

        /// <summary> Compares a ConsoleBanStatus object containing expected (test generated) values against an API result object. </summary>
        public static void ValidateBanInfoResults(ConsoleBanInfo[] results, ConsoleBanEditor.ConsoleBanStatus[] expectedResults)
        {
            List<ConsoleBanEditor.ConsoleBanStatus> obtainedResults=new List<ConsoleBanEditor.ConsoleBanStatus>();

            foreach (ConsoleBanInfo consoleInfo in results)
            {
                obtainedResults.Add(new ConsoleBanEditor.ConsoleBanStatus(consoleInfo.ConsoleId, (int)consoleInfo.ReasonCode, consoleInfo.BanStart));
            }

            ValueCheck.Test("The counts of results differed from what was expected.", expectedResults.Length, results.Length);
            foreach (ConsoleBanEditor.ConsoleBanStatus expectedResult in expectedResults)
            {
                bool found=false;
                foreach (ConsoleBanInfo info in results)
                {
                    if (info.ConsoleId==expectedResult.ConsoleId)
                    {
                        ValueCheck.Test("Invalid ban start time:", expectedResult.StartDate, info.BanStart);
                        ValueCheck.Test("Invalid ban end time:", DateTime.MaxValue, info.BanEnd);
                        ValueCheck.Test("Invalid reason code:", (uint)expectedResult.ReasonCode, info.ReasonCode);
                        found = true;
                    }
                }

                if (!found)
                {
                    throw new UnexpectedTestResultException("We could not find a ban for console with console id: "+expectedResult.ConsoleId);
                }
            }
        }

        /// <summary> This returns an array of ConsoleBanStatus objects containing expected results after calling LookupBansByConsoleId. </summary>
        public static ConsoleBanEditor.ConsoleBanStatus[] CreateMachine(bool ban, bool dupe, bool unban, DateTime banStart, uint reason, out string consoleId)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            if (dupe)
            {
                XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId);
            }

            if (ban)
            {
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, reason, banStart);
            }

            if (unban)
            {
                UnbanConsoleIds.UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0); //All reasons.
            }

            consoleId=mach.ConsoleId;
            return ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
        }

        [TestCase, Description("Looking up some bans. Different combinations of duped, existing, banned and unbanned states."), TestCasePriority(1)]
        [CompoundCase("NotExists_NotBanned_NotDuped_NotUnbanned", false, false, false, false)]
        [CompoundCase("Exists_NotBanned_NotDuped_NotUnbanned",    true,  false, false, false)]
        [CompoundCase("Exists_NotBanned_Duped_NotUnbanned",       true,  false, true,  false)]
        [CompoundCase("Exists_Banned_NotDuped_NotUnbanned",       true,  true,  false, false)]
        [CompoundCase("Exists_Banned_NotDuped_Unbanned",          true,  true,  false, true)]
        [CompoundCase("Exists_Banned_Duped_NotUnbanned",          true,  true,  true,  false)]
        [CompoundCase("Exists_Banned_Duped_Unbanned",             true,  true,  true,  true)]
        public void LookupConsoleBans(TestNode self)
        {
            ConsoleBanEditor.ConsoleBanStatus[] expectedResults;
            bool consoleExists=(bool)self.MyValues[0];
            bool consoleBanned=(bool)self.MyValues[1];
            bool consoleDuped=(bool)self.MyValues[2];
            bool consoleUnbanned=(bool)self.MyValues[3];
            string consoleId;

            DateTime now=DateTime.UtcNow;
            expectedResults=CreateMachine(consoleBanned, consoleDuped, consoleUnbanned, now, 0x80000001, out consoleId);

            if (!consoleExists)
            {
                consoleId=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            }

            ConsoleBanInfo []res=LookupConsoleBansByConsoleIdsVerbose(new string[]{consoleId});

            ValidateBanInfoResults(res, expectedResults);
        }

        [TestCase, Description("Looking up multiple bans."), TestCasePriority(1)]
        [CompoundCase("1", 1)]
        [CompoundCase("2", 2)]
        [CompoundCase("10", 10)]
        [CompoundCase("100", 100)]
        public void LookupMultipleConsoleBans(TestNode self)
        {
            List<ConsoleBanEditor.ConsoleBanStatus> expectedResults=new List<ConsoleBanEditor.ConsoleBanStatus>();
            List<string> consoleIds=new List<string>();
            int banCount=(int)self.MyValues[0];

            for (int k=0; k<banCount; ++k)
            {
                string consoleId="";
                DateTime now=DateTime.UtcNow;
                expectedResults.AddRange(CreateMachine(true, false, false, now, 0x80000001, out consoleId));
                consoleIds.Add(consoleId);
            }

            ConsoleBanInfo []res=LookupConsoleBansByConsoleIdsVerbose(consoleIds.ToArray());

            ValidateBanInfoResults(res, expectedResults.ToArray());
        }

        [TestCase, Description("Invalid console ids"), TestCasePriority(2)]
        [CompoundCase("InvalidString", "!@!@#@!#")]
        [CompoundCase("LongString",    "aaaaaaaaaaaaaaaaa")]
        [CompoundCase("360Zero",       "XE.0")]
        [CompoundCase("PCZero",        "PC.0")]
        [CompoundCase("PCNegative",    "PC.-01111111119")]
        [CompoundCase("X1Zero",        "SN.0")]
        [CompoundCase("X1Negative",    "SN.-01111111119")]
        [CompoundCase("Zero",          "0")]
        [CompoundCase("Negative",      "-1")]
        public void LookupBansInvalidConsoleIds(TestNode self)
        {
            string id=(string)self.MyValues[0];
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupConsoleBansByConsoleIdsVerbose(new string[]{id});}, "Invalid");
        }

        [TestCase, Description("Invalid console ids"), TestCasePriority(2)]
        public void InvalidChecksumNegative(TestNode self)
        {
            string id="XE.-01111111119";
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupConsoleBansByConsoleIdsVerbose(new string[]{id});}, "Invalid Checksum");
        }

        [TestCase, Description("Expired ban"), TestCasePriority(1)]
        public void LookupExpiredBan()
        {
            DateTime banStart=DateTime.UtcNow.AddDays(-600);
            DateTime banEnd=DateTime.UtcNow.AddDays(-300);

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            ConsoleBanInfo []res=LookupConsoleBansByConsoleIdsVerbose(new string[]{mach.ConsoleId});
            ValidateBanInfoResults(res, ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans());
        }

        [TestCase, Description("Expired ban"), TestCasePriority(1)]
        public void LookupFutureBan()
        {
            DateTime banStart=DateTime.UtcNow.AddDays(300);
            DateTime banEnd=DateTime.UtcNow.AddDays(600);

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            ConsoleBanInfo []res=LookupConsoleBansByConsoleIdsVerbose(new string[]{mach.ConsoleId});
            ValidateBanInfoResults(res, ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans());
        }

        [TestCase, Description("Null console id array"), TestCasePriority(2)]
        public void LookupBansNull(TestNode self)
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupConsoleBansByConsoleIdsVerbose(null);}, "Null array");
        }

        [TestCase, Description("Empty console id array"), TestCasePriority(2)]
        public void LookupBansEmptyArray(TestNode self)
        {
            ConsoleBanInfo []ret=LookupConsoleBansByConsoleIdsVerbose(new string[]{});
            ValueCheck.Test("Length of returned array.", 0, ret.Length);
        }

        [TestCase, Description("Phone test case."), TestCasePriority(2)]
        public void LookupPhone(TestNode self)
        {
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            MachineEditor mach=MachineEditor.FromId(puid);
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupConsoleBansByConsoleIdsVerbose(new string[]{mach.ConsoleId});}, "Invalid Non-Xbox360");
        }

        [TestCase, Description("Look for a PC console id ban"), TestCasePriority(2)]
        public void LookupConsoleBansPC(TestNode self)
        {
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);
            ulong puidA=XMachineTestUtil.CreatePCMachine(voucherA);
            string cidA=MachineEditor.FromId(puidA).ConsoleId;

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHashA});

            List<ConsoleBanEditor.ConsoleBanStatus> banList=new List<ConsoleBanEditor.ConsoleBanStatus>();
            banList.Add(new ConsoleBanEditor.ConsoleBanStatus(cidA, unchecked((int)0x8015190d), DateTime.UtcNow));

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupConsoleBansByConsoleIdsVerbose(new string []{cidA});}, "Invalid Non-Xbox360");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LogPassportHistory.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using xonline.common.config;
using xonline.server.xmachine.fd.soap;

namespace XMachineTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LogPassportHistory: DoubleWriteTestGroup
    {
        public static void LogPassportHistoryVerbose(PassportHistoryDetails phd)
        {
            Global.RO.Debug("Calling LogPassportHistory: phd="+HistoryCommon.PassportHistoryDetailsStringer(phd));
            new XMachineSoapClient().LogPassportHistory(phd);
            Global.RO.Debug("LogPassportHistory returned.");
        }

        public class CallAndVerifier: LogAccumulatorAndCaller<PassportHistoryDetails, MachinePassportHistoryEditor.MachinePassportHistoryEntry>
        {
            public override MachinePassportHistoryEditor.MachinePassportHistoryEntry ConvertCallTypeToDbType(PassportHistoryDetails log)
            {
                return new MachinePassportHistoryEditor.MachinePassportHistoryEntry
                {
                    UserPuid   =log.UserPuid,
                    MachinePuid=log.MachinePuid,
                    IpAddress  =log.IpAddress,
                    TimeStamp  =log.Timestamp,
                    Hr         =log.HResult,
                    OldPassport=log.OldPassportPuid,
                    NewPassport=log.NewPassportPuid,
                    Reason     =(byte)log.Reason,
                    HashBucket =-1 //recomputed later to be correct
                };
            }

            public override MachinePassportHistoryEditor.MachinePassportHistoryEntry[] GetActualRowsFromDb(ulong machinePuid, bool hitSecHistoryDbInsteadOfUodb)
            {
                return MachinePassportHistoryEditor.FromMachinePuid(machinePuid, hitSecHistoryDbInsteadOfUodb).GetAllHistory();
            }

            public override ulong GetMachinePuid(PassportHistoryDetails log)
            {
                return log.MachinePuid;
            }

            public override ulong GetMachinePuid(MachinePassportHistoryEditor.MachinePassportHistoryEntry log)
            {
                return log.MachinePuid;
            }

            public override void SetHashBucket(MachinePassportHistoryEditor.MachinePassportHistoryEntry log, short bucket)
            {
                log.HashBucket=bucket;
            }
        }

        public static ulong RandomPuid()
        {
            return ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
        }

        public static PassportHistoryDetails GenerateDetails(ulong? userPuid, ulong? machinePuid, string ip, System.DateTime timestamp, uint hr, byte reason, ulong ?oldPassportPuid, ulong ?newPassportPuid)
        {
            if (userPuid==null)
            {
                userPuid=UserEditor.CreateNew().Puid;
            }

            if (machinePuid==null)
            {
                machinePuid=MachineEditor.CreateNew().Id;
            }

            return new PassportHistoryDetails
            {
                UserPuid=userPuid.Value,
                MachinePuid=machinePuid.Value,
                IpAddress=ip,
                Timestamp=timestamp,
                HResult=hr,
                Reason=reason,
                OldPassportPuid=oldPassportPuid,
                NewPassportPuid=newPassportPuid
            };
        }

        // --

        [TestCase, Description("One simple row with all fields present as normal values.")]
        public void SimpleMainline(TestNode self)
        {
            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogPassportHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for UserPuid.")]
        [CompoundCase("0x{0:X}", (ulong)0)]
        [CompoundCase("0x{0:X}", (ulong)1)]
        [CompoundCase("0x{0:X}", (ulong)0xABCD000012340000)]
        [CompoundCase("0x{0:X}", (ulong)0xFFFFFFFFFFFFFFFF)]
        public void VariousUserPuids(TestNode self)
        {
            ulong userPuid=(ulong)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogPassportHistoryVerbose, GenerateDetails(userPuid, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for MachinePuid.")]
        [CompoundCase("0x{0:X}", (ulong)0,                  "MachinePuid is invalid: 0x0000000000000000")]
        [CompoundCase("0x{0:X}", (ulong)1,                  "MachinePuid is invalid: 0x0000000000000001")]
        [CompoundCase("0x{0:X}", (ulong)0xABCD000012340000, "MachinePuid is invalid: 0xABCD000012340000")]
        [CompoundCase("0x{0:X}", (ulong)0xFFFFFFFFFFFFFFFF, "MachinePuid is invalid: 0xFFFFFFFFFFFFFFFF")]
        [CompoundCase("0x{0:X}", (ulong)0xFFED0000FFFFFFFF, "MachinePuid is invalid: 0xFFED0000FFFFFFFF")]
        [CompoundCase("0x{0:X}", (ulong)0xFA000000F0000000, "MachinePuid is invalid on lookup: 0xFA000000F0000000")]
        public void VariousInvalidMachinePuids(TestNode self)
        {
            ulong machinePuid=(ulong)self.MyValues[0];
            string expectedSoapError=(string)self.MyValues[1];

            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogPassportHistoryVerbose, GenerateDetails(null, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
                },
                expectedSoapError);

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("One simple row with all fields present as normal values for different platforms.")]
        [CompoundCase("{0}", MachineType.Xbox1)]
        [CompoundCase("{0}", MachineType.Xbox360)]
        [CompoundCase("{0}", MachineType.PC)]
        [CompoundCase("{0}", MachineType.Phone)]
        public void VariousValidMachinePuids(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            ulong mpuid=MachineEditor.CreateNew(mtype).Id;

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogPassportHistoryVerbose, GenerateDetails(null, mpuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for IpAddress.")]
        [CompoundCase("EmptyString", "")]
        [CompoundCase("null", null)]
        [CompoundCase("{0}", "Not.An.IP.Addy")]
        [CompoundCase("{0}", "Woops")]
        [CompoundCase("SingleDot", ".")]
        [CompoundCase("{0}", "999.999.999.999")]
        [CompoundCase("{0}", "0.0.0.0")]
        [CompoundCase("{0}", "100.002.003.0004")]
        public void VariousIPAddress(TestNode self)
        {
            string ip=(string)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogPassportHistoryVerbose, GenerateDetails(null, null, ip, System.DateTime.UtcNow, 0x80000000, 1, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Timestamp.")]
        public class VariousTimestamps: TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                instances.Add(new CompoundCaseAttribute("MaxDotNetDateTime", System.DateTime.MaxValue,                                   null));
                instances.Add(new CompoundCaseAttribute("MinDotNetDateTime", System.DateTime.MinValue,                                   "Invalid timestamp:1/1/0001"));
                instances.Add(new CompoundCaseAttribute("MinSqlDateTime",    (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue, null));
            }

            public override void Run()
            {
                System.DateTime timestamp=(System.DateTime)MyValues[0];
                string expectedSoapError=(string)MyValues[1];

                PassportHistoryDetails phd=GenerateDetails(null, null, "1.2.3.4", timestamp, 0x80000000, 1, RandomPuid(), RandomPuid());

                CallAndVerifier cav=new CallAndVerifier();
                if (expectedSoapError==null)
                {
                    cav.CallAndAccumulate(LogPassportHistoryVerbose, phd);
                }
                else
                {
                    XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                        {
                            cav.CallAndAccumulate(LogPassportHistoryVerbose, phd);
                        },
                        expectedSoapError);
                }
                cav.Verify(IsDoubleWrite(this));
            }
        }

        [TestCase, Description("Various values for HResult.")]
        [CompoundCase("0x{0:X}", (uint)0)]
        [CompoundCase("0x{0:X}", (uint)1)]
        [CompoundCase("0x{0:X}", (uint)0x7fffffff)]
        [CompoundCase("0x{0:X}", (uint)0x80000000)]
        [CompoundCase("0x{0:X}", (uint)0xffffffff)]
        public void VariousHResults(TestNode self)
        {
            uint hresult=(uint)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogPassportHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, hresult, 1, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Reason.")]
        [CompoundCase("0x{0:X}", (byte)0)]
        [CompoundCase("0x{0:X}", (byte)1)]
        [CompoundCase("Max", (byte)99)]
        public void VariousValidReasons(TestNode self)
        {
            byte reason=(byte)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogPassportHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, RandomPuid(), RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Values for Reason that are not in t_history_reasons.")]
        [CompoundCase("0x{0:X}", (byte)255)] //passes through protocol but isn't valid
        public void VariousInvalidReasons(TestNode self)
        {
            byte reason=(byte)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogPassportHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, RandomPuid(), RandomPuid()));
                },
                "HistoryReason is invalid");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for OldPassportPuid and NewPassportPuid.")]
        [CompoundCase("OldPassportPuid=0x{0:X}",   (ulong)0,           (ulong)777)]
        [CompoundCase("OldPassportPuid=0x{0:X}",   0xffffffffffffffff, (ulong)777)]
        [CompoundCase("OldPassportPuid=null",      null,               (ulong)777)]
        [CompoundCase("NewPassportPuid=0x{1:X}",   (ulong)777,         (ulong)0)]
        [CompoundCase("NewPassportPuid=0x{1:X}",   (ulong)777,         0xffffffffffffffff)]
        [CompoundCase("NewPassportPuid=null",      (ulong)777,         null)]
        public void VariousPassportPuids(TestNode self)
        {
            ulong ?pppOld=(self.MyValues[0]==null?(ulong?)null:(ulong?)(ulong)self.MyValues[0]);
            ulong ?pppNew=(self.MyValues[1]==null?(ulong?)null:(ulong?)(ulong)self.MyValues[1]);

            PassportHistoryDetails phd=GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 0, pppOld, pppNew);

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogPassportHistoryVerbose, phd);
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for OldPassportPuid and NewPassportPuid where both are the same.")]
        [CompoundCase("0x{0:X}", (ulong)0)]
        [CompoundCase("0x{0:X}", 0xffffffffffffffff)]
        [CompoundCase("Random",  null)]
        public void PassportPuidsSame(TestNode self)
        {
            ulong ppp=(self.MyValues[0]==null?RandomPuid():(ulong)self.MyValues[0]);

            PassportHistoryDetails phd=GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 0, ppp, ppp);

            CallAndVerifier cav=new CallAndVerifier();
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(LogPassportHistoryVerbose, phd);}, "NewPassportPuid cannot be equal to OldPassportPuid");
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log multiple times with the same machine puid.")]
        public void LogMultiple(TestNode self)
        {
            ulong machinePuid=MachineEditor.CreateNew().Id;
            ulong []userPuid=new ulong[]{UserEditor.CreateNew().Puid, UserEditor.CreateNew().Puid};

            CallAndVerifier cav=new CallAndVerifier();
            for (int i=0; i<10; ++i)
            {
                cav.CallAndAccumulate(LogPassportHistoryVerbose, GenerateDetails(userPuid[i%2], machinePuid, "1.2.3."+i, System.DateTime.UtcNow-new System.TimeSpan(0, 0, i), (uint)i*10+10, (byte)i, RandomPuid(), RandomPuid()));
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log twice with the same machine puid, using the same timestamp for both calls.")]
        [CompoundCase("SameData", true)]
        [CompoundCase("DifferentData", false)]
        public void LogTwoSameMachinesSameTime(TestNode self)
        {
            bool isDataTheSame=(bool)self.MyValues[0];

            ulong machinePuid=MachineEditor.CreateNew().Id;
            System.DateTime now=System.DateTime.UtcNow;
            PassportHistoryDetails phd1=GenerateDetails(null, machinePuid, "1.2.3.4", now, 0x80000000, 1, RandomPuid(), RandomPuid());
            PassportHistoryDetails phd2=phd1;

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogPassportHistoryVerbose, phd1);

            if (!isDataTheSame)
            {
                phd2=GenerateDetails(null, machinePuid, "1.2.3.5", now, 0x80000001, 2, RandomPuid(), RandomPuid());
            }

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(LogPassportHistoryVerbose, phd2);}, "existing log record found");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Pass null for the only parameter.")]
        public void PassNull(TestNode self)
        {
            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogPassportHistoryVerbose, null);
                },
                "Null parameter: PassportHistoryDetails");

            cav.Verify(IsDoubleWrite(self));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LogGamertagHistory.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.server.xmachine.fd.soap;

namespace XMachineTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LogGamertagHistory: DoubleWriteTestGroup
    {
        public static void LogGamertagHistoryVerbose(GamertagHistoryDetails gthd)
        {
            Global.RO.Debug("Calling LogGamertagHistory: gthd="+HistoryCommon.GamertagHistoryDetailsStringer(gthd));
            new XMachineSoapClient().LogGamertagHistory(gthd);
            Global.RO.Debug("LogGamertagHistory returned.");
        }

        public class CallAndVerifier: LogAccumulatorAndCaller<GamertagHistoryDetails, MachineGamertagHistoryEditor.MachineGamertagHistoryEntry>
        {
            public override MachineGamertagHistoryEditor.MachineGamertagHistoryEntry ConvertCallTypeToDbType(GamertagHistoryDetails log)
            {
                return new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry
                {
                    UserPuid   =log.UserPuid,
                    MachinePuid=log.MachinePuid,
                    IpAddress  =log.IpAddress,
                    TimeStamp  =log.Timestamp,
                    Hr         =log.HResult,
                    OldGamertag=log.OldGamertag,
                    NewGamertag=log.NewGamertag,
                    Reason     =(byte)log.Reason,
                    HashBucket =-1 //recomputed later to be correct
                };
            }

            public override MachineGamertagHistoryEditor.MachineGamertagHistoryEntry[] GetActualRowsFromDb(ulong machinePuid, bool hitSecHistoryDbInsteadOfUodb)
            {
                return MachineGamertagHistoryEditor.FromMachinePuid(machinePuid, hitSecHistoryDbInsteadOfUodb).GetAllHistory();
            }

            public override ulong GetMachinePuid(GamertagHistoryDetails log)
            {
                return log.MachinePuid;
            }

            public override ulong GetMachinePuid(MachineGamertagHistoryEditor.MachineGamertagHistoryEntry log)
            {
                return log.MachinePuid;
            }

            public override void SetHashBucket(MachineGamertagHistoryEditor.MachineGamertagHistoryEntry log, short bucket)
            {
                log.HashBucket=bucket;
            }
        }

        public static GamertagHistoryDetails GenerateDetails(ulong? userPuid, ulong? machinePuid, string ip, System.DateTime timestamp, uint hr, byte reason, string oldGamertag, string newGamertag)
        {
            UserEditor user=null;

            if (userPuid==null || newGamertag=="_" || oldGamertag=="_")
            {
                user=UserEditor.CreateNew();
            }

            if (userPuid==null)
            {
                userPuid=user.Puid;
            }

            if (machinePuid==null)
            {
                machinePuid=MachineEditor.CreateNew().Id;
            }

            // The underscore is just a signal character to use the auto generated gamertag so that we can still pass in null when we want to.
            if (newGamertag=="_")
            {
                newGamertag=user.Gamertag;
            }

            if (oldGamertag=="_")
            {
                string baseGt=newGamertag;
                if (baseGt==null || baseGt.Length<5)
                {
                    baseGt=user.Gamertag;
                }

                oldGamertag=baseGt.Substring(0, baseGt.Length-4)+"_old";
                if (oldGamertag.Length>15)
                {
                    oldGamertag=oldGamertag.Substring(oldGamertag.Length-15, 15);
                }
            }

            return new GamertagHistoryDetails
            {
                UserPuid=userPuid.Value,
                MachinePuid=machinePuid.Value,
                IpAddress=ip,
                Timestamp=timestamp,
                HResult=hr,
                Reason=reason,
                OldGamertag=oldGamertag,
                NewGamertag=newGamertag,
            };
        }

        // --

        [TestCase, Description("One simple row with all fields present as normal values.")]
        public void SimpleMainline(TestNode self)
        {
            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogGamertagHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for UserPuid.")]
        [CompoundCase("0x{0:X}", (ulong)0)]
        [CompoundCase("0x{0:X}", (ulong)1)]
        [CompoundCase("0x{0:X}", (ulong)0xABCD000012340000)]
        [CompoundCase("0x{0:X}", (ulong)0xFFFFFFFFFFFFFFFF)]
        public void VariousUserPuids(TestNode self)
        {
            ulong userPuid=(ulong)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogGamertagHistoryVerbose, GenerateDetails(userPuid, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for MachinePuid.")]
        [CompoundCase("0x{0:X}", (ulong)0,                  "MachinePuid is invalid: 0x0000000000000000")]
        [CompoundCase("0x{0:X}", (ulong)1,                  "MachinePuid is invalid: 0x0000000000000001")]
        [CompoundCase("0x{0:X}", (ulong)0xABCD000012340000, "MachinePuid is invalid: 0xABCD000012340000")]
        [CompoundCase("0x{0:X}", (ulong)0xFFFFFFFFFFFFFFFF, "MachinePuid is invalid: 0xFFFFFFFFFFFFFFFF")]
        [CompoundCase("0x{0:X}", (ulong)0xFFED0000FFFFFFFF, "MachinePuid is invalid: 0xFFED0000FFFFFFFF")]
        [CompoundCase("0x{0:X}", (ulong)0xFA000000F0000000, "MachinePuid is invalid on lookup: 0xFA000000F0000000")]
        public void VariousInvalidMachinePuids(TestNode self)
        {
            ulong machinePuid=(ulong)self.MyValues[0];
            string expectedSoapError=(string)self.MyValues[1];

            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogGamertagHistoryVerbose, GenerateDetails(null, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
                },
                expectedSoapError);

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("One simple row with all fields present as normal values for different platforms.")]
        [CompoundCase("{0}", MachineType.Xbox1)]
        [CompoundCase("{0}", MachineType.Xbox360)]
        [CompoundCase("{0}", MachineType.PC)]
        [CompoundCase("{0}", MachineType.Phone)]
        public void VariousValidMachinePuids(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            ulong mpuid=MachineEditor.CreateNew(mtype).Id;

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogGamertagHistoryVerbose, GenerateDetails(null, mpuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for IpAddress.")]
        [CompoundCase("EmptyString", "")]
        [CompoundCase("null", null)]
        [CompoundCase("{0}", "Not.An.IP.Addy")]
        [CompoundCase("{0}", "Woops")]
        [CompoundCase("SingleDot", ".")]
        [CompoundCase("{0}", "999.999.999.999")]
        [CompoundCase("{0}", "0.0.0.0")]
        [CompoundCase("{0}", "100.002.003.0004")]
        public void VariousIPAddress(TestNode self)
        {
            string ip=(string)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogGamertagHistoryVerbose, GenerateDetails(null, null, ip, System.DateTime.UtcNow, 0x80000000, 1, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Timestamp.")]
        public class VariousTimestamps: TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                instances.Add(new CompoundCaseAttribute("MaxDotNetDateTime", System.DateTime.MaxValue,                                   null));
                instances.Add(new CompoundCaseAttribute("MinDotNetDateTime", System.DateTime.MinValue,                                   "Invalid timestamp:1/1/0001"));
                instances.Add(new CompoundCaseAttribute("MinSqlDateTime",    (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue, null));
            }

            public override void Run()
            {
                System.DateTime timestamp=(System.DateTime)MyValues[0];
                string expectedSoapError=(string)MyValues[1];

                GamertagHistoryDetails ghd=GenerateDetails(null, null, "1.2.3.4", timestamp, 0x80000000, 1, "_", "_");

                CallAndVerifier cav=new CallAndVerifier();
                if (expectedSoapError==null)
                {
                    cav.CallAndAccumulate(LogGamertagHistoryVerbose, ghd);
                }
                else
                {
                    XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                        {
                            cav.CallAndAccumulate(LogGamertagHistoryVerbose, ghd);
                        },
                        expectedSoapError);
                }
                cav.Verify(IsDoubleWrite(this));
            }
        }

        [TestCase, Description("Various values for HResult.")]
        [CompoundCase("0x{0:X}", (uint)0)]
        [CompoundCase("0x{0:X}", (uint)1)]
        [CompoundCase("0x{0:X}", (uint)0x7fffffff)]
        [CompoundCase("0x{0:X}", (uint)0x80000000)]
        [CompoundCase("0x{0:X}", (uint)0xffffffff)]
        public void VariousHResults(TestNode self)
        {
            uint hresult=(uint)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogGamertagHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, hresult, 1, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Reason.")]
        [CompoundCase("0x{0:X}", (byte)0)]
        [CompoundCase("0x{0:X}", (byte)1)]
        [CompoundCase("Max", (byte)99)]
        public void VariousValidReasons(TestNode self)
        {
            byte reason=(byte)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogGamertagHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, "_", "_"));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Values for Reason that are not in t_history_reasons.")]
        [CompoundCase("0x{0:X}", (byte)255)] //passes through protocol but isn't valid
        public void VariousInvalidReasons(TestNode self)
        {
            byte reason=(byte)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogGamertagHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, "_", "_"));
                },
                "HistoryReason is invalid");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for OldGamertag and NewGamertag.")]
        [CompoundCase("OldGamertag=EmptyString",    "",                 "_",                 null)]
        [CompoundCase("OldGamertag=null",           null,               "_",                 null)]
        [CompoundCase("OldGamertag=MaxValid",      "STFU0123456789A",   "_",                 null)]
        [CompoundCase("OldGamertag=MaxInvalid",    "STFU0123456789AB",  "_",                 null)] //Technically this is also invalid.  However it does fit in the DB... so it was decided to just accept it anyways for now.
        [CompoundCase("OldGamertag=BiggerThanMax", "STFU0123456789ABC", "_",                 "Gamertag too long")]
        [CompoundCase("OldGamertag=LineBreak",      "\n",               "_",                 null)]
        [CompoundCase("NewGamertag=EmptyString",    "_",                "",                  null)]
        [CompoundCase("NewGamertag=null",           "_",                null,                null)]
        [CompoundCase("NewGamertag=MaxValid",       "_",                "STFU0123456789A",   null)]
        [CompoundCase("NewGamertag=MaxInvalid",     "_",                "STFU0123456789AB",  null)] //Technically this is also invalid.  However it does fit in the DB... so it was decided to just accept it anyways for now.
        [CompoundCase("NewGamertag=BiggerThanMax",  "_",                "STFU0123456789ABC", "Gamertag too long")]
        [CompoundCase("BothGamertag=null",          null,               null,                "NewGamertag and OldGamertag cannot both be null")]
        [CompoundCase("OldGamertag=NewGamertag",    "SameOldAndNew",    "SameOldAndNew",     "NewGamertag and OldGamertag cannot be equal")]
        public void VariousGamertags(TestNode self)
        {
            string gamertagOld=(string)self.MyValues[0];
            string gamertagNew=(string)self.MyValues[1];
            string expectedSoapError=(string)self.MyValues[2];

            GamertagHistoryDetails ghd=GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 0, gamertagOld, gamertagNew);

            CallAndVerifier cav=new CallAndVerifier();
            if (expectedSoapError==null)
            {
                cav.CallAndAccumulate(LogGamertagHistoryVerbose, ghd);
            }
            else
            {
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                    {
                        cav.CallAndAccumulate(LogGamertagHistoryVerbose, ghd);
                    },
                    expectedSoapError);
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log multiple times with the same machine puid.")]
        public void LogMultiple(TestNode self)
        {
            ulong machinePuid=MachineEditor.CreateNew().Id;
            ulong []userPuid=new ulong[]{UserEditor.CreateNew().Puid, UserEditor.CreateNew().Puid};

            CallAndVerifier cav=new CallAndVerifier();
            for (int i=0; i<10; ++i)
            {
                cav.CallAndAccumulate(LogGamertagHistoryVerbose, GenerateDetails(userPuid[i%2], machinePuid, "1.2.3."+i, System.DateTime.UtcNow-new System.TimeSpan(0, 0, i), (uint)i*10+10, (byte)i, "_", "_"));
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log twice with the same machine puid, using the same timestamp for both calls.")]
        [CompoundCase("SameData", true)]
        [CompoundCase("DifferentData", false)]
        public void LogTwoSameMachinesSameTime(TestNode self)
        {
            bool isDataTheSame=(bool)self.MyValues[0];

            ulong machinePuid=MachineEditor.CreateNew().Id;
            System.DateTime now=System.DateTime.UtcNow;
            GamertagHistoryDetails ghd1=GenerateDetails(null, machinePuid, "1.2.3.4", now, 0x80000000, 1, "_", "_");
            GamertagHistoryDetails ghd2=ghd1;

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogGamertagHistoryVerbose, ghd1);

            if (!isDataTheSame)
            {
                ghd2=GenerateDetails(null, machinePuid, "1.2.3.5", now, 0x80000001, 2, "_", "_");
            }

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(LogGamertagHistoryVerbose, ghd2);}, "existing log record found");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Pass null for the only parameter.")]
        public void PassNull(TestNode self)
        {
            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogGamertagHistoryVerbose, null);
                },
                "Null parameter: GamertagHistoryDetails");

            cav.Verify(IsDoubleWrite(self));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupBanHistoryByMachinePuid.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Test for calling the LookupBanHistoryByMachinePuid API. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupBanHistoryByMachinePuid: TestNode
    {
        public static string MachineBanHistoryInfoStringer(MachineBanHistoryInfo info)
        {
            return "MachineBanHistoryInfo(MachinePuid="+string.Format("0x{0:X}", info.MachinePuid)+" EntryDate="+info.EntryDate+" ReasonCode="+string.Format("0x{0:X}", info.ReasonCode)+" BanStart="+info.BanStart+" BanEnd="+info.BanEnd+")";
        }

        public static string MachineBanHistoryInfoStringer(object info)
        {
            if (info is MachineBanHistoryInfo)
            {
                return MachineBanHistoryInfoStringer((MachineBanHistoryInfo)info);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(info);
            }
        }

        public static bool MachineBanHistoryInfoEquals(MachineBanHistoryInfo left, MachineBanHistoryInfo right)
        {
            return left.MachinePuid==right.MachinePuid &&
                System.Math.Abs((left.EntryDate-right.EntryDate).TotalMilliseconds)<10 &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.BanStart-right.BanStart).TotalMilliseconds)<10 &&
                System.Math.Abs((left.BanEnd-right.BanEnd).TotalMilliseconds)<10;
        }

        public static MachineBanHistoryInfo[] LookupBanHistoryByMachinePuidVerbose(Puid machinePuid, DateTime ?since)
        {
            Global.RO.Debug("Calling LookupBanHistoryByMachinePuid: MachinePuid="+machinePuid+", Since="+since);
            MachineBanHistoryInfo[] ret=new XMachineSoapClient().LookupBanHistoryByMachinePuid(machinePuid, since);
            Global.RO.Debug("LookupBanHistoryByMachinePuid returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", MachineBanHistoryInfoStringer));
            return ret;
        }

        public static void VerifyBanHistory(Puid puid, System.DateTime ?expectedSince, MachineBanHistoryInfo[] gottenResults)
        {
            //lookup the actual rows in the db and convert them into MachineBanHistoryInfo, then verify that set matches the result set passed in
            List<MachineBanHistoryInfo> expectedResults=new List<MachineBanHistoryInfo>();
            MachineEditor.MachineBanHistory []allHistories=MachineEditor.FromId(puid).GetAllMachineBanHistories();
            foreach (MachineEditor.MachineBanHistory mbh in allHistories)
            {
                if (expectedSince==null || mbh.ChangeTime>expectedSince)
                {
                    MachineBanHistoryInfo hi=new MachineBanHistoryInfo();
                    hi.MachinePuid=puid;
                    hi.EntryDate=mbh.ChangeTime;
                    hi.ReasonCode=unchecked((uint)mbh.ReasonCode);
                    hi.BanStart=mbh.StartDate;
                    hi.BanEnd=mbh.EndDate;
                    expectedResults.Add(hi);
                }
            }

            Global.RO.Debug(expectedResults.Count+" results expected (based on db).");
            ValueCheck.TestAllUnordered("MachineBanHistoryInfo", expectedResults, gottenResults, MachineBanHistoryInfoEquals, MachineBanHistoryInfoStringer);
        }

        // -----

        [TestGroup]
        public class Xbox360: TestNode
        {
            [TestCase, Description("Machine has no bans, ask since forever."), BVT]
            public void NoBansSinceForever()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                //call the ban api and verify
                System.DateTime ?since=null;
                MachineBanHistoryInfo []ret=LookupBanHistoryByMachinePuidVerbose(puid, since);
                VerifyBanHistory(puid, since, ret);
            }

            [TestCase, Description("Machine has one ban, ask since forever."), BVT]
            public void OneBanSinceForever()
            {
                //create machine and ban
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, System.DateTime.UtcNow, System.DateTime.MaxValue);

                //call the ban api and verify
                System.DateTime ?since=null;
                MachineBanHistoryInfo []ret=LookupBanHistoryByMachinePuidVerbose(puid, since);
                VerifyBanHistory(puid, since, ret);
            }

            [TestCase, Description("Machine has a mixture of bans and unbans for various reasons.")]
            public void MixedBansAndUnbansSinceForever()
            {
                //create machine and ban
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, System.DateTime.UtcNow, System.DateTime.MaxValue);
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000002, System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0), System.DateTime.UtcNow+new System.TimeSpan(7, 0, 0, 0));
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000003, System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0), System.DateTime.MaxValue);

                UnbanMachinePuids.UnbanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001);

                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, System.DateTime.UtcNow+new System.TimeSpan(1, 0, 0, 0), System.DateTime.MaxValue);

                //call the ban api and verify
                System.DateTime ?since=null;
                MachineBanHistoryInfo []ret=LookupBanHistoryByMachinePuidVerbose(puid, since);
                VerifyBanHistory(puid, since, ret);
            }

            [TestCase, Description("Machine has a mixture of bans happening at different change times.")]
            public void MixedBansAndUnbansSinceSpecific()
            {
                //create machine and ban
                ulong puid=XMachineTestUtil.CreateXbox360Machine();

                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, System.DateTime.UtcNow, System.DateTime.MaxValue);
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000002, System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0), System.DateTime.MaxValue);

                System.Threading.Thread.Sleep(5000); //sleep 5 before we add the other row so we can ask for just this time range

                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000003, System.DateTime.UtcNow+new System.TimeSpan(3, 0, 0, 0), System.DateTime.MaxValue);

                //call the ban api and verify
                System.DateTime ?since=System.DateTime.UtcNow-new System.TimeSpan(0, 0, 4);
                MachineBanHistoryInfo []ret=LookupBanHistoryByMachinePuidVerbose(puid, since);
                VerifyBanHistory(puid, since, ret);
            }

            [TestCase, Description("Pass a puid that is not a valid flatform type")]
            public void BadPuidPlatform()
            {
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupBanHistoryByMachinePuidVerbose(0x12345, null);}, "Invalid puid:0x0000000000012345");
            }

            [TestCase, Description("Pass a puid that is not a valid flatform type")]
            public void NonexistantPuid()
            {
                ulong puid=MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupBanHistoryByMachinePuidVerbose(puid, null);}, "Invalid puid:"+string.Format("0x{0:X16}", puid));
            }

            [TestCase, Description("Pass a puid that is not a valid flatform type")]
            public void InvalidSQLDate()
            {
                ulong puid=XMachineTestUtil.CreateXbox360Machine();
                XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupBanHistoryByMachinePuidVerbose(puid, System.DateTime.MinValue);}, "Invalid since:");
            }
        }; //class Xbox360

        [TestGroup]
        public class PC: TestNode
        {
            [TestCase, Description("Machine has no bans, ask since forever.")]
            public void NoBansSinceForever()
            {
                //create machine
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

                //call the ban api and verify
                System.DateTime ?since=null;
                MachineBanHistoryInfo []ret=LookupBanHistoryByMachinePuidVerbose(puid, since);
                VerifyBanHistory(puid, since, ret);
            }

            [TestCase, Description("Machine has one ban, ask since forever.")]
            public void OneBanSinceForever()
            {
                //create machine and ban
                string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
                ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x8015190D, System.DateTime.UtcNow, System.DateTime.MaxValue);

                //call the ban api and verify
                System.DateTime ?since=null;
                MachineBanHistoryInfo []ret=LookupBanHistoryByMachinePuidVerbose(puid, since);
                VerifyBanHistory(puid, since, ret);
            }
        } //class PC

        [TestGroup]
        public class Phone: TestNode
        {
            [TestCase, Description("Machine has no bans, ask since forever.")]
            public void NoBansSinceForever()
            {
                //create machine
                ulong puid=XMachineTestUtil.CreatePhoneMachine();

                //call the ban api and verify
                System.DateTime ?since=null;
                MachineBanHistoryInfo []ret=LookupBanHistoryByMachinePuidVerbose(puid, since);
                VerifyBanHistory(puid, since, ret);
            }

            [TestCase, Description("Machine has one ban, ask since forever.")]
            public void OneBanSinceForever()
            {
                //create machine and ban
                ulong puid=XMachineTestUtil.CreatePhoneMachine();

                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, System.DateTime.UtcNow, System.DateTime.MaxValue);

                //call the ban api and verify
                System.DateTime ?since=null;
                MachineBanHistoryInfo []ret=LookupBanHistoryByMachinePuidVerbose(puid, since);
                VerifyBanHistory(puid, since, ret);
            }
        } //class Phone
    }; //class LookupBanHistoryByMachinePuid
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LogRecoveryHistory.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using xonline.common.config;
using xonline.server.xmachine.fd.soap;

namespace XMachineTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LogRecoveryHistory: DoubleWriteTestGroup
    {
        public static void LogRecoveryHistoryVerbose(RecoveryHistoryDetails rhd)
        {
            Global.RO.Debug("Calling LogRecoveryHistory: rhd="+HistoryCommon.RecoveryHistoryDetailsStringer(rhd));
            new XMachineSoapClient().LogRecoveryHistory(rhd);
            Global.RO.Debug("LogRecoveryHistory returned.");
        }

        public class CallAndVerifier: LogAccumulatorAndCaller<RecoveryHistoryDetails, MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry>
        {
            public override MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry ConvertCallTypeToDbType(RecoveryHistoryDetails log)
            {
                return new MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry
                {
                    UserPuid    =log.UserPuid,
                    MachinePuid =log.MachinePuid,
                    IpAddress   =log.IpAddress,
                    TimeStamp   =log.Timestamp,
                    Hr          =log.HResult,
                    PassportPuid=log.PassportPuid,
                    Reason      =(byte)log.Reason,
                    HashBucket  =-1 //recomputed later to be correct
                };
            }

            public override MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry[] GetActualRowsFromDb(ulong machinePuid, bool hitSecHistoryDbInsteadOfUodb)
            {
                return MachineRecoveryHistoryEditor.FromMachinePuid(machinePuid, hitSecHistoryDbInsteadOfUodb).GetAllHistory();
            }

            public override ulong GetMachinePuid(RecoveryHistoryDetails log)
            {
                return log.MachinePuid;
            }

            public override ulong GetMachinePuid(MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry log)
            {
                return log.MachinePuid;
            }

            public override void SetHashBucket(MachineRecoveryHistoryEditor.MachineRecoveryHistoryEntry log, short bucket)
            {
                log.HashBucket=bucket;
            }
        }

        public static ulong RandomPuid()
        {
            return ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
        }

        public static RecoveryHistoryDetails GenerateDetails(ulong? userPuid, ulong? machinePuid, string ip, System.DateTime timestamp, uint hr, byte reason, ulong passportPuid)
        {
            if (userPuid==null)
            {
                userPuid=UserEditor.CreateNew().Puid;
            }

            if (machinePuid==null)
            {
                machinePuid=MachineEditor.CreateNew().Id;
            }

            return new RecoveryHistoryDetails
            {
                UserPuid=userPuid.Value,
                MachinePuid=machinePuid.Value,
                IpAddress=ip,
                Timestamp=timestamp,
                HResult=hr,
                Reason=reason,
                PassportPuid=passportPuid
            };
        }

        // --

        [TestCase, Description("One simple row with all fields present as normal values.")]
        public void SimpleMainline(TestNode self)
        {
            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogRecoveryHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for UserPuid.")]
        [CompoundCase("0x{0:X}", (ulong)0)]
        [CompoundCase("0x{0:X}", (ulong)1)]
        [CompoundCase("0x{0:X}", (ulong)0xABCD000012340000)]
        [CompoundCase("0x{0:X}", (ulong)0xFFFFFFFFFFFFFFFF)]
        public void VariousUserPuids(TestNode self)
        {
            ulong userPuid=(ulong)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogRecoveryHistoryVerbose, GenerateDetails(userPuid, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for MachinePuid.")]
        [CompoundCase("0x{0:X}", (ulong)0,                  "MachinePuid is invalid: 0x0000000000000000")]
        [CompoundCase("0x{0:X}", (ulong)1,                  "MachinePuid is invalid: 0x0000000000000001")]
        [CompoundCase("0x{0:X}", (ulong)0xABCD000012340000, "MachinePuid is invalid: 0xABCD000012340000")]
        [CompoundCase("0x{0:X}", (ulong)0xFFFFFFFFFFFFFFFF, "MachinePuid is invalid: 0xFFFFFFFFFFFFFFFF")]
        [CompoundCase("0x{0:X}", (ulong)0xFFED0000FFFFFFFF, "MachinePuid is invalid: 0xFFED0000FFFFFFFF")]
        [CompoundCase("0x{0:X}", (ulong)0xFA000000F0000000, "MachinePuid is invalid on lookup: 0xFA000000F0000000")]
        public void VariousInvalidMachinePuids(TestNode self)
        {
            ulong machinePuid=(ulong)self.MyValues[0];
            string expectedSoapError=(string)self.MyValues[1];

            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogRecoveryHistoryVerbose, GenerateDetails(null, machinePuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
                },
                expectedSoapError);

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("One simple row with all fields present as normal values for different platforms.")]
        [CompoundCase("{0}", MachineType.Xbox1)]
        [CompoundCase("{0}", MachineType.Xbox360)]
        [CompoundCase("{0}", MachineType.PC)]
        [CompoundCase("{0}", MachineType.Phone)]
        public void VariousValidMachinePuids(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            ulong mpuid=MachineEditor.CreateNew(mtype).Id;

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogRecoveryHistoryVerbose, GenerateDetails(null, mpuid, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for IpAddress.")]
        [CompoundCase("EmptyString", "")]
        [CompoundCase("null", null)]
        [CompoundCase("{0}", "Not.An.IP.Addy")]
        [CompoundCase("{0}", "Woops")]
        [CompoundCase("SingleDot", ".")]
        [CompoundCase("{0}", "999.999.999.999")]
        [CompoundCase("{0}", "0.0.0.0")]
        [CompoundCase("{0}", "100.002.003.0004")]
        public void VariousIPAddress(TestNode self)
        {
            string ip=(string)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogRecoveryHistoryVerbose, GenerateDetails(null, null, ip, System.DateTime.UtcNow, 0x80000000, 1, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Timestamp.")]
        public class VariousTimestamps: TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                instances.Add(new CompoundCaseAttribute("MaxDotNetDateTime", System.DateTime.MaxValue,                                   null));
                instances.Add(new CompoundCaseAttribute("MinDotNetDateTime", System.DateTime.MinValue,                                   "Invalid timestamp:1/1/0001"));
                instances.Add(new CompoundCaseAttribute("MinSqlDateTime",    (System.DateTime)System.Data.SqlTypes.SqlDateTime.MinValue, null));
            }

            public override void Run()
            {
                System.DateTime timestamp=(System.DateTime)MyValues[0];
                string expectedSoapError=(string)MyValues[1];

                RecoveryHistoryDetails rhd=GenerateDetails(null, null, "1.2.3.4", timestamp, 0x80000000, 1, RandomPuid());

                CallAndVerifier cav=new CallAndVerifier();
                if (expectedSoapError==null)
                {
                    cav.CallAndAccumulate(LogRecoveryHistoryVerbose, rhd);
                }
                else
                {
                    XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                        {
                            cav.CallAndAccumulate(LogRecoveryHistoryVerbose, rhd);
                        },
                        expectedSoapError);
                }
                cav.Verify(IsDoubleWrite(this));
            }
        }

        [TestCase, Description("Various values for HResult.")]
        [CompoundCase("0x{0:X}", (uint)0)]
        [CompoundCase("0x{0:X}", (uint)1)]
        [CompoundCase("0x{0:X}", (uint)0x7fffffff)]
        [CompoundCase("0x{0:X}", (uint)0x80000000)]
        [CompoundCase("0x{0:X}", (uint)0xffffffff)]
        public void VariousHResults(TestNode self)
        {
            uint hresult=(uint)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogRecoveryHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, hresult, 1, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for Reason.")]
        [CompoundCase("0x{0:X}", (byte)0)]
        [CompoundCase("0x{0:X}", (byte)1)]
        [CompoundCase("Max", (byte)99)]
        public void VariousValidReasons(TestNode self)
        {
            byte reason=(byte)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogRecoveryHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, RandomPuid()));
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Values for Reason that are not in t_history_reasons.")]
        [CompoundCase("0x{0:X}", (byte)255)] //passes through protocol but isn't valid
        public void VariousInvalidReasons(TestNode self)
        {
            byte reason=(byte)self.MyValues[0];

            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogRecoveryHistoryVerbose, GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, reason, RandomPuid()));
                },
                "HistoryReason is invalid");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for PassportPuid.")]
        [CompoundCase("PassportPuid=0x{0:X}", (ulong)0xffffffffffffffff)]
        [CompoundCase("PassportPuid=0x{0:X}", (ulong)0x7777777777777777)]
        public void VariousValidPassportPuids(TestNode self)
        {
            ulong ppp=(self.MyValues[0]==null?RandomPuid():(ulong)self.MyValues[0]);

            RecoveryHistoryDetails rhd=GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 0, ppp);

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogRecoveryHistoryVerbose, rhd);
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Various values for PassportPuid.")]
        [CompoundCase("PassportPuid=0x{0:X}", (ulong)0)]
        public void VariousInvalidPassportPuids(TestNode self)
        {
            ulong ppp=(self.MyValues[0]==null?RandomPuid():(ulong)self.MyValues[0]);

            RecoveryHistoryDetails rhd=GenerateDetails(null, null, "1.2.3.4", System.DateTime.UtcNow, 0x80000000, 0, ppp);

            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogRecoveryHistoryVerbose, rhd);
                },
                "PassportPuid is invalid");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log multiple times with the same machine puid.")]
        public void LogMultiple(TestNode self)
        {
            ulong machinePuid=MachineEditor.CreateNew().Id;
            ulong []userPuid=new ulong[]{UserEditor.CreateNew().Puid, UserEditor.CreateNew().Puid};

            CallAndVerifier cav=new CallAndVerifier();
            for (int i=0; i<10; ++i)
            {
                cav.CallAndAccumulate(LogRecoveryHistoryVerbose, GenerateDetails(userPuid[i%2], machinePuid, "1.2.3."+i, System.DateTime.UtcNow-new System.TimeSpan(0, 0, i), (uint)i*10+10, (byte)i, RandomPuid()));
            }
            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Calls log twice with the same machine puid, using the same timestamp for both calls.")]
        [CompoundCase("SameData", true)]
        [CompoundCase("DifferentData", false)]
        public void LogTwoSameMachinesSameTime(TestNode self)
        {
            bool isDataTheSame=(bool)self.MyValues[0];

            ulong machinePuid=MachineEditor.CreateNew().Id;
            System.DateTime now=System.DateTime.UtcNow;
            RecoveryHistoryDetails rhd1=GenerateDetails(null, machinePuid, "1.2.3.4", now, 0x80000000, 1, RandomPuid());
            RecoveryHistoryDetails rhd2=rhd1;

            CallAndVerifier cav=new CallAndVerifier();
            cav.CallAndAccumulate(LogRecoveryHistoryVerbose, rhd1);

            if (!isDataTheSame)
            {
                rhd2=GenerateDetails(null, machinePuid, "1.2.3.5", now, 0x80000001, 2, RandomPuid());
            }

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{cav.CallAndAccumulate(LogRecoveryHistoryVerbose, rhd2);}, "existing log record found");

            cav.Verify(IsDoubleWrite(self));
        }

        [TestCase, Description("Pass null for the only parameter.")]
        public void PassNull(TestNode self)
        {
            CallAndVerifier cav=new CallAndVerifier();

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate
                {
                    cav.CallAndAccumulate(LogRecoveryHistoryVerbose, null);
                },
                "Null parameter: RecoveryHistoryDetails");

            cav.Verify(IsDoubleWrite(self));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupConsoleBansByMachinepuids.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the LookupConsoleBansByMachinePuids API. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupConsoleBansByMachinePuids: TestNode
    {
        /// <summary> Calls the LookupConsoleBansByMachinePuids API and returns its ConsoleBanInfo objects. </summary>
        public static ConsoleBanInfo[] LookupConsoleBansByMachinePuidsVerbose(ulong[] puidList)
        {
            Global.RO.Debug("Calling LookupConsoleBansByMachinePuids: ConsoleIdList={"+StringUtils.MakeCommaSeparatedList(puidList)+"}");
            ConsoleBanInfo []ret=new XMachineSoapClient().LookupConsoleBansByMachinePuids(puidList);

            Global.RO.Debug("ConsoleBanInfos returned: ");
            foreach (ConsoleBanInfo cbi in ret)
            {
                Global.RO.Debug("ConsoleId={0} BanStart={1} BanEnd={2} Reason={3}",
                                    cbi.ConsoleId,
                                    cbi.BanStart,
                                    cbi.BanEnd,
                                    cbi.ReasonCode
                                    );
            }
            return ret;
        }

        /// <summary> Compares a ConsoleBanStatus object containing expected (test generated) values against an API result object. </summary>
        public static void ValidateBanInfoResults(ConsoleBanInfo []results, ConsoleBanEditor.ConsoleBanStatus []expectedResults)
        {
            List<ConsoleBanEditor.ConsoleBanStatus> obtainedResults=new List<ConsoleBanEditor.ConsoleBanStatus>();

            foreach (ConsoleBanInfo consoleInfo in results)
            {
                obtainedResults.Add(new ConsoleBanEditor.ConsoleBanStatus(consoleInfo.ConsoleId, (int)consoleInfo.ReasonCode, consoleInfo.BanStart));
            }

            ValueCheck.Test("The counts of results differed from what was expected.", expectedResults.Length, results.Length);
            foreach (ConsoleBanEditor.ConsoleBanStatus expectedResult in expectedResults)
            {
                bool found=false;
                foreach (ConsoleBanInfo info in results)
                {
                    if (info.ConsoleId==expectedResult.ConsoleId)
                    {
                        ValueCheck.Test("Invalid ban start time:", expectedResult.StartDate, info.BanStart);
                        ValueCheck.Test("Invalid ban end time:", DateTime.MaxValue, info.BanEnd);
                        ValueCheck.Test("Invalid reason code:", (uint)expectedResult.ReasonCode, info.ReasonCode);
                        found=true;
                    }
                }

                if (!found)
                {
                    throw new UnexpectedTestResultException("We could not find a ban for console with console id: "+expectedResult.ConsoleId);
                }
            }
        }

        /// <summary> This returns an array of ConsoleBanStatus objects containing expected results after calling LookupBansByConsoleId. </summary>
        public static ConsoleBanEditor.ConsoleBanStatus[] CreateMachine(bool ban, bool dupe, bool unban, DateTime banStart, uint reason, out ulong machinePuid)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            if (dupe)
            {
                XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId);
            }

            if (ban)
            {
                BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, reason, banStart);
            }

            if (unban)
            {
                UnbanConsoleIds.UnbanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0); //All reasons.
            }

            machinePuid=mach.Id;
            return ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans();
        }

        [TestCase, Description("Looking up some bans. Different combinations of duped, existing, banned and unbanned states."), TestCasePriority(1)]
        [CompoundCase("NotExists_NotBanned_NotDuped_NotUnbanned", false, false, false, false)]
        [CompoundCase("Exists_NotBanned_NotDuped_NotUnbanned",    true,  false, false, false)]
        [CompoundCase("Exists_NotBanned_Duped_NotUnbanned",       true,  false, true,  false)]
        [CompoundCase("Exists_Banned_NotDuped_NotUnbanned",       true,  true,  false, false)]
        [CompoundCase("Exists_Banned_NotDuped_Unbanned",          true,  true,  false, true)]
        [CompoundCase("Exists_Banned_Duped_NotUnbanned",          true,  true,  true,  false)]
        [CompoundCase("Exists_Banned_Duped_Unbanned",             true,  true,  true,  true)]
        public void LookupConsoleBans(TestNode self)
        {
            ConsoleBanEditor.ConsoleBanStatus[] expectedResults;
            bool machineExists=(bool)self.MyValues[0];
            bool consoleBanned=(bool)self.MyValues[1];
            bool consoleDuped=(bool)self.MyValues[2];
            bool consoleUnbanned=(bool)self.MyValues[3];
            ulong machinePuid;

            DateTime now=DateTime.UtcNow;
            expectedResults=CreateMachine(consoleBanned, consoleDuped, consoleUnbanned, now, 0x80000001, out machinePuid);

            if (!machineExists)
            {
                machinePuid=MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
            }

            ConsoleBanInfo []res=LookupConsoleBansByMachinePuidsVerbose(new ulong[]{machinePuid});

            ValidateBanInfoResults(res, expectedResults);
        }

        [TestCase, Description("Looking up multiple bans."), TestCasePriority(1)]
        [CompoundCase("1", 1)]
        [CompoundCase("2", 2)]
        [CompoundCase("10", 10)]
        [CompoundCase("100", 100)]
        public void LookupMultipleConsoleBans(TestNode self)
        {
            List<ConsoleBanEditor.ConsoleBanStatus> expectedResults=new List<ConsoleBanEditor.ConsoleBanStatus>();
            List<ulong> machineIds=new List<ulong>();
            int banCount=(int)self.MyValues[0];

            for (int k=0; k<banCount; ++k)
            {
                ulong machinePuid;
                expectedResults.AddRange(CreateMachine(true, false, false, DateTime.UtcNow, 0x80000001, out machinePuid));
                machineIds.Add(machinePuid);
            }

            ConsoleBanInfo []res=LookupConsoleBansByMachinePuidsVerbose(machineIds.ToArray());

            ValidateBanInfoResults(res, expectedResults.ToArray());
        }

        [TestCase, Description("Expired ban"), TestCasePriority(1)]
        public void LookupExpiredBan()
        {
            DateTime banStart=DateTime.UtcNow.AddDays(-600);
            DateTime banEnd=DateTime.UtcNow.AddDays(-300);

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            ConsoleBanInfo []res=LookupConsoleBansByMachinePuidsVerbose(new ulong[]{mach.Id});
            ValidateBanInfoResults(res, ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans());
        }

        [TestCase, Description("Expired ban"), TestCasePriority(1)]
        public void LookupFutureBan()
        {
            DateTime banStart=DateTime.UtcNow.AddDays(300);
            DateTime banEnd=DateTime.UtcNow.AddDays(600);

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            ConsoleBanInfo []res=LookupConsoleBansByMachinePuidsVerbose(new ulong[]{mach.Id});
            ValidateBanInfoResults(res, ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans());
        }

        [TestCase, Description("Null console id array"), TestCasePriority(2)]
        public void LookupBansNull(TestNode self)
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupConsoleBansByMachinePuidsVerbose(null);}, "Null array");
        }

        [TestCase, Description("Empty console id array"), TestCasePriority(2)]
        public void LookupBansEmptyArray(TestNode self)
        {
            ConsoleBanInfo []ret=LookupConsoleBansByMachinePuidsVerbose(new ulong[]{});
            ValueCheck.Test("Number of results returned", 0, ret.Length);
        }

        [TestCase, Description("Phone test case."), TestCasePriority(2)]
        public void LookupPhone(TestNode self)
        {
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            MachineEditor mach=MachineEditor.FromId(puid);
            ConsoleBanInfo []res=LookupConsoleBansByMachinePuidsVerbose(new ulong[]{mach.Id});

            ValidateBanInfoResults(res, ConsoleBanEditor.FromConsoleId(mach.ConsoleId).GetAllConsoleBans());
        }

        [TestCase, Description("Look for a PC console id ban"), TestCasePriority(2)]
        public void LookupConsoleBansPC(TestNode self)
        {
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte[] voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);
            ulong puidA=XMachineTestUtil.CreatePCMachine(voucherA);
            string cidA=MachineEditor.FromId(puidA).ConsoleId;

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHashA});

            List<ConsoleBanEditor.ConsoleBanStatus> banList=new List<ConsoleBanEditor.ConsoleBanStatus>();
            banList.Add(new ConsoleBanEditor.ConsoleBanStatus(cidA, unchecked((int)0x8015190d), DateTime.UtcNow));

            ConsoleBanInfo[] res=LookupConsoleBansByMachinePuidsVerbose(new ulong[]{puidA});
            ValidateBanInfoResults(res, ConsoleBanEditor.FromConsoleId(cidA).GetAllConsoleBans());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupGamertagHistoryByMachinePuid.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupGamertagHistoryByMachinePuid: DoubleWriteTestGroup
    {
        public static GamertagHistory LookupGamertagHistoryByMachinePuidVerbose(Puid machinePuid, Puid? userPuid, DateTime? since, bool details)
        {
            Global.RO.Debug("Calling LookupGamertagHistoryByMachinePuid: MachinePuid="+machinePuid+", UserPuid="+userPuid+", Since="+since+", Details="+details);
            GamertagHistory ret=new XMachineSoapClient().LookupGamertagHistoryByMachinePuid((ulong)machinePuid, (ulong?)userPuid, since, details);
            Global.RO.Debug("LookupGamertagHistoryByMachinePuid returned: "+HistoryCommon.GamertagHistoryStringer(ret));
            return ret;
        }

        public static void ComputeAndVerifyGamertagHistory(Puid machinePuid, Puid? userPuid, System.DateTime ?since, bool details, GamertagHistory gottenResult, bool isSecMHDB)
        {
            //lookup the actual rows in the db and convert them into a GamertagHistory that contains the expected result
            GamertagHistory expectedResult=new GamertagHistory();

            MachineGamertagHistoryEditor.MachineGamertagHistoryEntry []allHistories=MachineGamertagHistoryEditor.FromMachinePuid(machinePuid, isSecMHDB).GetAllHistory();
            HashSet<ulong> uniqueUsers=new HashSet<ulong>();
            int totalEntries=0;
            System.DateTime ?first=null;
            System.DateTime ?last=null;
            List<GamertagHistoryDetails> detailsExpectedInResult=new List<GamertagHistoryDetails>();
            foreach (MachineGamertagHistoryEditor.MachineGamertagHistoryEntry entry in allHistories)
            {
                if (since==null || entry.TimeStamp>=since)
                {
                    if (userPuid==null || userPuid==entry.UserPuid)
                    {
                        ++totalEntries;

                        if (first==null || first>entry.TimeStamp)
                        {
                            first=entry.TimeStamp;
                        }

                        if (last==null || last<entry.TimeStamp)
                        {
                            last=entry.TimeStamp;
                        }

                        if (!uniqueUsers.Contains(entry.UserPuid))
                        {
                            uniqueUsers.Add(entry.UserPuid);
                        }

                        if (details)
                        {
                            GamertagHistoryDetails detail=new GamertagHistoryDetails();
                            detail.MachinePuid=machinePuid;
                            detail.UserPuid=entry.UserPuid;
                            detail.IpAddress=entry.IpAddress;
                            detail.Timestamp=entry.TimeStamp;
                            detail.HResult=entry.Hr;
                            detail.Reason=entry.Reason;
                            detail.OldGamertag=entry.OldGamertag;
                            detail.NewGamertag=entry.NewGamertag;
                            detailsExpectedInResult.Add(detail);
                        }
                    }
                }
            }

            expectedResult.Total=totalEntries;
            expectedResult.Unique=uniqueUsers.Count;
            expectedResult.First=first;
            expectedResult.Last=last;
            expectedResult.Details=detailsExpectedInResult.ToArray();
            if (!details)
            {
                expectedResult.Details=null;
            }

            //Verify
            HistoryCommon.VerifyGamertagHistory(expectedResult, gottenResult);
        }

        public static void CallAndVerify(Puid machinePuid, Puid? userPuid, System.DateTime ?since, bool details, bool isSecMHDB)
        {
            GamertagHistory ret=LookupGamertagHistoryByMachinePuidVerbose(machinePuid, userPuid, since, details);
            ComputeAndVerifyGamertagHistory(machinePuid, userPuid, since, details, ret, isSecMHDB);
        }

        // -----

        [TestCase, Description("One simple row is placed only in the relevent database.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithUserPuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoUserPuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("WithUserPuid WithDate NoDetails",   true,  true,  false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithUserPuid NoDate WithDetails",   true,  false, true)]
        [CompoundCase("NoUserPuid WithDate WithDetails",   false, true,  true)]
        [CompoundCase("WithUserPuid WithDate WithDetails", true,  true,  true)]
        public void SimpleOneRow(TestNode self)
        {
            bool useSecMHDB=!IsDoubleWrite(self);
            bool passUserPuid=(bool)self.MyValues[0];
            bool passPastDate=(bool)self.MyValues[1];
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachineGamertagHistoryEditor mghe=MachineGamertagHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, "Oldy", "Newy", 1, useSecMHDB));

            ulong ?userPuid=(passUserPuid?(ulong?)user.Puid:(ulong?)null);
            System.DateTime ?sinceDate=(passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestCase, Description("Two simple rows are placed in the database with different dates.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",           false, null, false)]
        [CompoundCase("NoUserPuid DateAfterAll NoDetails",     false, 0,    false)]
        [CompoundCase("NoUserPuid DateAfterOne NoDetails",     false, 2,    false)]
        [CompoundCase("NoUserPuid DateAfterTwo NoDetails",     false, 4,    false)]
        [CompoundCase("WithUserPuid NoDate NoDetails",         true,  null, false)]
        [CompoundCase("WithUserPuid DateAfterAll NoDetails",   true,  0,    false)]
        [CompoundCase("WithUserPuid DateAfterOne NoDetails",   true,  2,    false)]
        [CompoundCase("WithUserPuid DateAfterTwo NoDetails",   true,  4,    false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",         false, null, true)]
        [CompoundCase("NoUserPuid DateAfterAll WithDetails",   false, 0,    true)]
        [CompoundCase("NoUserPuid DateAfterOne WithDetails",   false, 2,    true)]
        [CompoundCase("NoUserPuid DateAfterTwo WithDetails",   false, 4,    true)]
        [CompoundCase("WithUserPuid NoDate WithDetails",       true,  null, true)]
        [CompoundCase("WithUserPuid DateAfterAll WithDetails", true,  0,    true)]
        [CompoundCase("WithUserPuid DateAfterOne WithDetails", true,  2,    true)]
        [CompoundCase("WithUserPuid DateAfterTwo WithDetails", true,  4,    true)]
        public void TwoRowsDifferentDates(TestNode self)
        {
            System.DateTime now=System.DateTime.UtcNow;
            bool useSecMHDB=!IsDoubleWrite(self);
            bool passUserPuid=(bool)self.MyValues[0];
            System.TimeSpan ?dateMod=(self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachineGamertagHistoryEditor mghe=MachineGamertagHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", now-new System.TimeSpan(0, 0, 1), 0x80000007, "OldyA", "NewyA", 1, useSecMHDB));
            mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(user.Puid, mach.Id, "4.3.2.1", now-new System.TimeSpan(0, 0, 3), 0x80000006, "OldyB", "NewyB", 2, useSecMHDB));

            ulong ?userPuid=(passUserPuid?(ulong?)user.Puid:(ulong?)null);
            System.DateTime ?sinceDate=(dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestCase, Description("Three simple rows spanning two users are placed only in the relevent database.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",         null, null, false)]
        [CompoundCase("UserA NoDate NoDetails",              0,    null, false)]
        [CompoundCase("UserB NoDate NoDetails",              1,    null, false)]
        [CompoundCase("NoUserPuid DateAfterOne NoDetails",   null, 2,    false)]
        [CompoundCase("UserA DateAfterOne NoDetails",        0,    2,    false)]
        [CompoundCase("UserB DateAfterOne NoDetails",        1,    2,    false)]
        [CompoundCase("NoUserPuid DateAfterTwo NoDetails",   null, 4,    false)]
        [CompoundCase("UserA DateAfterTwo NoDetails",        0,    4,    false)]
        [CompoundCase("UserB DateAfterTwo NoDetails",        1,    4,    false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",       null, null, true)]
        [CompoundCase("UserA NoDate WithDetails",            0,    null, true)]
        [CompoundCase("UserB NoDate WithDetails",            1,    null, true)]
        [CompoundCase("NoUserPuid DateAfterOne WithDetails", null, 2,    true)]
        [CompoundCase("UserA DateAfterOne WithDetails",      0,    2,    true)]
        [CompoundCase("UserB DateAfterOne WithDetails",      1,    2,    true)]
        [CompoundCase("NoUserPuid DateAfterTwo WithDetails", null, 4,    true)]
        [CompoundCase("UserA DateAfterTwo WithDetails",      0,    4,    true)]
        [CompoundCase("UserB DateAfterTwo WithDetails",      1,    4,    true)]
        public void ThreeRowsTwoUsersDifferentDates(TestNode self)
        {
            System.DateTime now=System.DateTime.UtcNow;
            bool useSecMHDB=!IsDoubleWrite(self);
            int ?passUserPuid=(self.MyValues[0]!=null?(int)self.MyValues[0]:(int?)null);
            System.TimeSpan ?dateMod=(self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor []users=new UserEditor[]{UserEditor.CreateNew(), UserEditor.CreateNew()};
            MachineEditor mach=MachineEditor.CreateNew();

            MachineGamertagHistoryEditor mghe=MachineGamertagHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(users[0].Puid, mach.Id, "1.2.3.1", now-new System.TimeSpan(0, 0, 1), 0x80000007, "OldyA", "NewyC", 1, useSecMHDB));
            mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(users[0].Puid, mach.Id, "1.2.3.2", now-new System.TimeSpan(0, 0, 5), 0x80000006, "OldyA", "NewyD", 2, useSecMHDB));
            mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(users[1].Puid, mach.Id, "1.2.3.3", now-new System.TimeSpan(0, 0, 3), 0x80000005, "OldyB", "NewyE", 3, useSecMHDB));

            ulong ?userPuid=(passUserPuid!=null?users[(int)passUserPuid].Puid:(ulong?)null);
            System.DateTime ?sinceDate=(dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestCase, Description("No rows for the machine.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithUserPuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoUserPuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithUserPuid WithDate WithDetails", true,  true,  true)]
        public void NoRows(TestNode self)
        {
            bool useSecMHDB=!IsDoubleWrite(self);
            bool passUserPuid=(bool)self.MyValues[0];
            bool passPastDate=(bool)self.MyValues[1];
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            ulong ?userPuid=(passUserPuid?(ulong?)user.Puid:(ulong?)null);
            System.DateTime ?sinceDate=(passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestGroup]
        public class WeirdValuesInDB: TestNode
        {
            //Machine puids have a foreign key constraint in UODB.

            [TestCase, Description("Weird user puids.")]
            [CompoundCase("0x{0:X}", (ulong)0)]
            [CompoundCase("0x{0:X}", (ulong)1)]
            [CompoundCase("0x{0:X}", (ulong)0xffffffffffffffff)]
            [CompoundCase("0x{0:X}", (ulong)0xfa00000000000000)]
            public void UserPuids(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                ulong userPuid=(ulong)self.MyValues[0];

                MachineEditor mach=MachineEditor.CreateNew();

                MachineGamertagHistoryEditor mghe=MachineGamertagHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(userPuid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, "Oldy", "Newy", 1, useSecMHDB));

                CallAndVerify(mach.Id, userPuid, null, true, useSecMHDB);
            }

            [TestCase, Description("Weird IP addresses.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("{0}", "Not.An.IP.Addr")]
            [CompoundCase("{0}", "Woops")]
            [CompoundCase("SingleDot", ".")]
            [CompoundCase("{0}", "999.999.999.999")]
            [CompoundCase("{0}", "0.0.0.0")]
            [CompoundCase("{0}", "100.002.003.0004")]
            public void IPAddress(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                string ipAddress=(string)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachineGamertagHistoryEditor mghe=MachineGamertagHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(user.Puid, mach.Id, ipAddress, System.DateTime.UtcNow, 0x80000007, "Oldy", "Newy", 1, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }

            [TestCase, Description("Different reasons.")]
            [CompoundCase("{0}", (byte)0)]
            [CompoundCase("{0}", (byte)1)]
            [CompoundCase("Max", (byte)99)]
            public void Reasons(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                byte reason=(byte)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachineGamertagHistoryEditor mghe=MachineGamertagHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, "Oldy", "Newy", reason, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }

            [TestCase, Description("Weird gamertags.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("MaxSize", "STFU0123456789AB")]
            //[CompoundCase("NullChar", "\0")]  //This is just a little too evil.  Requires some unusually bad data to be placed in the database manually.
            public void Gamertags(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                string gamertags=(string)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachineGamertagHistoryEditor mghe=MachineGamertagHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(user.Puid, mach.Id, "123.234.120.210", System.DateTime.UtcNow, 0x80000007, gamertags, gamertags, 1, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }
        }

        [TestCase, Description("There are 1000 rows for a single machine to be returned.")]
        public void OneThousandRows(TestNode self)
        {
            bool useSecMHDB=!IsDoubleWrite(self);

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachineGamertagHistoryEditor mghe=MachineGamertagHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            for (int i=0; i<1000; ++i)
            {
                mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0x80000007, "Oldy"+i, "Newy"+(i+1), (byte)(i%10+1), useSecMHDB));
            }

            CallAndVerify(mach.Id, null, null, true, useSecMHDB);
        }

        [TestCase, Description("Tests for what happens to older clients when another value is added in the future.")]
        public class ReasonEnumIsExpandedInTheFuture: TestNode
        {
            public override void PreRun()
            {
                //Add a "future" value to the database to simulate what will happen when a new reason is added in the future.
                WebstoreDB.ExecuteSQLNonQuery(xonline.common.config.ConfigUtil.SecMachineHistoryWebstoreApp, "if ((select count(*) from t_history_reason where ti_reason=128)=0) begin insert into t_history_reason (ti_reason, vc_friendly_name) values (128, 'Test Future Value') end", null);

                //In the future when this data is migrated out of UODB completely, delete this copy:
                UodbWS.ExecuteSQLNonQuery("if ((select count(*) from t_history_reason where ti_reason=128)=0) begin insert into t_history_reason (ti_reason, vc_friendly_name) values (128, 'Test Future Value') end", null);
            }

            public override void Run()
            {
                bool useSecMHDB=!IsDoubleWrite(this);

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachineGamertagHistoryEditor mghe=MachineGamertagHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachineGamertagHistoryEditor.MachineGamertagHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, "Oldy", "Newy", 128, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupMachineBansByConsoleIds.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the LookupMachineBansByConsoleIds API. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupMachineBansByConsoleIds: TestNode
    {
        /// <summary> Calls the LookupMachineBansByConsoleIds API and returns its result object. </summary>
        public static MachineBanInfo[] LookupMachineBansByConsoleIdsVerbose(string []consoleIdList)
        {
            Global.RO.Debug("Calling LookupMachineBansByConsoleIds: consoleIdList={"+StringUtils.MakeCommaSeparatedList(consoleIdList)+"}");
            MachineBanInfo []ret=new XMachineSoapClient().LookupMachineBansByConsoleIds(consoleIdList);

            Global.RO.Debug("MachineBans returned:");
            foreach (MachineBanInfo mbi in ret)
            {
                Global.RO.Debug("MachinePuid={0} ConsoleId={1} BanStart={2} BanEnd={3} Reason={4}",
                                    mbi.MachinePuid,
                                    mbi.ConsoleId,
                                    mbi.BanStart,
                                    mbi.BanEnd,
                                    mbi.ReasonCode
                                    );
            }

            return ret;
        }

        public static string MachineBanInfoStringer(MachineBanInfo result)
        {
            return "MachineBanInfo(MachinePuid="+string.Format("0x{0:X}", result.MachinePuid)+" ConsoleId="+result.ConsoleId+" ReasonCode="+string.Format("0x{0:X}", result.ReasonCode)+" BanStart="+result.BanStart+" BanEnd="+result.BanEnd+")";
        }

        public static string MachineBanInfoStringer(object result)
        {
            if (result is MachineBanInfo)
            {
                return MachineBanInfoStringer((MachineBanInfo)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static bool MachineBanInfoEquals(MachineBanInfo left, MachineBanInfo right)
        {
            return left.MachinePuid==right.MachinePuid &&
                left.ConsoleId==right.ConsoleId &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.BanStart-right.BanStart).TotalMilliseconds)<10 &&
                System.Math.Abs((left.BanEnd-right.BanEnd).TotalMilliseconds)<10;
        }

        public static MachineEditor CreateBanned360(DateTime banStart, DateTime banEnd)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{mach.Id}, 0x80000001, banStart, banEnd);
            return mach;
        }

        /// <summary> Compares a MachineBanStatus object containing expected values against an API result object. </summary>
        public static void ValidateBanInfoResults(MachineBanInfo []results, MachineEditor.MachineBanStatus []expectedResults)
        {
            List<MachineBanInfo> realExpectedResults=new List<MachineBanInfo>();
            foreach (MachineEditor.MachineBanStatus mbs in expectedResults)
            {
                MachineBanInfo mbi=new MachineBanInfo();
                mbi.MachinePuid=mbs.MachineId;
                mbi.ConsoleId=MachineEditor.FromId(mbs.MachineId).ConsoleId;
                mbi.ReasonCode=unchecked((uint)mbs.ReasonCode);
                mbi.BanStart=mbs.StartDate;
                mbi.BanEnd=mbs.EndDate;
                realExpectedResults.Add(mbi);
            }

            ValueCheck.TestAllUnordered("MachineBanInfo returned", realExpectedResults, results, MachineBanInfoEquals, MachineBanInfoStringer);
        }

        /// <summary> This returns an array of MachineBanStatus objects containing expected results after calling LookupMachineBansByMachinePuids. </summary>
        public static MachineEditor.MachineBanStatus[] CreateMachine(bool ban, bool dupe, bool unban, DateTime banStart, uint reason, out string consoleId)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            if (dupe)
            {
                XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId);
            }

            if (ban)
            {
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{mach.Id}, reason, banStart, banStart.AddYears(1)); //1 year ban.
            }

            if (unban)
            {
                UnbanMachinePuids.UnbanMachinePuidsVerbose(new ulong[]{mach.Id}, 0);
            }

            consoleId=mach.ConsoleId;
            return MachineEditor.FromId(mach.Id).GetAllMachineBans();
        }

        [TestCase, Description("Looking up some bans. Different combinations of duped, existing, banned and unbanned states."), TestCasePriority(1)]
        [CompoundCase("NotExists_NotBanned_NotDuped_NotUnbanned", false, false, false, false)]
        [CompoundCase("Exists_NotBanned_NotDuped_NotUnbanned",    true,  false, false, false)]
        [CompoundCase("Exists_NotBanned_Duped_NotUnbanned",       true,  false, true,  false)]
        [CompoundCase("Exists_Banned_NotDuped_NotUnbanned",       true,  true,  false, false)]
        [CompoundCase("Exists_Banned_NotDuped_Unbanned",          true,  true,  false, true)]
        [CompoundCase("Exists_Banned_Duped_NotUnbanned",          true,  true,  true,  false)]
        [CompoundCase("Exists_Banned_Duped_Unbanned",             true,  true,  true,  true)]
        public void LookupMachineBans(TestNode self)
        {
            MachineEditor.MachineBanStatus []expectedResults;
            bool machineExists=(bool)self.MyValues[0];
            bool machineBanned=(bool)self.MyValues[1];
            bool machineDuped=(bool)self.MyValues[2];
            bool machineUnbanned=(bool)self.MyValues[3];

            string consoleId;

            DateTime now=DateTime.UtcNow;
            expectedResults=CreateMachine(machineBanned, machineDuped, machineUnbanned, now, 0x80000001, out consoleId);

            if (!machineExists)
            {
                consoleId=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            }

            MachineBanInfo []res=LookupMachineBansByConsoleIdsVerbose(new string[]{consoleId});

            ValidateBanInfoResults(res, expectedResults);
        }

        [TestCase, Description("Looking up some bans. In this case both the original and dupe are banned."), TestCasePriority(1)]
        public void LookupDoubleMachineBans(TestNode self)
        {
            List<MachineEditor.MachineBanStatus> expectedBanList=new List<MachineEditor.MachineBanStatus>();

            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            MachineEditor dupe=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId));

            MachineBanInfo []res=LookupMachineBansByConsoleIdsVerbose(new string[]{mach.ConsoleId});

            expectedBanList.AddRange(mach.GetAllMachineBans());
            expectedBanList.AddRange(dupe.GetAllMachineBans());

            ValidateBanInfoResults(res, expectedBanList.ToArray());
        }

        [TestCase, Description("Looking up multiple bans."), TestCasePriority(1)]
        [CompoundCase("1", 1)]
        [CompoundCase("2", 2)]
        [CompoundCase("10", 10)]
        [CompoundCase("100", 100)]
        public void LookupMultipleMachineBans(TestNode self)
        {
            List<MachineEditor.MachineBanStatus> expectedResults=new List<MachineEditor.MachineBanStatus>();
            List<string> machineIds=new List<string>();
            int banCount=(int)self.MyValues[0];

            for (int k=0; k<banCount; ++k)
            {
                string consoleId;
                DateTime now=DateTime.UtcNow;
                expectedResults.AddRange(CreateMachine(true, false, false, now, 0x80000001, out consoleId));
                machineIds.Add(consoleId);
            }

            MachineBanInfo []res=LookupMachineBansByConsoleIdsVerbose(machineIds.ToArray());

            ValidateBanInfoResults(res, expectedResults.ToArray());
        }

        [TestCase, Description("Null machinePuid array"), TestCasePriority(2)]
        public void LookupMachineBansNull(TestNode self)
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachineBansByConsoleIdsVerbose(null);}, "Null array:");
        }

        [TestCase, Description("Empty machinePuid array"), TestCasePriority(2)]
        public void LookupMachineBansEmptyArray(TestNode self)
        {
            MachineBanInfo []res=LookupMachineBansByConsoleIdsVerbose(new string[]{});
        }

        [TestCase, Description("Expired ban"), TestCasePriority(1)]
        public void LookupExpiredBan()
        {
            //600 days ago he got banned, 300 days ago unbanned.
            DateTime banStart=DateTime.UtcNow.AddDays(-600);
            DateTime banEnd=DateTime.UtcNow.AddDays(-300);

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            MachineBanInfo []res=LookupMachineBansByConsoleIdsVerbose(new string[]{mach.ConsoleId});
            ValidateBanInfoResults(res, mach.GetAllMachineBans());
        }

        [TestCase, Description("Pending ban"), TestCasePriority(1)]
        public void LookupFutureBan()
        {
            //This ban hasn't happened yet.
            DateTime banStart=DateTime.UtcNow.AddDays(300);
            DateTime banEnd=DateTime.UtcNow.AddDays(600);

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            MachineBanInfo []res=LookupMachineBansByConsoleIdsVerbose(new string[]{mach.ConsoleId});
            ValidateBanInfoResults(res, mach.GetAllMachineBans());
        }

        [TestCase, Description("Look for a PC machine ban"), TestCasePriority(2)]
        public void LookupBansPC(TestNode self)
        {
            //create voucher + machine and bans it
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte[] voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);
            string cid=MachineEditor.FromId(puid).ConsoleId;

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});

            MachineBanInfo []res=LookupMachineBansByConsoleIdsVerbose(new string[]{cid});

            ValidateBanInfoResults(res, MachineEditor.FromId(puid).GetAllMachineBans());
        }

        [TestCase, Description("Look for a PC machine ban"), TestCasePriority(2)]
        public void LookupBansPhone(TestNode self)
        {
            //create voucher + machine and bans it
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            string cid=MachineEditor.FromId(puid).ConsoleId;

            BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, DateTime.UtcNow, DateTime.MaxValue);

            MachineBanInfo []res=LookupMachineBansByConsoleIdsVerbose(new string[]{cid});
            ValidateBanInfoResults(res, MachineEditor.FromId(puid).GetAllMachineBans());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupMachineBansByMachinePuids.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the LookupMachineBansByMachinePuids API. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupMachineBansByMachinePuids: TestNode
    {
        /// <summary> Calls the LookupBansByMachinePuids API and returns its result object. </summary>
        public static MachineBanInfo[] LookupMachineBansByMachinePuidsVerbose(ulong []machinePuidsList)
        {
            Global.RO.Debug("Calling LookupBansByMachinePuids: machinePuidsList={"+StringUtils.MakeCommaSeparatedList(machinePuidsList)+"}");
            MachineBanInfo []ret=new XMachineSoapClient().LookupMachineBansByMachinePuids(machinePuidsList);

            Global.RO.Debug("MachineBans returned:");
            foreach (MachineBanInfo mbi in ret)
            {
                Global.RO.Debug("MachinePuid={0} ConsoleId={1} BanStart={2} BanEnd={3} Reason={4}",
                                    mbi.MachinePuid,
                                    mbi.ConsoleId,
                                    mbi.BanStart,
                                    mbi.BanEnd,
                                    mbi.ReasonCode
                                    );
            }

            return ret;
        }

        /// <summary> This returns an array of MachineBanStatus objects containing expected results after calling LookupMachineBansByMachinePuids. </summary>
        public static MachineEditor.MachineBanStatus[] CreateMachine(bool ban, bool dupe, bool unban, DateTime banStart, uint reason, out ulong machinePuid)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            if (dupe)
            {
                XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId);
            }

            if (ban)
            {
                BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{mach.Id}, reason, banStart, banStart.AddYears(1)); //1 year ban.
            }

            if (unban)
            {
                UnbanMachinePuids.UnbanMachinePuidsVerbose(new ulong[]{mach.Id}, 0);
            }

            machinePuid=mach.Id;
            return MachineEditor.FromId(mach.Id).GetAllMachineBans();
        }

        [TestCase, Description("Looking up some bans. Different combinations of duped, existing, banned and unbanned states."), TestCasePriority(1)]
        [CompoundCase("NotExists_NotBanned_NotDuped_NotUnbanned", false, false, false, false)]
        [CompoundCase("Exists_NotBanned_NotDuped_NotUnbanned",    true,  false, false, false)]
        [CompoundCase("Exists_NotBanned_Duped_NotUnbanned",       true,  false, true,  false)]
        [CompoundCase("Exists_Banned_NotDuped_NotUnbanned",       true,  true,  false, false)]
        [CompoundCase("Exists_Banned_NotDuped_Unbanned",          true,  true,  false, true)]
        [CompoundCase("Exists_Banned_Duped_NotUnbanned",          true,  true,  true,  false)]
        [CompoundCase("Exists_Banned_Duped_Unbanned",             true,  true,  true,  true)]
        public void LookupMachineBans(TestNode self)
        {
            MachineEditor.MachineBanStatus []expectedResults;
            bool machineExists=(bool)self.MyValues[0];
            bool machineBanned=(bool)self.MyValues[1];
            bool machineDuped=(bool)self.MyValues[2];
            bool machineUnbanned=(bool)self.MyValues[3];

            ulong machineId;

            DateTime now=DateTime.UtcNow;
            expectedResults=CreateMachine(machineBanned, machineDuped, machineUnbanned, now, 0x80000001, out machineId);

            if (!machineExists)
            {
                machineId=MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
            }

            MachineBanInfo []res=LookupMachineBansByMachinePuidsVerbose(new ulong[]{machineId});

            LookupMachineBansByConsoleIds.ValidateBanInfoResults(res, expectedResults);
        }

        [TestCase, Description("Looking up multiple bans."), TestCasePriority(1)]
        [CompoundCase("1", 1)]
        [CompoundCase("2", 2)]
        [CompoundCase("10", 10)]
        [CompoundCase("100", 100)]
        public void LookupMultipleMachineBans(TestNode self)
        {
            List<MachineEditor.MachineBanStatus> expectedResults=new List<MachineEditor.MachineBanStatus>();
            List<ulong> machineIds=new List<ulong>();
            int banCount=(int)self.MyValues[0];

            for (int k=0; k<banCount; ++k)
            {
                ulong machineId;
                DateTime now=DateTime.UtcNow;
                expectedResults.AddRange(CreateMachine(true, false, false, now+new System.TimeSpan(k, 0, 0), 0x80000001, out machineId));
                machineIds.Add(machineId);
            }

            MachineBanInfo []res=LookupMachineBansByMachinePuidsVerbose(machineIds.ToArray());

            LookupMachineBansByConsoleIds.ValidateBanInfoResults(res, expectedResults.ToArray());
        }

        [TestCase, Description("Null machinePuid array"), TestCasePriority(2)]
        public void LookupMachineBansNull(TestNode self)
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachineBansByMachinePuidsVerbose(null);}, "Null array:");
        }

        [TestCase, Description("Empty machinePuid array"), TestCasePriority(2)]
        public void LookupMachineBansEmptyArray(TestNode self)
        {
            MachineBanInfo []res=LookupMachineBansByMachinePuidsVerbose(new ulong[]{});
        }

        [TestCase, Description("Expired ban"), TestCasePriority(1)]
        public void LookupExpiredBan()
        {
            //600 days ago he got banned, 300 days ago unbanned.
            DateTime banStart=DateTime.UtcNow.AddDays(-600);
            DateTime banEnd=DateTime.UtcNow.AddDays(-300);

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            MachineBanInfo []res=LookupMachineBansByMachinePuidsVerbose(new ulong[]{mach.Id});
            LookupMachineBansByConsoleIds.ValidateBanInfoResults(res, mach.GetAllMachineBans());
        }

        [TestCase, Description("Pending ban"), TestCasePriority(1)]
        public void LookupFutureBan()
        {
            //This ban hasn't happened yet.
            DateTime banStart=DateTime.UtcNow.AddDays(300);
            DateTime banEnd=DateTime.UtcNow.AddDays(600);

            MachineEditor mach=LookupMachineBansByConsoleIds.CreateBanned360(banStart, banEnd);
            MachineBanInfo []res=LookupMachineBansByMachinePuidsVerbose(new ulong[]{mach.Id});
            LookupMachineBansByConsoleIds.ValidateBanInfoResults(res, mach.GetAllMachineBans());
        }

        [TestCase, Description("Look for a PC machine ban"), TestCasePriority(2)]
        public void LookupBansPC(TestNode self)
        {
            //create voucher + machine and bans it
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);
            string cid=MachineEditor.FromId(puid).ConsoleId;

            BanPcTokens.BanPcTokensVerbose(new byte[][]{voucherHash});

            MachineBanInfo []ret=LookupMachineBansByMachinePuidsVerbose(new ulong[]{puid});
            LookupMachineBansByConsoleIds.ValidateBanInfoResults(ret, MachineEditor.FromId(puid).GetAllMachineBans());
        }

        [TestCase, Description("Look for a PC machine ban"), TestCasePriority(2)]
        public void LookupBansPhone(TestNode self)
        {
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            string cid=MachineEditor.FromId(puid).ConsoleId;

            BanMachinePuids.BanMachinePuidsVerbose(new ulong[]{puid}, 0x80000001, DateTime.UtcNow, DateTime.MaxValue);
            MachineBanInfo []ret=LookupMachineBansByMachinePuidsVerbose(new ulong[]{puid});
            LookupMachineBansByConsoleIds.ValidateBanInfoResults(ret, MachineEditor.FromId(puid).GetAllMachineBans());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupConsoleIdsByMachinePuids.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Test for calling the LookupConsoleIdsByMachinePuids. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupConsoleIdsByMachinePuids: TestNode
    {
        #region Helpers

        /// <summary> Calls the LookupConsoleIdsByMachinePuids API and returns its result object. </summary>
        public static MachinePuidInfo[] LookupConsoleIdsVerbose(ulong []machinePuidList)
        {
            Global.RO.Debug("Calling LookupConsoleIdsByMachinePuids: ConsoleIdList={"+StringUtils.MakeCommaSeparatedList(machinePuidList)+"}");
            MachinePuidInfo []ret=new XMachineSoapClient().LookupConsoleIdsByMachinePuids(machinePuidList);

            Global.RO.Debug("LookupMachinePuidsByConsoleIds returned: ");
            foreach (MachinePuidInfo info in ret)
            {
                Global.RO.Debug("ConsoleId={0} MachinePuid={1}",
                                    info.ConsoleId,
                                    (Puid)info.MachinePuid);
            }
            return ret;
        }

        /// <summary> Creates a specified number of machines and returns a dictionary containing them, keyed by PUID. </summary>
        public static Dictionary<ulong, MachineEditor> CreateMachines(int machinesToCreate, out ulong []machinePuids)
        {
            machinePuids=new ulong[machinesToCreate];
            if (machinesToCreate<0)
            {
                throw new ArgumentException("Can't create negative machines! What in the world are you doing?");
            }

            Dictionary<ulong, MachineEditor> machineIds=new Dictionary<ulong, MachineEditor>();

            for (int k=0; k<machinesToCreate; ++k)
            {
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                machinePuids[k]=mach.Id;
                machineIds.Add(mach.Id, mach);
            }
            return machineIds;
        }

        /// <summary> Compares a MachineEditor object containing expected (test generated) values against an API result object. </summary>
        public static void ValidateConsoleIdsResults(MachinePuidInfo []results, Dictionary<ulong, MachineEditor> machines)
        {
            ValueCheck.Test("The count obtained from the server was different from what was expected.", machines.Count, results.Length);
            foreach (MachinePuidInfo info in results)
            {
                ValueCheck.ContainsKey("We obtained an unexpected console id in the result:", machines, info.MachinePuid);
                ValidateMachinePuidInfo(info, machines[info.MachinePuid]);
            }
        }

        /// <summary> Makes sure the machine puid matches, and that the secondary info matches as well. </summary>
        public static void ValidateMachinePuidInfo(MachinePuidInfo info, MachineEditor machine)
        {
            string machineName=string.Format("0x{0:X}", machine.Id);
            ValueCheck.Test("Machine Puid for machine "+machineName, machine.Id, info.MachinePuid);
            ValueCheck.Test("ConsoleId for machine"+machineName, machine.ConsoleId, info.ConsoleId);
        }
        #endregion helpers

        // --

        #region LookupConsoleIdsByMachinePuid test cases.
        [TestCase, Description("Different ConsoleId counts to look up in a single request."), TestCasePriority(1)]
        [CompoundCase("0", 0)]
        [CompoundCase("1", 1)]
        [CompoundCase("5", 5)]
        [CompoundCase("25", 25)]
        [CompoundCase("100", 100)]
        public void LookupConsoleIds(TestNode self)
        {
            int machineCount=Convert.ToInt32(self.MyValues[0]);
            ulong []machinePuids;
            Dictionary<ulong, MachineEditor> machines=CreateMachines(machineCount, out machinePuids);

            MachinePuidInfo []res=LookupConsoleIdsVerbose(machinePuids);

            ValidateConsoleIdsResults(res, machines);
        }

        [TestCase, Description("Ask for an existing and a non-existing console id."), TestCasePriority(1)]
        public void LookupMachineIdsMixedExistance(TestNode self)
        {
            ulong []machinePuids;
            Dictionary<ulong, MachineEditor> machines=CreateMachines(1, out machinePuids);

            MachinePuidInfo []res=LookupConsoleIdsVerbose(new ulong[]{456, machinePuids[0], 123});

            ValidateConsoleIdsResults(res, machines);
        }

        [TestCase, Description("Duplicate console ids!"), TestCasePriority(1)]
        [CompoundCase("0", 0)]
        [CompoundCase("1", 1)]
        [CompoundCase("5", 5)]
        [CompoundCase("15", 15)] //More makes XMacs shake its fist at me for spamming.
        public void LookupDuplicates(TestNode self)
        {
            int dupeCount=Convert.ToInt32(self.MyValues[0]);
            ulong[] machinePuids;
            Dictionary<ulong, MachineEditor> machines=CreateMachines(1, out machinePuids);

            for (int k=0; k<dupeCount; ++k)
            {
                MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(machines[machinePuids[0]].ConsoleId));
            }

            MachinePuidInfo []res=LookupConsoleIdsVerbose(machinePuids);

            ValidateConsoleIdsResults(res, machines);
        }

        [TestCase, Description("Invalid machine ids"), TestCasePriority(2)]
        [CompoundCase("Zero", ulong.MinValue)]
        [CompoundCase("Medium", unchecked((ulong)long.MinValue))]
        [CompoundCase("Huge", ulong.MaxValue)]
        public void LookupInvalidConsoleId(TestNode self)
        {
            ulong inputNumber=(ulong)self.MyValues[0];

            MachinePuidInfo []res=LookupConsoleIdsVerbose(new ulong[]{inputNumber});

            ValueCheck.Test("Number of results returned", 0, res.Length);
        }

        [TestCase, Description("Look up a banned machine id, as well as normal ones and make sure they all show up."), TestCasePriority(2)]
        public void LookupBannedMachineId()
        {
            ulong []machinePuids;
            Dictionary<ulong, MachineEditor> machines=CreateMachines(4, out machinePuids);

            ulong []machinePuidsToBan=new ulong[2];
            machinePuidsToBan[0]=machinePuids[0];
            machinePuidsToBan[1]=machinePuids[3];

            BanMachinePuids.BanMachinePuidsVerbose(machinePuidsToBan, 0x80000001, DateTime.UtcNow, DateTime.MaxValue);
            MachinePuidInfo []res=LookupConsoleIdsVerbose(machinePuids);

            ValidateConsoleIdsResults(res, machines);
        }

        [TestCase, Description("Look up a null console id. Negative case."), TestCasePriority(2)]
        public void NullMachinePuid()
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupConsoleIdsVerbose(null);}, "Null array:");
        }

        [TestCase, Description("Look up a banned machine id, as well as normal ones and make sure they all show up."), TestCasePriority(2)]
        public void LegacyMachine()
        {
            MachineEditor mach=MachineEditor.CreateLegacyXbox360();
            MachinePuidInfo []res=LookupConsoleIdsVerbose(new ulong[]{mach.Id});
            ValueCheck.Test("Number of results returned", 1, res.Length);
            ValidateMachinePuidInfo(res[0], mach);
        }

        [TestCase, Description("Look for a PC console id through a machine puid."), TestCasePriority(2)]
        public void LookupConsoleIdsPC(TestNode self)
        {
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);
            MachineEditor mach=MachineEditor.FromId(puid);

            MachinePuidInfo []ret=LookupConsoleIdsVerbose(new ulong[]{puid});
            ValueCheck.Test("Number of results returned", 1, ret.Length);
            ValidateMachinePuidInfo(ret[0], mach);
        }

        [TestCase, Description("Phone test case."), TestCasePriority(2)]
        public void LookupPhone(TestNode self)
        {
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            MachinePuidInfo []res=LookupConsoleIdsVerbose(new ulong[]{puid});
            ValueCheck.Test("Number of results returned", 1, res.Length);
            ValidateMachinePuidInfo(res[0], MachineEditor.FromId(puid));
        }
        #endregion LookupMachinePuidsByConsoleId test cases.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupMachinePuidsByPcTokens.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Test for calling the LookupMachinePuidsByPcTokens API. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupMachinePuidsByPcTokens: TestNode
    {
        public static PcTokenInfo MakePcTokenInfo(ulong machinePuid, byte []voucherHash)
        {
            PcTokenInfo r=new PcTokenInfo();
            r.MachinePuid=machinePuid;
            r.VoucherHash=voucherHash;
            return r;
        }

        public static string PcTokenInfoStringer(PcTokenInfo result)
        {
            return "PcTokenInfo(MachinePuid="+string.Format("0x{0:X}", result.MachinePuid)+" VoucherHash="+VoucherHashStringer(result.VoucherHash)+")";
        }

        public static string PcTokenInfoStringer(object result)
        {
            if (result is PcTokenInfo)
            {
                return PcTokenInfoStringer((PcTokenInfo)result);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(result);
            }
        }

        public static string VoucherHashStringer(byte []vh)
        {
            return "0x"+Hexer.tohex(vh);
        }

        public static string VoucherHashStringer(object vh)
        {
            if (vh is byte[])
            {
                return VoucherHashStringer((byte[])vh);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(vh);
            }
        }

        public static bool PcTokenInfoEquals(PcTokenInfo left, PcTokenInfo right)
        {
            if (left.MachinePuid!=right.MachinePuid)
            {
                return false;
            }

            if (left.VoucherHash.Length!=right.VoucherHash.Length)
            {
                return false;
            }

            for (int i=0; i<left.VoucherHash.Length; ++i)
            {
                if (left.VoucherHash[i]!=right.VoucherHash[i])
                {
                    return false;
                }
            }

            return true;
        }

        public static PcTokenInfo[] LookupMachinePuidsByPcTokensVerbose(byte [][]info)
        {
            Global.RO.Debug("Calling LookupMachinePuidsByPcTokens: VoucherHash={"+StringUtils.MakeDeliminatorSeparatedList(info, ", ", VoucherHashStringer)+"}");
            PcTokenInfo []ret=new XMachineSoapClient().LookupMachinePuidsByPcTokens(info);
            Global.RO.Debug("LookupMachinePuidsByPcTokens returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", PcTokenInfoStringer));
            return ret;
        }

        // -----

        [TestCase, Description("Does a lookup of one voucher that has one machine associated with it."), BVT]
        public void OneVoucherHasOneMachine()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify
            PcTokenInfo []ret=LookupMachinePuidsByPcTokensVerbose(new byte[][]{voucherHash});
            ValueCheck.TestAllUnordered("LookupMachinePuidsByPcTokens return", new PcTokenInfo[]{MakePcTokenInfo(puid, voucherHash)}, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Does a lookup of one voucher which has multiple machines associated with it.")]
        public void OneVoucherHasMultipleMachines()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puidA=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puidB=XMachineTestUtil.CreatePCMachine(voucher);
            ulong puidC=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify
            PcTokenInfo []ret=LookupMachinePuidsByPcTokensVerbose(new byte[][]{voucherHash});
            ValueCheck.TestAllUnordered("LookupMachinePuidsByPcTokens return", new PcTokenInfo[]{MakePcTokenInfo(puidA, voucherHash), MakePcTokenInfo(puidB, voucherHash), MakePcTokenInfo(puidC, voucherHash)}, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Does a lookup of one voucher that has no machines associated with it.")]
        public void OneVoucherHasNoMachine()
        {
            //create voucher and machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);

            //call api and verify
            PcTokenInfo []ret=LookupMachinePuidsByPcTokensVerbose(new byte[][]{voucherHash});
            ValueCheck.TestAllUnordered("LookupMachinePuidsByPcTokens return", new PcTokenInfo[0], ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Lookup multiple vouchers at once.")]
        [CompoundCase("7", 7)]
        [CompoundCase("100", 100)]
        public void LookupMultiple(TestNode self)
        {
            //create vouchers and machines.  we do this directly here because hitting passport for 100 tickets is not desirable.
            int createCount=(int)self.MyValues[0];

            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashA=TokendbWS.GetHashForPanoramaVoucher(voucherA);
            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHashB=TokendbWS.GetHashForPanoramaVoucher(voucherB);

            ulong []puids=new ulong[createCount];
            for (int i=0; i<createCount; ++i)
            {
                if (0==(i&1))
                {
                    puids[i]=MachineEditor.CreateOrUseExistingPCName(voucherA, (ulong)i, MachineEditor.GetCachedPassportId()).Id;
                }
                else
                {
                    puids[i]=MachineEditor.CreateOrUseExistingPCName(voucherB, (ulong)i, MachineEditor.GetCachedPassportId()).Id;
                }
            }

            //call api and verify
            PcTokenInfo []ret=LookupMachinePuidsByPcTokensVerbose(new byte[][]{voucherHashA, voucherHashB});

            PcTokenInfo []expectedRet=new PcTokenInfo[createCount];
            for (int i=0; i<createCount; ++i)
            {
                expectedRet[i]=MakePcTokenInfo(puids[i], (0==(i&1)?voucherHashA:voucherHashB));
            }

            ValueCheck.TestAllUnordered("LookupMachinePuidsByPcTokens return", expectedRet, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Attempt to lookup more than the API can handle at once.")]
        public void LookupTooMany()
        {
            List<byte[]> hashList=new List<byte[]>();

            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            XMachineTestUtil.CreatePCMachine(voucher);

            for (int k=0; k<500; ++k)
            {
                hashList.Add(voucherHash);
            }

            //call the api and verify the return
            XMachineTestUtil.ExecuteCallExpecting404(delegate{LookupMachinePuidsByPcTokensVerbose(hashList.ToArray());});
        }

        [TestCase, Description("Does a lookup of nothing.")]
        public void LookupNone()
        {
            PcTokenInfo []ret=LookupMachinePuidsByPcTokensVerbose(new byte[][]{});
            ValueCheck.TestAllUnordered("LookupMachinePuidsByPcTokens return", new PcTokenInfo[0], ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Pass duplicates of some vouchers to lookup.")]
        public void DuplicateVouchersInParameter()
        {
            //create voucher and machines
            string voucherA=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherAHash=TokendbWS.GetHashForPanoramaVoucher(voucherA);
            ulong puidA=XMachineTestUtil.CreatePCMachine(voucherA);

            string voucherB=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherBHash=TokendbWS.GetHashForPanoramaVoucher(voucherB);
            ulong puidB=XMachineTestUtil.CreatePCMachine(voucherB);

            //call api and verify
            PcTokenInfo []ret=LookupMachinePuidsByPcTokensVerbose(new byte[][]{voucherAHash, voucherAHash, voucherBHash, voucherBHash});
            ValueCheck.TestAllUnordered("LookupPcTokensByMachinePuids return", new PcTokenInfo[]{MakePcTokenInfo(puidA, voucherAHash), MakePcTokenInfo(puidB, voucherBHash)}, ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Passes null for the puids parameter.")]
        public void NullParameter()
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByPcTokensVerbose((byte[][])null);}, "Null array");
        }

        [TestCase, Description("Pass some vouchers in the right range for a PC but that don't actually exist.")]
        public void NonexistantVouchersInParameter()
        {
            //create voucher and machines
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);

            Array.Reverse(voucherHash);

            //call api and verify
            PcTokenInfo []ret=LookupMachinePuidsByPcTokensVerbose(new byte[][]{voucherHash});
            ValueCheck.TestAllUnordered("LookupMachinePuidsByPcTokens return", new PcTokenInfo[0], ret, PcTokenInfoEquals, PcTokenInfoStringer);
        }

        [TestCase, Description("Pass a voucher has with less than 20 bytes.")]
        public void InvalidVoucherInParameter()
        {
            //create voucher and machines
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=new byte[10];

            //all FF
            for (int k=0; k<voucherHash.Length; ++k)
            {
                voucherHash[k]=Byte.MaxValue;
            }
            ulong puidReal=XMachineTestUtil.CreatePCMachine(voucher);

            //call api and verify
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByPcTokensVerbose(new byte[][]{voucherHash});}, "Token Hashes must be 20 bytes long");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupMachinePuidsByConsoleIds.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the LookupMachinePuidsByConsoleIds API. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupMachinePuidsByConsoleIds: TestNode
    {
        /// <summary> This returns a dictionary keyed by machine puid containing a count of machinesToCreate new machines. </summary>
        public static Dictionary<ulong, MachineEditor> CreateMachines(int machinesToCreate, out string []consoleIds)
        {
            consoleIds=new string[machinesToCreate];

            if (machinesToCreate<0)
            {
                throw new Exception("Can't create negative machines! What in the world are you doing.");
            }

            Dictionary<ulong, MachineEditor> machineIds=new Dictionary<ulong, MachineEditor>();

            for (int k=0; k<machinesToCreate; ++k)
            {
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                consoleIds[k]=mach.ConsoleId;
                machineIds.Add(mach.Id, mach);
            }
            return machineIds;
        }

        /// <summary> Calls the LookupMachinePuids API and returns its result object. </summary>
        public static ConsoleIdInfo[] LookupMachinePuidsByConsoleIdsVerbose(string []consoleIdList)
        {
            Global.RO.Debug("Calling LookupMachinePuidsByConsoleIds: ConsoleIdList={"+StringUtils.MakeCommaSeparatedList(consoleIdList)+"}");
            ConsoleIdInfo []ret=new XMachineSoapClient().LookupMachinePuidsByConsoleIds(consoleIdList);

            Global.RO.Debug("LookupMachinePuidsByConsoleIds returned:");
            foreach (ConsoleIdInfo info in ret)
            {
                Global.RO.Debug("Id={0} Secondary=0x{1} Puid={2}",
                                    info.ConsoleId,
                                    String.Join("", Array.ConvertAll(info.SecondaryIdentifier, (u => u.ToString("X2")))),
                                    (Puid)info.MachinePuid);
            }
            return ret;
        }

        /// <summary> Compares a machineeditor object containing expected (test generated) values against an API result object. </summary>
        public static void ValidateMachinePuidsResults(ConsoleIdInfo[] results, Dictionary<ulong, MachineEditor> machines)
        {
            ValueCheck.Test("The count obtained from the server was different from what was expected.", machines.Keys.Count, results.Length);
            foreach (ConsoleIdInfo info in results)
            {
                ValueCheck.ContainsKey("We obtained an unexpected machine puid in the result:", machines, info.MachinePuid);
                ValidateConsoleInfoObject(info, machines[info.MachinePuid]);
            }
        }

        /// <summary> Makes sure the machine puid matches, and that the secondary info matches as well. </summary>
        public static void ValidateConsoleInfoObject(ConsoleIdInfo info, MachineEditor machine)
        {
            byte []certHash=machine.CertHash;
            if (certHash==null)
            {
                certHash=new byte[20]; //Initialize array to all zeroes to match the value used for legacy machines
            }

            ValueCheck.Test("Machine Puid mismatch between what we expected and what was returned.", machine.Id, info.MachinePuid);
            ValueCheck.Test("ConsoleId mismatch between what we expected and what was returned.", machine.ConsoleId, info.ConsoleId);
            ValueCheck.TestAll("SecondaryIdentifier did not match what was expected.", certHash, info.SecondaryIdentifier);
        }

        // --

        [TestCase, Description("Different ConsoleId counts to look up in a single request."), TestCasePriority(1)]
        [CompoundCase("0", 0)]
        [CompoundCase("1", 1)]
        [CompoundCase("5", 5)]
        [CompoundCase("25", 25)]
        [CompoundCase("100", 100)]
        public void LookupMachineIds(TestNode self)
        {
            int machineCount=Convert.ToInt32(self.MyValues[0]);
            string []consoleIds;
            Dictionary<ulong, MachineEditor> machines=CreateMachines(machineCount, out consoleIds);

            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdsVerbose(consoleIds);

            ValidateMachinePuidsResults(res, machines);
        }

        [TestCase, Description("Ask for an existing and a non-existing console id."), TestCasePriority(1)]
        public void LookupMachineIdsMixedExisting(TestNode self)
        {
            string []consoleIds;
            Dictionary<ulong, MachineEditor> machines=CreateMachines(1, out consoleIds);

            string fakeCid0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            string fakeCid1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdsVerbose(new string[]{fakeCid0, consoleIds[0], fakeCid1});

            ValidateMachinePuidsResults(res, machines);
        }

        [TestCase, Description("Duplicate console ids!"), TestCasePriority(1)]
        [CompoundCase("0", 0)]
        [CompoundCase("1", 1)]
        [CompoundCase("5", 5)]
        [CompoundCase("15", 15)] //More makes XMacs shake its fist at me for spamming.
        public void LookupDuplicates(TestNode self)
        {
            int dupeCount=Convert.ToInt32(self.MyValues[0]);
            string []consoleIds;
            Dictionary<ulong, MachineEditor> machines=CreateMachines(1, out consoleIds);

            for (int k=0; k<dupeCount; ++k)
            {
                 MachineEditor dupeN=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(consoleIds[0]));
                 machines.Add(dupeN.Id, dupeN);
            }

            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdsVerbose(consoleIds);

            ValidateMachinePuidsResults(res, machines);
        }

        [TestCase, Description("Invalid console ids"), TestCasePriority(2)]
        [CompoundCase("InvalidString", "!@!@#@!#",          "Invalid ConsoleId")]
        [CompoundCase("LongString",    "aaaaaaaaaaaaaaaaa", "Invalid ConsoleId")]
        [CompoundCase("360Zero",       "XE.0",              "Invalid ConsoleId")]
        [CompoundCase("360Negative",   "XE.-01111111119",   "Invalid Checksum for ConsoleId")]
        [CompoundCase("360BadSum",     "XE.111111111112",   "Invalid Checksum for ConsoleId")]
        [CompoundCase("PCZero",        "PC.0",              "Invalid ConsoleId")]
        [CompoundCase("X1Zero",        "SN.0",              "Invalid ConsoleId")]
        [CompoundCase("Zero",          "0",                 "Invalid ConsoleId")]
        [CompoundCase("Negative",      "-1",                "Invalid ConsoleId")]
        public void LookupInvalidConsoleId(TestNode self)
        {
            string inputString=(string)self.MyValues[0];
            string expectedFailure=(string)self.MyValues[1];

            ConsoleIdInfo []res=null;

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{res=LookupMachinePuidsByConsoleIdsVerbose(new string[]{inputString});}, expectedFailure);
        }

        [TestCase, Description("Invalid console ids"), TestCasePriority(2)]
        [CompoundCase("PCNegative", "PC.-01111111119")]
        [CompoundCase("X1Negative", "SN.-01111111119")]
        [CompoundCase("X1Normal",   "SN.111111111111")]
        public void LookupInvalidConsoleIdNonFailure(TestNode self)
        {
            string inputString=(string)self.MyValues[0];
            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdsVerbose(new string[]{inputString});
            ValueCheck.Test("Obtained a different count of results from LookupMachinePuidsByConsoleIds:", 0, res.Length);
            //TODO: Should these really be non-failures?  At least it is returning 0 results though...
        }

        [TestCase, Description("Look up a banned console id, as well as normal ones and make sure they all show up."), TestCasePriority(1)]
        public void LookupBannedConsoleId()
        {
            string []consoleIds;
            Dictionary<ulong, MachineEditor> machines=CreateMachines(4, out consoleIds);

            string []consoleIdsToBan=new string[2];
            consoleIdsToBan[0]=consoleIds[0];
            consoleIdsToBan[1]=consoleIds[3]; //Ban #1 and #4.

            BanConsoleIds.BanConsoleIdsVerbose(consoleIdsToBan, 0x80000001, DateTime.UtcNow);
            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdsVerbose(consoleIds);

            ValidateMachinePuidsResults(res, machines);
        }

        [TestCase, Description("Look up a null console id. Negative case."), TestCasePriority(2)]
        public void NullConsoleId()
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdsVerbose(null);}, "Null array");
        }

        [TestCase, Description("Look up a legary machine id."), TestCasePriority(2)]
        public void LegacyMachine()
        {
            MachineEditor mach=MachineEditor.CreateLegacyXbox360();

            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdsVerbose(new string[]{mach.ConsoleId});

            ValueCheck.Test("Number of results returned by the server", 1, res.Length);
            ValidateConsoleInfoObject(res[0], mach);
        }

        [TestCase, Description("Look for a PC machine puid through its console id."), TestCasePriority(2)]
        public void LookupIdsPC(TestNode self)
        {
            //Voucher A is 1:1 voucher->Machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);
            MachineEditor mach=MachineEditor.FromId(puid);

            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdsVerbose(new string[]{mach.ConsoleId});

            ValueCheck.Test("Number of results returned by the server", 1, res.Length);
            ValidateConsoleInfoObject(res[0], mach);
        }

        [TestCase, Description("Phone test case"), TestCasePriority(2)]
        public void LookupPhone(TestNode self)
        {
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            MachineEditor mach=MachineEditor.FromId(puid);

            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdsVerbose(new string[]{mach.ConsoleId});

            ValueCheck.Test("Number of results returned by the server", 1, res.Length);
            ValidateConsoleInfoObject(res[0], mach);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupMachinePuidByConsoleIdAndXuid.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Test for calling the LookupMachinePuidByConsoleIdAndXuid. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupMachinePuidByConsoleIdAndXuid: TestNode
    {
        /// <summary> Creates a machine and links it with a user. </summary>
        public static MachineEditor CreateMachineAndUser(ref ulong machinePuid, ref ulong xuid, bool haveHistory, bool isDuplicated)
        {
            MachineEditor mach=CreateMachine(ref machinePuid);
            UserEditor user=CreateUser(ref xuid);

            if (isDuplicated && mach.Exists)
            {
                MachineEditor dupeMachine=MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId)); //Just give it a dupe.

                if (haveHistory && user.Exists)
                {
                    UserMachineHistoryEditor ed=UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, dupeMachine.Id);
                    ed.FirstSeen=DateTime.UtcNow.AddDays(-31); //A month ago.
                    ed.LastSeen=DateTime.UtcNow.AddDays(-30); //A month ago.
                }
            }

            if (haveHistory)
            {
                UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, mach.Id);
            }
            else
            {
                if (user.Exists)
                {
                    //Give him sumfin to sit there.
                    MachineEditor junkMachine=CreateMachine(ref machinePuid);
                    UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, junkMachine.Id);
                    if (isDuplicated && junkMachine.Exists)
                    {
                        XMachineTestUtil.CreateDuplicateXbox360Machine(junkMachine.ConsoleId); //Give it a dupe.
                    }
                }
            }

            machinePuid=mach.Id;
            xuid=user.Puid;

            return mach;
        }

        /// <summary> Just creates an xbox360 machine or loads it if the specified machinePuid is non-zero. </summary>
        public static MachineEditor CreateMachine(ref ulong machinePuid)
        {
            MachineEditor mach;

            if (machinePuid==0)
            {
                mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            }
            else
            {
                mach=MachineEditor.FromId(machinePuid);
            }

            return mach;
        }

        /// <summary> Creates a user or loads if if the puid is non-zero. </summary>
        public static UserEditor CreateUser(ref ulong puid)
        {
            UserEditor user;

            if (puid==0)
            {
                user=UserEditor.CreateNew();
            }
            else
            {
                user=UserEditor.FromPuid(puid);
            }

            return user;
        }

        /// <summary> Calls the LookupMachinePuidByConsoleIdAndXuid API and returns its result object.  It should be noted that despite the API returning an array, it should never be the case that the API returns more than one result.  It may return 0 results though. </summary>
        public static ConsoleIdInfo[] LookupMachinePuidByConsoleIdAndXuidVerbose(string consoleId, ulong userXuid)
        {
            Global.RO.Debug("Calling LookupMachinePuidByConsoleIdAndXuid: ConsoleId="+consoleId+" UserXuid="+string.Format("0x{0:X}", userXuid));
            ConsoleIdInfo []ret=new XMachineSoapClient().LookupMachinePuidByConsoleIdAndXuid(consoleId, userXuid);

            Global.RO.Debug("LookupMachinePuidByConsoleIdAndXuid returned:");
            foreach (ConsoleIdInfo info in ret)
            {
                Global.RO.Debug("Id={0} Secondary=0x{1} Puid={2}",
                                    info.ConsoleId,
                                    String.Join("", Array.ConvertAll(info.SecondaryIdentifier, (u => u.ToString("X2")))),
                                    (Puid)info.MachinePuid);
            }
            return ret;
        }

        /// <summary> Compares a MachineEditor object containing expected values against an API result object. </summary>
        public static void ValidateMachinePuidsResults(ConsoleIdInfo []results, MachineEditor machine, bool expectReturn)
        {
            if (expectReturn)
            {
                ValueCheck.Test("The count obtained from the server was different from what was expected.", 1, results.Length);
                ValidateConsoleInfoObject(results[0], machine);
            }
            else
            {
                ValueCheck.Test("The count obtained from the server was different from what was expected.", 0, results.Length);
            }
        }

        /// <summary> Makes sure the machine puid matches, and that the secondary info matches as well. </summary>
        public static void ValidateConsoleInfoObject(ConsoleIdInfo info, MachineEditor machine)
        {
            byte []certHash=machine.CertHash;
            if (certHash==null)
            {
                certHash=new byte[20]; //Initialize array to all zeroes to match response for legacy machines that don't have a secondary id stored yet
            }

            ValueCheck.Test("Machine Puid mismatch between what we expected and what was returned.", machine.Id, info.MachinePuid);
            ValueCheck.Test("ConsoleId mismatch between what we expected and what was returned.", machine.ConsoleId, info.ConsoleId);
            ValueCheck.TestAll("SecondaryIdentifier did not match what was expected.", certHash, info.SecondaryIdentifier);
        }

        // --

        [TestCase, Description("Different ConsoleId counts to look up in a single request."), TestCasePriority(1)]
        [CompoundCase("UserNotExists_MachineNotExists_HistoryNotExists",       false, false, false, false)]
        [CompoundCase("UserNotExists_MachineNotExists_HistoryNotExists_Duped", false, false, false, true)]
        [CompoundCase("UserNotExists_MachineExists_HistoryNotExists",          false, true,  false, false)]
        [CompoundCase("UserNotExists_MachineExists_HistoryNotExists_Duped",    false, true,  false, true)]
        [CompoundCase("UserExists_MachineNotExists_HistoryNotExists",          true,  false, false, false)]
        [CompoundCase("UserExists_MachineNotExists_HistoryExists",             true,  false, true,  false)]
        [CompoundCase("UserExists_MachineNotExists_HistoryExists_Duped",       true,  false, true,  true)]
        [CompoundCase("UserExists_MachineNotExists_HistoryNotExists_Duped",    true,  false, false, true)]
        [CompoundCase("UserExists_MachineExists_HistoryNotExists",             true,  true,  false, false)]
        [CompoundCase("UserExists_MachineExists_HistoryNotExists_Duped",       true,  true,  false, true)]
        [CompoundCase("UserExists_MachineExists_HistoryExists",                true,  true,  true,  false)]
        [CompoundCase("UserExists_MachineExists_HistoryExists_Duped",          true,  true,  true,  true)]
        public void LookupMachineAndXuid(TestNode self)
        {
            bool userExists=(bool)self.MyValues[0];
            bool machineExists=(bool)self.MyValues[1];
            bool historyExists=(bool)self.MyValues[2];
            bool dupeExists=(bool)self.MyValues[3];
            bool expectReturn=(machineExists && !dupeExists) || (machineExists && dupeExists && userExists && historyExists);
            ulong xuid=0;
            ulong machinePuid=0;
            string consoleId="";

            if (!userExists)
            {
                xuid=UserEditor.AllocatePuid();
            }

            if (!machineExists)
            {
                machinePuid=MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
            }

            MachineEditor machine=CreateMachineAndUser(ref machinePuid, ref xuid, historyExists, dupeExists);

            if (machine.Exists)
            {
                consoleId=machine.ConsoleId;
            }
            else
            {
                consoleId=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            }

            ConsoleIdInfo []res=LookupMachinePuidByConsoleIdAndXuidVerbose(consoleId, xuid);

            ValidateMachinePuidsResults(res, machine, expectReturn);
        }

        [TestCase, Description("Invalid console ids"), TestCasePriority(2)]
        [CompoundCase("InvalidString", "!@!@#@!#"         , "Invalid ConsoleId:")]
        [CompoundCase("LongString",    "aaaaaaaaaaaaaaaaa", "Invalid ConsoleId:")]
        [CompoundCase("360Zero",       "XE.0"             , "Invalid ConsoleId:")]
        [CompoundCase("360Negative",   "XE.-01111111119"  , "Invalid Checksum for ConsoleId:")]
        [CompoundCase("360BadSum",     "XE.111111111112"  , "Invalid Checksum for ConsoleId:")]
        [CompoundCase("PCZero",        "PC.0"             , "Invalid ConsoleId:")]
        [CompoundCase("X1Zero",        "SN.0"             , "Invalid ConsoleId:")]
        [CompoundCase("Zero",          "0"                , "Invalid ConsoleId:")]
        [CompoundCase("Negative",      "-1"               , "Invalid ConsoleId:")]
        public void LookupInvalidConsoleId(TestNode self)
        {
            string inputString=(string)self.MyValues[0];
            string expectedFailure=(string)self.MyValues[1];
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidByConsoleIdAndXuidVerbose(inputString, 2);}, expectedFailure);
        }

        [TestCase, Description("Invalid console ids.  TODO: Investigate why these tests are separate.  Is there a service bug here?"), TestCasePriority(2)]
        [CompoundCase("PCNegative", "PC.-01111111119")]
        [CompoundCase("X1Negative", "SN.-01111111119")]
        public void LookupInvalidConsoleIdNonFailure(TestNode self)
        {
            string inputString=(string)self.MyValues[0];
            ConsoleIdInfo []res=LookupMachinePuidByConsoleIdAndXuidVerbose(inputString, 2);
            ValueCheck.Test("Obtained a different count of results back:", 0, res.Length);
        }

        [TestCase, Description("Look up a banned machine id and make sure it shows up."), TestCasePriority(2)]
        public void LookupBannedMachineId()
        {
            ulong xuid=0;
            ulong machinePuid=0;
            MachineEditor machine=CreateMachineAndUser(ref machinePuid, ref xuid, true, false);

            BanConsoleIds.BanConsoleIdsVerbose(new string[]{machine.ConsoleId}, 0x80000001, DateTime.UtcNow);
            ConsoleIdInfo []res=LookupMachinePuidByConsoleIdAndXuidVerbose(machine.ConsoleId, xuid);

            ValidateMachinePuidsResults(res, machine, true);
        }

        [TestCase, Description("Look up a null console id."), TestCasePriority(2)]
        public void NullConsoleId()
        {
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidByConsoleIdAndXuidVerbose(null, 2);}, "Null ConsoleId");
        }

        [TestCase, Description("Look up a legacy machine which has no secondary identifier."), TestCasePriority(2)]
        public void LegacyMachine()
        {
            MachineEditor mach=MachineEditor.CreateLegacyXbox360();
            ConsoleIdInfo []res=LookupMachinePuidByConsoleIdAndXuidVerbose(mach.ConsoleId, 2);
            ValidateConsoleInfoObject(res[0], mach);
        }

        [TestCase, Description("Look up a pc machine id with a pc console id and xuid. This should be invalid."), TestCasePriority(2)]
        public void LookupPC()
        {
            //Voucher A is 1:1 voucher->Machine
            //Creating this stuff is overkill since it is blocked at the consoleId validation level, but whatevs it's cheap.
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);
            MachineEditor mach=MachineEditor.FromId(puid);

            ulong xuid=0;
            CreateMachineAndUser(ref puid, ref xuid, true, false);

            ConsoleIdInfo []res=LookupMachinePuidByConsoleIdAndXuidVerbose(mach.ConsoleId, xuid);
            ValidateMachinePuidsResults(res, mach, true);
        }

        [TestCase, Description("Phone test case."), TestCasePriority(2)]
        public void LookupPhone(TestNode self)
        {
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            MachineEditor mach=MachineEditor.FromId(puid);
            ConsoleIdInfo []res=LookupMachinePuidByConsoleIdAndXuidVerbose(mach.ConsoleId, 2);

            ValidateMachinePuidsResults(res, mach, true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupMachinePuidsByConsoleIdAndSCode.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the LookupMachinePuidsByConsoleIdAndSCode. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupMachinePuidsByConsoleIdAndSCode: TestNode
    {
        /// <summary> This returns a dictionary keyed by machine puid containing a count of machinesToCreate new machines. </summary>
        public static Dictionary<ulong, MachineEditor> CreateMachines(int machinesToCreate, out string []consoleIds)
        {
            consoleIds=new string[machinesToCreate];
            if (machinesToCreate<0)
            {
                throw new ArgumentException("Can't create negative machines! What in the world are you doing.");
            }

            Dictionary<ulong, MachineEditor> machineIds=new Dictionary<ulong, MachineEditor>();

            for (int k=0; k<machinesToCreate; ++k)
            {
                MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
                consoleIds[k]=mach.ConsoleId;
                machineIds.Add(mach.Id, mach);
            }
            return machineIds;
        }

        /// <summary> Gets the truncated secondary id. This is the one that will be presented to the user in the dashboard. It is calculated off of the full  cert hash. </summary>
        public static byte[] GetTruncatedSecondaryID(byte []secondaryIdentifier)
        {
            if (secondaryIdentifier==null)
            {
                return null;
            }

            byte []truncId=GetTruncatedSecondaryIDSilent(secondaryIdentifier);
            byte lowNibble=(byte)(truncId[7]&0x0F);
            byte highNibble=(byte)(truncId[7]&0xF0);

            Global.RO.Debug("Debug id: SecondaryIdentifier=0x{4}, Checksum={0}, High Nibble={1}, Low Nibble={2}, TruncatedSecondaryIdentifier={3}",
                truncId[7], highNibble, lowNibble, (xonline.common.utilities2.Blob)truncId, (xonline.common.utilities2.Blob)secondaryIdentifier);

            return truncId;
        }

        public static byte[] GetTruncatedSecondaryIDSilent(byte []secondaryIdentifier)
        {
            if (secondaryIdentifier==null)
            {
                return null;
            }

            byte []truncId=new byte[8];

            byte lowNibble=0, highNibble=0;
            for (int k=0; k<7; ++k)
            {
                lowNibble+=(byte)(secondaryIdentifier[k]&0x0F);
                lowNibble&=0x0F;

                highNibble+=(byte)(secondaryIdentifier[k]&0xF0);
                highNibble&=0xF0;

                truncId[k]=secondaryIdentifier[k];
            }

            truncId[7]=(byte)(lowNibble|highNibble);
            return truncId;
        }

        /// <summary> Calls the LookupMachinePuidsByConsoleIdAndSCode API and returns its result object. Note that SCode is the truncated secondary identifier. </summary>
        public static ConsoleIdInfo[] LookupMachinePuidsByConsoleIdAndSCodeVerbose(string consoleId, byte []sCode)
        {
            Global.RO.Debug("Calling LookupMachinePuidsByConsoleIdAndSCode: ConsoleId{"+consoleId+"} SCode{"+((xonline.common.utilities2.Blob)sCode).ToString()+"}");
            ConsoleIdInfo []ret=new XMachineSoapClient().LookupMachinePuidsByConsoleIdAndSCode(consoleId, sCode);

            Global.RO.Debug("LookupMachinePuidsByConsoleIdAndSCode returned:");
            foreach (ConsoleIdInfo info in ret)
            {
                Global.RO.Debug("ConsoleId={0} SecondaryId=0x{1} Puid={2}",
                                    info.ConsoleId,
                                    String.Join("", Array.ConvertAll(info.SecondaryIdentifier, (u => u.ToString("X2")))),
                                    (Puid)info.MachinePuid);
            }
            return ret;
        }

        /// <summary> Compares a dictionary of machineeditor objects containing expected values against an API result object. </summary>
        public static void ValidateMachinePuidsResults(ConsoleIdInfo []results, Dictionary<ulong, MachineEditor> machines)
        {
            ValueCheck.Test("The count obtained from the server was different from what was expected.", machines.Keys.Count, results.Length);
            foreach (ConsoleIdInfo info in results)
            {
                ValueCheck.ContainsKey("We obtained an unexpected machine id in the result:", machines, info.MachinePuid);
                ValidateConsoleInfoObject(info, machines[info.MachinePuid]);
            }
        }

        /// <summary> Compares a machineeditor object containing expected values against an API result object. </summary>
        public static void ValidateMachinePuidsResult(ConsoleIdInfo []results, MachineEditor machine)
        {
            ValueCheck.Test("The count obtained from the server was different from what was expected.", 1, results.Length);
            ValidateConsoleInfoObject(results[0], machine);
        }

        /// <summary> Makes sure the machine puid matches, and that the secondary info matches as well. </summary>
        public static void ValidateConsoleInfoObject(ConsoleIdInfo info, MachineEditor machine)
        {
            byte []certHash=machine.CertHash;
            if (certHash==null)
            {
                certHash=new byte[20]; //Initialize array to all zeroes to match what the api will return in the case of legacy xbox360 machines
            }

            ValueCheck.Test("Machine Puid mismatch between what we expected and what was returned.", machine.Id, info.MachinePuid);
            ValueCheck.Test("ConsoleId mismatch between what we expected and what was returned.", machine.ConsoleId, info.ConsoleId);
            ValueCheck.TestAll("SecondaryIdentifier did not match what was expected.", certHash, info.SecondaryIdentifier);
        }

        // --

        [TestCase, Description("Basic test that pinpoints a single machine."), TestCasePriority(1)]
        public void LookupMachineId(TestNode self)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, GetTruncatedSecondaryID(mach.CertHash));

            ValidateMachinePuidsResult(res, mach);
        }

        [TestCase, Description("Hash too long."), TestCasePriority(2)]
        public void LookupMachineIdHashTooLong(TestNode self)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            //Full certhash is too long and wrong.
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, mach.CertHash);}, "scode must be 8 bytes");
        }

        [TestCase, Description("Hash too short."), TestCasePriority(2)]
        [CompoundCase("{0} bytes", 0)]
        [CompoundCase("{0} bytes", 1)]
        [CompoundCase("{0} bytes", 2)]
        [CompoundCase("{0} bytes", 7)]
        public void LookupMachineIdHashTooShort(TestNode self)
        {
            int bytesToUse=(int)self.MyValues[0];

            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            byte []secondaryId=new byte[bytesToUse];
            System.Array.Copy(mach.CertHash, 0, secondaryId, 0, bytesToUse);

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, secondaryId);}, "scode must be 8 bytes");
        }

        [TestCase, Description("Invalid hash."), TestCasePriority(1)]
        public void LookupMachineIdInvalidHash(TestNode self)
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            byte []truncatedId=GetTruncatedSecondaryID(mach.CertHash);
            truncatedId[7]=(byte)~truncatedId[7];

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, truncatedId);}, "SecondaryId Failed Checksum");
        }

        [TestCase, Description("Ask for a valid console id but a non-existent hash for that console id."), TestCasePriority(1)]
        public void LookupMachineIdsNonExistingHash(TestNode self)
        {
            //Create 2 machines
            int machineCount=2;
            string []consoleIds;
            Dictionary<ulong, MachineEditor> machines=CreateMachines(machineCount, out consoleIds);

            //Get the 2nd one to be the source of your hash.
            MachineEditor mach=MachineEditor.FromName(consoleIds[1]);

            //Send console id 1 and cert hash 2 which should fail to find anything.
            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdAndSCodeVerbose(consoleIds[0], GetTruncatedSecondaryID(mach.CertHash));

            ValidateMachinePuidsResults(res, new Dictionary<ulong, MachineEditor>());
        }

        [TestCase, Description("Duplicate console ids!"), TestCasePriority(1)]
        [CompoundCase("0", 0)]
        [CompoundCase("1", 1)]
        [CompoundCase("5", 5)]
        [CompoundCase("15", 15)] //More makes XMacs shake its fist at me for spamming.
        public void LookupDuplicates(TestNode self)
        {
            int dupeCount=Convert.ToInt32(self.MyValues[0]);
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            for (int k=0; k<dupeCount; ++k)
            {
                MachineEditor.FromId(XMachineTestUtil.CreateDuplicateXbox360Machine(mach.ConsoleId));
            }

            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, GetTruncatedSecondaryID(mach.CertHash));

            ValidateMachinePuidsResult(res, mach);
        }

        [TestCase, Description("Invalid console ids"), TestCasePriority(2)]
        [CompoundCase("InvalidString", "!@!@#@!#",          "Invalid ConsoleId")]
        [CompoundCase("LongString",    "aaaaaaaaaaaaaaaaa", "Invalid ConsoleId")]
        [CompoundCase("360Zero",       "XE.0",              "Invalid ConsoleId")]
        [CompoundCase("360Negative",   "XE.-01111111119",   "Invalid Checksum for ConsoleId")]
        [CompoundCase("360BadSum",     "XE.111111111112",   "Invalid Checksum for ConsoleId")]
        [CompoundCase("PCZero",        "PC.0",              "Invalid ConsoleId")]
        [CompoundCase("PCNegative",    "PC.-01111111119",   "Invalid Non-Xbox360 ConsoleId")]
        [CompoundCase("X1Zero",        "SN.0",              "Invalid ConsoleId")]
        [CompoundCase("X1Negative",    "SN.-01111111119",   "Invalid Non-Xbox360 ConsoleId")]
        [CompoundCase("X1Normal",      "SN.111111111111",   "Invalid Non-Xbox360 ConsoleId")]
        [CompoundCase("Zero",          "0",                 "Invalid ConsoleId")]
        [CompoundCase("Negative",      "-1",                "Invalid ConsoleId")]
        public void LookupInvalidConsoleId(TestNode self)
        {
            string inputString=(string)self.MyValues[0];
            string expectedFailure=(string)self.MyValues[1];

            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdAndSCodeVerbose(inputString, GetTruncatedSecondaryID(mach.CertHash));}, expectedFailure);
        }

        [TestCase, Description("Look up a banned machine id."), TestCasePriority(2)]
        public void LookupBannedMachineId()
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());

            BanConsoleIds.BanConsoleIdsVerbose(new string[]{mach.ConsoleId}, 0x80000001, DateTime.UtcNow.AddHours(-1));
            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, GetTruncatedSecondaryID(MachineEditor.FromName(mach.ConsoleId).CertHash));

            ValidateMachinePuidsResult(res, mach);
        }

        [TestCase, Description("Look up a null console id."), TestCasePriority(2)]
        public void NullConsoleId()
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdAndSCodeVerbose(null, GetTruncatedSecondaryID(mach.CertHash));}, "null consoleid");
        }

        [TestCase, Description("Look up a null console id."), TestCasePriority(2)]
        public void NullCertHash()
        {
            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, new byte[]{});}, "scode must be 8 bytes");
        }

        [TestCase, Description("Look up a legacy machine.  It should not be found."), TestCasePriority(2)]
        [CompoundCase("Zero SecondaryId",    true)]
        [CompoundCase("Nonzero SecondaryId", false)]
        public void LegacyMachine(TestNode self)
        {
            bool useZeroSid=(bool)self.MyValues[0];

            MachineEditor mach=MachineEditor.CreateLegacyXbox360();
            byte []scode=new byte[8];

            if (!useZeroSid)
            {
                scode=GetTruncatedSecondaryID(MachineEditor.CreateNew().CertHash);
                ValueCheck.Test("Test code is busted", false, scode==null);
            }

            ConsoleIdInfo []res=LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, scode);

            if (useZeroSid) //zero code should match legacy
            {
                ValidateMachinePuidsResult(res, mach);
            }
            else //specific code should return 0 results
            {
                ValidateMachinePuidsResults(res, new Dictionary<ulong, MachineEditor>());
            }
        }

        [TestCase, Description("Look for a PC machine."), TestCasePriority(2)]
        public void LookupIdsPC(TestNode self)
        {
            //Voucher A is 1:1 voucher->Machine
            string voucher=XMachineTestUtil.CreateUnlimitedPCVoucher();
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            ulong puid=XMachineTestUtil.CreatePCMachine(voucher);
            MachineEditor mach=MachineEditor.FromId(puid);
            byte []emptySCode=new byte[8];

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, emptySCode);}, "Invalid Non-Xbox360 ConsoleId");
        }

        [TestCase, Description("Phone test case."), TestCasePriority(2)]
        public void LookupPhone(TestNode self)
        {
            ulong puid=XMachineTestUtil.CreatePhoneMachine();
            MachineEditor mach=MachineEditor.FromId(puid);
            byte []emptySCode=new byte[8];

            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, emptySCode);}, "Invalid Non-Xbox360 ConsoleId");
        }

        [TestCase, Description("All FF bytes in the hash."), TestCasePriority(2)]
        public void LookupIdsMaxCertHash(TestNode self)
        {
            byte []max=new byte[8];

            for (int k=0; k<max.Length; ++k)
                max[k]=Byte.MaxValue;

            MachineEditor mach=MachineEditor.FromId(XMachineTestUtil.CreateXbox360Machine());
            XMachineTestUtil.ExecuteCallExpectingSoapError(delegate{LookupMachinePuidsByConsoleIdAndSCodeVerbose(mach.ConsoleId, max);}, "SecondaryId Failed Checksum");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupPassportHistoryByMachinePuid.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupPassportHistoryByMachinePuid: DoubleWriteTestGroup
    {
        public static PassportHistory LookupPassportHistoryByMachinePuidVerbose(Puid machinePuid, Puid? userPuid, DateTime? since, bool details)
        {
            Global.RO.Debug("Calling LookupPassportHistoryByMachinePuid: MachinePuid="+machinePuid+", UserPuid="+userPuid+", Since="+since+", Details="+details);
            PassportHistory ret=new XMachineSoapClient().LookupPassportHistoryByMachinePuid((ulong)machinePuid, (ulong?)userPuid, since, details);
            Global.RO.Debug("LookupPassportHistoryByMachinePuid returned: "+HistoryCommon.PassportHistoryStringer(ret));
            return ret;
        }

        public static void ComputeAndVerifyPassportHistory(Puid machinePuid, Puid? userPuid, System.DateTime ?since, bool details, PassportHistory gottenResult, bool isSecMHDB)
        {
            //lookup the actual rows in the db and convert them into a PassportHistory that contains the expected result
            PassportHistory expectedResult=new PassportHistory();

            MachinePassportHistoryEditor.MachinePassportHistoryEntry []allHistories=MachinePassportHistoryEditor.FromMachinePuid(machinePuid, isSecMHDB).GetAllHistory();
            HashSet<ulong> uniqueUsers=new HashSet<ulong>();
            int totalEntries=0;
            System.DateTime ?first=null;
            System.DateTime ?last=null;
            List<PassportHistoryDetails> detailsExpectedInResult=new List<PassportHistoryDetails>();
            foreach (MachinePassportHistoryEditor.MachinePassportHistoryEntry entry in allHistories)
            {
                if (since==null || entry.TimeStamp>=since)
                {
                    if (userPuid==null || userPuid==entry.UserPuid)
                    {
                        ++totalEntries;

                        if (first==null || first>entry.TimeStamp)
                        {
                            first=entry.TimeStamp;
                        }

                        if (last==null || last<entry.TimeStamp)
                        {
                            last=entry.TimeStamp;
                        }

                        if (!uniqueUsers.Contains(entry.UserPuid))
                        {
                            uniqueUsers.Add(entry.UserPuid);
                        }

                        if (details)
                        {
                            PassportHistoryDetails detail=new PassportHistoryDetails();
                            detail.MachinePuid=machinePuid;
                            detail.UserPuid=entry.UserPuid;
                            detail.IpAddress=entry.IpAddress;
                            detail.Timestamp=entry.TimeStamp;
                            detail.HResult=entry.Hr;
                            detail.Reason=entry.Reason;
                            detail.OldPassportPuid=entry.OldPassport;
                            detail.NewPassportPuid=entry.NewPassport;
                            detailsExpectedInResult.Add(detail);
                        }
                    }
                }
            }

            expectedResult.Total=totalEntries;
            expectedResult.Unique=uniqueUsers.Count;
            expectedResult.First=first;
            expectedResult.Last=last;
            expectedResult.Details=detailsExpectedInResult.ToArray();
            if (!details)
            {
                expectedResult.Details=null;
            }

            //Verify
            HistoryCommon.VerifyPassportHistory(expectedResult, gottenResult);
        }

        public static void CallAndVerify(Puid machinePuid, Puid? userPuid, System.DateTime ?since, bool details, bool isSecMHDB)
        {
            PassportHistory ret=LookupPassportHistoryByMachinePuidVerbose(machinePuid, userPuid, since, details);
            ComputeAndVerifyPassportHistory(machinePuid, userPuid, since, details, ret, isSecMHDB);
        }

        // -----

        [TestCase, Description("One simple row is placed only in the relevent database.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithUserPuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoUserPuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("WithUserPuid WithDate NoDetails",   true,  true,  false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithUserPuid NoDate WithDetails",   true,  false, true)]
        [CompoundCase("NoUserPuid WithDate WithDetails",   false, true,  true)]
        [CompoundCase("WithUserPuid WithDate WithDetails", true,  true,  true)]
        public void SimpleOneRow(TestNode self)
        {
            bool useSecMHDB=!IsDoubleWrite(self);
            bool passUserPuid=(bool)self.MyValues[0];
            bool passPastDate=(bool)self.MyValues[1];
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachinePassportHistoryEditor mghe=MachinePassportHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 0x7000000000000000, 0x8000000000000000, 1, useSecMHDB));

            ulong ?userPuid=(passUserPuid?(ulong?)user.Puid:(ulong?)null);
            System.DateTime ?sinceDate=(passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestCase, Description("Two simple rows are placed in the database with different dates.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",           false, null, false)]
        [CompoundCase("NoUserPuid DateAfterAll NoDetails",     false, 0,    false)]
        [CompoundCase("NoUserPuid DateAfterOne NoDetails",     false, 2,    false)]
        [CompoundCase("NoUserPuid DateAfterTwo NoDetails",     false, 4,    false)]
        [CompoundCase("WithUserPuid NoDate NoDetails",         true,  null, false)]
        [CompoundCase("WithUserPuid DateAfterAll NoDetails",   true,  0,    false)]
        [CompoundCase("WithUserPuid DateAfterOne NoDetails",   true,  2,    false)]
        [CompoundCase("WithUserPuid DateAfterTwo NoDetails",   true,  4,    false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",         false, null, true)]
        [CompoundCase("NoUserPuid DateAfterAll WithDetails",   false, 0,    true)]
        [CompoundCase("NoUserPuid DateAfterOne WithDetails",   false, 2,    true)]
        [CompoundCase("NoUserPuid DateAfterTwo WithDetails",   false, 4,    true)]
        [CompoundCase("WithUserPuid NoDate WithDetails",       true,  null, true)]
        [CompoundCase("WithUserPuid DateAfterAll WithDetails", true,  0,    true)]
        [CompoundCase("WithUserPuid DateAfterOne WithDetails", true,  2,    true)]
        [CompoundCase("WithUserPuid DateAfterTwo WithDetails", true,  4,    true)]
        public void TwoRowsDifferentDates(TestNode self)
        {
            System.DateTime now=System.DateTime.UtcNow;
            bool useSecMHDB=!IsDoubleWrite(self);
            bool passUserPuid=(bool)self.MyValues[0];
            System.TimeSpan ?dateMod=(self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachinePassportHistoryEditor mghe=MachinePassportHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(user.Puid, mach.Id, "1.2.3.4", now-new System.TimeSpan(0, 0, 1), 0x80000007, 1, 2, 1, useSecMHDB));
            mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(user.Puid, mach.Id, "4.3.2.1", now-new System.TimeSpan(0, 0, 3), 0x80000006, 3, 4, 2, useSecMHDB));

            ulong ?userPuid=(passUserPuid?(ulong?)user.Puid:(ulong?)null);
            System.DateTime ?sinceDate=(dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestCase, Description("Three simple rows spanning two users are placed only in the relevent database.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",         null, null, false)]
        [CompoundCase("UserA NoDate NoDetails",              0,    null, false)]
        [CompoundCase("UserB NoDate NoDetails",              1,    null, false)]
        [CompoundCase("NoUserPuid DateAfterOne NoDetails",   null, 2,    false)]
        [CompoundCase("UserA DateAfterOne NoDetails",        0,    2,    false)]
        [CompoundCase("UserB DateAfterOne NoDetails",        1,    2,    false)]
        [CompoundCase("NoUserPuid DateAfterTwo NoDetails",   null, 4,    false)]
        [CompoundCase("UserA DateAfterTwo NoDetails",        0,    4,    false)]
        [CompoundCase("UserB DateAfterTwo NoDetails",        1,    4,    false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",       null, null, true)]
        [CompoundCase("UserA NoDate WithDetails",            0,    null, true)]
        [CompoundCase("UserB NoDate WithDetails",            1,    null, true)]
        [CompoundCase("NoUserPuid DateAfterOne WithDetails", null, 2,    true)]
        [CompoundCase("UserA DateAfterOne WithDetails",      0,    2,    true)]
        [CompoundCase("UserB DateAfterOne WithDetails",      1,    2,    true)]
        [CompoundCase("NoUserPuid DateAfterTwo WithDetails", null, 4,    true)]
        [CompoundCase("UserA DateAfterTwo WithDetails",      0,    4,    true)]
        [CompoundCase("UserB DateAfterTwo WithDetails",      1,    4,    true)]
        public void ThreeRowsTwoUsersDifferentDates(TestNode self)
        {
            System.DateTime now=System.DateTime.UtcNow;
            bool useSecMHDB=!IsDoubleWrite(self);
            int ?passUserPuid=(self.MyValues[0]!=null?(int)self.MyValues[0]:(int?)null);
            System.TimeSpan ?dateMod=(self.MyValues[1]==null?(System.TimeSpan?)null:(System.TimeSpan?)new System.TimeSpan(0, 0, (int)self.MyValues[1]));
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor []users=new UserEditor[]{UserEditor.CreateNew(), UserEditor.CreateNew()};
            MachineEditor mach=MachineEditor.CreateNew();

            MachinePassportHistoryEditor mghe=MachinePassportHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(users[0].Puid, mach.Id, "1.2.3.1", now-new System.TimeSpan(0, 0, 1), 0x80000007, 1, 2, 1, useSecMHDB));
            mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(users[0].Puid, mach.Id, "1.2.3.2", now-new System.TimeSpan(0, 0, 5), 0x80000006, 3, 4, 2, useSecMHDB));
            mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(users[1].Puid, mach.Id, "1.2.3.3", now-new System.TimeSpan(0, 0, 3), 0x80000005, 5, 6, 3, useSecMHDB));

            ulong ?userPuid=(passUserPuid!=null?users[(int)passUserPuid].Puid:(ulong?)null);
            System.DateTime ?sinceDate=(dateMod!=null?(System.DateTime?)(now-(System.TimeSpan)dateMod):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestCase, Description("No rows for the machine.")]
        [CompoundCase("NoUserPuid NoDate NoDetails",       false, false, false)]
        [CompoundCase("WithUserPuid NoDate NoDetails",     true,  false, false)]
        [CompoundCase("NoUserPuid WithDate NoDetails",     false, true,  false)]
        [CompoundCase("NoUserPuid NoDate WithDetails",     false, false, true)]
        [CompoundCase("WithUserPuid WithDate WithDetails", true,  true,  true)]
        public void NoRows(TestNode self)
        {
            bool useSecMHDB=!IsDoubleWrite(self);
            bool passUserPuid=(bool)self.MyValues[0];
            bool passPastDate=(bool)self.MyValues[1];
            bool passDetailsFlag=(bool)self.MyValues[2];

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            ulong ?userPuid=(passUserPuid?(ulong?)user.Puid:(ulong?)null);
            System.DateTime ?sinceDate=(passPastDate?(System.DateTime?)(System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)):(System.DateTime?)null);
            CallAndVerify(mach.Id, userPuid, sinceDate, passDetailsFlag, useSecMHDB);
        }

        [TestGroup]
        public class WeirdValuesInDB: TestNode
        {
            //Machine puids have a foreign key constraint in UODB.

            [TestCase, Description("Weird user puids.")]
            [CompoundCase("0x{0:X}", (ulong)0)]
            [CompoundCase("0x{0:X}", (ulong)1)]
            [CompoundCase("0x{0:X}", (ulong)0xffffffffffffffff)]
            [CompoundCase("0x{0:X}", (ulong)0xfa00000000000000)]
            public void UserPuids(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                ulong userPuid=(ulong)self.MyValues[0];

                MachineEditor mach=MachineEditor.CreateNew();

                MachinePassportHistoryEditor mghe=MachinePassportHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(userPuid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 1, 2, 1, useSecMHDB));

                CallAndVerify(mach.Id, userPuid, null, true, useSecMHDB);
            }

            [TestCase, Description("Weird IP addresses.")]
            [CompoundCase("EmptyString", "")]
            [CompoundCase("null", null)]
            [CompoundCase("{0}", "Not.An.IP.Addr")]
            [CompoundCase("{0}", "Woops")]
            [CompoundCase("SingleDot", ".")]
            [CompoundCase("{0}", "999.999.999.999")]
            [CompoundCase("{0}", "0.0.0.0")]
            [CompoundCase("{0}", "100.002.003.0004")]
            public void IPAddress(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                string ipAddress=(string)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachinePassportHistoryEditor mghe=MachinePassportHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(user.Puid, mach.Id, ipAddress, System.DateTime.UtcNow, 0x80000007, 1, 2, 1, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }

            [TestCase, Description("Different reasons.")]
            [CompoundCase("{0}", (byte)0)]
            [CompoundCase("{0}", (byte)1)]
            [CompoundCase("Max", (byte)99)]
            public void Reasons(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                byte reason=(byte)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachinePassportHistoryEditor mghe=MachinePassportHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow, 0x80000007, 8, 9, reason, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }

            [TestCase, Description("Weird passport puids.")]
            [CompoundCase("null", null)]
            [CompoundCase("MinValue", (ulong)0)]
            [CompoundCase("MaxValue", (ulong)0xffffffffffffffff)]
            public void Passports(TestNode self)
            {
                bool useSecMHDB=!IsDoubleWrite(self);
                ulong ?Passports=(ulong?)self.MyValues[0];

                UserEditor user=UserEditor.CreateNew();
                MachineEditor mach=MachineEditor.CreateNew();

                MachinePassportHistoryEditor mghe=MachinePassportHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
                mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(user.Puid, mach.Id, "123.234.120.210", System.DateTime.UtcNow, 0x80000007, Passports, Passports, 1, useSecMHDB));

                CallAndVerify(mach.Id, null, null, true, useSecMHDB);
            }
        }

        [TestCase, Description("There are 1000 rows for a single machine to be returned.")]
        public void OneThousandRows(TestNode self)
        {
            bool useSecMHDB=!IsDoubleWrite(self);

            UserEditor user=UserEditor.CreateNew();
            MachineEditor mach=MachineEditor.CreateNew();

            MachinePassportHistoryEditor mghe=MachinePassportHistoryEditor.FromMachinePuid(mach.Id, useSecMHDB);
            for (int i=0; i<1000; ++i)
            {
                mghe.SetHistory(new MachinePassportHistoryEditor.MachinePassportHistoryEntry(user.Puid, mach.Id, "1.2.3.4", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0), 0x80000007, (ulong)i, (ulong)i*3, (byte)(i%10+1), useSecMHDB));
            }

            CallAndVerify(mach.Id, null, null, true, useSecMHDB);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xmachine\test\LookupMachineInfoByMachinePuids.cs ===
using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.server.xmachine.fd.soap;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;

namespace XMachineTests
{
    /// <summary> Tests for calling the LookupMachineInfoByMachinePuids. </summary>
    [TestGroup, Owner("LukeL"), TestCasePriority(1)]
    public class LookupMachineInfoByMachinePuids : TestNode
    {
        public static MachineInfo MakeMachineInfo(ulong machinePuid)
        {
            MachineEditor mach=MachineEditor.FromId(machinePuid);

            MachineInfo info=new MachineInfo();
            info.MachinePuid=mach.Id;
            info.ConsoleId=mach.ConsoleId;
            info.SecondaryIdentifier=mach.CertHash??new byte[20]; //all 0's is used for machines that don't have a cert hash stored
            info.ResetDate=mach.ResetDate;
            info.CreateDate=mach.CreationDate??System.DateTime.MinValue; //note that the API treats all NULL values in the DB as minimum values
            info.FlashVersion=mach.ClientFlashVersion;
            info.FlashDate=mach.ClientFlashVersionChangedDate??System.DateTime.MinValue;
            info.ConsoleRegion=mach.ConsoleRegion;
            info.UpdateVersion=mach.ClientFlashUpdateVersion;
            info.UpdateDate=mach.ClientFlashUpdateVersionChangedDate??System.DateTime.MinValue;
            return info;
        }

        public static string MachineInfoStringer(MachineInfo info)
        {
            return "MachineInfo(MachinePuid="+string.Format("0x{0:X}", info.MachinePuid)+" ConsoleId="+info.ConsoleId+" SecondaryIdentifier=0x"+ToHexString(info.SecondaryIdentifier)+" ResetDate="+info.ResetDate+" CreateDate="+info.CreateDate+" FlashVersion="+info.FlashVersion+" FlashDate="+info.FlashDate+" ConsoleRegion="+info.ConsoleRegion+" UpdateVersion="+info.UpdateVersion+" UpdateDate="+info.UpdateDate+")";
        }

        public static string MachineInfoStringer(object info)
        {
            if (info is MachineInfo)
            {
                return MachineInfoStringer((MachineInfo)info);
            }
            else
            {
                return StringUtils.MakeDeliminatorSeparatedListDefaultStringer(info);
            }
        }

        public static string ToHexString(byte []b)
        {
            if (b==null)
                return null;

            return Hexer.tohex(b);
        }

        public static bool MachineInfoEquals(MachineInfo left, MachineInfo right)
        {
            return
                left.MachinePuid==right.MachinePuid &&
                left.ConsoleId==right.ConsoleId &&
                ToHexString(left.SecondaryIdentifier)==ToHexString(right.SecondaryIdentifier) &&
                System.Math.Abs((left.ResetDate-right.ResetDate).TotalMilliseconds)<10 &&
                System.Math.Abs((left.CreateDate-right.CreateDate).TotalMilliseconds)<10 &&
                left.FlashVersion==right.FlashVersion &&
                System.Math.Abs((left.FlashDate-right.FlashDate).TotalMilliseconds)<10 &&
                left.ConsoleRegion==right.ConsoleRegion &&
                left.UpdateVersion==right.UpdateVersion &&
                System.Math.Abs((left.UpdateDate-right.UpdateDate).TotalMilliseconds)<10;
        }

        public static MachineInfo[] LookupMachineInfoByMachinePuidsVerbose(Puid []puids)
        {
            Global.RO.Debug("Calling LookupMachineInfoByMachinePuids: Puids={"+StringUtils.MakeCommaSeparatedList(puids)+"}");
            MachineInfo[] ret;
            if (puids!=null)
            {
                ret=new XMachineSoapClient().LookupMachineInfoByMachinePuids(System.Array.ConvertAll(puids, u=>(ulong)(u)));
            }
            else
            {
                ret=new XMachineSoapClient().LookupMachineInfoByMachinePuids(null);
            }
            Global.RO.Debug("LookupMachineInfoByMachinePuids returned: "+StringUtils.MakeDeliminatorSeparatedList(ret, ", ", MachineInfoStringer));
            return ret;
        }

        public static MachineInfo[] LookupMachineInfoByMachinePuidsVerbose(ulong []puids)
        {
            return LookupMachineInfoByMachinePuidsVerbose(System.Array.ConvertAll(puids, u=>(Puid)(u)));
        }

        // -----

        [TestCase, Description("Does a lookup on a single valid machine in the default just-created state.")]
        [CompoundCase("{0}", MachineType.Xbox360)]
        [CompoundCase("{0}", MachineType.PC)]
        [CompoundCase("{0}", MachineType.Phone)]
        public void SingleValid(TestNode self)
        {
            //create machine
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.CreateNew(mtype);
            mach.CreationDate=System.DateTime.UtcNow-new System.TimeSpan(3