inds at HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\KindMap
//  The list of kinds is not extensible.
DEFINE_PROPERTYKEY(PKEY_Kind, 0x1E3EE840, 0xBC2B, 0x476C, 0x82, 0x37, 0x2A, 0xCD, 0x1A, 0x83, 0x9B, 0x22, 3);

// Possible discrete values for PKEY_Kind are:
#define KIND_CALENDAR                       L"calendar"
#define KIND_COMMUNICATION                  L"communication"
#define KIND_CONTACT                        L"contact"
#define KIND_DOCUMENT                       L"document"
#define KIND_EMAIL                          L"email"
#define KIND_FEED                           L"feed"
#define KIND_FOLDER                         L"folder"
#define KIND_GAME                           L"game"
#define KIND_INSTANTMESSAGE                 L"instantmessage"
#define KIND_JOURNAL                        L"journal"
#define KIND_LINK                           L"link"
#define KIND_MOVIE                          L"movie"
#define KIND_MUSIC                          L"music"
#define KIND_NOTE                           L"note"
#define KIND_PICTURE                        L"picture"
#define KIND_PROGRAM                        L"program"
#define KIND_RECORDEDTV                     L"recordedtv"
#define KIND_SEARCHFOLDER                   L"searchfolder"
#define KIND_TASK                           L"task"
#define KIND_VIDEO                          L"video"
#define KIND_WEBHISTORY                     L"webhistory"

//  Name:     System.KindText -- PKEY_KindText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F04BEF95-C585-4197-A2B7-DF46FDC9EE6D, 100
//  
//  This is the user-friendly form of System.Kind.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_KindText, 0xF04BEF95, 0xC585, 0x4197, 0xA2, 0xB7, 0xDF, 0x46, 0xFD, 0xC9, 0xEE, 0x6D, 100);

//  Name:     System.Language -- PKEY_Language
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 28
//
//  
DEFINE_PROPERTYKEY(PKEY_Language, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 28);

//  Name:     System.MileageInformation -- PKEY_MileageInformation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: FDF84370-031A-4ADD-9E91-0D775F1C6605, 100
DEFINE_PROPERTYKEY(PKEY_MileageInformation, 0xFDF84370, 0x031A, 0x4ADD, 0x9E, 0x91, 0x0D, 0x77, 0x5F, 0x1C, 0x66, 0x05, 100);

//  Name:     System.MIMEType -- PKEY_MIMEType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 0B63E350-9CCC-11D0-BCDB-00805FCCCE04, 5
//
//  The MIME type.  Eg, for EML files: 'message/rfc822'.
DEFINE_PROPERTYKEY(PKEY_MIMEType, 0x0B63E350, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 5);

//  Name:     System.Null -- PKEY_Null
//  Type:     Null -- VT_NULL
//  FormatID: 00000000-0000-0000-0000-000000000000, 0
DEFINE_PROPERTYKEY(PKEY_Null, 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0);

//  Name:     System.OfflineAvailability -- PKEY_OfflineAvailability
//  Type:     UInt32 -- VT_UI4
//  FormatID: A94688B6-7D9F-4570-A648-E3DFC0AB2B3F, 100
DEFINE_PROPERTYKEY(PKEY_OfflineAvailability, 0xA94688B6, 0x7D9F, 0x4570, 0xA6, 0x48, 0xE3, 0xDF, 0xC0, 0xAB, 0x2B, 0x3F, 100);

// Possible discrete values for PKEY_OfflineAvailability are:
#define OFFLINEAVAILABILITY_NOT_AVAILABLE   0ul
#define OFFLINEAVAILABILITY_AVAILABLE       1ul
#define OFFLINEAVAILABILITY_ALWAYS_AVAILABLE 2ul

//  Name:     System.OfflineStatus -- PKEY_OfflineStatus
//  Type:     UInt32 -- VT_UI4
//  FormatID: 6D24888F-4718-4BDA-AFED-EA0FB4386CD8, 100
DEFINE_PROPERTYKEY(PKEY_OfflineStatus, 0x6D24888F, 0x4718, 0x4BDA, 0xAF, 0xED, 0xEA, 0x0F, 0xB4, 0x38, 0x6C, 0xD8, 100);

// Possible discrete values for PKEY_OfflineStatus are:
#define OFFLINESTATUS_ONLINE                0ul
#define OFFLINESTATUS_OFFLINE               1ul
#define OFFLINESTATUS_OFFLINE_FORCED        2ul
#define OFFLINESTATUS_OFFLINE_SLOW          3ul
#define OFFLINESTATUS_OFFLINE_ERROR         4ul
#define OFFLINESTATUS_OFFLINE_ITEM_VERSION_CONFLICT 5ul
#define OFFLINESTATUS_OFFLINE_SUSPENDED     6ul

//  Name:     System.OriginalFileName -- PKEY_OriginalFileName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) 0CEF7D53-FA64-11D1-A203-0000F81FEDEE, 6
//  
//  
DEFINE_PROPERTYKEY(PKEY_OriginalFileName, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 6);

//  Name:     System.ParentalRating -- PKEY_ParentalRating
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 21 (PIDMSI_PARENTAL_RATING)
//
//  
DEFINE_PROPERTYKEY(PKEY_ParentalRating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 21);

//  Name:     System.ParentalRatingReason -- PKEY_ParentalRatingReason
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 10984E0A-F9F2-4321-B7EF-BAF195AF4319, 100
DEFINE_PROPERTYKEY(PKEY_ParentalRatingReason, 0x10984E0A, 0xF9F2, 0x4321, 0xB7, 0xEF, 0xBA, 0xF1, 0x95, 0xAF, 0x43, 0x19, 100);

//  Name:     System.ParentalRatingsOrganization -- PKEY_ParentalRatingsOrganization
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A7FE0840-1344-46F0-8D37-52ED712A4BF9, 100
DEFINE_PROPERTYKEY(PKEY_ParentalRatingsOrganization, 0xA7FE0840, 0x1344, 0x46F0, 0x8D, 0x37, 0x52, 0xED, 0x71, 0x2A, 0x4B, 0xF9, 100);

//  Name:     System.ParsingBindContext -- PKEY_ParsingBindContext
//  Type:     Any -- VT_NULL  Legacy code may treat this as VT_UNKNOWN.
//  FormatID: DFB9A04D-362F-4CA3-B30B-0254B17B5B84, 100
//  
//  used to get the IBindCtx for an item for parsing
DEFINE_PROPERTYKEY(PKEY_ParsingBindContext, 0xDFB9A04D, 0x362F, 0x4CA3, 0xB3, 0x0B, 0x02, 0x54, 0xB1, 0x7B, 0x5B, 0x84, 100);

//  Name:     System.ParsingName -- PKEY_ParsingName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 24
//  
//  The shell namespace name of an item relative to a parent folder.  This name may be passed to 
//  IShellFolder::ParseDisplayName() of the parent shell folder.
DEFINE_PROPERTYKEY(PKEY_ParsingName, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 24);

//  Name:     System.ParsingPath -- PKEY_ParsingPath
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 30
//  
//  This is the shell namespace path to the item.  This path may be passed to 
//  SHParseDisplayName to parse the path to the correct shell folder.
//  
//  If the item is a file, the value is identical to System.ItemPathDisplay.
//  
//  If the item cannot be accessed through the shell namespace, this value is VT_EMPTY.
DEFINE_PROPERTYKEY(PKEY_ParsingPath, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 30);

//  Name:     System.PerceivedType -- PKEY_PerceivedType
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 9
//
//  The perceived type of a shell item, based upon its canonical type.
DEFINE_PROPERTYKEY(PKEY_PerceivedType, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 9);

// For the enumerated values of PKEY_PerceivedType, see the PERCEIVED_TYPE_* values in shtypes.idl.

//  Name:     System.PercentFull -- PKEY_PercentFull
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_Volume) 9B174B35-40FF-11D2-A27E-00C04FC30871, 5  (Filesystem Volume Properties)
//
//  The amount filled as a percentage, multiplied by 100 (ie, the valid range is 0 through 100).
DEFINE_PROPERTYKEY(PKEY_PercentFull, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 5);

//  Name:     System.Priority -- PKEY_Priority
//  Type:     UInt16 -- VT_UI2
//  FormatID: 9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4, 5
//
//  
DEFINE_PROPERTYKEY(PKEY_Priority, 0x9C1FCF74, 0x2D97, 0x41BA, 0xB4, 0xAE, 0xCB, 0x2E, 0x36, 0x61, 0xA6, 0xE4, 5);

// Possible discrete values for PKEY_Priority are:
#define PRIORITY_PROP_LOW                   0u
#define PRIORITY_PROP_NORMAL                1u
#define PRIORITY_PROP_HIGH                  2u

//  Name:     System.PriorityText -- PKEY_PriorityText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D98BE98B-B86B-4095-BF52-9D23B2E0A752, 100
//  
//  This is the user-friendly form of System.Priority.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_PriorityText, 0xD98BE98B, 0xB86B, 0x4095, 0xBF, 0x52, 0x9D, 0x23, 0xB2, 0xE0, 0xA7, 0x52, 100);

//  Name:     System.Project -- PKEY_Project
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 39A7F922-477C-48DE-8BC8-B28441E342E3, 100
DEFINE_PROPERTYKEY(PKEY_Project, 0x39A7F922, 0x477C, 0x48DE, 0x8B, 0xC8, 0xB2, 0x84, 0x41, 0xE3, 0x42, 0xE3, 100);

//  Name:     System.ProviderItemID -- PKEY_ProviderItemID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F21D9941-81F0-471A-ADEE-4E74B49217ED, 100
//  
//  
DEFINE_PROPERTYKEY(PKEY_ProviderItemID, 0xF21D9941, 0x81F0, 0x471A, 0xAD, 0xEE, 0x4E, 0x74, 0xB4, 0x92, 0x17, 0xED, 100);

//  Name:     System.Rating -- PKEY_Rating
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 9 (PIDMSI_RATING)
//  
//  Indicates the users preference rating of an item on a scale of 0-99 (0 = unrated, 1-12 = One Star, 
//  13-37 = Two Stars, 38-62 = Three Stars, 63-87 = Four Stars, 88-99 = Five Stars).
DEFINE_PROPERTYKEY(PKEY_Rating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 9);

// Use the following constants to convert between visual stars and the ratings value:
#define RATING_UNRATED_MIN                  0ul
#define RATING_UNRATED_SET                  0ul
#define RATING_UNRATED_MAX                  0ul

#define RATING_ONE_STAR_MIN                 1ul
#define RATING_ONE_STAR_SET                 1ul
#define RATING_ONE_STAR_MAX                 12ul

#define RATING_TWO_STARS_MIN                13ul
#define RATING_TWO_STARS_SET                25ul
#define RATING_TWO_STARS_MAX                37ul

#define RATING_THREE_STARS_MIN              38ul
#define RATING_THREE_STARS_SET              50ul
#define RATING_THREE_STARS_MAX              62ul

#define RATING_FOUR_STARS_MIN               63ul
#define RATING_FOUR_STARS_SET               75ul
#define RATING_FOUR_STARS_MAX               87ul

#define RATING_FIVE_STARS_MIN               88ul
#define RATING_FIVE_STARS_SET               99ul
#define RATING_FIVE_STARS_MAX               99ul


//  Name:     System.RatingText -- PKEY_RatingText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 90197CA7-FD8F-4E8C-9DA3-B57E1E609295, 100
//  
//  This is the user-friendly form of System.Rating.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_RatingText, 0x90197CA7, 0xFD8F, 0x4E8C, 0x9D, 0xA3, 0xB5, 0x7E, 0x1E, 0x60, 0x92, 0x95, 100);

//  Name:     System.Sensitivity -- PKEY_Sensitivity
//  Type:     UInt16 -- VT_UI2
//  FormatID: F8D3F6AC-4874-42CB-BE59-AB454B30716A, 100
//
//  
DEFINE_PROPERTYKEY(PKEY_Sensitivity, 0xF8D3F6AC, 0x4874, 0x42CB, 0xBE, 0x59, 0xAB, 0x45, 0x4B, 0x30, 0x71, 0x6A, 100);

// Possible discrete values for PKEY_Sensitivity are:
#define SENSITIVITY_PROP_NORMAL             0u
#define SENSITIVITY_PROP_PERSONAL           1u
#define SENSITIVITY_PROP_PRIVATE            2u
#define SENSITIVITY_PROP_CONFIDENTIAL       3u

//  Name:     System.SensitivityText -- PKEY_SensitivityText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D0C7F054-3F72-4725-8527-129A577CB269, 100
//  
//  This is the user-friendly form of System.Sensitivity.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_SensitivityText, 0xD0C7F054, 0x3F72, 0x4725, 0x85, 0x27, 0x12, 0x9A, 0x57, 0x7C, 0xB2, 0x69, 100);

//  Name:     System.SFGAOFlags -- PKEY_SFGAOFlags
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 25
//
//  IShellFolder::GetAttributesOf flags, with SFGAO_PKEYSFGAOMASK attributes masked out.
DEFINE_PROPERTYKEY(PKEY_SFGAOFlags, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 25);

//  Name:     System.SharedWith -- PKEY_SharedWith
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: EF884C5B-2BFE-41BB-AAE5-76EEDF4F9902, 200
//
//  Who is the item shared with?
DEFINE_PROPERTYKEY(PKEY_SharedWith, 0xEF884C5B, 0x2BFE, 0x41BB, 0xAA, 0xE5, 0x76, 0xEE, 0xDF, 0x4F, 0x99, 0x02, 200);

//  Name:     System.ShareUserRating -- PKEY_ShareUserRating
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 12 (PIDMSI_SHARE_USER_RATING)
//
//  
DEFINE_PROPERTYKEY(PKEY_ShareUserRating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 12);

//  Name:     System.Shell.OmitFromView -- PKEY_Shell_OmitFromView
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DE35258C-C695-4CBC-B982-38B0AD24CED0, 2
//  
//  Set this to a string value of 'True' to omit this item from shell views
DEFINE_PROPERTYKEY(PKEY_Shell_OmitFromView, 0xDE35258C, 0xC695, 0x4CBC, 0xB9, 0x82, 0x38, 0xB0, 0xAD, 0x24, 0xCE, 0xD0, 2);

//  Name:     System.SimpleRating -- PKEY_SimpleRating
//  Type:     UInt32 -- VT_UI4
//  FormatID: A09F084E-AD41-489F-8076-AA5BE3082BCA, 100
//  
//  Indicates the users preference rating of an item on a scale of 0-5 (0=unrated, 1=One Star, 2=Two Stars, 3=Three Stars,
//  4=Four Stars, 5=Five Stars)
DEFINE_PROPERTYKEY(PKEY_SimpleRating, 0xA09F084E, 0xAD41, 0x489F, 0x80, 0x76, 0xAA, 0x5B, 0xE3, 0x08, 0x2B, 0xCA, 100);

//  Name:     System.Size -- PKEY_Size
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 12 (PID_STG_SIZE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Size, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 12);

//  Name:     System.SoftwareUsed -- PKEY_SoftwareUsed
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 305
//
//  PropertyTagSoftwareUsed
DEFINE_PROPERTYKEY(PKEY_SoftwareUsed, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 305);

//  Name:     System.SourceItem -- PKEY_SourceItem
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 668CDFA5-7A1B-4323-AE4B-E527393A1D81, 100
DEFINE_PROPERTYKEY(PKEY_SourceItem, 0x668CDFA5, 0x7A1B, 0x4323, 0xAE, 0x4B, 0xE5, 0x27, 0x39, 0x3A, 0x1D, 0x81, 100);

//  Name:     System.StartDate -- PKEY_StartDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 48FD6EC8-8A12-4CDF-A03E-4EC5A511EDDE, 100
DEFINE_PROPERTYKEY(PKEY_StartDate, 0x48FD6EC8, 0x8A12, 0x4CDF, 0xA0, 0x3E, 0x4E, 0xC5, 0xA5, 0x11, 0xED, 0xDE, 100);

//  Name:     System.Status -- PKEY_Status
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_IntSite) 000214A1-0000-0000-C000-000000000046, 9
DEFINE_PROPERTYKEY(PKEY_Status, 0x000214A1, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 9);

//  Name:     System.Subject -- PKEY_Subject
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 3 (PIDSI_SUBJECT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Subject, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 3);

//  Name:     System.Thumbnail -- PKEY_Thumbnail
//  Type:     Clipboard -- VT_CF
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 17 (PIDSI_THUMBNAIL)
//
//  A data that represents the thumbnail in VT_CF format.
DEFINE_PROPERTYKEY(PKEY_Thumbnail, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 17);

//  Name:     System.ThumbnailCacheId -- PKEY_ThumbnailCacheId
//  Type:     UInt64 -- VT_UI8
//  FormatID: 446D16B1-8DAD-4870-A748-402EA43D788C, 100
//  
//  Unique value that can be used as a key to cache thumbnails. The value changes when the name, volume, or data modified 
//  of an item changes.
DEFINE_PROPERTYKEY(PKEY_ThumbnailCacheId, 0x446D16B1, 0x8DAD, 0x4870, 0xA7, 0x48, 0x40, 0x2E, 0xA4, 0x3D, 0x78, 0x8C, 100);

//  Name:     System.ThumbnailStream -- PKEY_ThumbnailStream
//  Type:     Stream -- VT_STREAM
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 27
//
//  Data that represents the thumbnail in VT_STREAM format that GDI+/WindowsCodecs supports (jpg, png, etc).
DEFINE_PROPERTYKEY(PKEY_ThumbnailStream, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 27);

//  Name:     System.Title -- PKEY_Title
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 2 (PIDSI_TITLE)
//
//  Title of item.
DEFINE_PROPERTYKEY(PKEY_Title, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 2);

//  Name:     System.TotalFileSize -- PKEY_TotalFileSize
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 14
//
//  
DEFINE_PROPERTYKEY(PKEY_TotalFileSize, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 14);

//  Name:     System.Trademarks -- PKEY_Trademarks
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) 0CEF7D53-FA64-11D1-A203-0000F81FEDEE, 9 (PIDVSI_Trademarks)
//
//  
DEFINE_PROPERTYKEY(PKEY_Trademarks, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 9);
 
//-----------------------------------------------------------------------------
// Document properties



//  Name:     System.Document.ByteCount -- PKEY_Document_ByteCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 4 (PIDDSI_BYTECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_ByteCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 4);

//  Name:     System.Document.CharacterCount -- PKEY_Document_CharacterCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 16 (PIDSI_CHARCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_CharacterCount, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 16);

//  Name:     System.Document.ClientID -- PKEY_Document_ClientID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 276D7BB0-5B34-4FB0-AA4B-158ED12A1809, 100
DEFINE_PROPERTYKEY(PKEY_Document_ClientID, 0x276D7BB0, 0x5B34, 0x4FB0, 0xAA, 0x4B, 0x15, 0x8E, 0xD1, 0x2A, 0x18, 0x09, 100);

//  Name:     System.Document.Contributor -- PKEY_Document_Contributor
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: F334115E-DA1B-4509-9B3D-119504DC7ABB, 100
DEFINE_PROPERTYKEY(PKEY_Document_Contributor, 0xF334115E, 0xDA1B, 0x4509, 0x9B, 0x3D, 0x11, 0x95, 0x04, 0xDC, 0x7A, 0xBB, 100);

//  Name:     System.Document.DateCreated -- PKEY_Document_DateCreated
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 12 (PIDSI_CREATE_DTM)
//  
//  This property is stored in the document, not obtained from the file system.
DEFINE_PROPERTYKEY(PKEY_Document_DateCreated, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 12);

//  Name:     System.Document.DatePrinted -- PKEY_Document_DatePrinted
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 11 (PIDSI_LASTPRINTED)
//
//  Legacy name: "DocLastPrinted".
DEFINE_PROPERTYKEY(PKEY_Document_DatePrinted, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 11);

//  Name:     System.Document.DateSaved -- PKEY_Document_DateSaved
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 13 (PIDSI_LASTSAVE_DTM)
//
//  Legacy name: "DocLastSavedTm".
DEFINE_PROPERTYKEY(PKEY_Document_DateSaved, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 13);

//  Name:     System.Document.Division -- PKEY_Document_Division
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 1E005EE6-BF27-428B-B01C-79676ACD2870, 100
DEFINE_PROPERTYKEY(PKEY_Document_Division, 0x1E005EE6, 0xBF27, 0x428B, 0xB0, 0x1C, 0x79, 0x67, 0x6A, 0xCD, 0x28, 0x70, 100);

//  Name:     System.Document.DocumentID -- PKEY_Document_DocumentID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E08805C8-E395-40DF-80D2-54F0D6C43154, 100
DEFINE_PROPERTYKEY(PKEY_Document_DocumentID, 0xE08805C8, 0xE395, 0x40DF, 0x80, 0xD2, 0x54, 0xF0, 0xD6, 0xC4, 0x31, 0x54, 100);

//  Name:     System.Document.HiddenSlideCount -- PKEY_Document_HiddenSlideCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 9 (PIDDSI_HIDDENCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_HiddenSlideCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 9);

//  Name:     System.Document.LastAuthor -- PKEY_Document_LastAuthor
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 8 (PIDSI_LASTAUTHOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_LastAuthor, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 8);

//  Name:     System.Document.LineCount -- PKEY_Document_LineCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 5 (PIDDSI_LINECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_LineCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 5);

//  Name:     System.Document.Manager -- PKEY_Document_Manager
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 14 (PIDDSI_MANAGER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_Manager, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 14);

//  Name:     System.Document.MultimediaClipCount -- PKEY_Document_MultimediaClipCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 10 (PIDDSI_MMCLIPCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_MultimediaClipCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 10);

//  Name:     System.Document.NoteCount -- PKEY_Document_NoteCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 8 (PIDDSI_NOTECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_NoteCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 8);

//  Name:     System.Document.PageCount -- PKEY_Document_PageCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 14 (PIDSI_PAGECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_PageCount, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 14);

//  Name:     System.Document.ParagraphCount -- PKEY_Document_ParagraphCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 6 (PIDDSI_PARCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_ParagraphCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 6);

//  Name:     System.Document.PresentationFormat -- PKEY_Document_PresentationFormat
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 3 (PIDDSI_PRESFORMAT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_PresentationFormat, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 3);

//  Name:     System.Document.RevisionNumber -- PKEY_Document_RevisionNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 9 (PIDSI_REVNUMBER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_RevisionNumber, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 9);

//  Name:     System.Document.Security -- PKEY_Document_Security
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 19
//
//  Access control information, from SummaryInfo propset
DEFINE_PROPERTYKEY(PKEY_Document_Security, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 19);

//  Name:     System.Document.SlideCount -- PKEY_Document_SlideCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 7 (PIDDSI_SLIDECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_SlideCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 7);

//  Name:     System.Document.Template -- PKEY_Document_Template
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 7 (PIDSI_TEMPLATE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_Template, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 7);

//  Name:     System.Document.TotalEditingTime -- PKEY_Document_TotalEditingTime
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 10 (PIDSI_EDITTIME)
//
//  100ns units, not milliseconds. VT_FILETIME for IPropertySetStorage handlers (legacy)
DEFINE_PROPERTYKEY(PKEY_Document_TotalEditingTime, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 10);

//  Name:     System.Document.Version -- PKEY_Document_Version
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 29
DEFINE_PROPERTYKEY(PKEY_Document_Version, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 29);

//  Name:     System.Document.WordCount -- PKEY_Document_WordCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 15 (PIDSI_WORDCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_WordCount, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 15);

 
 
//-----------------------------------------------------------------------------
// DRM properties

//  Name:     System.DRM.DatePlayExpires -- PKEY_DRM_DatePlayExpires
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 6 (PIDDRSI_PLAYEXPIRES)
//
//  Indicates when play expires for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_DatePlayExpires, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 6);

//  Name:     System.DRM.DatePlayStarts -- PKEY_DRM_DatePlayStarts
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 5 (PIDDRSI_PLAYSTARTS)
//
//  Indicates when play starts for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_DatePlayStarts, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 5);

//  Name:     System.DRM.Description -- PKEY_DRM_Description
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 3 (PIDDRSI_DESCRIPTION)
//
//  Displays the description for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_Description, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 3);

//  Name:     System.DRM.IsProtected -- PKEY_DRM_IsProtected
//  Type:     Boolean -- VT_BOOL
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 2 (PIDDRSI_PROTECTED)
//
//  
DEFINE_PROPERTYKEY(PKEY_DRM_IsProtected, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 2);

//  Name:     System.DRM.PlayCount -- PKEY_DRM_PlayCount
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 4 (PIDDRSI_PLAYCOUNT)
//
//  Indicates the play count for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_PlayCount, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 4);
 
//-----------------------------------------------------------------------------
// GPS properties

//  Name:     System.GPS.Altitude -- PKEY_GPS_Altitude
//  Type:     Double -- VT_R8
//  FormatID: 827EDB4F-5B73-44A7-891D-FDFFABEA35CA, 100
//  
//  Indicates the altitude based on the reference in PKEY_GPS_AltitudeRef.  Calculated from PKEY_GPS_AltitudeNumerator and 
//  PKEY_GPS_AltitudeDenominator
DEFINE_PROPERTYKEY(PKEY_GPS_Altitude, 0x827EDB4F, 0x5B73, 0x44A7, 0x89, 0x1D, 0xFD, 0xFF, 0xAB, 0xEA, 0x35, 0xCA, 100);

//  Name:     System.GPS.AltitudeDenominator -- PKEY_GPS_AltitudeDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 78342DCB-E358-4145-AE9A-6BFE4E0F9F51, 100
//
//  Denominator of PKEY_GPS_Altitude
DEFINE_PROPERTYKEY(PKEY_GPS_AltitudeDenominator, 0x78342DCB, 0xE358, 0x4145, 0xAE, 0x9A, 0x6B, 0xFE, 0x4E, 0x0F, 0x9F, 0x51, 100);

//  Name:     System.GPS.AltitudeNumerator -- PKEY_GPS_AltitudeNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 2DAD1EB7-816D-40D3-9EC3-C9773BE2AADE, 100
//
//  Numerator of PKEY_GPS_Altitude
DEFINE_PROPERTYKEY(PKEY_GPS_AltitudeNumerator, 0x2DAD1EB7, 0x816D, 0x40D3, 0x9E, 0xC3, 0xC9, 0x77, 0x3B, 0xE2, 0xAA, 0xDE, 100);

//  Name:     System.GPS.AltitudeRef -- PKEY_GPS_AltitudeRef
//  Type:     Byte -- VT_UI1
//  FormatID: 46AC629D-75EA-4515-867F-6DC4321C5844, 100
//
//  Indicates the reference for the altitude property. (eg: above sea level, below sea level, absolute value)
DEFINE_PROPERTYKEY(PKEY_GPS_AltitudeRef, 0x46AC629D, 0x75EA, 0x4515, 0x86, 0x7F, 0x6D, 0xC4, 0x32, 0x1C, 0x58, 0x44, 100);

//  Name:     System.GPS.AreaInformation -- PKEY_GPS_AreaInformation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 972E333E-AC7E-49F1-8ADF-A70D07A9BCAB, 100
//
//  Represents the name of the GPS area
DEFINE_PROPERTYKEY(PKEY_GPS_AreaInformation, 0x972E333E, 0xAC7E, 0x49F1, 0x8A, 0xDF, 0xA7, 0x0D, 0x07, 0xA9, 0xBC, 0xAB, 100);

//  Name:     System.GPS.Date -- PKEY_GPS_Date
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 3602C812-0F3B-45F0-85AD-603468D69423, 100
//
//  Date and time of the GPS record
DEFINE_PROPERTYKEY(PKEY_GPS_Date, 0x3602C812, 0x0F3B, 0x45F0, 0x85, 0xAD, 0x60, 0x34, 0x68, 0xD6, 0x94, 0x23, 100);

//  Name:     System.GPS.DestBearing -- PKEY_GPS_DestBearing
//  Type:     Double -- VT_R8
//  FormatID: C66D4B3C-E888-47CC-B99F-9DCA3EE34DEA, 100
//  
//  Indicates the bearing to the destination point.  Calculated from PKEY_GPS_DestBearingNumerator and 
//  PKEY_GPS_DestBearingDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearing, 0xC66D4B3C, 0xE888, 0x47CC, 0xB9, 0x9F, 0x9D, 0xCA, 0x3E, 0xE3, 0x4D, 0xEA, 100);

//  Name:     System.GPS.DestBearingDenominator -- PKEY_GPS_DestBearingDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 7ABCF4F8-7C3F-4988-AC91-8D2C2E97ECA5, 100
//
//  Denominator of PKEY_GPS_DestBearing
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearingDenominator, 0x7ABCF4F8, 0x7C3F, 0x4988, 0xAC, 0x91, 0x8D, 0x2C, 0x2E, 0x97, 0xEC, 0xA5, 100);

//  Name:     System.GPS.DestBearingNumerator -- PKEY_GPS_DestBearingNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: BA3B1DA9-86EE-4B5D-A2A4-A271A429F0CF, 100
//
//  Numerator of PKEY_GPS_DestBearing
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearingNumerator, 0xBA3B1DA9, 0x86EE, 0x4B5D, 0xA2, 0xA4, 0xA2, 0x71, 0xA4, 0x29, 0xF0, 0xCF, 100);

//  Name:     System.GPS.DestBearingRef -- PKEY_GPS_DestBearingRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 9AB84393-2A0F-4B75-BB22-7279786977CB, 100
//
//  Indicates the reference used for the giving the bearing to the destination point.  (eg: true direction, magnetic direction)
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearingRef, 0x9AB84393, 0x2A0F, 0x4B75, 0xBB, 0x22, 0x72, 0x79, 0x78, 0x69, 0x77, 0xCB, 100);

//  Name:     System.GPS.DestDistance -- PKEY_GPS_DestDistance
//  Type:     Double -- VT_R8
//  FormatID: A93EAE04-6804-4F24-AC81-09B266452118, 100
//  
//  Indicates the distance to the destination point.  Calculated from PKEY_GPS_DestDistanceNumerator and 
//  PKEY_GPS_DestDistanceDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistance, 0xA93EAE04, 0x6804, 0x4F24, 0xAC, 0x81, 0x09, 0xB2, 0x66, 0x45, 0x21, 0x18, 100);

//  Name:     System.GPS.DestDistanceDenominator -- PKEY_GPS_DestDistanceDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 9BC2C99B-AC71-4127-9D1C-2596D0D7DCB7, 100
//
//  Denominator of PKEY_GPS_DestDistance
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistanceDenominator, 0x9BC2C99B, 0xAC71, 0x4127, 0x9D, 0x1C, 0x25, 0x96, 0xD0, 0xD7, 0xDC, 0xB7, 100);

//  Name:     System.GPS.DestDistanceNumerator -- PKEY_GPS_DestDistanceNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 2BDA47DA-08C6-4FE1-80BC-A72FC517C5D0, 100
//
//  Numerator of PKEY_GPS_DestDistance
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistanceNumerator, 0x2BDA47DA, 0x08C6, 0x4FE1, 0x80, 0xBC, 0xA7, 0x2F, 0xC5, 0x17, 0xC5, 0xD0, 100);

//  Name:     System.GPS.DestDistanceRef -- PKEY_GPS_DestDistanceRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: ED4DF2D3-8695-450B-856F-F5C1C53ACB66, 100
//
//  Indicates the unit used to express the distance to the destination.  (eg: kilometers, miles, knots)
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistanceRef, 0xED4DF2D3, 0x8695, 0x450B, 0x85, 0x6F, 0xF5, 0xC1, 0xC5, 0x3A, 0xCB, 0x66, 100);

//  Name:     System.GPS.DestLatitude -- PKEY_GPS_DestLatitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: 9D1D7CC5-5C39-451C-86B3-928E2D18CC47, 100
//  
//  Indicates the latitude of the destination point.  This is an array of three values.  Index 0 is the degrees, index 1 
//  is the minutes, index 2 is the seconds.  Each is calculated from the values in PKEY_GPS_DestLatitudeNumerator and 
//  PKEY_GPS_DestLatitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitude, 0x9D1D7CC5, 0x5C39, 0x451C, 0x86, 0xB3, 0x92, 0x8E, 0x2D, 0x18, 0xCC, 0x47, 100);

//  Name:     System.GPS.DestLatitudeDenominator -- PKEY_GPS_DestLatitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 3A372292-7FCA-49A7-99D5-E47BB2D4E7AB, 100
//
//  Denominator of PKEY_GPS_DestLatitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitudeDenominator, 0x3A372292, 0x7FCA, 0x49A7, 0x99, 0xD5, 0xE4, 0x7B, 0xB2, 0xD4, 0xE7, 0xAB, 100);

//  Name:     System.GPS.DestLatitudeNumerator -- PKEY_GPS_DestLatitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: ECF4B6F6-D5A6-433C-BB92-4076650FC890, 100
//
//  Numerator of PKEY_GPS_DestLatitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitudeNumerator, 0xECF4B6F6, 0xD5A6, 0x433C, 0xBB, 0x92, 0x40, 0x76, 0x65, 0x0F, 0xC8, 0x90, 100);

//  Name:     System.GPS.DestLatitudeRef -- PKEY_GPS_DestLatitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CEA820B9-CE61-4885-A128-005D9087C192, 100
//
//  Indicates whether the latitude destination point is north or south latitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitudeRef, 0xCEA820B9, 0xCE61, 0x4885, 0xA1, 0x28, 0x00, 0x5D, 0x90, 0x87, 0xC1, 0x92, 100);

//  Name:     System.GPS.DestLongitude -- PKEY_GPS_DestLongitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: 47A96261-CB4C-4807-8AD3-40B9D9DBC6BC, 100
//  
//  Indicates the latitude of the destination point.  This is an array of three values.  Index 0 is the degrees, index 1 
//  is the minutes, index 2 is the seconds.  Each is calculated from the values in PKEY_GPS_DestLongitudeNumerator and 
//  PKEY_GPS_DestLongitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitude, 0x47A96261, 0xCB4C, 0x4807, 0x8A, 0xD3, 0x40, 0xB9, 0xD9, 0xDB, 0xC6, 0xBC, 100);

//  Name:     System.GPS.DestLongitudeDenominator -- PKEY_GPS_DestLongitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 425D69E5-48AD-4900-8D80-6EB6B8D0AC86, 100
//
//  Denominator of PKEY_GPS_DestLongitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitudeDenominator, 0x425D69E5, 0x48AD, 0x4900, 0x8D, 0x80, 0x6E, 0xB6, 0xB8, 0xD0, 0xAC, 0x86, 100);

//  Name:     System.GPS.DestLongitudeNumerator -- PKEY_GPS_DestLongitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: A3250282-FB6D-48D5-9A89-DBCACE75CCCF, 100
//
//  Numerator of PKEY_GPS_DestLongitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitudeNumerator, 0xA3250282, 0xFB6D, 0x48D5, 0x9A, 0x89, 0xDB, 0xCA, 0xCE, 0x75, 0xCC, 0xCF, 100);

//  Name:     System.GPS.DestLongitudeRef -- PKEY_GPS_DestLongitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 182C1EA6-7C1C-4083-AB4B-AC6C9F4ED128, 100
//
//  Indicates whether the longitude destination point is east or west longitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitudeRef, 0x182C1EA6, 0x7C1C, 0x4083, 0xAB, 0x4B, 0xAC, 0x6C, 0x9F, 0x4E, 0xD1, 0x28, 100);

//  Name:     System.GPS.Differential -- PKEY_GPS_Differential
//  Type:     UInt16 -- VT_UI2
//  FormatID: AAF4EE25-BD3B-4DD7-BFC4-47F77BB00F6D, 100
//
//  Indicates whether differential correction was applied to the GPS receiver
DEFINE_PROPERTYKEY(PKEY_GPS_Differential, 0xAAF4EE25, 0xBD3B, 0x4DD7, 0xBF, 0xC4, 0x47, 0xF7, 0x7B, 0xB0, 0x0F, 0x6D, 100);

//  Name:     System.GPS.DOP -- PKEY_GPS_DOP
//  Type:     Double -- VT_R8
//  FormatID: 0CF8FB02-1837-42F1-A697-A7017AA289B9, 100
//
//  Indicates the GPS DOP (data degree of precision).  Calculated from PKEY_GPS_DOPNumerator and PKEY_GPS_DOPDenominator
DEFINE_PROPERTYKEY(PKEY_GPS_DOP, 0x0CF8FB02, 0x1837, 0x42F1, 0xA6, 0x97, 0xA7, 0x01, 0x7A, 0xA2, 0x89, 0xB9, 100);

//  Name:     System.GPS.DOPDenominator -- PKEY_GPS_DOPDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: A0BE94C5-50BA-487B-BD35-0654BE8881ED, 100
//
//  Denominator of PKEY_GPS_DOP
DEFINE_PROPERTYKEY(PKEY_GPS_DOPDenominator, 0xA0BE94C5, 0x50BA, 0x487B, 0xBD, 0x35, 0x06, 0x54, 0xBE, 0x88, 0x81, 0xED, 100);

//  Name:     System.GPS.DOPNumerator -- PKEY_GPS_DOPNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 47166B16-364F-4AA0-9F31-E2AB3DF449C3, 100
//
//  Numerator of PKEY_GPS_DOP
DEFINE_PROPERTYKEY(PKEY_GPS_DOPNumerator, 0x47166B16, 0x364F, 0x4AA0, 0x9F, 0x31, 0xE2, 0xAB, 0x3D, 0xF4, 0x49, 0xC3, 100);

//  Name:     System.GPS.ImgDirection -- PKEY_GPS_ImgDirection
//  Type:     Double -- VT_R8
//  FormatID: 16473C91-D017-4ED9-BA4D-B6BAA55DBCF8, 100
//  
//  Indicates direction of the image when it was captured.  Calculated from PKEY_GPS_ImgDirectionNumerator and 
//  PKEY_GPS_ImgDirectionDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirection, 0x16473C91, 0xD017, 0x4ED9, 0xBA, 0x4D, 0xB6, 0xBA, 0xA5, 0x5D, 0xBC, 0xF8, 100);

//  Name:     System.GPS.ImgDirectionDenominator -- PKEY_GPS_ImgDirectionDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 10B24595-41A2-4E20-93C2-5761C1395F32, 100
//
//  Denominator of PKEY_GPS_ImgDirection
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirectionDenominator, 0x10B24595, 0x41A2, 0x4E20, 0x93, 0xC2, 0x57, 0x61, 0xC1, 0x39, 0x5F, 0x32, 100);

//  Name:     System.GPS.ImgDirectionNumerator -- PKEY_GPS_ImgDirectionNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: DC5877C7-225F-45F7-BAC7-E81334B6130A, 100
//
//  Numerator of PKEY_GPS_ImgDirection
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirectionNumerator, 0xDC5877C7, 0x225F, 0x45F7, 0xBA, 0xC7, 0xE8, 0x13, 0x34, 0xB6, 0x13, 0x0A, 100);

//  Name:     System.GPS.ImgDirectionRef -- PKEY_GPS_ImgDirectionRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A4AAA5B7-1AD0-445F-811A-0F8F6E67F6B5, 100
//
//  Indicates reference for giving the direction of the image when it was captured.  (eg: true direction, magnetic direction)
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirectionRef, 0xA4AAA5B7, 0x1AD0, 0x445F, 0x81, 0x1A, 0x0F, 0x8F, 0x6E, 0x67, 0xF6, 0xB5, 100);

//  Name:     System.GPS.Latitude -- PKEY_GPS_Latitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: 8727CFFF-4868-4EC6-AD5B-81B98521D1AB, 100
//  
//  Indicates the latitude.  This is an array of three values.  Index 0 is the degrees, index 1 is the minutes, index 2 
//  is the seconds.  Each is calculated from the values in PKEY_GPS_LatitudeNumerator and PKEY_GPS_LatitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Latitude, 0x8727CFFF, 0x4868, 0x4EC6, 0xAD, 0x5B, 0x81, 0xB9, 0x85, 0x21, 0xD1, 0xAB, 100);

//  Name:     System.GPS.LatitudeDenominator -- PKEY_GPS_LatitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 16E634EE-2BFF-497B-BD8A-4341AD39EEB9, 100
//
//  Denominator of PKEY_GPS_Latitude
DEFINE_PROPERTYKEY(PKEY_GPS_LatitudeDenominator, 0x16E634EE, 0x2BFF, 0x497B, 0xBD, 0x8A, 0x43, 0x41, 0xAD, 0x39, 0xEE, 0xB9, 100);

//  Name:     System.GPS.LatitudeNumerator -- PKEY_GPS_LatitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 7DDAAAD1-CCC8-41AE-B750-B2CB8031AEA2, 100
//
//  Numerator of PKEY_GPS_Latitude
DEFINE_PROPERTYKEY(PKEY_GPS_LatitudeNumerator, 0x7DDAAAD1, 0xCCC8, 0x41AE, 0xB7, 0x50, 0xB2, 0xCB, 0x80, 0x31, 0xAE, 0xA2, 100);

//  Name:     System.GPS.LatitudeRef -- PKEY_GPS_LatitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 029C0252-5B86-46C7-ACA0-2769FFC8E3D4, 100
//
//  Indicates whether latitude is north or south latitude 
DEFINE_PROPERTYKEY(PKEY_GPS_LatitudeRef, 0x029C0252, 0x5B86, 0x46C7, 0xAC, 0xA0, 0x27, 0x69, 0xFF, 0xC8, 0xE3, 0xD4, 100);

//  Name:     System.GPS.Longitude -- PKEY_GPS_Longitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: C4C4DBB2-B593-466B-BBDA-D03D27D5E43A, 100
//  
//  Indicates the longitude.  This is an array of three values.  Index 0 is the degrees, index 1 is the minutes, index 2 
//  is the seconds.  Each is calculated from the values in PKEY_GPS_LongitudeNumerator and PKEY_GPS_LongitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Longitude, 0xC4C4DBB2, 0xB593, 0x466B, 0xBB, 0xDA, 0xD0, 0x3D, 0x27, 0xD5, 0xE4, 0x3A, 100);

//  Name:     System.GPS.LongitudeDenominator -- PKEY_GPS_LongitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: BE6E176C-4534-4D2C-ACE5-31DEDAC1606B, 100
//
//  Denominator of PKEY_GPS_Longitude
DEFINE_PROPERTYKEY(PKEY_GPS_LongitudeDenominator, 0xBE6E176C, 0x4534, 0x4D2C, 0xAC, 0xE5, 0x31, 0xDE, 0xDA, 0xC1, 0x60, 0x6B, 100);

//  Name:     System.GPS.LongitudeNumerator -- PKEY_GPS_LongitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 02B0F689-A914-4E45-821D-1DDA452ED2C4, 100
//
//  Numerator of PKEY_GPS_Longitude
DEFINE_PROPERTYKEY(PKEY_GPS_LongitudeNumerator, 0x02B0F689, 0xA914, 0x4E45, 0x82, 0x1D, 0x1D, 0xDA, 0x45, 0x2E, 0xD2, 0xC4, 100);

//  Name:     System.GPS.LongitudeRef -- PKEY_GPS_LongitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 33DCF22B-28D5-464C-8035-1EE9EFD25278, 100
//
//  Indicates whether longitude is east or west longitude
DEFINE_PROPERTYKEY(PKEY_GPS_LongitudeRef, 0x33DCF22B, 0x28D5, 0x464C, 0x80, 0x35, 0x1E, 0xE9, 0xEF, 0xD2, 0x52, 0x78, 100);

//  Name:     System.GPS.MapDatum -- PKEY_GPS_MapDatum
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 2CA2DAE6-EDDC-407D-BEF1-773942ABFA95, 100
//
//  Indicates the geodetic survey data used by the GPS receiver
DEFINE_PROPERTYKEY(PKEY_GPS_MapDatum, 0x2CA2DAE6, 0xEDDC, 0x407D, 0xBE, 0xF1, 0x77, 0x39, 0x42, 0xAB, 0xFA, 0x95, 100);

//  Name:     System.GPS.MeasureMode -- PKEY_GPS_MeasureMode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A015ED5D-AAEA-4D58-8A86-3C586920EA0B, 100
//
//  Indicates the GPS measurement mode.  (eg: 2-dimensional, 3-dimensional)
DEFINE_PROPERTYKEY(PKEY_GPS_MeasureMode, 0xA015ED5D, 0xAAEA, 0x4D58, 0x8A, 0x86, 0x3C, 0x58, 0x69, 0x20, 0xEA, 0x0B, 100);

//  Name:     System.GPS.ProcessingMethod -- PKEY_GPS_ProcessingMethod
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 59D49E61-840F-4AA9-A939-E2099B7F6399, 100
//
//  Indicates the name of the method used for location finding
DEFINE_PROPERTYKEY(PKEY_GPS_ProcessingMethod, 0x59D49E61, 0x840F, 0x4AA9, 0xA9, 0x39, 0xE2, 0x09, 0x9B, 0x7F, 0x63, 0x99, 100);

//  Name:     System.GPS.Satellites -- PKEY_GPS_Satellites
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 467EE575-1F25-4557-AD4E-B8B58B0D9C15, 100
//
//  Indicates the GPS satellites used for measurements
DEFINE_PROPERTYKEY(PKEY_GPS_Satellites, 0x467EE575, 0x1F25, 0x4557, 0xAD, 0x4E, 0xB8, 0xB5, 0x8B, 0x0D, 0x9C, 0x15, 100);

//  Name:     System.GPS.Speed -- PKEY_GPS_Speed
//  Type:     Double -- VT_R8
//  FormatID: DA5D0862-6E76-4E1B-BABD-70021BD25494, 100
//  
//  Indicates the speed of the GPS receiver movement.  Calculated from PKEY_GPS_SpeedNumerator and 
//  PKEY_GPS_SpeedDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Speed, 0xDA5D0862, 0x6E76, 0x4E1B, 0xBA, 0xBD, 0x70, 0x02, 0x1B, 0xD2, 0x54, 0x94, 100);

//  Name:     System.GPS.SpeedDenominator -- PKEY_GPS_SpeedDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 7D122D5A-AE5E-4335-8841-D71E7CE72F53, 100
//
//  Denominator of PKEY_GPS_Speed
DEFINE_PROPERTYKEY(PKEY_GPS_SpeedDenominator, 0x7D122D5A, 0xAE5E, 0x4335, 0x88, 0x41, 0xD7, 0x1E, 0x7C, 0xE7, 0x2F, 0x53, 100);

//  Name:     System.GPS.SpeedNumerator -- PKEY_GPS_SpeedNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: ACC9CE3D-C213-4942-8B48-6D0820F21C6D, 100
//
//  Numerator of PKEY_GPS_Speed
DEFINE_PROPERTYKEY(PKEY_GPS_SpeedNumerator, 0xACC9CE3D, 0xC213, 0x4942, 0x8B, 0x48, 0x6D, 0x08, 0x20, 0xF2, 0x1C, 0x6D, 100);

//  Name:     System.GPS.SpeedRef -- PKEY_GPS_SpeedRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: ECF7F4C9-544F-4D6D-9D98-8AD79ADAF453, 100
//  
//  Indicates the unit used to express the speed of the GPS receiver movement.  (eg: kilometers per hour, 
//  miles per hour, knots).
DEFINE_PROPERTYKEY(PKEY_GPS_SpeedRef, 0xECF7F4C9, 0x544F, 0x4D6D, 0x9D, 0x98, 0x8A, 0xD7, 0x9A, 0xDA, 0xF4, 0x53, 100);

//  Name:     System.GPS.Status -- PKEY_GPS_Status
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 125491F4-818F-46B2-91B5-D537753617B2, 100
//  
//  Indicates the status of the GPS receiver when the image was recorded.  (eg: measurement in progress, 
//  measurement interoperability).
DEFINE_PROPERTYKEY(PKEY_GPS_Status, 0x125491F4, 0x818F, 0x46B2, 0x91, 0xB5, 0xD5, 0x37, 0x75, 0x36, 0x17, 0xB2, 100);

//  Name:     System.GPS.Track -- PKEY_GPS_Track
//  Type:     Double -- VT_R8
//  FormatID: 76C09943-7C33-49E3-9E7E-CDBA872CFADA, 100
//  
//  Indicates the direction of the GPS receiver movement.  Calculated from PKEY_GPS_TrackNumerator and 
//  PKEY_GPS_TrackDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Track, 0x76C09943, 0x7C33, 0x49E3, 0x9E, 0x7E, 0xCD, 0xBA, 0x87, 0x2C, 0xFA, 0xDA, 100);

//  Name:     System.GPS.TrackDenominator -- PKEY_GPS_TrackDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: C8D1920C-01F6-40C0-AC86-2F3A4AD00770, 100
//
//  Denominator of PKEY_GPS_Track
DEFINE_PROPERTYKEY(PKEY_GPS_TrackDenominator, 0xC8D1920C, 0x01F6, 0x40C0, 0xAC, 0x86, 0x2F, 0x3A, 0x4A, 0xD0, 0x07, 0x70, 100);

//  Name:     System.GPS.TrackNumerator -- PKEY_GPS_TrackNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 702926F4-44A6-43E1-AE71-45627116893B, 100
//
//  Numerator of PKEY_GPS_Track
DEFINE_PROPERTYKEY(PKEY_GPS_TrackNumerator, 0x702926F4, 0x44A6, 0x43E1, 0xAE, 0x71, 0x45, 0x62, 0x71, 0x16, 0x89, 0x3B, 100);

//  Name:     System.GPS.TrackRef -- PKEY_GPS_TrackRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 35DBE6FE-44C3-4400-AAAE-D2C799C407E8, 100
//
//  Indicates reference for the direction of the GPS receiver movement.  (eg: true direction, magnetic direction)
DEFINE_PROPERTYKEY(PKEY_GPS_TrackRef, 0x35DBE6FE, 0x44C3, 0x4400, 0xAA, 0xAE, 0xD2, 0xC7, 0x99, 0xC4, 0x07, 0xE8, 100);

//  Name:     System.GPS.VersionID -- PKEY_GPS_VersionID
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: 22704DA4-C6B2-4A99-8E56-F16DF8C92599, 100
//
//  Indicates the version of the GPS information
DEFINE_PROPERTYKEY(PKEY_GPS_VersionID, 0x22704DA4, 0xC6B2, 0x4A99, 0x8E, 0x56, 0xF1, 0x6D, 0xF8, 0xC9, 0x25, 0x99, 100);
 
//-----------------------------------------------------------------------------
// Image properties



//  Name:     System.Image.BitDepth -- PKEY_Image_BitDepth
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 7 (PIDISI_BITDEPTH)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_BitDepth, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 7);

//  Name:     System.Image.ColorSpace -- PKEY_Image_ColorSpace
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 40961
//
//  PropertyTagExifColorSpace
DEFINE_PROPERTYKEY(PKEY_Image_ColorSpace, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 40961);

// Possible discrete values for PKEY_Image_ColorSpace are:
#define IMAGE_COLORSPACE_SRGB               1u
#define IMAGE_COLORSPACE_UNCALIBRATED       0xFFFFu

//  Name:     System.Image.CompressedBitsPerPixel -- PKEY_Image_CompressedBitsPerPixel
//  Type:     Double -- VT_R8
//  FormatID: 364B6FA9-37AB-482A-BE2B-AE02F60D4318, 100
//
//  Calculated from PKEY_Image_CompressedBitsPerPixelNumerator and PKEY_Image_CompressedBitsPerPixelDenominator.
DEFINE_PROPERTYKEY(PKEY_Image_CompressedBitsPerPixel, 0x364B6FA9, 0x37AB, 0x482A, 0xBE, 0x2B, 0xAE, 0x02, 0xF6, 0x0D, 0x43, 0x18, 100);

//  Name:     System.Image.CompressedBitsPerPixelDenominator -- PKEY_Image_CompressedBitsPerPixelDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 1F8844E1-24AD-4508-9DFD-5326A415CE02, 100
//
//  Denominator of PKEY_Image_CompressedBitsPerPixel.
DEFINE_PROPERTYKEY(PKEY_Image_CompressedBitsPerPixelDenominator, 0x1F8844E1, 0x24AD, 0x4508, 0x9D, 0xFD, 0x53, 0x26, 0xA4, 0x15, 0xCE, 0x02, 100);

//  Name:     System.Image.CompressedBitsPerPixelNumerator -- PKEY_Image_CompressedBitsPerPixelNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: D21A7148-D32C-4624-8900-277210F79C0F, 100
//
//  Numerator of PKEY_Image_CompressedBitsPerPixel.
DEFINE_PROPERTYKEY(PKEY_Image_CompressedBitsPerPixelNumerator, 0xD21A7148, 0xD32C, 0x4624, 0x89, 0x00, 0x27, 0x72, 0x10, 0xF7, 0x9C, 0x0F, 100);

//  Name:     System.Image.Compression -- PKEY_Image_Compression
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 259
//
//  Indicates the image compression level.  PropertyTagCompression.
DEFINE_PROPERTYKEY(PKEY_Image_Compression, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 259);

// Possible discrete values for PKEY_Image_Compression are:
#define IMAGE_COMPRESSION_UNCOMPRESSED      1u
#define IMAGE_COMPRESSION_CCITT_T3          2u
#define IMAGE_COMPRESSION_CCITT_T4          3u
#define IMAGE_COMPRESSION_CCITT_T6          4u
#define IMAGE_COMPRESSION_LZW               5u
#define IMAGE_COMPRESSION_JPEG              6u
#define IMAGE_COMPRESSION_PACKBITS          32773u

//  Name:     System.Image.CompressionText -- PKEY_Image_CompressionText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 3F08E66F-2F44-4BB9-A682-AC35D2562322, 100
//  
//  This is the user-friendly form of System.Image.Compression.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Image_CompressionText, 0x3F08E66F, 0x2F44, 0x4BB9, 0xA6, 0x82, 0xAC, 0x35, 0xD2, 0x56, 0x23, 0x22, 100);

//  Name:     System.Image.Dimensions -- PKEY_Image_Dimensions
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 13 (PIDISI_DIMENSIONS)
//
//  Indicates the dimensions of the image.
DEFINE_PROPERTYKEY(PKEY_Image_Dimensions, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 13);

//  Name:     System.Image.HorizontalResolution -- PKEY_Image_HorizontalResolution
//  Type:     Double -- VT_R8
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 5 (PIDISI_RESOLUTIONX)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_HorizontalResolution, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 5);

//  Name:     System.Image.HorizontalSize -- PKEY_Image_HorizontalSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 3 (PIDISI_CX)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_HorizontalSize, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 3);

//  Name:     System.Image.ImageID -- PKEY_Image_ImageID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 10DABE05-32AA-4C29-BF1A-63E2D220587F, 100
DEFINE_PROPERTYKEY(PKEY_Image_ImageID, 0x10DABE05, 0x32AA, 0x4C29, 0xBF, 0x1A, 0x63, 0xE2, 0xD2, 0x20, 0x58, 0x7F, 100);

//  Name:     System.Image.ResolutionUnit -- PKEY_Image_ResolutionUnit
//  Type:     Int16 -- VT_I2
//  FormatID: 19B51FA6-1F92-4A5C-AB48-7DF0ABD67444, 100
DEFINE_PROPERTYKEY(PKEY_Image_ResolutionUnit, 0x19B51FA6, 0x1F92, 0x4A5C, 0xAB, 0x48, 0x7D, 0xF0, 0xAB, 0xD6, 0x74, 0x44, 100);

//  Name:     System.Image.VerticalResolution -- PKEY_Image_VerticalResolution
//  Type:     Double -- VT_R8
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 6 (PIDISI_RESOLUTIONY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_VerticalResolution, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 6);

//  Name:     System.Image.VerticalSize -- PKEY_Image_VerticalSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 4 (PIDISI_CY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_VerticalSize, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 4);

 
 
//-----------------------------------------------------------------------------
// Journal properties

//  Name:     System.Journal.Contacts -- PKEY_Journal_Contacts
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: DEA7C82C-1D89-4A66-9427-A4E3DEBABCB1, 100
DEFINE_PROPERTYKEY(PKEY_Journal_Contacts, 0xDEA7C82C, 0x1D89, 0x4A66, 0x94, 0x27, 0xA4, 0xE3, 0xDE, 0xBA, 0xBC, 0xB1, 100);

//  Name:     System.Journal.EntryType -- PKEY_Journal_EntryType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 95BEB1FC-326D-4644-B396-CD3ED90E6DDF, 100
DEFINE_PROPERTYKEY(PKEY_Journal_EntryType, 0x95BEB1FC, 0x326D, 0x4644, 0xB3, 0x96, 0xCD, 0x3E, 0xD9, 0x0E, 0x6D, 0xDF, 100);
 
//-----------------------------------------------------------------------------
// Link properties



//  Name:     System.Link.Comment -- PKEY_Link_Comment
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_LINK) B9B4B3FC-2B51-4A42-B5D8-324146AFCF25, 5
DEFINE_PROPERTYKEY(PKEY_Link_Comment, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 5);

//  Name:     System.Link.DateVisited -- PKEY_Link_DateVisited
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 5CBF2787-48CF-4208-B90E-EE5E5D420294, 23  (PKEYs relating to URLs.  Used by IE History.)
DEFINE_PROPERTYKEY(PKEY_Link_DateVisited, 0x5CBF2787, 0x48CF, 0x4208, 0xB9, 0x0E, 0xEE, 0x5E, 0x5D, 0x42, 0x02, 0x94, 23);

//  Name:     System.Link.Description -- PKEY_Link_Description
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 5CBF2787-48CF-4208-B90E-EE5E5D420294, 21  (PKEYs relating to URLs.  Used by IE History.)
DEFINE_PROPERTYKEY(PKEY_Link_Description, 0x5CBF2787, 0x48CF, 0x4208, 0xB9, 0x0E, 0xEE, 0x5E, 0x5D, 0x42, 0x02, 0x94, 21);

//  Name:     System.Link.Status -- PKEY_Link_Status
//  Type:     Int32 -- VT_I4
//  FormatID: (PSGUID_LINK) B9B4B3FC-2B51-4A42-B5D8-324146AFCF25, 3 (PID_LINK_TARGET_TYPE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Link_Status, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 3);

// Possible discrete values for PKEY_Link_Status are:
#define LINK_STATUS_RESOLVED                1l
#define LINK_STATUS_BROKEN                  2l

//  Name:     System.Link.TargetExtension -- PKEY_Link_TargetExtension
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: 7A7D76F4-B630-4BD7-95FF-37CC51A975C9, 2
//
//  The file extension of the link target.  See System.File.Extension
DEFINE_PROPERTYKEY(PKEY_Link_TargetExtension, 0x7A7D76F4, 0xB630, 0x4BD7, 0x95, 0xFF, 0x37, 0xCC, 0x51, 0xA9, 0x75, 0xC9, 2);

//  Name:     System.Link.TargetParsingPath -- PKEY_Link_TargetParsingPath
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_LINK) B9B4B3FC-2B51-4A42-B5D8-324146AFCF25, 2 (PID_LINK_TARGET)
//  
//  This is the shell namespace path to the target of the link item.  This path may be passed to 
//  SHParseDisplayName to parse the path to the correct shell folder.
//  
//  If the target item is a file, the value is identical to System.ItemPathDisplay.
//  
//  If the target item cannot be accessed through the shell namespace, this value is VT_EMPTY.
DEFINE_PROPERTYKEY(PKEY_Link_TargetParsingPath, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 2);

//  Name:     System.Link.TargetSFGAOFlags -- PKEY_Link_TargetSFGAOFlags
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_LINK) B9B4B3FC-2B51-4A42-B5D8-324146AFCF25, 8
//  
//  IShellFolder::GetAttributesOf flags for the target of a link, with SFGAO_PKEYSFGAOMASK 
//  attributes masked out.
DEFINE_PROPERTYKEY(PKEY_Link_TargetSFGAOFlags, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 8);
 
//-----------------------------------------------------------------------------
// Media properties



//  Name:     System.Media.AuthorUrl -- PKEY_Media_AuthorUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 32 (PIDMSI_AUTHOR_URL)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_AuthorUrl, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 32);

//  Name:     System.Media.AverageLevel -- PKEY_Media_AverageLevel
//  Type:     UInt32 -- VT_UI4
//  FormatID: 09EDD5B6-B301-43C5-9990-D00302EFFD46, 100
DEFINE_PROPERTYKEY(PKEY_Media_AverageLevel, 0x09EDD5B6, 0xB301, 0x43C5, 0x99, 0x90, 0xD0, 0x03, 0x02, 0xEF, 0xFD, 0x46, 100);

//  Name:     System.Media.ClassPrimaryID -- PKEY_Media_ClassPrimaryID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 13 (PIDMSI_CLASS_PRIMARY_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ClassPrimaryID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 13);

//  Name:     System.Media.ClassSecondaryID -- PKEY_Media_ClassSecondaryID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 14 (PIDMSI_CLASS_SECONDARY_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ClassSecondaryID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 14);

//  Name:     System.Media.CollectionGroupID -- PKEY_Media_CollectionGroupID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 24 (PIDMSI_COLLECTION_GROUP_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CollectionGroupID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 24);

//  Name:     System.Media.CollectionID -- PKEY_Media_CollectionID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 25 (PIDMSI_COLLECTION_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CollectionID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 25);

//  Name:     System.Media.ContentDistributor -- PKEY_Media_ContentDistributor
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 18 (PIDMSI_CONTENTDISTRIBUTOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ContentDistributor, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 18);

//  Name:     System.Media.ContentID -- PKEY_Media_ContentID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 26 (PIDMSI_CONTENT_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ContentID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 26);

//  Name:     System.Media.CreatorApplication -- PKEY_Media_CreatorApplication
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 27 (PIDMSI_TOOL_NAME)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CreatorApplication, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 27);

//  Name:     System.Media.CreatorApplicationVersion -- PKEY_Media_CreatorApplicationVersion
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 28 (PIDMSI_TOOL_VERSION)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CreatorApplicationVersion, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 28);

//  Name:     System.Media.DateEncoded -- PKEY_Media_DateEncoded
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 2E4B640D-5019-46D8-8881-55414CC5CAA0, 100
//
//  DateTime is in UTC (in the doc, not file system).
DEFINE_PROPERTYKEY(PKEY_Media_DateEncoded, 0x2E4B640D, 0x5019, 0x46D8, 0x88, 0x81, 0x55, 0x41, 0x4C, 0xC5, 0xCA, 0xA0, 100);

//  Name:     System.Media.DateReleased -- PKEY_Media_DateReleased
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DE41CC29-6971-4290-B472-F59F2E2F31E2, 100
DEFINE_PROPERTYKEY(PKEY_Media_DateReleased, 0xDE41CC29, 0x6971, 0x4290, 0xB4, 0x72, 0xF5, 0x9F, 0x2E, 0x2F, 0x31, 0xE2, 100);

//  Name:     System.Media.Duration -- PKEY_Media_Duration
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 3 (PIDASI_TIMELENGTH)
//
//  100ns units, not milliseconds
DEFINE_PROPERTYKEY(PKEY_Media_Duration, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 3);

//  Name:     System.Media.DVDID -- PKEY_Media_DVDID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 15 (PIDMSI_DVDID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_DVDID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 15);

//  Name:     System.Media.EncodedBy -- PKEY_Media_EncodedBy
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 36 (PIDMSI_ENCODED_BY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_EncodedBy, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 36);

//  Name:     System.Media.EncodingSettings -- PKEY_Media_EncodingSettings
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 37 (PIDMSI_ENCODING_SETTINGS)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_EncodingSettings, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 37);

//  Name:     System.Media.FrameCount -- PKEY_Media_FrameCount
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 12 (PIDISI_FRAMECOUNT)
//
//  Indicates the frame count for the image.
DEFINE_PROPERTYKEY(PKEY_Media_FrameCount, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 12);

//  Name:     System.Media.MCDI -- PKEY_Media_MCDI
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 16 (PIDMSI_MCDI)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_MCDI, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 16);

//  Name:     System.Media.MetadataContentProvider -- PKEY_Media_MetadataContentProvider
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 17 (PIDMSI_PROVIDER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_MetadataContentProvider, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 17);

//  Name:     System.Media.Producer -- PKEY_Media_Producer
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 22 (PIDMSI_PRODUCER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Producer, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 22);

//  Name:     System.Media.PromotionUrl -- PKEY_Media_PromotionUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 33 (PIDMSI_PROMOTION_URL)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_PromotionUrl, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 33);

//  Name:     System.Media.ProtectionType -- PKEY_Media_ProtectionType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 38
//  
//  If media is protected, how is it protected?
DEFINE_PROPERTYKEY(PKEY_Media_ProtectionType, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 38);

//  Name:     System.Media.ProviderRating -- PKEY_Media_ProviderRating
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 39
//  
//  Rating (0 - 99) supplied by metadata provider
DEFINE_PROPERTYKEY(PKEY_Media_ProviderRating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 39);

//  Name:     System.Media.ProviderStyle -- PKEY_Media_ProviderStyle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 40
//  
//  Style of music or video, supplied by metadata provider
DEFINE_PROPERTYKEY(PKEY_Media_ProviderStyle, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 40);

//  Name:     System.Media.Publisher -- PKEY_Media_Publisher
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 30 (PIDMSI_PUBLISHER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Publisher, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 30);

//  Name:     System.Media.SubscriptionContentId -- PKEY_Media_SubscriptionContentId
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 9AEBAE7A-9644-487D-A92C-657585ED751A, 100
DEFINE_PROPERTYKEY(PKEY_Media_SubscriptionContentId, 0x9AEBAE7A, 0x9644, 0x487D, 0xA9, 0x2C, 0x65, 0x75, 0x85, 0xED, 0x75, 0x1A, 100);

//  Name:     System.Media.SubTitle -- PKEY_Media_SubTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 38 (PIDSI_MUSIC_SUB_TITLE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_SubTitle, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 38);

//  Name:     System.Media.UniqueFileIdentifier -- PKEY_Media_UniqueFileIdentifier
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 35 (PIDMSI_UNIQUE_FILE_IDENTIFIER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_UniqueFileIdentifier, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 35);

//  Name:     System.Media.UserNoAutoInfo -- PKEY_Media_UserNoAutoInfo
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 41
//  
//  If true, do NOT alter this file's metadata. Set by user.
DEFINE_PROPERTYKEY(PKEY_Media_UserNoAutoInfo, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 41);

//  Name:     System.Media.UserWebUrl -- PKEY_Media_UserWebUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 34 (PIDMSI_USER_WEB_URL)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_UserWebUrl, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 34);

//  Name:     System.Media.Writer -- PKEY_Media_Writer
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 23 (PIDMSI_WRITER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Writer, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 23);

//  Name:     System.Media.Year -- PKEY_Media_Year
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 5 (PIDSI_MUSIC_YEAR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Year, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 5);
 
//-----------------------------------------------------------------------------
// Message properties



//  Name:     System.Message.AttachmentContents -- PKEY_Message_AttachmentContents
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 3143BF7C-80A8-4854-8880-E2E40189BDD0, 100
DEFINE_PROPERTYKEY(PKEY_Message_AttachmentContents, 0x3143BF7C, 0x80A8, 0x4854, 0x88, 0x80, 0xE2, 0xE4, 0x01, 0x89, 0xBD, 0xD0, 100);

//  Name:     System.Message.AttachmentNames -- PKEY_Message_AttachmentNames
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 21
//
//  The names of the attachments in a message
DEFINE_PROPERTYKEY(PKEY_Message_AttachmentNames, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 21);

//  Name:     System.Message.BccAddress -- PKEY_Message_BccAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 2
//
//  Addresses in Bcc: field
DEFINE_PROPERTYKEY(PKEY_Message_BccAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 2);

//  Name:     System.Message.BccName -- PKEY_Message_BccName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 3
//
//  person names in Bcc: field
DEFINE_PROPERTYKEY(PKEY_Message_BccName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 3);

//  Name:     System.Message.CcAddress -- PKEY_Message_CcAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 4
//
//  Addresses in Cc: field
DEFINE_PROPERTYKEY(PKEY_Message_CcAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 4);

//  Name:     System.Message.CcName -- PKEY_Message_CcName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 5
//
//  person names in Cc: field
DEFINE_PROPERTYKEY(PKEY_Message_CcName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 5);

//  Name:     System.Message.ConversationID -- PKEY_Message_ConversationID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DC8F80BD-AF1E-4289-85B6-3DFC1B493992, 100
DEFINE_PROPERTYKEY(PKEY_Message_ConversationID, 0xDC8F80BD, 0xAF1E, 0x4289, 0x85, 0xB6, 0x3D, 0xFC, 0x1B, 0x49, 0x39, 0x92, 100);

//  Name:     System.Message.ConversationIndex -- PKEY_Message_ConversationIndex
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: DC8F80BD-AF1E-4289-85B6-3DFC1B493992, 101
//  
//  
DEFINE_PROPERTYKEY(PKEY_Message_ConversationIndex, 0xDC8F80BD, 0xAF1E, 0x4289, 0x85, 0xB6, 0x3D, 0xFC, 0x1B, 0x49, 0x39, 0x92, 101);

//  Name:     System.Message.DateReceived -- PKEY_Message_DateReceived
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 20
//
//  Date and Time communication was received
DEFINE_PROPERTYKEY(PKEY_Message_DateReceived, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 20);

//  Name:     System.Message.DateSent -- PKEY_Message_DateSent
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 19
//
//  Date and Time communication was sent
DEFINE_PROPERTYKEY(PKEY_Message_DateSent, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 19);

//  Name:     System.Message.FromAddress -- PKEY_Message_FromAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 13
DEFINE_PROPERTYKEY(PKEY_Message_FromAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 13);

//  Name:     System.Message.FromName -- PKEY_Message_FromName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 14
//
//  Address in from field as person name
DEFINE_PROPERTYKEY(PKEY_Message_FromName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 14);

//  Name:     System.Message.HasAttachments -- PKEY_Message_HasAttachments
//  Type:     Boolean -- VT_BOOL
//  FormatID: 9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4, 8
//
//  
DEFINE_PROPERTYKEY(PKEY_Message_HasAttachments, 0x9C1FCF74, 0x2D97, 0x41BA, 0xB4, 0xAE, 0xCB, 0x2E, 0x36, 0x61, 0xA6, 0xE4, 8);

//  Name:     System.Message.IsFwdOrReply -- PKEY_Message_IsFwdOrReply
//  Type:     Int32 -- VT_I4
//  FormatID: 9A9BC088-4F6D-469E-9919-E705412040F9, 100
DEFINE_PROPERTYKEY(PKEY_Message_IsFwdOrReply, 0x9A9BC088, 0x4F6D, 0x469E, 0x99, 0x19, 0xE7, 0x05, 0x41, 0x20, 0x40, 0xF9, 100);

//  Name:     System.Message.MessageClass -- PKEY_Message_MessageClass
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CD9ED458-08CE-418F-A70E-F912C7BB9C5C, 103
//  
//  What type of outlook msg this is (meeting, task, mail, etc.)
DEFINE_PROPERTYKEY(PKEY_Message_MessageClass, 0xCD9ED458, 0x08CE, 0x418F, 0xA7, 0x0E, 0xF9, 0x12, 0xC7, 0xBB, 0x9C, 0x5C, 103);

//  Name:     System.Message.SenderAddress -- PKEY_Message_SenderAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 0BE1C8E7-1981-4676-AE14-FDD78F05A6E7, 100
DEFINE_PROPERTYKEY(PKEY_Message_SenderAddress, 0x0BE1C8E7, 0x1981, 0x4676, 0xAE, 0x14, 0xFD, 0xD7, 0x8F, 0x05, 0xA6, 0xE7, 100);

//  Name:     System.Message.SenderName -- PKEY_Message_SenderName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 0DA41CFA-D224-4A18-AE2F-596158DB4B3A, 100
DEFINE_PROPERTYKEY(PKEY_Message_SenderName, 0x0DA41CFA, 0xD224, 0x4A18, 0xAE, 0x2F, 0x59, 0x61, 0x58, 0xDB, 0x4B, 0x3A, 100);

//  Name:     System.Message.Store -- PKEY_Message_Store
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 15
//
//  The store (aka protocol handler) FILE, MAIL, OUTLOOKEXPRESS
DEFINE_PROPERTYKEY(PKEY_Message_Store, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 15);

//  Name:     System.Message.ToAddress -- PKEY_Message_ToAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 16
//
//  Addresses in To: field
DEFINE_PROPERTYKEY(PKEY_Message_ToAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 16);

//  Name:     System.Message.ToDoTitle -- PKEY_Message_ToDoTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: BCCC8A3C-8CEF-42E5-9B1C-C69079398BC7, 100
DEFINE_PROPERTYKEY(PKEY_Message_ToDoTitle, 0xBCCC8A3C, 0x8CEF, 0x42E5, 0x9B, 0x1C, 0xC6, 0x90, 0x79, 0x39, 0x8B, 0xC7, 100);

//  Name:     System.Message.ToName -- PKEY_Message_ToName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 17
//
//  Person names in To: field
DEFINE_PROPERTYKEY(PKEY_Message_ToName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 17);
 
//-----------------------------------------------------------------------------
// Music properties

//  Name:     System.Music.AlbumArtist -- PKEY_Music_AlbumArtist
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 13 (PIDSI_MUSIC_ALBUM_ARTIST)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_AlbumArtist, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 13);

//  Name:     System.Music.AlbumTitle -- PKEY_Music_AlbumTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 4 (PIDSI_MUSIC_ALBUM)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_AlbumTitle, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 4);

//  Name:     System.Music.Artist -- PKEY_Music_Artist
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 2 (PIDSI_MUSIC_ARTIST)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Artist, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 2);

//  Name:     System.Music.BeatsPerMinute -- PKEY_Music_BeatsPerMinute
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 35 (PIDSI_MUSIC_BEATS_PER_MINUTE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_BeatsPerMinute, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 35);

//  Name:     System.Music.Composer -- PKEY_Music_Composer
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 19 (PIDMSI_COMPOSER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Composer, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 19);

//  Name:     System.Music.Conductor -- PKEY_Music_Conductor
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 36 (PIDSI_MUSIC_CONDUCTOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Conductor, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 36);

//  Name:     System.Music.ContentGroupDescription -- PKEY_Music_ContentGroupDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 33 (PIDSI_MUSIC_CONTENT_GROUP_DESCRIPTION)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_ContentGroupDescription, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 33);

//  Name:     System.Music.Genre -- PKEY_Music_Genre
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 11 (PIDSI_MUSIC_GENRE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Genre, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 11);

//  Name:     System.Music.InitialKey -- PKEY_Music_InitialKey
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 34 (PIDSI_MUSIC_INITIAL_KEY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_InitialKey, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 34);

//  Name:     System.Music.Lyrics -- PKEY_Music_Lyrics
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 12 (PIDSI_MUSIC_LYRICS)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Lyrics, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 12);

//  Name:     System.Music.Mood -- PKEY_Music_Mood
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 39 (PIDSI_MUSIC_MOOD)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Mood, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 39);

//  Name:     System.Music.PartOfSet -- PKEY_Music_PartOfSet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 37 (PIDSI_MUSIC_PART_OF_SET)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_PartOfSet, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 37);

//  Name:     System.Music.Period -- PKEY_Music_Period
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 31 (PIDMSI_PERIOD)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Period, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 31);

//  Name:     System.Music.SynchronizedLyrics -- PKEY_Music_SynchronizedLyrics
//  Type:     Blob -- VT_BLOB
//  FormatID: 6B223B6A-162E-4AA9-B39F-05D678FC6D77, 100
DEFINE_PROPERTYKEY(PKEY_Music_SynchronizedLyrics, 0x6B223B6A, 0x162E, 0x4AA9, 0xB3, 0x9F, 0x05, 0xD6, 0x78, 0xFC, 0x6D, 0x77, 100);

//  Name:     System.Music.TrackNumber -- PKEY_Music_TrackNumber
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 7 (PIDSI_MUSIC_TRACK)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_TrackNumber, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 7);

 
 
//-----------------------------------------------------------------------------
// Note properties

//  Name:     System.Note.Color -- PKEY_Note_Color
//  Type:     UInt16 -- VT_UI2
//  FormatID: 4776CAFA-BCE4-4CB1-A23E-265E76D8EB11, 100
DEFINE_PROPERTYKEY(PKEY_Note_Color, 0x4776CAFA, 0xBCE4, 0x4CB1, 0xA2, 0x3E, 0x26, 0x5E, 0x76, 0xD8, 0xEB, 0x11, 100);

// Possible discrete values for PKEY_Note_Color are:
#define NOTE_COLOR_BLUE                     0u
#define NOTE_COLOR_GREEN                    1u
#define NOTE_COLOR_PINK                     2u
#define NOTE_COLOR_YELLOW                   3u
#define NOTE_COLOR_WHITE                    4u
#define NOTE_COLOR_LIGHTGREEN               5u

//  Name:     System.Note.ColorText -- PKEY_Note_ColorText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 46B4E8DE-CDB2-440D-885C-1658EB65B914, 100
//  
//  This is the user-friendly form of System.Note.Color.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Note_ColorText, 0x46B4E8DE, 0xCDB2, 0x440D, 0x88, 0x5C, 0x16, 0x58, 0xEB, 0x65, 0xB9, 0x14, 100);
 
//-----------------------------------------------------------------------------
// Photo properties



//  Name:     System.Photo.Aperture -- PKEY_Photo_Aperture
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37378
//
//  PropertyTagExifAperture.  Calculated from PKEY_Photo_ApertureNumerator and PKEY_Photo_ApertureDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_Aperture, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37378);

//  Name:     System.Photo.ApertureDenominator -- PKEY_Photo_ApertureDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: E1A9A38B-6685-46BD-875E-570DC7AD7320, 100
//
//  Denominator of PKEY_Photo_Aperture
DEFINE_PROPERTYKEY(PKEY_Photo_ApertureDenominator, 0xE1A9A38B, 0x6685, 0x46BD, 0x87, 0x5E, 0x57, 0x0D, 0xC7, 0xAD, 0x73, 0x20, 100);

//  Name:     System.Photo.ApertureNumerator -- PKEY_Photo_ApertureNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 0337ECEC-39FB-4581-A0BD-4C4CC51E9914, 100
//
//  Numerator of PKEY_Photo_Aperture
DEFINE_PROPERTYKEY(PKEY_Photo_ApertureNumerator, 0x0337ECEC, 0x39FB, 0x4581, 0xA0, 0xBD, 0x4C, 0x4C, 0xC5, 0x1E, 0x99, 0x14, 100);

//  Name:     System.Photo.Brightness -- PKEY_Photo_Brightness
//  Type:     Double -- VT_R8
//  FormatID: 1A701BF6-478C-4361-83AB-3701BB053C58, 100 (PropertyTagExifBrightness)
//  
//  This is the brightness of the photo.
//  
//  Calculated from PKEY_Photo_BrightnessNumerator and PKEY_Photo_BrightnessDenominator.
//  
//  The units are "APEX", normally in the range of -99.99 to 99.99. If the numerator of 
//  the recorded value is FFFFFFFF.H, "Unknown" should be indicated.
DEFINE_PROPERTYKEY(PKEY_Photo_Brightness, 0x1A701BF6, 0x478C, 0x4361, 0x83, 0xAB, 0x37, 0x01, 0xBB, 0x05, 0x3C, 0x58, 100);

//  Name:     System.Photo.BrightnessDenominator -- PKEY_Photo_BrightnessDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 6EBE6946-2321-440A-90F0-C043EFD32476, 100
//
//  Denominator of PKEY_Photo_Brightness
DEFINE_PROPERTYKEY(PKEY_Photo_BrightnessDenominator, 0x6EBE6946, 0x2321, 0x440A, 0x90, 0xF0, 0xC0, 0x43, 0xEF, 0xD3, 0x24, 0x76, 100);

//  Name:     System.Photo.BrightnessNumerator -- PKEY_Photo_BrightnessNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 9E7D118F-B314-45A0-8CFB-D654B917C9E9, 100
//
//  Numerator of PKEY_Photo_Brightness
DEFINE_PROPERTYKEY(PKEY_Photo_BrightnessNumerator, 0x9E7D118F, 0xB314, 0x45A0, 0x8C, 0xFB, 0xD6, 0x54, 0xB9, 0x17, 0xC9, 0xE9, 100);

//  Name:     System.Photo.CameraManufacturer -- PKEY_Photo_CameraManufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 271 (PropertyTagEquipMake)
//
//  
DEFINE_PROPERTYKEY(PKEY_Photo_CameraManufacturer, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 271);

//  Name:     System.Photo.CameraModel -- PKEY_Photo_CameraModel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 272 (PropertyTagEquipModel)
//
//  
DEFINE_PROPERTYKEY(PKEY_Photo_CameraModel, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 272);

//  Name:     System.Photo.CameraSerialNumber -- PKEY_Photo_CameraSerialNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 273
//
//  Serial number of camera that produced this photo
DEFINE_PROPERTYKEY(PKEY_Photo_CameraSerialNumber, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 273);

//  Name:     System.Photo.Contrast -- PKEY_Photo_Contrast
//  Type:     UInt32 -- VT_UI4
//  FormatID: 2A785BA9-8D23-4DED-82E6-60A350C86A10, 100
//  
//  This indicates the direction of contrast processing applied by the camera 
//  when the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_Contrast, 0x2A785BA9, 0x8D23, 0x4DED, 0x82, 0xE6, 0x60, 0xA3, 0x50, 0xC8, 0x6A, 0x10, 100);

// Possible discrete values for PKEY_Photo_Contrast are:
#define PHOTO_CONTRAST_NORMAL               0ul
#define PHOTO_CONTRAST_SOFT                 1ul
#define PHOTO_CONTRAST_HARD                 2ul

//  Name:     System.Photo.ContrastText -- PKEY_Photo_ContrastText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 59DDE9F2-5253-40EA-9A8B-479E96C6249A, 100
//  
//  This is the user-friendly form of System.Photo.Contrast.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_ContrastText, 0x59DDE9F2, 0x5253, 0x40EA, 0x9A, 0x8B, 0x47, 0x9E, 0x96, 0xC6, 0x24, 0x9A, 100);

//  Name:     System.Photo.DateTaken -- PKEY_Photo_DateTaken
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 36867
//
//  PropertyTagExifDTOrig
DEFINE_PROPERTYKEY(PKEY_Photo_DateTaken, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 36867);

//  Name:     System.Photo.DigitalZoom -- PKEY_Photo_DigitalZoom
//  Type:     Double -- VT_R8
//  FormatID: F85BF840-A925-4BC2-B0C4-8E36B598679E, 100
//
//  PropertyTagExifDigitalZoom.  Calculated from PKEY_Photo_DigitalZoomNumerator and PKEY_Photo_DigitalZoomDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_DigitalZoom, 0xF85BF840, 0xA925, 0x4BC2, 0xB0, 0xC4, 0x8E, 0x36, 0xB5, 0x98, 0x67, 0x9E, 100);

//  Name:     System.Photo.DigitalZoomDenominator -- PKEY_Photo_DigitalZoomDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 745BAF0E-E5C1-4CFB-8A1B-D031A0A52393, 100
//
//  Denominator of PKEY_Photo_DigitalZoom
DEFINE_PROPERTYKEY(PKEY_Photo_DigitalZoomDenominator, 0x745BAF0E, 0xE5C1, 0x4CFB, 0x8A, 0x1B, 0xD0, 0x31, 0xA0, 0xA5, 0x23, 0x93, 100);

//  Name:     System.Photo.DigitalZoomNumerator -- PKEY_Photo_DigitalZoomNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 16CBB924-6500-473B-A5BE-F1599BCBE413, 100
//
//  Numerator of PKEY_Photo_DigitalZoom
DEFINE_PROPERTYKEY(PKEY_Photo_DigitalZoomNumerator, 0x16CBB924, 0x6500, 0x473B, 0xA5, 0xBE, 0xF1, 0x59, 0x9B, 0xCB, 0xE4, 0x13, 100);

//  Name:     System.Photo.Event -- PKEY_Photo_Event
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 18248
//
//  The event at which the photo was taken
DEFINE_PROPERTYKEY(PKEY_Photo_Event, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 18248);

//  Name:     System.Photo.EXIFVersion -- PKEY_Photo_EXIFVersion
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D35F743A-EB2E-47F2-A286-844132CB1427, 100
//
//  The EXIF version.
DEFINE_PROPERTYKEY(PKEY_Photo_EXIFVersion, 0xD35F743A, 0xEB2E, 0x47F2, 0xA2, 0x86, 0x84, 0x41, 0x32, 0xCB, 0x14, 0x27, 100);

//  Name:     System.Photo.ExposureBias -- PKEY_Photo_ExposureBias
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37380
//
//  PropertyTagExifExposureBias.  Calculated from PKEY_Photo_ExposureBiasNumerator and PKEY_Photo_ExposureBiasDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureBias, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37380);

//  Name:     System.Photo.ExposureBiasDenominator -- PKEY_Photo_ExposureBiasDenominator
//  Type:     Int32 -- VT_I4
//  FormatID: AB205E50-04B7-461C-A18C-2F233836E627, 100
//
//  Denominator of PKEY_Photo_ExposureBias
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureBiasDenominator, 0xAB205E50, 0x04B7, 0x461C, 0xA1, 0x8C, 0x2F, 0x23, 0x38, 0x36, 0xE6, 0x27, 100);

//  Name:     System.Photo.ExposureBiasNumerator -- PKEY_Photo_ExposureBiasNumerator
//  Type:     Int32 -- VT_I4
//  FormatID: 738BF284-1D87-420B-92CF-5834BF6EF9ED, 100
//
//  Numerator of PKEY_Photo_ExposureBias
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureBiasNumerator, 0x738BF284, 0x1D87, 0x420B, 0x92, 0xCF, 0x58, 0x34, 0xBF, 0x6E, 0xF9, 0xED, 100);

//  Name:     System.Photo.ExposureIndex -- PKEY_Photo_ExposureIndex
//  Type:     Double -- VT_R8
//  FormatID: 967B5AF8-995A-46ED-9E11-35B3C5B9782D, 100
//
//  PropertyTagExifExposureIndex.  Calculated from PKEY_Photo_ExposureIndexNumerator and PKEY_Photo_ExposureIndexDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureIndex, 0x967B5AF8, 0x995A, 0x46ED, 0x9E, 0x11, 0x35, 0xB3, 0xC5, 0xB9, 0x78, 0x2D, 100);

//  Name:     System.Photo.ExposureIndexDenominator -- PKEY_Photo_ExposureIndexDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 93112F89-C28B-492F-8A9D-4BE2062CEE8A, 100
//
//  Denominator of PKEY_Photo_ExposureIndex
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureIndexDenominator, 0x93112F89, 0xC28B, 0x492F, 0x8A, 0x9D, 0x4B, 0xE2, 0x06, 0x2C, 0xEE, 0x8A, 100);

//  Name:     System.Photo.ExposureIndexNumerator -- PKEY_Photo_ExposureIndexNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: CDEDCF30-8919-44DF-8F4C-4EB2FFDB8D89, 100
//
//  Numerator of PKEY_Photo_ExposureIndex
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureIndexNumerator, 0xCDEDCF30, 0x8919, 0x44DF, 0x8F, 0x4C, 0x4E, 0xB2, 0xFF, 0xDB, 0x8D, 0x89, 100);

//  Name:     System.Photo.ExposureProgram -- PKEY_Photo_ExposureProgram
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 34850 (PropertyTagExifExposureProg)
//
//  
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureProgram, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 34850);

// Possible discrete values for PKEY_Photo_ExposureProgram are:
#define PHOTO_EXPOSUREPROGRAM_UNKNOWN       0ul
#define PHOTO_EXPOSUREPROGRAM_MANUAL        1ul
#define PHOTO_EXPOSUREPROGRAM_NORMAL        2ul
#define PHOTO_EXPOSUREPROGRAM_APERTURE      3ul
#define PHOTO_EXPOSUREPROGRAM_SHUTTER       4ul
#define PHOTO_EXPOSUREPROGRAM_CREATIVE      5ul
#define PHOTO_EXPOSUREPROGRAM_ACTION        6ul
#define PHOTO_EXPOSUREPROGRAM_PORTRAIT      7ul
#define PHOTO_EXPOSUREPROGRAM_LANDSCAPE     8ul

//  Name:     System.Photo.ExposureProgramText -- PKEY_Photo_ExposureProgramText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: FEC690B7-5F30-4646-AE47-4CAAFBA884A3, 100
//  
//  This is the user-friendly form of System.Photo.ExposureProgram.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureProgramText, 0xFEC690B7, 0x5F30, 0x4646, 0xAE, 0x47, 0x4C, 0xAA, 0xFB, 0xA8, 0x84, 0xA3, 100);

//  Name:     System.Photo.ExposureTime -- PKEY_Photo_ExposureTime
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 33434
//
//  PropertyTagExifExposureTime.  Calculated from  PKEY_Photo_ExposureTimeNumerator and PKEY_Photo_ExposureTimeDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureTime, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 33434);

//  Name:     System.Photo.ExposureTimeDenominator -- PKEY_Photo_ExposureTimeDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 55E98597-AD16-42E0-B624-21599A199838, 100
//
//  Denominator of PKEY_Photo_ExposureTime
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureTimeDenominator, 0x55E98597, 0xAD16, 0x42E0, 0xB6, 0x24, 0x21, 0x59, 0x9A, 0x19, 0x98, 0x38, 100);

//  Name:     System.Photo.ExposureTimeNumerator -- PKEY_Photo_ExposureTimeNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 257E44E2-9031-4323-AC38-85C552871B2E, 100
//
//  Numerator of PKEY_Photo_ExposureTime
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureTimeNumerator, 0x257E44E2, 0x9031, 0x4323, 0xAC, 0x38, 0x85, 0xC5, 0x52, 0x87, 0x1B, 0x2E, 100);

//  Name:     System.Photo.Flash -- PKEY_Photo_Flash
//  Type:     Byte -- VT_UI1
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37385
//
//  PropertyTagExifFlash
DEFINE_PROPERTYKEY(PKEY_Photo_Flash, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37385);

// Possible discrete values for PKEY_Photo_Flash are:
#define PHOTO_FLASH_NONE                    0
#define PHOTO_FLASH_FLASH                   1
#define PHOTO_FLASH_WITHOUTSTROBE           5
#define PHOTO_FLASH_WITHSTROBE              7

//  Name:     System.Photo.FlashEnergy -- PKEY_Photo_FlashEnergy
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 41483
//
//  PropertyTagExifFlashEnergy.  Calculated from PKEY_Photo_FlashEnergyNumerator and PKEY_Photo_FlashEnergyDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_FlashEnergy, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 41483);

//  Name:     System.Photo.FlashEnergyDenominator -- PKEY_Photo_FlashEnergyDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: D7B61C70-6323-49CD-A5FC-C84277162C97, 100
//
//  Denominator of PKEY_Photo_FlashEnergy
DEFINE_PROPERTYKEY(PKEY_Photo_FlashEnergyDenominator, 0xD7B61C70, 0x6323, 0x49CD, 0xA5, 0xFC, 0xC8, 0x42, 0x77, 0x16, 0x2C, 0x97, 100);

//  Name:     System.Photo.FlashEnergyNumerator -- PKEY_Photo_FlashEnergyNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: FCAD3D3D-0858-400F-AAA3-2F66CCE2A6BC, 100
//
//  Numerator of PKEY_Photo_FlashEnergy
DEFINE_PROPERTYKEY(PKEY_Photo_FlashEnergyNumerator, 0xFCAD3D3D, 0x0858, 0x400F, 0xAA, 0xA3, 0x2F, 0x66, 0xCC, 0xE2, 0xA6, 0xBC, 100);

//  Name:     System.Photo.FlashManufacturer -- PKEY_Photo_FlashManufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: AABAF6C9-E0C5-4719-8585-57B103E584FE, 100
DEFINE_PROPERTYKEY(PKEY_Photo_FlashManufacturer, 0xAABAF6C9, 0xE0C5, 0x4719, 0x85, 0x85, 0x57, 0xB1, 0x03, 0xE5, 0x84, 0xFE, 100);

//  Name:     System.Photo.FlashModel -- PKEY_Photo_FlashModel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: FE83BB35-4D1A-42E2-916B-06F3E1AF719E, 100
DEFINE_PROPERTYKEY(PKEY_Photo_FlashModel, 0xFE83BB35, 0x4D1A, 0x42E2, 0x91, 0x6B, 0x06, 0xF3, 0xE1, 0xAF, 0x71, 0x9E, 100);

//  Name:     System.Photo.FlashText -- PKEY_Photo_FlashText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6B8B68F6-200B-47EA-8D25-D8050F57339F, 100
//  
//  This is the user-friendly form of System.Photo.Flash.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_FlashText, 0x6B8B68F6, 0x200B, 0x47EA, 0x8D, 0x25, 0xD8, 0x05, 0x0F, 0x57, 0x33, 0x9F, 100);

//  Name:     System.Photo.FNumber -- PKEY_Photo_FNumber
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 33437
//
//  PropertyTagExifFNumber.  Calculated from PKEY_Photo_FNumberNumerator and PKEY_Photo_FNumberDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_FNumber, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 33437);

//  Name:     System.Photo.FNumberDenominator -- PKEY_Photo_FNumberDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: E92A2496-223B-4463-A4E3-30EABBA79D80, 100
//
//  Denominator of PKEY_Photo_FNumber
DEFINE_PROPERTYKEY(PKEY_Photo_FNumberDenominator, 0xE92A2496, 0x223B, 0x4463, 0xA4, 0xE3, 0x30, 0xEA, 0xBB, 0xA7, 0x9D, 0x80, 100);

//  Name:     System.Photo.FNumberNumerator -- PKEY_Photo_FNumberNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 1B97738A-FDFC-462F-9D93-1957E08BE90C, 100
//
//  Numerator of PKEY_Photo_FNumber
DEFINE_PROPERTYKEY(PKEY_Photo_FNumberNumerator, 0x1B97738A, 0xFDFC, 0x462F, 0x9D, 0x93, 0x19, 0x57, 0xE0, 0x8B, 0xE9, 0x0C, 100);

//  Name:     System.Photo.FocalLength -- PKEY_Photo_FocalLength
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37386
//
//  PropertyTagExifFocalLength.  Calculated from PKEY_Photo_FocalLengthNumerator and PKEY_Photo_FocalLengthDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLength, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37386);

//  Name:     System.Photo.FocalLengthDenominator -- PKEY_Photo_FocalLengthDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 305BC615-DCA1-44A5-9FD4-10C0BA79412E, 100
//
//  Denominator of PKEY_Photo_FocalLength
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLengthDenominator, 0x305BC615, 0xDCA1, 0x44A5, 0x9F, 0xD4, 0x10, 0xC0, 0xBA, 0x79, 0x41, 0x2E, 100);

//  Name:     System.Photo.FocalLengthInFilm -- PKEY_Photo_FocalLengthInFilm
//  Type:     UInt16 -- VT_UI2
//  FormatID: A0E74609-B84D-4F49-B860-462BD9971F98, 100
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLengthInFilm, 0xA0E74609, 0xB84D, 0x4F49, 0xB8, 0x60, 0x46, 0x2B, 0xD9, 0x97, 0x1F, 0x98, 100);

//  Name:     System.Photo.FocalLengthNumerator -- PKEY_Photo_FocalLengthNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 776B6B3B-1E3D-4B0C-9A0E-8FBAF2A8492A, 100
//
//  Numerator of PKEY_Photo_FocalLength
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLengthNumerator, 0x776B6B3B, 0x1E3D, 0x4B0C, 0x9A, 0x0E, 0x8F, 0xBA, 0xF2, 0xA8, 0x49, 0x2A, 100);

//  Name:     System.Photo.FocalPlaneXResolution -- PKEY_Photo_FocalPlaneXResolution
//  Type:     Double -- VT_R8
//  FormatID: CFC08D97-C6F7-4484-89DD-EBEF4356FE76, 100
//  
//  PropertyTagExifFocalXRes.  Calculated from PKEY_Photo_FocalPlaneXResolutionNumerator and 
//  PKEY_Photo_FocalPlaneXResolutionDenominator.
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneXResolution, 0xCFC08D97, 0xC6F7, 0x4484, 0x89, 0xDD, 0xEB, 0xEF, 0x43, 0x56, 0xFE, 0x76, 100);

//  Name:     System.Photo.FocalPlaneXResolutionDenominator -- PKEY_Photo_FocalPlaneXResolutionDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 0933F3F5-4786-4F46-A8E8-D64DD37FA521, 100
//
//  Denominator of PKEY_Photo_FocalPlaneXResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneXResolutionDenominator, 0x0933F3F5, 0x4786, 0x4F46, 0xA8, 0xE8, 0xD6, 0x4D, 0xD3, 0x7F, 0xA5, 0x21, 100);

//  Name:     System.Photo.FocalPlaneXResolutionNumerator -- PKEY_Photo_FocalPlaneXResolutionNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: DCCB10AF-B4E2-4B88-95F9-031B4D5AB490, 100
//
//  Numerator of PKEY_Photo_FocalPlaneXResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneXResolutionNumerator, 0xDCCB10AF, 0xB4E2, 0x4B88, 0x95, 0xF9, 0x03, 0x1B, 0x4D, 0x5A, 0xB4, 0x90, 100);

//  Name:     System.Photo.FocalPlaneYResolution -- PKEY_Photo_FocalPlaneYResolution
//  Type:     Double -- VT_R8
//  FormatID: 4FFFE4D0-914F-4AC4-8D6F-C9C61DE169B1, 100
//  
//  PropertyTagExifFocalYRes.  Calculated from PKEY_Photo_FocalPlaneYResolutionNumerator and 
//  PKEY_Photo_FocalPlaneYResolutionDenominator.
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneYResolution, 0x4FFFE4D0, 0x914F, 0x4AC4, 0x8D, 0x6F, 0xC9, 0xC6, 0x1D, 0xE1, 0x69, 0xB1, 100);

//  Name:     System.Photo.FocalPlaneYResolutionDenominator -- PKEY_Photo_FocalPlaneYResolutionDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 1D6179A6-A876-4031-B013-3347B2B64DC8, 100
//
//  Denominator of PKEY_Photo_FocalPlaneYResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneYResolutionDenominator, 0x1D6179A6, 0xA876, 0x4031, 0xB0, 0x13, 0x33, 0x47, 0xB2, 0xB6, 0x4D, 0xC8, 100);

//  Name:     System.Photo.FocalPlaneYResolutionNumerator -- PKEY_Photo_FocalPlaneYResolutionNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: A2E541C5-4440-4BA8-867E-75CFC06828CD, 100
//
//  Numerator of PKEY_Photo_FocalPlaneYResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneYResolutionNumerator, 0xA2E541C5, 0x4440, 0x4BA8, 0x86, 0x7E, 0x75, 0xCF, 0xC0, 0x68, 0x28, 0xCD, 100);

//  Name:     System.Photo.GainControl -- PKEY_Photo_GainControl
//  Type:     Double -- VT_R8
//  FormatID: FA304789-00C7-4D80-904A-1E4DCC7265AA, 100 (PropertyTagExifGainControl)
//  
//  This indicates the degree of overall image gain adjustment.
//  
//  Calculated from PKEY_Photo_GainControlNumerator and PKEY_Photo_GainControlDenominator.
DEFINE_PROPERTYKEY(PKEY_Photo_GainControl, 0xFA304789, 0x00C7, 0x4D80, 0x90, 0x4A, 0x1E, 0x4D, 0xCC, 0x72, 0x65, 0xAA, 100);

// Possible discrete values for PKEY_Photo_GainControl are:
#define PHOTO_GAINCONTROL_NONE              0.0
#define PHOTO_GAINCONTROL_LOWGAINUP         1.0
#define PHOTO_GAINCONTROL_HIGHGAINUP        2.0
#define PHOTO_GAINCONTROL_LOWGAINDOWN       3.0
#define PHOTO_GAINCONTROL_HIGHGAINDOWN      4.0

//  Name:     System.Photo.GainControlDenominator -- PKEY_Photo_GainControlDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 42864DFD-9DA4-4F77-BDED-4AAD7B256735, 100
//
//  Denominator of PKEY_Photo_GainControl
DEFINE_PROPERTYKEY(PKEY_Photo_GainControlDenominator, 0x42864DFD, 0x9DA4, 0x4F77, 0xBD, 0xED, 0x4A, 0xAD, 0x7B, 0x25, 0x67, 0x35, 100);

//  Name:     System.Photo.GainControlNumerator -- PKEY_Photo_GainControlNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 8E8ECF7C-B7B8-4EB8-A63F-0EE715C96F9E, 100
//
//  Numerator of PKEY_Photo_GainControl
DEFINE_PROPERTYKEY(PKEY_Photo_GainControlNumerator, 0x8E8ECF7C, 0xB7B8, 0x4EB8, 0xA6, 0x3F, 0x0E, 0xE7, 0x15, 0xC9, 0x6F, 0x9E, 100);

//  Name:     System.Photo.GainControlText -- PKEY_Photo_GainControlText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C06238B2-0BF9-4279-A723-25856715CB9D, 100
//  
//  This is the user-friendly form of System.Photo.GainControl.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_GainControlText, 0xC06238B2, 0x0BF9, 0x4279, 0xA7, 0x23, 0x25, 0x85, 0x67, 0x15, 0xCB, 0x9D, 100);

//  Name:     System.Photo.ISOSpeed -- PKEY_Photo_ISOSpeed
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 34855
//
//  PropertyTagExifISOSpeed
DEFINE_PROPERTYKEY(PKEY_Photo_ISOSpeed, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 34855);

//  Name:     System.Photo.LensManufacturer -- PKEY_Photo_LensManufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E6DDCAF7-29C5-4F0A-9A68-D19412EC7090, 100
DEFINE_PROPERTYKEY(PKEY_Photo_LensManufacturer, 0xE6DDCAF7, 0x29C5, 0x4F0A, 0x9A, 0x68, 0xD1, 0x94, 0x12, 0xEC, 0x70, 0x90, 100);

//  Name:     System.Photo.LensModel -- PKEY_Photo_LensModel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E1277516-2B5F-4869-89B1-2E585BD38B7A, 100
DEFINE_PROPERTYKEY(PKEY_Photo_LensModel, 0xE1277516, 0x2B5F, 0x4869, 0x89, 0xB1, 0x2E, 0x58, 0x5B, 0xD3, 0x8B, 0x7A, 100);

//  Name:     System.Photo.LightSource -- PKEY_Photo_LightSource
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37384
//
//  PropertyTagExifLightSource
DEFINE_PROPERTYKEY(PKEY_Photo_LightSource, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37384);

// Possible discrete values for PKEY_Photo_LightSource are:
#define PHOTO_LIGHTSOURCE_UNKNOWN           0ul
#define PHOTO_LIGHTSOURCE_DAYLIGHT          1ul
#define PHOTO_LIGHTSOURCE_FLUORESCENT       2ul
#define PHOTO_LIGHTSOURCE_TUNGSTEN          3ul
#define PHOTO_LIGHTSOURCE_STANDARD_A        17ul
#define PHOTO_LIGHTSOURCE_STANDARD_B        18ul
#define PHOTO_LIGHTSOURCE_STANDARD_C        19ul
#define PHOTO_LIGHTSOURCE_D55               20ul
#define PHOTO_LIGHTSOURCE_D65               21ul
#define PHOTO_LIGHTSOURCE_D75               22ul

//  Name:     System.Photo.MakerNote -- PKEY_Photo_MakerNote
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: FA303353-B659-4052-85E9-BCAC79549B84, 100
DEFINE_PROPERTYKEY(PKEY_Photo_MakerNote, 0xFA303353, 0xB659, 0x4052, 0x85, 0xE9, 0xBC, 0xAC, 0x79, 0x54, 0x9B, 0x84, 100);

//  Name:     System.Photo.MakerNoteOffset -- PKEY_Photo_MakerNoteOffset
//  Type:     UInt64 -- VT_UI8
//  FormatID: 813F4124-34E6-4D17-AB3E-6B1F3C2247A1, 100
DEFINE_PROPERTYKEY(PKEY_Photo_MakerNoteOffset, 0x813F4124, 0x34E6, 0x4D17, 0xAB, 0x3E, 0x6B, 0x1F, 0x3C, 0x22, 0x47, 0xA1, 100);

//  Name:     System.Photo.MaxAperture -- PKEY_Photo_MaxAperture
//  Type:     Double -- VT_R8
//  FormatID: 08F6D7C2-E3F2-44FC-AF1E-5AA5C81A2D3E, 100
//
//  Calculated from PKEY_Photo_MaxApertureNumerator and PKEY_Photo_MaxApertureDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_MaxAperture, 0x08F6D7C2, 0xE3F2, 0x44FC, 0xAF, 0x1E, 0x5A, 0xA5, 0xC8, 0x1A, 0x2D, 0x3E, 100);

//  Name:     System.Photo.MaxApertureDenominator -- PKEY_Photo_MaxApertureDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: C77724D4-601F-46C5-9B89-C53F93BCEB77, 100
//
//  Denominator of PKEY_Photo_MaxAperture
DEFINE_PROPERTYKEY(PKEY_Photo_MaxApertureDenominator, 0xC77724D4, 0x601F, 0x46C5, 0x9B, 0x89, 0xC5, 0x3F, 0x93, 0xBC, 0xEB, 0x77, 100);

//  Name:     System.Photo.MaxApertureNumerator -- PKEY_Photo_MaxApertureNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: C107E191-A459-44C5-9AE6-B952AD4B906D, 100
//
//  Numerator of PKEY_Photo_MaxAperture
DEFINE_PROPERTYKEY(PKEY_Photo_MaxApertureNumerator, 0xC107E191, 0xA459, 0x44C5, 0x9A, 0xE6, 0xB9, 0x52, 0xAD, 0x4B, 0x90, 0x6D, 100);

//  Name:     System.Photo.MeteringMode -- PKEY_Photo_MeteringMode
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37383
//
//  PropertyTagExifMeteringMode
DEFINE_PROPERTYKEY(PKEY_Photo_MeteringMode, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37383);

// Possible discrete values for PKEY_Photo_MeteringMode are:
#define PHOTO_METERINGMODE_UNKNOWN          0u
#define PHOTO_METERINGMODE_AVERAGE          1u
#define PHOTO_METERINGMODE_CENTER           2u
#define PHOTO_METERINGMODE_SPOT             3u
#define PHOTO_METERINGMODE_MULTISPOT        4u
#define PHOTO_METERINGMODE_PATTERN          5u
#define PHOTO_METERINGMODE_PARTIAL          6u

//  Name:     System.Photo.MeteringModeText -- PKEY_Photo_MeteringModeText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F628FD8C-7BA8-465A-A65B-C5AA79263A9E, 100
//  
//  This is the user-friendly form of System.Photo.MeteringMode.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_MeteringModeText, 0xF628FD8C, 0x7BA8, 0x465A, 0xA6, 0x5B, 0xC5, 0xAA, 0x79, 0x26, 0x3A, 0x9E, 100);

//  Name:     System.Photo.Orientation -- PKEY_Photo_Orientation
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 274 (PropertyTagOrientation)
//  
//  This is the image orientation viewed in terms of rows and columns.
DEFINE_PROPERTYKEY(PKEY_Photo_Orientation, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 274);

// Possible discrete values for PKEY_Photo_Orientation are:
#define PHOTO_ORIENTATION_NORMAL            1u
#define PHOTO_ORIENTATION_FLIPHORIZONTAL    2u
#define PHOTO_ORIENTATION_ROTATE180         3u
#define PHOTO_ORIENTATION_FLIPVERTICAL      4u
#define PHOTO_ORIENTATION_TRANSPOSE         5u
#define PHOTO_ORIENTATION_ROTATE270         6u
#define PHOTO_ORIENTATION_TRANSVERSE        7u
#define PHOTO_ORIENTATION_ROTATE90          8u

//  Name:     System.Photo.OrientationText -- PKEY_Photo_OrientationText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A9EA193C-C511-498A-A06B-58E2776DCC28, 100
//  
//  This is the user-friendly form of System.Photo.Orientation.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_OrientationText, 0xA9EA193C, 0xC511, 0x498A, 0xA0, 0x6B, 0x58, 0xE2, 0x77, 0x6D, 0xCC, 0x28, 100);

//  Name:     System.Photo.PhotometricInterpretation -- PKEY_Photo_PhotometricInterpretation
//  Type:     UInt16 -- VT_UI2
//  FormatID: 341796F1-1DF9-4B1C-A564-91BDEFA43877, 100
//  
//  This is the pixel composition. In JPEG compressed data, a JPEG marker is used 
//  instead of this property.
DEFINE_PROPERTYKEY(PKEY_Photo_PhotometricInterpretation, 0x341796F1, 0x1DF9, 0x4B1C, 0xA5, 0x64, 0x91, 0xBD, 0xEF, 0xA4, 0x38, 0x77, 100);

// Possible discrete values for PKEY_Photo_PhotometricInterpretation are:
#define PHOTO_PHOTOMETRIC_RGB               2u
#define PHOTO_PHOTOMETRIC_YCBCR             6u

//  Name:     System.Photo.PhotometricInterpretationText -- PKEY_Photo_PhotometricInterpretationText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 821437D6-9EAB-4765-A589-3B1CBBD22A61, 100
//  
//  This is the user-friendly form of System.Photo.PhotometricInterpretation.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_PhotometricInterpretationText, 0x821437D6, 0x9EAB, 0x4765, 0xA5, 0x89, 0x3B, 0x1C, 0xBB, 0xD2, 0x2A, 0x61, 100);

//  Name:     System.Photo.ProgramMode -- PKEY_Photo_ProgramMode
//  Type:     UInt32 -- VT_UI4
//  FormatID: 6D217F6D-3F6A-4825-B470-5F03CA2FBE9B, 100
//  
//  This is the class of the program used by the camera to set exposure when the 
//  picture is taken.
DEFINE_PROPERTYKEY(PKEY_Photo_ProgramMode, 0x6D217F6D, 0x3F6A, 0x4825, 0xB4, 0x70, 0x5F, 0x03, 0xCA, 0x2F, 0xBE, 0x9B, 100);

// Possible discrete values for PKEY_Photo_ProgramMode are:
#define PHOTO_PROGRAMMODE_NOTDEFINED        0ul
#define PHOTO_PROGRAMMODE_MANUAL            1ul
#define PHOTO_PROGRAMMODE_NORMAL            2ul
#define PHOTO_PROGRAMMODE_APERTURE          3ul
#define PHOTO_PROGRAMMODE_SHUTTER           4ul
#define PHOTO_PROGRAMMODE_CREATIVE          5ul
#define PHOTO_PROGRAMMODE_ACTION            6ul
#define PHOTO_PROGRAMMODE_PORTRAIT          7ul
#define PHOTO_PROGRAMMODE_LANDSCAPE         8ul

//  Name:     System.Photo.ProgramModeText -- PKEY_Photo_ProgramModeText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7FE3AA27-2648-42F3-89B0-454E5CB150C3, 100
//  
//  This is the user-friendly form of System.Photo.ProgramMode.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_ProgramModeText, 0x7FE3AA27, 0x2648, 0x42F3, 0x89, 0xB0, 0x45, 0x4E, 0x5C, 0xB1, 0x50, 0xC3, 100);

//  Name:     System.Photo.RelatedSoundFile -- PKEY_Photo_RelatedSoundFile
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 318A6B45-087F-4DC2-B8CC-05359551FC9E, 100
DEFINE_PROPERTYKEY(PKEY_Photo_RelatedSoundFile, 0x318A6B45, 0x087F, 0x4DC2, 0xB8, 0xCC, 0x05, 0x35, 0x95, 0x51, 0xFC, 0x9E, 100);

//  Name:     System.Photo.Saturation -- PKEY_Photo_Saturation
//  Type:     UInt32 -- VT_UI4
//  FormatID: 49237325-A95A-4F67-B211-816B2D45D2E0, 100
//  
//  This indicates the direction of saturation processing applied by the camera when 
//  the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_Saturation, 0x49237325, 0xA95A, 0x4F67, 0xB2, 0x11, 0x81, 0x6B, 0x2D, 0x45, 0xD2, 0xE0, 100);

// Possible discrete values for PKEY_Photo_Saturation are:
#define PHOTO_SATURATION_NORMAL             0ul
#define PHOTO_SATURATION_LOW                1ul
#define PHOTO_SATURATION_HIGH               2ul

//  Name:     System.Photo.SaturationText -- PKEY_Photo_SaturationText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 61478C08-B600-4A84-BBE4-E99C45F0A072, 100
//  
//  This is the user-friendly form of System.Photo.Saturation.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_SaturationText, 0x61478C08, 0xB600, 0x4A84, 0xBB, 0xE4, 0xE9, 0x9C, 0x45, 0xF0, 0xA0, 0x72, 100);

//  Name:     System.Photo.Sharpness -- PKEY_Photo_Sharpness
//  Type:     UInt32 -- VT_UI4
//  FormatID: FC6976DB-8349-4970-AE97-B3C5316A08F0, 100
//  
//  This indicates the direction of sharpness processing applied by the camera when 
//  the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_Sharpness, 0xFC6976DB, 0x8349, 0x4970, 0xAE, 0x97, 0xB3, 0xC5, 0x31, 0x6A, 0x08, 0xF0, 100);

// Possible discrete values for PKEY_Photo_Sharpness are:
#define PHOTO_SHARPNESS_NORMAL              0ul
#define PHOTO_SHARPNESS_SOFT                1ul
#define PHOTO_SHARPNESS_HARD                2ul

//  Name:     System.Photo.SharpnessText -- PKEY_Photo_SharpnessText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 51EC3F47-DD50-421D-8769-334F50424B1E, 100
//  
//  This is the user-friendly form of System.Photo.Sharpness.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_SharpnessText, 0x51EC3F47, 0xDD50, 0x421D, 0x87, 0x69, 0x33, 0x4F, 0x50, 0x42, 0x4B, 0x1E, 100);

//  Name:     System.Photo.ShutterSpeed -- PKEY_Photo_ShutterSpeed
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37377
//
//  PropertyTagExifShutterSpeed.  Calculated from PKEY_Photo_ShutterSpeedNumerator and PKEY_Photo_ShutterSpeedDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ShutterSpeed, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37377);

//  Name:     System.Photo.ShutterSpeedDenominator -- PKEY_Photo_ShutterSpeedDenominator
//  Type:     Int32 -- VT_I4
//  FormatID: E13D8975-81C7-4948-AE3F-37CAE11E8FF7, 100
//
//  Denominator of PKEY_Photo_ShutterSpeed
DEFINE_PROPERTYKEY(PKEY_Photo_ShutterSpeedDenominator, 0xE13D8975, 0x81C7, 0x4948, 0xAE, 0x3F, 0x37, 0xCA, 0xE1, 0x1E, 0x8F, 0xF7, 100);

//  Name:     System.Photo.ShutterSpeedNumerator -- PKEY_Photo_ShutterSpeedNumerator
//  Type:     Int32 -- VT_I4
//  FormatID: 16EA4042-D6F4-4BCA-8349-7C78D30FB333, 100
//
//  Numerator of PKEY_Photo_ShutterSpeed
DEFINE_PROPERTYKEY(PKEY_Photo_ShutterSpeedNumerator, 0x16EA4042, 0xD6F4, 0x4BCA, 0x83, 0x49, 0x7C, 0x78, 0xD3, 0x0F, 0xB3, 0x33, 100);

//  Name:     System.Photo.SubjectDistance -- PKEY_Photo_SubjectDistance
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37382
//
//  PropertyTagExifSubjectDist.  Calculated from PKEY_Photo_SubjectDistanceNumerator and PKEY_Photo_SubjectDistanceDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_SubjectDistance, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37382);

//  Name:     System.Photo.SubjectDistanceDenominator -- PKEY_Photo_SubjectDistanceDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 0C840A88-B043-466D-9766-D4B26DA3FA77, 100
//
//  Denominator of PKEY_Photo_SubjectDistance
DEFINE_PROPERTYKEY(PKEY_Photo_SubjectDistanceDenominator, 0x0C840A88, 0xB043, 0x466D, 0x97, 0x66, 0xD4, 0xB2, 0x6D, 0xA3, 0xFA, 0x77, 100);

//  Name:     System.Photo.SubjectDistanceNumerator -- PKEY_Photo_SubjectDistanceNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 8AF4961C-F526-43E5-AA81-DB768219178D, 100
//
//  Numerator of PKEY_Photo_SubjectDistance
DEFINE_PROPERTYKEY(PKEY_Photo_SubjectDistanceNumerator, 0x8AF4961C, 0xF526, 0x43E5, 0xAA, 0x81, 0xDB, 0x76, 0x82, 0x19, 0x17, 0x8D, 100);

//  Name:     System.Photo.TranscodedForSync -- PKEY_Photo_TranscodedForSync
//  Type:     Boolean -- VT_BOOL
//  FormatID: 9A8EBB75-6458-4E82-BACB-35C0095B03BB, 100
DEFINE_PROPERTYKEY(PKEY_Photo_TranscodedForSync, 0x9A8EBB75, 0x6458, 0x4E82, 0xBA, 0xCB, 0x35, 0xC0, 0x09, 0x5B, 0x03, 0xBB, 100);

//  Name:     System.Photo.WhiteBalance -- PKEY_Photo_WhiteBalance
//  Type:     UInt32 -- VT_UI4
//  FormatID: EE3D3D8A-5381-4CFA-B13B-AAF66B5F4EC9, 100
//  
//  This indicates the white balance mode set when the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_WhiteBalance, 0xEE3D3D8A, 0x5381, 0x4CFA, 0xB1, 0x3B, 0xAA, 0xF6, 0x6B, 0x5F, 0x4E, 0xC9, 100);

// Possible discrete values for PKEY_Photo_WhiteBalance are:
#define PHOTO_WHITEBALANCE_AUTO             0ul
#define PHOTO_WHITEBALANCE_MANUAL           1ul

//  Name:     System.Photo.WhiteBalanceText -- PKEY_Photo_WhiteBalanceText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6336B95E-C7A7-426D-86FD-7AE3D39C84B4, 100
//  
//  This is the user-friendly form of System.Photo.WhiteBalance.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_WhiteBalanceText, 0x6336B95E, 0xC7A7, 0x426D, 0x86, 0xFD, 0x7A, 0xE3, 0xD3, 0x9C, 0x84, 0xB4, 100);
 
//-----------------------------------------------------------------------------
// PropGroup properties

//  Name:     System.PropGroup.Advanced -- PKEY_PropGroup_Advanced
//  Type:     Null -- VT_NULL
//  FormatID: 900A403B-097B-4B95-8AE2-071FDAEEB118, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Advanced, 0x900A403B, 0x097B, 0x4B95, 0x8A, 0xE2, 0x07, 0x1F, 0xDA, 0xEE, 0xB1, 0x18, 100);

//  Name:     System.PropGroup.Audio -- PKEY_PropGroup_Audio
//  Type:     Null -- VT_NULL
//  FormatID: 2804D469-788F-48AA-8570-71B9C187E138, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Audio, 0x2804D469, 0x788F, 0x48AA, 0x85, 0x70, 0x71, 0xB9, 0xC1, 0x87, 0xE1, 0x38, 100);

//  Name:     System.PropGroup.Calendar -- PKEY_PropGroup_Calendar
//  Type:     Null -- VT_NULL
//  FormatID: 9973D2B5-BFD8-438A-BA94-5349B293181A, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Calendar, 0x9973D2B5, 0xBFD8, 0x438A, 0xBA, 0x94, 0x53, 0x49, 0xB2, 0x93, 0x18, 0x1A, 100);

//  Name:     System.PropGroup.Camera -- PKEY_PropGroup_Camera
//  Type:     Null -- VT_NULL
//  FormatID: DE00DE32-547E-4981-AD4B-542F2E9007D8, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Camera, 0xDE00DE32, 0x547E, 0x4981, 0xAD, 0x4B, 0x54, 0x2F, 0x2E, 0x90, 0x07, 0xD8, 100);

//  Name:     System.PropGroup.Contact -- PKEY_PropGroup_Contact
//  Type:     Null -- VT_NULL
//  FormatID: DF975FD3-250A-4004-858F-34E29A3E37AA, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Contact, 0xDF975FD3, 0x250A, 0x4004, 0x85, 0x8F, 0x34, 0xE2, 0x9A, 0x3E, 0x37, 0xAA, 100);

//  Name:     System.PropGroup.Content -- PKEY_PropGroup_Content
//  Type:     Null -- VT_NULL
//  FormatID: D0DAB0BA-368A-4050-A882-6C010FD19A4F, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Content, 0xD0DAB0BA, 0x368A, 0x4050, 0xA8, 0x82, 0x6C, 0x01, 0x0F, 0xD1, 0x9A, 0x4F, 100);

//  Name:     System.PropGroup.Description -- PKEY_PropGroup_Description
//  Type:     Null -- VT_NULL
//  FormatID: 8969B275-9475-4E00-A887-FF93B8B41E44, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Description, 0x8969B275, 0x9475, 0x4E00, 0xA8, 0x87, 0xFF, 0x93, 0xB8, 0xB4, 0x1E, 0x44, 100);

//  Name:     System.PropGroup.FileSystem -- PKEY_PropGroup_FileSystem
//  Type:     Null -- VT_NULL
//  FormatID: E3A7D2C1-80FC-4B40-8F34-30EA111BDC2E, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_FileSystem, 0xE3A7D2C1, 0x80FC, 0x4B40, 0x8F, 0x34, 0x30, 0xEA, 0x11, 0x1B, 0xDC, 0x2E, 100);

//  Name:     System.PropGroup.General -- PKEY_PropGroup_General
//  Type:     Null -- VT_NULL
//  FormatID: CC301630-B192-4C22-B372-9F4C6D338E07, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_General, 0xCC301630, 0xB192, 0x4C22, 0xB3, 0x72, 0x9F, 0x4C, 0x6D, 0x33, 0x8E, 0x07, 100);

//  Name:     System.PropGroup.GPS -- PKEY_PropGroup_GPS
//  Type:     Null -- VT_NULL
//  FormatID: F3713ADA-90E3-4E11-AAE5-FDC17685B9BE, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_GPS, 0xF3713ADA, 0x90E3, 0x4E11, 0xAA, 0xE5, 0xFD, 0xC1, 0x76, 0x85, 0xB9, 0xBE, 100);

//  Name:     System.PropGroup.Image -- PKEY_PropGroup_Image
//  Type:     Null -- VT_NULL
//  FormatID: E3690A87-0FA8-4A2A-9A9F-FCE8827055AC, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Image, 0xE3690A87, 0x0FA8, 0x4A2A, 0x9A, 0x9F, 0xFC, 0xE8, 0x82, 0x70, 0x55, 0xAC, 100);

//  Name:     System.PropGroup.Media -- PKEY_PropGroup_Media
//  Type:     Null -- VT_NULL
//  FormatID: 61872CF7-6B5E-4B4B-AC2D-59DA84459248, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Media, 0x61872CF7, 0x6B5E, 0x4B4B, 0xAC, 0x2D, 0x59, 0xDA, 0x84, 0x45, 0x92, 0x48, 100);

//  Name:     System.PropGroup.MediaAdvanced -- PKEY_PropGroup_MediaAdvanced
//  Type:     Null -- VT_NULL
//  FormatID: 8859A284-DE7E-4642-99BA-D431D044B1EC, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_MediaAdvanced, 0x8859A284, 0xDE7E, 0x4642, 0x99, 0xBA, 0xD4, 0x31, 0xD0, 0x44, 0xB1, 0xEC, 100);

//  Name:     System.PropGroup.Message -- PKEY_PropGroup_Message
//  Type:     Null -- VT_NULL
//  FormatID: 7FD7259D-16B4-4135-9F97-7C96ECD2FA9E, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Message, 0x7FD7259D, 0x16B4, 0x4135, 0x9F, 0x97, 0x7C, 0x96, 0xEC, 0xD2, 0xFA, 0x9E, 100);

//  Name:     System.PropGroup.Music -- PKEY_PropGroup_Music
//  Type:     Null -- VT_NULL
//  FormatID: 68DD6094-7216-40F1-A029-43FE7127043F, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Music, 0x68DD6094, 0x7216, 0x40F1, 0xA0, 0x29, 0x43, 0xFE, 0x71, 0x27, 0x04, 0x3F, 100);

//  Name:     System.PropGroup.Origin -- PKEY_PropGroup_Origin
//  Type:     Null -- VT_NULL
//  FormatID: 2598D2FB-5569-4367-95DF-5CD3A177E1A5, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Origin, 0x2598D2FB, 0x5569, 0x4367, 0x95, 0xDF, 0x5C, 0xD3, 0xA1, 0x77, 0xE1, 0xA5, 100);

//  Name:     System.PropGroup.PhotoAdvanced -- PKEY_PropGroup_PhotoAdvanced
//  Type:     Null -- VT_NULL
//  FormatID: 0CB2BF5A-9EE7-4A86-8222-F01E07FDADAF, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_PhotoAdvanced, 0x0CB2BF5A, 0x9EE7, 0x4A86, 0x82, 0x22, 0xF0, 0x1E, 0x07, 0xFD, 0xAD, 0xAF, 100);

//  Name:     System.PropGroup.RecordedTV -- PKEY_PropGroup_RecordedTV
//  Type:     Null -- VT_NULL
//  FormatID: E7B33238-6584-4170-A5C0-AC25EFD9DA56, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_RecordedTV, 0xE7B33238, 0x6584, 0x4170, 0xA5, 0xC0, 0xAC, 0x25, 0xEF, 0xD9, 0xDA, 0x56, 100);

//  Name:     System.PropGroup.Video -- PKEY_PropGroup_Video
//  Type:     Null -- VT_NULL
//  FormatID: BEBE0920-7671-4C54-A3EB-49FDDFC191EE, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Video, 0xBEBE0920, 0x7671, 0x4C54, 0xA3, 0xEB, 0x49, 0xFD, 0xDF, 0xC1, 0x91, 0xEE, 100);
 
//-----------------------------------------------------------------------------
// PropList properties



//  Name:     System.PropList.ConflictPrompt -- PKEY_PropList_ConflictPrompt
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 11
//  
//  The list of properties to show in the file operation conflict resolution dialog. Properties with empty 
//  values will not be displayed. Register under the regvalue of "ConflictPrompt".
DEFINE_PROPERTYKEY(PKEY_PropList_ConflictPrompt, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 11);

//  Name:     System.PropList.ExtendedTileInfo -- PKEY_PropList_ExtendedTileInfo
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 9
//  
//  The list of properties to show in the listview on extended tiles. Register under the regvalue of 
//  "ExtendedTileInfo".
DEFINE_PROPERTYKEY(PKEY_PropList_ExtendedTileInfo, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 9);

//  Name:     System.PropList.FileOperationPrompt -- PKEY_PropList_FileOperationPrompt
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 10
//  
//  The list of properties to show in the file operation confirmation dialog. Properties with empty values 
//  will not be displayed. If this list is not specified, then the InfoTip property list is used instead. 
//  Register under the regvalue of "FileOperationPrompt".
DEFINE_PROPERTYKEY(PKEY_PropList_FileOperationPrompt, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 10);

//  Name:     System.PropList.FullDetails -- PKEY_PropList_FullDetails
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 2
//  
//  The list of all the properties to show in the details page.  Property groups can be included in this list 
//  in order to more easily organize the UI.  Register under the regvalue of "FullDetails".
DEFINE_PROPERTYKEY(PKEY_PropList_FullDetails, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 2);

//  Name:     System.PropList.InfoTip -- PKEY_PropList_InfoTip
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 4 (PID_PROPLIST_INFOTIP)
//  
//  The list of properties to show in the infotip. Properties with empty values will not be displayed. Register 
//  under the regvalue of "InfoTip".
DEFINE_PROPERTYKEY(PKEY_PropList_InfoTip, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 4);

//  Name:     System.PropList.NonPersonal -- PKEY_PropList_NonPersonal
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 49D1091F-082E-493F-B23F-D2308AA9668C, 100
//  
//  The list of properties that are considered 'non-personal'. When told to remove all non-personal properties 
//  from a given file, the system will leave these particular properties untouched. Register under the regvalue 
//  of "NonPersonal".
DEFINE_PROPERTYKEY(PKEY_PropList_NonPersonal, 0x49D1091F, 0x082E, 0x493F, 0xB2, 0x3F, 0xD2, 0x30, 0x8A, 0xA9, 0x66, 0x8C, 100);

//  Name:     System.PropList.PreviewDetails -- PKEY_PropList_PreviewDetails
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 8
//
//  The list of properties to display in the preview pane.  Register under the regvalue of "PreviewDetails".
DEFINE_PROPERTYKEY(PKEY_PropList_PreviewDetails, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 8);

//  Name:     System.PropList.PreviewTitle -- PKEY_PropList_PreviewTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 6
//  
//  The one or two properties to display in the preview pane title section.  The optional second property is 
//  displayed as a subtitle.  Register under the regvalue of "PreviewTitle".
DEFINE_PROPERTYKEY(PKEY_PropList_PreviewTitle, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 6);

//  Name:     System.PropList.QuickTip -- PKEY_PropList_QuickTip
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 5 (PID_PROPLIST_QUICKTIP)
//  
//  The list of properties to show in the infotip when the item is on a slow network. Properties with empty 
//  values will not be displayed. Register under the regvalue of "QuickTip".
DEFINE_PROPERTYKEY(PKEY_PropList_QuickTip, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 5);

//  Name:     System.PropList.TileInfo -- PKEY_PropList_TileInfo
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 3 (PID_PROPLIST_TILEINFO)
//  
//  The list of properties to show in the listview on tiles. Register under the regvalue of "TileInfo".
DEFINE_PROPERTYKEY(PKEY_PropList_TileInfo, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 3);

//  Name:     System.PropList.XPDetailsPanel -- PKEY_PropList_XPDetailsPanel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_WebView) F2275480-F782-4291-BD94-F13693513AEC, 0 (PID_DISPLAY_PROPERTIES)
//
//  The list of properties to display in the XP webview details panel. Obsolete.
DEFINE_PROPERTYKEY(PKEY_PropList_XPDetailsPanel, 0xF2275480, 0xF782, 0x4291, 0xBD, 0x94, 0xF1, 0x36, 0x93, 0x51, 0x3A, 0xEC, 0);
 
//-----------------------------------------------------------------------------
// RecordedTV properties



//  Name:     System.RecordedTV.ChannelNumber -- PKEY_RecordedTV_ChannelNumber
//  Type:     UInt32 -- VT_UI4
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 7
//
//  Example: 42
DEFINE_PROPERTYKEY(PKEY_RecordedTV_ChannelNumber, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 7);

//  Name:     System.RecordedTV.Credits -- PKEY_RecordedTV_Credits
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 4
//
//  Example: "Don Messick/Frank Welker/Casey Kasem/Heather North/Nicole Jaffe;;;"
DEFINE_PROPERTYKEY(PKEY_RecordedTV_Credits, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 4);

//  Name:     System.RecordedTV.DateContentExpires -- PKEY_RecordedTV_DateContentExpires
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 15
DEFINE_PROPERTYKEY(PKEY_RecordedTV_DateContentExpires, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 15);

//  Name:     System.RecordedTV.EpisodeName -- PKEY_RecordedTV_EpisodeName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 2
//
//  Example: "Nowhere to Hyde"
DEFINE_PROPERTYKEY(PKEY_RecordedTV_EpisodeName, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 2);

//  Name:     System.RecordedTV.IsATSCContent -- PKEY_RecordedTV_IsATSCContent
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 16
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsATSCContent, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 16);

//  Name:     System.RecordedTV.IsClosedCaptioningAvailable -- PKEY_RecordedTV_IsClosedCaptioningAvailable
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 12
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsClosedCaptioningAvailable, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 12);

//  Name:     System.RecordedTV.IsDTVContent -- PKEY_RecordedTV_IsDTVContent
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 17
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsDTVContent, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 17);

//  Name:     System.RecordedTV.IsHDContent -- PKEY_RecordedTV_IsHDContent
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 18
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsHDContent, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 18);

//  Name:     System.RecordedTV.IsRepeatBroadcast -- PKEY_RecordedTV_IsRepeatBroadcast
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 13
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsRepeatBroadcast, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 13);

//  Name:     System.RecordedTV.IsSAP -- PKEY_RecordedTV_IsSAP
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 14
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsSAP, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 14);

//  Name:     System.RecordedTV.NetworkAffiliation -- PKEY_RecordedTV_NetworkAffiliation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 2C53C813-FB63-4E22-A1AB-0B331CA1E273, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_NetworkAffiliation, 0x2C53C813, 0xFB63, 0x4E22, 0xA1, 0xAB, 0x0B, 0x33, 0x1C, 0xA1, 0xE2, 0x73, 100);

//  Name:     System.RecordedTV.OriginalBroadcastDate -- PKEY_RecordedTV_OriginalBroadcastDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 4684FE97-8765-4842-9C13-F006447B178C, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_OriginalBroadcastDate, 0x4684FE97, 0x8765, 0x4842, 0x9C, 0x13, 0xF0, 0x06, 0x44, 0x7B, 0x17, 0x8C, 100);

//  Name:     System.RecordedTV.ProgramDescription -- PKEY_RecordedTV_ProgramDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 3
DEFINE_PROPERTYKEY(PKEY_RecordedTV_ProgramDescription, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 3);

//  Name:     System.RecordedTV.RecordingTime -- PKEY_RecordedTV_RecordingTime
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: A5477F61-7A82-4ECA-9DDE-98B69B2479B3, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_RecordingTime, 0xA5477F61, 0x7A82, 0x4ECA, 0x9D, 0xDE, 0x98, 0xB6, 0x9B, 0x24, 0x79, 0xB3, 100);

//  Name:     System.RecordedTV.StationCallSign -- PKEY_RecordedTV_StationCallSign
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 5
//
//  Example: "TOONP"
DEFINE_PROPERTYKEY(PKEY_RecordedTV_StationCallSign, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 5);

//  Name:     System.RecordedTV.StationName -- PKEY_RecordedTV_StationName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 1B5439E7-EBA1-4AF8-BDD7-7AF1D4549493, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_StationName, 0x1B5439E7, 0xEBA1, 0x4AF8, 0xBD, 0xD7, 0x7A, 0xF1, 0xD4, 0x54, 0x94, 0x93, 100);
 
//-----------------------------------------------------------------------------
// Search properties



//  Name:     System.Search.AutoSummary -- PKEY_Search_AutoSummary
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 560C36C0-503A-11CF-BAA1-00004C752A9A, 2
//
//  General Summary of the document.
DEFINE_PROPERTYKEY(PKEY_Search_AutoSummary, 0x560C36C0, 0x503A, 0x11CF, 0xBA, 0xA1, 0x00, 0x00, 0x4C, 0x75, 0x2A, 0x9A, 2);

//  Name:     System.Search.ContainerHash -- PKEY_Search_ContainerHash
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: BCEEE283-35DF-4D53-826A-F36A3EEFC6BE, 100
//
//  Hash code used to identify attachments to be deleted based on a common container url
DEFINE_PROPERTYKEY(PKEY_Search_ContainerHash, 0xBCEEE283, 0x35DF, 0x4D53, 0x82, 0x6A, 0xF3, 0x6A, 0x3E, 0xEF, 0xC6, 0xBE, 100);

//  Name:     System.Search.Contents -- PKEY_Search_Contents
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 19 (PID_STG_CONTENTS)
//  
//  The contents of the item. This property is for query restrictions only; it cannot be retrieved in a 
//  query result. The Indexing Service friendly name is 'contents'.
DEFINE_PROPERTYKEY(PKEY_Search_Contents, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 19);

//  Name:     System.Search.EntryID -- PKEY_Search_EntryID
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_Query) 49691C90-7E17-101A-A91C-08002B2ECDA9, 5 (PROPID_QUERY_WORKID)
//  
//  The entry ID for an item within a given catalog in the Windows Search Index.
//  This value may be recycled, and therefore is not considered unique over time.
DEFINE_PROPERTYKEY(PKEY_Search_EntryID, 0x49691C90, 0x7E17, 0x101A, 0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9, 5);

//  Name:     System.Search.GatherTime -- PKEY_Search_GatherTime
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 0B63E350-9CCC-11D0-BCDB-00805FCCCE04, 8
//
//  The Datetime that the Windows Search Gatherer process last pushed properties of this document to the Windows Search Gatherer Plugins.
DEFINE_PROPERTYKEY(PKEY_Search_GatherTime, 0x0B63E350, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 8);

//  Name:     System.Search.IsClosedDirectory -- PKEY_Search_IsClosedDirectory
//  Type:     Boolean -- VT_BOOL
//  FormatID: 0B63E343-9CCC-11D0-BCDB-00805FCCCE04, 23
//
//  If this property is emitted with a value of TRUE, then it indicates that this URL's last modified time applies to all of it's children, and if this URL is deleted then all of it's children are deleted as well.  For example, this would be emitted as TRUE when emitting the URL of an email so that all attachments are tied to the last modified time of that email.
DEFINE_PROPERTYKEY(PKEY_Search_IsClosedDirectory, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 23);

//  Name:     System.Search.IsFullyContained -- PKEY_Search_IsFullyContained
//  Type:     Boolean -- VT_BOOL
//  FormatID: 0B63E343-9CCC-11D0-BCDB-00805FCCCE04, 24
//
//  Any child URL of a URL which has System.Search.IsClosedDirectory=TRUE must emit System.Search.IsFullyContained=TRUE.  This ensures that the URL is not deleted at the end of a crawl because it hasn't been visited (which is the normal mechanism for detecting deletes).  For example an email attachment would emit this property
DEFINE_PROPERTYKEY(PKEY_Search_IsFullyContained, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 24);

//  Name:     System.Search.QueryFocusedSummary -- PKEY_Search_QueryFocusedSummary
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 560C36C0-503A-11CF-BAA1-00004C752A9A, 3
//
//  Query Focused Summary of the document.
DEFINE_PROPERTYKEY(PKEY_Search_QueryFocusedSummary, 0x560C36C0, 0x503A, 0x11CF, 0xBA, 0xA1, 0x00, 0x00, 0x4C, 0x75, 0x2A, 0x9A, 3);

//  Name:     System.Search.Rank -- PKEY_Search_Rank
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_Query) 49691C90-7E17-101A-A91C-08002B2ECDA9, 3 (PROPID_QUERY_RANK)
//  
//  Relevance rank of row. Ranges from 0-1000. Larger numbers = better matches.  Query-time only, not 
//  defined in Search schema, retrievable but not searchable.
DEFINE_PROPERTYKEY(PKEY_Search_Rank, 0x49691C90, 0x7E17, 0x101A, 0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9, 3);

//  Name:     System.Search.Store -- PKEY_Search_Store
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A06992B3-8CAF-4ED7-A547-B259E32AC9FC, 100
//
//  The identifier for the protocol handler that produced this item. (E.g. MAPI, CSC, FILE etc.)
DEFINE_PROPERTYKEY(PKEY_Search_Store, 0xA06992B3, 0x8CAF, 0x4ED7, 0xA5, 0x47, 0xB2, 0x59, 0xE3, 0x2A, 0xC9, 0xFC, 100);

//  Name:     System.Search.UrlToIndex -- PKEY_Search_UrlToIndex
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 0B63E343-9CCC-11D0-BCDB-00805FCCCE04, 2
//
//  This property should be emitted by a container IFilter for each child URL within the container.  The children will eventually be crawled by the indexer if they are within scope.
DEFINE_PROPERTYKEY(PKEY_Search_UrlToIndex, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 2);

//  Name:     System.Search.UrlToIndexWithModificationTime -- PKEY_Search_UrlToIndexWithModificationTime
//  Type:     Multivalue Any -- VT_VECTOR | VT_NULL  (For variants: VT_ARRAY | VT_NULL)
//  FormatID: 0B63E343-9CCC-11D0-BCDB-00805FCCCE04, 12
//
//  This property is the same as System.Search.UrlToIndex except that it includes the time the URL was last modified.  This is an optimization for the indexer as it doesn't have to call back into the protocol handler to ask for this information to determine if the content needs to be indexed again.  The property is a vector with two elements, a VT_LPWSTR with the URL and a VT_FILETIME for the last modified time.
DEFINE_PROPERTYKEY(PKEY_Search_UrlToIndexWithModificationTime, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 12);
 
//-----------------------------------------------------------------------------
// Shell properties



//  Name:     System.DescriptionID -- PKEY_DescriptionID
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 2 (PID_DESCRIPTIONID)
//
//  The contents of a SHDESCRIPTIONID structure as a buffer of bytes.
DEFINE_PROPERTYKEY(PKEY_DescriptionID, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 2);

//  Name:     System.Link.TargetSFGAOFlagsStrings -- PKEY_Link_TargetSFGAOFlagsStrings
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: D6942081-D53B-443D-AD47-5E059D9CD27A, 3
//  
//  Expresses the SFGAO flags of a link as string values and is used as a query optimization.  See 
//  PKEY_Shell_SFGAOFlagsStrings for possible values of this.
DEFINE_PROPERTYKEY(PKEY_Link_TargetSFGAOFlagsStrings, 0xD6942081, 0xD53B, 0x443D, 0xAD, 0x47, 0x5E, 0x05, 0x9D, 0x9C, 0xD2, 0x7A, 3);

//  Name:     System.Link.TargetUrl -- PKEY_Link_TargetUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 5CBF2787-48CF-4208-B90E-EE5E5D420294, 2  (PKEYs relating to URLs.  Used by IE History.)
DEFINE_PROPERTYKEY(PKEY_Link_TargetUrl, 0x5CBF2787, 0x48CF, 0x4208, 0xB9, 0x0E, 0xEE, 0x5E, 0x5D, 0x42, 0x02, 0x94, 2);

//  Name:     System.Shell.SFGAOFlagsStrings -- PKEY_Shell_SFGAOFlagsStrings
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: D6942081-D53B-443D-AD47-5E059D9CD27A, 2
//
//  Expresses the SFGAO flags as string values and is used as a query optimization.
DEFINE_PROPERTYKEY(PKEY_Shell_SFGAOFlagsStrings, 0xD6942081, 0xD53B, 0x443D, 0xAD, 0x47, 0x5E, 0x05, 0x9D, 0x9C, 0xD2, 0x7A, 2);

// Possible discrete values for PKEY_Shell_SFGAOFlagsStrings are:
#define SFGAOSTR_FILESYS                    L"filesys"               // SFGAO_FILESYSTEM
#define SFGAOSTR_FILEANC                    L"fileanc"               // SFGAO_FILESYSANCESTOR
#define SFGAOSTR_STORAGEANC                 L"storageanc"               // SFGAO_STORAGEANCESTOR
#define SFGAOSTR_STREAM                     L"stream"               // SFGAO_STREAM
#define SFGAOSTR_LINK                       L"link"               // SFGAO_LINK
#define SFGAOSTR_HIDDEN                     L"hidden"               // SFGAO_HIDDEN
#define SFGAOSTR_FOLDER                     L"folder"               // SFGAO_FOLDER
#define SFGAOSTR_NONENUM                    L"nonenum"               // SFGAO_NONENUMERATED
#define SFGAOSTR_BROWSABLE                  L"browsable"               // SFGAO_BROWSABLE
 
//-----------------------------------------------------------------------------
// Software properties



//  Name:     System.Software.DateLastUsed -- PKEY_Software_DateLastUsed
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 841E4F90-FF59-4D16-8947-E81BBFFAB36D, 16
//  
//  
DEFINE_PROPERTYKEY(PKEY_Software_DateLastUsed, 0x841E4F90, 0xFF59, 0x4D16, 0x89, 0x47, 0xE8, 0x1B, 0xBF, 0xFA, 0xB3, 0x6D, 16);

//  Name:     System.Software.ProductName -- PKEY_Software_ProductName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) 0CEF7D53-FA64-11D1-A203-0000F81FEDEE, 7
//  
//  
DEFINE_PROPERTYKEY(PKEY_Software_ProductName, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 7);
 
//-----------------------------------------------------------------------------
// Sync properties



//  Name:     System.Sync.Comments -- PKEY_Sync_Comments
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 13
DEFINE_PROPERTYKEY(PKEY_Sync_Comments, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 13);

//  Name:     System.Sync.ConflictDescription -- PKEY_Sync_ConflictDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 4
DEFINE_PROPERTYKEY(PKEY_Sync_ConflictDescription, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 4);

//  Name:     System.Sync.ConflictFirstLocation -- PKEY_Sync_ConflictFirstLocation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 6
DEFINE_PROPERTYKEY(PKEY_Sync_ConflictFirstLocation, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 6);

//  Name:     System.Sync.ConflictSecondLocation -- PKEY_Sync_ConflictSecondLocation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 7
DEFINE_PROPERTYKEY(PKEY_Sync_ConflictSecondLocation, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 7);

//  Name:     System.Sync.HandlerCollectionID -- PKEY_Sync_HandlerCollectionID
//  Type:     Guid -- VT_CLSID
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 2
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerCollectionID, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 2);

//  Name:     System.Sync.HandlerID -- PKEY_Sync_HandlerID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 3
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerID, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 3);

//  Name:     System.Sync.HandlerName -- PKEY_Sync_HandlerName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 2
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerName, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 2);

//  Name:     System.Sync.HandlerType -- PKEY_Sync_HandlerType
//  Type:     UInt32 -- VT_UI4
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 8
//  
//  
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerType, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 8);

// Possible discrete values for PKEY_Sync_HandlerType are:
#define SYNC_HANDLERTYPE_OTHER              0ul
#define SYNC_HANDLERTYPE_PROGRAMS           1ul
#define SYNC_HANDLERTYPE_DEVICES            2ul
#define SYNC_HANDLERTYPE_FOLDERS            3ul
#define SYNC_HANDLERTYPE_WEBSERVICES        4ul
#define SYNC_HANDLERTYPE_COMPUTERS          5ul

//  Name:     System.Sync.HandlerTypeLabel -- PKEY_Sync_HandlerTypeLabel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 9
//  
//  
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerTypeLabel, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 9);

//  Name:     System.Sync.ItemID -- PKEY_Sync_ItemID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 6
DEFINE_PROPERTYKEY(PKEY_Sync_ItemID, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 6);

//  Name:     System.Sync.ItemName -- PKEY_Sync_ItemName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 3
DEFINE_PROPERTYKEY(PKEY_Sync_ItemName, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 3);
 
//-----------------------------------------------------------------------------
// Task properties

//  Name:     System.Task.BillingInformation -- PKEY_Task_BillingInformation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D37D52C6-261C-4303-82B3-08B926AC6F12, 100
DEFINE_PROPERTYKEY(PKEY_Task_BillingInformation, 0xD37D52C6, 0x261C, 0x4303, 0x82, 0xB3, 0x08, 0xB9, 0x26, 0xAC, 0x6F, 0x12, 100);

//  Name:     System.Task.CompletionStatus -- PKEY_Task_CompletionStatus
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 084D8A0A-E6D5-40DE-BF1F-C8820E7C877C, 100
DEFINE_PROPERTYKEY(PKEY_Task_CompletionStatus, 0x084D8A0A, 0xE6D5, 0x40DE, 0xBF, 0x1F, 0xC8, 0x82, 0x0E, 0x7C, 0x87, 0x7C, 100);

//  Name:     System.Task.Owner -- PKEY_Task_Owner
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 08C7CC5F-60F2-4494-AD75-55E3E0B5ADD0, 100
DEFINE_PROPERTYKEY(PKEY_Task_Owner, 0x08C7CC5F, 0x60F2, 0x4494, 0xAD, 0x75, 0x55, 0xE3, 0xE0, 0xB5, 0xAD, 0xD0, 100);

 
 
//-----------------------------------------------------------------------------
// Video properties

//  Name:     System.Video.Compression -- PKEY_Video_Compression
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 10 (PIDVSI_COMPRESSION)
//
//  Indicates the level of compression for the video stream.  "Compression".
DEFINE_PROPERTYKEY(PKEY_Video_Compression, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 10);

//  Name:     System.Video.Director -- PKEY_Video_Director
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 20 (PIDMSI_DIRECTOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Video_Director, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 20);

//  Name:     System.Video.EncodingBitrate -- PKEY_Video_EncodingBitrate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 8 (PIDVSI_DATA_RATE)
//
//  Indicates the data rate in "bits per second" for the video stream. "DataRate".
DEFINE_PROPERTYKEY(PKEY_Video_EncodingBitrate, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 8);

//  Name:     System.Video.FourCC -- PKEY_Video_FourCC
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 44
//  
//  Indicates the 4CC for the video stream.
DEFINE_PROPERTYKEY(PKEY_Video_FourCC, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 44);

//  Name:     System.Video.FrameHeight -- PKEY_Video_FrameHeight
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 4
//
//  Indicates the frame height for the video stream.
DEFINE_PROPERTYKEY(PKEY_Video_FrameHeight, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 4);

//  Name:     System.Video.FrameRate -- PKEY_Video_FrameRate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 6 (PIDVSI_FRAME_RATE)
//
//  Indicates the frame rate in "frames per millisecond" for the video stream.  "FrameRate".
DEFINE_PROPERTYKEY(PKEY_Video_FrameRate, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 6);

//  Name:     System.Video.FrameWidth -- PKEY_Video_FrameWidth
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 3
//
//  Indicates the frame width for the video stream.
DEFINE_PROPERTYKEY(PKEY_Video_FrameWidth, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 3);

//  Name:     System.Video.HorizontalAspectRatio -- PKEY_Video_HorizontalAspectRatio
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 42
//  
//  Indicates the horizontal portion of the aspect ratio. The X portion of XX:YY,
//  like 16:9.
DEFINE_PROPERTYKEY(PKEY_Video_HorizontalAspectRatio, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 42);

//  Name:     System.Video.SampleSize -- PKEY_Video_SampleSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 9 (PIDVSI_SAMPLE_SIZE)
//
//  Indicates the sample size in bits for the video stream.  "SampleSize".
DEFINE_PROPERTYKEY(PKEY_Video_SampleSize, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 9);

//  Name:     System.Video.StreamName -- PKEY_Video_StreamName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 2 (PIDVSI_STREAM_NAME)
//
//  Indicates the name for the video stream. "StreamName".
DEFINE_PROPERTYKEY(PKEY_Video_StreamName, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 2);

//  Name:     System.Video.StreamNumber -- PKEY_Video_StreamNumber
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 11 (PIDVSI_STREAM_NUMBER)
//
//  "Stream Number".
DEFINE_PROPERTYKEY(PKEY_Video_StreamNumber, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 11);

//  Name:     System.Video.TotalBitrate -- PKEY_Video_TotalBitrate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 43 (PIDVSI_TOTAL_BITRATE)
//
//  Indicates the total data rate in "bits per second" for all video and audio streams.
DEFINE_PROPERTYKEY(PKEY_Video_TotalBitrate, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 43);

//  Name:     System.Video.VerticalAspectRatio -- PKEY_Video_VerticalAspectRatio
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 45
//  
//  Indicates the vertical portion of the aspect ratio. The Y portion of 
//  XX:YY, like 16:9.
DEFINE_PROPERTYKEY(PKEY_Video_VerticalAspectRatio, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 45);

 
 
//-----------------------------------------------------------------------------
// Volume properties

//  Name:     System.Volume.FileSystem -- PKEY_Volume_FileSystem
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Volume) 9B174B35-40FF-11D2-A27E-00C04FC30871, 4 (PID_VOLUME_FILESYSTEM)  (Filesystem Volume Properties)
//
//  Indicates the filesystem of the volume.
DEFINE_PROPERTYKEY(PKEY_Volume_FileSystem, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 4);

//  Name:     System.Volume.IsMappedDrive -- PKEY_Volume_IsMappedDrive
//  Type:     Boolean -- VT_BOOL
//  FormatID: 149C0B69-2C2D-48FC-808F-D318D78C4636, 2
DEFINE_PROPERTYKEY(PKEY_Volume_IsMappedDrive, 0x149C0B69, 0x2C2D, 0x48FC, 0x80, 0x8F, 0xD3, 0x18, 0xD7, 0x8C, 0x46, 0x36, 2);

//  Name:     System.Volume.IsRoot -- PKEY_Volume_IsRoot
//  Type:     Boolean -- VT_BOOL
//  FormatID: (FMTID_Volume) 9B174B35-40FF-11D2-A27E-00C04FC30871, 10  (Filesystem Volume Properties)
//
//  
DEFINE_PROPERTYKEY(PKEY_Volume_IsRoot, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 10);

#endif  /* _INC_PROPKEY */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\prsht.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
*                                                                             *
\*****************************************************************************/

#pragma once

#ifndef _PRSHT_H_
#define _PRSHT_H_

#pragma warning(disable: 4201) //nonstandard ext used : nameless struct/union

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif // DUMMYUNIONNAME

#ifdef __cplusplus
extern "C" {
#endif


#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA FAR *ppsp);
typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW FAR *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT             0x0000
#define PSP_DLGINDIRECT         0x0001
#define PSP_USEHICON            0x0002
#define PSP_USEICONID           0x0004
#define PSP_USETITLE            0x0008
#define PSP_RTLREADING          0x0010

#define PSP_HASHELP             0x0020
#define PSP_USEREFPARENT        0x0040
#define PSP_USECALLBACK         0x0080
#define PSP_PREMATURE           0x0400


#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2


typedef struct _PROPSHEETPAGEA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEA, FAR *LPPROPSHEETPAGEA;
typedef const PROPSHEETPAGEA FAR *LPCPROPSHEETPAGEA;

typedef struct _PROPSHEETPAGEW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEW, FAR *LPPROPSHEETPAGEW;
typedef const PROPSHEETPAGEW FAR *LPCPROPSHEETPAGEW;

#ifdef UNICODE
#define PROPSHEETPAGE           PROPSHEETPAGEW
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#else
#define PROPSHEETPAGE           PROPSHEETPAGEA
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#endif


#define PSH_DEFAULT             0x0000
#define PSH_PROPTITLE           0x0001
#define PSH_USEHICON            0x0002
#define PSH_USEICONID           0x0004
#define PSH_PROPSHEETPAGE       0x0008
#define PSH_WIZARDHASFINISH     0x0010
#define PSH_WIZARD              0x0020
#define PSH_USEPSTARTPAGE       0x0040
#define PSH_NOAPPLYNOW          0x0080
#define PSH_USECALLBACK         0x0100
#define PSH_HASHELP             0x0200
#define PSH_MODELESS            0x0400
#define PSH_RTLREADING          0x0800
#define PSH_WIZARDCONTEXTHELP   0x1000
#define PSH_MAXIMIZE   			0x2000

// Property sheet bit specific to PPC
#define PSH_NOCANCELBUTTON    0x80000000

typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

typedef struct _PROPSHEETHEADERA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }DUMMYUNIONNAME;
        LPCSTR          pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERA, FAR *LPPROPSHEETHEADERA;
typedef const PROPSHEETHEADERA FAR *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        }DUMMYUNIONNAME;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERW, FAR *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW FAR *LPCPROPSHEETHEADERW;

#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#endif

#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2
//#ifdef WPC_NEW  Marking new for WPC
#define PSCB_GETVERSION   3
#define PSCB_GETTITLE     4
#define PSCB_GETLINKTEXT  5
//endif

WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
WINCOMMCTRLAPI int            WINAPI PropertySheetA(LPCPROPSHEETHEADERA);
WINCOMMCTRLAPI int            WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, FAR *LPPSHNOTIFY;


#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)

#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2


#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        PostMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)

#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)lpszText)


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)



#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        PostMessage(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218



#ifdef __cplusplus
}
#endif

#ifdef WINCEOEM
#include <pprsht.h>     // OEM defines 
#endif

#endif  // _PRSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\projects.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++ 
  Copyright (c) Microsoft Corporation. All rights reserved.
  
  File: project.h
  
  Abstract:
  
  Contents:
    Project APIs defines
  
--*/
#ifndef __PROJECT_H__
#define __PROJECT_H__

#ifdef __cplusplus
extern "C" {
#endif



typedef enum tagENUM {
	PRJ_ENUM_MEMORY		= 0x1,	// enumerate main memory projects only				
	PRJ_ENUM_FLASH		= 0x2,	// enumerate flash card projects only
	PRJ_ENUM_ALL_DEVICES= 0x4,	// enumerate main memory projects & Flash card,	
	PRJ_ENUM_ALL_PROJ	= 0x10,	// enumerate in all projects 
	PRJ_ENUM_HOME_PROJ	= 0x100,// add 'My Documents' home folder 
} PRJ_ENUM;


//////////////////////////////////////////////////////////////////////////////
// THE "OID" PROBLEM
//
// The OS changed from returning faked OIDs for
// storage cards and other FAT file systems to returning invalid / -1.  This
// seriously messes up anything that wants to uses OIDs to identify objects
// on a storage card.
//

typedef BOOL (CALLBACK *PFNCOLCUSTOK)(HWND, LPVOID);
typedef BOOL (CALLBACK *PROJECTS_ENUMPROC)(DWORD, LPARAM);
typedef BOOL (CALLBACK *PROJECTSFILES_ENUMPROC)(DWORD dwOID, LPARAM lParam);

/*****************************************************************************
EnumProjects	Exported API: Enumerates all projects on the specified file
				system.


PARAMETERS:
pfnEnumProc	pointer to callback function. If NULL, this function simply
			returns the number of projects, without enumerating through them.
			If the callback function ever returns FALSE, the enumeration will
			halt.  The callback has the following prototype:
			BOOL CALLBACK EnumProjectsCallback(DWORD dwOid, LPARAM lParam);

dwOidFlash	Only used for (dwFlags == PRJ_ENUM_FLASH).  This is the OID of
			the flash card to look at; the value returned by
			FindFirstFlashCard or FindNextFlashCard.

dwFlags	
			Any combo of the following (specifying the LOCATION to check):
			PRJ_ENUM_MEMORY - check all main memory projects/folders,
							  dwOidFlash is not used
			PRJ_ENUM_FLASH  - check all projects on the specified flash card,
							  where dwOidFlash specifies the flash card to
							  examine.
			PRJ_ENUM_ALL_DEVICES - check all projects/folders from main memory,
							  and from *every* flash card.  (dwOid is not used)

lParam		user defined parameter passed to pfnEnumProc 


RETURN:
The total number of projects.  NOTE: this is actually the total number of
projects in MAIN MEMORY ONLY (see below).


THIS IS PROVIDED FOR BACKWARD COMPATIBILITY.  It will silently skip over any
project that isn't on an OID-based filesystem (it enumerates everything in
main memory, but will silently skip everything on storage cards).  The modern
function is EnumProjectsEx.
******************************************************************************/
int		EnumProjects(PROJECTS_ENUMPROC lpEnumProc, DWORD  dwOid, DWORD dwFlags, LPARAM lParam);

/*****************************************************************************
EnumProjectsFiles	Exported API: Enumaretes all files in a project on the
					specified file system.

PARAMETERS:
pfnEnumProc	pointer to callback function. If NULL, this function simply
			returns the number of files without enumerating through them.
			If the callback function ever returns FALSE, the enumeration will
			halt.  The callback has the following prototype:
 (normal)	BOOL CALLBACK EnumProjectFilesCallback(DWORD dwOID, LPARAM lParam);
 (ex ver)	BOOL CALLBACK EnumProjectFilesExCallback(PAstruct* pPA, LPARAM lParam);

dwOidFlash	Only used for (dwFlags & PRJ_ENUM_FLASH).  This is the OID of
			the flash card to look at; the value returned by
			FindFirstFlashCard or FindNextFlashCard.

dwFlags	
			Any combo of the following (specifying the LOCATION to check):
			PRJ_ENUM_MEMORY - check all main memory projects/folders,
							  dwOidFlash is not used
			PRJ_ENUM_FLASH  - check all projects on the specified flash card,
							  where dwOidFlash specifies the flash card to
							  examine.
			PRJ_ENUM_ALL_DEVICES - check all projects/folders from main memory,
							  and from *every* flash card.  (dwOid is not used)

			Plus any of the following (specifying which PROJECTS to check):
			PRJ_ENUM_ALL_PROJ- enumerate in all project (szProj is not used)

szProj		Only used for when (dwFlags & PRJ_ENUM_ALL_PROJ) is NOT set.  This
			specifies which project to search; NULL specifies to look for files
			that aren't in a project/folder (i.e., they're at the top level,
			under "\My Documents").

szFileName	pointer to name of file to search for. (i.e. '*.wav' or '*.*')

lParam		user defined parameter passed to pfnEnumProc 


RETURN:
The total number of matching files found.  NOTE: in the regular version,
this is actually the total number of files in MAIN MEMORY ONLY (see below).


The regular version is provided for backward compatibility.  It will silently
skip over any file that isn't on an OID-based filesystem (it enumerates
everything in main memory, but will silently skip everything on storage cards).

The modern version, EnumProjectsFilesEx, requires the extended callback
function, too.
******************************************************************************/
int		EnumProjectsFiles(PROJECTSFILES_ENUMPROC lpEnumProc, DWORD  dwOidFlash, DWORD dwFlags,LPTSTR lpszProj, LPTSTR lpszFileName, LPARAM lParam);

/**************************************************************************************************
FindFirstFlashCard
Find the first mountable file system
	lpFindProjData -  pointer to returned information
**************************************************************************************************/
HANDLE	FindFirstFlashCard( LPWIN32_FIND_DATA  lpFindFlashData);

/**************************************************************************************************
FindNextFlashCard                                                                                
Find the next mountable file system
	lpFindProjData	-  pointer to returned information 
	hFindFlash		- Identifies a search handle returned by a previous call to the FindFirstFlashCard function. 
**************************************************************************************************/
BOOL	FindNextFlashCard(HANDLE hFindFlash, LPWIN32_FIND_DATA  lpFindFlashData);

/**************************************************************************************************
FindFirstProjectFile                                                                                
Find the first file in a project, on the desired mountable file system
	lpFileName		- pointer to name of file to search for	(i.e: '*.wav')
	lpFindFileData	- pointer to returned information 
	dwOidFlash		- Oid to the desired mountable file system (FindFirstFlashCard or FindNextFlashCard)
					  or 0 if main memory       
	lpszProj		- desired project, or NULL (or 'All') to search for files that do not 
					  have a project (under '\My Documents')
**************************************************************************************************/
HANDLE	FindFirstProjectFile(LPCTSTR lpFileName, LPWIN32_FIND_DATA  lpFindFileData,  DWORD dwOidFlash, LPTSTR szProject);

/**************************************************************************************************
FindNextProjectFile
Find the next file in a project
	lpFindProjData	- pointer to returned information 
	hFind			- Identifies a search handle returned by a previous call to the FindFirstProjectFile function. 
**************************************************************************************************/
BOOL	FindNextProjectFile(HANDLE hFindFlash, LPWIN32_FIND_DATA  lpFindFlashData);


// new code, it solves the "OID Problem"

//////////////////////////////////////////////////////////////////////////////
// PAstruct:
// This is pretty much a drop-in replacement for the spot where OIDs are
// currently used.  Instead of passing around a DWORD, we now pass a pointer
// to this struct.  IMPORTANT: callers are responsible for allocating and
// freeing the string memory for file paths.

typedef enum _EFileIDType
{
	FILE_ID_TYPE_OID	= 0,	// This file is specified through an OID
	FILE_ID_TYPE_PATH	= 1,	// This file is specified through its pathname
	FILE_ID_LAST		= 2,	// last value in the list (invalid)
} EFileIDType;

#define PA_MAX_PATHNAME 96		// including null terminator, practically speaking, might be " \storage card 3\My Documents\document folder 7\very long filename.wav" or 69 char's max

// Pure-NT machines don't necessarily define CEOID.  In the future, we'll want
// to replace this define with the actual typedef (JParks).
#ifndef CEOID
#define CEOID DWORD
#endif

typedef struct _PAstruct		// "PA" (Pathname Array) OID-NUMBER REPLACEMENT STRUCTURE
{
	EFileIDType		m_IDtype;	// is this an OID or a pathname?
	union
	{
		CEOID		m_fileOID;	// we're storing the OID
		TCHAR		m_szPathname[PA_MAX_PATHNAME];	// we're storing the full pathname\filename
	};
} PAstruct;


typedef BOOL (CALLBACK *PROJECTS_ENUMPROC_EX)(PAstruct* pPA, LPARAM lParam);
typedef BOOL (CALLBACK *PROJECTSFILES_ENUMPROC_EX)(PAstruct* pPA, LPARAM lParam);

/*****************************************************************************
EnumProjectsEx	Exported API: Enumerates all projects on the specified file
				system.

PARAMETERS:
pfnEnumProc	pointer to callback function. If NULL, this function simply
			returns the number of projects, without enumerating through them.
			If the callback function ever returns FALSE, the enumeration will
			halt.  The callback has the following prototype:
			BOOL CALLBACK EnumProjectsExCallback(PAstruct* pPA, LPARAM lParam);

dwOidFlash	Only used for (dwFlags == PRJ_ENUM_FLASH).  This is the OID of
			the flash card to look at; the value returned by
			FindFirstFlashCard or FindNextFlashCard.

dwFlags	
			Any combo of the following (specifying the LOCATION to check):
			PRJ_ENUM_MEMORY - check all main memory projects/folders,
							  dwOidFlash is not used
			PRJ_ENUM_FLASH  - check all projects on the specified flash card,
							  where dwOidFlash specifies the flash card to
							  examine.
			PRJ_ENUM_ALL_DEVICES - check all projects/folders from main memory,
							  and from *every* flash card.  (dwOid is not used)

lParam		user defined parameter passed to pfnEnumProc 


RETURN:
The total number of projects *including* storage cards.


This enhanced version can enumerate through both new (OID-based) file systems
and older (DOS-style) filesystems -- including storage cards.
******************************************************************************/
int EnumProjectsEx(PROJECTS_ENUMPROC_EX pfnEnumProc, DWORD dwOidFlash, DWORD dwFlags, LPARAM lParam);


/*****************************************************************************
EnumProjectsFiles	Exported API: Enumaretes all files in a project on the
					specified file system.

PARAMETERS:
pfnEnumProc	pointer to callback function. If NULL, this function simply
			returns the number of files without enumerating through them.
			If the callback function ever returns FALSE, the enumeration will
			halt.  The callback has the following prototype:
 (normal)	BOOL CALLBACK EnumProjectFilesCallback(DWORD dwOID, LPARAM lParam);
 (ex ver)	BOOL CALLBACK EnumProjectFilesExCallback(PAstruct* pPA, LPARAM lParam);

dwOidFlash	Only used for (dwFlags & PRJ_ENUM_FLASH).  This is the OID of
			the flash card to look at; the value returned by
			FindFirstFlashCard or FindNextFlashCard.

dwFlags	
			Any combo of the following (specifying the LOCATION to check):
			PRJ_ENUM_MEMORY - check all main memory projects/folders,
							  dwOidFlash is not used
			PRJ_ENUM_FLASH  - check all projects on the specified flash card,
							  where dwOidFlash specifies the flash card to
							  examine.
			PRJ_ENUM_ALL_DEVICES - check all projects/folders from main memory,
							  and from *every* flash card.  (dwOid is not used)

			Plus any of the following (specifying which PROJECTS to check):
			PRJ_ENUM_ALL_PROJ- enumerate in all project (szProj is not used)

szProj		Only used for when (dwFlags & PRJ_ENUM_ALL_PROJ) is NOT set.  This
			specifies which project to search; NULL specifies to look for files
			that aren't in a project/folder (i.e., they're at the top level,
			under "\My Documents").

szFileName	pointer to name of file to search for. (i.e. '*.wav' or '*.*')

lParam		user defined parameter passed to pfnEnumProc 


RETURN:
The total number of matching files found.  NOTE: in the regular version,
this is actually the total number of files in MAIN MEMORY ONLY (see below).


The regular version is provided for backward compatibility.  It will silently
skip over any file that isn't on an OID-based filesystem (it enumerates
everything in main memory, but will silently skip everything on storage cards).

The modern version, EnumProjectsFilesEx, requires the extended callback
function, too.
******************************************************************************/
int EnumProjectsFilesEx(PROJECTSFILES_ENUMPROC_EX pfnEnumProc, DWORD dwOidFlash, DWORD dwFlags,LPTSTR szProj, LPTSTR szFileName, LPARAM lParam);


#ifdef __cplusplus
}
#endif


#endif // __PROJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\prgsnk.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:15:39 2007
 */
/* Compiler settings for ..\prgsnk.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __prgsnk_h__
#define __prgsnk_h__

/* Forward Declarations */ 

#ifndef __IProgSink_FWD_DEFINED__
#define __IProgSink_FWD_DEFINED__
typedef interface IProgSink IProgSink;
#endif 	/* __IProgSink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IProgSink_INTERFACE_DEFINED__
#define __IProgSink_INTERFACE_DEFINED__

/* interface IProgSink */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IProgSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f371-98b5-11cf-bb82-00aa00bdce0b")
    IProgSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProgress( 
            /* [in] */ DWORD dwClass,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProgress( 
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwState,
            /* [in] */ LPCTSTR pchText,
            /* [in] */ DWORD dwIds,
            /* [in] */ DWORD dwPos,
            /* [in] */ DWORD dwMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelProgress( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProgSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProgSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProgSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProgSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddProgress )( 
            IProgSink __RPC_FAR * This,
            /* [in] */ DWORD dwClass,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProgress )( 
            IProgSink __RPC_FAR * This,
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwState,
            /* [in] */ LPCTSTR pchText,
            /* [in] */ DWORD dwIds,
            /* [in] */ DWORD dwPos,
            /* [in] */ DWORD dwMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DelProgress )( 
            IProgSink __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IProgSinkVtbl;

    interface IProgSink
    {
        CONST_VTBL struct IProgSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProgSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProgSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProgSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProgSink_AddProgress(This,dwClass,pdwCookie)	\
    (This)->lpVtbl -> AddProgress(This,dwClass,pdwCookie)

#define IProgSink_SetProgress(This,dwCookie,dwFlags,dwState,pchText,dwIds,dwPos,dwMax)	\
    (This)->lpVtbl -> SetProgress(This,dwCookie,dwFlags,dwState,pchText,dwIds,dwPos,dwMax)

#define IProgSink_DelProgress(This,dwCookie)	\
    (This)->lpVtbl -> DelProgress(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProgSink_AddProgress_Proxy( 
    IProgSink __RPC_FAR * This,
    /* [in] */ DWORD dwClass,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IProgSink_AddProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProgSink_SetProgress_Proxy( 
    IProgSink __RPC_FAR * This,
    /* [in] */ DWORD dwCookie,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwState,
    /* [in] */ LPCTSTR pchText,
    /* [in] */ DWORD dwIds,
    /* [in] */ DWORD dwPos,
    /* [in] */ DWORD dwMax);


void __RPC_STUB IProgSink_SetProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProgSink_DelProgress_Proxy( 
    IProgSink __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IProgSink_DelProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProgSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_prgsnk_0106 */
/* [local] */ 

#define PROGSINK_CLASS_FORWARDED    0x80000000
#define PROGSINK_CLASS_NOSPIN       0x40000000
#define PROGSINK_CLASS_HTML         0x00000000
#define PROGSINK_CLASS_MULTIMEDIA   0x00000001
#define PROGSINK_CLASS_CONTROL      0x00000002
#define PROGSINK_CLASS_DATABIND     0x00000003
#define PROGSINK_CLASS_OTHER        0x00000004
#define PROGSINK_CLASS_NOREMAIN     0x00000005
#define PROGSINK_CLASS_FRAME        0x00000006

#define PROGSINK_STATE_IDLE         0x00000000
#define PROGSINK_STATE_FINISHING    0x00000001
#define PROGSINK_STATE_CONNECTING   0x00000002
#define PROGSINK_STATE_LOADING      0x00000003

#define PROGSINK_SET_STATE          0x00000001
#define PROGSINK_SET_TEXT           0x00000002
#define PROGSINK_SET_IDS            0x00000004
#define PROGSINK_SET_POS            0x00000008
#define PROGSINK_SET_MAX            0x00000010



extern RPC_IF_HANDLE __MIDL_itf_prgsnk_0106_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_prgsnk_0106_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\proxydbs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _PROXYDBS_H_
#define _PROXYDBS_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Proxy Information Data Structures
//

// Version information
const DWORD PS_CURRENT_VERSION = 1;
const DWORD PS_CONNNAME_LEN = 64;

// String max length (excluding the null terminator).
//
// These values are only used in the call to PsSetProxy()
// as guidance to the clients about how much the buffer
// should be. The PsSetProxy() funciton will check that
// the input strings do not exceed the max limits.
// These values are NOT used in the call to PsGetProxy(),
// since the PsGetProxy() funciton will allocate the needed
// buffer for the clients.
//
const unsigned long PS_SERVER_MAXLEN = 256;
const unsigned long PS_FRIENDLYNAME_MAXLEN = 64;
const unsigned long PS_USERNAME_MAXLEN = 128;
const unsigned long PS_PASSWORD_MAXLEN = 128;
const unsigned long PS_EXCEPTION_MAXLEN = 1024;
const unsigned long PS_EXTRAINFO_MAXLEN = 1024;

// Proxy type definition
typedef enum _PS_PROXYTYPE
{
    PS_PROXYTYPE_NULL = 0,
    PS_PROXYTYPE_HTTP = 1,
    PS_PROXYTYPE_WAP = 2,
    PS_PROXYTYPE_SOCKS4 = 4,
    PS_PROXYTYPE_SOCKS5 = 5
} PS_PROXYTYPE;

// This enum indicate whether the PROXY_INFO data structure
// contains the 'CONFIG' information or the 'SCRIPT' information.
typedef enum _PS_INFOSWTICH
{
    PS_INFOSWITCH_CONFIG    = 0,
    PS_INFOSWITCH_SCRIPT    = PS_INFOSWITCH_CONFIG + 1
} PS_INFOSWITCH;

// This enum can be ORed to form the 'Flags' field of PROXY_INFO.
typedef enum _PS_INFOFLAG
{
    PS_INFOFLAG_DISABLED  = 0x1 << 0,
    PS_INFOFLAG_BYPASSLOCAL   = 0x1 << 1
} PS_INFOFLAG;

typedef struct _PS_PROXYINFO
{
    DWORD Version;
    WCHAR *pszFriendlyName;
    DWORD Flags;
    PS_INFOSWITCH InfoSwitch;
    union 
    {
        struct 
        {
            WCHAR *pszServer;
            WCHAR *pszUsername;
            WCHAR *pszPassword;
            WCHAR *pszException;
            WCHAR *pszExtraInfo;
            WORD Port;
        };
        struct 
        {
            WCHAR *pszScript;
        };
    };
}PS_PROXYINFO;

typedef struct _PS_PROXYELEMENT
{
    PS_PROXYTYPE Type;
    PS_PROXYINFO Info;
} PS_PROXYELEMENT;

typedef struct _PS_PROXYLIST
{
    DWORD Size;
    PS_PROXYELEMENT *Proxies;
} PS_PROXYLIST;

typedef struct _PS_CONNNAME
{
    WCHAR szConnName[PS_CONNNAME_LEN];
} PS_CONNNAME;

typedef struct _PS_CONNNAMELIST
{
    DWORD Size;
    PS_CONNNAME *Names;
} PS_CONNNAMELIST;

//
// Proxy Service Client Dll APIs
//

//! Initialize the Proxy client API.
//! This function must be called before calling any other API functions.
//! Each successfuly call to PsInit() must be balanced by a corresponding
//! PsDeInit() call to completely cleanup the Proxy client API.
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     RPC error code: to indicate RPC status
//!
DWORD PsInit();

//! Cleanup the Proxy client API.
//! This function must be called after all API functions are done.
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     RPC error code: to indicate RPC status
//!
DWORD PsDeInit();

//! Get the proxy information for a type in a connection.
//! Need to call PsFreeGetProxy() after a successful call to PsGetProxy().
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     ERROR_INVALID_PARAMETER: invalid parameter (NULL)
//!     ERROR_FILE_NOT_FOUND: the proxy does not exist
//!     ERROR_OUTOFMEMORY: out of memory
//!     RPC error code: to indicate RPC status
//!
DWORD PsGetProxy(
    __in const WCHAR* pszConnectionName,
    __in const PS_PROXYTYPE Type,
    __out PS_PROXYINFO* pProxyInfo);

//! Free the memory allocated during call to PsGetProxy().
//! This will clear Struce (*pProxyInfo) to all 0 at exit.
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     ERROR_INVALID_PARAMETER: invalid parameter (NULL)
//!
DWORD PsFreeGetProxy(
    __inout PS_PROXYINFO* pProxyInfo);

//! Set the proxy information for a type in a connection.
//! If there is no proxy for the specified type in the
//! connection before, this will add the proxy; otherwise,
//! this will replace the old proxy.
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     ERROR_INVALID_PARAMETER: invalid parameter (NULL or invalid 'Version' field)
//!     RPC error code: to indicate RPC status
//!
DWORD PsSetProxy(
    __in const WCHAR* pszConnectionName,
    __in const PS_PROXYTYPE Type,
    __in const PS_PROXYINFO* pProxyInfo);

//! Get all types of proxies in one connection.
//! Need to call PsFreeGetProxyList() after a successful call to PsGetProxyList().
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     ERROR_INVALID_PARAMETER: invalid parameter (NULL)
//!     ERROR_FILE_NOT_FOUND: the proxy list does not exist
//!     ERROR_OUTOFMEMORY: out of memory
//!     RPC error code: to indicate RPC status
//!
DWORD PsGetProxyList(
    __in const WCHAR* pszConnectionName,
    __out PS_PROXYLIST* pList);

//! Free the memory allocated during call to PsGetProxyList().
//! This will clear structure (*pList) to all 0 at exit.
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     ERROR_INVALID_PARAMETER: invalid parameter (NULL)
//!
DWORD PsFreeGetProxyList(
    __inout PS_PROXYLIST* pList);

//! Delete the proxy for a specific type in a connection.
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     ERROR_INVALID_PARAMETER: invalid parameter (NULL)
//!     ERROR_FILE_NOT_FOUND: the proxy does not exist
//!     RPC error code: to indicate RPC status
//!
DWORD PsDelProxy(
    __in const WCHAR* pszConnectionName,
    __in const PS_PROXYTYPE Type);

//! Get the names of all connections that have proxies associated with them.
//! Need to call PsFreeGetConnNameList() after a successful call to PsGetConnNameList().
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     ERROR_INVALID_PARAMETER: invalid parameter (NULL)
//!     ERROR_FILE_NOT_FOUND: the connection name list does not exist
//!     ERROR_OUTOFMEMORY: out of memory
//!     RPC error code: to indicate RPC status
//!
DWORD PsGetConnNameList(
    __out PS_CONNNAMELIST* pList);

//! Free the memory allocated during call to PsGetConnNameList().
//! This will clear structure (*pList) to all 0 at exit.
//!
//! Returns:
//!     ERROR_SUCCESS: if successful
//!     ERROR_INVALID_PARAMETER: invalid parameter (NULL)
//!
DWORD PsFreeGetConnNameList(
    __inout PS_CONNNAMELIST* pList);

#ifdef __cplusplus
}
#endif

#endif  // _PROXYDBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\pshpack8.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(8)
#else
#pragma pack(8)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\psapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: psapi.h

Purpose: Declaration of Process Status Helper APIs.

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


#if !defined (IN_KERNEL) && !defined (COREDLL)

BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    __out_bcount(cb) LPMODULEINFO lpmodinfo,
    __in DWORD cb
    );

BOOL 
WINAPI 
CeSetProcessVersion (
    __in HANDLE hProcess,
    __in DWORD dwVersion
    );

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\pshpack4.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(4)
#else
#pragma pack(4)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\pshpack1.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\pshpack2.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(2)
#else
#pragma pack(2)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rapitypes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// *************************************************************************
//  rapitypes.h
//
//  Copyright 2002 Microsoft Corporation, All Rights Reserved
//
//  Typedefs common to public and private RAPI idl.
//
// ***************************************************************************

#pragma once

#ifdef MIDL_ONLY

typedef BYTE far * LPBYTE;
#define STDAPICALLTYPE __stdcall
#endif // MIDL_ONLY

// 
// The Windows CE WIN32_FIND_DATA structure differs from the
// Windows WIN32_FIND_DATA stucture so we copy the Windows CE
// definition to here so that both sides match.
//
#define MAX_PATH 260

typedef struct CE_FIND_DATA
{
    DWORD    dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD    nFileSizeHigh;
    DWORD    nFileSizeLow;
    DWORD    dwOID;
    WCHAR    cFileName[MAX_PATH];
} CE_FIND_DATA;

typedef CE_FIND_DATA*  LPCE_FIND_DATA;

typedef CE_FIND_DATA** LPLPCE_FIND_DATA;

//
// These are flags for CeFindAllFiles
//
#define FAF_ATTRIBUTES      ((DWORD) 0x01)
#define FAF_CREATION_TIME   ((DWORD) 0x02)
#define FAF_LASTACCESS_TIME ((DWORD) 0x04)
#define FAF_LASTWRITE_TIME  ((DWORD) 0x08)
#define FAF_SIZE_HIGH       ((DWORD) 0x10)
#define FAF_SIZE_LOW        ((DWORD) 0x20)
#define FAF_OID             ((DWORD) 0x40)
#define FAF_NAME            ((DWORD) 0x80)
#define FAF_FLAG_COUNT      ((UINT)  8)
#define FAF_ATTRIB_CHILDREN ((DWORD)            0x01000)
#define FAF_ATTRIB_NO_HIDDEN ((DWORD)            0x02000)
#define FAF_FOLDERS_ONLY    ((DWORD)            0x04000)
#define FAF_NO_HIDDEN_SYS_ROMMODULES ((DWORD)    0x08000)
#define FAF_GETTARGET        ((DWORD)            0x10000)

#define FAD_OID             ((WORD) 0x01)
#define FAD_FLAGS           ((WORD) 0x02)
#define FAD_NAME            ((WORD) 0x04)
#define FAD_TYPE            ((WORD) 0x08)
#define FAD_NUM_RECORDS     ((WORD) 0x10)
#define FAD_NUM_SORT_ORDER  ((WORD) 0x20)
#define FAD_SIZE            ((WORD) 0x40)
#define FAD_LAST_MODIFIED   ((WORD) 0x80)
#define FAD_SORT_SPECS      ((WORD) 0x100)
#define FAD_FLAG_COUNT      ((UINT) 9)

#ifndef FILE_ATTRIBUTE_INROM
#define FILE_ATTRIBUTE_INROM        0x00000040
#endif
#ifndef FILE_ATTRIBUTE_ROMSTATICREF
#define FILE_ATTRIBUTE_ROMSTATICREF 0x00001000
#endif
#ifndef FILE_ATTRIBUTE_ROMMODULE
#define FILE_ATTRIBUTE_ROMMODULE    0x00002000
#endif

//
// The following is not a standard Windows CE File Attribute.
//
#ifndef FILE_ATTRIBUTE_HAS_CHILDREN
#define FILE_ATTRIBUTE_HAS_CHILDREN 0x00010000
#endif
#ifndef FILE_ATTRIBUTE_SHORTCUT
#define FILE_ATTRIBUTE_SHORTCUT        0x00020000
#endif

typedef enum RAPISTREAMFLAG
{
    STREAM_TIMEOUT_READ
} RAPISTREAMFLAG;

// forward define
#ifdef MIDL_ONLY
interface IRAPIStream;
#else
typedef struct IRAPIStream IRAPIStream;
#endif

// RAPI extension on Windows CE (e.g., MyFunctionFOO) called via CeRapiInvoke should be declared as:
// EXTERN_C RAPIEXT MyFunctionFOO;
typedef  HRESULT (STDAPICALLTYPE RAPIEXT)(
         DWORD             cbInput,     // [IN]
         BYTE        *     pInput,      // [IN]
         DWORD       *     pcbOutput,   // [OUT]
         BYTE        **    ppOutput,    // [OUT]
         IRAPIStream *     pIRAPIStream // [IN]
         );                             

//
// The following definitions are for the client side only,
// because they are already defined on Windows CE.
//
#ifndef UNDER_CE

#ifndef MIDL_ONLY
#include <stddef.h>
#endif

typedef struct STORE_INFORMATION
{
    DWORD dwStoreSize;
    DWORD dwFreeSize;
} STORE_INFORMATION;


typedef STORE_INFORMATION * LPSTORE_INFORMATION;

typedef DWORD CEPROPID;

typedef CEPROPID * PCEPROPID;

#define TypeFromPropID(propid) LOWORD(propid)

typedef DWORD CEOID;

typedef CEOID *PCEOID;

typedef struct CEGUID
{
    DWORD Data1;
    DWORD Data2;
    DWORD Data3;
    DWORD Data4;
} CEGUID;

typedef CEGUID * PCEGUID;

typedef struct CENOTIFICATION {
    DWORD dwSize;
    DWORD dwParam;
    UINT  uType;
    CEGUID guid;
    CEOID  oid;
    CEOID  oidParent;
} CENOTIFICATION;

#define CEDB_EXNOTIFICATION    0x00000001

typedef struct CENOTIFYREQUEST {
    DWORD dwSize;
    HWND  hwnd;
    DWORD dwFlags;
    HANDLE hHeap;
    DWORD  dwParam;
} CENOTIFYREQUEST;

typedef CENOTIFYREQUEST * PCENOTIFYREQUEST;

typedef struct CEFILEINFO
{
    DWORD   dwAttributes;
    CEOID   oidParent;
    WCHAR   szFileName[MAX_PATH];
    FILETIME ftLastChanged;
    DWORD   dwLength;
} CEFILEINFO;

typedef struct CEDIRINFO {
    DWORD   dwAttributes;
    CEOID   oidParent;
    WCHAR   szDirName[MAX_PATH];
} CEDIRINFO;

typedef struct CERECORDINFO {
    CEOID  oidParent;
} CERECORDINFO;

#define CEDB_SORT_DESCENDING        0x00000001
#define CEDB_SORT_CASEINSENSITIVE   0x00000002
#define CEDB_SORT_UNKNOWNFIRST      0x00000004
#define CEDB_SORT_GENERICORDER      0x00000008

typedef struct SORTORDERSPEC {
    CEPROPID  propid;
    DWORD     dwFlags;
} SORTORDERSPEC;

#define CEDB_MAXDBASENAMELEN  32
#define CEDB_MAXDBASENAMELEN  32
#define CEDB_MAXSORTORDER     4
#define CEDB_MAXSORTORDER     4

#define CEDB_VALIDNAME      0x0001
#define CEDB_VALIDTYPE      0x0002
#define CEDB_VALIDSORTSPEC  0x0004
#define CEDB_VALIDMODTIME   0x0008
#define CEDB_VALIDDBFLAGS   0x0010
#define CEDB_VALIDCREATE (CEDB_VALIDNAME|CEDB_VALIDTYPE|CEDB_VALIDSORTSPEC|CEDB_VALIDDBFLAGS)

#define CEDB_NOCOMPRESS     0x00010000

typedef struct CEDBASEINFO 
{
    DWORD   dwFlags;
    WCHAR   szDbaseName[CEDB_MAXDBASENAMELEN];
    DWORD   dwDbaseType;
    WORD    wNumRecords;
    WORD    wNumSortOrder;
    DWORD   dwSize;
    FILETIME ftLastModified;
    SORTORDERSPEC rgSortSpecs[CEDB_MAXSORTORDER];
} CEDBASEINFO;

typedef struct CEDB_FIND_DATA {
    CEOID       OidDb;
    CEDBASEINFO DbInfo;
} CEDB_FIND_DATA;


typedef CEDB_FIND_DATA * LPCEDB_FIND_DATA;

typedef CEDB_FIND_DATA ** LPLPCEDB_FIND_DATA;

#define OBJTYPE_INVALID     0
#define OBJTYPE_FILE        1
#define OBJTYPE_DIRECTORY   2
#define OBJTYPE_DATABASE    3
#define OBJTYPE_RECORD      4

typedef struct CEOIDINFO
{
    WORD  wObjType;
    WORD  wPad;
    union 
    {
        CEFILEINFO infFile;
        CEDIRINFO    infDirectory;
        CEDBASEINFO  infDatabase;
        CERECORDINFO infRecord;    
    };
} CEOIDINFO;

#define CEDB_AUTOINCREMENT      0x00000001

#define CEDB_SEEK_CEOID         0x00000001
#define CEDB_SEEK_BEGINNING     0x00000002
#define CEDB_SEEK_END           0x00000004
#define CEDB_SEEK_CURRENT       0x00000008
#define CEDB_SEEK_VALUESMALLER     0x00000010
#define CEDB_SEEK_VALUEFIRSTEQUAL  0x00000020
#define CEDB_SEEK_VALUEGREATER     0x00000040
#define CEDB_SEEK_VALUENEXTEQUAL   0x00000080

typedef struct CEBLOB{
    DWORD       dwCount;
    LPBYTE      lpb;
} CEBLOB;

#define CEVT_I2       2
#define CEVT_UI2      18
#define CEVT_I4       3
#define CEVT_UI4      19
#define CEVT_FILETIME 64
#define CEVT_LPWSTR   31
#define CEVT_BLOB     65
#define CEVT_BOOL     11
#define    CEVT_R8       5

typedef union CEVALUNION {
    short           iVal;
    USHORT          uiVal;
    long            lVal;
    ULONG           ulVal;
    FILETIME        filetime;
    LPWSTR          lpwstr;
    CEBLOB          blob;
    BOOL            boolVal;
    double          dblVal;
} CEVALUNION;
 
#define CEDB_PROPNOTFOUND 0x0100
#define CEDB_PROPDELETE   0x0200

typedef struct CEPROPVAL {
    CEPROPID    propid;
    WORD        wLenData;
    WORD        wFlags;
    CEVALUNION  val;
} CEPROPVAL;

typedef CEPROPVAL * PCEPROPVAL;


#define CEDB_MAXDATABLOCKSIZE  4092
#define CEDB_MAXPROPDATASIZE   (CEDB_MAXDATABLOCKSIZE*16)
#define CEDB_MAXRECORDSIZE     (128*1024)

#define CEDB_ALLOWREALLOC  0x00000001

#define CREATE_SYSTEMGUID(pguid) (memset((pguid), 0, sizeof(CEGUID)))
#define CREATE_INVALIDGUID(pguid) (memset((pguid), -1, sizeof(CEGUID)))

#define CHECK_SYSTEMGUID(pguid) !((pguid)->Data1|(pguid)->Data2|(pguid)->Data3|(pguid)->Data4)
#define CHECK_INVALIDGUID(pguid) !~((pguid)->Data1&(pguid)->Data2&(pguid)->Data3&(pguid)->Data4)

#define SYSMEM_CHANGED    0
#define SYSMEM_MUSTREBOOT 1
#define SYSMEM_REBOOTPENDING 2
#define SYSMEM_FAILED 3

typedef struct CEOSVERSIONINFO {
    DWORD dwOSVersionInfoSize; 
    DWORD dwMajorVersion; 
    DWORD dwMinorVersion; 
    DWORD dwBuildNumber; 
    DWORD dwPlatformId; 
    WCHAR szCSDVersion[ 128 ]; 
} CEOSVERSIONINFO;

typedef CEOSVERSIONINFO * LPCEOSVERSIONINFO;

#define AC_LINE_OFFLINE                 0x00
#define AC_LINE_ONLINE                  0x01
#define AC_LINE_BACKUP_POWER            0x02
#define AC_LINE_UNKNOWN                 0xFF

#define BATTERY_FLAG_HIGH               0x01
#define BATTERY_FLAG_LOW                0x02
#define BATTERY_FLAG_CRITICAL           0x04
#define BATTERY_FLAG_CHARGING           0x08
#define BATTERY_FLAG_NO_BATTERY         0x80
#define BATTERY_FLAG_UNKNOWN            0xFF

#define BATTERY_PERCENTAGE_UNKNOWN      0xFF

#define BATTERY_LIFE_UNKNOWN        0xFFFFFFFF

typedef struct SYSTEM_POWER_STATUS_EX{
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
    BYTE Reserved2;
    BYTE BackupBatteryFlag;
    BYTE BackupBatteryLifePercent;
    BYTE Reserved3;
    DWORD BackupBatteryLifeTime;
    DWORD BackupBatteryFullLifeTime;
} SYSTEM_POWER_STATUS_EX;

typedef SYSTEM_POWER_STATUS_EX * PSYSTEM_POWER_STATUS_EX;

typedef SYSTEM_POWER_STATUS_EX * LPSYSTEM_POWER_STATUS_EX;


//
// MessageId: CERAPI_E_ALREADYINITIALIZED
//
//  CeRapiInit(Ex) has already been successfully called
//
#define CERAPI_E_ALREADYINITIALIZED     0x80041001

typedef struct RAPIINIT
{
    DWORD cbSize;
    HANDLE heRapiInit;
    HRESULT hrRapiInit;
} RAPIINIT;

//
// Instruction set definitions for CeQueryInstructionSet() 
//
// PROCESSOR_ARCHITECTURE_x are already defined in desktop winnt.h
// Here we include the CE specific definitions from CE winnt.h
//
#define PROCESSOR_INSTRUCTION_CODE(arch, core, feature)      \
    ((arch) << 24 | (core) << 16 | (feature))
#define PROCESSOR_X86_32BIT_CORE                1

#define PROCESSOR_MIPS16_CORE                   1
#define PROCESSOR_MIPSII_CORE                   2
#define PROCESSOR_MIPSIV_CORE                   3

#define PROCESSOR_HITACHI_SH3_CORE              1
#define PROCESSOR_HITACHI_SH4_CORE              2

#define PROCESSOR_ARM_V4_CORE                   1
#define PROCESSOR_ARM_V4I_CORE                  2
#define PROCESSOR_ARM_V4T_CORE                  3

#define PROCESSOR_FEATURE_NOFP                  0
#define PROCESSOR_FEATURE_FP                    1
#define PROCESSOR_FEATURE_DSP                   PROCESSOR_FEATURE_FP

#define PROCESSOR_QUERY_INSTRUCTION             PROCESSOR_INSTRUCTION_CODE(0,0,0)

#define PROCESSOR_X86_32BIT_INSTRUCTION         \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_INTEL, PROCESSOR_X86_32BIT_CORE, PROCESSOR_FEATURE_FP)

#define PROCESSOR_MIPS_MIPS16_INSTRUCTION       \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_MIPS,  PROCESSOR_MIPS16_CORE, PROCESSOR_FEATURE_NOFP)
#define PROCESSOR_MIPS_MIPSII_INSTRUCTION       \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_MIPS,  PROCESSOR_MIPSII_CORE, PROCESSOR_FEATURE_NOFP)
#define PROCESSOR_MIPS_MIPSIIFP_INSTRUCTION     \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_MIPS,  PROCESSOR_MIPSII_CORE, PROCESSOR_FEATURE_FP)
#define PROCESSOR_MIPS_MIPSIV_INSTRUCTION       \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_MIPS,  PROCESSOR_MIPSIV_CORE, PROCESSOR_FEATURE_NOFP)
#define PROCESSOR_MIPS_MIPSIVFP_INSTRUCTION     \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_MIPS,  PROCESSOR_MIPSIV_CORE, PROCESSOR_FEATURE_FP)

#define PROCESSOR_HITACHI_SH3_INSTRUCTION       \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_SHX,   PROCESSOR_HITACHI_SH3_CORE, PROCESSOR_FEATURE_NOFP)
#define PROCESSOR_HITACHI_SH3DSP_INSTRUCTION    \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_SHX,   PROCESSOR_HITACHI_SH3_CORE, PROCESSOR_FEATURE_DSP)
#define PROCESSOR_HITACHI_SH4_INSTRUCTION       \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_SHX,   PROCESSOR_HITACHI_SH4_CORE, PROCESSOR_FEATURE_FP)

#define PROCESSOR_ARM_V4_INSTRUCTION            \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_ARM,   PROCESSOR_ARM_V4_CORE, PROCESSOR_FEATURE_NOFP)
#define PROCESSOR_ARM_V4FP_INSTRUCTION          \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_ARM,   PROCESSOR_ARM_V4_CORE, PROCESSOR_FEATURE_FP)
#define PROCESSOR_ARM_V4I_INSTRUCTION           \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_ARM,   PROCESSOR_ARM_V4I_CORE, PROCESSOR_FEATURE_NOFP)
#define PROCESSOR_ARM_V4IFP_INSTRUCTION         \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_ARM,   PROCESSOR_ARM_V4I_CORE, PROCESSOR_FEATURE_FP)
#define PROCESSOR_ARM_V4T_INSTRUCTION           \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_ARM,   PROCESSOR_ARM_V4T_CORE, PROCESSOR_FEATURE_NOFP)
#define PROCESSOR_ARM_V4TFP_INSTRUCTION         \
    PROCESSOR_INSTRUCTION_CODE(PROCESSOR_ARCHITECTURE_ARM,   PROCESSOR_ARM_V4T_CORE, PROCESSOR_FEATURE_FP)


#endif // !UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\pullpin.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

#ifndef __PULLPIN_H__
#define __PULLPIN_H__

//
// CPullPin
//
// object supporting pulling data from an IAsyncReader interface.
// Given a start/stop position, calls a pure Receive method with each
// IMediaSample received.
//
// This is essentially for use in a MemInputPin when it finds itself
// connected to an IAsyncReader pin instead of a pushing pin.
//

class CPullPin : public CAMThread
{
    IAsyncReader*       m_pReader;
    REFERENCE_TIME      m_tStart;
    REFERENCE_TIME      m_tStop;
    REFERENCE_TIME      m_tDuration;
    BOOL                m_bSync;

    enum ThreadMsg {
	TM_Pause,       // stop pulling and wait for next message
	TM_Start,       // start pulling
	TM_Exit,        // stop and exit
    };

    ThreadMsg m_State;

    // override pure thread proc from CAMThread
    DWORD ThreadProc(void);

    // running pull method (check m_bSync)
    void Process(void);

    // clean up any cancelled i/o after a flush
    void CleanupCancelled(void);

    // suspend thread from pulling, eg during seek
    HRESULT PauseThread();

    // start thread pulling - create thread if necy
    HRESULT StartThread();

    // stop and close thread
    HRESULT StopThread();

    // called from ProcessAsync to queue and collect requests
    HRESULT QueueSample(
		REFERENCE_TIME& tCurrent,
		REFERENCE_TIME tAlignStop,
		BOOL bDiscontinuity);

    HRESULT CollectAndDeliver(
		REFERENCE_TIME tStart,
		REFERENCE_TIME tStop);

    HRESULT DeliverSample(
		IMediaSample* pSample,
		REFERENCE_TIME tStart,
		REFERENCE_TIME tStop);

protected:
    IMemAllocator *     m_pAlloc;

public:
    CPullPin();
    virtual ~CPullPin();

    // returns S_OK if successfully connected to an IAsyncReader interface
    // from this object
    // Optional allocator should be proposed as a preferred allocator if
    // necessary
    // bSync is TRUE if we are to use sync reads instead of the
    // async methods.
    HRESULT Connect(IUnknown* pUnk, IMemAllocator* pAlloc, BOOL bSync);

    // disconnect any connection made in Connect
    HRESULT Disconnect();

    // agree an allocator using RequestAllocator - optional
    // props param specifies your requirements (non-zero fields).
    // returns an error code if fail to match requirements.
    // optional IMemAllocator interface is offered as a preferred allocator
    // but no error occurs if it can't be met.
    virtual HRESULT DecideAllocator(
		IMemAllocator* pAlloc,
		ALLOCATOR_PROPERTIES * pProps);

    // set start and stop position. if active, will start immediately at
    // the new position. Default is 0 to duration
    HRESULT Seek(REFERENCE_TIME tStart, REFERENCE_TIME tStop);

    // return the total duration
    HRESULT Duration(REFERENCE_TIME* ptDuration);

    // start pulling data
    HRESULT Active(void);

    // stop pulling data
    HRESULT Inactive(void);

    // helper functions
    LONGLONG AlignDown(LONGLONG ll, LONG lAlign) {
	// aligning downwards is just truncation
	return ll & ~(lAlign-1);
    };

    LONGLONG AlignUp(LONGLONG ll, LONG lAlign) {
	// align up: round up to next boundary
	return (ll + (lAlign -1)) & ~(lAlign -1);
    };

    // GetReader returns the (addrefed) IAsyncReader interface
    // for SyncRead etc
    IAsyncReader* GetReader() {
	m_pReader->AddRef();
	return m_pReader;
    };

    // -- pure --

    // override this to handle data arrival
    // return value other than S_OK will stop data
    virtual HRESULT Receive(IMediaSample*) PURE;

    // override this to handle end-of-stream
    virtual HRESULT EndOfStream(void) PURE;

    // called on runtime errors that will have caused pulling
    // to stop
    // these errors are all returned from the upstream filter, who
    // will have already reported any errors to the filtergraph.
    virtual void OnError(HRESULT hr) PURE;

    // flush this pin and all downstream
    virtual HRESULT BeginFlush() PURE;
    virtual HRESULT EndFlush() PURE;

};

#endif //__PULLPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rapitypes2.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// ***************************************************************************
//  rapitypes2.h
//
//  Copyright 2003 Microsoft Corporation, All Rights Reserved
//
//  Types needed for RAPI2.
//
// ***************************************************************************

#pragma once

#ifdef MIDL_ONLY

#include <basetsd.h>

typedef struct OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union UNION_OFFSET_POINTER{
        struct OFFSET{
            DWORD Offset;
            DWORD OffsetHigh;
        } OFFSET;

        PVOID Pointer;
    } UNION_OFFSET_POINTER;

    HANDLE  hEvent;
} OVERLAPPED;

typedef OVERLAPPED * LPOVERLAPPED;

#define CONST const
typedef CONST void far      *LPCVOID;
typedef LONG *PLONG;    

typedef struct STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA;

typedef STARTUPINFOA * LPSTARTUPINFOA;

typedef struct STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOW;

typedef STARTUPINFOW * LPSTARTUPINFOW;

#ifdef UNICODE
typedef STARTUPINFOW STARTUPINFO;
typedef LPSTARTUPINFOW LPSTARTUPINFO;
#else
typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
#endif // UNICODE

typedef struct PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION;

typedef PROCESS_INFORMATION * PPROCESS_INFORMATION;
typedef PROCESS_INFORMATION * LPPROCESS_INFORMATION;

typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK REGSAM;
typedef HKEY *PHKEY;

typedef struct SYSTEM_INFO {
    union UNION_OEMID_PROCESSOR_INFO{
        DWORD dwOemId;          // Obsolete field...do not use
        struct PROCESSOR_INFO{
            WORD wProcessorArchitecture;
            WORD wReserved;
        } PROCESSOR_INFO;
    } UNION_OEMID_PROCESSOR_INFO;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO;
typedef SYSTEM_INFO * LPSYSTEM_INFO;


typedef struct MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS;

typedef MEMORYSTATUS * LPMEMORYSTATUS;

#define _SS_MAXSIZE 128                  // Maximum size.
#define _SS_ALIGNSIZE (sizeof(__int64))  // Desired alignment.
#define _SS_PAD1SIZE (_SS_ALIGNSIZE - sizeof (short))
#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof (short) + _SS_PAD1SIZE \
                                                    + _SS_ALIGNSIZE))

typedef struct sockaddr_storage {
    short ss_family;               // Address family.
    char __ss_pad1[_SS_PAD1SIZE];  // 6 byte pad, this is to make
                                   // implementation specific pad up to
                                   // alignment field that follows explicit
                                   // in the data structure.
    __int64 __ss_align;            // Field to force desired structure.
    char __ss_pad2[_SS_PAD2SIZE];  // 112 byte pad to achieve desired size;
                                   // _SS_MAXSIZE value minus size of
                                   // ss_family, __ss_pad1, and
                                   // __ss_align fields is 112.
} sockaddr_storage ;

typedef struct sockaddr_storage SOCKADDR_STORAGE;

#else // MIDL_ONLY

#ifndef UNDER_CE
#if(_WIN32_WINNT < 0x0501)
#ifndef __SOCKADDR_STORAGE_DEFINED
typedef struct sockaddr_storage SOCKADDR_STORAGE;
typedef SOCKADDR_STORAGE *PSOCKADDR_STORAGE, FAR *LPSOCKADDR_STORAGE;
#define __SOCKADDR_STORAGE_DEFINED
#endif // __SOCKADDR_STORAGE_DEFINED
#endif // _WIN32_WINNT
#endif // UNDER_CE

#endif // MIDL_ONLY

// end gross struct copy hack (everything after this is previously hacked from CE stuff that doesn't exist on desktop, so leave it as is).

//
// DEVICEID structure
//
typedef GUID RAPIDEVICEID;
#define RAPIDEVICEID_BACKCOMPAT  GUID_NULL  // device id for older devices

#ifndef UNDER_CE

// this is defined in CE's pwinuser.h, so we only want it for desktop
typedef struct {
    DWORD dwMajor;
    DWORD dwMinor;
} PLATFORMVERSION;

#endif

//
//  struct to hold additional platforms and their versions.
//
#define MAX_SUB_PLATFORMS   6

typedef struct RAPI_DEVICE_PLATFORM
{
    BSTR     bstrName;
    DWORD    dwMajor;
    DWORD    dwMinor;
} RAPI_DEVICE_PLATFORM;

//
// RAPI_DEVICEINFO
//
typedef struct RAPI_DEVICEINFO 
{
    RAPIDEVICEID    DeviceId;                       
    DWORD           dwOsVersionMajor;               
    DWORD           dwOsVersionMinor;               
    BSTR            bstrName;       
    BSTR            bstrPlatform;
} RAPI_DEVICEINFO;                     

#define FreeDeviceInfoData(pDevInfo) \
    do \
    { \
        SysFreeString((pDevInfo)->bstrName); \
        SysFreeString((pDevInfo)->bstrPlatform); \
    } while (0,0)

#ifndef MIDL_ONLY
#include "winsock2.h"
#endif

//
// RAPI_DEVICESTATUS
//
typedef enum RAPI_DEVICESTATUS
{
    RAPI_DEVICE_DISCONNECTED = 0,
    RAPI_DEVICE_CONNECTED    = 1,
} RAPI_DEVICESTATUS;

//
// op codes for IRAPIDesktop funcs
//
typedef enum RAPI_GETDEVICEOPCODE
{
    RAPI_GETDEVICE_NONBLOCKING,
    RAPI_GETDEVICE_BLOCKING
} RAPI_GETDEVICEOPCODE;

//
// Connected type codes
//
typedef enum RAPI_CONNECTIONTYPE
{
    RAPI_CONNECTION_USB         = 0,
    RAPI_CONNECTION_IR          = 1,
    RAPI_CONNECTION_SERIAL      = 2,
    RAPI_CONNECTION_NETWORK     = 3,
} RAPI_CONNECTIONTYPE;

typedef struct RAPI_CONNECTIONINFO {
    SOCKADDR_STORAGE ipaddr;            
    SOCKADDR_STORAGE hostIpaddr;   
    RAPI_CONNECTIONTYPE   connectionType;
} RAPI_CONNECTIONINFO;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\pstream.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

#ifndef __PSTREAM__
#define __PSTREAM__

// Base class for persistent properties of filters
// (i.e. filter properties in saved graphs)

// The simplest way to use this is:
// 1. Arrange for your filter to inherit this class
// 2. Implement in your class WriteToStream and ReadFromStream
//    These will override the "do nothing" functions here.
// 3. Change your NonDelegatingQueryInterface to handle IPersistStream
// 4. Implement SizeMax to return the number of bytes of data you save.
//    If you save UNICODE data, don't forget a char is 2 bytes.
// 5. Whenever your data changes, call SetDirty()
//
// At some point you may decide to alter, or extend the format of your data.
// At that point you will wish that you had a version number in all the old
// saved graphs, so that you can tell, when you read them, whether they
// represent the old or new form.  To assist you in this, this class
// writes and reads a version number.
// When it writes, it calls GetSoftwareVersion()  to enquire what version
// of the software we have at the moment.  (In effect this is a version number
// of the data layout in the file).  It writes this as the first thing in the data.
// If you want to change the version, implement (override) GetSoftwareVersion().
// It reads this from the file into mPS_dwFileVersion before calling ReadFromStream,
// so in ReadFromStream you can check mPS_dwFileVersion to see if you are reading
// an old version file.
// Normally you should accept files whose version is no newer than the software
// version that's reading them.


// CPersistStream
//
// Implements IPersistStream.
// See 'OLE Programmers Reference (Vol 1):Structured Storage Overview' for
// more implementation information.
class CPersistStream : public IPersistStream {
    private:

        // Internal state:

    protected:
        DWORD     mPS_dwFileVersion;         // version number of file (being read)
        BOOL      mPS_fDirty;

    public:

        // IPersistStream methods

        STDMETHODIMP IsDirty()
            {return (mPS_fDirty ? S_OK : S_FALSE);}  // note FALSE means clean
        STDMETHODIMP Load(LPSTREAM pStm);
        STDMETHODIMP Save(LPSTREAM pStm, BOOL fClearDirty);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize)
                         // Allow 24 bytes for version.
                         { pcbSize->QuadPart = 12*sizeof(WCHAR)+SizeMax(); return NOERROR; }

        // implementation

        CPersistStream(IUnknown *punk, HRESULT *phr);
        virtual ~CPersistStream();

        HRESULT SetDirty(BOOL fDirty)
            { mPS_fDirty = fDirty; return NOERROR;}


        // override to reveal IPersist & IPersistStream
        // STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

        // --- IPersist ---

        // You must override this to provide your own class id
        STDMETHODIMP GetClassID(CLSID *pClsid) PURE;

        // overrideable if you want
        // file version number.  Override it if you ever change format
        virtual DWORD GetSoftwareVersion(void) { return 0; }


        //=========================================================================
        // OVERRIDE THESE to read and write your data
        // OVERRIDE THESE to read and write your data
        // OVERRIDE THESE to read and write your data

        virtual int SizeMax() {return 0;}
        virtual HRESULT WriteToStream(IStream *pStream);
        virtual HRESULT ReadFromStream(IStream *pStream);
        //=========================================================================

    private:

};


// --- Useful helpers ---


// Writes an int to an IStream as UNICODE.
STDAPI WriteInt(IStream *pIStream, int n);

// inverse of WriteInt
STDAPI_(int) ReadInt(IStream *pIStream, HRESULT &hr);

#endif // __PSTREAM__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\pushclient.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
////////////////////////////////////////////////////////////////////////////////
//                      Copyright  2002, Microsoft Corporation
////////////////////////////////////////////////////////////////////////////////
//
// 
//
//       pushclient.h | 
//                      Push Router Client Interface
//
//     There are six methods in the Push Router Client Interface. 
//          They are defined in pushclient.h. These are APIs on the Push Router proxy dll. 
//          Push Router clients call these APIs. 
//
//          A push router client is a standalone executable that gets registered 
//          with the Push Router and then gets launched if an incoming message matches the  
//          application ID/content-type combination that is registered for that particular client.  
//          Once lauched, the client must call PushRouter_Open to get a handle to Push Router and an event  
//          handle that the client uses to determine when messages arrive for the client. When the event 
//          handle is signaled, the client calls PushRouter_GetMessage to retrieve the message. 
//          Note that, in addition to returning standard Windows HRESULTS, these API's can 
//          also return Push Router-specific HRESULTS, defined in pushclient.h and prefixed by PUSHRTR_.
//
//       The following client example shows how to use these APIs to retrieve 
//          a push message from the Push Router. |
/*

#include "windows.h"
#include "pushclient.h"         

TCHAR const c_szAppId[] = TEXT("TestAppId");
TCHAR const c_szPath[] = TEXT("pushclnt.exe");
TCHAR const c_szContentType[] = TEXT("text/xml");
TCHAR const c_szParams[] = TEXT("/c");

HRESULT
HandleMessage(PUSHMSG *pPushMsg)
{
    // Handle the message here
    return S_OK;

}

int 
WINAPI
WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR szCmdLine, int nCmdShow)
{
    HRESULT         hr              = NOERROR;
    HANDLE          hevtMsgAvailable= NULL;
    HPUSHROUTER     hPushRouter     = NULL;
    PUSHMSG         PushMsg;

    memset(&PushMsg, 0, sizeof(PUSHMSG));

    if (!_tcsicmp(szCmdLine, TEXT("/register"))) 
    {
        hr = PushRouter_RegisterClient(c_szContentType, c_szAppId, c_szPath, c_szParams);
        goto Exit;
    } 
    else if (!_tcsicmp(szCmdLine, TEXT("/unregister"))) 
    {
        hr = PushRouter_UnRegisterClient(c_szContentType, c_szAppId);
        goto Exit;
    }
    else if (!_tcsicmp(szCmdLine, TEXT("/c")))
    {
        // Handle the "/c" parameter here.
    }

    hr = PushRouter_Open(c_szContentType, c_szAppId, &hevtMsgAvailable, &hPushRouter);
    if (FAILED(hr))
    {
        goto Exit;
    }

    while (WaitForSingleObject(hevtMsgAvailable, 10000) != WAIT_TIMEOUT) 
    {
        // Inner loop gets and processes available messages.
        for (;;)
        {
            memset(&PushMsg, 0, sizeof(PUSHMSG));
            PushMsg.cbSize = sizeof(PUSHMSG);

            hr = PushRouter_GetMessage(hPushRouter, &PushMsg);
            if (PUSHRTR_S_NOMESSAGESPENDING == hr)
            {
                // No more pending message. Exit inner loop and wait for message.
                break;
            }
            else if (FAILED(hr))
            {
                goto Exit;
            }
            
            hr = HandleMessage(&PushMsg);
            if (FAILED(hr)) 
            {
                goto Exit;
            }

            PushRouter_FreeMessage(&PushMsg);
        }
    }

Exit:
    hr = PushRouter_Close(hPushRouter);
    PushRouter_FreeMessage(&PushMsg);
    return 0;
}

*/
////////////////////////////////////////////////////////////////////////////////

#pragma once

#ifdef __cplusplus
extern "C" { 
#endif // __cplusplus

#ifndef PUSHROUTERAPI
#define PUSHROUTERAPI
#endif  

// type HPUSHROUTER | Handle to the Push Router.
typedef DWORD HPUSHROUTER;

//
// Push Router-specific Error Return values
// 

// Another client is already opened with same application id/content-type combination.
#define PUSHRTR_E_ALREADYOPENED         0x80530001

// No messages are pending in client's queue.
#define PUSHRTR_S_NOMESSAGESPENDING     0x00530002

// Another client is already registered with same application id/content-type combination.
#define PUSHRTR_E_ALREADYREGISTERED     0x80530003

// No registration exists for the client to be opened or unregistered.
#define PUSHRTR_E_NOTFOUND              0x80530004

// An exception occurred in a pushrouter API.
#define PUSHRTR_E_EXCEPTION             0x80530005
//
// Push Router Structures
//

////////////////////////////////////////////////////////////////////////////////
//
//       PUSHMSG |
//                      Message structure returned to the client from PushRouter_GetMessage 
//
//     The cbSize member needs to be initialized by the push client to be the size of the 
//          PUSHMSG structure before the PUSHMSG structure can be passed into 
//          PushRouter_GetMessage.
////////////////////////////////////////////////////////////////////////////////

typedef struct tagPushMsg
{
    DWORD   cbSize;             //  size of PUSHMSG structure
    LPTSTR  szHeaders;          //  RFC 822 headers
    LPBYTE  pbBody;             //  push message body
    DWORD   cbBodyLength;       //  size of the message body (in bytes)
    DWORD   dwSecurityRole;     //  Security role(s) assigned to the message by Push Router
    DWORD   dwReserved1;        //  Reserved; set to 0
    DWORD   dwReserved2;        //  Reserved; set to 0
} PUSHMSG, *LPPUSHMSG;

//
// Push Router Functions
//

////////////////////////////////////////////////////////////////////////////////
//
//         HRESULT | PushRouter_RegisterClient |
//                      This method registers a client in the Push Router's Registration 
//          Table. All clients that require any interaction with the Push Router 
//          must register using this method.
//
//   PushRouter_RegisterClient(LPCTSTR szContentType, LPCTSTR szAppId, LPCTSTR szPath, LPCTSTR szParams);
//
//         LPCTSTR | szContentType |
//                      Content-type of messages routed to the client
//
//         LPCTSTR | szAppId |
//                      Application ID of the client
//
//         LPCTSTR | szPath |
//                      Path to the client's executable file
//
//         LPCTSTR | szParams |
//                      Command-line parameters to be passed to the client upon launch
//
//       S_OK | Success.
//       PUSHRTR_E_ALREADYREGISTERED | Another client is already registered with same application id/content-type combination.
//       PUSHRTR_E_EXCEPTION | An exception occurred in a pushrouter API.
//
//        HRESULT: An HRESULT describing any errors that occurred.
//
////////////////////////////////////////////////////////////////////////////////

HRESULT PUSHROUTERAPI PushRouter_RegisterClient
(
    LPCTSTR szContentType,
    LPCTSTR szAppId,
    LPCTSTR szPath,
    LPCTSTR szParams
);

////////////////////////////////////////////////////////////////////////////////
//
//         HRESULT | PushRouter_UnRegisterClient |
//                      This method deletes a client entry from the Registration table in the 
//          Push Router. If the client no longer wants to receive push messages 
//          from push router, the client should use this method to unregister itself.
//
//     This API needs to be called once per Application ID/Content-Type combination.
//
//   PushRouter_UnRegisterClient(LPCTSTR szContentType, LPCTSTR szAppId);
//
//         LPCTSTR | szContentType |
//                      Content-type of messages routed to the client
//
//         LPCTSTR | szAppId |
//                      Application ID of the client
//
//       S_OK | Success.
//       PUSHRTR_E_NOTFOUND | No registration exists for the client to be unregistered.
//       PUSHRTR_E_EXCEPTION | An exception occurred in a pushrouter API.
//
//        HRESULT: An HRESULT describing any errors that occurred.
//
////////////////////////////////////////////////////////////////////////////////

HRESULT PUSHROUTERAPI PushRouter_UnRegisterClient
(
    LPCTSTR szContentType,
    LPCTSTR szAppId
);


////////////////////////////////////////////////////////////////////////////////
//
//         HRESULT | PushRouter_Open |
//                      This method opens a communication channel to a client through which 
//          a push message can be passed.  
//
//     CloseHandle should not be called on the message handle returned by PushRouter_Open.
//
//   PushRouter_Open(LPCTSTR szContentType, LPCTSTR szAppId, HANDLE *pMsgAvailableEvent, HPUSHROUTER *phPushRouter);
//
//         LPCTSTR | szContentType |
//                      Content-type of messages routed to the client
//
//         LPCTSTR | szAppId |
//                      Application ID of the client
//
//         HANDLE | *pMsgAvailableEvent |
//                      Handle to event signaled by the Push Router when a message is available
//
//         HPUSHROUTER | *phPushRouter |
//                      Handle to the Push Router
//
//       S_OK | Success.
//       PUSHRTR_E_NOTFOUND | No registration exists for the client to be opened.
//       PUSHRTR_E_ALREADYOPENED | Another client is already opened with same application id/content-type combination.
//       PUSHRTR_E_EXCEPTION | An exception occurred in a pushrouter API.
//
//        HRESULT: An HRESULT describing any errors that occurred.
//
////////////////////////////////////////////////////////////////////////////////

HRESULT PUSHROUTERAPI PushRouter_Open
(
    LPCTSTR      szContentType,
    LPCTSTR      szAppId,
    HANDLE*      pMsgAvailableEvent,
    HPUSHROUTER* phPushRouter
);


////////////////////////////////////////////////////////////////////////////////
//
//         HRESULT | PushRouter_Close |
//                      This method closes the communication with the client.
//
//   PushRouter_Close(HPUSHROUTER hPushRouter);
//
//         HPUSHROUTER | hPushRouter |
//                      Handle to the Push Router
//
//       S_OK | Success.
//       PUSHRTR_E_EXCEPTION | An exception occurred in a pushrouter API.
//
//        HRESULT: An HRESULT describing any errors that occurred.
//
////////////////////////////////////////////////////////////////////////////////

HRESULT PUSHROUTERAPI PushRouter_Close(HPUSHROUTER hPushRouter);


////////////////////////////////////////////////////////////////////////////////
//
//         HRESULT | PushRouter_GetMessage |
//                      This method passes the message from the Push Router to the client.
//
//     The cbSize member needs to be initialized by the push client to be the size of the 
//          PUSHMSG structure before the PUSHMSG structure can be passed into 
//          PushRouter_GetMessage.
//
//   PushRouter_GetMessage(HPUSHROUTER hPushRouter, LPPUSHMSG pPushMsg);
//
//         HPUSHROUTER | hPushRouter |
//                      Handle to the Push Router
//
//         LPPUSHMSG | pPushMsg |
//                      Message structure filled out by the Push Router
//
//       S_OK | Success.
//       PUSHRTR_S_NOMESSAGESPENDING | No messages are pending in client's queue.
//       PUSHRTR_E_EXCEPTION | An exception occurred in a pushrouter API.
//
//        HRESULT: An HRESULT describing any errors that occurred.
//
////////////////////////////////////////////////////////////////////////////////

HRESULT PUSHROUTERAPI PushRouter_GetMessage
(
    HPUSHROUTER hPushRouter,
    LPPUSHMSG pPushMsg
);


////////////////////////////////////////////////////////////////////////////////
//
//  HRESULT | PushRouter_FreeMessage |
//  This method frees up the memory allocated in the client process space 
//  by the Push Router.
//
//  If pMsg is NULL, nothing is done.  
//
//  PushRouter_FreeMessage(LPPUSHMSG pPushMsg);
//
//  LPPUSHMSG | pPushMsg |
//  Message structure filled out by the Push Router
//
//  S_OK | Success.
//
//  HRESULT: An HRESULT describing any errors that occurred.
//
////////////////////////////////////////////////////////////////////////////////

HRESULT PUSHROUTERAPI PushRouter_FreeMessage(__in_opt LPPUSHMSG pPushMsg);


#ifdef __cplusplus
};
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\qnetwork.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for qnetwork.odl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __qnetwork_h__
#define __qnetwork_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAMNetShowConfig_FWD_DEFINED__
#define __IAMNetShowConfig_FWD_DEFINED__
typedef interface IAMNetShowConfig IAMNetShowConfig;
#endif 	/* __IAMNetShowConfig_FWD_DEFINED__ */


#ifndef __IAMChannelInfo_FWD_DEFINED__
#define __IAMChannelInfo_FWD_DEFINED__
typedef interface IAMChannelInfo IAMChannelInfo;
#endif 	/* __IAMChannelInfo_FWD_DEFINED__ */


#ifndef __IAMNetworkStatus_FWD_DEFINED__
#define __IAMNetworkStatus_FWD_DEFINED__
typedef interface IAMNetworkStatus IAMNetworkStatus;
#endif 	/* __IAMNetworkStatus_FWD_DEFINED__ */


#ifndef __IAMExtendedSeeking_FWD_DEFINED__
#define __IAMExtendedSeeking_FWD_DEFINED__
typedef interface IAMExtendedSeeking IAMExtendedSeeking;
#endif 	/* __IAMExtendedSeeking_FWD_DEFINED__ */


#ifndef __IAMNetShowExProps_FWD_DEFINED__
#define __IAMNetShowExProps_FWD_DEFINED__
typedef interface IAMNetShowExProps IAMNetShowExProps;
#endif 	/* __IAMNetShowExProps_FWD_DEFINED__ */


#ifndef __IAMExtendedErrorInfo_FWD_DEFINED__
#define __IAMExtendedErrorInfo_FWD_DEFINED__
typedef interface IAMExtendedErrorInfo IAMExtendedErrorInfo;
#endif 	/* __IAMExtendedErrorInfo_FWD_DEFINED__ */


#ifndef __IAMMediaContent_FWD_DEFINED__
#define __IAMMediaContent_FWD_DEFINED__
typedef interface IAMMediaContent IAMMediaContent;
#endif 	/* __IAMMediaContent_FWD_DEFINED__ */


#ifndef __IAMMediaContent2_FWD_DEFINED__
#define __IAMMediaContent2_FWD_DEFINED__
typedef interface IAMMediaContent2 IAMMediaContent2;
#endif 	/* __IAMMediaContent2_FWD_DEFINED__ */


#ifndef __IAMMediaContentEx_FWD_DEFINED__
#define __IAMMediaContentEx_FWD_DEFINED__
typedef interface IAMMediaContentEx IAMMediaContentEx;
#endif 	/* __IAMMediaContentEx_FWD_DEFINED__ */


#ifndef __IAMNetShowPreroll_FWD_DEFINED__
#define __IAMNetShowPreroll_FWD_DEFINED__
typedef interface IAMNetShowPreroll IAMNetShowPreroll;
#endif 	/* __IAMNetShowPreroll_FWD_DEFINED__ */


#ifndef __IDShowPlugin_FWD_DEFINED__
#define __IDShowPlugin_FWD_DEFINED__
typedef interface IDShowPlugin IDShowPlugin;
#endif 	/* __IDShowPlugin_FWD_DEFINED__ */


#ifndef __IAMSecureMediaContent_FWD_DEFINED__
#define __IAMSecureMediaContent_FWD_DEFINED__
typedef interface IAMSecureMediaContent IAMSecureMediaContent;
#endif 	/* __IAMSecureMediaContent_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __QuartzNetTypeLib_LIBRARY_DEFINED__
#define __QuartzNetTypeLib_LIBRARY_DEFINED__

/* library QuartzNetTypeLib */
/* [version][lcid][helpstring][uuid] */ 

typedef 
enum __MIDL___MIDL_itf_qnetwork_0001_0002_0001
    {	AM_EXSEEK_CANSEEK	= 1,
	AM_EXSEEK_CANSCAN	= 2,
	AM_EXSEEK_MARKERSEEK	= 4,
	AM_EXSEEK_SCANWITHOUTCLOCK	= 8,
	AM_EXSEEK_NOSTANDARDREPAINT	= 16,
	AM_EXSEEK_BUFFERING	= 32,
	AM_EXSEEK_SENDS_VIDEOFRAMEREADY	= 64
    } 	AMExtendedSeekingCapabilities;


DEFINE_GUID(LIBID_QuartzNetTypeLib,0x56a868b1,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#ifndef __IAMNetShowConfig_INTERFACE_DEFINED__
#define __IAMNetShowConfig_INTERFACE_DEFINED__

/* interface IAMNetShowConfig */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMNetShowConfig,0xFA2AA8F1,0x8B62,0x11d0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA2AA8F1-8B62-11d0-A520-000000000000")
    IAMNetShowConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BufferingTime( 
            /* [retval][out] */ double *pBufferingTime) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BufferingTime( 
            /* [in] */ double BufferingTime) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UseFixedUDPPort( 
            /* [retval][out] */ VARIANT_BOOL *pUseFixedUDPPort) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseFixedUDPPort( 
            /* [in] */ VARIANT_BOOL UseFixedUDPPort) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FixedUDPPort( 
            /* [retval][out] */ long *pFixedUDPPort) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FixedUDPPort( 
            /* [in] */ long FixedUDPPort) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UseHTTPProxy( 
            /* [retval][out] */ VARIANT_BOOL *pUseHTTPProxy) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseHTTPProxy( 
            /* [in] */ VARIANT_BOOL UseHTTPProxy) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableAutoProxy( 
            /* [retval][out] */ VARIANT_BOOL *pEnableAutoProxy) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableAutoProxy( 
            /* [in] */ VARIANT_BOOL EnableAutoProxy) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HTTPProxyHost( 
            /* [retval][out] */ BSTR *pbstrHTTPProxyHost) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HTTPProxyHost( 
            /* [in] */ BSTR bstrHTTPProxyHost) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HTTPProxyPort( 
            /* [retval][out] */ long *pHTTPProxyPort) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HTTPProxyPort( 
            /* [in] */ long HTTPProxyPort) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableMulticast( 
            /* [retval][out] */ VARIANT_BOOL *pEnableMulticast) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableMulticast( 
            /* [in] */ VARIANT_BOOL EnableMulticast) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableUDP( 
            /* [retval][out] */ VARIANT_BOOL *pEnableUDP) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableUDP( 
            /* [in] */ VARIANT_BOOL EnableUDP) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableTCP( 
            /* [retval][out] */ VARIANT_BOOL *pEnableTCP) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableTCP( 
            /* [in] */ VARIANT_BOOL EnableTCP) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EnableHTTP( 
            /* [retval][out] */ VARIANT_BOOL *pEnableHTTP) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableHTTP( 
            /* [in] */ VARIANT_BOOL EnableHTTP) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMNetShowConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMNetShowConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMNetShowConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMNetShowConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMNetShowConfig * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMNetShowConfig * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMNetShowConfig * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMNetShowConfig * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingTime )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ double *pBufferingTime);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BufferingTime )( 
            IAMNetShowConfig * This,
            /* [in] */ double BufferingTime);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseFixedUDPPort )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ VARIANT_BOOL *pUseFixedUDPPort);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseFixedUDPPort )( 
            IAMNetShowConfig * This,
            /* [in] */ VARIANT_BOOL UseFixedUDPPort);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FixedUDPPort )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ long *pFixedUDPPort);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FixedUDPPort )( 
            IAMNetShowConfig * This,
            /* [in] */ long FixedUDPPort);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseHTTPProxy )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ VARIANT_BOOL *pUseHTTPProxy);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseHTTPProxy )( 
            IAMNetShowConfig * This,
            /* [in] */ VARIANT_BOOL UseHTTPProxy);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableAutoProxy )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableAutoProxy);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableAutoProxy )( 
            IAMNetShowConfig * This,
            /* [in] */ VARIANT_BOOL EnableAutoProxy);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HTTPProxyHost )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ BSTR *pbstrHTTPProxyHost);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HTTPProxyHost )( 
            IAMNetShowConfig * This,
            /* [in] */ BSTR bstrHTTPProxyHost);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HTTPProxyPort )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ long *pHTTPProxyPort);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HTTPProxyPort )( 
            IAMNetShowConfig * This,
            /* [in] */ long HTTPProxyPort);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableMulticast )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableMulticast);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableMulticast )( 
            IAMNetShowConfig * This,
            /* [in] */ VARIANT_BOOL EnableMulticast);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableUDP )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableUDP);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableUDP )( 
            IAMNetShowConfig * This,
            /* [in] */ VARIANT_BOOL EnableUDP);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableTCP )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableTCP);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableTCP )( 
            IAMNetShowConfig * This,
            /* [in] */ VARIANT_BOOL EnableTCP);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableHTTP )( 
            IAMNetShowConfig * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableHTTP);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableHTTP )( 
            IAMNetShowConfig * This,
            /* [in] */ VARIANT_BOOL EnableHTTP);
        
        END_INTERFACE
    } IAMNetShowConfigVtbl;

    interface IAMNetShowConfig
    {
        CONST_VTBL struct IAMNetShowConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMNetShowConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMNetShowConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMNetShowConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMNetShowConfig_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMNetShowConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMNetShowConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMNetShowConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMNetShowConfig_get_BufferingTime(This,pBufferingTime)	\
    ( (This)->lpVtbl -> get_BufferingTime(This,pBufferingTime) ) 

#define IAMNetShowConfig_put_BufferingTime(This,BufferingTime)	\
    ( (This)->lpVtbl -> put_BufferingTime(This,BufferingTime) ) 

#define IAMNetShowConfig_get_UseFixedUDPPort(This,pUseFixedUDPPort)	\
    ( (This)->lpVtbl -> get_UseFixedUDPPort(This,pUseFixedUDPPort) ) 

#define IAMNetShowConfig_put_UseFixedUDPPort(This,UseFixedUDPPort)	\
    ( (This)->lpVtbl -> put_UseFixedUDPPort(This,UseFixedUDPPort) ) 

#define IAMNetShowConfig_get_FixedUDPPort(This,pFixedUDPPort)	\
    ( (This)->lpVtbl -> get_FixedUDPPort(This,pFixedUDPPort) ) 

#define IAMNetShowConfig_put_FixedUDPPort(This,FixedUDPPort)	\
    ( (This)->lpVtbl -> put_FixedUDPPort(This,FixedUDPPort) ) 

#define IAMNetShowConfig_get_UseHTTPProxy(This,pUseHTTPProxy)	\
    ( (This)->lpVtbl -> get_UseHTTPProxy(This,pUseHTTPProxy) ) 

#define IAMNetShowConfig_put_UseHTTPProxy(This,UseHTTPProxy)	\
    ( (This)->lpVtbl -> put_UseHTTPProxy(This,UseHTTPProxy) ) 

#define IAMNetShowConfig_get_EnableAutoProxy(This,pEnableAutoProxy)	\
    ( (This)->lpVtbl -> get_EnableAutoProxy(This,pEnableAutoProxy) ) 

#define IAMNetShowConfig_put_EnableAutoProxy(This,EnableAutoProxy)	\
    ( (This)->lpVtbl -> put_EnableAutoProxy(This,EnableAutoProxy) ) 

#define IAMNetShowConfig_get_HTTPProxyHost(This,pbstrHTTPProxyHost)	\
    ( (This)->lpVtbl -> get_HTTPProxyHost(This,pbstrHTTPProxyHost) ) 

#define IAMNetShowConfig_put_HTTPProxyHost(This,bstrHTTPProxyHost)	\
    ( (This)->lpVtbl -> put_HTTPProxyHost(This,bstrHTTPProxyHost) ) 

#define IAMNetShowConfig_get_HTTPProxyPort(This,pHTTPProxyPort)	\
    ( (This)->lpVtbl -> get_HTTPProxyPort(This,pHTTPProxyPort) ) 

#define IAMNetShowConfig_put_HTTPProxyPort(This,HTTPProxyPort)	\
    ( (This)->lpVtbl -> put_HTTPProxyPort(This,HTTPProxyPort) ) 

#define IAMNetShowConfig_get_EnableMulticast(This,pEnableMulticast)	\
    ( (This)->lpVtbl -> get_EnableMulticast(This,pEnableMulticast) ) 

#define IAMNetShowConfig_put_EnableMulticast(This,EnableMulticast)	\
    ( (This)->lpVtbl -> put_EnableMulticast(This,EnableMulticast) ) 

#define IAMNetShowConfig_get_EnableUDP(This,pEnableUDP)	\
    ( (This)->lpVtbl -> get_EnableUDP(This,pEnableUDP) ) 

#define IAMNetShowConfig_put_EnableUDP(This,EnableUDP)	\
    ( (This)->lpVtbl -> put_EnableUDP(This,EnableUDP) ) 

#define IAMNetShowConfig_get_EnableTCP(This,pEnableTCP)	\
    ( (This)->lpVtbl -> get_EnableTCP(This,pEnableTCP) ) 

#define IAMNetShowConfig_put_EnableTCP(This,EnableTCP)	\
    ( (This)->lpVtbl -> put_EnableTCP(This,EnableTCP) ) 

#define IAMNetShowConfig_get_EnableHTTP(This,pEnableHTTP)	\
    ( (This)->lpVtbl -> get_EnableHTTP(This,pEnableHTTP) ) 

#define IAMNetShowConfig_put_EnableHTTP(This,EnableHTTP)	\
    ( (This)->lpVtbl -> put_EnableHTTP(This,EnableHTTP) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMNetShowConfig_INTERFACE_DEFINED__ */


#ifndef __IAMChannelInfo_INTERFACE_DEFINED__
#define __IAMChannelInfo_INTERFACE_DEFINED__

/* interface IAMChannelInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMChannelInfo,0xFA2AA8F2,0x8B62,0x11d0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA2AA8F2-8B62-11d0-A520-000000000000")
    IAMChannelInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ChannelName( 
            /* [retval][out] */ BSTR *pbstrChannelName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ChannelDescription( 
            /* [retval][out] */ BSTR *pbstrChannelDescription) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ChannelURL( 
            /* [retval][out] */ BSTR *pbstrChannelURL) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContactAddress( 
            /* [retval][out] */ BSTR *pbstrContactAddress) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContactPhone( 
            /* [retval][out] */ BSTR *pbstrContactPhone) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContactEmail( 
            /* [retval][out] */ BSTR *pbstrContactEmail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMChannelInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMChannelInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMChannelInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMChannelInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMChannelInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMChannelInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMChannelInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMChannelInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelName )( 
            IAMChannelInfo * This,
            /* [retval][out] */ BSTR *pbstrChannelName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelDescription )( 
            IAMChannelInfo * This,
            /* [retval][out] */ BSTR *pbstrChannelDescription);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelURL )( 
            IAMChannelInfo * This,
            /* [retval][out] */ BSTR *pbstrChannelURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContactAddress )( 
            IAMChannelInfo * This,
            /* [retval][out] */ BSTR *pbstrContactAddress);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContactPhone )( 
            IAMChannelInfo * This,
            /* [retval][out] */ BSTR *pbstrContactPhone);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContactEmail )( 
            IAMChannelInfo * This,
            /* [retval][out] */ BSTR *pbstrContactEmail);
        
        END_INTERFACE
    } IAMChannelInfoVtbl;

    interface IAMChannelInfo
    {
        CONST_VTBL struct IAMChannelInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMChannelInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMChannelInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMChannelInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMChannelInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMChannelInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMChannelInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMChannelInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMChannelInfo_get_ChannelName(This,pbstrChannelName)	\
    ( (This)->lpVtbl -> get_ChannelName(This,pbstrChannelName) ) 

#define IAMChannelInfo_get_ChannelDescription(This,pbstrChannelDescription)	\
    ( (This)->lpVtbl -> get_ChannelDescription(This,pbstrChannelDescription) ) 

#define IAMChannelInfo_get_ChannelURL(This,pbstrChannelURL)	\
    ( (This)->lpVtbl -> get_ChannelURL(This,pbstrChannelURL) ) 

#define IAMChannelInfo_get_ContactAddress(This,pbstrContactAddress)	\
    ( (This)->lpVtbl -> get_ContactAddress(This,pbstrContactAddress) ) 

#define IAMChannelInfo_get_ContactPhone(This,pbstrContactPhone)	\
    ( (This)->lpVtbl -> get_ContactPhone(This,pbstrContactPhone) ) 

#define IAMChannelInfo_get_ContactEmail(This,pbstrContactEmail)	\
    ( (This)->lpVtbl -> get_ContactEmail(This,pbstrContactEmail) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMChannelInfo_INTERFACE_DEFINED__ */


#ifndef __IAMNetworkStatus_INTERFACE_DEFINED__
#define __IAMNetworkStatus_INTERFACE_DEFINED__

/* interface IAMNetworkStatus */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMNetworkStatus,0xFA2AA8F3,0x8B62,0x11d0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA2AA8F3-8B62-11d0-A520-000000000000")
    IAMNetworkStatus : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ReceivedPackets( 
            /* [retval][out] */ long *pReceivedPackets) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RecoveredPackets( 
            /* [retval][out] */ long *pRecoveredPackets) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LostPackets( 
            /* [retval][out] */ long *pLostPackets) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ReceptionQuality( 
            /* [retval][out] */ long *pReceptionQuality) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BufferingCount( 
            /* [retval][out] */ long *pBufferingCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsBroadcast( 
            /* [retval][out] */ VARIANT_BOOL *pIsBroadcast) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BufferingProgress( 
            /* [retval][out] */ long *pBufferingProgress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMNetworkStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMNetworkStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMNetworkStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMNetworkStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMNetworkStatus * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMNetworkStatus * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMNetworkStatus * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMNetworkStatus * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivedPackets )( 
            IAMNetworkStatus * This,
            /* [retval][out] */ long *pReceivedPackets);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RecoveredPackets )( 
            IAMNetworkStatus * This,
            /* [retval][out] */ long *pRecoveredPackets);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LostPackets )( 
            IAMNetworkStatus * This,
            /* [retval][out] */ long *pLostPackets);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReceptionQuality )( 
            IAMNetworkStatus * This,
            /* [retval][out] */ long *pReceptionQuality);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingCount )( 
            IAMNetworkStatus * This,
            /* [retval][out] */ long *pBufferingCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsBroadcast )( 
            IAMNetworkStatus * This,
            /* [retval][out] */ VARIANT_BOOL *pIsBroadcast);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingProgress )( 
            IAMNetworkStatus * This,
            /* [retval][out] */ long *pBufferingProgress);
        
        END_INTERFACE
    } IAMNetworkStatusVtbl;

    interface IAMNetworkStatus
    {
        CONST_VTBL struct IAMNetworkStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMNetworkStatus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMNetworkStatus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMNetworkStatus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMNetworkStatus_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMNetworkStatus_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMNetworkStatus_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMNetworkStatus_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMNetworkStatus_get_ReceivedPackets(This,pReceivedPackets)	\
    ( (This)->lpVtbl -> get_ReceivedPackets(This,pReceivedPackets) ) 

#define IAMNetworkStatus_get_RecoveredPackets(This,pRecoveredPackets)	\
    ( (This)->lpVtbl -> get_RecoveredPackets(This,pRecoveredPackets) ) 

#define IAMNetworkStatus_get_LostPackets(This,pLostPackets)	\
    ( (This)->lpVtbl -> get_LostPackets(This,pLostPackets) ) 

#define IAMNetworkStatus_get_ReceptionQuality(This,pReceptionQuality)	\
    ( (This)->lpVtbl -> get_ReceptionQuality(This,pReceptionQuality) ) 

#define IAMNetworkStatus_get_BufferingCount(This,pBufferingCount)	\
    ( (This)->lpVtbl -> get_BufferingCount(This,pBufferingCount) ) 

#define IAMNetworkStatus_get_IsBroadcast(This,pIsBroadcast)	\
    ( (This)->lpVtbl -> get_IsBroadcast(This,pIsBroadcast) ) 

#define IAMNetworkStatus_get_BufferingProgress(This,pBufferingProgress)	\
    ( (This)->lpVtbl -> get_BufferingProgress(This,pBufferingProgress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMNetworkStatus_INTERFACE_DEFINED__ */


#ifndef __IAMExtendedSeeking_INTERFACE_DEFINED__
#define __IAMExtendedSeeking_INTERFACE_DEFINED__

/* interface IAMExtendedSeeking */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMExtendedSeeking,0xFA2AA8F9,0x8B62,0x11d0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA2AA8F9-8B62-11d0-A520-000000000000")
    IAMExtendedSeeking : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExSeekCapabilities( 
            /* [retval][out] */ long *pExCapabilities) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MarkerCount( 
            /* [retval][out] */ long *pMarkerCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentMarker( 
            /* [retval][out] */ long *pCurrentMarker) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMarkerTime( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMarkerName( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PlaybackSpeed( 
            /* [in] */ double Speed) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PlaybackSpeed( 
            /* [retval][out] */ double *pSpeed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMExtendedSeekingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMExtendedSeeking * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMExtendedSeeking * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMExtendedSeeking * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMExtendedSeeking * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMExtendedSeeking * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMExtendedSeeking * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMExtendedSeeking * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExSeekCapabilities )( 
            IAMExtendedSeeking * This,
            /* [retval][out] */ long *pExCapabilities);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MarkerCount )( 
            IAMExtendedSeeking * This,
            /* [retval][out] */ long *pMarkerCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMarker )( 
            IAMExtendedSeeking * This,
            /* [retval][out] */ long *pCurrentMarker);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerTime )( 
            IAMExtendedSeeking * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerName )( 
            IAMExtendedSeeking * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlaybackSpeed )( 
            IAMExtendedSeeking * This,
            /* [in] */ double Speed);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlaybackSpeed )( 
            IAMExtendedSeeking * This,
            /* [retval][out] */ double *pSpeed);
        
        END_INTERFACE
    } IAMExtendedSeekingVtbl;

    interface IAMExtendedSeeking
    {
        CONST_VTBL struct IAMExtendedSeekingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMExtendedSeeking_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMExtendedSeeking_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMExtendedSeeking_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMExtendedSeeking_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMExtendedSeeking_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMExtendedSeeking_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMExtendedSeeking_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMExtendedSeeking_get_ExSeekCapabilities(This,pExCapabilities)	\
    ( (This)->lpVtbl -> get_ExSeekCapabilities(This,pExCapabilities) ) 

#define IAMExtendedSeeking_get_MarkerCount(This,pMarkerCount)	\
    ( (This)->lpVtbl -> get_MarkerCount(This,pMarkerCount) ) 

#define IAMExtendedSeeking_get_CurrentMarker(This,pCurrentMarker)	\
    ( (This)->lpVtbl -> get_CurrentMarker(This,pCurrentMarker) ) 

#define IAMExtendedSeeking_GetMarkerTime(This,MarkerNum,pMarkerTime)	\
    ( (This)->lpVtbl -> GetMarkerTime(This,MarkerNum,pMarkerTime) ) 

#define IAMExtendedSeeking_GetMarkerName(This,MarkerNum,pbstrMarkerName)	\
    ( (This)->lpVtbl -> GetMarkerName(This,MarkerNum,pbstrMarkerName) ) 

#define IAMExtendedSeeking_put_PlaybackSpeed(This,Speed)	\
    ( (This)->lpVtbl -> put_PlaybackSpeed(This,Speed) ) 

#define IAMExtendedSeeking_get_PlaybackSpeed(This,pSpeed)	\
    ( (This)->lpVtbl -> get_PlaybackSpeed(This,pSpeed) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMExtendedSeeking_INTERFACE_DEFINED__ */


#ifndef __IAMNetShowExProps_INTERFACE_DEFINED__
#define __IAMNetShowExProps_INTERFACE_DEFINED__

/* interface IAMNetShowExProps */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMNetShowExProps,0xFA2AA8F5,0x8B62,0x11d0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA2AA8F5-8B62-11d0-A520-000000000000")
    IAMNetShowExProps : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SourceProtocol( 
            /* [retval][out] */ long *pSourceProtocol) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Bandwidth( 
            /* [retval][out] */ long *pBandwidth) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCorrection( 
            /* [retval][out] */ BSTR *pbstrErrorCorrection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CodecCount( 
            /* [retval][out] */ long *pCodecCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCodecInstalled( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL *pCodecInstalled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCodecDescription( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecDescription) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCodecURL( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecURL) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CreationDate( 
            /* [retval][out] */ DATE *pCreationDate) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SourceLink( 
            /* [retval][out] */ BSTR *pbstrSourceLink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMNetShowExPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMNetShowExProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMNetShowExProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMNetShowExProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMNetShowExProps * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMNetShowExProps * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMNetShowExProps * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMNetShowExProps * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceProtocol )( 
            IAMNetShowExProps * This,
            /* [retval][out] */ long *pSourceProtocol);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Bandwidth )( 
            IAMNetShowExProps * This,
            /* [retval][out] */ long *pBandwidth);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCorrection )( 
            IAMNetShowExProps * This,
            /* [retval][out] */ BSTR *pbstrErrorCorrection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CodecCount )( 
            IAMNetShowExProps * This,
            /* [retval][out] */ long *pCodecCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCodecInstalled )( 
            IAMNetShowExProps * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL *pCodecInstalled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCodecDescription )( 
            IAMNetShowExProps * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecDescription);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCodecURL )( 
            IAMNetShowExProps * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationDate )( 
            IAMNetShowExProps * This,
            /* [retval][out] */ DATE *pCreationDate);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLink )( 
            IAMNetShowExProps * This,
            /* [retval][out] */ BSTR *pbstrSourceLink);
        
        END_INTERFACE
    } IAMNetShowExPropsVtbl;

    interface IAMNetShowExProps
    {
        CONST_VTBL struct IAMNetShowExPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMNetShowExProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMNetShowExProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMNetShowExProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMNetShowExProps_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMNetShowExProps_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMNetShowExProps_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMNetShowExProps_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMNetShowExProps_get_SourceProtocol(This,pSourceProtocol)	\
    ( (This)->lpVtbl -> get_SourceProtocol(This,pSourceProtocol) ) 

#define IAMNetShowExProps_get_Bandwidth(This,pBandwidth)	\
    ( (This)->lpVtbl -> get_Bandwidth(This,pBandwidth) ) 

#define IAMNetShowExProps_get_ErrorCorrection(This,pbstrErrorCorrection)	\
    ( (This)->lpVtbl -> get_ErrorCorrection(This,pbstrErrorCorrection) ) 

#define IAMNetShowExProps_get_CodecCount(This,pCodecCount)	\
    ( (This)->lpVtbl -> get_CodecCount(This,pCodecCount) ) 

#define IAMNetShowExProps_GetCodecInstalled(This,CodecNum,pCodecInstalled)	\
    ( (This)->lpVtbl -> GetCodecInstalled(This,CodecNum,pCodecInstalled) ) 

#define IAMNetShowExProps_GetCodecDescription(This,CodecNum,pbstrCodecDescription)	\
    ( (This)->lpVtbl -> GetCodecDescription(This,CodecNum,pbstrCodecDescription) ) 

#define IAMNetShowExProps_GetCodecURL(This,CodecNum,pbstrCodecURL)	\
    ( (This)->lpVtbl -> GetCodecURL(This,CodecNum,pbstrCodecURL) ) 

#define IAMNetShowExProps_get_CreationDate(This,pCreationDate)	\
    ( (This)->lpVtbl -> get_CreationDate(This,pCreationDate) ) 

#define IAMNetShowExProps_get_SourceLink(This,pbstrSourceLink)	\
    ( (This)->lpVtbl -> get_SourceLink(This,pbstrSourceLink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMNetShowExProps_INTERFACE_DEFINED__ */


#ifndef __IAMExtendedErrorInfo_INTERFACE_DEFINED__
#define __IAMExtendedErrorInfo_INTERFACE_DEFINED__

/* interface IAMExtendedErrorInfo */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMExtendedErrorInfo,0xFA2AA8F6,0x8B62,0x11d0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA2AA8F6-8B62-11d0-A520-000000000000")
    IAMExtendedErrorInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasError( 
            /* [retval][out] */ VARIANT_BOOL *pHasError) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pbstrErrorDescription) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ long *pErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMExtendedErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMExtendedErrorInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMExtendedErrorInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMExtendedErrorInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMExtendedErrorInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMExtendedErrorInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMExtendedErrorInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMExtendedErrorInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasError )( 
            IAMExtendedErrorInfo * This,
            /* [retval][out] */ VARIANT_BOOL *pHasError);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IAMExtendedErrorInfo * This,
            /* [retval][out] */ BSTR *pbstrErrorDescription);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IAMExtendedErrorInfo * This,
            /* [retval][out] */ long *pErrorCode);
        
        END_INTERFACE
    } IAMExtendedErrorInfoVtbl;

    interface IAMExtendedErrorInfo
    {
        CONST_VTBL struct IAMExtendedErrorInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMExtendedErrorInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMExtendedErrorInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMExtendedErrorInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMExtendedErrorInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMExtendedErrorInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMExtendedErrorInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMExtendedErrorInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMExtendedErrorInfo_get_HasError(This,pHasError)	\
    ( (This)->lpVtbl -> get_HasError(This,pHasError) ) 

#define IAMExtendedErrorInfo_get_ErrorDescription(This,pbstrErrorDescription)	\
    ( (This)->lpVtbl -> get_ErrorDescription(This,pbstrErrorDescription) ) 

#define IAMExtendedErrorInfo_get_ErrorCode(This,pErrorCode)	\
    ( (This)->lpVtbl -> get_ErrorCode(This,pErrorCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMExtendedErrorInfo_INTERFACE_DEFINED__ */


#ifndef __IAMMediaContent_INTERFACE_DEFINED__
#define __IAMMediaContent_INTERFACE_DEFINED__

/* interface IAMMediaContent */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMMediaContent,0xFA2AA8F4,0x8B62,0x11d0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA2AA8F4-8B62-11d0-A520-000000000000")
    IAMMediaContent : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AuthorName( 
            /* [retval][out] */ BSTR *pbstrAuthorName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR *pbstrTitle) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Rating( 
            /* [retval][out] */ BSTR *pbstrRating) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pbstrDescription) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pbstrCopyright) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BaseURL( 
            /* [retval][out] */ BSTR *pbstrBaseURL) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LogoURL( 
            /* [retval][out] */ BSTR *pbstrLogoURL) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LogoIconURL( 
            /* [retval][out] */ BSTR *pbstrLogoURL) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_WatermarkURL( 
            /* [retval][out] */ BSTR *pbstrWatermarkURL) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MoreInfoURL( 
            /* [retval][out] */ BSTR *pbstrMoreInfoURL) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MoreInfoBannerImage( 
            /* [retval][out] */ BSTR *pbstrMoreInfoBannerImage) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MoreInfoBannerURL( 
            /* [retval][out] */ BSTR *pbstrMoreInfoBannerURL) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MoreInfoText( 
            /* [retval][out] */ BSTR *pbstrMoreInfoText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMediaContentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMediaContent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMediaContent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMediaContent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMMediaContent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMMediaContent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMMediaContent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMMediaContent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuthorName )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrAuthorName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rating )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrRating);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrCopyright);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BaseURL )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrBaseURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogoURL )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrLogoURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogoIconURL )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrLogoURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WatermarkURL )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrWatermarkURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoURL )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrMoreInfoURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoBannerImage )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrMoreInfoBannerImage);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoBannerURL )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrMoreInfoBannerURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoText )( 
            IAMMediaContent * This,
            /* [retval][out] */ BSTR *pbstrMoreInfoText);
        
        END_INTERFACE
    } IAMMediaContentVtbl;

    interface IAMMediaContent
    {
        CONST_VTBL struct IAMMediaContentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMediaContent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMMediaContent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMMediaContent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMMediaContent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMMediaContent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMMediaContent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMMediaContent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMMediaContent_get_AuthorName(This,pbstrAuthorName)	\
    ( (This)->lpVtbl -> get_AuthorName(This,pbstrAuthorName) ) 

#define IAMMediaContent_get_Title(This,pbstrTitle)	\
    ( (This)->lpVtbl -> get_Title(This,pbstrTitle) ) 

#define IAMMediaContent_get_Rating(This,pbstrRating)	\
    ( (This)->lpVtbl -> get_Rating(This,pbstrRating) ) 

#define IAMMediaContent_get_Description(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbstrDescription) ) 

#define IAMMediaContent_get_Copyright(This,pbstrCopyright)	\
    ( (This)->lpVtbl -> get_Copyright(This,pbstrCopyright) ) 

#define IAMMediaContent_get_BaseURL(This,pbstrBaseURL)	\
    ( (This)->lpVtbl -> get_BaseURL(This,pbstrBaseURL) ) 

#define IAMMediaContent_get_LogoURL(This,pbstrLogoURL)	\
    ( (This)->lpVtbl -> get_LogoURL(This,pbstrLogoURL) ) 

#define IAMMediaContent_get_LogoIconURL(This,pbstrLogoURL)	\
    ( (This)->lpVtbl -> get_LogoIconURL(This,pbstrLogoURL) ) 

#define IAMMediaContent_get_WatermarkURL(This,pbstrWatermarkURL)	\
    ( (This)->lpVtbl -> get_WatermarkURL(This,pbstrWatermarkURL) ) 

#define IAMMediaContent_get_MoreInfoURL(This,pbstrMoreInfoURL)	\
    ( (This)->lpVtbl -> get_MoreInfoURL(This,pbstrMoreInfoURL) ) 

#define IAMMediaContent_get_MoreInfoBannerImage(This,pbstrMoreInfoBannerImage)	\
    ( (This)->lpVtbl -> get_MoreInfoBannerImage(This,pbstrMoreInfoBannerImage) ) 

#define IAMMediaContent_get_MoreInfoBannerURL(This,pbstrMoreInfoBannerURL)	\
    ( (This)->lpVtbl -> get_MoreInfoBannerURL(This,pbstrMoreInfoBannerURL) ) 

#define IAMMediaContent_get_MoreInfoText(This,pbstrMoreInfoText)	\
    ( (This)->lpVtbl -> get_MoreInfoText(This,pbstrMoreInfoText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMMediaContent_INTERFACE_DEFINED__ */


#ifndef __IAMMediaContent2_INTERFACE_DEFINED__
#define __IAMMediaContent2_INTERFACE_DEFINED__

/* interface IAMMediaContent2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMMediaContent2,0x817FF170,0xC535,0x11d2,0x9C,0x67,0x00,0xA0,0xC9,0x8C,0x04,0x78);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("817FF170-C535-11d2-9C67-00A0C98C0478")
    IAMMediaContent2 : public IAMMediaContent
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MoreInfoBannerBitmap( 
            /* [retval][out] */ LONG *pMoreInfoBannerBitmap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMediaContent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMediaContent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMediaContent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMediaContent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMMediaContent2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMMediaContent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMMediaContent2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMMediaContent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuthorName )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrAuthorName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rating )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrRating);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrCopyright);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BaseURL )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrBaseURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogoURL )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrLogoURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogoIconURL )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrLogoURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WatermarkURL )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrWatermarkURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoURL )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrMoreInfoURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoBannerImage )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrMoreInfoBannerImage);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoBannerURL )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrMoreInfoBannerURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoText )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ BSTR *pbstrMoreInfoText);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreInfoBannerBitmap )( 
            IAMMediaContent2 * This,
            /* [retval][out] */ LONG *pMoreInfoBannerBitmap);
        
        END_INTERFACE
    } IAMMediaContent2Vtbl;

    interface IAMMediaContent2
    {
        CONST_VTBL struct IAMMediaContent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMediaContent2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMMediaContent2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMMediaContent2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMMediaContent2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMMediaContent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMMediaContent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMMediaContent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMMediaContent2_get_AuthorName(This,pbstrAuthorName)	\
    ( (This)->lpVtbl -> get_AuthorName(This,pbstrAuthorName) ) 

#define IAMMediaContent2_get_Title(This,pbstrTitle)	\
    ( (This)->lpVtbl -> get_Title(This,pbstrTitle) ) 

#define IAMMediaContent2_get_Rating(This,pbstrRating)	\
    ( (This)->lpVtbl -> get_Rating(This,pbstrRating) ) 

#define IAMMediaContent2_get_Description(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbstrDescription) ) 

#define IAMMediaContent2_get_Copyright(This,pbstrCopyright)	\
    ( (This)->lpVtbl -> get_Copyright(This,pbstrCopyright) ) 

#define IAMMediaContent2_get_BaseURL(This,pbstrBaseURL)	\
    ( (This)->lpVtbl -> get_BaseURL(This,pbstrBaseURL) ) 

#define IAMMediaContent2_get_LogoURL(This,pbstrLogoURL)	\
    ( (This)->lpVtbl -> get_LogoURL(This,pbstrLogoURL) ) 

#define IAMMediaContent2_get_LogoIconURL(This,pbstrLogoURL)	\
    ( (This)->lpVtbl -> get_LogoIconURL(This,pbstrLogoURL) ) 

#define IAMMediaContent2_get_WatermarkURL(This,pbstrWatermarkURL)	\
    ( (This)->lpVtbl -> get_WatermarkURL(This,pbstrWatermarkURL) ) 

#define IAMMediaContent2_get_MoreInfoURL(This,pbstrMoreInfoURL)	\
    ( (This)->lpVtbl -> get_MoreInfoURL(This,pbstrMoreInfoURL) ) 

#define IAMMediaContent2_get_MoreInfoBannerImage(This,pbstrMoreInfoBannerImage)	\
    ( (This)->lpVtbl -> get_MoreInfoBannerImage(This,pbstrMoreInfoBannerImage) ) 

#define IAMMediaContent2_get_MoreInfoBannerURL(This,pbstrMoreInfoBannerURL)	\
    ( (This)->lpVtbl -> get_MoreInfoBannerURL(This,pbstrMoreInfoBannerURL) ) 

#define IAMMediaContent2_get_MoreInfoText(This,pbstrMoreInfoText)	\
    ( (This)->lpVtbl -> get_MoreInfoText(This,pbstrMoreInfoText) ) 


#define IAMMediaContent2_get_MoreInfoBannerBitmap(This,pMoreInfoBannerBitmap)	\
    ( (This)->lpVtbl -> get_MoreInfoBannerBitmap(This,pMoreInfoBannerBitmap) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMMediaContent2_INTERFACE_DEFINED__ */


#ifndef __IAMMediaContentEx_INTERFACE_DEFINED__
#define __IAMMediaContentEx_INTERFACE_DEFINED__

/* interface IAMMediaContentEx */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMMediaContentEx,0xCE8F78C1,0x74D9,0x11d2,0xB0,0x9D,0x00,0xA0,0xC9,0xA8,0x11,0x17);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CE8F78C1-74D9-11d2-B09D-00A0C9A81117")
    IAMMediaContentEx : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MediaParameter( 
            /* [in] */ long EntryNum,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pbstrValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MediaParameterName( 
            /* [in] */ long EntryNum,
            /* [in] */ long Index,
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PlaylistCount( 
            /* [retval][out] */ long *pNumberEntries) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMediaContentExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMediaContentEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMediaContentEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMediaContentEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMMediaContentEx * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMMediaContentEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMMediaContentEx * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMMediaContentEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaParameter )( 
            IAMMediaContentEx * This,
            /* [in] */ long EntryNum,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ BSTR *pbstrValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaParameterName )( 
            IAMMediaContentEx * This,
            /* [in] */ long EntryNum,
            /* [in] */ long Index,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlaylistCount )( 
            IAMMediaContentEx * This,
            /* [retval][out] */ long *pNumberEntries);
        
        END_INTERFACE
    } IAMMediaContentExVtbl;

    interface IAMMediaContentEx
    {
        CONST_VTBL struct IAMMediaContentExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMediaContentEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMMediaContentEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMMediaContentEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMMediaContentEx_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMMediaContentEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMMediaContentEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMMediaContentEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMMediaContentEx_get_MediaParameter(This,EntryNum,bstrName,pbstrValue)	\
    ( (This)->lpVtbl -> get_MediaParameter(This,EntryNum,bstrName,pbstrValue) ) 

#define IAMMediaContentEx_get_MediaParameterName(This,EntryNum,Index,pbstrName)	\
    ( (This)->lpVtbl -> get_MediaParameterName(This,EntryNum,Index,pbstrName) ) 

#define IAMMediaContentEx_get_PlaylistCount(This,pNumberEntries)	\
    ( (This)->lpVtbl -> get_PlaylistCount(This,pNumberEntries) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMMediaContentEx_INTERFACE_DEFINED__ */


#ifndef __IAMNetShowPreroll_INTERFACE_DEFINED__
#define __IAMNetShowPreroll_INTERFACE_DEFINED__

/* interface IAMNetShowPreroll */
/* [object][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMNetShowPreroll,0xAAE7E4E2,0x6388,0x11D1,0x8D,0x93,0x00,0x60,0x97,0xC9,0xA2,0xB2);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AAE7E4E2-6388-11D1-8D93-006097C9A2B2")
    IAMNetShowPreroll : public IDispatch
    {
    public:
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Preroll( 
            /* [in] */ VARIANT_BOOL fPreroll) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Preroll( 
            /* [retval][out] */ VARIANT_BOOL *pfPreroll) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMNetShowPrerollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMNetShowPreroll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMNetShowPreroll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMNetShowPreroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAMNetShowPreroll * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAMNetShowPreroll * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAMNetShowPreroll * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAMNetShowPreroll * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Preroll )( 
            IAMNetShowPreroll * This,
            /* [in] */ VARIANT_BOOL fPreroll);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Preroll )( 
            IAMNetShowPreroll * This,
            /* [retval][out] */ VARIANT_BOOL *pfPreroll);
        
        END_INTERFACE
    } IAMNetShowPrerollVtbl;

    interface IAMNetShowPreroll
    {
        CONST_VTBL struct IAMNetShowPrerollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMNetShowPreroll_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMNetShowPreroll_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMNetShowPreroll_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMNetShowPreroll_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAMNetShowPreroll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAMNetShowPreroll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAMNetShowPreroll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAMNetShowPreroll_put_Preroll(This,fPreroll)	\
    ( (This)->lpVtbl -> put_Preroll(This,fPreroll) ) 

#define IAMNetShowPreroll_get_Preroll(This,pfPreroll)	\
    ( (This)->lpVtbl -> get_Preroll(This,pfPreroll) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMNetShowPreroll_INTERFACE_DEFINED__ */


#ifndef __IDShowPlugin_INTERFACE_DEFINED__
#define __IDShowPlugin_INTERFACE_DEFINED__

/* interface IDShowPlugin */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_IDShowPlugin,0x4746B7C8,0x700E,0x11d1,0xBE,0xCC,0x00,0xC0,0x4F,0xB6,0xE9,0x37);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4746B7C8-700E-11d1-BECC-00C04FB6E937")
    IDShowPlugin : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [retval][out] */ BSTR *pURL) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserAgent( 
            /* [retval][out] */ BSTR *pUserAgent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDShowPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDShowPlugin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDShowPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDShowPlugin * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IDShowPlugin * This,
            /* [retval][out] */ BSTR *pURL);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserAgent )( 
            IDShowPlugin * This,
            /* [retval][out] */ BSTR *pUserAgent);
        
        END_INTERFACE
    } IDShowPluginVtbl;

    interface IDShowPlugin
    {
        CONST_VTBL struct IDShowPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDShowPlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDShowPlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDShowPlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDShowPlugin_get_URL(This,pURL)	\
    ( (This)->lpVtbl -> get_URL(This,pURL) ) 

#define IDShowPlugin_get_UserAgent(This,pUserAgent)	\
    ( (This)->lpVtbl -> get_UserAgent(This,pUserAgent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDShowPlugin_INTERFACE_DEFINED__ */


#ifndef __IAMSecureMediaContent_INTERFACE_DEFINED__
#define __IAMSecureMediaContent_INTERFACE_DEFINED__

/* interface IAMSecureMediaContent */
/* [object][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IAMSecureMediaContent,0x36F0A694,0xC536,0x11d2,0x9C,0x67,0x00,0xA0,0xC9,0x8C,0x04,0x78);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36F0A694-C536-11d2-9C67-00A0C98C0478")
    IAMSecureMediaContent : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsSecure( 
            /* [retval][out] */ VARIANT_BOOL *pfIsSecure) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Tooltip( 
            /* [retval][out] */ BSTR *pbstrTooltip) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMSecureMediaContentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMSecureMediaContent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMSecureMediaContent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMSecureMediaContent * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSecure )( 
            IAMSecureMediaContent * This,
            /* [retval][out] */ VARIANT_BOOL *pfIsSecure);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tooltip )( 
            IAMSecureMediaContent * This,
            /* [retval][out] */ BSTR *pbstrTooltip);
        
        END_INTERFACE
    } IAMSecureMediaContentVtbl;

    interface IAMSecureMediaContent
    {
        CONST_VTBL struct IAMSecureMediaContentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMSecureMediaContent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMSecureMediaContent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMSecureMediaContent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMSecureMediaContent_get_IsSecure(This,pfIsSecure)	\
    ( (This)->lpVtbl -> get_IsSecure(This,pfIsSecure) ) 

#define IAMSecureMediaContent_get_Tooltip(This,pbstrTooltip)	\
    ( (This)->lpVtbl -> get_Tooltip(This,pbstrTooltip) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMSecureMediaContent_INTERFACE_DEFINED__ */

#endif /* __QuartzNetTypeLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\qos.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    qos.h - QoS definitions for NDIS components.

Abstract:

    This module defines the Quality of Service structures and types used
    by Winsock applications.

Revision History:

--*/

#pragma once

#ifndef __QOS_H_
#define __QOS_H_


/*
 *  Definitions for valued-based Service Type for each direction of data flow.
 */

typedef ULONG   SERVICETYPE;

#define SERVICETYPE_NOTRAFFIC               0x00000000  /* No data in this 
                                                         * direction */
#define SERVICETYPE_BESTEFFORT              0x00000001  /* Best Effort */
#define SERVICETYPE_CONTROLLEDLOAD          0x00000002  /* Controlled Load */
#define SERVICETYPE_GUARANTEED              0x00000003  /* Guaranteed */

#define SERVICETYPE_NETWORK_UNAVAILABLE     0x00000004  /* Used to notify 
                                                         * change to user */
#define SERVICETYPE_GENERAL_INFORMATION     0x00000005  /* corresponds to 
                                                         * "General Parameters"
                                                         * defined by IntServ */
#define SERVICETYPE_NOCHANGE                0x00000006  /* used to indicate
                                                         * that the flow spec
                                                         * contains no change
                                                         * from any previous
                                                         * one */
#define SERVICETYPE_NONCONFORMING           0x00000009  /* Non-Conforming Traffic */
#define SERVICETYPE_NETWORK_CONTROL         0x0000000A  /* Network Control traffic */
#define SERVICETYPE_QUALITATIVE             0x0000000D  /* Qualitative applications */ 



/*********  The usage of these is currently not supported.  ***************/
#define SERVICE_BESTEFFORT                  0x80010000
#define SERVICE_CONTROLLEDLOAD              0x80020000
#define SERVICE_GUARANTEED                  0x80040000
#define SERVICE_QUALITATIVE                 0x80200000
/* **************************** ***** ************************************ */



/*
 * Flags to control the usage of RSVP on this flow.
 */

/*
 * to turn off traffic control, 'OR' ( | ) this flag with the 
 * ServiceType field in the FLOWSPEC
 */
#define SERVICE_NO_TRAFFIC_CONTROL   0x81000000


/*
 * this flag can be used to prevent any rsvp signaling messages from being 
 * sent. Local traffic control will be invoked, but no RSVP Path messages 
 * will be sent.This flag can also be used in conjunction with a receiving 
 * flowspec to suppress the automatic generation of a Reserve message.  
 * The application would receive notification that a Path  message had arrived 
 * and would then need to alter the QOS by issuing WSAIoctl( SIO_SET_QOS ), 
 * to unset this flag and thereby causing Reserve messages to go out.
 */

#define SERVICE_NO_QOS_SIGNALING   0x40000000




/*
 *  Flow Specifications for each direction of data flow.
 */
typedef struct _flowspec
{
    ULONG       TokenRate;              /* In Bytes/sec */
    ULONG       TokenBucketSize;        /* In Bytes */
    ULONG       PeakBandwidth;          /* In Bytes/sec */
    ULONG       Latency;                /* In microseconds */
    ULONG       DelayVariation;         /* In microseconds */
    SERVICETYPE ServiceType;
    ULONG       MaxSduSize;             /* In Bytes */
    ULONG       MinimumPolicedSize;     /* In Bytes */

} FLOWSPEC, *PFLOWSPEC, * LPFLOWSPEC;

/*
 * this value can be used in the FLOWSPEC structure to instruct the Rsvp Service 
 * provider to derive the appropriate default value for the parameter.  Note 
 * that not all values in the FLOWSPEC structure can be defaults. In the
 * ReceivingFlowspec, all parameters can be defaulted except the ServiceType.  
 * In the SendingFlowspec, the MaxSduSize and MinimumPolicedSize can be
 * defaulted. Other defaults may be possible. Refer to the appropriate
 * documentation.
 */
#define QOS_NOT_SPECIFIED     0xFFFFFFFF

/*
 * define a value that can be used for the PeakBandwidth, which will map into 
 * positive infinity when the FLOWSPEC is converted into IntServ floating point 
 * format.  We can't use (-1) because that value was previously defined to mean
 * "select the default".
 */
#define   POSITIVE_INFINITY_RATE     0xFFFFFFFE



/*
 * the provider specific structure can have a number of objects in it.
 * Each next structure in the
 * ProviderSpecific will be the QOS_OBJECT_HDR struct that prefaces the actual
 * data with a type and length for that object.  This QOS_OBJECT struct can 
 * repeat several times if there are several objects.  This list of objects
 * terminates either when the buffer length has been reached ( WSABUF ) or
 * an object of type QOS_END_OF_LIST is encountered.
 */
typedef struct  {

    ULONG   ObjectType;
    ULONG   ObjectLength;  /* the length of object buffer INCLUDING 
                            * this header */

} QOS_OBJECT_HDR, *LPQOS_OBJECT_HDR;


/*
 * general QOS objects start at this offset from the base and have a range 
 * of 1000
 */
#define   QOS_GENERAL_ID_BASE                      2000

#define   QOS_OBJECT_END_OF_LIST                   (0x00000001 + QOS_GENERAL_ID_BASE) 
          /* QOS_End_of_list structure passed */
#define   QOS_OBJECT_SD_MODE                       (0x00000002 + QOS_GENERAL_ID_BASE) 
          /* QOS_ShapeDiscard structure passed */
#define   QOS_OBJECT_SHAPING_RATE	           (0x00000003 + QOS_GENERAL_ID_BASE)
          /* QOS_ShapingRate structure */
#define   QOS_OBJECT_DESTADDR                      (0x00000004 + QOS_GENERAL_ID_BASE)
          /* QOS_DestAddr structure (defined in qossp.h) */


/*
 * This structure is used to define the behaviour that the traffic
 * control packet shaper will apply to the flow.
 *
 * TC_NONCONF_BORROW - the flow will receive resources remaining 
 *  after all higher priority flows have been serviced. If a 
 *  TokenRate is specified, packets may be non-conforming and
 *  will be demoted to less than best-effort priority.
 *  
 * TC_NONCONF_SHAPE - TokenRate must be specified. Non-conforming
 *  packets will be retianed in the packet shaper until they become
 *  conforming.
 *
 * TC_NONCONF_DISCARD - TokenRate must be specified. Non-conforming
 *  packets will be discarded.
 *
 */

typedef struct _QOS_SD_MODE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapeDiscardMode;

} QOS_SD_MODE, *LPQOS_SD_MODE;

#define TC_NONCONF_BORROW      0
#define TC_NONCONF_SHAPE       1
#define TC_NONCONF_DISCARD     2
#define TC_NONCONF_BORROW_PLUS 3 // Not supported currently


/*
 * This structure allows an app to specify a prorated "average token rate" using by
 * the traffic shaper under SHAPE modehaper queue. It is expressed in bytes per sec.
 *
 * ShapingRate (bytes per sec.)
 *
 */

typedef struct _QOS_SHAPING_RATE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapingRate;

} QOS_SHAPING_RATE, *LPQOS_SHAPING_RATE;


#endif  /* __QOS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ras.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:

ras.h

Abstract:

Remote Access Service structures and defines

Notes: 

--*/

// @CESYSGEN IF CE_MODULES_PPP
#ifndef _RAS_H_
#define _RAS_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif
#include <tapi.h>

#include "pshpack4.h"

#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     128
#define RAS_MaxDeviceType     16
#define RAS_MaxParamKey       32
#define RAS_MaxParamValue     128
#define RAS_MaxPhoneNumber    128
#define RAS_MaxCallbackNumber 48
#define RAS_MaxIpAddress      15
#define RAS_MaxIpxAddress     21

// Ras extensions

#define RAS_MaxAreaCode         (10)
#define RAS_MaxPadType          (32)
#define RAS_MaxX25Address       (200)
#define RAS_MaxFacilities       (200)
#define RAS_MaxUserData         (200)

// RAS IP Address

typedef struct  tagRasIpAddr
{
    BYTE    a;
    BYTE    b;
    BYTE    c;
    BYTE    d;
}
RASIPADDR;

// RAS Entry Definition

#define RASENTRYW struct tagRASENTRYW
RASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    WCHAR       szScript[ MAX_PATH ];
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    DWORD       dwReserved1;
    DWORD       dwReserved2;

    DWORD       dwCustomAuthKey; // EAP extension type to use
};

#define RASENTRY RASENTRYW

#define LPRASENTRYW RASENTRYW*
#define LPRASENTRY  RASENTRY*

/* Describes Country Information
*/
#define RASCTRYINFO struct RASCTRYINFO
RASCTRYINFO
{
    DWORD       dwSize;
    DWORD       dwCountryID;
    DWORD       dwNextCountryID;
    DWORD       dwCountryCode;
    DWORD       dwCountryNameOffset;
};
typedef RASCTRYINFO * LPRASCTRYINFO;

#define RASCTRYINFOW   RASCTRYINFO
#define LPRASCTRYINFOW RASCTRYINFOW*
#define LPRASCTRYINFO  RASCTRYINFO*

/* Describes RAS Device Information
*/
#define RASDEVINFOW struct tagRASDEVINFOW
RASDEVINFOW
{
    DWORD       dwSize;
    WCHAR       szDeviceType[RAS_MaxDeviceType+1];
    WCHAR       szDeviceName[RAS_MaxDeviceName+1];
};

typedef RASDEVINFOW * LPRASDEVINFOW;

#define RASDEVINFO      RASDEVINFOW
#define LPRASDEVINFOW   RASDEVINFOW*
#define LPRASDEVINFO    RASDEVINFO*

/* RASENTRY 'dwfOptions' bit flags.
*/
#define RASEO_UseCountryAndAreaCodes  0x00000001
#define RASEO_SpecificIpAddr          0x00000002
#define RASEO_SpecificNameServers     0x00000004
#define RASEO_IpHeaderCompression     0x00000008
#define RASEO_RemoteDefaultGateway    0x00000010
#define RASEO_DisableLcpExtensions    0x00000020
#define RASEO_TerminalBeforeDial      0x00000040
#define RASEO_TerminalAfterDial       0x00000080
#define RASEO_ModemLights             0x00000100
#define RASEO_SwCompression           0x00000200
#define RASEO_RequireEncryptedPw      0x00000400
#define RASEO_RequireMsEncryptedPw    0x00000800
#define RASEO_RequireDataEncryption   0x00001000
#define RASEO_NetworkLogon            0x00002000
#define RASEO_UseLogonCredentials     0x00004000
#define RASEO_PromoteAlternates       0x00008000
#define RASEO_SecureLocalFiles        0x00010000
#define RASEO_DialAsLocalCall         0x00020000

#define RASEO_ProhibitPAP             0x00040000
#define RASEO_ProhibitCHAP            0x00080000
#define RASEO_ProhibitMsCHAP          0x00100000
#define RASEO_ProhibitMsCHAP2         0x00200000
#define RASEO_ProhibitEAP             0x00400000
#define RASEO_PreviewUserPw           0x01000000
#define RASEO_NoUserPwRetryDialog     0x02000000
#define RASEO_CustomScript            0x80000000


/* RASENTRY 'dwfNetProtocols' bit flags. (session negotiated protocols)
*/
#define RASNP_NetBEUI       0x00000001  // Negotiate NetBEUI
#define RASNP_Ipx           0x00000002  // Negotiate IPX
#define RASNP_Ip            0x00000004  // Negotiate TCP/IP


/* RASENTRY 'dwFramingProtocols' (framing protocols used by the server)
*/
#define RASFP_Ppp           0x00000001  // Point-to-Point Protocol (PPP)
#define RASFP_Slip          0x00000002  // Serial Line Internet Protocol (SLIP)
#define RASFP_Ras           0x00000004  // Microsoft proprietary protocol


/* RASENTRY 'szDeviceType' strings
*/
#define RASDT_Direct        TEXT("direct")    // Direct Connect (WINCE Extension)
#define RASDT_Modem         TEXT("modem")     // Modem
#define RASDT_Isdn          TEXT("isdn")      // ISDN
#define RASDT_X25           TEXT("x25")       // X.25
#define RASDT_Vpn           TEXT("vpn")       // PPTP
#define RASDT_PPPoE         TEXT("PPPoE")     // PPPoE


DECLARE_HANDLE( HRASCONN );
typedef HRASCONN *LPHRASCONN;

// Identifies an active RAS connection.  (See RasEnumConnections)

#define RASCONNW struct tagRASCONNW
RASCONNW
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
};

#define RASCONN RASCONNW

#define LPRASCONNW RASCONNW*
#define LPRASCONN  RASCONN*


// Enumerates intermediate states to a connection.  (See RasDial)

#define RASCS_PAUSED 0x1000
#define RASCS_DONE   0x2000

typedef enum tagRASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,
    RASCS_Projected,

    RASCS_Interactive           = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,

    RASCS_Connected             = RASCS_DONE,
    RASCS_Disconnected
} 
RASCONNSTATE, *LPRASCONNSTATE;


// Describes the status of a RAS connection.  (See RasConnectionStatus)

#define RASCONNSTATUSW struct tagRASCONNSTATUSW
RASCONNSTATUSW
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASCONNSTATUS RASCONNSTATUSW

#define LPRASCONNSTATUSW RASCONNSTATUSW*
#define LPRASCONNSTATUS  RASCONNSTATUS*

// Describes connection establishment parameters.  (See RasDial)

#define RASDIALPARAMSW struct tagRASDIALPARAMSW
RASDIALPARAMSW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#define RASDIALPARAMS RASDIALPARAMSW

#define LPRASDIALPARAMSW RASDIALPARAMSW*
#define LPRASDIALPARAMS  RASDIALPARAMS*

// Describes extended connection establishment options.  (See RasDial)

#define RASDIALEXTENSIONS struct tagRASDIALEXTENSIONS
RASDIALEXTENSIONS
{
    DWORD dwSize;
    DWORD dwfOptions;
    HWND  hwndParent;
    DWORD reserved;
};

#define LPRASDIALEXTENSIONS RASDIALEXTENSIONS*

// 'dwfOptions' bit flags.

#define RDEOPT_UsePrefixSuffix           0x00000001
#define RDEOPT_PausedStates              0x00000002
#define RDEOPT_IgnoreModemSpeaker        0x00000004
#define RDEOPT_SetModemSpeaker           0x00000008
#define RDEOPT_IgnoreSoftwareCompression 0x00000010
#define RDEOPT_SetSoftwareCompression    0x00000020


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW struct tagRASENTRYNAMEW
RASENTRYNAMEW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
};

#define RASENTRYNAME RASENTRYNAMEW

#define LPRASENTRYNAMEW RASENTRYNAMEW*
#define LPRASENTRYNAME  RASENTRYNAME*

//
// Custom Script Dll Support
//
typedef struct tagRASCOMMSETTINGS {
  DWORD   dwSize;
  BYTE    bParity;
  BYTE    bStop;
  WORD    wAlign;
} RASCOMMSETTINGS;

typedef DWORD (APIENTRY *PFNRASSETCOMMSETTINGS) (
  HANDLE    hPort,
  RASCOMMSETTINGS    * pRasCommSettings,
  PVOID    pvReserved
);

typedef struct RASCUSTOMSCRIPTEXTENSIONS {
  DWORD dwSize;
  PFNRASSETCOMMSETTINGS   pfRasSetCommSettings;
} RASCUSTOMSCRIPTEXTENSIONS;

typedef DWORD (APIENTRY *PFNRASGETBUFFER) (
  PBYTE *   ppBuffer,
  PDWORD    pdwSize
);

typedef DWORD (APIENTRY *PFNRASFREEBUFFER) (
  PBYTE    pBuffer
);

typedef DWORD (APIENTRY *PFNRASSENDBUFFER) (
  HANDLE    hPort,
  PBYTE     pBuffer,
  DWORD     dwSize
);

typedef DWORD (APIENTRY *PFNRASRECEIVEBUFFER) (
  HANDLE    hPort,
  PBYTE     pBuffer,
  PDWORD    pdwSize,
  DWORD     dwTimeoutMilliseconds,
  HANDLE    hEvent
);

typedef DWORD (APIENTRY *PFNRASRETRIEVEBUFFER ) (
  HANDLE    hPort,
  PBYTE    pBuffer,
  PDWORD   pdwSize
);

// Protocol code to projection data structure mapping.

typedef enum tagRASPROJECTION
{
    RASP_Amb = 0x10000,
    RASP_PppNbf = 0x803F,
    RASP_PppIpx = 0x802B,
    RASP_PppIp = 0x8021,
    RASP_PppIpV6 = 0x8057,
    RASP_PppLcp = 0xC021,
    RASP_Slip = 0x20000
}
RASPROJECTION, *LPRASPROJECTION;

/* 
** Describes the result of a RAS AMB (Authentication Message Block)
** projection.  This protocol is used with NT 3.1 and OS/2 1.3 downlevel
** RAS servers.
*/

typedef struct tagRASAMBA
{
    DWORD dwSize;
    DWORD dwError;
    TCHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
} 
RASAMB, *LPRASAMB;

// Describes the result of a PPP NBF (NetBEUI) projection.

typedef struct tagRASPPPNBFW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    TCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    TCHAR szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
} 
RASPPPNBF, *LPRASPPPNBF;


// Describes the results of a PPP IPX (Internetwork Packet Exchange)
// projection.

typedef struct tagRASIPX
{
    DWORD dwSize;
    DWORD dwError;
    TCHAR szIpxAddress[ RAS_MaxIpxAddress + 1 ];
} 
RASPPPIPX, *LPRASPPPIPX;

// Describes the results of an PPP IP (Internet) projection.

#define RASPPPIPW struct tagRASPPPIPW
RASPPPIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];
    DWORD dwOptions;
    DWORD dwServerOptions;
};

#define RASPPPIP RASPPPIPW

#define LPRASPPPIPW RASPPPIPW*
#define LPRASPPPIP  RASPPPIP*

//
// RASPPPIP 'dwOptions' and 'dwServerOptions' flags.
//
#define RASIPO_VJ       0x00000001      // Indicates that VJ compression is on

// Describes the results of an PPP IPV6 (Internet) projection.

#define RASPPPIPV6 struct tagRASPPPIPV6
RASPPPIPV6
{
    DWORD dwSize;
    DWORD dwError;
    BYTE  LocalInterfaceIdentifier[8];
    BYTE  PeerInterfaceIdentifier[8];
    BYTE  LocalCompressionProtocol[2];
    BYTE  PeerCompressionProtocol[2];
};

#define LPRASPPPIPV6 RASPPPIPV6*

// Describes results of a GET_WINS/DNS I/O control. If
// the requested address has been negotiated the boolean
// valid is TRUE and the IpAddress contains the address of
// the requested server.  If Valid is false IpAddress is
// zero.

typedef struct  tagRASPPPAddr
{
    DWORD   dwSize;
    DWORD   dwError;
    BOOL    Valid;
    DWORD   IpAddress;
}
RASPPPADDR;

/* Describes the results of a SLIP (Serial Line IP) projection.
*/
#define RASSLIPW struct tagRASSLIPW
RASSLIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#define RASSLIP RASSLIPW

#define LPRASSLIPW RASSLIPW*
#define LPRASSLIP  RASSLIP*


//  RAS Control Structures
//
//  Control Request Enumeration

typedef enum    tagRasCntlEnum
{
                                                //                                                 pBufIn                 pBufOut
    RASCNTL_SET_DEBUG,                          // obsolete
    RASCNTL_LOCK_STATUS,                        // obsolete
    RASCNTL_PRINT_CS,                           // obsolete
    RASCNTL_STATISTICS,                         // Get statistics
    RASCNTL_ENUMDEV,                            // Enum Devices
    RASCNTL_GETPROJINFO,                        // RasGetProjectionInfoW
    RASCNTL_GETDISPPHONE,                       // RasGetDispPhoneNumW
    RASCNTL_DEVCONFIGDIALOGEDIT,                // RasDevConfigDialogEditW
    RASCNTL_SERVER_GET_STATUS,                  // Get status of PPP server and lines               NULL                   RASCNTL_SERVERSTATUS + dwNumLines * RASCNTL_SERVERLINE
    RASCNTL_SERVER_ENABLE,                      // Turn the PPP server on                           NULL                   NULL
    RASCNTL_SERVER_DISABLE,                     // Turn the PPP server off                          NULL                   NULL
    RASCNTL_SERVER_GET_PARAMETERS,              // Get global server parameters                     NULL                   RASCNTL_SERVERSTATUS
    RASCNTL_SERVER_SET_PARAMETERS,              // Set global server parameters                     RASCNTL_SERVERSTATUS   NULL
    RASCNTL_SERVER_LINE_ADD,                    // Add a line to be managed by the PPP server       RASCNTL_SERVERLINE     NULL
    RASCNTL_SERVER_LINE_REMOVE,                 // Remove a line being managed by the PPP server    RASCNTL_SERVERLINE     NULL
    RASCNTL_SERVER_LINE_ENABLE,                 // Enable management of a line                      RASCNTL_SERVERLINE     NULL
    RASCNTL_SERVER_LINE_DISABLE,                // Disable management of a line                     RASCNTL_SERVERLINE     NULL
    RASCNTL_SERVER_LINE_GET_PARAMETERS,         // Get line parameters                              RASCNTL_SERVERLINE     RASCNTL_SERVERLINE
    RASCNTL_SERVER_LINE_SET_PARAMETERS,         // Set line parameters                              RASCNTL_SERVERLINE     NULL
    RASCNTL_SERVER_USER_SET_CREDENTIALS,        // Allow a username/password                        RASCNTL_SERVERUSERCREDENTIALS NULL
    RASCNTL_SERVER_USER_DELETE_CREDENTIALS,     // Remove a username                                RASCNTL_SERVERUSERCREDENTIALS NULL
    RASCNTL_EAP_GET_USER_DATA,                  // Get a ras entry's EAP user data
    RASCNTL_EAP_SET_USER_DATA,                  // Set a ras entry's EAP user data
    RASCNTL_EAP_GET_CONNECTION_DATA,            // Get a ras entry's EAP conn data
    RASCNTL_EAP_SET_CONNECTION_DATA,            // Set a ras entry's EAP conn data
    RASCNTL_ENABLE_LOGGING,                     // Load logging extension dll if present
    RASCNTL_DISABLE_LOGGING,                    // Unload logging extension dll if loaded, stop logging
    RASCNTL_SERVER_LINE_GET_CONNECTION_INFO,    // Get state info on a server lines                 RASCNTL_SERVERLINE               RASCNTL_SERVERCONNECTION
    RASCNTL_SERVER_GET_IPV6_NET_PREFIX,         // Get IPV6 Network prefix pool                     NULL                             RASCNTL_SERVER_IPV6_NET_PREFIX
    RASCNTL_SERVER_SET_IPV6_NET_PREFIX,         // Set IPV6 Network prefix pool                     PRASCNTL_SERVER_IPV6_NET_PREFIX  NULL
    RASCNTL_LAYER_OPEN,                         // Open LCP/Auth/CCP/IPCP                           DWORD (Layer Id)                 NULL
    RASCNTL_LAYER_CLOSE,                        // Close LCP/Auth/CCP/IPCP                          DWORD (Layer Id)                 NULL
    RASCNTL_LAYER_RENEGOTIATE,                  // Renegotiate LCP/Auth/CCP/IPCP                    DWORD (Layer Id)                 NULL
    RASCNTL_LAYER_PARAMETER_GET,                // Get LCP/Auth/CCP/IPCP value                      RASCNTL_LAYER_PARAMETER          RASCNTL_LAYER_PARAMETER
    RASCNTL_LAYER_PARAMETER_SET,                // Set LCP/Auth/CCP/IPCP value                      RASCNTL_LAYER_PARAMETER          NULL
    // Add others here
}
RasCntlEnum_t;

typedef struct _RASCNTL_LAYER_PARAMETER
{
    DWORD dwProtocolType;
    DWORD dwParameterId;
    DWORD dwValueType;
#define RASCNTL_LAYER_PARAMETER_TYPE_NONE   0
#define RASCNTL_LAYER_PARAMETER_TYPE_DWORD  1
#define RASCNTL_LAYER_PARAMETER_TYPE_BYTES  2
    DWORD dwValueSize;
#pragma warning( push )
#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union
    union
    {
        DWORD dwValue;       // for most (simple integer) values
        BYTE  bytesValue[1]; // array of bytes (size 1 is placeholder)
    };
#pragma warning( pop )
} RASCNTL_LAYER_PARAMETER, *PRASCNTL_LAYER_PARAMETER;

typedef struct tagRasCntlDevConfigDlgEdit
{
    WCHAR   szDeviceName[RAS_MaxDeviceName + 1];
    WCHAR   szDeviceType[RAS_MaxDeviceType + 1];
    HWND    hWndOwner;
    DWORD   dwSize;
    BYTE    DataBuf[1];
} RASCNTL_DEVCFGDLGED, *PRASCNTL_DEVCFGDLGED;

#define MAX_IF_NAME_LEN 256

//
//  RASCNTL_SERVERSTATUS is...
//
//  ..Returned by:
//      RASCNTL_SERVER_GET_STATUS
//      RASCNTL_SERVER_GET_PARAMETERS
//  ..Passed to:
//      RASCNTL_SERVER_SET_PARAMETERS
//
typedef struct tagRasCntlServerStatus
{
    BOOL    bEnable;
    DWORD   bmFlags;
#define PPPSRV_FLAG_REQUIRE_DATA_ENCRYPTION         (1<<1)  // Require encryption on this connection.
#define PPPSRV_FLAG_ALLOW_UNAUTHENTICATED_ACCESS    (1<<2)  // Do not require authentication on the connection
#define PPPSRV_FLAG_NO_VJ_HEADER_COMPRESSION        (1<<3)  // Prevent VJ TCP/IP header compression
#define PPPSRV_FLAG_NO_DATA_COMPRESSION             (1<<4)  // Prevent MS data compression
#define PPPSRV_FLAG_ADD_CLIENT_SUBNET               (1<<5)  // Add a subnet route for a client connection

    BOOL    bUseDhcpAddresses;      // Obtain addresses from DHCP server rather than static pool
    DWORD   dwStaticIpAddrStart;    // If using static IP address pool, this is the first address
    DWORD   dwStaticIpAddrCount;    // Number of static IP addresses following IpAddrStart in pool
    DWORD   bmAuthenticationMethods;// Bitmask of authentication methods to be disallowed, see
                                    // RASEO_ProhibitXxx in ras.h

    DWORD   dwNumLines;

    BOOL    bUseAutoIpAddresses;    // TRUE if IP addresses for clients should be generated from AutoIp pool
    DWORD   dwAutoIpSubnet;         // Defines AutoIP address pool
    DWORD   dwAutoIpSubnetMask;             

    WCHAR   wszDhcpInterface[MAX_IF_NAME_LEN+1];
} RASCNTL_SERVERSTATUS, *PRASCNTL_SERVERSTATUS;

//
//  Structure passed to the following IOCTLs
//       RASCNTL_SERVER_LINE_GET_PARAMETERS
//       RASCNTL_SERVER_LINE_SET_PARAMETERS
//       RASCNTL_SERVER_LINE_ENABLE
//       RASCNTL_SERVER_LINE_DISABLE
//
typedef struct tagRasCntlServerLine
{
    RASDEVINFO  rasDevInfo;             // szDeviceType and szDeviceName of the line
    BOOL        bEnable;
    DWORD       bmFlags;
    UINT        DisconnectIdleSeconds;
    DWORD       dwDevConfigSize;
    BYTE        DevConfig[1];           // Variable size (dwDevConfigSize bytes) array of device config info
} RASCNTL_SERVERLINE, *PRASCNTL_SERVERLINE;

//
//  Structure passed to the following IOCTLs
//      RASCNTL_SERVER_USER_SET_CREDENTIALS          Allow a username/password
//      RASCNTL_SERVER_USER_DELETE_CREDENTIALS       Remove a username
//
typedef struct tagRasCntlServerUser
{
    TCHAR       tszUserName[UNLEN + 1];
    TCHAR       tszDomainName[DNLEN + 1];           // may be null
    BYTE        password[PWLEN];
    DWORD       cbPassword;
} RASCNTL_SERVERUSERCREDENTIALS, *PRASCNTL_SERVERUSERCREDENTIALS;

//
//  Structure containing info describing an enabled line's connection status
//
//  Used with the IOCTLS:
//      RASCNTL_SERVER_LINE_GET_CONNECTION_INFO
//
typedef struct tagRasCntlServerConnection
{
    RASDEVINFO   rasDevInfo;                         // szDeviceType and szDeviceName of the line
    HRASCONN     hrasconn;                           // handle that can be used in RasGetLinkStatistics (NULL if line is not enabled)
    DWORD        dwServerIpAddress;                  // IP Address for server line IP interface
    DWORD        dwClientIpAddress;                  // IP Address that will be assigned to client connecting to this line
    RASCONNSTATE RasConnState;                       // RASCS_Disconnected, etc.
    TCHAR        tszUserName[DNLEN + 1 + UNLEN + 1]; // Name of user logged in to the port
} RASCNTL_SERVERCONNECTION, *PRASCNTL_SERVERCONNECTION;

//
//  Structure containing info describing the pool of IPV6 network prefixes that
//  can be assigned by the server.
//  Used with the IOCTLS:
//      RASCNTL_SERVER_GET_IPV6_NET_PREFIX
//      RASCNTL_SERVER_SET_IPV6_NET_PREFIX
//
typedef struct tagRasCntlServerIPV6NetPrefix
{
    BYTE         IPV6NetPrefix[16];
    DWORD        IPV6NetPrefixBitLength;
    DWORD        IPV6NetPrefixCount;
} RASCNTL_SERVER_IPV6_NET_PREFIX, *PRASCNTL_SERVER_IPV6_NET_PREFIX;

// 
// RasDial message notifications are sent with Message ID set to
// WM_RASDIALEVENT
//

#define RASDIALEVENT        "RasDialEvent"

#define WM_RASDIALEVENT     0xCCCD


typedef struct _RAS_STATS
{
    DWORD   dwSize;
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwCompressionRatioIn;
    DWORD   dwCompressionRatioOut;
    DWORD   dwBps;
    DWORD   dwConnectDuration;

} RAS_STATS, *PRAS_STATS;


#ifdef UNDER_CE

// This structure is used by the RnaApp application on WINCE
// to signal when a connection has occured.

typedef struct tagRNAAppInfo {
    DWORD   dwSize;                 // The size of this structure
    DWORD   hWndRNAApp;             // The handle of the RNAApp window
    DWORD   Context;                // Context value specified on CmdLine
    DWORD   ErrorCode;              // Last error code
    TCHAR   RasEntryName[RAS_MaxEntryName+1];
} RNAAPP_INFO, *PRNAAPP_INFO;


#define RNA_RASCMD      WM_USER+1
#define RNA_ADDREF      1
#define RNA_DELREF      2
#endif

#include "poppack.h"

#ifndef RASAPI
#define RASAPI
#endif

DWORD RASAPI RasDial (LPRASDIALEXTENSIONS dialExtensions,
           LPCTSTR phoneBookPath,
           LPRASDIALPARAMS rasDialParam,
           DWORD NotifierType,
           LPVOID notifier,
           LPHRASCONN pRasConn);
#define RasDialW RasDial

DWORD RASAPI RasHangUp (HRASCONN Session);
#define RasHangUpW RasHangUp

DWORD RASAPI RasEnumEntries (LPCWSTR Reserved,
              LPCWSTR lpszPhoneBookPath,
              LPRASENTRYNAME lprasentryname,
              LPDWORD lpcb,
              LPDWORD lpcEntries);
#define RasEnumEntriesW RasEnumEntries

DWORD RASAPI RasGetEntryDialParams (LPWSTR lpszPhoneBook,
                 LPRASDIALPARAMS lpRasDialParams,   
                 LPBOOL lpfPassword);
#define RasGetEntryDialParamsW RasGetEntryDialParams

DWORD RASAPI RasSetEntryDialParams (LPCWSTR lpszPhoneBook,
                 LPRASDIALPARAMS lpRasDialParams,
                 BOOL fRemovePassword);
#define RasSetEntryDialParamsW RasSetEntryDialParams

DWORD RASAPI RasGetEntryProperties (LPCWSTR lpszPhoneBook,
                 LPCWSTR szEntry,
                 LPRASENTRY lpEntry,
                 LPDWORD lpdwEntrySize,
                 LPBYTE lpb,
                 LPDWORD lpdwSize);
#define RasGetEntryPropertiesW RasGetEntryProperties

DWORD RASAPI RasSetEntryProperties (LPCWSTR lpszPhoneBook,      
                 LPCWSTR szEntry,
                 LPRASENTRY lpEntry,
                 DWORD dwEntrySize,
                 LPBYTE lpb,
                 DWORD dwSize);
#define RasSetEntryPropertiesW RasSetEntryProperties

DWORD RASAPI RasValidateEntryName (LPCWSTR lpszPhonebook,       
                LPCWSTR lpszEntry);
#define RasValidateEntryNameW RasValidateEntryName

DWORD RASAPI RasDeleteEntry (LPCWSTR lpszPhonebook,
              LPCWSTR lpszEntry);
#define RasDeleteEntryW RasDeleteEntry

DWORD RASAPI RasRenameEntry (LPCWSTR lpszPhonebook,
              LPCWSTR lpszOldEntry,
              LPCWSTR lpszNewEntry);
#define RasRenameEntryW RasRenameEntry

DWORD RASAPI RasEnumConnections (__out_bcount(*lpcb) LPRASCONN lprasconn,
              LPDWORD lpcb,
              LPDWORD lpcConnections);
#define RasEnumConnectionsW RasEnumConnections

DWORD RASAPI RasGetConnectStatus (HRASCONN rasconn,             
               LPRASCONNSTATUS lprasconnstatus);
#define RasGetConnectStatusW    RasGetConnectStatus

DWORD RASAPI RasGetEntryDevConfig (LPCTSTR szPhonebook,
                LPCTSTR szEntry,
                LPDWORD pdwDeviceID,
                LPDWORD pdwSize,
                LPVARSTRING pDeviceConfig);
#define RasGetEntryDevConfigW RasGetEntryDevConfig

DWORD RASAPI RasSetEntryDevConfig (LPCTSTR szPhonebook,
                LPCTSTR szEntry,
                DWORD dwDeviceID,
                LPVARSTRING lpDeviceConfig);
#define RasSetEntryDevConfigW RasSetEntryDevConfig


DWORD APIENTRY RasEnumDevicesW( LPRASDEVINFOW, LPDWORD, LPDWORD );
#define RasEnumDevices          RasEnumDevicesW

DWORD APIENTRY RasGetProjectionInfoW( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );
#define RasGetProjectionInfo    RasGetProjectionInfoW

DWORD APIENTRY RasGetLinkStatistics(HRASCONN hRasConn,
                                    DWORD dwSubEntry,
                                    RAS_STATS *lpStatistics);

DWORD APIENTRY RasGetDispPhoneNumW(LPCWSTR szPhonebook,
                                   LPCWSTR szEntry,
                                   LPWSTR szPhoneNum,
                                   DWORD dwPhoneNumLen);
#define RasGetDispPhoneNum  RasGetDispPhoneNumW

DWORD APIENTRY RasDevConfigDialogEditW (LPCWSTR szDeviceName, LPCWSTR szDeviceType,
                                        HWND hWndOwner, LPVOID lpDeviceConfigIn,
                                        DWORD dwSize, LPVARSTRING lpDeviceConfigOut);
#define RasDevConfigDialogEdit RasDevConfigDialogEditW

DWORD APIENTRY RasIOControl(LPVOID hRasConn, DWORD dwCode, PBYTE pBufIn,
                            DWORD dwLenIn, PBYTE pBufOut, DWORD dwLenOut,
                            PDWORD pdwActualOut);

DWORD
RasGetEapUserData (
    IN      HANDLE  hToken,           // access token for user 
    IN      LPCTSTR pszPhonebook,     // path to phone book to use 
    IN      LPCTSTR pszEntry,         // name of entry in phone book 
    OUT     PBYTE   pbEapData,        // retrieved data for the user 
    IN  OUT PDWORD  pdwSizeofEapData);// size of retrieved data 

DWORD
RasSetEapUserData(
    IN  HANDLE  hToken,           // access token for user
    IN  LPCTSTR pszPhonebook,     // path to phone book to use
    IN  LPCTSTR pszEntry,         // name of entry in phone book
    IN  PBYTE   pbEapData,        // data to store for the user
    IN  DWORD   dwSizeofEapData); // size of data

DWORD
RasGetEapConnectionData (
    IN      LPCTSTR pszPhonebook,     // path to phone book to use 
    IN      LPCTSTR pszEntry,         // name of entry in phone book 
    OUT     PBYTE   pbEapData,        // retrieved data for the user 
    IN  OUT PDWORD  pdwSizeofEapData);// size of retrieved data 

DWORD
RasSetEapConnectionData(
    IN  LPCTSTR pszPhonebook,    // path to phone book to use
    IN  LPCTSTR pszEntry,        // name of entry in phone book
    IN  PBYTE   pbEapData,       // data to store for the connection
    IN  DWORD   dwSizeofEapData);// size of data

#ifdef __cplusplus
}
#endif


#ifdef WINCEOEM
#include <pras.h>   // internal defines 
#endif

#endif // _RAS_H_

// @CESYSGEN ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rcdef.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*


Module Name: RCDef.h

--*/
#ifndef __RCDEF_H__
#define __RCDEF_H__

#pragma warning(disable:4005)

#include <commctrl.h>

#define DIALOGEX        DIALOG DISCARDABLE
#define SHMENUBAR       RCDATA

#ifndef I_IMAGENONE
#define I_IMAGENONE     (-2)
#endif

#define NOMENU          0xFFFF

#define  IDS_SHNEW            1                
#define  IDM_SHAREDNEW        10                  
#define  IDM_SHAREDNEWDEFAULT 11                  

#define  IDC_CMDBAR           0xE408              
#define  IDC_CMDBAR_COMBOBOX  0xE409              
#define  AFX_ID_DOCLIST       0xE40A              

#ifndef IDC_STATIC
#define IDC_STATIC      (-1)
#endif

// Animate control
#ifndef ACS_AUTOPLAY
#define  ACS_AUTOPLAY         0x0004              
#endif
#ifndef ACS_CENTER
#define  ACS_CENTER           0x0001              
#endif
#ifndef ACS_TRANSPARENT
#define  ACS_TRANSPARENT      0x0002              
#endif

// Button styles
#define  BS_BITMAP            0x00000080L         
#define  BS_FLAT              0x00008000L         
#define  BS_ICON              0x00000040L         
#define  BS_USERBUTTON        0x00000008L         

// Combo-box styles
#define  CBS_OWNERDRAWFIXED   0x0010L             
#define  CBS_OWNERDRAWVARIABLE 0x0020L             
#define  CBS_SIMPLE           0x0001L             

// COMMON CONTROL STYLES
#ifndef CCS_ADJUSTABLE
#define  CCS_ADJUSTABLE       0x00000020L         
#endif
#ifndef CCS_BOTTOM
#define  CCS_BOTTOM           0x00000003L         
#endif
#ifndef CCS_NODIVIDER
#define  CCS_NODIVIDER        0x00000040L         
#endif
#ifndef CCS_NOHILITE
#define  CCS_NOHILITE         0x00000010L         
#endif
#ifndef CCS_NOMOVEY
#define  CCS_NOMOVEY          0x00000002L         
#endif
#ifndef CCS_NOPARENTALIGN
#define  CCS_NOPARENTALIGN    0x00000008L         
#endif
#ifndef CCS_NORESIZE
#define  CCS_NORESIZE         0x00000004L         
#endif
#ifndef CCS_TOP
#define  CCS_TOP              0x00000001L         
#endif

// Dialog styles
#define  DS_ABSALIGN          0x01L               
#define  DS_CENTERMOUSE       0x1000L             
#define  DS_CONTEXTHELP       0x2000L             
#define  DS_FIXEDSYS          0x0008L             
#define  DS_NOFAILCREATE      0x0010L             
#define  DS_NOIDLEMSG         0x100L              
#define  DS_SYSMODAL          0x02L               

// Header control styles
#ifndef HDS_HORZ
#define HDS_HORZ                0x00000000
#endif
#ifndef HDS_BUTTONS
#define HDS_BUTTONS             0x00000002
#endif
#ifndef HDS_HIDDEN
#define HDS_HIDDEN              0x00000008
#endif

// List-view styles
#define  LVS_ALIGNLEFT        0x0800              
#define  LVS_ALIGNMASK        0x0c00              
#define  LVS_ALIGNTOP         0x0000              
#define  LVS_AUTOARRANGE      0x0100              
#define  LVS_EDITLABELS       0x0200              
#define  LVS_ICON             0x0000              
#define  LVS_LIST             0x0003              
#define  LVS_NOCOLUMNHEADER   0x4000              
#define  LVS_NOLABELWRAP      0x0080              
#define  LVS_NOSCROLL         0x2000              
#define  LVS_NOSORTHEADER     0x8000              
#define  LVS_OWNERDRAWFIXED   0x0400              
#define  LVS_REPORT           0x0001              
#define  LVS_SHAREIMAGELISTS  0x0040              
#define  LVS_SHOWSELALWAYS    0x0008              
#define  LVS_SINGLESEL        0x0004              
#define  LVS_SMALLICON        0x0002              
#define  LVS_SORTASCENDING    0x0010              
#define  LVS_SORTDESCENDING   0x0020              
#define  LVS_TYPEMASK         0x0003              

// Bitmaps
#define  OBM_BTNCORNERS       32758               
#define  OBM_BTSIZE           32761               
#define  OBM_CHECK            32760               
#define  OBM_CHECKBOXES       32759               
#define  OBM_CLOSE            32754               
#define  OBM_COMBO            32738               
#define  OBM_DNARROW          32752               
#define  OBM_DNARROWD         32742               
#define  OBM_DNARROWI         32736               
#define  OBM_LFARROW          32750               
#define  OBM_LFARROWD         32740               
#define  OBM_LFARROWI         32734               
#define  OBM_MNARROW          32739               
#define  OBM_OLD_CLOSE        32767               
#define  OBM_OLD_DNARROW      32764               
#define  OBM_OLD_LFARROW      32762               
#define  OBM_OLD_REDUCE       32757               
#define  OBM_OLD_RESTORE      32755               
#define  OBM_OLD_RGARROW      32763               
#define  OBM_OLD_UPARROW      32765               
#define  OBM_OLD_ZOOM         32756               
#define  OBM_REDUCE           32749               
#define  OBM_REDUCED          32746               
#define  OBM_RESTORE          32747               
#define  OBM_RESTORED         32744               
#define  OBM_RGARROW          32751               
#define  OBM_RGARROWD         32741               
#define  OBM_RGARROWI         32735               
#define  OBM_SIZE             32766               
#define  OBM_UPARROW          32753               
#define  OBM_UPARROWD         32743               
#define  OBM_UPARROWI         32737               
#define  OBM_ZOOM             32748               
#define  OBM_ZOOMD            32745             

// Cursors
#define  OCR_APPSTARTING      32650               
#define  OCR_CROSS            32515               
#define  OCR_IBEAM            32513               
#define  OCR_ICOCUR           32647               
#define  OCR_ICON             32641               
#define  OCR_NO               32648               
#define  OCR_NORMAL           32512               
#define  OCR_SIZE             32640               
#define  OCR_SIZEALL          32646               
#define  OCR_SIZENESW         32643               
#define  OCR_SIZENS           32645               
#define  OCR_SIZENWSE         32642               
#define  OCR_SIZEWE           32644               
#define  OCR_UP               32516               
#define  OCR_WAIT             32514               

// Icons
#define  OIC_BANG             32515               
#define  OIC_HAND             32513               
#define  OIC_NOTE             32516               
#define  OIC_QUES             32514               
#define  OIC_SAMPLE           32512               
#define  OIC_WINLOGO          32517            

#define  OIC_WARNING          OIC_BANG            
#define  OIC_ERROR            OIC_HAND            
#define  OIC_INFORMATION      OIC_NOTE            

// Scroll bar styles
#define  SBARS_SIZEGRIP       0x0100              
#define  SBS_BOTTOMALIGN      0x0004L             
#define  SBS_LEFTALIGN        0x0002L             
#define  SBS_RIGHTALIGN       0x0004L             
#define  SBS_SIZEBOX          0x0008L             
#define  SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L             
#define  SBS_SIZEBOXTOPLEFTALIGN 0x0002L             
#define  SBS_SIZEGRIP         0x0010L             
#define  SBS_TOPALIGN         0x0002L             

// System commands
#define  SC_ARRANGE           0xF110              
#define  SC_HOTKEY            0xF150              
#define  SC_HSCROLL           0xF080              
#define  SC_MAXIMIZE          0xF030              
#define  SC_MINIMIZE          0xF020              
#define  SC_MOUSEMENU         0xF090              
#define  SC_MOVE              0xF010              
#define  SC_NEXTWINDOW        0xF040              
#define  SC_PREVWINDOW        0xF050              
#define  SC_RESTORE           0xF120              
#define  SC_SCREENSAVE        0xF140              
#define  SC_SIZE              0xF000              
#define  SC_TASKLIST          0xF130              
#define  SC_VSCROLL           0xF070              

// Label/Static styles
#define  SS_BLACKFRAME        0x00000007L         
#define  SS_BLACKRECT         0x00000004L         
#define  SS_ENHMETAFILE       0x0000000FL         
#define  SS_ETCHEDFRAME       0x00000012L         
#define  SS_ETCHEDHORZ        0x00000010L         
#define  SS_ETCHEDVERT        0x00000011L         
#define  SS_GRAYFRAME         0x00000008L         
#define  SS_GRAYRECT          0x00000005L         
#define  SS_OWNERDRAW         0x0000000DL         
#define  SS_REALSIZEIMAGE     0x00000800L         
#define  SS_RIGHTJUST         0x00000400L         
#define  SS_SIMPLE            0x0000000BL         
#define  SS_SUNKEN            0x00001000L         
#define  SS_WHITEFRAME        0x00000009L         
#define  SS_WHITERECT         0x00000006L         

// Customizable column-width tracking control
#define  TBS_AUTOTICKS        0x0001              
#define  TBS_BOTH             0x0008              
#define  TBS_BOTTOM           0x0000              
#define  TBS_ENABLESELRANGE   0x0020              
#define  TBS_FIXEDLENGTH      0x0040              
#define  TBS_HORZ             0x0000              
#define  TBS_LEFT             0x0004              
#define  TBS_NOTHUMB          0x0080              
#define  TBS_NOTICKS          0x0010              
#define  TBS_RIGHT            0x0000              
#define  TBS_TOP              0x0004              
#define  TBS_VERT             0x0002              

// Tab control
#define  TCS_BUTTONS          0x0100              
#define  TCS_FIXEDWIDTH       0x0400              
#define  TCS_FOCUSNEVER       0x8000              
#define  TCS_FOCUSONBUTTONDOWN 0x1000              
#define  TCS_FORCEICONLEFT    0x0010              
#define  TCS_FORCELABELLEFT   0x0020              
#define  TCS_MULTILINE        0x0200              
#define  TCS_OWNERDRAWFIXED   0x2000              
#define  TCS_RAGGEDRIGHT      0x0800              
#define  TCS_RIGHTJUSTIFY     0x0000              
#define  TCS_SHAREIMAGELISTS  0x0040              
#define  TCS_SINGLELINE       0x0000              
#define  TCS_TABS             0x0000              
#define  TCS_TOOLTIPS         0x4000              

// tooltips
#define  TTS_ALWAYSTIP        0x01                
#define  TTS_NOPREFIX         0x02            

// TreeView control
#define  TVS_DISABLEDRAGDROP  0x0010              
#define  TVS_EDITLABELS       0x0008              
#define  TVS_HASBUTTONS       0x0001              
#define  TVS_HASLINES         0x0002              
#define  TVS_LINESATROOT      0x0004              
#define  TVS_SHOWSELALWAYS    0x0020              

// Up and Down arrow increment/decrement control
#define  UDS_ALIGNLEFT        0x0008              
#define  UDS_ALIGNRIGHT       0x0004              
#define  UDS_ARROWKEYS        0x0020              
#define  UDS_AUTOBUDDY        0x0010              
#define  UDS_HORZ             0x0040              
#define  UDS_NOTHOUSANDS      0x0080              
#define  UDS_SETBUDDYINT      0x0002              
#define  UDS_WRAP             0x0001              

#ifndef WS_OVERLAPPED
#define  WS_OVERLAPPED        0x00000000L
#endif

// Common extended styles
#define  WS_EX_ACCEPTFILES    0x00000010L         
#define  WS_EX_APPWINDOW      0x00040000L         
#define  WS_EX_CONTROLPARENT  0x00010000L         
#define  WS_EX_LEFT           0x00000000L         
#define  WS_EX_LTRREADING     0x00000000L         
#define  WS_EX_MDICHILD       0x00000040L         
#define  WS_EX_NOPARENTNOTIFY 0x00000004L         
#define  WS_EX_PALETTEWINDOW  (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)
#define  WS_EX_RIGHTSCROLLBAR 0x00000000L         
#define  WS_EX_TRANSPARENT    0x00000020L         
#define  WS_MAXIMIZE          0x01000000L         
#define  WS_MINIMIZE          0x20000000L         

#define  WS_OVERLAPPEDWINDOW  (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define  WS_POPUPWINDOW       (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define  WS_CHILDWINDOW       (WS_CHILD)          
#define  WS_TILED             WS_OVERLAPPED       
#define  WS_ICONIC            WS_MINIMIZE        
#define  WS_TILEDWINDOW       WS_OVERLAPPEDWINDOW 

// 32-bit language/sub-language identifiers

#ifndef LANG_NEUTRAL
// Primary language IDs.
#define LANG_NEUTRAL                     0x00

#define LANG_BULGARIAN                   0x02
#define LANG_CHINESE                     0x04
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_TURKISH                     0x1f
#endif //!LANG_NEUTRAL

#ifndef SUBLANG_NEUTRAL
// Sublanguage IDs.
#define SUBLANG_NEUTRAL                  0x00
#define SUBLANG_DEFAULT                  0x01
#define SUBLANG_SYS_DEFAULT              0x02

#define SUBLANG_CHINESE_TRADITIONAL      0x01
#define SUBLANG_CHINESE_SIMPLIFIED       0x02
#define SUBLANG_CHINESE_HONGKONG         0x03
#define SUBLANG_CHINESE_SINGAPORE        0x04
#define SUBLANG_DUTCH                    0x01
#define SUBLANG_DUTCH_BELGIAN            0x02
#define SUBLANG_ENGLISH_US               0x01
#define SUBLANG_ENGLISH_UK               0x02
#define SUBLANG_ENGLISH_AUS              0x03
#define SUBLANG_ENGLISH_CAN              0x04
#define SUBLANG_ENGLISH_NZ               0x05
#define SUBLANG_ENGLISH_EIRE             0x06
#define SUBLANG_FRENCH                   0x01
#define SUBLANG_FRENCH_BELGIAN           0x02
#define SUBLANG_FRENCH_CANADIAN          0x03
#define SUBLANG_FRENCH_SWISS             0x04
#define SUBLANG_GERMAN                   0x01
#define SUBLANG_GERMAN_SWISS             0x02
#define SUBLANG_GERMAN_AUSTRIAN          0x03
#define SUBLANG_ITALIAN                  0x01
#define SUBLANG_ITALIAN_SWISS            0x02
#define SUBLANG_NORWEGIAN_BOKMAL         0x01
#define SUBLANG_NORWEGIAN_NYNORSK        0x02
#define SUBLANG_PORTUGUESE               0x02
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01
#define SUBLANG_SPANISH                  0x01
#define SUBLANG_SPANISH_MEXICAN          0x02
#define SUBLANG_SPANISH_MODERN           0x03
#endif //!SUBLANG_NEUTRAL

#pragma warning(default:4005)

#endif // __RCDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\raserror.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:

raserror.h

Abstract:

Remote Access external API
RAS specific error codes

Notes:

--*/

// @CESYSGEN IF CE_MODULES_PPP

#ifndef _RASERROR_H_
#define _RASERROR_H_


#define RASBASE 600
#define SUCCESS 0


#define PENDING                              (RASBASE+0)
#define ERROR_INVALID_PORT_HANDLE            (RASBASE+1)
#define ERROR_PORT_ALREADY_OPEN              (RASBASE+2)
#define ERROR_BUFFER_TOO_SMALL               (RASBASE+3)
#define ERROR_WRONG_INFO_SPECIFIED           (RASBASE+4)
#define ERROR_CANNOT_SET_PORT_INFO           (RASBASE+5)
#define ERROR_PORT_NOT_CONNECTED             (RASBASE+6)
#define ERROR_EVENT_INVALID                  (RASBASE+7)
#define ERROR_DEVICE_DOES_NOT_EXIST          (RASBASE+8)
#define ERROR_DEVICETYPE_DOES_NOT_EXIST      (RASBASE+9)
#define ERROR_BUFFER_INVALID                 (RASBASE+10)
#define ERROR_ROUTE_NOT_AVAILABLE            (RASBASE+11)
#define ERROR_ROUTE_NOT_ALLOCATED            (RASBASE+12)
#define ERROR_INVALID_COMPRESSION_SPECIFIED  (RASBASE+13)
#define ERROR_OUT_OF_BUFFERS                 (RASBASE+14)
#define ERROR_PORT_NOT_FOUND                 (RASBASE+15)
#define ERROR_ASYNC_REQUEST_PENDING          (RASBASE+16)
#define ERROR_ALREADY_DISCONNECTING          (RASBASE+17)
#define ERROR_PORT_NOT_OPEN                  (RASBASE+18)
#define ERROR_PORT_DISCONNECTED              (RASBASE+19)
#define ERROR_NO_ENDPOINTS                   (RASBASE+20)
#define ERROR_CANNOT_OPEN_PHONEBOOK          (RASBASE+21)
#define ERROR_CANNOT_LOAD_PHONEBOOK          (RASBASE+22)
#define ERROR_CANNOT_FIND_PHONEBOOK_ENTRY    (RASBASE+23)
#define ERROR_CANNOT_WRITE_PHONEBOOK         (RASBASE+24)
#define ERROR_CORRUPT_PHONEBOOK              (RASBASE+25)
#define ERROR_CANNOT_LOAD_STRING             (RASBASE+26)
#define ERROR_KEY_NOT_FOUND                  (RASBASE+27)
#define ERROR_DISCONNECTION                  (RASBASE+28)
#define ERROR_REMOTE_DISCONNECTION           (RASBASE+29)
#define ERROR_HARDWARE_FAILURE               (RASBASE+30)
#define ERROR_USER_DISCONNECTION             (RASBASE+31)
#define ERROR_INVALID_SIZE                   (RASBASE+32)
#define ERROR_PORT_NOT_AVAILABLE             (RASBASE+33)
#define ERROR_CANNOT_PROJECT_CLIENT          (RASBASE+34)
#define ERROR_UNKNOWN                        (RASBASE+35)
#define ERROR_WRONG_DEVICE_ATTACHED          (RASBASE+36)
#define ERROR_BAD_STRING                     (RASBASE+37)
#define ERROR_REQUEST_TIMEOUT                (RASBASE+38)
#define ERROR_CANNOT_GET_LANA                (RASBASE+39)
#define ERROR_NETBIOS_ERROR                  (RASBASE+40)
#define ERROR_SERVER_OUT_OF_RESOURCES        (RASBASE+41)
#define ERROR_NAME_EXISTS_ON_NET             (RASBASE+42)
#define ERROR_SERVER_GENERAL_NET_FAILURE     (RASBASE+43)
#define WARNING_MSG_ALIAS_NOT_ADDED          (RASBASE+44)
#define ERROR_AUTH_INTERNAL                  (RASBASE+45)
#define ERROR_RESTRICTED_LOGON_HOURS         (RASBASE+46)
#define ERROR_ACCT_DISABLED                  (RASBASE+47)
#define ERROR_PASSWD_EXPIRED                 (RASBASE+48)
#define ERROR_NO_DIALIN_PERMISSION           (RASBASE+49)
#define ERROR_SERVER_NOT_RESPONDING          (RASBASE+50)
#define ERROR_FROM_DEVICE                    (RASBASE+51)
#define ERROR_UNRECOGNIZED_RESPONSE          (RASBASE+52)
#define ERROR_MACRO_NOT_FOUND                (RASBASE+53)
#define ERROR_MACRO_NOT_DEFINED              (RASBASE+54)
#define ERROR_MESSAGE_MACRO_NOT_FOUND        (RASBASE+55)
#define ERROR_DEFAULTOFF_MACRO_NOT_FOUND     (RASBASE+56)
#define ERROR_FILE_COULD_NOT_BE_OPENED       (RASBASE+57)
#define ERROR_DEVICENAME_TOO_LONG            (RASBASE+58)
#define ERROR_DEVICENAME_NOT_FOUND           (RASBASE+59)
#define ERROR_NO_RESPONSES                   (RASBASE+60)
#define ERROR_NO_COMMAND_FOUND               (RASBASE+61)
#define ERROR_WRONG_KEY_SPECIFIED            (RASBASE+62)
#define ERROR_UNKNOWN_DEVICE_TYPE            (RASBASE+63)
#define ERROR_ALLOCATING_MEMORY              (RASBASE+64)
#define ERROR_PORT_NOT_CONFIGURED            (RASBASE+65)
#define ERROR_DEVICE_NOT_READY               (RASBASE+66)
#define ERROR_READING_INI_FILE               (RASBASE+67)
#define ERROR_NO_CONNECTION                  (RASBASE+68)
#define ERROR_BAD_USAGE_IN_INI_FILE          (RASBASE+69)
#define ERROR_READING_SECTIONNAME            (RASBASE+70)
#define ERROR_READING_DEVICETYPE             (RASBASE+71)
#define ERROR_READING_DEVICENAME             (RASBASE+72)
#define ERROR_READING_USAGE                  (RASBASE+73)
#define ERROR_READING_MAXCONNECTBPS          (RASBASE+74)
#define ERROR_READING_MAXCARRIERBPS          (RASBASE+75)
#define ERROR_LINE_BUSY                      (RASBASE+76)
#define ERROR_VOICE_ANSWER                   (RASBASE+77)
#define ERROR_NO_ANSWER                      (RASBASE+78)
#define ERROR_NO_CARRIER                     (RASBASE+79)
#define ERROR_NO_DIALTONE                    (RASBASE+80)
#define ERROR_IN_COMMAND                     (RASBASE+81)
#define ERROR_WRITING_SECTIONNAME            (RASBASE+82)
#define ERROR_WRITING_DEVICETYPE             (RASBASE+83)
#define ERROR_WRITING_DEVICENAME             (RASBASE+84)
#define ERROR_WRITING_MAXCONNECTBPS          (RASBASE+85)
#define ERROR_WRITING_MAXCARRIERBPS          (RASBASE+86)
#define ERROR_WRITING_USAGE                  (RASBASE+87)
#define ERROR_WRITING_DEFAULTOFF             (RASBASE+88)
#define ERROR_READING_DEFAULTOFF             (RASBASE+89)
#define ERROR_EMPTY_INI_FILE                 (RASBASE+90)
#define ERROR_AUTHENTICATION_FAILURE         (RASBASE+91)
#define ERROR_PORT_OR_DEVICE                 (RASBASE+92)
#define ERROR_NOT_BINARY_MACRO               (RASBASE+93)
#define ERROR_DCB_NOT_FOUND                  (RASBASE+94)
#define ERROR_STATE_MACHINES_NOT_STARTED     (RASBASE+95)
#define ERROR_STATE_MACHINES_ALREADY_STARTED (RASBASE+96)
#define ERROR_PARTIAL_RESPONSE_LOOPING       (RASBASE+97)
#define ERROR_UNKNOWN_RESPONSE_KEY           (RASBASE+98)
#define ERROR_RECV_BUF_FULL                  (RASBASE+99)
#define ERROR_CMD_TOO_LONG                   (RASBASE+100)
#define ERROR_UNSUPPORTED_BPS                (RASBASE+101)
#define ERROR_UNEXPECTED_RESPONSE            (RASBASE+102)
#define ERROR_INTERACTIVE_MODE               (RASBASE+103)
#define ERROR_BAD_CALLBACK_NUMBER            (RASBASE+104)
#define ERROR_INVALID_AUTH_STATE             (RASBASE+105)
#define ERROR_WRITING_INITBPS                (RASBASE+106)
#define ERROR_X25_DIAGNOSTIC                 (RASBASE+107)
#define ERROR_ACCT_EXPIRED                   (RASBASE+108)
#define ERROR_CHANGING_PASSWORD              (RASBASE+109)
#define ERROR_OVERRUN                        (RASBASE+110)
#define ERROR_RASMAN_CANNOT_INITIALIZE	     (RASBASE+111)
#define ERROR_BIPLEX_PORT_NOT_AVAILABLE      (RASBASE+112)
#define ERROR_NO_ACTIVE_ISDN_LINES           (RASBASE+113)
#define ERROR_NO_ISDN_CHANNELS_AVAILABLE     (RASBASE+114)
#define ERROR_TOO_MANY_LINE_ERRORS           (RASBASE+115)
#define ERROR_IP_CONFIGURATION               (RASBASE+116)
#define ERROR_NO_IP_ADDRESSES                (RASBASE+117)
#define ERROR_PPP_TIMEOUT                    (RASBASE+118)
#define ERROR_PPP_REMOTE_TERMINATED          (RASBASE+119)
#define ERROR_PPP_NO_PROTOCOLS_CONFIGURED    (RASBASE+120)
#define ERROR_PPP_NO_RESPONSE                (RASBASE+121)
#define ERROR_PPP_INVALID_PACKET             (RASBASE+122)
#define ERROR_PHONE_NUMBER_TOO_LONG          (RASBASE+123)
#define ERROR_IPXCP_NO_DIALOUT_CONFIGURED    (RASBASE+124)
#define ERROR_IPXCP_NO_DIALIN_CONFIGURED     (RASBASE+125)
#define ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE   (RASBASE+126)
#define ERROR_ACCESSING_TCPCFGDLL            (RASBASE+127)
#define ERROR_NO_IP_RAS_ADAPTER              (RASBASE+128)
#define ERROR_SLIP_REQUIRES_IP               (RASBASE+129)
#define ERROR_PROJECTION_NOT_COMPLETE        (RASBASE+130)
#define ERROR_PROTOCOL_NOT_CONFIGURED        (RASBASE+131)
#define ERROR_PPP_NOT_CONVERGING             (RASBASE+132)
#define ERROR_PPP_CP_REJECTED                (RASBASE+133)
#define ERROR_PPP_LCP_TERMINATED             (RASBASE+134)
#define ERROR_PPP_REQUIRED_ADDRESS_REJECTED  (RASBASE+135)
#define ERROR_PPP_NCP_TERMINATED             (RASBASE+136)
#define ERROR_PPP_LOOPBACK_DETECTED          (RASBASE+137)
#define ERROR_PPP_NO_ADDRESS_ASSIGNED        (RASBASE+138)
#define ERROR_CANNOT_USE_LOGON_CREDENTIALS   (RASBASE+139)
#define ERROR_TAPI_CONFIGURATION             (RASBASE+140)
#define ERROR_NO_LOCAL_ENCRYPTION            (RASBASE+141)
#define ERROR_NO_REMOTE_ENCRYPTION           (RASBASE+142)
#define ERROR_REMOTE_REQUIRES_ENCRYPTION     (RASBASE+143)
#define ERROR_IPXCP_NET_NUMBER_CONFLICT      (RASBASE+144)
#define ERROR_INVALID_SMM                    (RASBASE+145)
#define ERROR_SMM_UNINITIALIZED              (RASBASE+146)
#define ERROR_NO_MAC_FOR_PORT                (RASBASE+147)
#define ERROR_SMM_TIMEOUT                    (RASBASE+148)
#define ERROR_BAD_PHONE_NUMBER               (RASBASE+149)
#define ERROR_WRONG_MODULE                   (RASBASE+150)
#define ERROR_PPP_MAC						 (RASBASE+151)
#define ERROR_PPP_LCP						 (RASBASE+152)
#define ERROR_PPP_AUTH						 (RASBASE+153)
#define ERROR_PPP_NCP						 (RASBASE+154)
#define ERROR_POWER_OFF						 (RASBASE+155)
#define ERROR_POWER_OFF_CD					 (RASBASE+156)


#define ERROR_DIAL_ALREADY_IN_PROGRESS       (RASBASE+157)
#define ERROR_RASAUTO_CANNOT_INITIALIZE      (RASBASE+158)
#define ERROR_UNABLE_TO_AUTHENTICATE_SERVER (RASBASE + 178)


#define RASBASEEND                           (RASBASE+158)

#ifndef ROUTEBASE
#define ROUTEBASE 900
#endif

#ifndef ERROR_IDLE_DISCONNECTED
#define ERROR_IDLE_DISCONNECTED                     (ROUTEBASE+26)
/*
 * The port has been disconnected due to inactivity.%0
 */
#endif


#endif // _RASERROR_H_

// @CESYSGEN ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\raseapif.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    raseapif.h

Abstract:

    Defines interface between a third party authentication module
    and the Remote Access Service PPP engine.
    
--*/

#ifndef _RASEAPIF_
#define _RASEAPIF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Defines used for installtion of EAP DLL
//
// Custom EAP DLL (ex. Name=Sample.dll, Type=(decimal 40) registry installation)
//
// HKEY_LOCAL_MACHINE\Comm\EAP\Extension\40)
//      Path                (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      ConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      InteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      IdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      FriendlyName        (REG_SZ) Sample EAP Protocol
//      RequireConfigUI     (REG_DWORD)     1
//      ConfigCLSID         (REG_SZ)        {0000031A-0000-0000-C000-000000000046}
//      StandaloneSupported (REG_DWORD)     1
//

#define RAS_EAP_REGISTRY_LOCATION   \
    TEXT("Comm\\EAP\\Extension")

#define RAS_EAPHOST_REGISTRY_LOCATION   \
    TEXT("Comm\\EapHost\\Extension")

#define RAS_EAP_VALUENAME_PATH                  TEXT("Path")
#define RAS_EAP_VALUENAME_CONFIGUI              TEXT("ConfigUIPath")
#define RAS_EAP_VALUENAME_INTERACTIVEUI         TEXT("InteractiveUIPath")
#define RAS_EAP_VALUENAME_IDENTITY              TEXT("IdentityPath")
#define RAS_EAP_VALUENAME_FRIENDLY_NAME         TEXT("FriendlyName")
#define RAS_EAP_VALUENAME_DEFAULT_DATA          TEXT("ConfigData")
#define RAS_EAP_VALUENAME_REQUIRE_CONFIGUI      TEXT("RequireConfigUI")
#define RAS_EAP_VALUENAME_ENCRYPTION            TEXT("MPPEEncryptionSupported")
#define RAS_EAP_VALUENAME_INVOKE_NAMEDLG        TEXT("InvokeUsernameDialog")
#define RAS_EAP_VALUENAME_INVOKE_PWDDLG         TEXT("InvokePasswordDialog")
#define RAS_EAP_VALUENAME_CONFIG_CLSID          TEXT("ConfigCLSID")
#define RAS_EAP_VALUENAME_STANDALONE_SUPPORTED  TEXT("StandaloneSupported")
#define RAS_EAP_VALUENAME_ROLES_SUPPORTED       TEXT("RolesSupported")

// Flags for RolesSupported.
#define RAS_EAP_ROLE_AUTHENTICATOR   0x00000001
#define RAS_EAP_ROLE_AUTHENTICATEE   0x00000002

//
// Following flags describe the hosting of EAP
// methods in PEAP or in EAP.  If this role is
// missing the default behavior is to show the
// EAP method in PEAP and in EAP.
//
#define RAS_EAP_ROLE_EXCLUDE_IN_EAP  0x00000004
#define RAS_EAP_ROLE_EXCLUDE_IN_PEAP 0x00000008
#define RAS_EAP_ROLE_EXCLUDE_IN_VPN  0x00000010

typedef enum _RAS_AUTH_ATTRIBUTE_TYPE_
{
    raatMinimum = 0,                // Undefined
    raatUserName,                   // Value field is a Pointer
    raatUserPassword,               // Value field is a Pointer
    raatMD5CHAPPassword,            // Value field is a Pointer
    raatNASIPAddress,               // Value field is a 32 bit integral value
    raatNASPort,                    // Value field is a 32 bit integral value
    raatServiceType,                // Value field is a 32 bit integral value
    raatFramedProtocol,             // Value field is a 32 bit integral value
    raatFramedIPAddress,            // Value field is a 32 bit integral value
    raatFramedIPNetmask,            // Value field is a 32 bit integral value
    raatFramedRouting = 10,         // Value field is a 32 bit integral value
    raatFilterId,                   // Value field is a Pointer
    raatFramedMTU,                  // Value field is a 32 bit integral value
    raatFramedCompression,          // Value field is a 32 bit integral value
    raatLoginIPHost,                // Value field is a 32 bit integral value
    raatLoginService,               // Value field is a 32 bit integral value
    raatLoginTCPPort,               // Value field is a 32 bit integral value
    raatUnassigned17,               // Undefined
    raatReplyMessage,               // Value field is a Pointer
    raatCallbackNumber,             // Value field is a Pointer
    raatCallbackId =20,             // Value field is a Pointer
    raatUnassigned21,               // Undefined
    raatFramedRoute,                // Value field is a Pointer
    raatFramedIPXNetwork,           // Value field is a 32 bit integral value
    raatState,                      // Value field is a Pointer
    raatClass,                      // Value field is a Pointer
    raatVendorSpecific,             // Value field is a Pointer
    raatSessionTimeout,             // Value field is a 32 bit integral value
    raatIdleTimeout,                // Value field is a 32 bit integral value
    raatTerminationAction,          // Value field is a 32 bit integral value
    raatCalledStationId = 30,       // Value field is a Pointer
    raatCallingStationId,           // Value field is a Pointer
    raatNASIdentifier,              // Value field is a Pointer
    raatProxyState,                 // Value field is a Pointer
    raatLoginLATService,            // Value field is a Pointer
    raatLoginLATNode,               // Value field is a Pointer
    raatLoginLATGroup,              // Value field is a Pointer
    raatFramedAppleTalkLink,        // Value field is a 32 bit integral value
    raatFramedAppleTalkNetwork,     // Value field is a 32 bit integral value
    raatFramedAppleTalkZone,        // Value field is a Pointer
    raatAcctStatusType = 40,        // Value field is a 32 bit integral value
    raatAcctDelayTime,              // Value field is a 32 bit integral value
    raatAcctInputOctets,            // Value field is a 32 bit integral value
    raatAcctOutputOctets,           // Value field is a 32 bit integral value
    raatAcctSessionId,              // Value field is a Pointer
    raatAcctAuthentic,              // Value field is a 32 bit integral value
    raatAcctSessionTime,            // Value field is a 32 bit integral value
    raatAcctInputPackets,           // Value field is a 32 bit integral value
    raatAcctOutputPackets,          // Value field is a 32 bit integral value
    raatAcctTerminateCause,         // Value field is a 32 bit integral value
    raatAcctMultiSessionId = 50,    // Value field is a Pointer
    raatAcctLinkCount,              // Value field is a 32 bit integral value
    raatAcctEventTimeStamp = 55,    // Value field is a 32 bit integral value
    raatMD5CHAPChallenge = 60,      // Value field is a Pointer
    raatNASPortType,                // Value field is a 32 bit integral value
    raatPortLimit,                  // Value field is a 32 bit integral value
    raatLoginLATPort,               // Value field is a Pointer
    raatTunnelType,                 // Value field is a 32 bit integral value
    raatTunnelMediumType,           // Value field is a 32 bit integral value
    raatTunnelClientEndpoint,       // Value field is a Pointer
    raatTunnelServerEndpoint,       // Value field is a Pointer
    raatARAPPassword = 70,          // Value field is a Pointer
    raatARAPFeatures,               // Value field is a Pointer
    raatARAPZoneAccess,             // Value field is a 32 bit integral value
    raatARAPSecurity,               // Value field is a 32 bit integral value
    raatARAPSecurityData,           // Value field is a Pointer
    raatPasswordRetry,              // Value field is a 32 bit integral value
    raatPrompt,                     // Value field is a 32 bit integral value
    raatConnectInfo,                // Value field is a Pointer
    raatConfigurationToken,         // Value field is a Pointer
    raatEAPMessage,                 // Value field is a Pointer
    raatSignature = 80,             // Value field is a Pointer
    raatARAPChallengeResponse = 84, // Value field is a Pointer
    raatAcctInterimInterval = 85,   // Value field is a 32 bit integral value
    raatARAPGuestLogon = 8096,      // Value field is a 32 bit integral value
    raatReserved = 0xFFFFFFFF       // Undefined

}RAS_AUTH_ATTRIBUTE_TYPE;


//
// VSA attribute ids for ARAP
//
#define  raatARAPChallenge              33
#define  raatARAPOldPassword            19
#define  raatARAPNewPassword            20
#define  raatARAPPasswordChangeReason   21

//
// Value is set to the 32 bit integral value or a pointer to data.
// 32 bit integral values should be in host format, not network format.
// Length for a 32 bit integral value can be 1, 2 or 4. The array of
// attributes must be terminated with an attribute of type raatMinimum.
//

typedef struct _RAS_AUTH_ATTRIBUTE
{
    RAS_AUTH_ATTRIBUTE_TYPE raaType;
    DWORD                   dwLength;
    PVOID                   Value;

}RAS_AUTH_ATTRIBUTE, *PRAS_AUTH_ATTRIBUTE;

//
// EAP packet codes from EAP spec.
//

#define EAPCODE_Request         1
#define EAPCODE_Response        2
#define EAPCODE_Success         3
#define EAPCODE_Failure         4

#define MAXEAPCODE              4

//
// Values of the fFlags field in PPP_EAP_INPUT
// These have the same values as the RASEAPF_ flags in ras.h
//

#define RAS_EAP_FLAG_ROUTER             0x00000001  // This is a router
#define RAS_EAP_FLAG_NON_INTERACTIVE    0x00000002  // No UI should be displayed
#define RAS_EAP_FLAG_LOGON              0x00000004  // The user data was
                                                    // obtained from Winlogon
#define RAS_EAP_FLAG_PREVIEW            0x00000008  // User has checked
                                                    // "Prompt for information
                                                    // before dialing"
#define RAS_EAP_FLAG_FIRST_LINK         0x00000010  // This is the first link
#define RAS_EAP_FLAG_MACHINE_AUTH       0x00000020  // Use the default machine cert
                                                    // or user cert based on the
                                                    // application logon context
#define RAS_EAP_FLAG_GUEST_ACCESS       0x00000040  // Request to provide guest
                                                    // access.
#define RAS_EAP_FLAG_8021X_AUTH         0x00000080  // Anything specific to 8021x
                                                    // to be done in TLS


typedef struct _PPP_EAP_PACKET
{
    BYTE    Code;       // 1-Request, 2-Response, 3-Success, 4-Failure

    BYTE    Id;         // Id of this packet

    BYTE    Length[2];  // Length of this packet

    BYTE    Data[1];    // Data - First byte is Type for Request/Response

}PPP_EAP_PACKET, *PPPP_EAP_PACKET;

#define PPP_EAP_PACKET_HDR_LEN  ( sizeof( PPP_EAP_PACKET ) - 1 )

//
// Interface structure between the engine and APs. This is passed to the
// AP's via the RasCpBegin call.
//

typedef struct _PPP_EAP_INPUT
{
    //
    // Size of this structure
    //

    DWORD       dwSizeInBytes;

    //
    // The following five fields are valid only in RasEapBegin call
    //

    DWORD       fFlags;         // See RAS_EAP_FLAG_*

    BOOL        fAuthenticator; // Act as authenticator or authenticatee

    WCHAR *     pwszIdentity;   // Users's identity

    WCHAR *     pwszPassword;   // Client's account password. Only valid when
                                // fAuthenticator is FALSE.

    BYTE        bInitialId;     // Initial packet identifier. Must be used for
                                // the first EAP packet sent by the DLL and
                                // incremented by one for each subsequent
                                // request packet.

    //
    // During the RasEapBegin call on the authenticator side, pUserAttributes
    // contains the set of attributes for the currently dialed in user, e.g.,
    // the port used, NAS IP Address, etc.
    //
    // When the fAuthenticationComplete flag is TRUE, pUserAttributes contains
    // attributes (if any) returned by the authentication provider.
    //
    // This memory is not owned by the EAP DLL and should be treated as
    // read-only.
    //

    RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // The next two fields are used only if the EAP DLL is using the
    // currently configured authentication provider ex: RADIUS or Windows NT
    // domain authentication, and the fAuthenticator field above is set to
    // TRUE.
    //

    //
    // Indicates that the authenticator has completed authentication.
    // Ignore this field if an authentication provider is not being used.
    //

    BOOL                fAuthenticationComplete;

    //
    // Result of the authentication process by the authentication provider.
    // NO_ERROR indicates success, otherwise it is a value from winerror.h,
    // raserror.h or mprerror.h indicating failure reason.
    //

    DWORD               dwAuthResultCode;

    //
    // Valid only on the authenticatee side. This may be used on the
    // authenticatee side to impersonate the user being authenticated.
    //

    OPTIONAL HANDLE     hTokenImpersonateUser;

    //
    // This variable should be examined only by the authenticatee side.
    // The EAP specification states that the success packet may be lost and
    // since it is a non-acknowledged packet, reception of an NCP packet should
    // be interpreted as a success packet. This varable is set to TRUE in this
    // case only on the authenticatee side
    //

    BOOL                fSuccessPacketReceived;

    //
    // Will be set to TRUE only when the user dismissed the interactive
    // UI that was invoked by the EAP dll
    //

    BOOL                fDataReceivedFromInteractiveUI;

    //
    // Data received from the Interactive UI. Will be set to
    // non-NULL when fDataReceivedFromInteractiveUI is set to TRUE and
    // RasEapInvokeInteractiveUI returned non-NULL data. This buffer will be
    // freed by the PPP engine on return from the RasEapMakeMessage call. A
    // copy of this data should be made in the EAP Dll's memory space.
    //

    OPTIONAL PBYTE      pDataFromInteractiveUI;

    //
    // Size in bytes of data pointed to by pInteractiveConnectionData. This may
    // be 0 if there was no data passed back by RasEapInvokeInteractiveUI.
    //

    DWORD               dwSizeOfDataFromInteractiveUI;

    //
    // Connection data received from the Config UI. Will be set to non-NULL
    // when the RasEapBegin call is made and the RasEapInvokeConfigUI
    // returned non-NULL data. This buffer will be freed by the PPP engine
    // on return from the RasEapBegin call. A copy of this data should
    // be made in the EAP Dll's memory space.
    //

    OPTIONAL PBYTE      pConnectionData;

    //
    // Size in bytes of data pointed to by pConnectionData. This may be
    // 0 if there was no data passed back by the RasEapInvokeConfigUI call.
    //

    DWORD               dwSizeOfConnectionData;

    //
    // User data received from the Identity UI or Interactive UI. Will be set
    // to non-NULL when the RasEapBegin call is made if such data exists.
    // This buffer will be freed by the PPP engine on return from the
    // RasEapBegin call. A copy of this data should be made in the EAP Dll's
    // memory space.
    //

    OPTIONAL PBYTE      pUserData;

    //
    // Size in bytes of data pointed to by pUserData. This may be 0 if there
    // is no data.
    //

    DWORD               dwSizeOfUserData;

    //
    // Reserved.
    //

    HANDLE              hReserved;

}PPP_EAP_INPUT, *PPPP_EAP_INPUT;

typedef enum _PPP_EAP_ACTION
{
    //
    // These actions are provided by the EAP DLL as output from the
    // RasEapMakeMessage API.  They tell the PPP engine what action (if any) to
    // take on the EAP DLL's behalf, and eventually inform the engine that the
    // EAP DLL has finished authentication.
    //

    EAPACTION_NoAction,     // Be passive, i.e. listen without timeout (default)
    EAPACTION_Authenticate, // Invoke the back-end authenticator.
    EAPACTION_Done,         // End auth session, dwAuthResultCode is set
    EAPACTION_SendAndDone,  // As above but send message without timeout first
    EAPACTION_Send,         // Send message, don't timeout waiting for reply
    EAPACTION_SendWithTimeout, // Send message, timeout if reply not received
    EAPACTION_SendWithTimeoutInteractive  // As above, but don't increment
                                          // retry count

}PPP_EAP_ACTION;

typedef struct _PPP_EAP_OUTPUT
{
    //
    // Size of this structure
    //

    DWORD                   dwSizeInBytes;

    //
    // Action that the PPP engine should take
    //

    PPP_EAP_ACTION          Action;

    //
    // dwAuthResultCode is valid only with an Action code of Done or
    // SendAndDone. Zero value indicates succesful authentication.
    // Non-zero indicates unsuccessful authentication with the value
    // indicating the reason for authentication failure.
    // Non-zero return codes should be only from winerror.h, raserror.h and
    // mprerror.h
    //

    DWORD                   dwAuthResultCode;

    //
    // When Action is EAPACTION_Authenticate, pUserAttributes may contain
    // additional attributes necessary to authenticate the user, e.g.,
    // User-Password. If no credentials are presented, the back-end
    // authenticator will assume the user is authentic and only retrieve
    // authorizations.
    //
    // When Action is EAPACTION_Done, EAPACTION_SendAndDone, or EAPACTION_Send,
    // pUserAttributes may contain additional attributes for the user. These
    // attributes will overwrite any attributes of the same type returned by
    // the back-end authenticator.
    //
    // It is up to the EAP DLL to free this memory in RasEapEnd call.
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pUserAttributes;
    //
    // Flag set to true will cause the RasEapInvokeInteractiveUI call to be
    // made.
    //

    BOOL                    fInvokeInteractiveUI;

    //
    // Pointer to context data, if any, to be sent to the UI. The EAP dll
    // is responsible for freeing this buffer in the RasEapEnd call or when
    // a response from the user for this invocation is obtained.
    //

    OPTIONAL PBYTE          pUIContextData;

    //
    // Size in bytes of the data pointed to by pUIContextData. Ignored if
    // pUIContextData is NULL
    //

    DWORD                   dwSizeOfUIContextData;

    //
    // When set to TRUE, indicates that the information pointed to by
    // pConnectionData should be saved in the phonebook. Only valid on
    // the authenticatee side.
    //

    BOOL                    fSaveConnectionData;

    //
    // If fSaveConnectionData above is true, the data pointed to by
    // pConnectionData will be saved in the phonebook. This data
    // must be freed by the DLL when the RasEapEnd call is made.
    //

    OPTIONAL PBYTE          pConnectionData;

    //
    // Size, in bytes, of the data pointed to by pConnectionData
    //

    DWORD                   dwSizeOfConnectionData;

    //
    // When set to TRUE, indicates that the information pointed to by
    // pUserData should be saved in the registry for this user. Only valid
    // on the authenticatee side.
    //

    BOOL                    fSaveUserData;

    //
    // If fSaveUserData above is true, the data pointed to by pUserData will be
    // saved in the registry for this user. This data must be freed by the DLL
    // when the RasEapEnd call is made.
    //

    OPTIONAL PBYTE          pUserData;

    //
    // Size, in bytes, of the data pointed to by pUserData
    //

    DWORD                   dwSizeOfUserData;

    //
    // If the extension wants to replace the password passed in
    // by the EAP framework in the pwszPassword field of the PPP_EAP_INPUT
    // structure, it can return a new password here.
    //
    // For example, if interactive UI data
    // is received by the extension which contains a new password then
    // it can indicate that change to the framework by setting fSetPassword
    // to TRUE and setting pwszPassword to the pointer to the password string.
    //
    // If fSetPassword is TRUE, then setting fSavePassword to TRUE will cause
    // the password to be saved in persistent storage such as the registry
    // that can be used for future connections.
    //
    // The client is responsible for releasing any memory allocated to
    // store the password at a later time (e.g. in RasEapEnd).
    //

    BOOL                    fSetPassword;
    BOOL                    fSavePassword;

    OPTIONAL PWSTR          pwszPassword;

}PPP_EAP_OUTPUT, *PPPP_EAP_OUTPUT;

typedef struct _PPP_EAP_INFO
{
    //
    // Size of this structure
    //

    DWORD   dwSizeInBytes;

    DWORD   dwEapTypeId;

    //
    // Called to initialize/uninitialize this module. This will be called before
    // any other call is made. fInitialize will be TRUE iff the module has to be
    // initialized. Must return errorcodes only from winerror.h, raserror.h or
    // mprerror.h
    //

    DWORD   (APIENTRY *RasEapInitialize)(   IN  BOOL        fInitialize );

    //
    // Called to get a context buffer for this EAP session and pass
    // initialization information. This will be called before any other
    // call is made, except RasEapInitialize. Must return errorcodes only from
    // winerror.h, raserror.h or mprerror.h
    //

    DWORD   (APIENTRY *RasEapBegin)( OUT VOID **             ppWorkBuffer,
                                     IN  PPP_EAP_INPUT *     pPppEapInput );

    //
    // Called to free the context buffer for this EAP session.
    // Called after this session is completed successfully or not, provided
    // the RasEapBegin call for this EAP session returned successfully.
    // Must return errorcodes only from winerror.h, raserror.h or mprerror.h
    //

    DWORD   (APIENTRY *RasEapEnd)(   IN  VOID *     pWorkBuffer );

    //
    // Called to process an incomming packet and/or send a packet.
    // cbSendPacket is the size in bytes of the buffer pointed to by
    // pSendPacket. Must return errorcodes only from winerror.h, raserror.h or
    // mprerror.h. Error return code indicates an error occurance during the
    // authentication process.
    //

    DWORD   (APIENTRY *RasEapMakeMessage)(
                            IN  VOID*               pWorkBuf,
                            IN  PPP_EAP_PACKET*     pReceivePacket,
                            OUT PPP_EAP_PACKET*     pSendPacket,
                            IN  DWORD               cbSendPacket,
                            OUT PPP_EAP_OUTPUT*     pEapOutput,
                            IN  PPP_EAP_INPUT*      pEapInput );

}PPP_EAP_INFO, *PPPP_EAP_INFO;

//
// RasEapGetInfo should be exported by the 3rd party EAP dll installed in the
// registry via the Path value.
//

DWORD APIENTRY
RasEapGetInfo(
    IN  DWORD           dwEapTypeId,
    OUT PPP_EAP_INFO*   pEapInfo
);

//
// RasEapFreeMemory should be exported by the 3rd party EAP dlls installed in
// the registry via the InteractiveUIPath, ConfigUIPath, and IdentityPath
// values.
//

DWORD APIENTRY
RasEapFreeMemory(
    IN  BYTE*           pMemory
);

//
// RasEapInvokeInteractiveUI and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the InteractiveUIPath
// value.
//

DWORD APIENTRY
RasEapInvokeInteractiveUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  BYTE*           pUIContextData,
    IN  DWORD           dwSizeOfUIContextData,
    OUT BYTE**          ppDataFromInteractiveUI,
    OUT DWORD*          pdwSizeOfDataFromInteractiveUI
);

//
// RasEapInvokeConfigUI and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the ConfigUIPath value.
//

DWORD APIENTRY
RasEapInvokeConfigUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    OUT BYTE**          ppConnectionDataOut,
    OUT DWORD*          pdwSizeOfConnectionDataOut
);

//
// RasEapGetIdentity and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the IdentityPath value.
//

DWORD APIENTRY
RasEapGetIdentity(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    __in_bcount(dwSizeOfConnectionDataIn) IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT WCHAR**         ppwszIdentity
);

#ifdef __cplusplus
}
#endif

#endif // _RASEAPIF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\recalc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:15:40 2007
 */
/* Compiler settings for ..\recalc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __recalc_h__
#define __recalc_h__

/* Forward Declarations */ 

#ifndef __IRecalcEngine_FWD_DEFINED__
#define __IRecalcEngine_FWD_DEFINED__
typedef interface IRecalcEngine IRecalcEngine;
#endif 	/* __IRecalcEngine_FWD_DEFINED__ */


#ifndef __IRecalcHost_FWD_DEFINED__
#define __IRecalcHost_FWD_DEFINED__
typedef interface IRecalcHost IRecalcHost;
#endif 	/* __IRecalcHost_FWD_DEFINED__ */


#ifndef __IRecalcProperty_FWD_DEFINED__
#define __IRecalcProperty_FWD_DEFINED__
typedef interface IRecalcProperty IRecalcProperty;
#endif 	/* __IRecalcProperty_FWD_DEFINED__ */


#ifndef __IRecalcHostDebug_FWD_DEFINED__
#define __IRecalcHostDebug_FWD_DEFINED__
typedef interface IRecalcHostDebug IRecalcHostDebug;
#endif 	/* __IRecalcHostDebug_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_recalc_0000 */
/* [local] */ 

#define SID_SRecalcEngine IID_IRecalcEngine




extern RPC_IF_HANDLE __MIDL_itf_recalc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_recalc_0000_v0_0_s_ifspec;

#ifndef __IRecalcEngine_INTERFACE_DEFINED__
#define __IRecalcEngine_INTERFACE_DEFINED__

/* interface IRecalcEngine */
/* [version][local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRecalcEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f496-98b5-11cf-bb82-00aa00bdce0b")
    IRecalcEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RecalcAll( 
            /* [in] */ BOOL fForce) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNameSpaceChange( 
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExpression( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            LPOLESTR language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpression( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pstrExpression,
            /* [out] */ BSTR __RPC_FAR *pstrLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearExpression( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginStyle( 
            /* [in] */ IUnknown __RPC_FAR *pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndStyle( 
            /* [in] */ IUnknown __RPC_FAR *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecalcEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRecalcEngine __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRecalcEngine __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRecalcEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecalcAll )( 
            IRecalcEngine __RPC_FAR * This,
            /* [in] */ BOOL fForce);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnNameSpaceChange )( 
            IRecalcEngine __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExpression )( 
            IRecalcEngine __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            LPOLESTR language);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExpression )( 
            IRecalcEngine __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pstrExpression,
            /* [out] */ BSTR __RPC_FAR *pstrLanguage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearExpression )( 
            IRecalcEngine __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginStyle )( 
            IRecalcEngine __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndStyle )( 
            IRecalcEngine __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pObject);
        
        END_INTERFACE
    } IRecalcEngineVtbl;

    interface IRecalcEngine
    {
        CONST_VTBL struct IRecalcEngineVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecalcEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecalcEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecalcEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecalcEngine_RecalcAll(This,fForce)	\
    (This)->lpVtbl -> RecalcAll(This,fForce)

#define IRecalcEngine_OnNameSpaceChange(This,pUnk)	\
    (This)->lpVtbl -> OnNameSpaceChange(This,pUnk)

#define IRecalcEngine_SetExpression(This,pUnk,dispid,strExpression,language)	\
    (This)->lpVtbl -> SetExpression(This,pUnk,dispid,strExpression,language)

#define IRecalcEngine_GetExpression(This,pUnk,dispid,pstrExpression,pstrLanguage)	\
    (This)->lpVtbl -> GetExpression(This,pUnk,dispid,pstrExpression,pstrLanguage)

#define IRecalcEngine_ClearExpression(This,pUnk,dispid)	\
    (This)->lpVtbl -> ClearExpression(This,pUnk,dispid)

#define IRecalcEngine_BeginStyle(This,pObject)	\
    (This)->lpVtbl -> BeginStyle(This,pObject)

#define IRecalcEngine_EndStyle(This,pObject)	\
    (This)->lpVtbl -> EndStyle(This,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRecalcEngine_RecalcAll_Proxy( 
    IRecalcEngine __RPC_FAR * This,
    /* [in] */ BOOL fForce);


void __RPC_STUB IRecalcEngine_RecalcAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_OnNameSpaceChange_Proxy( 
    IRecalcEngine __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB IRecalcEngine_OnNameSpaceChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_SetExpression_Proxy( 
    IRecalcEngine __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ LPOLESTR strExpression,
    LPOLESTR language);


void __RPC_STUB IRecalcEngine_SetExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_GetExpression_Proxy( 
    IRecalcEngine __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ DISPID dispid,
    /* [out] */ BSTR __RPC_FAR *pstrExpression,
    /* [out] */ BSTR __RPC_FAR *pstrLanguage);


void __RPC_STUB IRecalcEngine_GetExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_ClearExpression_Proxy( 
    IRecalcEngine __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ DISPID dispid);


void __RPC_STUB IRecalcEngine_ClearExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_BeginStyle_Proxy( 
    IRecalcEngine __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pObject);


void __RPC_STUB IRecalcEngine_BeginStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcEngine_EndStyle_Proxy( 
    IRecalcEngine __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pObject);


void __RPC_STUB IRecalcEngine_EndStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecalcEngine_INTERFACE_DEFINED__ */


#ifndef __IRecalcHost_INTERFACE_DEFINED__
#define __IRecalcHost_INTERFACE_DEFINED__

/* interface IRecalcHost */
/* [version][local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRecalcHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f497-98b5-11cf-bb82-00aa00bdce0b")
    IRecalcHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompileExpression( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            /* [in] */ LPOLESTR strLanguage,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppExpressionObject,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppThis) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvalExpression( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            /* [in] */ LPOLESTR strLanguage,
            /* [out] */ VARIANT __RPC_FAR *pvResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResolveNames( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ unsigned int cNames,
            /* [in] */ BSTR __RPC_FAR *pstrNames,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjects,
            /* [out] */ DISPID __RPC_FAR *pDispids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestRecalc( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ VARIANT __RPC_FAR *pv,
            /* [in] */ BOOL fStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveValue( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptTextAttributes( 
            /* [in] */ LPCOLESTR szLanguage,
            /* [in] */ LPCOLESTR pchCode,
            /* [in] */ ULONG cchCode,
            /* [in] */ LPCOLESTR szDelim,
            /* [in] */ DWORD dwFlags,
            /* [out] */ WORD __RPC_FAR *pwAttr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecalcHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRecalcHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRecalcHost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRecalcHost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompileExpression )( 
            IRecalcHost __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            /* [in] */ LPOLESTR strLanguage,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppExpressionObject,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppThis);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EvalExpression )( 
            IRecalcHost __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ LPOLESTR strExpression,
            /* [in] */ LPOLESTR strLanguage,
            /* [out] */ VARIANT __RPC_FAR *pvResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResolveNames )( 
            IRecalcHost __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ unsigned int cNames,
            /* [in] */ BSTR __RPC_FAR *pstrNames,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjects,
            /* [out] */ DISPID __RPC_FAR *pDispids);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestRecalc )( 
            IRecalcHost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRecalcHost __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [in] */ VARIANT __RPC_FAR *pv,
            /* [in] */ BOOL fStyle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveValue )( 
            IRecalcHost __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptTextAttributes )( 
            IRecalcHost __RPC_FAR * This,
            /* [in] */ LPCOLESTR szLanguage,
            /* [in] */ LPCOLESTR pchCode,
            /* [in] */ ULONG cchCode,
            /* [in] */ LPCOLESTR szDelim,
            /* [in] */ DWORD dwFlags,
            /* [out] */ WORD __RPC_FAR *pwAttr);
        
        END_INTERFACE
    } IRecalcHostVtbl;

    interface IRecalcHost
    {
        CONST_VTBL struct IRecalcHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecalcHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecalcHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecalcHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecalcHost_CompileExpression(This,pUnk,dispid,strExpression,strLanguage,ppExpressionObject,ppThis)	\
    (This)->lpVtbl -> CompileExpression(This,pUnk,dispid,strExpression,strLanguage,ppExpressionObject,ppThis)

#define IRecalcHost_EvalExpression(This,pUnk,dispid,strExpression,strLanguage,pvResult)	\
    (This)->lpVtbl -> EvalExpression(This,pUnk,dispid,strExpression,strLanguage,pvResult)

#define IRecalcHost_ResolveNames(This,pUnk,dispid,cNames,pstrNames,ppObjects,pDispids)	\
    (This)->lpVtbl -> ResolveNames(This,pUnk,dispid,cNames,pstrNames,ppObjects,pDispids)

#define IRecalcHost_RequestRecalc(This)	\
    (This)->lpVtbl -> RequestRecalc(This)

#define IRecalcHost_SetValue(This,pUnk,dispid,pv,fStyle)	\
    (This)->lpVtbl -> SetValue(This,pUnk,dispid,pv,fStyle)

#define IRecalcHost_RemoveValue(This,pUnk,dispid)	\
    (This)->lpVtbl -> RemoveValue(This,pUnk,dispid)

#define IRecalcHost_GetScriptTextAttributes(This,szLanguage,pchCode,cchCode,szDelim,dwFlags,pwAttr)	\
    (This)->lpVtbl -> GetScriptTextAttributes(This,szLanguage,pchCode,cchCode,szDelim,dwFlags,pwAttr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRecalcHost_CompileExpression_Proxy( 
    IRecalcHost __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ LPOLESTR strExpression,
    /* [in] */ LPOLESTR strLanguage,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppExpressionObject,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppThis);


void __RPC_STUB IRecalcHost_CompileExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_EvalExpression_Proxy( 
    IRecalcHost __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ LPOLESTR strExpression,
    /* [in] */ LPOLESTR strLanguage,
    /* [out] */ VARIANT __RPC_FAR *pvResult);


void __RPC_STUB IRecalcHost_EvalExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_ResolveNames_Proxy( 
    IRecalcHost __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ unsigned int cNames,
    /* [in] */ BSTR __RPC_FAR *pstrNames,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjects,
    /* [out] */ DISPID __RPC_FAR *pDispids);


void __RPC_STUB IRecalcHost_ResolveNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_RequestRecalc_Proxy( 
    IRecalcHost __RPC_FAR * This);


void __RPC_STUB IRecalcHost_RequestRecalc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_SetValue_Proxy( 
    IRecalcHost __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ DISPID dispid,
    /* [in] */ VARIANT __RPC_FAR *pv,
    /* [in] */ BOOL fStyle);


void __RPC_STUB IRecalcHost_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_RemoveValue_Proxy( 
    IRecalcHost __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ DISPID dispid);


void __RPC_STUB IRecalcHost_RemoveValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecalcHost_GetScriptTextAttributes_Proxy( 
    IRecalcHost __RPC_FAR * This,
    /* [in] */ LPCOLESTR szLanguage,
    /* [in] */ LPCOLESTR pchCode,
    /* [in] */ ULONG cchCode,
    /* [in] */ LPCOLESTR szDelim,
    /* [in] */ DWORD dwFlags,
    /* [out] */ WORD __RPC_FAR *pwAttr);


void __RPC_STUB IRecalcHost_GetScriptTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecalcHost_INTERFACE_DEFINED__ */


#ifndef __IRecalcProperty_INTERFACE_DEFINED__
#define __IRecalcProperty_INTERFACE_DEFINED__

/* interface IRecalcProperty */
/* [version][local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRecalcProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5d6-98b5-11cf-bb82-00aa00bdce0b")
    IRecalcProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCanonicalProperty( 
            DISPID dispid,
            IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
            DISPID __RPC_FAR *pdispid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecalcPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRecalcProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRecalcProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRecalcProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCanonicalProperty )( 
            IRecalcProperty __RPC_FAR * This,
            DISPID dispid,
            IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
            DISPID __RPC_FAR *pdispid);
        
        END_INTERFACE
    } IRecalcPropertyVtbl;

    interface IRecalcProperty
    {
        CONST_VTBL struct IRecalcPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecalcProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecalcProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecalcProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecalcProperty_GetCanonicalProperty(This,dispid,ppUnk,pdispid)	\
    (This)->lpVtbl -> GetCanonicalProperty(This,dispid,ppUnk,pdispid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRecalcProperty_GetCanonicalProperty_Proxy( 
    IRecalcProperty __RPC_FAR * This,
    DISPID dispid,
    IUnknown __RPC_FAR *__RPC_FAR *ppUnk,
    DISPID __RPC_FAR *pdispid);


void __RPC_STUB IRecalcProperty_GetCanonicalProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecalcProperty_INTERFACE_DEFINED__ */


#ifndef __IRecalcHostDebug_INTERFACE_DEFINED__
#define __IRecalcHostDebug_INTERFACE_DEFINED__

/* interface IRecalcHostDebug */
/* [version][local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRecalcHostDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5f7-98b5-11cf-bb82-00aa00bdce0b")
    IRecalcHostDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectInfo( 
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pbstrID,
            /* [out] */ BSTR __RPC_FAR *pbstrMember,
            /* [out] */ BSTR __RPC_FAR *pbstrTag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecalcHostDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRecalcHostDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRecalcHostDebug __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRecalcHostDebug __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectInfo )( 
            IRecalcHostDebug __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnk,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pbstrID,
            /* [out] */ BSTR __RPC_FAR *pbstrMember,
            /* [out] */ BSTR __RPC_FAR *pbstrTag);
        
        END_INTERFACE
    } IRecalcHostDebugVtbl;

    interface IRecalcHostDebug
    {
        CONST_VTBL struct IRecalcHostDebugVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecalcHostDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecalcHostDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecalcHostDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecalcHostDebug_GetObjectInfo(This,pUnk,dispid,pbstrID,pbstrMember,pbstrTag)	\
    (This)->lpVtbl -> GetObjectInfo(This,pUnk,dispid,pbstrID,pbstrMember,pbstrTag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRecalcHostDebug_GetObjectInfo_Proxy( 
    IRecalcHostDebug __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnk,
    /* [in] */ DISPID dispid,
    /* [out] */ BSTR __RPC_FAR *pbstrID,
    /* [out] */ BSTR __RPC_FAR *pbstrMember,
    /* [out] */ BSTR __RPC_FAR *pbstrTag);


void __RPC_STUB IRecalcHostDebug_GetObjectInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecalcHostDebug_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\regext.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//
// State and Notification Broker
//
// This file defines the State and Notification Broker API.
// For the list of specific states and notifications available from the 
// State and Notification Broker, see SNApi.h
//
#pragma once

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

#define E_ALREADY_REGISTERED         HRESULT_FROM_WIN32(ERROR_ALREADY_REGISTERED)
#define E_DATATYPE_MISMATCH          HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)
#define E_INSUFFICIENT_BUFFER        HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
#define E_INVALID_HANDLE             HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE)
#define E_NOT_READY                  HRESULT_FROM_WIN32(ERROR_NOT_READY)
#define E_NOT_FOUND                  HRESULT_FROM_WIN32(ERROR_NOT_FOUND)

DECLARE_HANDLE(HREGNOTIFY); // transient notification handle


// **************************************************************************
// Enumeration Name: REG_COMPARISONTYPE
// 
// Purpose: used to define how state property values should be compared to
//          target values for conditional change notifications. When executing 
//          the REG_COMPARISONTYPE, the changed value is always used as the
//          l-value, that is, REG_CT_LESS would mean fire the notification if
//          the changed value is less than the target value.
//
// Description:
//    the following shows what statements will be true when the comparison is
//    done. In the actual implementation a case insensitive CompareString using
//    the system locale (LOCALE_SYSTEM_DEFAULT) is used to compare the strings,
//    and the DWORDs are always masked before the comparison. The following
//    information is just to clarify the intent of the REG_COMPARISONTYPE
//    values.
//    Let "cv" represent the changed value and "psz" or "dw" represent the
//    TargetValue specified in the NOTIFICATIONCONDITION structure. Let "l"
//    represent the length of the string specified in psz (wcslen(psz)) and
//    "cvl" represents the string length of the changed value (wcslen(cv)).
//                                        REG_SZ                REG_DWORD
//    REG_CT_ANYCHANGE        |           always             |   always   |
//    REG_CT_EQUAL            | (0 == strcmp(cv, psz))       | (cv == dw) |
//    REG_CT_NOT_EQUAL        | (0 != strcmp(cv, psz))       | (cv != dw) | 
//    REG_CT_GREATER          | (0 <  strcmp(cv, psz))       | (cv >  dw) |
//    REG_CT_GREATER_OR_EQUAL | (0 <= strcmp(cv, psz))       | (cv >= dw) | 
//    REG_CT_LESS             | (0 >  strcmp(cv, psz))       | (cv <  dw) |
//    REG_CT_LESS_OR_EQUAL    | (0 >= strcmp(cv, psz))       | (cv <= dw) |
//    REG_CT_CONTAINS         | (0 != strstr(cv, psz))       |     N/A    |
//    REG_CT_STARTS_WITH      | (0 == strncmp(cv, psz, l))   |     N/A    |
//    REG_CT_ENDS_WITH        | (0 == strcmp(cv+cvl-l, psz)) |     N/A    |
//
// **************************************************************************
typedef enum tagREG_COMPARISONTYPE 
{ 
    REG_CT_ANYCHANGE,
    REG_CT_EQUAL,
    REG_CT_NOT_EQUAL,
    REG_CT_GREATER,
    REG_CT_GREATER_OR_EQUAL,
    REG_CT_LESS,
    REG_CT_LESS_OR_EQUAL,
    REG_CT_CONTAINS,
    REG_CT_STARTS_WITH,
    REG_CT_ENDS_WITH
} REG_COMPARISONTYPE;


// **************************************************************************
// Structure Name: NOTIFICATIONCONDITION
// 
// Purpose: used to define a condition under which property state change
//          notifications should be fired
//
// Description:
//    REG_COMPARSIONTYPE ctComparisonType - how to compare the changed value
//                                          with the value specified in
//                                          TargetValue
//    DWORD dwMask - If this value is set to any value other than 0 then
//                   TargetValue is interpreted as a DWORD. This mask is applied
//                   to the changed DWORD value as well as TargetValue before
//                   the comparison is done. If this value is set to 0 then
//                   TargetValue is interpreted as a string.
//    union TargetValue - if dwMask is set to 0 then the comparison is done
//                        between psz and the changed value. If dwMask is set
//                        to any value other than 0 then the comparison is done
//                        between the masked dw and the masked changed value.
//                        If the changed value is not of type REG_SZ nor
//                        REG_DWORD or if the changed value is of type REG_DWORD
//                        and dwMask is set to 0 or if the changed value is of
//                        type REG_SZ and dwMask is not set to 0, then the
//                        notification is ignored. If the changed value is
//                        deleted and the comparison is to be done against dw,
//                        0 is used as the changed value and the comparison
//                        proceeds as usual. If the value is deleted and the
//                        comparison is to be done against psz, NULL is used as
//                        the changed value and only REG_CT_EQUAL and
//                        REG_CT_NOT_EQUAL are processed by the comparison, the
//                        deletion notification is ignored if any other
//                        ctComparisonType is used. When REG_CT_ANYCHANGE is
//                        specified for ctComparisonType, this value is ignored.
//
// **************************************************************************
typedef struct tagNOTIFICATIONCONDITION
{
    REG_COMPARISONTYPE ctComparisonType;
    DWORD dwMask;
    union
    {
        LPCTSTR psz;
        DWORD dw;
    } TargetValue;
} NOTIFICATIONCONDITION;


// **************************************************************************
// Flags: RNAF_*
//
// Purpose: defines the flags that can be passed to RegistryNotifyApp
//
// Description:
//    RNAF_NONAMEONCMDLINE - the "/notify "pszName"" string will not be passed
//                           on the command line to the application when
//                           launched
//
// **************************************************************************
#define RNAF_NONAMEONCMDLINE 0x00000001


// **************************************************************************
// Structure Name: NOTIFYMSGQUEUEPACKET
// 
// Purpose: used to define the layout of the packets sent to the message queue
//          in RegistryNotifyMsgQueue
//
// Description:
//    HREGNOTIFY hNotify - the same hNotify as returned in phNotify on the call
//                         to RegistryNotifyMsgQueue
//    DWORD dwUserData -  the user data passed as dwUserData on the call to
//                        RegistryNotifyMsgQueue
//    UINT cbData - the number of bytes to follow (for deletes this value is 0)
//    BYTE rgData[] - the new value for pszValueName
//
// **************************************************************************
typedef struct tagNOTIFYMSGQUEUEPACKET
{
    HREGNOTIFY hNotify;
    DWORD dwUserData;
    UINT cbData;
    BYTE rgData[1];
} NOTIFYMSGQUEUEPACKET;


// **************************************************************************
// Function Prototype: REGISTRYNOTIFYCALLBACK
//
// Purpose: defines the prototype of the callback used by RegistryNotifyCallback
//
// Arguments:
//    IN HREGNOTIFY hNotify - the handle to a valid HREGNOTIFY, this will be the
//                            same handle returned from RegistryNotifyCallback
//    IN DWORD dwUserData - user data that was passed to RegistryNotifyCallback
//    IN const PBYTE pData - a pointer to the new value for the value, this
//                           will be set to NULL if the value was deleted
//    IN const UINT cbData - the number of bytes to pointed to by pData, this
//                           value will be set to 0 if the value was deleted
//
// Description:
//    this callback is used to notify clients that registered for notifications
//    using RegistryNotifyCallback. It is safe to call RegistryCloseNotification
//    from within the callback if no further notifications are required. All
//    notifications happen synchronously, so it is important to not block while
//    executing this callback.
//
// **************************************************************************
typedef void (*REGISTRYNOTIFYCALLBACK)(HREGNOTIFY hNotify,
                                       DWORD dwUserData,
                                       const PBYTE pData,
                                       const UINT cbData);


// **************************************************************************
// Function Name: RegistryGetDWORD
// 
// Purpose: used to read a REG_DWORD registry value
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value to retrieve (may be NULL
//                              to retrieve the default value)
//    OUT DWORD * pdwData - a pointer to the buffer which will receive the 
//                          data associated with the value
//
// Return Values:
//    HRESULT
//    S_OK - the data was copied to the buffer
//    E_INVALIDARG - hKey or pdwData is invalid
//    E_DATATYPE_MISMATCH - the value is not of type REG_DWORD
//    An error value returned from RegOpenKeyEx or RegQueryValueEx wrapped as 
//    a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - pData points to the data associated with the value
//    FAILED - no change.
// 
// Description:
//    the DWORD associated with the value is copied to the buffer pointed to
//    by pData. If the key pointed to by hKey+pszSubKey does not exist,
//    RegistryGetDWORD will fail since it uses RegOpenKey to access the key
//
// **************************************************************************
HRESULT WINAPI RegistryGetDWORD(HKEY hKey,
                                LPCTSTR pszSubKey,
                                LPCTSTR pszValueName,
                                DWORD * pdwData);


// **************************************************************************
// Function Name: RegistryGetString
// 
// Purpose: used to read a REG_SZ registry value
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value to retrieve (may be NULL
//                              to retrieve the default value)
//    OUT LPTSTR pszData - a pointer to the buffer which will receive the 
//                          data associated with the value
//    IN UINT cchData - a pointer to the variable which is length in characters
//                      of the buffer pointed to by pData
//
// Return Values:
//    HRESULT
//    S_OK - the data was copied to the buffer
//    E_INVALIDARG - hKey or pszData is invalid
//    E_DATATYPE_MISMATCH - the value is not of type REG_SZ
//    E_INSUFFICIENT_BUFFER - the size of the buffer pointed to by pszData, as
//                            determined by cchData is not large enough to hold
//                            the string
//    An error value returned from RegOpenKeyEx or RegQueryValueEx wrapped as 
//    a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - pData points to the data associated with the value
//    FAILED - no change.
// 
// Description:
//    the string associated with the value is copied to the buffer pointed to
//    by pData. If the key pointed to by hKey+pszSubKey does not exist, 
//    RegistryGetString will fail since it uses RegOpenKey to access the key
//
// **************************************************************************
HRESULT WINAPI RegistryGetString(HKEY hKey,
                                 LPCTSTR pszSubKey,
                                 LPCTSTR pszValueName,
                                 LPTSTR pszData,
                                 UINT cchData);


// **************************************************************************
// Function Name: RegistrySetDWORD
// 
// Purpose: used to set a REG_DWORD registry value
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value to set (may be NULL
//                              to set the default value)
//    IN DWORD dwData - the new value
//
// Return Values:
//    HRESULT
//    S_OK - the data value for pszValueName was changed to the data in dwData
//    E_INVALIDARG - hKey is invalid
//    E_DATATYPE_MISMATCH - the value is not of type REG_DWORD
//    An error value returned from RegOpenKeyEx or RegQueryValueEx wrapped as 
//    a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - the data associated with the value was changed
//    FAILED - no change
// 
// Description:
//    the data associated with the value is changed to the new value. If the
//    key pointed to by hKey+pszSubKey does not exist, RegistrySetDWORD will
//    fail since it uses RegOpenKey to access the key
//
// **************************************************************************
HRESULT WINAPI RegistrySetDWORD(HKEY hKey,
                                LPCTSTR pszSubKey,
                                LPCTSTR pszValueName,
                                DWORD dwData);


// **************************************************************************
// Function Name: RegistrySetString
// 
// Purpose: used to set a REG_SZ registry value
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value to set (may be NULL
//                              for to set the default value)
//    IN LPCTSTR pszData - the new value. This string must be null terminated.
//
// Return Values:
//    HRESULT
//    S_OK - the data value for pszValueName was changed to the data in pszData
//    E_INVALIDARG - hKey or pszData is invalid
//    E_DATATYPE_MISMATCH - the value is not of type REG_SZ
//    An error value returned from RegOpenKeyEx or RegQueryValueEx wrapped as 
//    a FACILITY_WIN32 HRESULT
//    An error HRESULT returned from StringCbLength
//
// Results:
//    SUCCEEDED - the data associated with the value was changed
//    FAILED - no change
// 
// Description:
//    the data associated with the value is changed to the new value. If the
//    key pointed to by hKey+pszSubKey does not exist, RegistrySetString will
//    fail since it uses RegOpenKey to access the key
//
// **************************************************************************
HRESULT WINAPI RegistrySetString(HKEY hKey,
                                 LPCTSTR pszSubKey,
                                 LPCTSTR pszValueName,
                                 LPCTSTR pszData);

// **************************************************************************
// Function Name: RegistryDeleteValue
// 
// Purpose: used to delete a registry value
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value to delete (may be NULL
//                              to delete the default value)
//
// Return Values:
//    HRESULT
//    S_OK - The value was deleted successfully
//    S_FALSE - The key or value does not exist.
//    E_INVALIDARG - hKey is invalid
//
// Results:
//    SUCCEEDED - The value pszValueName under the key hKey and subkey pszSubKey is
//                deleted
//    FAILED - no change.
// 
// Description:
//    The value under the hKey+pszSubKey will be deleted if it exists, if the value
//    does not exist, there is no change and this method will succeed.
//    If the key pointed to by hKey+pszSubKey does not exist,
//    RegistryDeleteValue will fail since it uses RegOpenKey to access the key
//
// **************************************************************************
HRESULT WINAPI RegistryDeleteValue(HKEY hKey, 
                                   LPCTSTR pszSubKey,
                                   LPCTSTR pszValueName);

// **************************************************************************
// Function Name: RegistryTestExchangeDWORD
// 
// Purpose: used to atomically set a value based on a condition
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value to set (may be NULL
//                              to set the default value)
//    IN DWORD dwOldValue - the value to check against
//    IN DWORD dwNewValue - the value to set conditionally
//
// Return Values:
//    HRESULT
//    S_OK - the data value was changed to dwNewValue
//    S_FALSE - the target value was not set to dwNewValue because the DWORD
//              value assocated with pszValueName was not equal to dwOldValue
//    E_INVALIDARG - the handle or one of the pointers passed in was invalid
//    E_DATATYPE_MISMATCH - the value is not of type REG_DWORD
//    An error value wrapped as a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - the data value associated with pszData was dwOldValue and is
//                now dwNewValue
//    FAILED - no change
//
// Description:
//    This function acts the same way as the Win32 InterlockedTestExchange
//    function. Is an interlocked function -- in other words, it can be
//    considered atomic. It checks to see if the DWORD value associated with
//    pszValueName is equal to OldValue. If so, it sets the target to NewValue,
//    otherwise, it fails.
//
// **************************************************************************
HRESULT WINAPI RegistryTestExchangeDWORD(HKEY hKey,
                                         LPCTSTR pszSubKey,
                                         LPCTSTR pszValueName,
                                         DWORD dwOldValue,
                                         DWORD dwNewValue);


// **************************************************************************
// Function Name: RegistryNotifyApp
// 
// Purpose: used to request that an app be launched or notified when a
//          specified value has been changed
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value on which change
//                              notifications are requested (may be NULL to
//                              indicate the default value)
//    IN LPCTSTR pszName - a case insensitive user defined string representing
//                         this notification request, the string should be
//                         passed to RegistryStopNotification when notifications
//                         are no longer needed. Each notification in the system
//                         must have a unique name.
//    IN LPCTSTR pszApp - pointer to string that is the path to the executable
//                        to launch
//    IN LPCTSTR pszClass  - once the executable is launched, or if it is
//    IN LPCTSTR pszWindow   already running, a window with this window name and
//                           class type is located in the process and the
//                           notification is passed to it. If both of these
//                           parameter are null this function will only launch
//                           the application.
//    IN UINT msg - the message that will be passed to the window
//    IN DWORD dwFlags - one or more of the RNAF_* flags which will define the
//                       behavior of RegistryNotifyApp
//    IN NOTIFICATIONCONDITION * pCondition - the condition under which change
//                                            notifications should be sent when
//                                            a comparison of it to the new
//                                            registry value is TRUE (may be
//                                            NULL to indicate that any change
//                                            should result in a notification)
//
// Return Values:
//    HRESULT
//    S_OK - the request for notification has been added to the notification 
//           list
//    E_INVALIDARG - hKey, pszApp or pszName is invalid
//    E_ALREADY_REGISTERED - a notification with a name equal to that specified
//                           by pszName already exists
//    An error value wrapped as a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - the caller will now be notified every time a change to this
//                value is made.
//    FAILED - no change
//
// Description:  
//    The notification request is added to the notification list. The caller
//    must call RegistryStopNotification to stop further notifications. This
//    type of notification request is permanent, that is, the notification
//    request will be active even if the device is reset. On notification, this
//    function will determine if an executable with the name specified in pszApp
//    is already running by doing a FindWindow on the class name and window name
//    specified by pszClass and pszWindow, if not it launches the app. The
//    command line passed to the application should be specified in the pszApp
//    string. If RNAF_NONAMEONCMDLINE is not specified in dwFlags, the following
//    is also appended to the user defined command line:
//        /notify "pszName"
//        pszName - the handle string passed to the function in the pszName
//                  parameter
//    After the app is launched a FindWindow is done looking for a window with 
//    the class name and window name specified in pszClass and pszWindow. If the
//    window is found, the message specified by msg is posted exactly as in
//    RegistryNotifyWindow, via PostMessage. The parameters to the PostMessage
//    are as follows:
//        WPARAM - for values of type REG_DWORD this is the new value or 0
//                 if the value was deleted; for all other types this value
//                 is 0
//        LPARAM - 0
//    The msg parameter should be unique for each call to RegistryNotifyApp
//    so that the client can differentiate between the multiple notifications.
//    The client will be notified when the value is added as well as on changes.
//    When a notification arrives, if the application pointed to by pszApp can
//    not be launched or a window with a class of type pszClass can not be found
//    or the PostMessage fails, the notification will be removed from the
//    notification list.
//    It is also possible to preregister a RegistryNotifyApp notification by
//    adding the notification directly to the registry. The notification will
//    become active the next time the device is soft reset. The registry format
//    is as follows (<notification name> represents the identifier of the
//    notification, that is, the name to pass to RegistryStopNotification):
//    [HKEY_LOCAL_MACHINE\System\Notifications\<notification name>]
//      ; the following are required
//        "HKEY"=dword:0x80000001                       ; a root registry key
//        "Application"="MyApp.exe param1 param2"         ; the app to launch
//        "Trust"=dword:0  ; trust level required to delete this notification
//      ; the following are optional
//        "Key"="System\\State"                       ; the registry key path
//        "Value Name"="SomeState"                       ; the value to watch
//        "Class Name"="MYWNDCLASS"              ; the class name to look for 
//        "Window Name"="My Window"             ; the window name to look for
//        "Message"=dword:400                           ; the message to post
//        "Flags"=dword:1                   ; any combination of RNAF_* flags
//        "Conditional Comparison"=dword:1             ; a REG_COMPARISONTYPE
//        "Conditional Mask"=dword:0                   ; the conditional mask
//        "Conditional Target"="change"          ; the psz conditional target
//        "Conditional Target"=dword:1            ; the dw conditional target
// **************************************************************************
HRESULT WINAPI RegistryNotifyApp(HKEY hKey,
                                 LPCTSTR pszSubKey,
                                 LPCTSTR pszValueName,
                                 LPCTSTR pszName,
                                 LPCTSTR pszApp,
                                 LPCTSTR pszClass,
                                 LPCTSTR pszWindow,
                                 UINT msg,
                                 DWORD dwFlags,
                                 NOTIFICATIONCONDITION * pCondition);


// **************************************************************************
// Function Name: RegistryNotifyWindow
// 
// Purpose: used to request that a window be notified when a specified value
//          has been changed
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value on which change
//                              notifications are requested (may be NULL to
//                              indicate the default value)
//    IN HWND hWnd - the handle of the window to which the message will be sent
//    IN UINT msg - the message that will be passed to the window
//    IN DWORD dwUserData - user data that will be passed back to the user
//                          with the notification
//    IN NOTIFICATIONCONDITION * pCondition - the condition under which change
//                                            notifications should be sent when
//                                            a comparison of it to the new
//                                            registry value is TRUE (may be
//                                            NULL to indicate that any change
//                                            should result in a notification)
//    OUT HREGNOTIFY * phNotify - receives the handle to the notification
//                                request. This handle should be closed using
//                                RegistryCloseNotification when notifications
//                                on this key are no longer needed.
//
// Return Values:
//    HRESULT
//    S_OK - the request for notification has been added to the notification
//           list
//    E_INVALIDARG - hKey, phNotify or hWnd is invalid
//    An error value wrapped as a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - the caller will now be notified every time a change to this
//                value is made.
//    FAILED - no change
// 
// Description:
//    The msg parameter should be unique for each call to RegistryNotifyWindow
//    so that the client can differentiate between the multiple notifications.
//    The notification request is added to the notification list. The caller
//    must call RegistryCloseNotification to stop further notifications and to
//    close the notification handle. This type of notification request is
//    transient, that is, if the device is reset the notification request will
//    no longer exist. When the value specified by pszValueName is changed, the
//    client is notified via a PostMessage. If the PostMessage fails or the
//    window specified by hWnd is no longer valid the notification request is
//    removed from the notification queue and the handle returned in phNotify
//    is closed.
//    The parameters passed on the PostMessage are as follows:
//      WPARAM - for values of type REG_DWORD this is the new value or 0
//               if the value was deleted; for all other types this value is 0
//      LPARAM - the value passed in on dwUserData
//    If the value does not exist at the time of the call to
//    RegistryNotifyWindow, the client will be notified when the value is added.
//
// **************************************************************************
HRESULT WINAPI RegistryNotifyWindow(HKEY hKey,
                                    LPCTSTR pszSubKey,
                                    LPCTSTR pszValueName,
                                    HWND hWnd,
                                    UINT msg,
                                    DWORD dwUserData,
                                    NOTIFICATIONCONDITION * pCondition,
                                    HREGNOTIFY * phNotify);


// **************************************************************************
// Function Name: RegistryNotifyMsgQueue
// 
// Purpose: used to request that a message queue be notified when a specified
//          value has been changed
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value on which change
//                              notifications are requested (may be NULL to
//                              indicate the default value)
//    IN LPCTSTR pszMsgQueue - A pointer to a string that is the name of the
//                             message queue to notify. If this message queue
//                             has not yet been created, RegistryNotifyMsgQueue
//                             will create it.
//    IN DWORD dwUserData - user data that will be passed back to the user
//                          with the notification
//    IN NOTIFICATIONCONDITION * pCondition - the condition under which change
//                                            notifications should be sent when
//                                            a comparison of it to the new
//                                            registry value is TRUE (may be
//                                            NULL to indicate that any change
//                                            should result in a notification)
//    OUT HREGNOTIFY * phNotify - receives the handle to the notification
//                                request. This handle should be closed using
//                                RegistryCloseNotification when notifications
//                                on this key are no longer needed.
//
// Return Values:
//    HRESULT
//    S_OK - the request for notification has been added to the notification
//           list
//    E_INVALIDARG - hKey, phNotify, or pszMsgQueue is invalid
//    An error value wrapped as a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - the caller will now be notified every time a change to this
//                value is made.
//    FAILED - no change
// 
// Description:  
//    The notification request is added to the notification list. The caller
//    must call RegistryCloseNotification to stop further notifications and
//    close the notification handle. This type of notification request is
//    transient, that is, if the device is reset the notification request will
//    no longer exist. The client will be notified of changes via the message
//    queue. Once the client is notified, information about the changed key can
//    be retrieved using the ReadMsgQueue function. The data returned is in the
//    following format:
//      | HREGNOTIFY hNotify | DWORD dwUserData | UINT byte count | BYTE[] new value |
//      hNotify - the same hNotify as returned in phNotify
//      dwUserData - the user data passed as dwUserData
//      byte count - the number of bytes to follow (for deletes this value is 0)
//      new value - the new value for pszValueName
//    The data sent to the message queue can be cast to a NOTIFYMSGQUEUEPACKET
//    for easier access. If the value does not exist at the time of the call to
//    RegistryNotifyMsgQueue, the client will be notified when the value is
//    added.
//
// **************************************************************************
HRESULT WINAPI RegistryNotifyMsgQueue(HKEY hKey,
                                      LPCTSTR pszSubKey,
                                      LPCTSTR pszValueName,
                                      LPCTSTR pszMsgQueue,
                                      DWORD dwUserData,
                                      NOTIFICATIONCONDITION * pCondition,
                                      HREGNOTIFY * phNotify);


// **************************************************************************
// Function Name: RegistryNotifyCallback
//
// Purpose: used to request that a callback be notified when a specified
//          value has been changed
//
// Arguments:
//    IN HKEY hKey - handle to a currently open key, or a predefined root value
//    IN LPCTSTR pszSubKey - the key under which the value is stored (if this
//                           value is null pszValueName is assumed to be under
//                           hKey)
//    IN LPCTSTR pszValueName - the name of the value on which change
//                              notifications are requested (may be NULL to
//                              indicate the default value)
//    IN REGISTRYNOTIFYCALLBACK pfnRegistryNotifyCallback - A pointer to a
//                                                          function that will
//                                                          be called back when
//                                                          a notification
//                                                          arrives
//    IN DWORD dwUserData - user data that will be passed back to the user
//                          with the notification
//    IN NOTIFICATIONCONDITION * pCondition - the condition under which change
//                                            notifications should be sent when
//                                            a comparison of it to the new
//                                            registry value is TRUE (may be
//                                            NULL to indicate that any change
//                                            should result in a notification)
//    OUT HREGNOTIFY * phNotify - receives the handle to the notification
//                                request. This handle should be closed using
//                                RegistryCloseNotification when notifications
//                                on this key are no longer needed.
//
// Return Values:
//    HRESULT
//    S_OK - the request for notification has been added to the notification
//           list
//    E_INVALIDARG - hKey, phNotify, or pfnRegistryNotifyCallback is invalid
//    An error value wrapped as a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - the caller will now be notified every time a change to this
//                value is made.
//    FAILED - no change
// 
// Description:  
//    The notification request is added to the notification list. The caller
//    must call RegistryCloseNotification to stop further notifications and
//    close the notification handle. This type of notification request is
//    transient, that is, if the device is reset the notification request will
//    no longer exist. The client will be notified of changes via the callback,
//    which is executed on private thread seperate from the thread that called
//    RegistryNotifyCallback. If the value does not exist at the time of the
//    call to RegistryNotifyCallback, the client will be notified when the value
//    is added.
//
// **************************************************************************
HRESULT WINAPI RegistryNotifyCallback(HKEY hKey,
                                      LPCTSTR pszSubKey,
                                      LPCTSTR pszValueName,
                                      REGISTRYNOTIFYCALLBACK pfnRegistryNotifyCallback,
                                      DWORD dwUserData,
                                      NOTIFICATIONCONDITION * pCondition,
                                      HREGNOTIFY * phNotify);


// **************************************************************************
// Function Name: RegistryCloseNotification
// 
// Purpose: used remove a request for notifications from the notification list
//          and close the notification handle
//
// Arguments:
//    IN HREGNOTIFY hNotify - the handle to a valid HREGNOTIFY, must have been
//                            returned one of the RegistryNotify* functions
//
// Return Values:
//    HRESULT
//    S_OK - the notification request was removed from the list
//    E_INVALID_HANDLE - hNotify is invalid
//    An error value wrapped as a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - the notification request has been removed, hNotify is now
//                an invalid handle
//    FAILED - no change
// 
// Description:  
//    the notification list is searched for references to hNotify, if found
//    they are removed the queue and the memory associated with hNotify is
//    freed. Any notifications that have not yet been dispatched to the client
//    will be lost.
//
// **************************************************************************
HRESULT WINAPI RegistryCloseNotification(HREGNOTIFY hNotify);


// **************************************************************************
// Function Name: RegistryStopNotification
// 
// Purpose: used to remove a request for a permanent notification from 
//          the notification list
//
// Arguments:
//    IN LPCTSTR pszName - a case insensitive string representing a permanent
//                         notification that has already been registered using
//                         RegistryNotifyApp
//
// Return Values:
//    HRESULT
//    S_OK - the notification request was removed from the list
//    E_INVALIDARG - pszName is invalid
//    An error value wrapped as a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - the notification request has been removed
//    FAILED - no change
// 
// Description:  
//    The notification list is searched for references to the notification,
//    if found they are removed the queue. Any notifications that have not
//    yet been dispatched to the client will be lost.
//
// **************************************************************************
HRESULT WINAPI RegistryStopNotification(LPCTSTR pszName);


// **************************************************************************
// Function Name: RegistryBatchNotification
// 
// Purpose: used to batch frequently occurring notifications
//
// Arguments:
//    IN HREGNOTIFY hNotify - the handle to a valid HREGNOTIFY, must have been
//                            returned one of the RegistryNotify* functions
//    IN DWORD dwMillisecondsIdle - the number of milliseconds the value should
//                                  be constant before the notification is fired
//    IN DWORD dwMillisecondsMax - the maximum number of milliseconds between
//                                 the time the first change happens and the
//                                 notification is sent
//
// Return Values:
//    HRESULT
//    S_OK - the notification request was removed from the list
//    E_INVALIDARG - dwMillisecondsIdle is set to INFINITE
//    E_INVALID_HANDLE - hNotify is invalid
//    An error value wrapped as a FACILITY_WIN32 HRESULT
//
// Results:
//    SUCCEEDED - the new batch times are set
//    FAILED - no change
// 
// Description:  
//    when a value is changed, the notification system will wait
//    dwMillisecondsIdle milliseconds and then send the notification. If a
//    another change happens during that wait period the timer is reset and
//    the notification system will wait another dwMillisecondsIdle
//    milliseconds to send the notification. In order to ensure that the
//    dwMillisecondsIdle doesn't prevent the notification from ever being
//    sent, dwMillisecondsMax is used. dwMillisecondsMax is the maximum
//    number of milliseconds that can pass from the time the first notification
//    arrives and the time notification is sent. If dwMillisecondsMax is set to
//    INFINITE the notification will batch until the value is idle.
//    dwMillisecondsIdle can not be INFINITE.
//
// **************************************************************************
HRESULT WINAPI RegistryBatchNotification(HREGNOTIFY hNotify,
                                         DWORD dwMillisecondsIdle,
                                         DWORD dwMillisecondsMax);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\refclock.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
//  REFCLOCK.H
//  Implements IReferenceClock Interface

#ifndef __BASEREFCLOCK__
#define __BASEREFCLOCK__

#include <Schedule.h>

const UINT RESOLUTION = 1;                      /* High resolution timer */
const INT ADVISE_CACHE = 4;                     /* Default cache size */
const LONGLONG MAX_TIME = 0x7FFFFFFFFFFFFFFF;   /* Maximum LONGLONG value */

inline LONGLONG WINAPI ConvertToMilliseconds(const REFERENCE_TIME& RT)
{
    /* This converts an arbitrary value representing a reference time
       into a MILLISECONDS value for use in subsequent system calls */

    return (RT / (UNITS / MILLISECONDS));
}

/* This class hierarchy will support an IReferenceClock interface so
   that an audio card (or other externally driven clock) can update the
   system wide clock that everyone uses.

   The interface will be pretty thin with probably just one update method
   This interface has not yet been defined.
 */

/* This abstract base class implements the IReferenceClock
 * interface.  Classes that actually provide clock signals (from
 * whatever source) have to be derived from this class.
 *
 * The abstract class provides implementations for:
 * 	CUnknown support
 *      locking support (CCritSec)
 *	client advise code (creates a thread)
 *
 * Question: what can we do about quality?  Change the timer
 * resolution to lower the system load?  Up the priority of the
 * timer thread to force more responsive signals?
 *
 * During class construction we create a worker thread that is destroyed during
 * destuction.  This thread executes a series of WaitForSingleObject calls,
 * waking up when a command is given to the thread or the next wake up point
 * is reached.  The wakeup points are determined by clients making Advise
 * calls.
 *
 * Each advise call defines a point in time when they wish to be notified.  A
 * periodic advise is a series of these such events.  We maintain a list of
 * advise links and calculate when the nearest event notification is due for.
 * We then call WaitForSingleObject with a timeout equal to this time.  The
 * handle we wait on is used by the class to signal that something has changed
 * and that we must reschedule the next event.  This typically happens when
 * someone comes in and asks for an advise link while we are waiting for an
 * event to timeout.
 *
 * While we are modifying the list of advise requests we
 * are protected from interference through a critical section.  Clients are NOT
 * advised through callbacks.  One shot clients have an event set, while
 * periodic clients have a semaphore released for each event notification.  A
 * semaphore allows a client to be kept up to date with the number of events
 * actually triggered and be assured that they can't miss multiple events being
 * set.
 *
 * Keeping track of advises is taken care of by the CAMSchedule class.
 */

class CBaseReferenceClock
: public CUnknown, public IReferenceClock, public CCritSec
{
protected:
    virtual ~CBaseReferenceClock();     // Don't let me be created on the stack!
public:
    CBaseReferenceClock(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr, CAMSchedule * pSched = 0 );

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void ** ppv);

    DECLARE_IUNKNOWN

    /* IReferenceClock methods */
    // Derived classes must implement GetPrivateTime().  All our GetTime
    // does is call GetPrivateTime and then check so that time does not
    // go backwards.  A return code of S_FALSE implies that the internal
    // clock has gone backwards and GetTime time has halted until internal
    // time has caught up. (Don't know if this will be much use to folk,
    // but it seems silly not to use the return code for something useful.)
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    // When this is called, it sets m_rtLastGotTime to the time it returns.

    /* Provide standard mechanisms for scheduling events */

    /* Ask for an async notification that a time has elapsed */
    STDMETHODIMP AdviseTime(
        REFERENCE_TIME baseTime,        // base reference time
        REFERENCE_TIME streamTime,      // stream offset time
        HEVENT hEvent,                  // advise via this event
        DWORD_PTR *pdwAdviseCookie          // where your cookie goes
    );

    /* Ask for an asynchronous periodic notification that a time has elapsed */
    STDMETHODIMP AdvisePeriodic(
        REFERENCE_TIME StartTime,       // starting at this time
        REFERENCE_TIME PeriodTime,      // time between notifications
        HSEMAPHORE hSemaphore,          // advise via a semaphore
        DWORD_PTR *pdwAdviseCookie          // where your cookie goes
    );

    /* Cancel a request for notification(s) - if the notification was
     * a one shot timer then this function doesn't need to be called
     * as the advise is automatically cancelled, however it does no
     * harm to explicitly cancel a one-shot advise.  It is REQUIRED that
     * clients call Unadvise to clear a Periodic advise setting.
     */

    STDMETHODIMP Unadvise(DWORD_PTR dwAdviseCookie);

    /* Methods for the benefit of derived classes or outer objects */

    // GetPrivateTime() is the REAL clock.  GetTime is just a cover for
    // it.  Derived classes will probably override this method but not
    // GetTime() itself.
    // The important point about GetPrivateTime() is it's allowed to go
    // backwards.  Our GetTime() will keep returning the LastGotTime
    // until GetPrivateTime() catches up.
    virtual REFERENCE_TIME GetPrivateTime();

    /* Provide a method for correcting drift */
    STDMETHODIMP SetTimeDelta( const REFERENCE_TIME& TimeDelta );

    CAMSchedule * GetSchedule() const { return m_pSchedule; }

private:
    REFERENCE_TIME m_rtPrivateTime;     // Current best estimate of time
    DWORD          m_dwPrevSystemTime;  // Last vaule we got from timeGetTime
    REFERENCE_TIME m_rtLastGotTime;     // Last time returned by GetTime
    REFERENCE_TIME m_rtNextAdvise;      // Time of next advise
    UINT           m_TimerResolution;

#ifdef PERF
    int m_idGetSystemTime;
#endif

// Thread stuff
public:
    void TriggerThread()                	// Wakes thread up.  Need to do this if
    {						// time to next advise needs reevaluating.
	EXECUTE_ASSERT(SetEvent(m_pSchedule->GetEvent()));
    }


private:
    BOOL           m_bAbort;            // Flag used for thread shutdown
    HANDLE         m_hThread;           // Thread handle

    HRESULT AdviseThread();             // Method in which the advise thread runs
    static DWORD __stdcall AdviseThreadFunction(LPVOID); // Function used to get there

protected:
    CAMSchedule * const m_pSchedule;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\reftime.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

//
// CRefTime
//
// Manage reference times.
// Shares same data layout as REFERENCE_TIME, but adds some (nonvirtual)
// functions providing simple comparison, conversion and arithmetic.
//
// A reference time (at the moment) is a unit of seconds represented in
// 100ns units as is used in the Win32 FILETIME structure. BUT the time
// a REFERENCE_TIME represents is NOT the time elapsed since 1/1/1601 it
// will either be stream time or reference time depending upon context
//
// This class provides simple arithmetic operations on reference times
//
// keep non-virtual otherwise the data layout will not be the same as
// REFERENCE_TIME


// -----
// note that you are safe to cast a CRefTime* to a REFERENCE_TIME*, but
// you will need to do so explicitly
// -----


#ifndef __REFTIME__
#define __REFTIME__


const LONGLONG MILLISECONDS = (1000);            // 10 ^ 3
const LONGLONG NANOSECONDS = (1000000000);       // 10 ^ 9
const LONGLONG UNITS = (NANOSECONDS / 100);      // 10 ^ 7

/*  Unfortunately an inline function here generates a call to __allmul
    - even for constants!
*/
#define MILLISECONDS_TO_100NS_UNITS(lMs) \
    Int32x32To64((lMs), (UNITS / MILLISECONDS))

class CRefTime
{
public:

    // *MUST* be the only data member so that this class is exactly
    // equivalent to a REFERENCE_TIME.
    // Also, must be *no virtual functions*

    REFERENCE_TIME m_time;

    inline CRefTime()
    {
        // default to 0 time
        m_time = 0;
    };

    inline CRefTime(LONG msecs)
    {
        m_time = MILLISECONDS_TO_100NS_UNITS(msecs);
    };

    inline CRefTime(REFERENCE_TIME rt)
    {
        m_time = rt;
    };

    inline operator REFERENCE_TIME() const
    {
        return m_time;
    };

    inline CRefTime& operator=(const CRefTime& rt)
    {
        m_time = rt.m_time;
        return *this;
    };

    inline CRefTime& operator=(const LONGLONG ll)
    {
        m_time = ll;
        return *this;
    };

    inline CRefTime& operator+=(const CRefTime& rt)
    {
        return (*this = *this + rt);
    };

    inline CRefTime& operator-=(const CRefTime& rt)
    {
        return (*this = *this - rt);
    };

    inline LONG Millisecs(void)
    {
        return (LONG)(m_time / (UNITS / MILLISECONDS));
    };

    inline LONGLONG GetUnits(void)
    {
        return m_time;
    };
};

const LONGLONG TimeZero = 0;

#endif /* __REFTIME__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\recog.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***************************************************************************\
*
* RECOG.H - Handwriting functions, types, and definitions
*
*	Version 1.1
*
*
\***************************************************************************/

#ifndef _INC_RECOG
#define _INC_RECOG

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Suggested sequence for using these APIs:
 *
 *	HwxConfig (once only)
 *		HwxCreate (once per recognition panel)
 *		HwxSetGuide
 *		HwxALCValid
 *		HwxALCPriority
 *		HwxSetContext	(if there is a previous character)
 *			HwxInput	(as the user writes)
 *			HwxProcess  (to process the ink input)
 *			HwxResultsAvailable (find out if new results are available)
 *				HwxGetResults   (every time there are any results available)
 *		HwxEndInput (when user is done inputting ink)
 *		HwxProcess  (to process the ink input)
 *		HwxGetResults (to get the last characters)
 *		HwxDestroy
 */

// The constants below are used with HWXSetAlphabet().  These specify which
// character groupings to recognize.
#define ALC_WHITE			0x00000001	// White space.
#define ALC_LCALPHA			0x00000002	// a..z
#define ALC_UCALPHA			0x00000004	// A..Z
#define ALC_NUMERIC			0x00000008	// 0..9
#define ALC_PUNC			0x00000010	// Standard punc., language dependent.
#define	ALC_NUMERIC_PUNC	0x00000020	// Non digit characters in numbers.
#define ALC_MATH			0x00000040	// %^*()-+={}<>,/.  (??? language dependent ???)
#define ALC_MONETARY		0x00000080	// Punct. in local monetary expressions.
#define	ALC_COMMON_SYMBOLS	0x00000100	// Commonly used symbols from all categories.
#define ALC_OTHER			0x00000200	// Other punctuation not typically used.
#define ALC_ASCII			0x00000400	// 7-bit chars 20..7F
#define ALC_HIRAGANA		0x00000800	// Hiragana (JPN)
#define ALC_KATAKANA		0x00001000	// Katakana (JPN)
#define ALC_KANJI_COMMON	0x00002000	// Common Kanji (JPN)
#define ALC_KANJI_RARE		0x00004000	// Common Kanji (JPN)
#define	ALC_HANGUL_COMMON	0x00008000	// Common Hangul used in Korea.
#define	ALC_HANGUL_RARE		0x00010000	// The rest of the Hangul used in Korea.
#define ALC_UNUSED			0x00FE0000	// Reserved for future use.
#define ALC_OEM				0xFF000000	// OEM recognizer-specific.

// Useful groupings

#define ALC_ALPHA			(ALC_LCALPHA | ALC_UCALPHA)
#define ALC_ALPHANUMERIC	(ALC_ALPHA | ALC_NUMERIC)
#define	ALC_KANA			(ALC_HIRAGANA | ALC_KATAKANA)
#define	ALC_KANJI_ALL		(ALC_KANJI_COMMON | ALC_KANJI_RARE)
#define	ALC_HANGUL_ALL		(ALC_HANGUL_COMMON | ALC_HANGUL_RARE)
#define	ALC_EXTENDED_SYM	(ALC_MATH | ALC_MONETARY | ALC_OTHER)
#define ALC_SYS_MINIMUM		(ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE)
#define ALC_SYS_DEFAULT		(ALC_SYS_MINIMUM | ALC_COMMON_SYMBOLS)

// Standard configurations for various languages.

#define	ALC_USA_COMMON		(ALC_SYS_DEFAULT)
#define	ALC_USA_EXTENDED	(ALC_USA_COMMON | ALC_EXTENDED_SYM)

#define	ALC_JPN_COMMON		(ALC_SYS_DEFAULT | ALC_KANA | ALC_KANJI_COMMON)
#define	ALC_JPN_EXTENDED	(ALC_JPN_COMMON | ALC_EXTENDED_SYM | ALC_KANJI_RARE)

#define	ALC_CHS_COMMON		(ALC_SYS_DEFAULT | ALC_KANJI_COMMON)
#define	ALC_CHS_EXTENDED	(ALC_CHS_COMMON | ALC_EXTENDED_SYM | ALC_KANJI_RARE)

#define	ALC_CHT_COMMON		(ALC_SYS_DEFAULT | ALC_KANJI_COMMON)
#define	ALC_CHT_EXTENDED	(ALC_CHT_COMMON | ALC_EXTENDED_SYM | ALC_KANJI_RARE)

#define	ALC_KOR_COMMON		(ALC_SYS_DEFAULT | ALC_HANGUL_COMMON | ALC_KANJI_COMMON)
#define	ALC_KOR_EXTENDED	(ALC_KOR_COMMON | ALC_EXTENDED_SYM | ALC_HANGUL_RARE | ALC_KANJI_RARE)

// Define ALC mask type.
typedef LONG				ALC;		// Enabled Alphabet
typedef ALC					*PALC;		// ptr to ALC

// Handwriting Recognizer:
DECLARE_HANDLE(HRC);			// Handwriting Recognition Context

typedef HRC			*PHRC;

// Filled in by HwxGetResults().
// The rgChar array is actually a variable sized array of alternate results.  The number of
// alternates is passed into HwxGetResults().
typedef struct tagHWXRESULTS {
    USHORT	indxBox;		// zero-based index into guide structure where char was written
	WCHAR	rgChar[1];		// variable-sized array of characters returned
} HWXRESULTS, *PHWXRESULTS;

// Passed in to HwxSetGuide().  Specifies where the boxes are on the screen.
// All positions are in scaled screen coordinates.  You should do the scaling so
// that cyWriting is around 1000.  To avoid speed and rounding problems you should
// use an integral multiple of your actual size.
// NOTE: the current code requires that the writing area be centered.  E.g. You
// need to set cxBox, cxOffset and cxWriting such that:
//		cxBox == 2 * cxOffset + cxWriting
typedef struct tagHWXGUIDE {
	// Number of input boxes in each direction.
	UINT	cHorzBox;
	UINT	cVertBox;

	// Upper left corner of input area.
	INT		xOrigin;
	INT		yOrigin;

	// Width and height of a single box.
	UINT	cxBox;
	UINT	cyBox;

	// Offset within a box to the upper left of the writing area.
	UINT	cxOffset;
	UINT	cyOffset;

	// Width and height of writing area.
	UINT	cxWriting;
	UINT	cyWriting;

	// Baseline and midline information for western alphabets.  They are measured from
	// the top of the writing area.  These fields are not used and must be set to zero
	// for the East Asian languages (Japanese, Chinese, and Korean).  They must be set to
	// the correct values for English or any other language based on Roman typeface letters.
	UINT	cyMid;
	UINT	cyBase;

	// Writing direction
	UINT	nDir;
} HWXGUIDE, *PHWXGUIDE;

// The following are the currently planned handwriting directions.  Note that a given recognizer
// may not support the requested direction, if this is the case, HwxSetGuide will return an error.

#define	HWX_HORIZONTAL		0
#define	HWX_BIDIRECTIONAL	1
#define	HWX_VERTICAL		2

// Called once to initialize DLL.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxConfig();

// Called to create an HRC before any ink is collected. You can pass in NULL
// for the parameter, but if you pass in an old HRC, it copies the old settings (such
// as alphabet, guide structure, previous context, etc.)
// On failure, use GetLastError() to identify the cause of the error.
HRC		WINAPI HwxCreate(HRC);

// Called to destroy an HRC after recognition is complete.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxDestroy(HRC);

// Tells the HRC where the boxes on the screen are.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetGuide(HRC, HWXGUIDE *);

// Limits the set of characters the recognizer can return.  (See ALC values above.)
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxALCValid(HRC, ALC);

// Reorders the characters the recognizer returns so that selected characters
// appear at the top of the list.  (See ALC values above.)
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxALCPriority(HRC, ALC);

// Sets parameter for partial recognition.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetPartial(HRC, UINT);

#define	HWX_PARTIAL_ALL		0
#define	HWX_PARTIAL_ORDER	1
#define	HWX_PARTIAL_FREE	2

// Sets abort address.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetAbort(HRC, UINT *);

// Adds ink to the HRC.
// Takes the HRC, the array of points, the count of points, and 
// the time stamp of the first mouse event in the stroke.  The
// time stamp should be taken directly from the MSG structure
// for the mouse down event.  The points should be scaled to
// match the guide structure.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxInput(HRC, POINT *, UINT, DWORD);

// Called after last ink is added.  You cannot add anymore ink
// to the HRC after this has been called.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxEndInput(HRC);

// Recognizes as much ink as it can.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxProcess(HRC);

// Retrieves the results from an HRC. This may be called repeatedly. This allows you
// to get results for several characters at a time. The return value is the number of
// characters actually returned.  The results for those characters are put in the
// rgBoxResults buffer that was passed in.
// Returns -1 on error.
// On failure, use GetLastError() to identify the cause of the error.
INT		WINAPI HwxGetResults(
	HRC			hrc,			// HRC containing results
	UINT		cAlt,			// number of alternates
	UINT		iFirst,			// index of first character to return
	UINT		cBoxRes,		// number of characters to return
	HWXRESULTS	*rgBoxResults	// array of cBoxRes ranked lists
);

// Tells the HRC what the previous character was for context purposes.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetContext(HRC, WCHAR);

// Tells you how many results can be retrieved from HwxGetResults.
// Returns -1 on error.
// On failure, use GetLastError() to identify the cause of the error.
INT		WINAPI HwxResultsAvailable(HRC);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // #define _INC_RECOG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\renbase.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Generic ActiveX base renderer class, December 1995

#ifndef __RENBASE__
#define __RENBASE__

#include <renqual.h>

// Forward class declarations

class CBaseRenderer;
class CBaseVideoRenderer;
class CRendererInputPin;

// This is our input pin class that channels calls to the renderer

class CRendererInputPin : public CBaseInputPin
{
protected:

    CBaseRenderer *m_pRenderer;

public:

    CRendererInputPin(CBaseRenderer *pRenderer,
                      HRESULT *phr,
                      LPCWSTR Name);

    // Overriden from the base pin classes

    HRESULT BreakConnect();
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT Active();
    HRESULT Inactive();

    // Add rendering behaviour to interface functions

    STDMETHODIMP QueryId(LPWSTR *Id);
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP Receive(IMediaSample *pMediaSample);

    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Helper
    IMemAllocator inline *Allocator() const
    {
        return m_pAllocator;
    }
};

// Main renderer class that handles synchronisation and state changes

class CBaseRenderer : public CBaseFilter
{
protected:

    friend class CRendererInputPin;

    friend void CALLBACK EndOfStreamTimer(UINT uID,      // Timer identifier
                                          UINT uMsg,     // Not currently used
                                          DWORD_PTR dwUser,  // User information
                                          DWORD_PTR dw1,     // Windows reserved
                                          DWORD_PTR dw2);    // Is also reserved

    CRendererPosPassThru *m_pPosition;  // Media seeking pass by object
    CAMEvent m_RenderEvent;             // Used to signal timer events
    CAMEvent m_ThreadSignal;            // Signalled to release worker thread
    CAMEvent m_evComplete;              // Signalled when state complete
    BOOL m_bAbort;                      // Stop us from rendering more data
    BOOL m_bStreaming;                  // Are we currently streaming
    DWORD_PTR m_dwAdvise;                   // Timer advise cookie
    IMediaSample *m_pMediaSample;       // Current image media sample
    BOOL m_bEOS;                        // Any more samples in the stream
    BOOL m_bEOSDelivered;               // Have we delivered an EC_COMPLETE
    CRendererInputPin *m_pInputPin;     // Our renderer input pin object
    CCritSec m_InterfaceLock;           // Critical section for interfaces
    CCritSec m_RendererLock;            // Controls access to internals
    IQualityControl * m_pQSink;         // QualityControl sink
    BOOL m_bRepaintStatus;              // Can we signal an EC_REPAINT
    //  Avoid some deadlocks by tracking filter during stop
    volatile BOOL  m_bInReceive;        // Inside Receive between PrepareReceive
                                        // And actually processing the sample
    REFERENCE_TIME m_SignalTime;        // Time when we signal EC_COMPLETE
    UINT m_EndOfStreamTimer;            // Used to signal end of stream

    BOOL m_bFirstFrameRendered;         // Used to indicate if a frame was already rendered or not
    double m_dRate;                     // current playback rate

    BOOL  m_bForceRendering;            // If set, we're going to render even if not streaming

    HRESULT Init(void);

public:

    CBaseRenderer(REFCLSID RenderClass, // CLSID for this renderer
                  TCHAR *pName,         // Debug ONLY description
                  LPUNKNOWN pUnk,       // Aggregated owner object
                  HRESULT *phr);         // General OLE return code

    CBaseRenderer(REFCLSID RenderClass, // CLSID for this renderer
                  TCHAR *pName,         // Debug ONLY description
                  LPUNKNOWN pUnk,       // Aggregated owner object
                  HRESULT *phr,         // General OLE return code
                  DWORD dwReporterTag);  // Reporter tag for WMILOG

    ~CBaseRenderer();

    // Overriden to say what interfaces we support and where

    virtual HRESULT GetMediaPositionInterface(REFIID riid,void **ppv);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    virtual HRESULT SourceThreadCanWait(BOOL bCanWait);

#ifdef DEBUG
    // Debug only dump of the renderer state
    void DisplayRendererState();
#endif
    virtual HRESULT WaitForRenderTime();
    virtual HRESULT CompleteStateChange(FILTER_STATE OldState);

    // Return internal information about this filter

    BOOL IsEndOfStream() { return m_bEOS; };
    BOOL IsEndOfStreamDelivered() { return m_bEOSDelivered; };
    BOOL IsStreaming() { return m_bStreaming; };
    void SetAbortSignal(BOOL bAbort) { m_bAbort = bAbort; };
    virtual void OnReceiveFirstSample(IMediaSample *pMediaSample) { };
    CAMEvent *GetRenderEvent() { return &m_RenderEvent; };

    // Permit access to the transition state

    void Ready() { m_evComplete.Set(); };
    void NotReady() { m_evComplete.Reset(); };
    BOOL CheckReady() { return m_evComplete.Check(); };

    virtual int GetPinCount();
    virtual CBasePin *GetPin(int n);
    FILTER_STATE GetRealState();
    void SendRepaint();
    void SendNotifyWindow(IPin *pPin,HWND hwnd);
    virtual BOOL OnDisplayChange();
    void SetRepaintStatus(BOOL bRepaint);

    // Override the filter and pin interface functions

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME StartTime);
    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *State);
    STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin);

    virtual void OnNewSegment(REFERENCE_TIME tStart,
                              REFERENCE_TIME tStop,
                              double dRate);

    // These are available for quality management and notification. Some of these don't do anything and are intended to be overridden.
    virtual void OnSampleReceived(IMediaSample* pSample);
    virtual void OnSampleDropped(IMediaSample* pSample);
    virtual void OnSampleScheduled(IMediaSample* pSample);

    virtual void OnRenderStart(IMediaSample *pMediaSample);
    virtual void OnRenderEnd(IMediaSample *pMediaSample, bool bRenderedOk);
    virtual HRESULT OnStartStreaming() { return NOERROR; };
    virtual HRESULT OnStopStreaming() { return NOERROR; };
    virtual void OnWaitStart() { };
    virtual void OnWaitEnd() { };
    virtual void PrepareRender() { };

    REFERENCE_TIME m_trRenderStart; // Just before we started drawing
                                    // Set in OnRenderStart, Used in OnRenderEnd
#ifdef PERF
    int m_idBaseStamp;              // MSR_id for frame time stamp
    int m_idBaseRenderTime;         // MSR_id for true wait time
    int m_idBaseAccuracy;           // MSR_id for time frame is late (int)
#endif

    // Quality management implementation for scheduling rendering

    virtual BOOL ScheduleSample(IMediaSample *pMediaSample);
    virtual HRESULT GetSampleTimes(IMediaSample *pMediaSample,
                                   REFERENCE_TIME *pStartTime,
                                   REFERENCE_TIME *pEndTime);

    virtual HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample,
                                        REFERENCE_TIME *ptrStart,
                                        REFERENCE_TIME *ptrEnd);

    // Lots of end of stream complexities

    void TimerCallback();
    void ResetEndOfStreamTimer();
    HRESULT NotifyEndOfStream();
    virtual HRESULT SendEndOfStream();
    virtual HRESULT ResetEndOfStream();
    virtual HRESULT EndOfStream();

    // Rendering is based around the clock

    virtual void SignalTimerFired();
    virtual HRESULT CancelNotification();
    virtual HRESULT ClearPendingSample();

    // Called when the filter changes state

    virtual HRESULT Active();
    virtual HRESULT Inactive();
    virtual HRESULT StartStreaming();
    virtual HRESULT StopStreaming();
    virtual HRESULT BeginFlush();
    virtual HRESULT EndFlush();

    // Deal with connections and type changes

    virtual HRESULT BreakConnect();
    virtual HRESULT SetMediaType(const CMediaType *pmt);
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // These look after the handling of data samples

    virtual HRESULT PrepareReceive(IMediaSample *pMediaSample);
    virtual HRESULT Receive(IMediaSample *pMediaSample);
    virtual BOOL HaveCurrentSample();
    virtual IMediaSample *GetCurrentSample();
    virtual HRESULT Render(IMediaSample *pMediaSample);

    // Derived classes MUST override these
    virtual HRESULT DoRenderSample(IMediaSample *pMediaSample) PURE;
    virtual HRESULT CheckMediaType(const CMediaType *) PURE;

    virtual void WaitForReceiveToComplete();
};


// CBaseVideoRenderer is a renderer class (see its ancestor class) and
// it handles scheduling of media samples so that they are drawn at the
// correct time by the reference clock.  It implements a degradation
// strategy.  Possible degradation modes are:
//    Drop frames here (only useful if the drawing takes significant time)
//    Signal supplier (upstream) to drop some frame(s) - i.e. one-off skip.
//    Signal supplier to change the frame rate - i.e. ongoing skipping.
//    Or any combination of the above.
// In order to determine what's useful to try we need to know what's going
// on.  This is done by timing various operations (including the supplier).
// This timing is done by using timeGetTime as it is accurate enough and
// usually cheaper than calling the reference clock.  It also tells the
// truth if there is an audio break and the reference clock stops.
// We provide a number of public entry points (named OnXxxStart, OnXxxEnd)
// which the rest of the renderer calls at significant moments.  These do
// the timing.
class CBaseVideoRenderer : public CBaseRenderer,         // Base renderer class
                           public CVideoRendererQuality, // Quality management
                           public IQualityControl
{
public:


    CBaseVideoRenderer(REFCLSID RenderClass, // CLSID for this renderer
                       TCHAR *pName,         // Debug ONLY description
                       LPUNKNOWN pUnk,       // Aggregated owner object
                       HRESULT *phr);        // General OLE return code

    ~CBaseVideoRenderer();

    BOOL ScheduleSample(IMediaSample *pMediaSample);
    virtual HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample, REFERENCE_TIME *ptrStart, REFERENCE_TIME *ptrEnd);

    virtual HRESULT SendQuality(REFERENCE_TIME trLate, REFERENCE_TIME trRealStream);
    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    // IQualityControl methods - Notify allows audio-video throttling
    STDMETHODIMP SetSink( IQualityControl * piqc);
    STDMETHODIMP Notify( IBaseFilter * pSelf, Quality q);

    // These provide a full video quality management implementation

    virtual void OnRenderStart(IMediaSample *pMediaSample) { CVideoRendererQuality::OnRenderStartQual (pMediaSample); }
    virtual void OnRenderEnd(IMediaSample *pMediaSample) { CVideoRendererQuality::OnRenderEndQual (pMediaSample); }
    virtual HRESULT OnStartStreaming() { return CVideoRendererQuality::OnStartStreamingQual (m_State); }
    virtual HRESULT OnStopStreaming(){ return CVideoRendererQuality::OnStopStreamingQual (m_State); }
    virtual void OnWaitStart() { CVideoRendererQuality::OnWaitStartQual (); }
    virtual void OnWaitEnd() { CVideoRendererQuality::OnWaitEndQual (); }

    virtual void PrepareRender();

    // IQualProp property page support
    STDMETHODIMP get_FramesDroppedInRenderer(int *cFramesDropped);
    STDMETHODIMP get_FramesDrawn(int *pcFramesDrawn);
    STDMETHODIMP get_AvgFrameRate(int *piAvgFrameRate);
    STDMETHODIMP get_Jitter(int *piJitter);
    STDMETHODIMP get_AvgSyncOffset(int *piAvg);
    STDMETHODIMP get_DevSyncOffset(int *piDev);
    HRESULT GetStdDev(int nSamples, int *piResult, LONGLONG llSumSq, LONGLONG iTot);

    // Implement an IUnknown interface and expose IQualProp

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,VOID **ppv);
};

#endif // __RENBASE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\renqual.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Generic ActiveX base video renderer quality class, December 1995

#ifndef __RENQUAL__
#define __RENQUAL__

// The class CVideoRenderQuality provides heuristics for dropping frame logic.
// It provides means to schedule media samples so that they are drawn at the
// correct time by the reference clock.  It implements a degradation
// strategy.  Possible degradation modes are:
//    Drop frames here (only useful if the drawing takes significant time)
//    Signal supplier (upstream) to drop some frame(s) - i.e. one-off skip.
//    Signal supplier to change the frame rate - i.e. ongoing skipping.
//    Or any combination of the above.
// In order to determine what's useful to try we need to know what's going
// on.  This is done by timing various operations (including the supplier).
// This timing is done by using timeGetTime as it is accurate enough and
// usually cheaper than calling the reference clock.  It also tells the
// truth if there is an audio break and the reference clock stops.
// We provide a number of public entry points (named OnXxxStart, OnXxxEnd)
// which the rest of the renderer calls at significant moments.  These do
// the timing.

// the number of frames that the sliding averages are averaged over.
// the rule is (1024*NewObservation + (AVGPERIOD-1) * PreviousAverage)/AVGPERIOD
#define AVGPERIOD 4
#define DO_MOVING_AVG(avg,obs) (avg = (1024*obs + (AVGPERIOD-1)*avg)/AVGPERIOD)
// Spot the problem with this macro - I can't. but it doesn't work!

class CBaseRenderer;

class CVideoRendererQuality : public IQualProp        // Property page guff
{
public:
    CVideoRendererQuality();
    ~CVideoRendererQuality();

    // Expose IQualProp
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,VOID **ppv);

    STDMETHODIMP NotifyQuality(Quality q);

    // These provide a full video quality management implementation

    void OnRenderStartQual(IMediaSample *pMediaSample);
    void OnRenderEndQual(IMediaSample *pMediaSample);
    void OnWaitStartQual();
    void OnWaitEndQual();
    HRESULT OnStartStreamingQual(FILTER_STATE state);
    HRESULT OnStopStreamingQual(FILTER_STATE state);
    void ThrottleWait();

    // Handle the statistics gathering for our quality management

    void PreparePerformanceData(int trLate, int trFrame);
    virtual void RecordFrameLateness(int trLate, int trFrame);
    virtual void OnDirectRender(IMediaSample *pMediaSample);
    virtual HRESULT ResetStreamingTimes();
    virtual HRESULT ComputeLateness(REFERENCE_TIME trStart, 
                                    REFERENCE_TIME trRealStream,
                                    REFERENCE_TIME *ptrLate);
    HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample,
                                REFERENCE_TIME *ptrStart,
                                REFERENCE_TIME *ptrEnd,
                                REFERENCE_TIME trRealStream,
                                BOOL bSupplierHandlingQuality);
    
    virtual void FrameDropped(IMediaSample *pMediaSample, REFERENCE_TIME rtStreamTime);

    virtual HRESULT GetQuality(REFERENCE_TIME trLate, REFERENCE_TIME trRealStream, Quality *pQ);

    //
    //  Do estimates for standard deviations for per-frame
    //  statistics
    //
    //  *piResult = (llSumSq - iTot * iTot / m_cFramesDrawn - 1) /
    //                            (m_cFramesDrawn - 2)
    //  or 0 if m_cFramesDrawn <= 3
    //
    HRESULT GetStdDev(
        int nSamples,
        int *piResult,
        LONGLONG llSumSq,
        LONGLONG iTot
    );

    // IQualProp property page support

    STDMETHODIMP get_FramesDroppedInRenderer(int *cFramesDropped);
    STDMETHODIMP get_FramesDrawn(int *pcFramesDrawn);
    STDMETHODIMP get_AvgFrameRate(int *piAvgFrameRate, BOOL bStreaming);
    STDMETHODIMP get_Jitter(int *piJitter);
    STDMETHODIMP get_AvgSyncOffset(int *piAvg);
    STDMETHODIMP get_DevSyncOffset(int *piDev);

protected:

    // Hungarian:
    //     tFoo is the time Foo in mSec (beware m_tStart from filter.h)
    //     trBar is the time Bar by the reference clock

    //******************************************************************
    // State variables to control synchronisation
    //******************************************************************

    // Control of sending Quality messages.  We need to know whether
    // we are in trouble (e.g. frames being dropped) and where the time
    // is being spent.

    // When we drop a frame we play the next one early.
    // The frame after that is likely to wait before drawing and counting this
    // wait as spare time is unfair, so we count it as a zero wait.
    // We therefore need to know whether we are playing frames early or not.

    int m_nNormal;                  // The number of consecutive frames
                                    // drawn at their normal time (not early)
                                    // -1 means we just dropped a frame.

#ifdef PERF
    BOOL m_bDrawLateFrames;         // Don't drop any frames (debug and I'm
                                    // not keen on people using it!)
#endif

    BOOL m_bSupplierHandlingQuality;// The response to Quality messages says
                                    // our supplier is handling things.
                                    // We will allow things to go extra late
                                    // before dropping frames.  We will play
                                    // very early after he has dropped one.

    // Control of scheduling, frame dropping etc.
    // We need to know where the time is being spent so as to tell whether
    // we should be taking action here, signalling supplier or what.
    // The variables are initialised to a mode of NOT dropping frames.
    // They will tell the truth after a few frames.
    // We typically record a start time for an event, later we get the time
    // again and subtract to get the elapsed time, and we average this over
    // a few frames.  The average is used to tell what mode we are in.

    // Although these are reference times (64 bit) they are all DIFFERENCES
    // between times which are small.  An int will go up to 214 secs before
    // overflow.  Avoiding 64 bit multiplications and divisions seems
    // worth while.



    // Audio-video throttling.  If the user has turned up audio quality
    // very high (in principle it could be any other stream, not just audio)
    // then we can receive cries for help via the graph manager.  In this case
    // we put in a wait for some time after rendering each frame.
    int m_trThrottle;

    // The time taken to render (i.e. BitBlt) frames controls which component
    // needs to degrade.  If the blt is expensive, the renderer degrades.
    // If the blt is cheap it's done anyway and the supplier degrades.
    int m_trRenderAvg;              // Time frames are taking to blt
    int m_trRenderLast;             // Time for last frame blt
    int m_tRenderStart;             // Just before we started drawing (mSec)
                                    // derived from timeGetTime.

    // When frames are dropped we will play the next frame as early as we can.
    // If it was a false alarm and the machine is fast we slide gently back to
    // normal timing.  To do this, we record the offset showing just how early
    // we really are.  This will normally be negative meaning early or zero.
    int m_trEarliness;

    // Target provides slow long-term feedback to try to reduce the
    // average sync offset to zero.  Whenever a frame is actually rendered
    // early we add a msec or two, whenever late we take off a few.
    // We add or take off 1/32 of the error time.
    // Eventually we should be hovering around zero.  For a really bad case
    // where we were (say) 300mSec off, it might take 100 odd frames to
    // settle down.  The rate of change of this is intended to be slower
    // than any other mechanism in Quartz, thereby avoiding hunting.
    int m_trTarget;

    // The proportion of time spent waiting for the right moment to blt
    // controls whether we bother to drop a frame or whether we reckon that
    // we're doing well enough that we can stand a one-frame glitch.
    int m_trWaitAvg;                // Average of last few wait times
                                    // (actually we just average how early
                                    // we were).  Negative here means LATE.

    // The average inter-frame time.
    // This is used to calculate the proportion of the time used by the
    // three operations (supplying us, waiting, rendering)
    int m_trFrameAvg;               // Average inter-frame time
    int m_trDuration;               // duration of last frame.

#ifdef PERF
    // Performance logging identifiers
    int m_idTimeStamp;              // MSR_id for frame time stamp
    int m_idEarliness;              // MSR_id for earliness fudge
    int m_idTarget;                 // MSR_id for Target fudge
    int m_idWaitReal;               // MSR_id for true wait time
    int m_idWait;                   // MSR_id for wait time recorded
    int m_idFrameAccuracy;          // MSR_id for time frame is late (int)
    int m_idRenderAvg;              // MSR_id for Render time recorded (int)
    int m_idSchLateTime;            // MSR_id for lateness at scheduler
    int m_idQualityRate;            // MSR_id for Quality rate requested
    int m_idQualityTime;            // MSR_id for Quality time requested
    int m_idDecision;               // MSR_id for decision code
    int m_idDuration;               // MSR_id for duration of a frame
    int m_idThrottle;               // MSR_id for audio-video throttling
    //int m_idDebug;                  // MSR_id for trace style debugging
    //int m_idSendQuality;          // MSR_id for timing the notifications per se
#endif // PERF
    REFERENCE_TIME m_trRememberStampForPerf;  // original time stamp of frame
                                              // with no earliness fudges etc.
#ifdef PERF
    REFERENCE_TIME m_trRememberFrameForPerf;  // time when previous frame rendered

    // debug...
    int m_idFrameAvg;
    int m_idWaitAvg;
#endif

    // PROPERTY PAGE
    // This has edit fields that show the user what's happening
    // These member variables hold these counts.

    int m_cFramesDropped;           // cumulative frames dropped IN THE RENDERER
    int m_cFramesDrawn;             // Frames since streaming started seen BY THE
                                    // RENDERER (some may be dropped upstream)

    // Next two support average sync offset and standard deviation of sync offset.
    LONGLONG m_iTotAcc;                  // Sum of accuracies in mSec
    LONGLONG m_iSumSqAcc;           // Sum of squares of (accuracies in mSec)

    // Next two allow jitter calculation.  Jitter is std deviation of frame time.
    REFERENCE_TIME m_trLastDraw;    // Time of prev frame (for inter-frame times)
    LONGLONG m_iSumSqFrameTime;     // Sum of squares of (inter-frame time in mSec)
    LONGLONG m_iSumFrameTime;            // Sum of inter-frame times in mSec

    // To get performance statistics on frame rate, jitter etc, we need
    // to record the lateness and inter-frame time.  What we actually need are the
    // data above (sum, sum of squares and number of entries for each) but the data
    // is generated just ahead of time and only later do we discover whether the
    // frame was actually drawn or not.  So we have to hang on to the data
    int m_trLate;                   // hold onto frame lateness
    int m_trFrame;                  // hold onto inter-frame time

    int m_tStreamingStart;          // if streaming then time streaming started
                                    // else time of last streaming session
                                    // used for property page statistics
#ifdef PERF
    LONGLONG m_llTimeOffset;        // timeGetTime()*10000+m_llTimeOffset==ref time
#endif
    FILTER_STATE m_prevState;        // state when we were issued a StopStreaming (may be Paused/Stopped)
};

#endif // __RENQUAL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\regstr.h ===
/*** regstr.h - Registry string definitions
 *
 *  This module contains public registry string definitions.
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *  Created     12/10/92
 *
 *  MODIFICATION HISTORY
 */


#ifndef _INC_REGSTR
#define _INC_REGSTR

#if _MSC_VER > 1000
#pragma once
#endif


/*** Public registry key names
 */

#define REGSTR_KEY_CLASS        TEXT("Class")      // under LOCAL_MACHINE
#define REGSTR_KEY_CONFIG       TEXT("Config")     // under LOCAL_MACHINE
#define REGSTR_KEY_ENUM         TEXT("Enum")       // under LOCAL_MACHINE
#define REGSTR_KEY_ROOTENUM     TEXT("Root")       // child of ENUM
#define REGSTR_KEY_BIOSENUM     TEXT("BIOS")       // child of ENUM
#define REGSTR_KEY_ACPIENUM     TEXT("ACPI")       // child of ENUM
#define REGSTR_KEY_PCMCIAENUM   TEXT("PCMCIA")     // child of ENUM
#define REGSTR_KEY_PCIENUM      TEXT("PCI")        // child of ENUM
#define REGSTR_KEY_VPOWERDENUM  TEXT("VPOWERD")    // child of ENUM
#ifndef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("ISAPnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("EISA")       // child of ENUM
#else // ifdef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("C98PnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("NESA")       // child of ENUM
#endif // ifdef NEC_98
#define REGSTR_KEY_LOGCONFIG    TEXT("LogConfig")  // child of enum\<enumerator>\<deviceid>\<instanceid>
#define REGSTR_KEY_SYSTEMBOARD  TEXT("*PNP0C01")   // child of enum\root
#define REGSTR_KEY_APM          TEXT("*PNP0C05")   // child of enum\root

#define REGSTR_KEY_INIUPDATE    TEXT("IniUpdate")
#define REG_KEY_INSTDEV         TEXT("Installed")  // child of hklm\class\classname (Win98-only)

#define REGSTR_KEY_DOSOPTCDROM  TEXT("CD-ROM")
#define REGSTR_KEY_DOSOPTMOUSE  TEXT("MOUSE")

#define REGSTR_KEY_KNOWNDOCKINGSTATES TEXT("Hardware Profiles")
#define REGSTR_KEY_DEVICEPARAMETERS   TEXT("Device Parameters")


/*** Public registry paths
 */

#define REGSTR_DEFAULT_INSTANCE          TEXT("0000")
#define REGSTR_PATH_MOTHERBOARD          REGSTR_KEY_SYSTEMBOARD TEXT("\\") REGSTR_DEFAULT_INSTANCE
#define REGSTR_PATH_SETUP                TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define REGSTR_PATH_DRIVERSIGN           TEXT("Software\\Microsoft\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN        TEXT("Software\\Microsoft\\Non-Driver Signing")
#define REGSTR_PATH_DRIVERSIGN_POLICY    TEXT("Software\\Policies\\Microsoft\\Windows NT\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN_POLICY TEXT("Software\\Policies\\Microsoft\\Windows NT\\Non-Driver Signing")
#define REGSTR_PATH_PIFCONVERT           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PIFConvert")
#define REGSTR_PATH_MSDOSOPTS            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSOptions")
#define REGSTR_PATH_NOSUGGMSDOS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NoMSDOSWarn")
#define REGSTR_PATH_NEWDOSBOX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSSpecialConfig")
#define REGSTR_PATH_RUNONCE              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define REGSTR_PATH_RUNONCEEX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define REGSTR_PATH_RUN                  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define REGSTR_PATH_RUNSERVICESONCE      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
#define REGSTR_PATH_RUNSERVICES          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define REGSTR_PATH_EXPLORER             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer")
#define REGSTR_PATH_PROPERTYSYSTEM       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PropertySystem")
#define REGSTR_PATH_DETECT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Detect")
#define REGSTR_PATH_APPPATHS             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths")
#define REGSTR_PATH_UNINSTALL            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
#define REGSTR_PATH_REALMODENET          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Real Mode Net")
#define REGSTR_PATH_NETEQUIV             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Equivalent")
#define REGSTR_PATH_CVNETWORK            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network")
#define REGSTR_PATH_WMI_SECURITY         TEXT("System\\CurrentControlSet\\Control\\Wmi\\Security")
#define REGSTR_PATH_RELIABILITY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Reliability")
#define REGSTR_PATH_RELIABILITY_POLICY   TEXT("Software\\Policies\\Microsoft\\Windows NT\\Reliability")
#define REGSTR_PATH_RELIABILITY_POLICY_SHUTDOWNREASONUI TEXT("ShutdownReasonUI")
#define REGSTR_PATH_RELIABILITY_POLICY_SNAPSHOT         TEXT("Snapshot")
#define REGSTR_PATH_RELIABILITY_POLICY_REPORTSNAPSHOT   TEXT("ReportSnapshot")

#define REGSTR_PATH_REINSTALL            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall")
#define REGSTR_PATH_NT_CURRENTVERSION TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")

#define REGSTR_PATH_VOLUMECACHE TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches")
#define REGSTR_VAL_DISPLAY      TEXT("display")


#define REGSTR_PATH_IDCONFIGDB  TEXT("System\\CurrentControlSet\\Control\\IDConfigDB")
#define REGSTR_PATH_CRITICALDEVICEDATABASE  TEXT("System\\CurrentControlSet\\Control\\CriticalDeviceDatabase")
#define REGSTR_PATH_CLASS       TEXT("System\\CurrentControlSet\\Services\\Class")
#define REGSTR_PATH_DISPLAYSETTINGS TEXT("Display\\Settings")
#define REGSTR_PATH_FONTS           TEXT("Display\\Fonts")
#define REGSTR_PATH_ENUM        TEXT("Enum")
#define REGSTR_PATH_ROOT        TEXT("Enum\\Root")

#define REGSTR_PATH_CURRENTCONTROLSET TEXT("System\\CurrentControlSet")
#define REGSTR_PATH_SYSTEMENUM  TEXT("System\\CurrentControlSet\\Enum")
#define REGSTR_PATH_HWPROFILES  TEXT("System\\CurrentControlSet\\Hardware Profiles")
#define REGSTR_PATH_HWPROFILESCURRENT TEXT("System\\CurrentControlSet\\Hardware Profiles\\Current")
#define REGSTR_PATH_CLASS_NT    TEXT("System\\CurrentControlSet\\Control\\Class")
#define REGSTR_PATH_PER_HW_ID_STORAGE TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\PerHwIdStorage")

#define REGSTR_PATH_DEVICE_CLASSES TEXT("System\\CurrentControlSet\\Control\\DeviceClasses")

#define REGSTR_PATH_CODEVICEINSTALLERS TEXT("System\\CurrentControlSet\\Control\\CoDeviceInstallers")
#define REGSTR_PATH_BUSINFORMATION TEXT("System\\CurrentControlSet\\Control\\PnP\\BusInformation")

#define REGSTR_PATH_SERVICES    TEXT("System\\CurrentControlSet\\Services")
#define REGSTR_PATH_VXD         TEXT("System\\CurrentControlSet\\Services\\VxD")
#define REGSTR_PATH_IOS     TEXT("System\\CurrentControlSet\\Services\\VxD\\IOS")
#define REGSTR_PATH_VMM         TEXT("System\\CurrentControlSet\\Services\\VxD\\VMM")
#define REGSTR_PATH_VPOWERD     TEXT("System\\CurrentControlSet\\Services\\VxD\\VPOWERD")
#define REGSTR_PATH_VNETSUP     TEXT("System\\CurrentControlSet\\Services\\VxD\\VNETSUP")
#define REGSTR_PATH_NWREDIR     TEXT("System\\CurrentControlSet\\Services\\VxD\\NWREDIR")
#define REGSTR_PATH_NCPSERVER   TEXT("System\\CurrentControlSet\\Services\\NcpServer\\Parameters")
#define REGSTR_PATH_VCOMM       TEXT("System\\CurrentControlSet\\Services\\VxD\\VCOMM")

#define REGSTR_PATH_IOARB       TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IOArb")
#define REGSTR_PATH_ADDRARB     TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\AddrArb")
#define REGSTR_PATH_DMAARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\DMAArb")
#define REGSTR_PATH_IRQARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IRQArb")

#define REGSTR_PATH_CODEPAGE                            TEXT("System\\CurrentControlSet\\Control\\Nls\\Codepage")
#define REGSTR_PATH_FILESYSTEM                          TEXT("System\\CurrentControlSet\\Control\\FileSystem")
#define REGSTR_PATH_FILESYSTEM_NOVOLTRACK       TEXT("System\\CurrentControlSet\\Control\\FileSystem\\NoVolTrack")
#define REGSTR_PATH_CDFS                                        TEXT("System\\CurrentControlSet\\Control\\FileSystem\\CDFS")
#define REGSTR_PATH_WINBOOT                                 TEXT("System\\CurrentControlSet\\Control\\WinBoot")
#define REGSTR_PATH_INSTALLEDFILES                      TEXT("System\\CurrentControlSet\\Control\\InstalledFiles")
#define REGSTR_PATH_VMM32FILES                          TEXT("System\\CurrentControlSet\\Control\\VMM32Files")

//
// Reasonable Limit for Values Names
//
#define REGSTR_MAX_VALUE_LENGTH     256

//
// Values used by user mode Pnp Manager
//
#define REGSTR_KEY_DEVICE_PROPERTIES               TEXT("Properties")
#define REGSTR_VAL_SLOTNUMBER                      TEXT("SlotNumber")
#define REGSTR_VAL_ATTACHEDCOMPONENTS              TEXT("AttachedComponents")
#define REGSTR_VAL_BASEDEVICEPATH                  TEXT("BaseDevicePath")
#define REGSTR_VAL_SYSTEMBUSNUMBER                 TEXT("SystemBusNumber")
#define REGSTR_VAL_BUSDATATYPE                     TEXT("BusDataType")
#define REGSTR_VAL_INTERFACETYPE                   TEXT("InterfaceType")
#define REGSTR_VAL_SERVICE                         TEXT("Service")
#define REGSTR_VAL_DETECTSIGNATURE                 TEXT("DetectSignature")
#define REGSTR_VAL_CLASSGUID                       TEXT("ClassGUID")
#define REGSTR_VAL_INSTANCEIDENTIFIER              TEXT("InstanceIdentifier")
#define REGSTR_VAL_DUPLICATEOF                     TEXT("DuplicateOf")
#define REGSTR_VAL_STATUSFLAGS                     TEXT("StatusFlags")
#define REGSTR_VAL_DISABLECOUNT                    TEXT("DisableCount")
#define REGSTR_VAL_UNKNOWNPROBLEMS                 TEXT("UnknownProblem")
#define REGSTR_VAL_DOCKSTATE                       TEXT("DockState")
#define REGSTR_VAL_PREFERENCEORDER                 TEXT("PreferenceOrder")
#define REGSTR_VAL_USERWAITINTERVAL                TEXT("UserWaitInterval")
#define REGSTR_VAL_DEVICE_INSTANCE                 TEXT("DeviceInstance")
#define REGSTR_VAL_SYMBOLIC_LINK                   TEXT("SymbolicLink")
#define REGSTR_VAL_DEFAULT                         TEXT("Default")
#define REGSTR_VAL_LOWERFILTERS                    TEXT("LowerFilters")
#define REGSTR_VAL_UPPERFILTERS                    TEXT("UpperFilters")
#define REGSTR_VAL_LOCATION_INFORMATION            TEXT("LocationInformation")
#define REGSTR_VAL_UI_NUMBER                       TEXT("UINumber")
#define REGSTR_VAL_UI_NUMBER_DESC_FORMAT           TEXT("UINumberDescFormat")
#define REGSTR_VAL_CAPABILITIES                    TEXT("Capabilities")
#define REGSTR_VAL_DEVICE_TYPE                     TEXT("DeviceType")
#define REGSTR_VAL_DEVICE_CHARACTERISTICS          TEXT("DeviceCharacteristics")
#define REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR      TEXT("Security")
#define REGSTR_VAL_DEVICE_EXCLUSIVE                TEXT("Exclusive")
#define REGSTR_VAL_RESOURCE_PICKER_TAGS            TEXT("ResourcePickerTags")
#define REGSTR_VAL_RESOURCE_PICKER_EXCEPTIONS      TEXT("ResourcePickerExceptions")
#define REGSTR_VAL_CUSTOM_PROPERTY_CACHE_DATE      TEXT("CustomPropertyCacheDate")
#define REGSTR_VAL_CUSTOM_PROPERTY_HW_ID_KEY       TEXT("CustomPropertyHwIdKey")
#define REGSTR_VAL_LAST_UPDATE_TIME                TEXT("LastUpdateTime")

//
// Values used by kernel mode Pnp Manager
//
#define REGSTR_VALUE_DEVICE_OBJECT_NAME            TEXT("DeviceObjectName")
#define REGSTR_VALUE_DEVICE_SYMBOLIC_NAME          TEXT("DeviceSymbolicName")
#define REGSTR_VAL_EJECT_PRIORITY                  TEXT("EjectPriority")

//
// Values used by both kernel-mode and user-mode PnP Managers
//
#define REGSTR_KEY_CONTROL                         TEXT("Control")
#define REGSTR_VAL_ACTIVESERVICE                   TEXT("ActiveService")
#define REGSTR_VAL_LINKED                          TEXT("Linked")
#define REGSTR_VAL_PHYSICALDEVICEOBJECT            TEXT("PhysicalDeviceObject")
#define REGSTR_VAL_REMOVAL_POLICY                  TEXT("RemovalPolicy")

//
// Values under REGSTR_PATH_NT_CURRENTVERSION
//
#define REGSTR_VAL_CURRENT_VERSION  TEXT("CurrentVersion")
#define REGSTR_VAL_CURRENT_BUILD    TEXT("CurrentBuildNumber")
#define REGSTR_VAL_CURRENT_CSDVERSION TEXT("CSDVersion")
#define REGSTR_VAL_CURRENT_TYPE     TEXT("CurrentType")

//
// Values under REGSTR_PATH_DISPLAYSETTINGS
//

#define REGSTR_VAL_BITSPERPIXEL  TEXT("BitsPerPixel")
#define REGSTR_VAL_RESOLUTION    TEXT("Resolution")
#define REGSTR_VAL_DPILOGICALX   TEXT("DPILogicalX")
#define REGSTR_VAL_DPILOGICALY   TEXT("DPILogicalY")
#define REGSTR_VAL_DPIPHYSICALX  TEXT("DPIPhysicalX")
#define REGSTR_VAL_DPIPHYSICALY  TEXT("DPIPhysicalY")
#define REGSTR_VAL_REFRESHRATE   TEXT("RefreshRate")
#define REGSTR_VAL_DISPLAYFLAGS  TEXT("DisplayFlags")


// under HKEY_CURRENT_USER
#define REGSTR_PATH_CONTROLPANEL    TEXT("Control Panel")

// under HKEY_LOCAL_MACHINE
#define REGSTR_PATH_CONTROLSFOLDER  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder")

//
// Entries under REGSTR_PATH_CODEPAGE
//

#define REGSTR_VAL_DOSCP        TEXT("OEMCP")
#define REGSTR_VAL_WINCP        TEXT("ACP")

#define REGSTR_PATH_DYNA_ENUM   TEXT("Config Manager\\Enum")

//
// Entries under REGSTR_PATH_DYNA_ENUM
//
#define REGSTR_VAL_HARDWARE_KEY TEXT("HardWareKey")
#define REGSTR_VAL_ALLOCATION   TEXT("Allocation")
#define REGSTR_VAL_PROBLEM      TEXT("Problem")
#define REGSTR_VAL_STATUS       TEXT("Status")

//
//  Used by address arbitrator
//
#define REGSTR_VAL_DONTUSEMEM   TEXT("DontAllocLastMem")

//
//  Entries under REGSTR_PATH_SETUP
//
#define REGSTR_VAL_SYSTEMROOT           TEXT("SystemRoot")
#define REGSTR_VAL_BOOTCOUNT            TEXT("BootCount")
#define REGSTR_VAL_REALNETSTART         TEXT("RealNetStart")
#define REGSTR_VAL_MEDIA                TEXT("MediaPath")
#define REGSTR_VAL_CONFIG               TEXT("ConfigPath")
#define REGSTR_VAL_DEVICEPATH           TEXT("DevicePath")      //default search path for .INFs
#define REGSTR_VAL_SRCPATH              TEXT("SourcePath")      //last source files path during setup.
#define REGSTR_VAL_DRIVERCACHEPATH      TEXT("DriverCachePath") //location of driver cache

#define REGSTR_VAL_OLDWINDIR            TEXT("OldWinDir")       //old windows location
#define REGSTR_VAL_SETUPFLAGS           TEXT("SetupFlags")      //flags that setup passes on after install.
#define REGSTR_VAL_REGOWNER             TEXT("RegisteredOwner")
#define REGSTR_VAL_REGORGANIZATION      TEXT("RegisteredOrganization")
#define REGSTR_VAL_LICENSINGINFO        TEXT("LicensingInfo")
#define REGSTR_VAL_OLDMSDOSVER          TEXT("OldMSDOSVer") // will be DOS ver < 7 (when Setup run)
#define REGSTR_VAL_FIRSTINSTALLDATETIME TEXT("FirstInstallDateTime") // will Win 95 install date-time

#define REGSTR_VAL_INSTALLTYPE          TEXT("InstallType")
//  Values for InstallType
#define IT_COMPACT          0x0000
#define IT_TYPICAL          0x0001
#define IT_PORTABLE         0x0002
#define IT_CUSTOM           0x0003

#define REGSTR_VAL_WRAPPER              TEXT("Wrapper")

#define REGSTR_KEY_RUNHISTORY           TEXT("RunHistory")
#define REGSTR_VAL_LASTALIVEINTERVAL    TEXT("TimeStampInterval")
#define REGSTR_VAL_DIRTYSHUTDOWN        TEXT("DirtyShutdown")
#define REGSTR_VAL_DIRTYSHUTDOWNTIME    TEXT("DirtyShutdownTime")
#define REGSTR_VAL_BT                   TEXT("6005BT")
#define REGSTR_VAL_LASTCOMPUTERNAME     TEXT("LastComputerName")
#define REGSTR_VAL_LASTALIVEBT          TEXT("LastAliveBT")
#define REGSTR_VAL_LASTALIVESTAMP       TEXT("LastAliveStamp")
#define REGSTR_VAL_LASTALIVESTAMPFORCED TEXT("LastAliveStampForced")
#define REGSTR_VAL_LASTALIVESTAMPINTERVAL   TEXT("LastAliveStampInterval")
#define REGSTR_VAL_LASTALIVESTAMPPOLICYINTERVAL TEXT("LastAliveStampPolicyInterval")
#define REGSTR_VAL_LASTALIVEUPTIME      TEXT("LastAliveUptime")
#define REGSTR_VAL_LASTALIVEPMPOLICY    TEXT("LastAlivePMPolicy")



#define REGSTR_VAL_SHUTDOWNREASON       TEXT("ShutdownReason")
#define REGSTR_VAL_SHUTDOWNREASON_CODE          TEXT("ShutdownReasonCode")
#define REGSTR_VAL_SHUTDOWNREASON_COMMENT       TEXT("ShutdownReasonComment")
#define REGSTR_VAL_SHUTDOWNREASON_PROCESS       TEXT("ShutdownReasonProcess")
#define REGSTR_VAL_SHUTDOWNREASON_USERNAME      TEXT("ShutdownReasonUserName")
#define REGSTR_VAL_SHOWREASONUI                 TEXT("ShutdownReasonUI")
#define REGSTR_VAL_SHUTDOWN_IGNORE_PREDEFINED   TEXT("ShutdownIgnorePredefinedReasons")
#define REGSTR_VAL_SHUTDOWN_STATE_SNAPSHOT      TEXT("ShutdownStateSnapshot")

#define REGSTR_KEY_SETUP                TEXT("\\Setup")
#define REGSTR_VAL_BOOTDIR              TEXT("BootDir")
#define REGSTR_VAL_WINBOOTDIR           TEXT("WinbootDir")
#define REGSTR_VAL_WINDIR               TEXT("WinDir")

#define REGSTR_VAL_APPINSTPATH          TEXT("AppInstallPath")    // Used by install wizard

// Values for international startup disk
#define REGSTR_PATH_EBD          REGSTR_PATH_SETUP REGSTR_KEY_SETUP TEXT("\\EBD")
// Keys under REGSTR_KEY_EBD
#define REGSTR_KEY_EBDFILESLOCAL     TEXT("EBDFilesLocale")
#define REGSTR_KEY_EBDFILESKEYBOARD     TEXT("EBDFilesKeyboard")
#define REGSTR_KEY_EBDAUTOEXECBATLOCAL TEXT("EBDAutoexecBatLocale")
#define REGSTR_KEY_EBDAUTOEXECBATKEYBOARD TEXT("EBDAutoexecBatKeyboard")
#define REGSTR_KEY_EBDCONFIGSYSLOCAL   TEXT("EBDConfigSysLocale")
#define REGSTR_KEY_EBDCONFIGSYSKEYBOARD   TEXT("EBDConfigSysKeyboard")


// Values under REGSTR_PATH_DRIVERSIGN and REGSTR_PATH_NONDRIVERSIGN
#define REGSTR_VAL_POLICY                     TEXT("Policy")

// Values under REGSTR_PATH_DRIVERSIGN_POLICY and REGSTR_PATH_NONDRIVERSIGN_POLICY
#define REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY  TEXT("BehaviorOnFailedVerify")

// Types of driver signing policies (apply to both preference and policy values
// defined above)
#define DRIVERSIGN_NONE             0x00000000
#define DRIVERSIGN_WARNING          0x00000001
#define DRIVERSIGN_BLOCKING         0x00000002

//
//  Entries under REGSTR_PATH_PIFCONVERT
//
#define REGSTR_VAL_MSDOSMODE            TEXT("MSDOSMode")
#define REGSTR_VAL_MSDOSMODEDISCARD     TEXT("Discard")

//
//  Entries under REGSTR_PATH_MSDOSOPTS (global settings)
//
#define REGSTR_VAL_DOSOPTGLOBALFLAGS    TEXT("GlobalFlags")
//  Flags for GlobalFlags
#define DOSOPTGF_DEFCLEAN   0x00000001L // Default action is clean config

//
//  Entries under REGSTR_PATH_MSDOSOPTS \ OptionSubkey
//
#define REGSTR_VAL_DOSOPTFLAGS          TEXT("Flags")
#define REGSTR_VAL_OPTORDER             TEXT("Order")
#define REGSTR_VAL_CONFIGSYS            TEXT("Config.Sys")
#define REGSTR_VAL_AUTOEXEC             TEXT("Autoexec.Bat")
#define REGSTR_VAL_STDDOSOPTION         TEXT("StdOption")
#define REGSTR_VAL_DOSOPTTIP            TEXT("TipText")

//  Flags for DOSOPTFLAGS
#define DOSOPTF_DEFAULT     0x00000001L // Default enabled for clean config
#define DOSOPTF_SUPPORTED   0x00000002L // Option actually supported
#define DOSOPTF_ALWAYSUSE   0x00000004L // Always use this option
#define DOSOPTF_USESPMODE   0x00000008L // Option puts machine in Prot Mode
#define DOSOPTF_PROVIDESUMB 0x00000010L // Can load drivers high
#define DOSOPTF_NEEDSETUP   0x00000020L // Need to configure option
#define DOSOPTF_INDOSSTART  0x00000040L // Suppored by DOSSTART.BAT
#define DOSOPTF_MULTIPLE    0x00000080L // Load multiple configuration lines

//
//  Flags returned by SUGetSetSetupFlags and in the registry
//
#define SUF_FIRSTTIME   0x00000001L // First boot into Win95.
#define SUF_EXPRESS     0x00000002L // User Setup via express mode (vs customize).
#define SUF_BATCHINF    0x00000004L // Setup using batch file (MSBATCH.INF).
#define SUF_CLEAN       0x00000008L // Setup was done to a clean directory.
#define SUF_INSETUP     0x00000010L // You're in Setup.
#define SUF_NETSETUP    0x00000020L // Doing a net (workstation) setup.
#define SUF_NETHDBOOT   0x00000040L // Workstation boots from local harddrive
#define SUF_NETRPLBOOT  0x00000080L // Workstation boots via RPL (vs floppy)
#define SUF_SBSCOPYOK   0x00000100L // Can copy to LDID_SHARED (SBS)

//
//  Entries under REGSTR_PATH_VMM
//
#define REGSTR_VAL_DOSPAGER     TEXT("DOSPager")
#define REGSTR_VAL_VXDGROUPS    TEXT("VXDGroups")

//
//  Entries under REGSTR_PATH_VPOWERD
//
#define REGSTR_VAL_VPOWERDFLAGS TEXT("Flags")
#define VPDF_DISABLEPWRMGMT         0x00000001  // Don't load device
#define VPDF_FORCEAPM10MODE         0x00000002  // Always go into 1.0 mode
#define VPDF_SKIPINTELSLCHECK       0x00000004  // Don't detect Intel SL chipset
#define VPDF_DISABLEPWRSTATUSPOLL   0x00000008  // Don't poll power status
#define VPDF_DISABLERINGRESUME      0x00000010  // Don't let the modem wake the machine (APM 1.2 only)
#define VPDF_SHOWMULTIBATT          0x00000020  // Show all batteries checkbox in power control panel

//
// Entries under REGSTR_PATH_BUSINFORMATION
//
#define BIF_SHOWSIMILARDRIVERS      0x00000001  // Show similar drivers instead of all class drivers in UI.
#define BIF_RAWDEVICENEEDSDRIVER    0x00000002  // RAW device needs a driver installed.

//
//  Entries under REGSTR_PATH_VNETSUP
//
#define REGSTR_VAL_WORKGROUP TEXT("Workgroup")
#define REGSTR_VAL_DIRECTHOST TEXT("DirectHost")
#define REGSTR_VAL_FILESHARING          TEXT("FileSharing")
#define REGSTR_VAL_PRINTSHARING         TEXT("PrintSharing")

//
//  Entries under REGSTR_PATH_NWREDIR
//
#define REGSTR_VAL_FIRSTNETDRIVE        TEXT("FirstNetworkDrive")
#define REGSTR_VAL_MAXCONNECTIONS       TEXT("MaxConnections")
#define REGSTR_VAL_APISUPPORT           TEXT("APISupport")
#define REGSTR_VAL_MAXRETRY             TEXT("MaxRetry")
#define REGSTR_VAL_MINRETRY             TEXT("MinRetry")
#define REGSTR_VAL_SUPPORTLFN           TEXT("SupportLFN")
#define REGSTR_VAL_SUPPORTBURST         TEXT("SupportBurst")
#define REGSTR_VAL_SUPPORTTUNNELLING    TEXT("SupportTunnelling")
#define REGSTR_VAL_FULLTRACE            TEXT("FullTrace")
#define REGSTR_VAL_READCACHING          TEXT("ReadCaching")
#define REGSTR_VAL_SHOWDOTS             TEXT("ShowDots")
#define REGSTR_VAL_GAPTIME              TEXT("GapTime")
#define REGSTR_VAL_SEARCHMODE           TEXT("SearchMode")
#define REGSTR_VAL_SHELLVERSION     TEXT("ShellVersion")
#define REGSTR_VAL_MAXLIP           TEXT("MaxLIP")
#define REGSTR_VAL_PRESERVECASE     TEXT("PreserveCase")
#define REGSTR_VAL_OPTIMIZESFN      TEXT("OptimizeSFN")

//
//  Entries under REGSTR_PATH_NCPSERVER
//
#define REGSTR_VAL_NCP_BROWSEMASTER     TEXT("BrowseMaster")
#define REGSTR_VAL_NCP_USEPEERBROWSING  TEXT("Use_PeerBrowsing")
#define REGSTR_VAL_NCP_USESAP           TEXT("Use_Sap")

//
// Entries under REGSTR_PATH_VCOMM
//

#define REGSTR_VAL_PCCARD_POWER         TEXT("EnablePowerManagement")

//
//  Entries under REGSTR_PATH_FILESYSTEM
//
#define REGSTR_VAL_WIN31FILESYSTEM              TEXT("Win31FileSystem")
#define REGSTR_VAL_PRESERVELONGNAMES            TEXT("PreserveLongNames")
#define REGSTR_VAL_DRIVEWRITEBEHIND             TEXT("DriveWriteBehind")
#define REGSTR_VAL_ASYNCFILECOMMIT              TEXT("AsyncFileCommit")
#define REGSTR_VAL_PATHCACHECOUNT               TEXT("PathCache")
#define REGSTR_VAL_NAMECACHECOUNT               TEXT("NameCache")
#define REGSTR_VAL_CONTIGFILEALLOC              TEXT("ContigFileAllocSize")
#define REGSTR_VAL_FREESPACERATIO               TEXT("FreeSpaceRatio")
#define REGSTR_VAL_VOLIDLETIMEOUT               TEXT("VolumeIdleTimeout")
#define REGSTR_VAL_BUFFIDLETIMEOUT              TEXT("BufferIdleTimeout")
#define REGSTR_VAL_BUFFAGETIMEOUT               TEXT("BufferAgeTimeout")
#define REGSTR_VAL_NAMENUMERICTAIL              TEXT("NameNumericTail")
#define REGSTR_VAL_READAHEADTHRESHOLD           TEXT("ReadAheadThreshold")
#define REGSTR_VAL_DOUBLEBUFFER                 TEXT("DoubleBuffer")
#define REGSTR_VAL_SOFTCOMPATMODE               TEXT("SoftCompatMode")
#define REGSTR_VAL_DRIVESPINDOWN                TEXT("DriveSpinDown")
#define REGSTR_VAL_FORCEPMIO                    TEXT("ForcePMIO")
#define REGSTR_VAL_FORCERMIO                    TEXT("ForceRMIO")
#define REGSTR_VAL_LASTBOOTPMDRVS               TEXT("LastBootPMDrvs")
#define REGSTR_VAL_ACSPINDOWNPREVIOUS           TEXT("ACSpinDownPrevious")
#define REGSTR_VAL_BATSPINDOWNPREVIOUS          TEXT("BatSpinDownPrevious")
#define REGSTR_VAL_VIRTUALHDIRQ                 TEXT("VirtualHDIRQ")
#define REGSTR_VAL_SRVNAMECACHECOUNT            TEXT("ServerNameCacheMax")
#define REGSTR_VAL_SRVNAMECACHE                 TEXT("ServerNameCache")
#define REGSTR_VAL_SRVNAMECACHENETPROV          TEXT("ServerNameCacheNumNets")
#define REGSTR_VAL_AUTOMOUNT                    TEXT("AutoMountDrives")
#define REGSTR_VAL_COMPRESSIONMETHOD            TEXT("CompressionAlgorithm")
#define REGSTR_VAL_COMPRESSIONTHRESHOLD         TEXT("CompressionThreshold")
#define REGSTR_VAL_ACDRIVESPINDOWN              TEXT("ACDriveSpinDown")
#define REGSTR_VAL_BATDRIVESPINDOWN             TEXT("BatDriveSpinDown")

//
//      Entries under REGSTR_PATH_FILESYSTEM_NOVOLTRACK
//
//      A sub-key under which a variable number of variable length structures are stored.
//
//      Each structure contains an offset followed by a number of pattern bytes.
//      The pattern in each structure is compared at the specified offset within
//      the boot record at the time a volume is mounted.  If any pattern in this
//      set of patterns matches a pattern already in the boot record, VFAT will not
//      write a volume tracking serial number in the OEM_SerialNum field of the
//      boot record on the volume being mounted.
//

//
//  Entries under REGSTR_PATH_CDFS
//
#define REGSTR_VAL_CDCACHESIZE  TEXT("CacheSize")       // Number of 2K cache sectors
#define REGSTR_VAL_CDPREFETCH   TEXT("Prefetch")        // Number of 2K cache sectors for prefetching
#define REGSTR_VAL_CDPREFETCHTAIL TEXT("PrefetchTail")// Number of LRU1 prefetch sectors
#define REGSTR_VAL_CDRAWCACHE   TEXT("RawCache")        // Number of 2352-byte cache sectors
#define REGSTR_VAL_CDEXTERRORS  TEXT("ExtendedErrors")// Return extended error codes
#define REGSTR_VAL_CDSVDSENSE   TEXT("SVDSense")        // 0=PVD, 1=Kanji, 2=Unicode
#define REGSTR_VAL_CDSHOWVERSIONS TEXT("ShowVersions")// Show file version numbers
#define REGSTR_VAL_CDCOMPATNAMES TEXT("MSCDEXCompatNames")// Disable Numeric Tails on long file names
#define REGSTR_VAL_CDNOREADAHEAD TEXT("NoReadAhead")    // Disable Read Ahead if set to 1

//
//      define values for IOS devices
//
#define REGSTR_VAL_SCSI TEXT("SCSI\\")
#define REGSTR_VAL_ESDI TEXT("ESDI\\")
#define REGSTR_VAL_FLOP TEXT("FLOP\\")

//
// define defs for IOS device types and values for IOS devices
//

#define REGSTR_VAL_DISK TEXT("GenDisk")
#define REGSTR_VAL_CDROM        TEXT("GenCD")
#define REGSTR_VAL_TAPE TEXT("TAPE")
#define REGSTR_VAL_SCANNER TEXT("SCANNER")
#define REGSTR_VAL_FLOPPY       TEXT("FLOPPY")

#define REGSTR_VAL_SCSITID TEXT("SCSITargetID")
#define REGSTR_VAL_SCSILUN TEXT("SCSILUN")
#define REGSTR_VAL_REVLEVEL TEXT("RevisionLevel")
#define REGSTR_VAL_PRODUCTID TEXT("ProductId")
#define REGSTR_VAL_PRODUCTTYPE TEXT("ProductType")
#define REGSTR_VAL_DEVTYPE TEXT("DeviceType")
#define REGSTR_VAL_REMOVABLE TEXT("Removable")
#define  REGSTR_VAL_CURDRVLET TEXT("CurrentDriveLetterAssignment")
#define REGSTR_VAL_USRDRVLET TEXT("UserDriveLetterAssignment")
#define REGSTR_VAL_SYNCDATAXFER TEXT("SyncDataXfer")
#define REGSTR_VAL_AUTOINSNOTE  TEXT("AutoInsertNotification")
#define REGSTR_VAL_DISCONNECT TEXT("Disconnect")
#define REGSTR_VAL_INT13 TEXT("Int13")
#define REGSTR_VAL_PMODE_INT13 TEXT("PModeInt13")
#define REGSTR_VAL_USERSETTINGS TEXT("AdapterSettings")
#define REGSTR_VAL_NOIDE TEXT("NoIDE")

// The foll. clase name definitions should be the same as in dirkdrv.inx and
// cdrom.inx
#define REGSTR_VAL_DISKCLASSNAME        TEXT("DiskDrive")
#define REGSTR_VAL_CDROMCLASSNAME       TEXT("CDROM")

// The foll. value determines whether a port driver should be force loaded
// or not.

#define REGSTR_VAL_FORCELOAD    TEXT("ForceLoadPD")

// The foll. value determines whether or not the FIFO is used on the Floppy
// controller.

#define REGSTR_VAL_FORCEFIFO    TEXT("ForceFIFO")
#define REGSTR_VAL_FORCECL              TEXT("ForceChangeLine")

//
// Generic CLASS Entries
//
#define REGSTR_VAL_NOUSECLASS       TEXT("NoUseClass")            // Don't include this class in PnP functions
#define REGSTR_VAL_NOINSTALLCLASS   TEXT("NoInstallClass")        // Don't include this class in New Device Wizard
#define REGSTR_VAL_NODISPLAYCLASS   TEXT("NoDisplayClass")        // Don't include this class in Device Manager
#define REGSTR_VAL_SILENTINSTALL    TEXT("SilentInstall")         // Always Silent Install devices of this class.
//
//  Class Names
//
#define REGSTR_KEY_PCMCIA_CLASS     TEXT("PCMCIA")              //child of PATH_CLASS
#define REGSTR_KEY_SCSI_CLASS       TEXT("SCSIAdapter")
#define REGSTR_KEY_PORTS_CLASS      TEXT("ports")
#define REGSTR_KEY_MEDIA_CLASS      TEXT("MEDIA")
#define REGSTR_KEY_DISPLAY_CLASS    TEXT("Display")
#define REGSTR_KEY_KEYBOARD_CLASS   TEXT("Keyboard")
#define REGSTR_KEY_MOUSE_CLASS      TEXT("Mouse")
#define REGSTR_KEY_MONITOR_CLASS    TEXT("Monitor")
#define REGSTR_KEY_MODEM_CLASS      TEXT("Modem")

//
//  Values under PATH_CLASS\PCMCIA
//
#define REGSTR_VAL_PCMCIA_OPT   TEXT("Options")
#define PCMCIA_OPT_HAVE_SOCKET  0x00000001l
//#define PCMCIA_OPT_ENABLED    0x00000002l
#define PCMCIA_OPT_AUTOMEM      0x00000004l
#define PCMCIA_OPT_NO_SOUND     0x00000008l
#define PCMCIA_OPT_NO_AUDIO     0x00000010l
#define PCMCIA_OPT_NO_APMREMOVE 0x00000020l

#define REGSTR_VAL_PCMCIA_MEM   TEXT("Memory")  // Card services shared mem range
#define PCMCIA_DEF_MEMBEGIN     0x000C0000      // default 0xC0000 - 0x00FFFFFF
#define PCMCIA_DEF_MEMEND       0x00FFFFFF      // (0 - 16meg)
#define PCMCIA_DEF_MEMLEN       0x00001000      // default 4k window

#define REGSTR_VAL_PCMCIA_ALLOC TEXT("AllocMemWin")     // PCCard alloced memory Window
#define REGSTR_VAL_PCMCIA_ATAD  TEXT("ATADelay")        // ATA device config start delay

#define REGSTR_VAL_PCMCIA_SIZ   TEXT("MinRegionSize") // Minimum region size
#define PCMCIA_DEF_MIN_REGION   0x00010000      // 64K minimum region size

// Values in LPTENUM keys
#define REGSTR_VAL_P1284MDL     TEXT("Model")
#define REGSTR_VAL_P1284MFG     TEXT("Manufacturer")

//
//  Values under PATH_CLASS\ISAPNP
//
#define REGSTR_VAL_ISAPNP               TEXT("ISAPNP")  // ISAPNP VxD name
#define REGSTR_VAL_ISAPNP_RDP_OVERRIDE  TEXT("RDPOverRide")     // ReadDataPort OverRide

//
//  Values under PATH_CLASS\PCI
//
#define REGSTR_VAL_PCI                  TEXT("PCI")             // PCI VxD name
#define REGSTR_PCI_OPTIONS              TEXT("Options") // Possible PCI options
#define REGSTR_PCI_DUAL_IDE             TEXT("PCIDualIDE")      // Dual IDE flag
#define PCI_OPTIONS_USE_BIOS            0x00000001l
#define PCI_OPTIONS_USE_IRQ_STEERING    0x00000002l

//
//  Values under PATH_CLASS\AGPxxxx
//
//  note:  These flags affect standard AGP capabilities,
//         and are set in agplib
//
#define AGP_FLAG_NO_1X_RATE             0x00000001l
#define AGP_FLAG_NO_2X_RATE             0x00000002l
#define AGP_FLAG_NO_4X_RATE             0x00000004l
#define AGP_FLAG_NO_8X_RATE             0x00000008l
#define AGP_FLAG_REVERSE_INITIALIZATION 0x00000080l

#define AGP_FLAG_NO_SBA_ENABLE          0x00000100l
#define AGP_FLAG_NO_FW_ENABLE           0x00000200l

//
// AGP flags > AGP_SPECIAL_TARGET are platform specific
//
#define AGP_FLAG_SPECIAL_TARGET         0x000FFFFFl
#define AGP_FLAG_SPECIAL_RESERVE        0x000F8000l

//
// Detection related values
//
#define REGSTR_KEY_CRASHES      TEXT("Crashes") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DANGERS      TEXT("Dangers") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DETMODVARS   TEXT("DetModVars")      // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_NDISINFO     TEXT("NDISInfo")        // key of netcard hw entry
#define REGSTR_VAL_PROTINIPATH  TEXT("ProtIniPath")     // protocol.ini path
#define REGSTR_VAL_RESOURCES    TEXT("Resources")       // resources of crash func.
#define REGSTR_VAL_CRASHFUNCS   TEXT("CrashFuncs")      // detfunc caused the crash
#define REGSTR_VAL_CLASS        TEXT("Class")   // device class
#define REGSTR_VAL_CLASSDESC    TEXT("ClassDesc")       // class description
#define REGSTR_VAL_DEVDESC      TEXT("DeviceDesc")      // device description
#define REGSTR_VAL_BOOTCONFIG   TEXT("BootConfig")      // detected configuration
#define REGSTR_VAL_DETFUNC      TEXT("DetFunc") // specifies detect mod/func.
#define REGSTR_VAL_DETFLAGS     TEXT("DetFlags")        // detection flags
#define REGSTR_VAL_COMPATIBLEIDS TEXT("CompatibleIDs") //value of enum\dev\inst
#define REGSTR_VAL_DETCONFIG    TEXT("DetConfig")       // detected configuration
#define REGSTR_VAL_VERIFYKEY    TEXT("VerifyKey")       // key used in verify mode
#define REGSTR_VAL_COMINFO      TEXT("ComInfo") // com info. for serial mouse
#define REGSTR_VAL_INFNAME      TEXT("InfName") // INF filename
#define REGSTR_VAL_CARDSPECIFIC TEXT("CardSpecific")    // Netcard specific info (WORD)
#define REGSTR_VAL_NETOSTYPE    TEXT("NetOSType")       // NetOS type associate w/ card
#define REGSTR_DATA_NETOS_NDIS  TEXT("NDIS")            // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_ODI   TEXT("ODI")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_IPX   TEXT("IPX")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_VAL_MFG      TEXT("Mfg")
#define REGSTR_VAL_SCAN_ONLY_FIRST      TEXT("ScanOnlyFirstDrive")      // used with IDE driver
#define REGSTR_VAL_SHARE_IRQ    TEXT("ForceIRQSharing") // used with IDE driver
#define REGSTR_VAL_NONSTANDARD_ATAPI    TEXT("NonStandardATAPI")        // used with IDE driver
#define REGSTR_VAL_IDE_FORCE_SERIALIZE  TEXT("ForceSerialization")      // used with IDE driver
#define REGSTR_VAL_MAX_HCID_LEN 1024            // Maximum hardware/compat ID len
#define REGSTR_VAL_HWREV            TEXT("HWRevision")
#define REGSTR_VAL_ENABLEINTS  TEXT("EnableInts")
//
// Bit values of REGSTR_VAL_DETFLAGS
//
#define REGDF_NOTDETIO          0x00000001      //cannot detect I/O resource
#define REGDF_NOTDETMEM         0x00000002      //cannot detect mem resource
#define REGDF_NOTDETIRQ         0x00000004      //cannot detect IRQ resource
#define REGDF_NOTDETDMA         0x00000008      //cannot detect DMA resource
#define REGDF_NOTDETALL         (REGDF_NOTDETIO | REGDF_NOTDETMEM | REGDF_NOTDETIRQ | REGDF_NOTDETDMA)
#define REGDF_NEEDFULLCONFIG    0x00000010      //stop devnode if lack resource
#define REGDF_GENFORCEDCONFIG   0x00000020      //also generate forceconfig
#define REGDF_NODETCONFIG       0x00008000      //don't write detconfig to reg.
#define REGDF_CONFLICTIO        0x00010000      //I/O res. in conflict
#define REGDF_CONFLICTMEM       0x00020000      //mem res. in conflict
#define REGDF_CONFLICTIRQ       0x00040000      //IRQ res. in conflict
#define REGDF_CONFLICTDMA       0x00080000      //DMA res. in conflict
#define REGDF_CONFLICTALL       (REGDF_CONFLICTIO | REGDF_CONFLICTMEM | REGDF_CONFLICTIRQ | REGDF_CONFLICTDMA)
#define REGDF_MAPIRQ2TO9        0x00100000      //IRQ2 has been mapped to 9
#define REGDF_NOTVERIFIED       0x80000000      //previous device unverified

//
//  Values in REGSTR_KEY_SYSTEMBOARD
//
#define REGSTR_VAL_APMBIOSVER           TEXT("APMBiosVer")
#define REGSTR_VAL_APMFLAGS             TEXT("APMFlags")
#define REGSTR_VAL_SLSUPPORT            TEXT("SLSupport")
#define REGSTR_VAL_MACHINETYPE          TEXT("MachineType")
#define REGSTR_VAL_SETUPMACHINETYPE TEXT("SetupMachineType")
#define REGSTR_MACHTYPE_UNKNOWN         TEXT("Unknown")
#define REGSTR_MACHTYPE_IBMPC           TEXT("IBM PC")
#define REGSTR_MACHTYPE_IBMPCJR         TEXT("IBM PCjr")
#define REGSTR_MACHTYPE_IBMPCCONV       TEXT("IBM PC Convertible")
#define REGSTR_MACHTYPE_IBMPCXT         TEXT("IBM PC/XT")
#define REGSTR_MACHTYPE_IBMPCXT_286     TEXT("IBM PC/XT 286")
#define REGSTR_MACHTYPE_IBMPCAT         TEXT("IBM PC/AT")
#define REGSTR_MACHTYPE_IBMPS2_25       TEXT("IBM PS/2-25")
#define REGSTR_MACHTYPE_IBMPS2_30_286   TEXT("IBM PS/2-30 286")
#define REGSTR_MACHTYPE_IBMPS2_30       TEXT("IBM PS/2-30")
#define REGSTR_MACHTYPE_IBMPS2_50       TEXT("IBM PS/2-50")
#define REGSTR_MACHTYPE_IBMPS2_50Z      TEXT("IBM PS/2-50Z")
#define REGSTR_MACHTYPE_IBMPS2_55SX     TEXT("IBM PS/2-55SX")
#define REGSTR_MACHTYPE_IBMPS2_60       TEXT("IBM PS/2-60")
#define REGSTR_MACHTYPE_IBMPS2_65SX     TEXT("IBM PS/2-65SX")
#define REGSTR_MACHTYPE_IBMPS2_70       TEXT("IBM PS/2-70")
#define REGSTR_MACHTYPE_IBMPS2_P70      TEXT("IBM PS/2-P70")
#define REGSTR_MACHTYPE_IBMPS2_70_80    TEXT("IBM PS/2-70/80")
#define REGSTR_MACHTYPE_IBMPS2_80       TEXT("IBM PS/2-80")
#define REGSTR_MACHTYPE_IBMPS2_90       TEXT("IBM PS/2-90")
#define REGSTR_MACHTYPE_IBMPS1          TEXT("IBM PS/1")
#define REGSTR_MACHTYPE_PHOENIX_PCAT    TEXT("Phoenix PC/AT Compatible")
#define REGSTR_MACHTYPE_HP_VECTRA       TEXT("HP Vectra")
#define REGSTR_MACHTYPE_ATT_PC          TEXT("AT&T PC")
#define REGSTR_MACHTYPE_ZENITH_PC       TEXT("Zenith PC")

#define REGSTR_VAL_APMMENUSUSPEND       TEXT("APMMenuSuspend")
#define APMMENUSUSPEND_DISABLED         0                   // always disabled
#define APMMENUSUSPEND_ENABLED          1                   // always enabled
#define APMMENUSUSPEND_UNDOCKED         2                   // enabled undocked
#define APMMENUSUSPEND_NOCHANGE     0x80        // bitflag - cannot change setting via UI

#define REGSTR_VAL_APMACTIMEOUT         TEXT("APMACTimeout")
#define REGSTR_VAL_APMBATTIMEOUT        TEXT("APMBatTimeout")
#define APMTIMEOUT_DISABLED             0

#define REGSTR_VAL_APMSHUTDOWNPOWER TEXT("APMShutDownPower")

#define REGSTR_VAL_BUSTYPE          TEXT("BusType")
#define REGSTR_VAL_CPU              TEXT("CPU")
#define REGSTR_VAL_NDP              TEXT("NDP")
#define REGSTR_VAL_PNPBIOSVER       TEXT("PnPBIOSVer")
#define REGSTR_VAL_PNPSTRUCOFFSET   TEXT("PnPStrucOffset")
#define REGSTR_VAL_PCIBIOSVER       TEXT("PCIBIOSVer")
#define REGSTR_VAL_HWMECHANISM      TEXT("HWMechanism")
#define REGSTR_VAL_LASTPCIBUSNUM    TEXT("LastPCIBusNum")
#define REGSTR_VAL_CONVMEM          TEXT("ConvMem")
#define REGSTR_VAL_EXTMEM           TEXT("ExtMem")
#define REGSTR_VAL_COMPUTERNAME     TEXT("ComputerName")
#define REGSTR_VAL_BIOSNAME         TEXT("BIOSName")
#define REGSTR_VAL_BIOSVERSION      TEXT("BIOSVersion")
#define REGSTR_VAL_BIOSDATE         TEXT("BIOSDate")
#define REGSTR_VAL_MODEL            TEXT("Model")
#define REGSTR_VAL_SUBMODEL         TEXT("Submodel")
#define REGSTR_VAL_REVISION         TEXT("Revision")

//
//  Values used in the LPT(ECP) device entry
//
#define REGSTR_VAL_FIFODEPTH            TEXT("FIFODepth")
#define REGSTR_VAL_RDINTTHRESHOLD       TEXT("RDIntThreshold")
#define REGSTR_VAL_WRINTTHRESHOLD       TEXT("WRIntThreshold")

//used in enum\xxx\<devname>\<instname>
#define REGSTR_VAL_PRIORITY     TEXT("Priority")
#define REGSTR_VAL_DRIVER       TEXT("Driver")          //
#define REGSTR_VAL_FUNCDESC     TEXT("FunctionDesc")            //
#define REGSTR_VAL_FORCEDCONFIG TEXT("ForcedConfig")            //
#define REGSTR_VAL_CONFIGFLAGS  TEXT("ConfigFlags")             // (binary ULONG)
#define REGSTR_VAL_CSCONFIGFLAGS TEXT("CSConfigFlags")  // (binary ULONG)

#define CONFIGFLAG_DISABLED             0x00000001      // Set if disabled
#define CONFIGFLAG_REMOVED              0x00000002      // Set if a present hardware enum device deleted
#define CONFIGFLAG_MANUAL_INSTALL       0x00000004      // Set if the devnode was manually installed
#define CONFIGFLAG_IGNORE_BOOT_LC       0x00000008      // Set if skip the boot config
#define CONFIGFLAG_NET_BOOT             0x00000010      // Load this devnode when in net boot
#define CONFIGFLAG_REINSTALL            0x00000020      // Redo install
#define CONFIGFLAG_FAILEDINSTALL        0x00000040      // Failed the install
#define CONFIGFLAG_CANTSTOPACHILD       0x00000080      // Can't stop/remove a single child
#define CONFIGFLAG_OKREMOVEROM          0x00000100      // Can remove even if rom.
#define CONFIGFLAG_NOREMOVEEXIT         0x00000200      // Don't remove at exit.
#define CONFIGFLAG_FINISH_INSTALL       0x00000400      // Complete install for devnode running 'raw'
#define CONFIGFLAG_NEEDS_FORCED_CONFIG  0x00000800      // This devnode requires a forced config
#if defined(REMOTE_BOOT)
#define CONFIGFLAG_NETBOOT_CARD         0x00001000      // This is the remote boot network card
#endif // defined(REMOTE_BOOT)
#define CONFIGFLAG_PARTIAL_LOG_CONF     0x00002000      // This device has a partial logconfig
#define CONFIGFLAG_SUPPRESS_SURPRISE    0x00004000      // Set if unsafe removals should be ignored
#define CONFIGFLAG_VERIFY_HARDWARE      0x00008000      // Set if hardware should be tested for logo failures
#define CONFIGFLAG_FINISHINSTALL_UI     0x00010000      // Show the finish install wizard pages for the installed device.
#define CONFIGFLAG_FINISHINSTALL_ACTION 0x00020000      // Call installer with DIF_FINISHINSTALL_ACTION in client context.

#define CSCONFIGFLAG_BITS               0x00000007      // OR of below bits
#define CSCONFIGFLAG_DISABLED           0x00000001      // Set if
#define CSCONFIGFLAG_DO_NOT_CREATE      0x00000002      // Set if
#define CSCONFIGFLAG_DO_NOT_START       0x00000004      // Set if

#define DMSTATEFLAG_APPLYTOALL      0x00000001  // Set if Apply To All check box is checked

//
// Special devnodes name
//
#define REGSTR_VAL_ROOT_DEVNODE         TEXT("HTREE\\ROOT\\0")
#define REGSTR_VAL_RESERVED_DEVNODE     TEXT("HTREE\\RESERVED\\0")
#define REGSTR_PATH_READDATAPORT        REGSTR_KEY_ISAENUM TEXT("\\ReadDataPort\\0")

//
// Multifunction definitions
//
#define REGSTR_PATH_MULTI_FUNCTION              TEXT("MF")
#define REGSTR_VAL_RESOURCE_MAP                 TEXT("ResourceMap")
#define REGSTR_PATH_CHILD_PREFIX                TEXT("Child")
#define NUM_RESOURCE_MAP                        256
#define REGSTR_VAL_MF_FLAGS                     TEXT("MFFlags")
#define MF_FLAGS_EVEN_IF_NO_RESOURCE            0x00000001
#define MF_FLAGS_NO_CREATE_IF_NO_RESOURCE       0x00000002
#define MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE       0x00000004
#define MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED    0x00000008

//
// EISA multi functions add-on
//
#ifndef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("EISARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("EISAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("EISAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("EISAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("EISASimulateInt15")
#else // ifdef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("NESARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("NESAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("NESAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("NESAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("NESASimulateInt15")
#endif // ifdef NEC_98
#define EISAFLAG_NO_IO_MERGE            0x00000001
#define EISAFLAG_SLOT_IO_FIRST          0x00000002
#define EISA_NO_MAX_FUNCTION            0xFF
#define NUM_EISA_RANGES                 4


//
//  Driver entries
//
#define REGSTR_VAL_DRVDESC      TEXT("DriverDesc")      // value of enum\dev\inst\DRV
#define REGSTR_VAL_DEVLOADER    TEXT("DevLoader")       // value of DRV
#define REGSTR_VAL_STATICVXD    TEXT("StaticVxD")       // value of DRV
#define REGSTR_VAL_PROPERTIES   TEXT("Properties")      // value of DRV
#define REGSTR_VAL_MANUFACTURER TEXT("Manufacturer")
#define REGSTR_VAL_EXISTS       TEXT("Exists")  // value of HCC\HW\ENUM\ROOT\dev\inst
#define REGSTR_VAL_CMENUMFLAGS  TEXT("CMEnumFlags")     // (binary ULONG)
#define REGSTR_VAL_CMDRIVFLAGS  TEXT("CMDrivFlags")     // (binary ULONG)
#define REGSTR_VAL_ENUMERATOR   TEXT("Enumerator")      // value of DRV
#define REGSTR_VAL_DEVICEDRIVER TEXT("DeviceDriver")    // value of DRV
#define REGSTR_VAL_PORTNAME     TEXT("PortName")        // VCOMM uses this for it's port names
#define REGSTR_VAL_INFPATH      TEXT("InfPath")
#define REGSTR_VAL_INFSECTION   TEXT("InfSection")
#define REGSTR_VAL_INFSECTIONEXT TEXT("InfSectionExt")
#define REGSTR_VAL_POLLING      TEXT("Polling")             // SCSI specific
#define REGSTR_VAL_DONTLOADIFCONFLICT TEXT("DontLoadIfConflict")  // SCSI specific
#define REGSTR_VAL_PORTSUBCLASS TEXT("PortSubClass")
#define REGSTR_VAL_NETCLEAN TEXT("NetClean") // Driver required for NetClean boot
#define REGSTR_VAL_IDE_NO_SERIALIZE TEXT("IDENoSerialize") // IDE specific
#define REGSTR_VAL_NOCMOSORFDPT TEXT("NoCMOSorFDPT")       // IDE specific
#define REGSTR_VAL_COMVERIFYBASE TEXT("COMVerifyBase")     // VCD specific
#define REGSTR_VAL_MATCHINGDEVID TEXT("MatchingDeviceId")
#define REGSTR_VAL_DRIVERDATE   TEXT("DriverDate")      // value of DRV
#define REGSTR_VAL_DRIVERDATEDATA TEXT("DriverDateData")// value of DRV
#define REGSTR_VAL_DRIVERVERSION TEXT("DriverVersion")  // value of DRV
#define REGSTR_VAL_LOCATION_INFORMATION_OVERRIDE    TEXT("LocationInformationOverride")  // value of DRV


//
//  Driver keys
//
#define REGSTR_KEY_OVERRIDE     TEXT("Override")        // key under the software section

//used by CONFIGMG
#define REGSTR_VAL_CONFIGMG     TEXT("CONFIGMG")        // Config Manager VxD name
#define REGSTR_VAL_SYSDM        TEXT("SysDM")           // The device installer DLL
#define REGSTR_VAL_SYSDMFUNC    TEXT("SysDMFunc")       // The device installer DLL function
#define REGSTR_VAL_PRIVATE      TEXT("Private") // The private library
#define REGSTR_VAL_PRIVATEFUNC  TEXT("PrivateFunc")     // The private library function
#define REGSTR_VAL_DETECT       TEXT("Detect")  // The detection library
#define REGSTR_VAL_DETECTFUNC   TEXT("DetectFunc")      // The detection library function
#define REGSTR_VAL_ASKFORCONFIG TEXT("AskForConfig")    // The AskForConfig library
#define REGSTR_VAL_ASKFORCONFIGFUNC TEXT("AskForConfigFunc") // The AskForConfig library function
#define REGSTR_VAL_WAITFORUNDOCK TEXT("WaitForUndock")  // The WaitForUndock library
#define REGSTR_VAL_WAITFORUNDOCKFUNC TEXT("WaitForUndockFunc") // The WaitForUndock library function
#define REGSTR_VAL_REMOVEROMOKAY TEXT("RemoveRomOkay")  // The RemoveRomOkay library
#define REGSTR_VAL_REMOVEROMOKAYFUNC TEXT("RemoveRomOkayFunc") // The RemoveRomOkay library function

//used in IDCONFIGDB
#define REGSTR_VAL_CURCONFIG    TEXT("CurrentConfig")           //value of idconfigdb
#define REGSTR_VAL_FRIENDLYNAME TEXT("FriendlyName")            //value of idconfigdb
#define REGSTR_VAL_CURRENTCONFIG TEXT("CurrentConfig")  //value of idconfigdb
#define REGSTR_VAL_MAP          TEXT("Map")                     //value of idconfigdb
#define REGSTR_VAL_ID           TEXT("CurrentID")               //value of idconfigdb
#define REGSTR_VAL_DOCKED       TEXT("CurrentDockedState")      //value of idconfigdb
#define REGSTR_VAL_CHECKSUM     TEXT("CurrentChecksum") //value of idconfigdb
#define REGSTR_VAL_HWDETECT     TEXT("HardwareDetect")  //value of idconfigdb
#define REGSTR_VAL_INHIBITRESULTS TEXT("InhibitResults")        //value of idconfigdb

//used in HKEY_CURRENT_CONFIG
#define REGSTR_VAL_PROFILEFLAGS TEXT("ProfileFlags")    // value of HKEY_CURRENT_CONFIG

//used in PCMCIA
#define REGSTR_KEY_PCMCIA       TEXT("PCMCIA\\")        //PCMCIA dev ID prefix
#define REGSTR_KEY_PCUNKNOWN    TEXT("UNKNOWN_MANUFACTURER")    //PCMCIA dev ID manuf
#define REGSTR_VAL_PCSSDRIVER   TEXT("Driver")  //value of DRV
#define REGSTR_KEY_PCMTD        TEXT("MTD-")            //MTD dev ID component
#define REGSTR_VAL_PCMTDRIVER   TEXT("MTD")             //value of Mem Tech DRV

//used in hardware\enum\dev\inst by Device Installer
#define REGSTR_VAL_HARDWAREID    TEXT("HardwareID")      //value of enum\dev\inst

//value names under class brach REGSTR_KEY_CLASS + class name
// and for the drivers REGSTR_KEY_CLASS\classname\xxxx
#define REGSTR_VAL_INSTALLER          TEXT("Installer")         // 16-bit class installer module/entry point
#define REGSTR_VAL_INSTALLER_32       TEXT("Installer32")       // 32-bit class installer module/entry point
#define REGSTR_VAL_INSICON            TEXT("Icon")              // value of class\name
#define REGSTR_VAL_ENUMPROPPAGES      TEXT("EnumPropPages")     // For Class/Device Properties (16-bit)
#define REGSTR_VAL_ENUMPROPPAGES_32   TEXT("EnumPropPages32")   // For Class/Device Properties (32-bit)
#define REGSTR_VAL_BASICPROPERTIES    TEXT("BasicProperties")   // For CPL basic Properties (16-bit)
#define REGSTR_VAL_BASICPROPERTIES_32 TEXT("BasicProperties32") // For CPL basic Properties (32-bit)
#define REGSTR_VAL_COINSTALLERS_32    TEXT("CoInstallers32")    // Device-specific co-installer multi-sz list (32-bit)
#define REGSTR_VAL_PRIVATEPROBLEM     TEXT("PrivateProblem")    // For Handling Private Problems

// names used for display driver set information
#define REGSTR_KEY_CURRENT      TEXT("Current") // current mode information
#define REGSTR_KEY_DEFAULT      TEXT("Default") // default configuration
#define REGSTR_KEY_MODES        TEXT("Modes")   // modes subtree

#define REGSTR_VAL_MODE         TEXT("Mode")            // default mode
#define REGSTR_VAL_BPP          TEXT("BPP")             // bits per pixel
#define REGSTR_VAL_HRES         TEXT("HRes")            // horizontal resolution
#define REGSTR_VAL_VRES         TEXT("VRes")            // vertical resolution
#define REGSTR_VAL_FONTSIZE     TEXT("FontSize")        // used in default or override
#define REGSTR_VAL_DRV          TEXT("drv")             // the driver file
#define REGSTR_VAL_GRB          TEXT("grb")             // the grabber file
#define REGSTR_VAL_VDD          TEXT("vdd")             // vdds used here
#define REGSTR_VAL_VER          TEXT("Ver")
#define REGSTR_VAL_MAXRES       TEXT("MaxResolution") // max res for monitors
#define REGSTR_VAL_DPMS         TEXT("DPMS")            // DPMS enabled
#define REGSTR_VAL_RESUMERESET  TEXT("ResumeReset")   // need reset on resume

#define REGSTR_VAL_DESCRIPTION TEXT("Description")

// keys in fontsize tree
#define REGSTR_KEY_SYSTEM       TEXT("System")  // entries for system.ini
#define REGSTR_KEY_USER         TEXT("User")            // entries for win.ini
#define REGSTR_VAL_DPI          TEXT("dpi")             // dpi of fontsize

//
// Used by PCIC socket services
//
#define REGSTR_VAL_PCICOPTIONS  TEXT("PCICOptions")     // Binary DWORD.  IRQ mask in
                                                // low word.  # skts in high
#ifndef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x4EB8          // Default IRQ masks
#else // ifdef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x1468          // Default IRQ masks
#endif // ifdef NEC_98
#define PCIC_DEFAULT_NUMSOCKETS 0               // 0 = Automatic detection
#define REGSTR_VAL_PCICIRQMAP   TEXT("PCICIRQMap")      // Binary 16 byte IRQ map table

// names used for control panel entries
#define REGSTR_PATH_APPEARANCE  TEXT("Control Panel\\Appearance")
#define REGSTR_PATH_LOOKSCHEMES TEXT("Control Panel\\Appearance\\Schemes")
#define REGSTR_VAL_CUSTOMCOLORS TEXT("CustomColors")

#define REGSTR_PATH_SCREENSAVE          TEXT("Control Panel\\Desktop")
#define REGSTR_VALUE_USESCRPASSWORD TEXT("ScreenSaveUsePassword")
#define REGSTR_VALUE_SCRPASSWORD    TEXT("ScreenSave_Data")

#define REGSTR_VALUE_LOWPOWERTIMEOUT    TEXT("ScreenSaveLowPowerTimeout")
#define REGSTR_VALUE_POWEROFFTIMEOUT    TEXT("ScreenSavePowerOffTimeout")
#define REGSTR_VALUE_LOWPOWERACTIVE     TEXT("ScreenSaveLowPowerActive")
#define REGSTR_VALUE_POWEROFFACTIVE     TEXT("ScreenSavePowerOffActive")

// used for Windows applets
#define REGSTR_PATH_WINDOWSAPPLETS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets")

//
// system tray.  Flag values defined in systrap.h
//
#define REGSTR_PATH_SYSTRAY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\SysTray")
#define REGSTR_VAL_SYSTRAYSVCS TEXT("Services")
#define REGSTR_VAL_SYSTRAYBATFLAGS TEXT("PowerFlags")
#define REGSTR_VAL_SYSTRAYPCCARDFLAGS TEXT("PCMCIAFlags")

//
// Used by system networking components to store per-user values.
// All keys here are under HKCU.
//
#define REGSTR_PATH_NETWORK_USERSETTINGS        TEXT("Network")

#define REGSTR_KEY_NETWORK_PERSISTENT           TEXT("\\Persistent")
#define REGSTR_KEY_NETWORK_RECENT               TEXT("\\Recent")
#define REGSTR_VAL_REMOTE_PATH                  TEXT("RemotePath")
#define REGSTR_VAL_USER_NAME                    TEXT("UserName")
#define REGSTR_VAL_PROVIDER_NAME                TEXT("ProviderName")
#define REGSTR_VAL_CONNECTION_TYPE              TEXT("ConnectionType")
#define REGSTR_VAL_UPGRADE                      TEXT("Upgrade")

#define REGSTR_KEY_LOGON TEXT("\\Logon")
#define REGSTR_VAL_MUSTBEVALIDATED  TEXT("MustBeValidated")
#define REGSTR_VAL_RUNLOGINSCRIPT       TEXT("ProcessLoginScript")

//
// NetworkProvider entries. These entries are under
// REGSTR_PATH_SERVICES\\xxx\\NetworkProvider
//
#define REGSTR_KEY_NETWORKPROVIDER TEXT("\\NetworkProvider")
#define REGSTR_PATH_NW32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\NWNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_PATH_MS32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\MSNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_VAL_AUTHENT_AGENT TEXT("AuthenticatingAgent")

//
// Entries under REGSTR_PATH_REALMODENET
//
#define REGSTR_VAL_PREFREDIR TEXT("PreferredRedir")
#define REGSTR_VAL_AUTOSTART TEXT("AutoStart")
#define REGSTR_VAL_AUTOLOGON TEXT("AutoLogon")
#define REGSTR_VAL_NETCARD TEXT("Netcard")
#define REGSTR_VAL_TRANSPORT TEXT("Transport")
#define REGSTR_VAL_DYNAMIC TEXT("Dynamic")
#define REGSTR_VAL_TRANSITION TEXT("Transition")
#define REGSTR_VAL_STATICDRIVE TEXT("StaticDrive")
#define REGSTR_VAL_LOADHI TEXT("LoadHi")
#define REGSTR_VAL_LOADRMDRIVERS TEXT("LoadRMDrivers")
#define REGSTR_VAL_SETUPN TEXT("SetupN")
#define REGSTR_VAL_SETUPNPATH TEXT("SetupNPath")

//
// Entries under REGSTR_PATH_CVNETWORK
//
#define REGSTR_VAL_WRKGRP_FORCEMAPPING TEXT("WrkgrpForceMapping")
#define REGSTR_VAL_WRKGRP_REQUIRED TEXT("WrkgrpRequired")

//
// NT-compatible place where the name of the currently logged-on user is stored.
//
#define REGSTR_PATH_CURRENT_CONTROL_SET TEXT("System\\CurrentControlSet\\Control")
#define REGSTR_VAL_CURRENT_USER                 TEXT("Current User")

// section where password providers are installed (each provider has subkey under this key)
#define REGSTR_PATH_PWDPROVIDER         TEXT("System\\CurrentControlSet\\Control\\PwdProvider")
#define REGSTR_VAL_PWDPROVIDER_PATH TEXT("ProviderPath")
#define REGSTR_VAL_PWDPROVIDER_DESC TEXT("Description")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWD TEXT("ChangePassword")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWDHWND TEXT("ChangePasswordHwnd")
#define REGSTR_VAL_PWDPROVIDER_GETPWDSTATUS TEXT("GetPasswordStatus")
#define REGSTR_VAL_PWDPROVIDER_ISNP TEXT("NetworkProvider")
#define REGSTR_VAL_PWDPROVIDER_CHANGEORDER TEXT("ChangeOrder")

//
// Used by administrator configuration tool and various components who enforce
// policies.
//
#define REGSTR_PATH_POLICIES    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")

// used to control remote update of administrator policies
#define REGSTR_PATH_UPDATE              TEXT("System\\CurrentControlSet\\Control\\Update")
#define REGSTR_VALUE_ENABLE             TEXT("Enable")
#define REGSTR_VALUE_VERBOSE    TEXT("Verbose")
#define REGSTR_VALUE_NETPATH    TEXT("NetworkPath")
#define REGSTR_VALUE_DEFAULTLOC TEXT("UseDefaultNetLocation")

//
//      Entries under REGSTR_PATH_POLICIES
//
#define REGSTR_KEY_NETWORK              TEXT("Network")
#define REGSTR_KEY_SYSTEM               TEXT("System")
#define REGSTR_KEY_PRINTERS             TEXT("Printers")
#define REGSTR_KEY_WINOLDAPP            TEXT("WinOldApp")
#define REGSTR_KEY_EXPLORER             TEXT("Explorer")

// Explorer run policy
#define REGSTR_PATH_RUN_POLICY          REGSTR_PATH_POLICIES TEXT("\\Explorer\\Run")

// (following are values REG_DWORD, legal values 0 or 1, treat as TEXT("0") if value not present)
// policies under NETWORK key
#define REGSTR_VAL_NOFILESHARING                TEXT("NoFileSharing") // TEXT("1") prevents server from loading
#define REGSTR_VAL_NOPRINTSHARING               TEXT("NoPrintSharing")
#define REGSTR_VAL_NOFILESHARINGCTRL    TEXT("NoFileSharingControl") // TEXT("1") removes sharing ui
#define REGSTR_VAL_NOPRINTSHARINGCTRL   TEXT("NoPrintSharingControl")
#define REGSTR_VAL_HIDESHAREPWDS                TEXT("HideSharePwds") // TEXT("1") hides share passwords with asterisks
#define REGSTR_VAL_DISABLEPWDCACHING    TEXT("DisablePwdCaching") // TEXT("1") disables caching
#define REGSTR_VAL_ALPHANUMPWDS                 TEXT("AlphanumPwds") // TEXT("1") forces alphanumeric passwords
#define REGSTR_VAL_NETSETUP_DISABLE                     TEXT("NoNetSetup")
#define REGSTR_VAL_NETSETUP_NOCONFIGPAGE        TEXT("NoNetSetupConfigPage")
#define REGSTR_VAL_NETSETUP_NOIDPAGE            TEXT("NoNetSetupIDPage")
#define REGSTR_VAL_NETSETUP_NOSECURITYPAGE      TEXT("NoNetSetupSecurityPage")
#define REGSTR_VAL_SYSTEMCPL_NOVIRTMEMPAGE  TEXT("NoVirtMemPage")
#define REGSTR_VAL_SYSTEMCPL_NODEVMGRPAGE   TEXT("NoDevMgrPage")
#define REGSTR_VAL_SYSTEMCPL_NOCONFIGPAGE       TEXT("NoConfigPage")
#define REGSTR_VAL_SYSTEMCPL_NOFILESYSPAGE      TEXT("NoFileSysPage")
#define REGSTR_VAL_DISPCPL_NODISPCPL            TEXT("NoDispCPL")
#define REGSTR_VAL_DISPCPL_NOBACKGROUNDPAGE TEXT("NoDispBackgroundPage")
#define REGSTR_VAL_DISPCPL_NOSCRSAVPAGE TEXT("NoDispScrSavPage")
#define REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE TEXT("NoDispAppearancePage")
#define REGSTR_VAL_DISPCPL_NOSETTINGSPAGE TEXT("NoDispSettingsPage")
#define REGSTR_VAL_SECCPL_NOSECCPL                      TEXT("NoSecCPL")
#define REGSTR_VAL_SECCPL_NOPWDPAGE                     TEXT("NoPwdPage")
#define REGSTR_VAL_SECCPL_NOADMINPAGE           TEXT("NoAdminPage")
#define REGSTR_VAL_SECCPL_NOPROFILEPAGE         TEXT("NoProfilePage")
#define REGSTR_VAL_PRINTERS_HIDETABS            TEXT("NoPrinterTabs")
#define REGSTR_VAL_PRINTERS_NODELETE            TEXT("NoDeletePrinter")
#define REGSTR_VAL_PRINTERS_NOADD                       TEXT("NoAddPrinter")
#define REGSTR_VAL_WINOLDAPP_DISABLED           TEXT("Disabled")
#define REGSTR_VAL_WINOLDAPP_NOREALMODE         TEXT("NoRealMode")
#define REGSTR_VAL_NOENTIRENETWORK                      TEXT("NoEntireNetwork")
#define REGSTR_VAL_NOWORKGROUPCONTENTS          TEXT("NoWorkgroupContents")

// (following are values REG_DWORD, legal values 0 or 1, treat as TEXT("1") if value not present)
// policies under Policies\SYSTEM key
#define REGSTR_VAL_UNDOCK_WITHOUT_LOGON         TEXT("UndockWithoutLogon")

// REG_DWORD, 0=off, otherwise value is minimum # of chars to allow in password
#define REGSTR_VAL_MINPWDLEN                    TEXT("MinPwdLen")
// REG_DWORD, 0=off, otherwise value is # of days for pwd to expire
#define REGSTR_VAL_PWDEXPIRATION                TEXT("PwdExpiration")

#define REGSTR_VAL_WIN31PROVIDER                TEXT("Win31Provider") // REG_SZ

// policies under SYSTEM key
#define REGSTR_VAL_DISABLEREGTOOLS              TEXT("DisableRegistryTools")

#define REGSTR_PATH_WINLOGON    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Winlogon")
#define REGSTR_VAL_LEGALNOTICECAPTION   TEXT("LegalNoticeCaption")      // REG_SZ
#define REGSTR_VAL_LEGALNOTICETEXT              TEXT("LegalNoticeText")         // REG_SZ
#define REGSTR_VAL_DRIVE_SPINDOWN               TEXT("NoDispSpinDown")
#define REGSTR_VAL_SHUTDOWN_FLAGS       	TEXT("ShutdownFlags")


#define REGSTR_VAL_RESTRICTRUN  TEXT("RestrictRun")
//
//  Entries in policy file.  (Won't be in local registry, only policy hive)
#define REGSTR_KEY_POL_USERS            TEXT("Users")
#define REGSTR_KEY_POL_COMPUTERS        TEXT("Computers")
#define REGSTR_KEY_POL_USERGROUPS       TEXT("UserGroups")
#define REGSTR_KEY_POL_DEFAULT          TEXT(".default")
#define REGSTR_KEY_POL_USERGROUPDATA TEXT("GroupData\\UserGroups\\Priority")

//
//      Entries for time zone information under LOCAL_MACHINE
//
#define REGSTR_PATH_TIMEZONE        TEXT("System\\CurrentControlSet\\Control\\TimeZoneInformation")
#define REGSTR_VAL_TZBIAS           TEXT("Bias")
#define REGSTR_VAL_TZDLTBIAS        TEXT("DaylightBias")
#define REGSTR_VAL_TZSTDBIAS        TEXT("StandardBias")
#define REGSTR_VAL_TZACTBIAS        TEXT("ActiveTimeBias")
#define REGSTR_VAL_TZDLTFLAG        TEXT("DaylightFlag")
#define REGSTR_VAL_TZSTDSTART       TEXT("StandardStart")
#define REGSTR_VAL_TZDLTSTART       TEXT("DaylightStart")
#define REGSTR_VAL_TZDLTNAME        TEXT("DaylightName")
#define REGSTR_VAL_TZSTDNAME        TEXT("StandardName")
#define REGSTR_VAL_TZNOCHANGESTART  TEXT("NoChangeStart")
#define REGSTR_VAL_TZNOCHANGEEND    TEXT("NoChangeEnd")
#define REGSTR_VAL_TZNOAUTOTIME     TEXT("DisableAutoDaylightTimeSet")

//
//      Entries for floating point processor existence under LOCAL_MACHINE
//
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor")
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR0 TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor\\0")


//
//      Entries for computer name under LOCAL_MACHINE
//
#define REGSTR_PATH_COMPUTRNAME TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName")
#define REGSTR_VAL_COMPUTRNAME TEXT("ComputerName")

//      Entry so that we force a reboot on shutdown / single instance dos app
#define REGSTR_PATH_SHUTDOWN TEXT("System\\CurrentControlSet\\Control\\Shutdown")
#define REGSTR_VAL_FORCEREBOOT     TEXT("ForceReboot")
#define REGSTR_VAL_SETUPPROGRAMRAN TEXT("SetupProgramRan")
#define REGSTR_VAL_DOES_POLLING    TEXT("PollingSupportNeeded")

//
//      Entries for known system DLLs under LOCAL_MACHINE
//
//      The VAL keys here are the actual DLL names (FOO.DLL)
//
#define REGSTR_PATH_KNOWNDLLS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs")
#define REGSTR_PATH_KNOWN16DLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\Known16DLLs")

//      Entries here for system dlls we need to version check in case overwritten
#define REGSTR_PATH_CHECKVERDLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckVerDLLs")
#define REGSTR_PATH_WARNVERDLLS  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\WarnVerDLLs")

//      Entries here for app ini files we (msgsrv32) need to hack
#define REGSTR_PATH_HACKINIFILE  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\HackIniFiles")

//      Keys here for bad applications we want to warn the user about before running
#define REGSTR_PATH_CHECKBADAPPS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps")

//      Keys here for applications we need to update
#define REGSTR_PATH_APPPATCH TEXT("System\\CurrentControlSet\\Control\\SessionManager\\AppPatches")

#define REGSTR_PATH_CHECKBADAPPS400 TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps400")

//
//      Entries for known system VxDs under LOCAL_MACHINE
//
//      The VAL keys here are the full path names of VxDs (c:\app\vapp.vxd)
//      It is suggested that the keynames be the same as the module name of
//      the VxD.
//      This section is used to dyna-load VxDs with
//      CreateFile(\\.\vxd_regstr_keyname).
//

#define REGSTR_PATH_KNOWNVXDS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownVxDs")

//
// Entries for values in uninstaller keys under REGSTR_PATH_UNINSTALL \ appname
//
#define REGSTR_VAL_UNINSTALLER_DISPLAYNAME     TEXT("DisplayName")
#define REGSTR_VAL_UNINSTALLER_COMMANDLINE     TEXT("UninstallString")

//
// Entries for values in uninstaller keys under REGSTR_PATH_REINSTALL \ instanceid
//
#define REGSTR_VAL_REINSTALL_DISPLAYNAME        TEXT("DisplayName")
#define REGSTR_VAL_REINSTALL_STRING             TEXT("ReinstallString")
#define REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS  TEXT("DeviceInstanceIds")

//
//      Entries for known per user settings: Under HKEY_CURRENT_USER
//
#define REGSTR_PATH_DESKTOP     REGSTR_PATH_SCREENSAVE
#define REGSTR_PATH_MOUSE           TEXT("Control Panel\\Mouse")
#define REGSTR_PATH_KEYBOARD    TEXT("Control Panel\\Keyboard")
#define REGSTR_PATH_COLORS          TEXT("Control Panel\\Colors")
#define REGSTR_PATH_SOUND           TEXT("Control Panel\\Sound")
#define REGSTR_PATH_METRICS         TEXT("Control Panel\\Desktop\\WindowMetrics")
#define REGSTR_PATH_ICONS       TEXT("Control Panel\\Icons")
#define REGSTR_PATH_CURSORS     TEXT("Control Panel\\Cursors")
#define REGSTR_PATH_CHECKDISK   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive")
#define REGSTR_PATH_CHECKDISKSET    TEXT("Settings")
#define REGSTR_PATH_CHECKDISKUDRVS  TEXT("NoUnknownDDErrDrvs")
//
//  Entries under REGSTR_PATH_FAULT
//
#define REGSTR_PATH_FAULT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fault")
#define REGSTR_VAL_FAULT_LOGFILE        TEXT("LogFile")

//
//  Entries under REGSTR_PATH_AEDEBUG
//
#define REGSTR_PATH_AEDEBUG             TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug")
#define REGSTR_VAL_AEDEBUG_DEBUGGER     TEXT("Debugger")
#define REGSTR_VAL_AEDEBUG_AUTO         TEXT("Auto")

//
//  Entries under REGSTR_PATH_GRPCONV
//
#define REGSTR_PATH_GRPCONV     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\GrpConv")

//
//  Entries under the RegItem key in a shell namespace
//
#define REGSTR_VAL_REGITEMDELETEMESSAGE TEXT("Removal Message")

//
//  Entries for the Drives Tools page
//
//  NOTE that these items are not recorded for removable drives. These
//  keys record X=DSKTLSYSTEMTIME where X is the drive letter. Since
//  these tools actually work on the disk in the drive, as opposed to
//  the drive itself, it is pointless to record them on a removable media
//  since if a different disk is inserted in the drive, the data is
//  meaningless.
//
#define REGSTR_PATH_LASTCHECK           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastCheck")
#define REGSTR_PATH_LASTOPTIMIZE        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastOptimize")
#define REGSTR_PATH_LASTBACKUP          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastBackup")
//
// The above 3 keys record with the registry value of the drive letter
// a SYSTEMTIME structure
//

//
// Entries under HKEY_LOCAL_MACHINE for Check Drive specific stuff
//
#define REGSTR_PATH_CHKLASTCHECK        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastCheck")
#define REGSTR_PATH_CHKLASTSURFAN       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastSurfaceAnalysis")

#ifndef _IN_KERNEL_

//
// The above 2 keys record the following binary structure which is
// a system time structure with the addition of a result code field.
// Note that the time part of REGSTR_PATH_CHKLASTCHECK is effectively
// identical to REGSTR_PATH_LASTCHECK under the explorer key
//
typedef struct _DSKTLSYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    WORD wResult;
} DSKTLSYSTEMTIME, *PDSKTLSYSTEMTIME, *LPDSKTLSYSTEMTIME;

#endif

//
// The following are defines for the wResult field
//
#define DTRESULTOK      0       // Operation was successful, no errors
#define DTRESULTFIX     1       // Operation was successful, errors were found
                                //   but all were fixed.
#define DTRESULTPROB    2       // Operation was not successful or errors
                                //   were found and some or all were not fixed.
#define DTRESULTPART    3       // Operation was partially completed but was
                                //   terminated either by the user or an error.

//
//  Entries for persistent shares
//
#define REGSTR_KEY_SHARES             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\LanMan")
#define REGSTR_VAL_SHARES_FLAGS   TEXT("Flags")
#define REGSTR_VAL_SHARES_TYPE    TEXT("Type")
#define REGSTR_VAL_SHARES_PATH    TEXT("Path")
#define REGSTR_VAL_SHARES_REMARK  TEXT("Remark")
#define REGSTR_VAL_SHARES_RW_PASS TEXT("Parm1")
#define REGSTR_VAL_SHARES_RO_PASS TEXT("Parm2")

//
//      Entries for printer settings under LOCAL_MACHINE
//
#define REGSTR_PATH_PRINT           TEXT("System\\CurrentControlSet\\Control\\Print")
#define REGSTR_PATH_PRINTERS        TEXT("System\\CurrentControlSet\\Control\\Print\\Printers")
#define REGSTR_PATH_PROVIDERS       TEXT("System\\CurrentControlSet\\Control\\Print\\Providers")
#define REGSTR_PATH_MONITORS        TEXT("System\\CurrentControlSet\\Control\\Print\\Monitors")
#define REGSTR_PATH_ENVIRONMENTS    TEXT("System\\CurrentControlSet\\Control\\Print\\Environments")
#define REGSTR_VAL_START_ON_BOOT    TEXT("StartOnBoot")
#define REGSTR_VAL_PRINTERS_MASK    TEXT("PrintersMask")
#define REGSTR_VAL_DOS_SPOOL_MASK   TEXT("DOSSpoolMask")
#define REGSTR_KEY_CURRENT_ENV      TEXT("\\Windows 4.0")
#define REGSTR_KEY_DRIVERS          TEXT("\\Drivers")
#define REGSTR_KEY_PRINT_PROC       TEXT("\\Print Processors")

//
// Entries for MultiMedia under HKEY_CURRENT_USER
//
#define REGSTR_PATH_EVENTLABELS     TEXT("AppEvents\\EventLabels")
#define REGSTR_PATH_SCHEMES         TEXT("AppEvents\\Schemes")
#define REGSTR_PATH_APPS            REGSTR_PATH_SCHEMES TEXT("\\Apps")
#define REGSTR_PATH_APPS_DEFAULT    REGSTR_PATH_SCHEMES TEXT("\\Apps\\.Default")
#define REGSTR_PATH_NAMES           REGSTR_PATH_SCHEMES TEXT("\\Names")
#define REGSTR_PATH_MULTIMEDIA      REGSTR_PATH_SETUP TEXT("\\Multimedia")
#define REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("Software\\Microsoft\\Multimedia\\Audio")
#define REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("\\Images")

//
// Entries for MultiMedia under HKEY_LOCAL_MACHINE
//
#define REGSTR_PATH_MEDIARESOURCES  REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaResources")
#define REGSTR_PATH_MEDIAPROPERTIES REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaProperties")
#define REGSTR_PATH_PRIVATEPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PrivateProperties")
#define REGSTR_PATH_PUBLICPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PublicProperties")

// joysticks
#define REGSTR_PATH_JOYOEM           REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\Joystick\\OEM")
#define REGSTR_PATH_JOYCONFIG        REGSTR_PATH_MEDIARESOURCES TEXT("\\Joystick")
#define REGSTR_KEY_JOYCURR           TEXT("CurrentJoystickSettings")
#define REGSTR_KEY_JOYSETTINGS       TEXT("JoystickSettings")

// joystick values found under REGSTR_PATH_JOYCONFIG
#define REGSTR_VAL_JOYUSERVALUES     TEXT("JoystickUserValues")
#define REGSTR_VAL_JOYCALLOUT        TEXT("JoystickCallout")

// joystick values found under REGSTR_KEY_JOYCURR and REGSTR_KEY_JOYSETTINGS
#define REGSTR_VAL_JOYNCONFIG        TEXT("Joystick%dConfiguration")
#define REGSTR_VAL_JOYNOEMNAME       TEXT("Joystick%dOEMName")
#define REGSTR_VAL_JOYNOEMCALLOUT    TEXT("Joystick%dOEMCallout")

// joystick values found under keys under REGSTR_PATH_JOYOEM
#define REGSTR_VAL_JOYOEMCALLOUT        TEXT("OEMCallout")
#define REGSTR_VAL_JOYOEMNAME           TEXT("OEMName")
#define REGSTR_VAL_JOYOEMDATA           TEXT("OEMData")
#define REGSTR_VAL_JOYOEMXYLABEL        TEXT("OEMXYLabel")
#define REGSTR_VAL_JOYOEMZLABEL         TEXT("OEMZLabel")
#define REGSTR_VAL_JOYOEMRLABEL         TEXT("OEMRLabel")
#define REGSTR_VAL_JOYOEMPOVLABEL       TEXT("OEMPOVLabel")
#define REGSTR_VAL_JOYOEMULABEL         TEXT("OEMULabel")
#define REGSTR_VAL_JOYOEMVLABEL         TEXT("OEMVLabel")
#define REGSTR_VAL_JOYOEMTESTMOVEDESC   TEXT("OEMTestMoveDesc")
#define REGSTR_VAL_JOYOEMTESTBUTTONDESC TEXT("OEMTestButtonDesc")
#define REGSTR_VAL_JOYOEMTESTMOVECAP    TEXT("OEMTestMoveCap")
#define REGSTR_VAL_JOYOEMTESTBUTTONCAP  TEXT("OEMTestButtonCap")
#define REGSTR_VAL_JOYOEMTESTWINCAP     TEXT("OEMTestWinCap")
#define REGSTR_VAL_JOYOEMCALCAP         TEXT("OEMCalCap")
#define REGSTR_VAL_JOYOEMCALWINCAP      TEXT("OEMCalWinCap")
#define REGSTR_VAL_JOYOEMCAL1           TEXT("OEMCal1")
#define REGSTR_VAL_JOYOEMCAL2           TEXT("OEMCal2")
#define REGSTR_VAL_JOYOEMCAL3           TEXT("OEMCal3")
#define REGSTR_VAL_JOYOEMCAL4           TEXT("OEMCal4")
#define REGSTR_VAL_JOYOEMCAL5           TEXT("OEMCal5")
#define REGSTR_VAL_JOYOEMCAL6           TEXT("OEMCal6")
#define REGSTR_VAL_JOYOEMCAL7           TEXT("OEMCal7")
#define REGSTR_VAL_JOYOEMCAL8           TEXT("OEMCal8")
#define REGSTR_VAL_JOYOEMCAL9           TEXT("OEMCal9")
#define REGSTR_VAL_JOYOEMCAL10          TEXT("OEMCal10")
#define REGSTR_VAL_JOYOEMCAL11          TEXT("OEMCal11")
#define REGSTR_VAL_JOYOEMCAL12          TEXT("OEMCal12")

// Image values under REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES
#define REGSTR_VAL_AUDIO_BITMAP TEXT("bitmap")
#define REGSTR_VAL_AUDIO_ICON TEXT("icon")

//
// Entries for Device Installer under HKEY_LOCAL_MACHINE and HKEY_CURRENT_USER
//
#define REGSTR_PATH_DEVICEINSTALLER     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Device Installer")

//
// Entries for DIFX (Device Install Frameworks) under HKEY_LOCAL_MACHINE
//
#define REGSTR_PATH_DIFX     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\DIFX")


// Device Installer values found under REGSTR_PATH_DEVICEINSTALLER
#define REGSTR_VAL_SEARCHOPTIONS        TEXT("SearchOptions")

// BiosInfo defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_BIOSINFO            TEXT("System\\CurrentControlSet\\Control\\BiosInfo")

#else

#define REGSTR_PATH_BIOSINFO            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\BiosInfo"

#endif

// Pci Irq Routing registry defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_PCIIR               TEXT("System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting")
#define REGSTR_VAL_OPTIONS              TEXT("Options")
#define REGSTR_VAL_STAT                 TEXT("Status")
#define REGSTR_VAL_TABLE_STAT           TEXT("TableStatus")
#define REGSTR_VAL_MINIPORT_STAT        TEXT("MiniportStatus")

#else

#define REGSTR_PATH_PCIIR               L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting"
#define REGSTR_VAL_OPTIONS              L"Options"
#define REGSTR_VAL_STAT                 L"Status"
#define REGSTR_VAL_TABLE_STAT           L"TableStatus"
#define REGSTR_VAL_MINIPORT_STAT        L"MiniportStatus"

#endif

// Pci Irq Routing Option values.
#define PIR_OPTION_ENABLED                  0x00000001
#define PIR_OPTION_REGISTRY                 0x00000002
#define PIR_OPTION_MSSPEC                   0x00000004
#define PIR_OPTION_REALMODE                 0x00000008
#define PIR_OPTION_DEFAULT                  0x0000000f

// Pci Irq Routing Status values.
#define PIR_STATUS_ERROR                    0x00000000
#define PIR_STATUS_ENABLED                  0x00000001
#define PIR_STATUS_DISABLED                 0x00000002
#define PIR_STATUS_MAX                      0x00000003

#define PIR_STATUS_TABLE_REGISTRY           0x00000000
#define PIR_STATUS_TABLE_MSSPEC                     0x00000001
#define PIR_STATUS_TABLE_REALMODE                   0x00000002
#define PIR_STATUS_TABLE_NONE                   0x00000003
#define PIR_STATUS_TABLE_ERROR                      0x00000004
#define PIR_STATUS_TABLE_BAD                        0x00000005
#define PIR_STATUS_TABLE_SUCCESS            0x00000006
#define PIR_STATUS_TABLE_MAX                0x00000007

#define PIR_STATUS_MINIPORT_NORMAL                  0x00000000
#define PIR_STATUS_MINIPORT_COMPATIBLE      0x00000001
#define PIR_STATUS_MINIPORT_OVERRIDE        0x00000002
#define PIR_STATUS_MINIPORT_NONE                    0x00000003
#define PIR_STATUS_MINIPORT_ERROR                   0x00000004
#define PIR_STATUS_MINIPORT_NOKEY                   0x00000005
#define PIR_STATUS_MINIPORT_SUCCESS                 0x00000006
#define PIR_STATUS_MINIPORT_INVALID                 0x00000007
#define PIR_STATUS_MINIPORT_MAX             0x00000008

//
// entries for LastKnownGood
// each value name under this key is SubPath/File (note reversal of '\\' to '/')
// each value is an indication of post-processing to be done after files have been recovered
// LASTGOOD_OPERATION bits indicate the primary post-processing operation
// remaining bits may be used as flags (allocate flags from highest bits first)
// a value of 0 is the same as the value being omitted, ie, no post processing.
//

#define REGSTR_PATH_LASTGOOD            TEXT("System\\LastKnownGoodRecovery\\LastGood")
#define REGSTR_PATH_LASTGOODTMP         TEXT("System\\LastKnownGoodRecovery\\LastGood.Tmp")

#define LASTGOOD_OPERATION              0x000000FF // operation to perform
#define LASTGOOD_OPERATION_NOPOSTPROC   0x00000000 // no post-processing
#define LASTGOOD_OPERATION_DELETE       0x00000001 // Delete file during recovery

#endif  //_INC_REGSTR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\replerr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/****************************************************************************
*                                                                           *
* replerr.h -- Pegasus filter error codes                                   *
*                                                                           *
* Copyright (c) Microsoft Corporation. All rights reserved.		            *
*                                                                           *
****************************************************************************/

#ifndef _REPLERR_
#define _REPLERR_

/*
 * Define how errors are declared
 */
#define CF_DECLARE_ERROR(e)  (0x80040000 | e)
#define PF_DECLARE_ERROR(e)  CF_DECLARE_ERROR(e)

/*
 * Predefined error messages
 */
#define ERROR_ALREADYCONVERTING  CF_DECLARE_ERROR(0x5000)  // conversion is not reentrant
#define ERROR_UNKNOWNCONVERSION  CF_DECLARE_ERROR(0x5001)  // conversion is not recognized by converter dll
#define ERROR_BADFILE            CF_DECLARE_ERROR(0x5002)  // generic error that indicates that the format of a file was not understood

#endif /* !_REPLERR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\renbaseasync.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Generic ActiveX base renderer class, December 1995

#ifndef __RENBASEASYNC__
#define __RENBASEASYNC__

#include <renbase.h>

// Forward class declarations

class CBaseRendererAsync;
class CBaseVideoRendererAsync;

//
// A sample that is queued in the RendererQueue, holding all samples that need to be processed.
// Just a single sample is scheduled at a time (the head of the queue).
//
class CRendererSample
{
    friend class CRendererSampleQueue;

public:
    CRendererSample (IMediaSample *pSample)
    {
        m_pMediaSample = pSample;
        m_pMediaSample->AddRef();
        m_bIsScheduled = FALSE;
        m_bForceRendering = FALSE;
        m_pNext = NULL;
    }

    ~CRendererSample()
    {
        ASSERT (m_pMediaSample  &&  m_pNext == NULL);
        m_pMediaSample->Release();
    }

    BOOL IsScheduled () { return m_bIsScheduled; }

    void SetScheduled (BOOL bIsScheduled) { m_bIsScheduled = bIsScheduled; }

    BOOL IsForceRendering() { return m_bForceRendering; }

    void SetForceRendering (BOOL bForce) { m_bForceRendering = bForce; }

    IMediaSample *MediaSample () { return m_pMediaSample; }

protected:
    BOOL             m_bIsScheduled;
    BOOL             m_bForceRendering;
    CRendererSample *m_pNext;
    IMediaSample    *m_pMediaSample;
};


//
// A queue of renderer sample objects
//
class CRendererSampleQueue
{
public:
    CRendererSampleQueue()
    {
        m_NEntries = 0;
        m_pHead = m_pTail = NULL;
    }

    virtual ~CRendererSampleQueue()
    {
        Flush();
    }

    void Flush (void)
    {
        CAutoLock lock(&m_Lock);

        CRendererSample *pRendererSample;
        while (Remove (&pRendererSample) == S_OK)
        {
            delete pRendererSample;
        }
    }

    HRESULT Insert(CRendererSample *pRendererSample)
    {
        CAutoLock lock(&m_Lock);

        ASSERT (pRendererSample);
        if (!pRendererSample)
        {
            return E_INVALIDARG;
        }

        if (m_pTail)
        {
            m_pTail->m_pNext = pRendererSample;
        }
        m_pTail = pRendererSample;
        m_pTail->m_pNext = NULL;
        if (!m_pHead)
        {
            m_pHead = m_pTail;
        }
        ++m_NEntries;

        return S_OK;
    }

    HRESULT Remove(CRendererSample **pRendererSample)
    {
        CAutoLock lock(&m_Lock);

        if (!pRendererSample)
            return E_INVALIDARG;

        *pRendererSample = m_pHead;
        if (m_pHead)
        {
            m_pHead = m_pHead->m_pNext;
            if (!m_pHead)
            {
                m_pTail = NULL;
            }
            (*pRendererSample)->m_pNext = NULL;
            --m_NEntries;
            ASSERT (m_NEntries >= 0);
        }
        return (*pRendererSample) ? S_OK : S_FALSE;
    }

    LONG Count() { return m_NEntries; }

    HRESULT PeekStart(CRendererSample **pRendererSample)
    {
        if (!pRendererSample)
        {
            return E_INVALIDARG;
        }

        m_Lock.Lock();
        *pRendererSample = m_pHead;        
        if (*pRendererSample)
        {
            return S_OK;
        }
        else
        {
            m_Lock.Unlock();
            return S_FALSE;
        }
    }

    void PeekEnd (CRendererSample *pRendererSample)
    {
        m_Lock.Unlock();
    }

protected:
    CCritSec         m_Lock;
    CRendererSample *m_pHead, *m_pTail;
    LONG             m_NEntries;
};


//
// Main renderer class that handles synchronisation and state changes
// Spawns a thread that takes care of scheduling/processing samples. The
// Receive method just queues samples for later processing
//
class CBaseRendererAsync : public CBaseRenderer, protected CAMThread
{
    friend class CRendererInputPin;
public:
    CBaseRendererAsync(REFCLSID RenderClass, // CLSID for this renderer
                       TCHAR *pName,         // Debug ONLY description
                       LPUNKNOWN pUnk,       // Aggregated owner object
                       HRESULT *phr);        // General OLE return code

    CBaseRendererAsync(REFCLSID RenderClass, // CLSID for this renderer
                       TCHAR *pName,         // Debug ONLY description
                       LPUNKNOWN pUnk,       // Aggregated owner object
                       HRESULT *phr,         // General OLE return code
                       DWORD dwReporterTag); // Reporter tag for WMILOG

    ~CBaseRendererAsync();
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    virtual HRESULT SourceThreadCanWait(BOOL bCanWait);

#ifdef DEBUG
    // Debug only dump of the renderer state
    void DisplayRendererState();
#endif
    virtual HRESULT WaitForRenderTime();

    virtual BOOL OnDisplayChange();

    // Override the filter and pin interface functions
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME StartTime);

    virtual void SignalTimerFired();

    // Called when the filter changes state

    virtual HRESULT Inactive();
    virtual HRESULT StartStreaming();
    virtual HRESULT StopStreaming();
    virtual HRESULT BeginFlush();
    virtual HRESULT EndFlush();

    // Deal with connections and type changes

    virtual HRESULT BreakConnect();

    // These look after the handling of data samples

    virtual HRESULT PrepareReceive(IMediaSample *pMediaSample);
    virtual HRESULT Receive(IMediaSample *pMediaSample);
    virtual BOOL HaveCurrentSample();
    virtual BOOL ScheduleSample(IMediaSample *pMediaSample);

    // Derived classes MUST override these
    virtual HRESULT DoRenderSample(IMediaSample *pMediaSample) PURE;
    virtual HRESULT CheckMediaType(const CMediaType *) PURE;

    virtual void WaitForReceiveToComplete();

protected:
    CAMEvent m_ScheduleEvent;             // Used to signal that an object needs to be scheduled
    CRendererSample *m_pScheduledSample;  // Sample that is currently scheduled with the m_dwAdvise cookie
    CRendererSampleQueue m_RendererQueue; // Contains the samples that need to be rendered
    BOOL m_bFirstSample;                  // set if this is the first sample after a pause
    BOOL m_bDisplayWhenPaused;            // set to display the first frame even when paused

    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

    // type-corrected overrides of communication funcs
    Command GetRequest() {
        return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
        return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    // commands we can give the thread
    HRESULT RunThread();
    HRESULT StopThread();
    HRESULT KillThread();   
    DWORD   ThreadProc();

    // schedule & render samples available in m_RendererQueue
    HRESULT ScheduleQueuedSample (void);
    HRESULT ProcessQueuedSample (void);

    HRESULT Init(void);
};


// CBaseVideoRendererAsync is a renderer class (see its async ancestor class) and 
// CVideoRendererQuality class for quality management
class CBaseVideoRendererAsync : public CBaseRendererAsync,   // Base renderer class
                                public CVideoRendererQuality // Quality management
{
public:
    CBaseVideoRendererAsync(REFCLSID RenderClass, // CLSID for this renderer
                       TCHAR *pName,         // Debug ONLY description
                       LPUNKNOWN pUnk,       // Aggregated owner object
                       HRESULT *phr);        // General OLE return code

    ~CBaseVideoRendererAsync();

    BOOL ScheduleSample(IMediaSample *pMediaSample);
    virtual HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample, REFERENCE_TIME *ptrStart, REFERENCE_TIME *ptrEnd);

    virtual HRESULT SendQuality(REFERENCE_TIME trLate, REFERENCE_TIME trRealStream);
    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    // IQualityControl methods - Notify allows audio-video throttling
    STDMETHODIMP SetSink( IQualityControl * piqc);
    STDMETHODIMP Notify( IBaseFilter * pSelf, Quality q);

    // These provide a full video quality management implementation

    virtual void OnRenderStart(IMediaSample *pMediaSample) { CVideoRendererQuality::OnRenderStartQual (pMediaSample); }
    virtual void OnRenderEnd(IMediaSample *pMediaSample, bool bRenderedOk) { CVideoRendererQuality::OnRenderEndQual (pMediaSample); }
    virtual HRESULT OnStartStreaming() { return CVideoRendererQuality::OnStartStreamingQual (m_State); }
    virtual HRESULT OnStopStreaming(){ return CVideoRendererQuality::OnStopStreamingQual (m_State); }
    virtual void OnWaitStart() { CVideoRendererQuality::OnWaitStartQual (); }
    virtual void OnWaitEnd() { CVideoRendererQuality::OnWaitEndQual (); }

    virtual void PrepareRender();

    // IQualProp property page support
    STDMETHODIMP get_FramesDroppedInRenderer(int *cFramesDropped);
    STDMETHODIMP get_FramesDrawn(int *pcFramesDrawn);
    STDMETHODIMP get_AvgFrameRate(int *piAvgFrameRate);
    STDMETHODIMP get_Jitter(int *piJitter);
    STDMETHODIMP get_AvgSyncOffset(int *piAvg);
    STDMETHODIMP get_DevSyncOffset(int *piDev);
    HRESULT GetStdDev(int nSamples, int *piResult, LONGLONG llSumSq, LONGLONG iTot);

    // Implement an IUnknown interface and expose IQualProp
    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,VOID **ppv);
};

#endif // __RENBASEASYNC__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\resmgr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/* File:    ResMgr.h
 *
 * Purpose: Resource manager definitions
 * The resource manager itself is part of the device manager (device.exe)
 * and its affliated entry points are declared in winbase.h.
 *
 */

#ifndef _RESMGR_H
#define _RESMGR_H

// Resource ids less than BASE_OEM are reserved by Microsoft;
// Resource ids between these limits are for OEM use.
#define RESMGR_BASE_OEM     0x00080000
#define RESMGR_MAX_OEM      0x000FFFFF
// Resource ids greater than MAX_OEM are reserved for future use by Microsoft.

// --- FIVE hex digits (not four) in these constants!
#define RESMGR_IRQ          0x00001
#define RESMGR_IOSPACE      0x00002

#endif // _RESMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rmnet.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//
// Contains the definitions of the Resource Manager (RM) interface used to
// coordinate access to establishing data connections through Connection Manager
//

#ifndef _RmNet_h_
#define _RmNet_h_

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

#define RM_CURRENT_VERSION (1)

typedef DWORD RM_RESOURCE_HANDLE;

typedef GUID RM_RESOURCE_ID;



/// <summary>
///     Results returned from calls to Resource Manager
/// </summary>
typedef enum RM_RESULT
{
    RMRE_SUCCESS = 0,

    RMRE_CONFLICT,
    RMRE_EXTERNAL_CONFLICT,
    RMRE_NOT_INITIALIZED,
    RMRE_INVALID_PARAMETER,
    RMRE_UNEXPECTED,
    RMRE_INVALID_VERSION,
    RMRE_INSUFFICIENT_BUFFER,
    RMRE_RESOURCE_DOES_NOT_EXIST,

    RMRE_LAST
} RM_RESULT;


/// <summary>
///     Notification types that can be sent by RM to a client through the
///     RM_CALLBACK function passed in to RmInitialize.
/// </summary>
typedef enum RM_NOTIFICATION_TYPE
{
    /// <summary>
    ///     RMNT_REVOKE
    ///     (RM_REVOKE_INFO*) pData
    ///     The revoke notification is sent when an acquired resource is lost.
    ///     This occurs when a resource has been taken and given to another
    ///     application or if a resource is lost due to some change in the state
    ///     of the device.
    ///
    ///     The pData parameter of the callback points to a RM_REVOKE_INFO
    ///     structure containing the resource handle of the acquired resource
    ///     that was revoked plus additional information about the reason of
    ///     the revoke.
    /// </summary>
    RMNT_REVOKE,

    /// <summary>
    ///     RMNT_SUSPEND_RESUME
    ///     (RM_SUSPEND_RESUME_INFO*) pData
    ///     The resource has been suspended or resumed due to external causes.
    ///     In the suspended case, the resource is still allocated exclusively
    ///     for the client that originally acquired it, but it cannot be used
    ///     until a resume notification is received.
    ///
    ///     The resume notification is sent when a previously suspended resource
    ///     is available for use again.
    ///
    ///     For example, a resource for a cellular data connection may receive a
    ///     suspended notification when a voice call is active. Once the voice
    ///     call is disconnected, a resume notification will be sent.
    ///
    ///     The pData parameter of the callback points to a
    ///     RM_SUSPEND_RESUME_INFO structure that contains a resource handle
    ///     returned from a RmAcquire call and a boolean value representing
    ///     if the resource is suspended or not.
    /// </summary>
    RMNT_SUSPEND_RESUME,


    /// <summary>
    ///     RMNT_RESOURCE_AVAILABILITY
    ///     (RM_AVAILABILITY_INFO*) pData
    ///     The resource availability notification is sent when an opened
    ///     resource's status changes due to external conditions that
    ///     causes the resource to be blocked during and acquire and vice versa.
    ///     For example, a resource for a cellular data connection may become
    ///     unavailable when a voice call is active on a non-simultaneous voice
    ///     and data device. Once the voice call was ended, the resource would
    ///     become available again.
    ///
    ///     The pData parameter of the callback points to a RM_AVAILABILITY_INFO
    ///     structure. This structure contains the resource ID,
    ///     a boolean flag marking the resource available or not
    ///     and a reason code containing the primary cause if unavailable.
    ///     The reason code is not valid for resource available notifications.
    /// </summary>
    RMNT_RESOURCE_AVAILABILITY,

    /// <summary>
    ///     RM_NOTIFY_RESOURCE_ROAMING
    ///     (RM_ROAMING_INFO*) pData
    ///     The resource roaming notification is sent when an opened resource
    ///     has went from what is considered a home network area to an outside
    ///     network and vice versa. This generally is a cellular specific
    ///     concept where a cellular device can operate on other networks
    ///     outside of the device's local or issuing network. When operating on
    ///     an outside network (roaming) the cost of using the network may be
    ///     different or have different characteristics.
    ///
    ///     The pData parameter of the callback points to a RM_ROAMING_INFO
    ///     structure. This contains the resource ID of the resource whose
    ///     roaming status has changed, and a boolean flag marking whether the
    ///     resource is roaming or not.
    /// </summary>
    RMNT_RESOURCE_ROAMING,

    /// <summary>
    ///     RM_NOTIFY_NETWORK_TYPE
    ///     (RM_NETWORK_TYPE_INFO*) pData
    ///
    ///     The Network Type notification is sent when an opened resource
    ///     changes the underlying network technology used by the
    ///     resource is changed. Examples of network type are GPRS, EDGE,
    ///     UMTS, HSDPA for cellular GPRS connections, 802.11a/b/g for WiFi,
    ///     or 1xRTT, EVDO, EVDV for CDMA cellular connections.
    ///
    ///     The pData parameter of the callback points to a RM_NETWORK_TYPE_INFO
    ///     structyre representing. This contains the corresponding resource ID
    ///      and the network type. The GUID value is defined by the underlying
    ///     RSP (and usually the corresponding Connection Manager CSP). It is
    ///     common to reuse the Connection Manager CM_CONNECTION_NETWORK_TYPE
    ///     value.
    /// </summary>
    RMNT_RESOURCE_NETWORK_TYPE,

    RMNT_LAST
} RM_NOTIFICATION_TYPE;



/// <summary>
///     Callback function definition for RM notifications. Used in RmInitialize.
/// </summary>
typedef void (*RM_CALLBACK) (
    DWORD dwNotificationParam,
    RM_NOTIFICATION_TYPE notificationCode,
    __in_bcount_opt(cbDataSize) const void* pData,
    DWORD cbDataSize);


/// <summary>
///     Detailed codes explaining the primary reason a resource is unavailable
///     or revoked.
/// </summary>
typedef enum RM_UNAVAILABLE_REASON
{
    RMUR_NO_SPECIFIC_REASON = 0,

    /// <summary>
    ///     The resource is not ready due to problems in the underlying
    ///     hardware. For example, the hardware is powered off or not attached
    ///     to a network.
    /// </summary>
    RMUR_RESOURCE_NOT_READY,

    /// <summary>
    ///     The resource cannot be used because of another activity occurring
    ///     on the device. For example a voice call or CSD connection is
    ///     active.
    /// </summary>
    RMUR_EXTERNAL_IN_USE,

    /// <summary>
    ///     The resource cannot be used because all instances of the resource
    ///     have already been acquired.
    /// </summary>
    RMUR_ALL_RESOURCES_IN_USE,

    /// <summary>
    ///     The resource is being revoked so that it can be acquired by
    ///     another request.
    ///
    ///     Note: The client is expected to have disconnect and clean up all
    ///     associated details of the resource before returning from the
    ///     callback function.
    /// </summary>
    RMUR_RESOURCE_REVOKE,

    /// <summary>
    ///     The resource cannot because of an event specific to the RSP.
    ///     This reason allows for RSP specific causes to be added in the
    ///     future.
    /// </summary>
    RMUR_RSP_SPECIFIC
} RM_UNAVAILABLE_REASON;


/// <summary>
///     Detailed codes explaining the primary reason a resource is unavailable
///     or revoked.
/// </summary>
typedef enum RM_UNAVAILABLE_SPECIFIC_CAUSE
{
        RMUSC_NO_SPECIFIC_CAUSE = 0,

        /// <summary>
        ///     The power to the resource's hardware is off.
        /// </summary>
        RMUSC_POWER_OFF,

        /// <summary>
        ///     The resource's hardware is not registered on a network.
        /// </summary>
        RMUSC_NOT_REGISTERED,

        /// <summary>
        ///     The resource cannot be used because a voice call is in progress.
        /// </summary>
        RMUSC_PHONE_IN_USE,

        /// <summary>
        ///     The resource cannot be used because a CSD connection is in
        ///     progress.
        /// </summary>
        RMUSC_CSD_IN_USE,

        /// <summary>
        ///     Start of the reserved section for RSP specific causes.
        /// </summary>
        RMUSC_RSP_SPECIFIC_START = 0x80000000
} RM_UNAVAILABLE_SPECIFIC_CAUSE;


typedef struct RM_CLIENT_INFO
{
    DWORD dwVersion;
    RM_CALLBACK pfnNotification;
    DWORD dwNotificationParam;

} RM_CLIENT_INFO;

typedef struct RM_AVAILABILITY_INFO
{
    DWORD dwVersion;
    RM_RESOURCE_ID resourceId;
    BOOL fAvailable;
    RM_UNAVAILABLE_REASON reason;
    RM_UNAVAILABLE_SPECIFIC_CAUSE specificCause;
} RM_AVAILABILITY_INFO;

typedef struct RM_ROAMING_INFO
{
    DWORD dwVersion;
    RM_RESOURCE_ID resourceId;
    BOOL fRoaming;
} RM_ROAMING_INFO;

typedef struct RM_NETWORK_TYPE_INFO
{
    DWORD dwVersion;
    RM_RESOURCE_ID resourceId;
    GUID networkType;
} RM_NETWORK_TYPE_INFO;

typedef struct RM_RESOURCE_INFO
{
    DWORD dwVersion;
    RM_AVAILABILITY_INFO availability;
    BOOL fRoaming;
    GUID networkType;
    GUID deviceType;
} RM_RESOURCE_INFO;

typedef struct RM_REVOKE_INFO
{
    DWORD dwVersion;
    RM_RESOURCE_HANDLE hResource;
    RM_UNAVAILABLE_REASON reason;
    RM_UNAVAILABLE_SPECIFIC_CAUSE specificCause;
} RM_REVOKE_INFO;

typedef struct RM_SUSPEND_RESUME_INFO
{
    DWORD dwVersion;
    RM_RESOURCE_HANDLE hResource;
    BOOL fSuspended;
} RM_SUSPEND_RESUME_INFO;


/// <summary>
///     RmInitialize must be called by client applications to provider RM time
///     to start internal processes necessary for RM to function. A client
///     must call RmInitialize before any other RM API will succeed.
/// </summary>
/// <param name="pClientInfo">
///     Contains necessary RM client information such as a callback function
///     for RM to send notifications of changes to resources and a client
///     defined value that will be sent with each notification.
///     A notification callback is necessary and
///     RMRE_INVALID_PARAMETER will be returned if this parameter is NULL.
/// </param>
/// <param name="cbClientInfo">
///     Size in bytes of the pClientInfo buffer.
/// </param>
/// <param name="phId">
///     Upon a successful result, a handle is returned to be used in
///     subsequent calls to the RM API.
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_INVALID_PARAMETER
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RmInitialize(
    __in_bcount(cbClientInfo) const RM_CLIENT_INFO* pClientInfo,
    __in const DWORD cbClientInfo,
    __out HANDLE* phId);



/// <summary>
///     RmDeinitialize allows for a client to inform RM that it no longer is
///     using RM.
/// </summary>
/// <param name="hId">
///     A valid handle returned as a part of a successful call to
///     RmInitialize.
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_INVALID_PARAMETER
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RmDeinitialize(
    __in HANDLE hId);


/// <summary>
///     RmOpenResource is used by a client to open the resource of the
///     type specified by pResId. Once opened, the application will
///     receive asynchronous notifications about the state of the resource.
/// </summary>
/// <param name="hId">
///     A valid handle returned as a part of a successful call to
///     RmInitialize.
/// </param>
/// <param name="pResId">
///     Pointer to a resource identifier of the type of resource to open.
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_INVALID_PARAMETER
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RmOpenResource(
    __in HANDLE hId,
    __in const RM_RESOURCE_ID* pResId);


/// <summary>
///     RmCloseResource is called by a client when it no longer needs to
///     receive notifications about the resource.
/// </summary>
/// <param name="hId">
///     A valid handle returned as a part of a successful call to
///     RmInitialize.
/// </param>
/// <param name="pResId">
///     Pointer to a resource identifier of the type of resource to close.
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_INVALID_PARAMETER
///     RMRE_UNEXPECTED
/// </returns>
/// <remarks>
///     RmCloseResource does not affect acquired resource handles returned
///     from calls to RmAcquire.
/// </remarks>
RM_RESULT RmCloseResource(
    __in HANDLE hId,
    __in const RM_RESOURCE_ID* pResId);

/// <summary>
///     RmGetResourceInfo allows for a client to retrieve the current state
///     information about a resource.
/// </summary>
/// <param name="hId">
///     A valid handle returned as a part of a successful call to
///     RmInitialize.
/// </param>
/// <param name="pResId">
///     Pointer to the resource identifier for the resource to return current
///     state information about.
/// </param>
/// <param name="pResourceInfo">
///     Buffer to return the resource information in.
/// </param>
/// <param name="cbResourceInfo">
///     Size of buffer passed in pResourceInfo
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_UNEXPECTED
///     RMRE_NOT_INITIALIZED
///     RMRE_INVALID_PARAMETER
///     RMRE_INSUFFICIENT_BUFFER
///     RMRE_RESOURCE_DOES_NOT_EXIST
/// </returns>
RM_RESULT RmGetResourceInfo(
    __in HANDLE hId,
    __in const RM_RESOURCE_ID* pResId,
    __out_bcount(cbResourceInfo) RM_RESOURCE_INFO* pResourceInfo,
    DWORD cbResourceInfo);


/// <summary>
///     RmAcquire allows an application to request a resource of the type
///     associated with pResId to be reserved for use and associated with an
///     application name.  A session identifier can also be included to help
///     resolve conflicts between multiple sessions coming from an application.
/// </summary>
/// <param name="hId">
///     A valid handle returned as a part of a successful call to
///     RmInitialize.
/// </param>
/// <param name="pResId">
///     Pointer to the resource identifier of the type of resource to acquire.
/// </param>
/// <param name="dwPriority">
///     An priority value associated with the acquire request for assigning
///     priorities to separate tasks within an application as well as
///     determining whether the resource will be used for user interactive
///     or background activity.
///
///     Values with their corresponding usage:
///     0 - 2^16-1: Background sessions
///     2^16 - 2^32-1: User Interactive sessions
/// </param>
/// <param name="phAcquired">
///     When success is returned, this will contain an handle associated with
///     the acquired resource. This is used when
///     calling RmRelease to release the acquired resource or in
///     calls to RmAddToResource and RmRemoveFromResource.
/// </param>
/// <returns>
///     RMRE_SUCCESS: Returned if the resource was available for the
///     application and was successfully acquired.
///
///     RMRE_CONFLICT: Returned if the resource is in use by a higher
///     priority application.
///
///     RMRE_EXTERNAL_CONFLICT: Returned if the resource is not available due
///     to conflicts caused by external conditions. For example a Cellular Data
///     resource could not be acquired because a voice call was active and
///     simultaneous voice and data is not supported.
///
///     RMRE_INVALID_PARAMETER
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RmAcquire(
    __in HANDLE hId,
    __in const RM_RESOURCE_ID* pResId,
    DWORD dwPriority,
    __out RM_RESOURCE_HANDLE* phAcquired);



/// <summary>
///     RmRelease allows for a client to release a resource so that it is free
///     for use by subsequent calls to RmAcquire.
/// </summary>
/// <param name="hId">
///     A valid handle returned as a part of a successful call to
///     RmInitialize.
/// </param>
/// <param name="hAcquired">
///     Resource handle returned from RmAcquire to release.
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_INVALID_PARAMETER
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RmRelease(
    __in HANDLE hId,
    __in RM_RESOURCE_HANDLE hAcquired);



/// <summary>
///     RmAddToResource allows attaching additional applications to an already
///     acquired resource. This allows for clients to inform RM about multiple
///     applications using a resource so that application resource conflict
///     decisions can be made.
/// </summary>
/// <param name="hId">
///     A valid handle returned as a part of a successful call to
///     RmInitialize.
/// </param>
/// <param name="hAcquired">
///     Resource handle returned from RmAcquire to add the specified
///     application to.
/// </param>
/// <param name="dwPriority">
///     A priority value associated with the acquire request for assigning
///     priorities to separate tasks within an application as well as
///     determining whether the resource will be used for user interactive
///     or background activity.
///
///     See RmAcquire for details.
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_INVALID_PARAMETER
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RmAddToResource(
    __in HANDLE hId,
    __in RM_RESOURCE_HANDLE hAcquired,
    DWORD dwPriority);



/// <summary>
///     RmRemoveFromResource allows a way to remove applications from an
///     acquired resource. This allows for clients to inform RM when an
///     applications is no longer using a resource so that application resource
///     conflict decisions can be made.
/// </summary>
/// <param name="hId">
///     A valid handle returned as a part of a successful call to
///     RmInitialize.
/// </param>
/// <param name="hAcquired">
///     Resource handle returned from RmAcquire to remove the specified
///     application from.
/// </param>
/// <param name="dwPriority">
///     The priority value associated with the account to be removed.
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_INVALID_PARAMETER
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RmRemoveFromResource(
    __in HANDLE hId,
    __in RM_RESOURCE_HANDLE hAcquired,
    DWORD dwPriority);


#ifdef __cplusplus
}
#endif

#endif // _RmNet_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rmrsp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//
// Resource service provider interface for Resource Manager.
//

#ifndef _Rsp_h_
#define _Rsp_h_

#include <windows.h>
#include <RmNet.h>

#ifdef __cplusplus
extern "C" {
#endif

/// <summary>
///     Callback function definition for RSP notifications.
/// </summary>
typedef void (*RSP_CALLBACK) (
    RM_NOTIFICATION_TYPE notificationCode,
    __in DWORD dwNotificationParam,
    __in_bcount_opt(cbDataSize) const void* pData,
    DWORD cbDataSize);

typedef struct RSP_HOST_INFO
{
    DWORD dwVersion;
    RSP_CALLBACK pfnNotification;
    DWORD dwNotificationParam;
} RSP_HOST_INFO;

typedef struct RSP_PROVIDER_INFO
{
    DWORD dwVersion;
    WCHAR wszName[MAX_PATH];
    DWORD cResourceId;
    RM_RESOURCE_ID resourceId[1];
} RSP_PROVIDER_INFO;

/*
    RSP Notifications re-use the RM notification enumerations and data
    structures. Please see Rm.h for the details.

    Specifically the following structures and enums apply:

    RM_NOTIFICATION_TYPE enum
    RM_UNAVAILABLE_REASON enum
    RM_AVAILABILITY_INFO structure
    RM_ROAMING_INFO structure
    RM_RESOURCE_INFO structure
    RM_REVOKE_INFO structure

*/



/// <summary>
///     Called by RM to initialize a RSP. Upon a successful result, an RSP
///     should be capable or responding to all other RSP API's, provide
///     notifications for the supported resource types, and return a list of
///     resource types supported by the RSP.
/// </summary>
/// <param name="pHostInfo">
///     Contains the RM information needed by the RSP to send notifications.
/// </param>
/// <param name="cbHostInfo">
///     Size in bytes of the buffer passed in to pHostInfo.
/// </param>
/// <param name="pProviderInfo">
///     Buffer containing the provider information upon a successful return.
/// </param>
/// <param name="pcbProviderInfo">
///     Pointer to a buffer containing the size of the pProviderInfo buffer in
///     bytes.
///     Upon a RMRE_INSUFFICIENT_BUFFER result, this will containg the needed
///     size in bytes to properly fill out pProviderInfo.
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_INVALID_PARAMETER
///     Returned if pHostInfo is invalid or cbHostInfo is incorrect size.
///     RMRE_INVALID_VERSION
///     Returned when pHostInfo version is incorrect.
///     RMRE_INSUFFICIENT_BUFFER
///     Returned when pProviderInfo buffer is not sufficient size to contain
///     the provider structure and list of resource ID's.
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RspInitialize(
    __in_bcount(cbHostInfo) const RSP_HOST_INFO* pHostInfo,
    __in DWORD const cbHostInfo,
    __out_bcount(*pcbProviderInfo) RSP_PROVIDER_INFO* pProviderInfo,
    __inout DWORD* pcbProviderInfo);

typedef RM_RESULT (*RSP_INITIALIZE)(
    __in_bcount(cbHostInfo) const RSP_HOST_INFO* pHostInfo,
    __in DWORD const cbHostInfo,
    __out_bcount(*pcbProviderInfo) RSP_PROVIDER_INFO* pProviderInfo,
    __inout DWORD* pcbProviderInfo);


/// <summary>
///     Called by RM to deinitialize an RSP before exiting.
/// </summary>
/// <returns>
///     void
/// </returns>
void RspDeinitialize();

typedef RM_RESULT (*RSP_DEINITIALIZE)();


/// <summary>
///     RM calls RspAcquire to lock an instance of a resource. The RSP is
///     responsible for checking if there is an available resource
///     and that access to a resource is not blocked by some state of the
///     device. For example, an active voice call that would block establishing
///     a cellular data connection.
/// </summary>
/// <param name="resourceId">
///     ID for the resource to acquire.
/// </param>
/// <param name="phResource">
///     When success is returned, this will contain an handle associated with
///     the acquired resource. This is used when
///     calling RspRelease and in notifications from the RSP.
/// </param>
/// <returns>
///     RMRE_SUCCESS: Returned if the resource was available.
///
///     RMRE_CONFLICT: Returned if all instances of the resource are in use.
///
///     RMRE_EXTERNAL_CONFLICT: Returned if the resource is not available due
///     to conflicts caused by external conditions.
///
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RspAcquire(
    __in const RM_RESOURCE_ID* pResId,
    __deref_out RM_RESOURCE_HANDLE* phResource);

typedef RM_RESULT (*RSP_ACQUIRE)(
    __in const RM_RESOURCE_ID* pResId,
    __deref_out RM_RESOURCE_HANDLE* phResource);


/// <summary>
///     RspRelease allows for a RM to release an acquired resource to free it up
///     for further use.
/// </summary>
/// <param name="hResource">
///     Resource handle returned from RspAcquire to release.
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RspRelease(
    RM_RESOURCE_HANDLE hResource);

typedef RM_RESULT (*RSP_RELEASE)(
    RM_RESOURCE_HANDLE hResource);


/// <summary>
///     RspGetResourceInfo allows for RM to retrieve the current state
///     information about a resource.
/// </summary>
/// <param name="pResId">
///     Pointer to the resource identifier for the resource to return current
///     state information about.
/// </param>
/// <param name="pResourceInfo">
///     Buffer to return the resource information in.
/// </param>
/// <param name="cbResourceInfo">
///     Size of buffer passed in pResourceInfo
/// </param>
/// <returns>
///     RMRE_SUCCESS
///     RMRE_UNEXPECTED
/// </returns>
RM_RESULT RspGetResourceInfo(
    __in const RM_RESOURCE_ID* pResId,
    __out RM_RESOURCE_INFO* pResourceInfo,
    DWORD cbResourceInfo);

typedef RM_RESULT (*RSP_GET_RESOURCE_INFO)(
    __in const RM_RESOURCE_ID* pResId,
    __out RM_RESOURCE_INFO* pResourceInfo,
    DWORD cbResourceInfo);

#ifdef __cplusplus
}
#endif

#endif // _Rsp_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

/* Lack of pragma once is deliberate */

#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC ) && (!defined(_KRPCENV_) || defined(UNDER_CE))
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif



//-------------------------------------------------------------
// platform specific defines
//-------------------------------------------------------------

//-------------------  MAC ---------------------------
#if defined( MAC ) || defined( _MAC )

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else // win32 platforms

#include <basetsd.h>

#if defined(_M_IA64) || defined(_M_AMD64)
#define __RPC_WIN64__
#else
#define __RPC_WIN32__
#endif

#endif

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;

// NTSTATUS is also long, so this definition is valid
// for both user mode and kernel mode
typedef long RPC_STATUS;

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define RPC_UNICODE_SUPPORTED
#endif

#if !defined(__RPC_MAC__) && ( (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) )
#   define __RPC_API  __stdcall
#   define __RPC_USER __stdcall
#   define __RPC_STUB __stdcall
#   define  RPC_ENTRY __stdcall
#else // Not Win32/Win64
#   define __RPC_API
#   define __RPC_USER
#   define __RPC_STUB
#   define RPC_ENTRY
#endif

#define __RPC_FAR

// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined(DECLSPEC_IMPORT)
#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined(_RPCRT4_) && !defined(_KRPCENV_)
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined(_RPCNS4_)
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#if defined (UNDER_CE)
#undef RPCRTAPI
#undef RPCNSAPI
#undef RPC_ENTRY

#define RPCRTAPI
#define RPCNSAPI
#define RPC_ENTRY

#endif


#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4005 )
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default :  4005 )
#endif

typedef void  (RPC_ENTRY *MACYIELDCALLBACK)(/*OSErr*/ short *) ;
RPC_STATUS RPC_ENTRY
RpcMacSetYieldInfo(
    MACYIELDCALLBACK pfnCallback) ;

#if !defined(UNALIGNED)
#define UNALIGNED
#endif

#include <poppack.h>

#else // __RPC_MAC__
#include <rpcdce.h>
#if !defined(_KRPCENV_)
#include <rpcnsi.h>
#endif // _KRPCENV_
#include <rpcnterr.h>
#include <excpt.h>
#if !defined(_KRPCENV_)
#include <winerror.h>
#endif // _KRPCENV_

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

#endif // __RPC_MAC__

// Definitions which depend on windows.h
#if (!defined( RPC_NO_WINDOWS_H ) && !defined(__RPC_MAC__)) || defined(_KRPCENV_)

#include <rpcasync.h>

#endif // RPC_NO_WINDOWS_H

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rowpos.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 17:20:43 1997
 */
/* Compiler settings for msdadc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rowpos_h__
#define __rowpos_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRowPosition_FWD_DEFINED__
#define __IRowPosition_FWD_DEFINED__
typedef interface IRowPosition IRowPosition;
#endif 	/* __IRowPosition_FWD_DEFINED__ */


#ifndef __IRowPositionChange_FWD_DEFINED__
#define __IRowPositionChange_FWD_DEFINED__
typedef interface IRowPositionChange IRowPositionChange;
#endif 	/* __IRowPositionChange_FWD_DEFINED__ */


#ifndef __RowPosition_FWD_DEFINED__
#define __RowPosition_FWD_DEFINED__

#ifdef __cplusplus
typedef class RowPosition RowPosition;
#else
typedef struct RowPosition RowPosition;
#endif /* __cplusplus */

#endif 	/* __RowPosition_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __IRowPosition_INTERFACE_DEFINED__
#define __IRowPosition_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPosition
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


typedef DWORD DBPOSITIONFLAGS;


enum DBPOSITIONFLAGSENUM
    {	DBPOSITION_OK	= 0,
	DBPOSITION_NOROW	= DBPOSITION_OK + 1,
	DBPOSITION_BOF	= DBPOSITION_NOROW + 1,
	DBPOSITION_EOF	= DBPOSITION_BOF + 1
    };

EXTERN_C const IID IID_IRowPosition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a94-2a1c-11ce-ade5-00aa0044773d")
    IRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ClearRowPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowPosition( 
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown __RPC_FAR *pRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRowPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPosition __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearRowPosition )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowset )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags);
        
        END_INTERFACE
    } IRowPositionVtbl;

    interface IRowPosition
    {
        CONST_VTBL struct IRowPositionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPosition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPosition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPosition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPosition_ClearRowPosition(This)	\
    (This)->lpVtbl -> ClearRowPosition(This)

#define IRowPosition_GetRowPosition(This,phChapter,phRow,pdwPositionFlags)	\
    (This)->lpVtbl -> GetRowPosition(This,phChapter,phRow,pdwPositionFlags)

#define IRowPosition_GetRowset(This,riid,ppRowset)	\
    (This)->lpVtbl -> GetRowset(This,riid,ppRowset)

#define IRowPosition_Initialize(This,pRowset)	\
    (This)->lpVtbl -> Initialize(This,pRowset)

#define IRowPosition_SetRowPosition(This,hChapter,hRow,dwPositionFlags)	\
    (This)->lpVtbl -> SetRowPosition(This,hChapter,hRow,dwPositionFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPosition_ClearRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This);


void __RPC_STUB IRowPosition_ClearRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [out] */ HCHAPTER __RPC_FAR *phChapter,
    /* [out] */ HROW __RPC_FAR *phRow,
    /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);


void __RPC_STUB IRowPosition_GetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowset_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);


void __RPC_STUB IRowPosition_GetRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_Initialize_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowset);


void __RPC_STUB IRowPosition_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_SetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags);


void __RPC_STUB IRowPosition_SetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPosition_INTERFACE_DEFINED__ */


#ifndef __IRowPositionChange_INTERFACE_DEFINED__
#define __IRowPositionChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPositionChange
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



enum DBREASONPOSITIONENUM
    {	DBREASON_ROWPOSITION_CHANGED	= DBREASON_ROWSET_CHANGED + 1,
	DBREASON_ROWPOSITION_CHAPTERCHANGED	= DBREASON_ROWPOSITION_CHANGED + 1,
	DBREASON_ROWPOSITION_CLEARED	= DBREASON_ROWPOSITION_CHAPTERCHANGED + 1
    };

EXTERN_C const IID IID_IRowPositionChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0997a571-126e-11d0-9f8a-00a0c9a0631e")
    IRowPositionChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnRowPositionChange( 
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPositionChange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPositionChange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnRowPositionChange )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        END_INTERFACE
    } IRowPositionChangeVtbl;

    interface IRowPositionChange
    {
        CONST_VTBL struct IRowPositionChangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPositionChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPositionChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPositionChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPositionChange_OnRowPositionChange(This,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnRowPositionChange(This,eReason,ePhase,fCantDeny)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPositionChange_OnRowPositionChange_Proxy( 
    IRowPositionChange __RPC_FAR * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


void __RPC_STUB IRowPositionChange_OnRowPositionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPositionChange_INTERFACE_DEFINED__ */



#ifndef __MSDAUTILLib_LIBRARY_DEFINED__
#define __MSDAUTILLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSDAUTILLib
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RowPosition;

class DECLSPEC_UUID("2048EEE6-7FA2-11D0-9E6A-00A0C9138C29")
RowPosition;

DEFINE_GUID(CLSID_RowPosition, 0x2048eee6, 0x7fa2, 0x11d0, 0x9e, 0x6a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x29);
DEFINE_GUID(IID_IRowPosition,  0x0c733a94, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x0, 0xaa, 0x0, 0x44, 0x77, 0x3d);
DEFINE_GUID(IID_IRowPositionChange,  0x0997a571, 0x126e, 0x11d0, 0x9f, 0x8a, 0x0, 0xa0, 0xc9, 0xa0, 0x63, 0x1e);


#endif
#endif /* __MSDAUTILLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcasync.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcasync.h

Abstract:

    This module contains the RPC runtime APIs needed to use
    [async] RPC features.

--*/

#pragma once

#ifndef __RPCASYNC_H__
#define __RPCASYNC_H__

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_KRPCENV_) && !defined(UNDER_CE)

#include <ntddk.h>
#include <windef.h>

#endif // _KRPCENV_

#define RPC_ASYNC_VERSION_1_0     sizeof(RPC_ASYNC_STATE)

typedef
enum _RPC_NOTIFICATION_TYPES
{
    RpcNotificationTypeNone,
    RpcNotificationTypeEvent,
#if !defined(_KRPCENV_)
    RpcNotificationTypeApc,
    RpcNotificationTypeIoc,
    RpcNotificationTypeHwnd,
#endif
    RpcNotificationTypeCallback
} RPC_NOTIFICATION_TYPES;

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete,
    RpcClientDisconnect,
    RpcClientCancel
    } RPC_ASYNC_EVENT;
    
#else // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete,
    RpcClientDisconnect
    } RPC_ASYNC_EVENT;    
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

struct _RPC_ASYNC_STATE;

typedef void RPC_ENTRY
RPCNOTIFICATION_ROUTINE (
                  struct _RPC_ASYNC_STATE *pAsync,
                  void *Context,
                  RPC_ASYNC_EVENT Event);
typedef RPCNOTIFICATION_ROUTINE *PFN_RPCNOTIFICATION_ROUTINE;

typedef union _RPC_ASYNC_NOTIFICATION_INFO {
#if !defined(_KRPCENV_)
    //
    // Notification by APC
    //
    struct {
        PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
        HANDLE hThread;
        } APC;

    //
    // Notification by IO completion port
    //
    struct {
        HANDLE hIOPort;
        DWORD dwNumberOfBytesTransferred;
        DWORD_PTR dwCompletionKey;
        LPOVERLAPPED lpOverlapped;
        } IOC;

    //
    // Notification by window message
    //
    struct {
        HWND hWnd;
        UINT Msg;
        } HWND;
    #endif // _KRPCENV_


    #if !defined(_KRPCENV_) || defined(UNDER_CE)
    //
    // Notification by event
    //
    HANDLE hEvent;
    #else   // _KRPCENV_
    //
    // Notification by event
    //
    PKEVENT Event;
    #endif  // _KRPCENV_

    //
    // Notification by callback function
    //
    // This option is available only to OLE
    //
    PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
} RPC_ASYNC_NOTIFICATION_INFO, *PRPC_ASYNC_NOTIFICATION_INFO;

typedef struct _RPC_ASYNC_STATE {
    unsigned int    Size; // size of this structure
    unsigned long   Signature;
    long   Lock;
    unsigned long   Flags;
    void           *StubInfo;
    void           *UserInfo;
    void           *RuntimeInfo;
    RPC_ASYNC_EVENT Event;

    RPC_NOTIFICATION_TYPES NotificationType;
    RPC_ASYNC_NOTIFICATION_INFO u;

    LONG_PTR Reserved[4];
    } RPC_ASYNC_STATE, *PRPC_ASYNC_STATE;

// Possible values for Flags
#define RPC_C_NOTIFY_ON_SEND_COMPLETE      0x1
#define RPC_C_INFINITE_TIMEOUT             INFINITE

#define RpcAsyncGetCallHandle(pAsync) (((PRPC_ASYNC_STATE) pAsync)->RuntimeInfo)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncInitializeHandle (
    __out_bcount(Size) PRPC_ASYNC_STATE pAsync,
    __in unsigned int     Size
    );

#if !defined(_KRPCENV_)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncRegisterInfo (
    __in PRPC_ASYNC_STATE pAsync
    ) ;
#endif

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncGetCallStatus (
    __in PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCompleteCall (
    __inout PRPC_ASYNC_STATE pAsync,
    __out_opt void *Reply
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncAbortCall (
    __inout PRPC_ASYNC_STATE pAsync,
    __in unsigned long ExceptionCode
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCancelCall (
    __inout PRPC_ASYNC_STATE pAsync,
    __in BOOL fAbort
    ) ;

#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)
typedef enum tagExtendedErrorParamTypes
{
    eeptAnsiString = 1,
    eeptUnicodeString,
    eeptLongVal,
    eeptShortVal,
    eeptPointerVal,
    eeptNone,
    eeptBinary
} ExtendedErrorParamTypes;

#define MaxNumberOfEEInfoParams    4
#define RPC_EEINFO_VERSION         1

typedef struct tagBinaryParam
{
    void *Buffer;
    short Size;
} BinaryParam;

typedef struct tagRPC_EE_INFO_PARAM
{
    ExtendedErrorParamTypes ParameterType;
    union
        {
        LPSTR AnsiString;
        LPWSTR UnicodeString;
        long LVal;
        short SVal;
        ULONGLONG PVal;
        BinaryParam BVal;
        } u;
} RPC_EE_INFO_PARAM;

#define EEInfoPreviousRecordsMissing     1
#define EEInfoNextRecordsMissing         2
#define EEInfoUseFileTime                4

#define EEInfoGCCOM                     11
#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
#define EEInfoGCFRS                     12
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

typedef struct tagRPC_EXTENDED_ERROR_INFO
{
    ULONG Version;
    LPWSTR ComputerName;
    ULONG ProcessID;
    union
        {
#if !defined(_KRPCENV_)
        SYSTEMTIME SystemTime;
        FILETIME FileTime;
#else    // _KRPCENV_
        LARGE_INTEGER KernelTime;
#endif   // _KRPCENV_
        } u;
    ULONG GeneratingComponent;
    ULONG Status;
    USHORT DetectionLocation;
    USHORT Flags;
    int NumberOfParameters;
    RPC_EE_INFO_PARAM Parameters[MaxNumberOfEEInfoParams];
} RPC_EXTENDED_ERROR_INFO;

typedef struct tagRPC_ERROR_ENUM_HANDLE
{
    ULONG Signature;
    void *CurrentPos;
    void *Head;
} RPC_ERROR_ENUM_HANDLE;

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorStartEnumeration (
    __out RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNextRecord (
    __in RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __in BOOL CopyStrings, 
    __out RPC_EXTENDED_ERROR_INFO *ErrorInfo
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorEndEnumeration (
    __inout RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorResetEnumeration (
    __inout RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNumberOfRecords (
    __in RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __out int *Records
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorSaveErrorInfo (
    __in RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __out_bcount(*BlobSize) PVOID *ErrorBlob, 
    __out size_t *BlobSize
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorLoadErrorInfo (
    __in_bcount(BlobSize) PVOID ErrorBlob, 
    __in size_t BlobSize, 
    __out RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorAddRecord (
    __in RPC_EXTENDED_ERROR_INFO *ErrorInfo
    );

RPCRTAPI
void 
RPC_ENTRY
RpcErrorClearInformation (
    void
    );

#if !defined(_KRPCENV_)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCleanupThread (
    __in DWORD dwTimeout
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcGetAuthorizationContextForClient (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __in BOOL ImpersonateOnReturn,
    __in_opt PVOID Reserved1,
    __in_opt PLARGE_INTEGER pExpirationTime,
    __in LUID Reserved2,
    __in DWORD Reserved3,
    __in_opt PVOID Reserved4,
    __out PVOID *pAuthzClientContext
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcFreeAuthorizationContext (
    __deref PVOID *pAuthzClientContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockExclusive (
    __in_opt RPC_BINDING_HANDLE ServerBindingHandle,
    __in PVOID UserContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockShared (
    __in RPC_BINDING_HANDLE ServerBindingHandle,
    __in PVOID UserContext
    );

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
typedef enum tagRpcLocalAddressFormat
{
    rlafInvalid = 0,
    rlafIPv4,
    rlafIPv6
} RpcLocalAddressFormat;

typedef struct _RPC_CALL_LOCAL_ADDRESS_V1
{
    unsigned int Version;
    void *Buffer;
    unsigned long BufferSize;
    RpcLocalAddressFormat AddressFormat;
} RPC_CALL_LOCAL_ADDRESS_V1, *PRPC_CALL_LOCAL_ADDRESS_V1;

#define RPC_CALL_ATTRIBUTES_VERSION                         (2)

#define RPC_QUERY_SERVER_PRINCIPAL_NAME                     (0x02)
#define RPC_QUERY_CLIENT_PRINCIPAL_NAME                     (0x04)
#define RPC_QUERY_CALL_LOCAL_ADDRESS                        (0x08)
#define RPC_QUERY_CLIENT_PID                                (0x10)
#define RPC_QUERY_IS_CLIENT_LOCAL                           (0x20)
#define RPC_QUERY_NO_AUTH_REQUIRED                          (0x40)
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#if ( (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_VISTA) ) && !defined(UNDER_CE)
#define RPC_CALL_ATTRIBUTES_VERSION                         (1)
#define RPC_QUERY_SERVER_PRINCIPAL_NAME                     (2)
#define RPC_QUERY_CLIENT_PRINCIPAL_NAME                     (4)
#endif // ( (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_VISTA) ) && !defined(UNDER_CE)

typedef struct tagRPC_CALL_ATTRIBUTES_V1_W
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned short *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned short *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
} RPC_CALL_ATTRIBUTES_V1_W;

typedef struct tagRPC_CALL_ATTRIBUTES_V1_A
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned char *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned char *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
} RPC_CALL_ATTRIBUTES_V1_A;

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
// CallStatus bit fields
#define RPC_CALL_STATUS_CANCELLED          0x01
#define RPC_CALL_STATUS_DISCONNECTED       0x02

typedef enum tagRpcCallType
{
    rctInvalid = 0,
    rctNormal,
    rctTraining,
    rctGuaranteed
} RpcCallType;

typedef enum tagRpcCallClientLocality
{
    rcclInvalid = 0,
    rcclLocal,
    rcclRemote,
    rcclClientUnknownLocality
} RpcCallClientLocality;


typedef struct tagRPC_CALL_ATTRIBUTES_V2_W
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned short *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned short *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
    BOOL KernelModeCaller;
    unsigned long ProtocolSequence;
    RpcCallClientLocality IsClientLocal;
    HANDLE ClientPID; 
    unsigned long CallStatus;
    RpcCallType CallType;
    RPC_CALL_LOCAL_ADDRESS_V1 *CallLocalAddress;    // one of the CallLocalAddress flavors
    unsigned short OpNum;
    UUID InterfaceUuid;        
} RPC_CALL_ATTRIBUTES_V2_W;
    
typedef struct tagRPC_CALL_ATTRIBUTES_V2_A
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned char *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned char *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
    BOOL KernelModeCaller;
    unsigned long ProtocolSequence;
    unsigned long IsClientLocal;
    HANDLE ClientPID; 
    unsigned long CallStatus;
    RpcCallType CallType;
    RPC_CALL_LOCAL_ADDRESS_V1 *CallLocalAddress;    // one of the CallLocalAddress flavors
    unsigned short OpNum;
    UUID InterfaceUuid;    
} RPC_CALL_ATTRIBUTES_V2_A;
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqCallAttributesW (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __inout void *RpcCallAttributes
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqCallAttributesA (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __inout void *RpcCallAttributes
    );

#ifdef UNICODE
#  define RPC_CALL_ATTRIBUTES_V1 RPC_CALL_ATTRIBUTES_V1_W
#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#  define RPC_CALL_ATTRIBUTES_V2 RPC_CALL_ATTRIBUTES_V2_W
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#  define RpcServerInqCallAttributes RpcServerInqCallAttributesW
#else
#  define RPC_CALL_ATTRIBUTES_V1 RPC_CALL_ATTRIBUTES_V1_A
#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#  define RPC_CALL_ATTRIBUTES_V2 RPC_CALL_ATTRIBUTES_V2_A
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#  define RpcServerInqCallAttributes RpcServerInqCallAttributesA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
typedef RPC_CALL_ATTRIBUTES_V2 RPC_CALL_ATTRIBUTES;
#else 
typedef RPC_CALL_ATTRIBUTES_V1 RPC_CALL_ATTRIBUTES;
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
// can be used as flags in a bitmask too
typedef enum _RPC_NOTIFICATIONS
{
    RpcNotificationCallNone = 0,
    RpcNotificationClientDisconnect = 1,
    RpcNotificationCallCancel = 2      // internal for Windows
} RPC_NOTIFICATIONS;

#define RpcNotificationCallStatusChange    RpcNotificationClientDisconnect

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcServerSubscribeForNotification (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in RPC_NOTIFICATIONS Notification,
    __in RPC_NOTIFICATION_TYPES NotificationType,
    __in RPC_ASYNC_NOTIFICATION_INFO *NotificationInfo
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcServerUnsubscribeForNotification (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in RPC_NOTIFICATIONS Notification,
    __out unsigned long *NotificationsQueued
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#endif // _KRPCENV_
 
#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcBindingBind (
    __in_opt PRPC_ASYNC_STATE pAsync,
    __in RPC_BINDING_HANDLE Binding,
    __in RPC_IF_HANDLE IfSpec    
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcBindingUnbind (
    __in RPC_BINDING_HANDLE Binding
    );

#define RPC_DE_USE_CURRENT_EEINFO              (1)

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcDiagnoseError (
    __in RPC_BINDING_HANDLE BindingHandle, 
    __in RPC_IF_HANDLE IfSpec, 
    __in RPC_STATUS RpcStatus, 
    __in_opt RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __in ULONG Options,
    __in_opt HWND ParentWindow
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)
//
// Internal APIs
//
RPC_STATUS RPC_ENTRY
I_RpcAsyncSetHandle (
    __in  PRPC_MESSAGE Message,
    __in  PRPC_ASYNC_STATE pAsync
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncAbortCall (
    __in PRPC_ASYNC_STATE pAsync,
    __in unsigned long ExceptionCode
    ) ;

#if (NTDDI_VERSION >= NTDDI_WXP) || defined(UNDER_CE)
int 
RPC_ENTRY
I_RpcExceptionFilter (
    __in unsigned long ExceptionCode
    );
#endif // (NTDDI_VERSION >= NTDDI_WXP) || defined(UNDER_CE)

#ifdef __cplusplus
}
#endif

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#endif /* __RPCASYNC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcnsi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcnsi.h

Abstract:

    This file contains the types and function definitions to use the
    Name Service Independent APIs.

--*/

#pragma once

#ifndef __RPCNSI_H__
#define __RPCNSI_H__


typedef void __RPC_FAR * RPC_NS_HANDLE;

#define RPC_C_NS_SYNTAX_DEFAULT 0
#define RPC_C_NS_SYNTAX_DCE 3

#define RPC_C_PROFILE_DEFAULT_ELT 0
#define RPC_C_PROFILE_ALL_ELT 1
#define RPC_C_PROFILE_ALL_ELTS RPC_C_PROFILE_ALL_ELT
#define RPC_C_PROFILE_MATCH_BY_IF 2
#define RPC_C_PROFILE_MATCH_BY_MBR 3
#define RPC_C_PROFILE_MATCH_BY_BOTH 4

#define RPC_C_NS_DEFAULT_EXP_AGE -1

/* Server APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingExportA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt RPC_BINDING_VECTOR __RPC_FAR *BindingVec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );


RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingExportW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt RPC_BINDING_VECTOR __RPC_FAR *BindingVec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

#endif

/* Server PnP APIs */

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

#endif

/* Client APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __in unsigned long BindingMaxCount,
    __out RPC_NS_HANDLE __RPC_FAR *LookupContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __in unsigned long BindingMaxCount,
    __out RPC_NS_HANDLE __RPC_FAR *LookupContext
    );
#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupNext(
    IN  RPC_NS_HANDLE LookupContext,
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

/* Group APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteA(
    __in unsigned long GroupNameSyntax,
    __in_opt RPC_CSTR GroupName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddA(
    __in unsigned long GroupNameSyntax,
    __in RPC_CSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveA(
    __in unsigned long GroupNameSyntax,
    __in RPC_CSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginA(
    __in unsigned long GroupNameSyntax,
    __in RPC_CSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextA(
    __inout RPC_NS_HANDLE InquiryContext,
    __deref_out RPC_CSTR __RPC_FAR *MemberName
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteW(
    __in unsigned long GroupNameSyntax,
    __in_opt RPC_WSTR GroupName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddW(
    __in unsigned long GroupNameSyntax,
    __in RPC_WSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveW(
    __in unsigned long GroupNameSyntax,
    __in RPC_WSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginW(
    __in unsigned long GroupNameSyntax,
    __in RPC_WSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextW(
    __inout RPC_NS_HANDLE InquiryContext,
    __deref_out RPC_WSTR __RPC_FAR *MemberName
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Profile APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName,
    __in unsigned long Priority,
    __in_opt RPC_CSTR Annotation
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName,
    __in unsigned long InquiryType,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in unsigned long MemberNameSyntax,
    __in_opt RPC_CSTR MemberName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextA(
    __in RPC_NS_HANDLE InquiryContext,
    __out_opt RPC_IF_ID __RPC_FAR *IfId,
    __out RPC_CSTR __RPC_FAR *MemberName,
    __out unsigned long __RPC_FAR *Priority,
    __out RPC_CSTR __RPC_FAR *Annotation
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName,
    __in unsigned long Priority,
    __in_opt RPC_WSTR Annotation
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName,
    __in unsigned long InquiryType,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in unsigned long MemberNameSyntax,
    __in_opt RPC_WSTR MemberName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextW(
    __in RPC_NS_HANDLE InquiryContext,
    __out_opt RPC_IF_ID __RPC_FAR *IfId,
    __out RPC_WSTR __RPC_FAR *MemberName,
    __out unsigned long __RPC_FAR *Priority,
    __out RPC_WSTR __RPC_FAR *Annotation
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Entry object APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqNext(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT UUID __RPC_FAR * ObjUuid
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Management and MISC APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __out RPC_CSTR __RPC_FAR *ExpandedName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __out RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR *IfIdVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtHandleSetExpAge(
    IN RPC_NS_HANDLE NsHandle,
    IN unsigned long ExpirationAge
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtInqExpAge(
    OUT unsigned long __RPC_FAR * ExpirationAge
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtSetExpAge(
    IN unsigned long ExpirationAge
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __out RPC_WSTR __RPC_FAR *ExpandedName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __out RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR *IfIdVec
    );

#endif

/* Client API's implemented in wrappers. */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __out RPC_NS_HANDLE __RPC_FAR *ImportContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __out RPC_NS_HANDLE __RPC_FAR *ImportContext
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportNext(
    IN RPC_NS_HANDLE ImportContext,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingSelect(
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * BindingVec,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

#ifdef UNICODE

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginW
#define RpcNsBindingImportBegin RpcNsBindingImportBeginW
#define RpcNsBindingExport RpcNsBindingExportW
#define RpcNsBindingUnexport RpcNsBindingUnexportW
#define RpcNsGroupDelete RpcNsGroupDeleteW
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddW
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveW
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginW
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextW
#define RpcNsEntryExpandName RpcNsEntryExpandNameW
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginW
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportW
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateW
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteW
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsW
#define RpcNsProfileDelete RpcNsProfileDeleteW
#define RpcNsProfileEltAdd RpcNsProfileEltAddW
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveW
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginW
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextW
#define RpcNsBindingExportPnP RpcNsBindingExportPnPW
#define RpcNsBindingUnexportPnP RpcNsBindingUnexportPnPW

#else

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginA
#define RpcNsBindingImportBegin RpcNsBindingImportBeginA
#define RpcNsBindingExport RpcNsBindingExportA
#define RpcNsBindingUnexport RpcNsBindingUnexportA
#define RpcNsGroupDelete RpcNsGroupDeleteA
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddA
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveA
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginA
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextA
#define RpcNsEntryExpandName RpcNsEntryExpandNameA
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginA
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportA
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateA
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteA
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsA
#define RpcNsProfileDelete RpcNsProfileDeleteA
#define RpcNsProfileEltAdd RpcNsProfileEltAddA
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveA
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginA
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextA
#define RpcNsBindingExportPnP RpcNsBindingExportPnPA
#define RpcNsBindingUnexportPnP RpcNsBindingUnexportPnPA
#endif /* UNICODE */

#endif /* __RPCNSI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rndismini.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  
    rndismini.h

Abstract:  
	This module defines the constants and type definitions shared by
	the rndis miniport mdd and pdd modules.

Functions:

    
--*/

#ifndef _RNDISMDD_H

#define _RNDISMDD_H

#include <types.h>

#ifdef __cplusplus
extern "C" {
#endif


////////////////////////////////////////////////////////////////////////////////
//
//	DebugZones shared by both MDD & PDD. PDD takes zone 8..13
//

#ifdef DEBUG
#define ZONE_INIT		DEBUGZONE(0)
#define	ZONE_RNDIS		DEBUGZONE(1)		
#define	ZONE_HOSTMINI	DEBUGZONE(2)
#define	ZONE_CEMINI		DEBUGZONE(3)
#define	ZONE_MEM		DEBUGZONE(4)
#define	ZONE_PDDCALL	DEBUGZONE(5)
#define ZONE_MDD_REF    DEBUGZONE(6)


/*

  DEBUGZONE(8..13) are for PDD.

*/

#define ZONE_WARNING	DEBUGZONE(14)
#define ZONE_ERROR		DEBUGZONE(15)
#endif


////////////////////////////////////////////////////////////////////////////////
//
//	USB Communication Class specific request code used by RNDIS
//

#define	SEND_ENCAPSULATED_COMMAND		0x00	
#define	GET_ENCAPSULATED_RESPONSE		0x01	
#define	RESPONSE_AVAILABLE				0x01


////////////////////////////////////////////////////////////////////////////////
//
//	RequestID sent for PDD's SetHandler & GetHandler.
//	

#define	REQ_ID_HARD_RESET				0x00000001	//	SET:: Hard reset..
#define	REQ_ID_SOFT_RESET				0x00000002	//	SET:: Soft reset..
#define REQ_ID_ENABLE_INT				0x00000003  //  SET:: Enable Interrupt 
#define REQ_ID_DISABLE_INT				0x00000004  //  SET:: Disable Interrupt

#define	REQ_ID_VENDOR_ID				0x80000001	//	GET:: Vendor ID
#define	REQ_ID_VENDOR_DESCRIPTION		0x80000002	//	GET:: Vendor desc.
#define	REQ_ID_DEVICE_MAX_RX			0x80000003	//	GET:: Vedor max rx.
#define REQ_ID_DEVICE_MACADDR           0x80000004  //  GET:: MAC Address.

////////////////////////////////////////////////////////////////////////////////
//
//	Wrapper for user data / RNDIS messages communicated between
//	MDD / PDD.
//

typedef struct _DATA_WRAPPER
{
	LIST_ENTRY	Link;	
	UCHAR		*pucData;	
	DWORD		dwDataSize;	

}	DATA_WRAPPER, *PDATA_WRAPPER;



////////////////////////////////////////////////////////////////////////////////
//
//	The RNDIS PDD driver needs to export the following functions for RNDIS MDD
//	during the call to InitPDD()
//

typedef
void
(* PFN_PDD_SEND_RNDIS_MESSAGE)(
	IN	PDATA_WRAPPER	pDataWrapper);

typedef
void
(* PFN_PDD_INDICATE_RNDIS_PACKET_COMPLETE)(
	IN	PDATA_WRAPPER	pDataWrapper);	


typedef
BOOL
(* PFN_PDD_SET)(
	IN	UINT	uiRequestId,
	IN	PVOID	pvData,
	IN	ULONG	ulDataLength);

typedef
BOOL
(* PFN_PDD_GET)(
	IN	UINT	uiRequestId,
	IN	PVOID	pvData,
	IN	ULONG	ulDataLength,
	OUT	ULONG	*pulRequiredLength);

typedef
void
(* PFN_PDD_SEND_RNDIS_PACKET)(
	IN	PDATA_WRAPPER	pDataWrapper);

typedef
BOOL
(* PFN_PDD_ISR)(PDWORD	pdwWaitTime);


typedef	struct _RNDIS_PDD_CHARACTERISTICS
{	
	PFN_PDD_SEND_RNDIS_MESSAGE				SendRndisMessageHandler;	
	PFN_PDD_SEND_RNDIS_PACKET				SendRndisPacketHandler;
	PFN_PDD_INDICATE_RNDIS_PACKET_COMPLETE	IndicateRndisPacketCompleteHandler;	
	PFN_PDD_SET								SetHandler;
	PFN_PDD_GET								GetHandler;
	PFN_PDD_ISR								ISRHandler;
	DWORD									dwIRQ;
	DWORD									dwMaxRx;
	DWORD									dwBaseAddr;

    //
    //  BUS specific information
    //  If it is PCI then this driver will be loaded by PCI enumerator through
    //  NDIS.   
    //

    BOOL    bPCIDevice;
    
    //
    //  These are only needed for PCI type device AND if the driver chooses
    //  to use GIISR.DLL as default ISR.
    //

    BOOL    CheckPort;            // If true, check port to see if device is asserting IRQ
    BOOL    PortIsIO;             // Port is IO port (possibly true only for x86)
    BOOL    UseMaskReg;           // If true, read from MaskAddr to obtain mask
    DWORD   PortAddr;             // Port Address
    DWORD   PortSize;             // Port data width in bytes
    DWORD   Mask;                 // Mask to use on data port to determine if device is asserting IRQ
    DWORD   MaskAddr;             // Address of register to use as mask

}	RNDIS_PDD_CHARACTERISTICS, *PRNDIS_PDD_CHARACTERISTICS;



////////////////////////////////////////////////////////////////////////////////
//
//	Functions exported by RNDIS PDD driver.
//
BOOL
PDDInit(
	OUT RNDIS_PDD_CHARACTERISTICS	*pRndisPddCharacteristics,
	IN	PBYTE 				pBaseAddress);

void
PDDDeinit(void);



////////////////////////////////////////////////////////////////////////////////
//
//	Functions exported by RNDIS MDD driver
//

void 
DumpMemory (PBYTE	pSource, DWORD	dwLength);

#ifdef	CELOGMSG 
#undef	CELOGMSG
#endif

#if DEBUG	
	void RndisMiniCeLogMsg(LPCWSTR lpszFmt, ...);
	
	#define CELOGMSG(cond,printf_exp)   \
		((void)((cond)?(RndisMiniCeLogMsg printf_exp),1:0))
#else

	#define CELOGMSG(cond,printf_exp)   

#endif

void
MddIndicateRndisMessage (
	PDATA_WRAPPER	pDataWrapper);

void
MddIndicateRndisPacket(
	PDATA_WRAPPER	pDataWrapper);
	
void
MddSendRndisMessageComplete(
	PDATA_WRAPPER	pDataWrapper);

void
MddSendRndisPacketComplete(
	PDATA_WRAPPER	pDataWrapper);

PDATA_WRAPPER
MDDAllocDataWrapper(void);

void
MDDFreeDataWrapper(PDATA_WRAPPER pDataWrapper);

PBYTE
MDDAllocMem(void);

void
MDDFreeMem(PBYTE pBuffer);

void
MddDisconnect();

BOOL
MddConnect();

void
MddEnterPdd(void);

void
MddLeavePdd(void);

void
MDDInit();

void
MDDDeinit();

DWORD
MDDGetBulkTransferSize();

BOOL
MDDHaltReceived();

#ifdef __cplusplus
}
#endif

#endif	// _RNDISMDD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcdcep.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcdcep.h

Abstract:

    This module contains the private RPC runtime APIs for use by the
    stubs and by support libraries.  Applications must not call these
    routines.

--*/

#pragma once

#ifndef __RPCDCEP_H__
#define __RPCDCEP_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RPC_VERSION {
    unsigned short MajorVersion;
    unsigned short MinorVersion;
} RPC_VERSION;

typedef struct _RPC_SYNTAX_IDENTIFIER {
    GUID SyntaxGUID;
    RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, __RPC_FAR * PRPC_SYNTAX_IDENTIFIER;

typedef struct _RPC_MESSAGE
{
    RPC_BINDING_HANDLE Handle;
    unsigned long DataRepresentation;
    void __RPC_FAR * Buffer;
    unsigned int BufferLength;
    unsigned int ProcNum;
    PRPC_SYNTAX_IDENTIFIER TransferSyntax;
    void __RPC_FAR * RpcInterfaceInformation;
    void __RPC_FAR * ReservedForRuntime;
    RPC_MGR_EPV __RPC_FAR * ManagerEpv;
    void __RPC_FAR * ImportContext;
    unsigned long RpcFlags;
} RPC_MESSAGE, __RPC_FAR * PRPC_MESSAGE;


typedef RPC_STATUS
RPC_ENTRY RPC_FORWARD_FUNCTION(
                       IN UUID             __RPC_FAR * InterfaceId,
                       IN RPC_VERSION      __RPC_FAR * InterfaceVersion,
                       IN UUID             __RPC_FAR * ObjectId,
                       IN unsigned char         __RPC_FAR * Rpcpro,
                       IN void __RPC_FAR * __RPC_FAR * ppDestEndpoint);

enum RPC_ADDRESS_CHANGE_TYPE
{
    PROTOCOL_NOT_LOADED = 1,
    PROTOCOL_LOADED,
    PROTOCOL_ADDRESS_CHANGE
};

typedef void
RPC_ENTRY RPC_ADDRESS_CHANGE_FN(
                        IN void * arg
                        );

/*
*  New context handle flavors.
*/
#define RPC_CONTEXT_HANDLE_DEFAULT_GUARD    ((void *)(ULONG_PTR)0xFFFFF00D)

#define RPC_CONTEXT_HANDLE_DEFAULT_FLAGS    0x00000000UL
#define RPC_CONTEXT_HANDLE_FLAGS            0x30000000UL
#define RPC_CONTEXT_HANDLE_SERIALIZE        0x10000000UL
#define RPC_CONTEXT_HANDLE_DONT_SERIALIZE   0x20000000UL
#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPC_TYPE_STRICT_CONTEXT_HANDLE      0x40000000UL
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

/*
 * Types of function calls for datagram rpc
 */

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPCFLG_HAS_GUARANTEE        0x00000010UL
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#define RPC_BUFFER_COMPLETE         0x00001000 /* used by pipes */
#define RPC_BUFFER_PARTIAL          0x00002000 /* used by pipes */
#define RPC_BUFFER_EXTRA            0x00004000 /* used by pipes */
#define RPC_BUFFER_ASYNC            0x00008000 /* used by async rpc */
#define RPC_BUFFER_NONOTIFY         0x00010000 /* used by async pipes */


#define RPCFLG_MESSAGE              0x01000000UL
#define RPCFLG_AUTO_COMPLETE        0x08000000UL
#define RPCFLG_LOCAL_CALL           0x10000000UL
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000UL
#define RPCFLG_ASYNCHRONOUS         0x40000000UL
#define RPCFLG_NON_NDR              0x80000000UL

#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)
#define RPCFLG_HAS_MULTI_SYNTAXES   0x02000000UL
#define RPCFLG_HAS_CALLBACK         0x04000000UL
#endif // (NTDDI_VERSION >= NTDDI_WXP) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
// These two bits will hold the combination of 
// anonymous/admin/authenticate/mixed mode
#define RPCFLG_ACCESSIBILITY_BIT1   0x00100000UL
#define RPCFLG_ACCESSIBILITY_BIT2   0x00200000UL
#define RPCFLG_ACCESS_LOCAL         0x00400000UL

// This goes to MIDL_STUB_DESC only
#define NDR_CUSTOM_OR_DEFAULT_ALLOCATOR 0x10000000UL
#define NDR_DEFAULT_ALLOCATOR           0x20000000UL
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#define RPC_FLAGS_VALID_BIT 0x00008000

typedef
void
(__RPC_STUB __RPC_FAR * RPC_DISPATCH_FUNCTION) (
    IN OUT PRPC_MESSAGE Message
    );

typedef struct {
    unsigned int DispatchTableCount;
    RPC_DISPATCH_FUNCTION __RPC_FAR * DispatchTable;
    LONG_PTR                          Reserved;
} RPC_DISPATCH_TABLE, __RPC_FAR * PRPC_DISPATCH_TABLE;

typedef struct _RPC_PROTSEQ_ENDPOINT
{
    unsigned char __RPC_FAR * RpcProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
} RPC_PROTSEQ_ENDPOINT, __RPC_FAR * PRPC_PROTSEQ_ENDPOINT;

/*
Both of these types MUST start with the InterfaceId and TransferSyntax.
Look at RpcIfInqId and I_RpcIfInqTransferSyntaxes to see why.
*/
#define NT351_INTERFACE_SIZE 0x40
#define RPC_INTERFACE_HAS_PIPES           0x0001

typedef struct _RPC_SERVER_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    RPC_MGR_EPV __RPC_FAR *DefaultManagerEpv;
    void const __RPC_FAR *InterpreterInfo;
    unsigned int Flags ;
} RPC_SERVER_INTERFACE, __RPC_FAR * PRPC_SERVER_INTERFACE;

typedef struct _RPC_CLIENT_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER   InterfaceId;
    RPC_SYNTAX_IDENTIFIER   TransferSyntax;
    PRPC_DISPATCH_TABLE     DispatchTable;
    unsigned int            RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT   RpcProtseqEndpoint;
    ULONG_PTR               Reserved;
    void const __RPC_FAR *  InterpreterInfo;
    unsigned int Flags ;
} RPC_CLIENT_INTERFACE, __RPC_FAR * PRPC_CLIENT_INTERFACE;

#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNegotiateTransferSyntax (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBufferWithObject (
    IN OUT RPC_MESSAGE __RPC_FAR * Message,
    IN UUID * ObjectUuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSendReceive (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSend (
    IN OUT PRPC_MESSAGE Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreePipeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReallocPipeBuffer (
    __in PRPC_MESSAGE Message,
    __in_bound unsigned int NewSize
    );

typedef void * I_RPC_MUTEX;

RPCRTAPI
void
RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
I_RpcAllocate (
    IN unsigned int Size
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcFree (
    IN void __RPC_FAR * Object
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long Milliseconds
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetExtendedError (
    void
    );

typedef
void
(__RPC_USER __RPC_FAR * PRPC_RUNDOWN) (
    void __RPC_FAR * AssociationContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle,
    IN PRPC_RUNDOWN RundownRoutine,
    IN void * Context
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcStopMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle
    );

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
I_RpcGetCurrentCallHandle(
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetAssociationContext (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void __RPC_FAR * __RPC_FAR * AssociationContext
    );

RPCRTAPI
void *
RPC_ENTRY
I_RpcGetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void * ServerContextList
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceUnexported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingToStaticStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short **StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqSecurityContext (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **SecurityContextHandle
    );

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqSecurityContextKeyInfo (
    __in_opt RPC_BINDING_HANDLE Binding,
    __inout void *KeyInfo
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqWireIdForSnego (
    __in RPC_BINDING_HANDLE Binding,
    __out RPC_CSTR WireId
    );

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqMarshalledTargetInfo (
    __in RPC_BINDING_HANDLE Binding,
    __out unsigned long * MarshalledTargetInfoSize,
    __deref_out_bcount(* MarshalledTargetInfoSize) RPC_CSTR * MarshalledTargetInfo
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#if (NTDDI_VERSION >= WINXP) || defined(UNDER_CE)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqLocalClientPID (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned long *Pid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingHandleToAsyncHandle (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **AsyncHandle
    );
#endif // (NTDDI_VERSION >= WINXP) || defined(UNDER_CE)

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameW (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameA (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2A (
    __in_opt RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2W (
    __in_opt RPC_WSTR NetworkAddress,
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2W (
    __in_opt RPC_WSTR NetworkAddress,
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2A (
    __in_opt RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );


#ifdef UNICODE
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameW
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2W
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2W
#else
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameA
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2A
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2A
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryName (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2 (
    __in RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2 (
    __in RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in void __RPC_FAR *SecurityDescriptor,
    __in void *Policy
    );
#endif

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStartService (
    __in RPC_WSTR Protseq,
    __in RPC_WSTR Endpoint,
    __in RPC_IF_HANDLE IfSpec
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out_opt RPC_WSTR __RPC_FAR *DynamicEndpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out_opt RPC_CSTR __RPC_FAR *DynamicEndpoint
    );

#ifdef UNICODE
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointW
#else
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointA
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out_opt RPC_CSTR __RPC_FAR *DynamicEndpoint
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerCheckClientRestriction (
    IN RPC_BINDING_HANDLE Context
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)

#define TRANSPORT_TYPE_CN        0x01
#define TRANSPORT_TYPE_DG        0x02
#define TRANSPORT_TYPE_LPC       0x04
#define TRANSPORT_TYPE_WMSG      0x08

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqTransportType (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    );

typedef struct _RPC_TRANSFER_SYNTAX
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX __RPC_FAR * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int __RPC_FAR * TransferSyntaxCount
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN OPTIONAL RPC_BINDING_HANDLE BindingHandle,
    OUT unsigned int __RPC_FAR * ClientLocalFlag
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqConnId (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **ConnId,
    OUT int *pfFirstCall
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingCreateNP (
    __in RPC_WSTR ServerName,
    __in RPC_WSTR ServiceName,
    __in RPC_WSTR NetworkOptions,
    __out RPC_BINDING_HANDLE *Binding
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcLaunchDatagramReceiveThread(
    void __RPC_FAR * pAddress
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerRegisterForwardFunction (
    IN RPC_FORWARD_FUNCTION  * pForwardFunction
    );

RPC_ADDRESS_CHANGE_FN * RPC_ENTRY
I_RpcServerInqAddressChangeFn(
    void
    );

RPC_STATUS RPC_ENTRY
I_RpcServerSetAddressChangeFn(
    IN RPC_ADDRESS_CHANGE_FN * pAddressChangeFn
    );

#if (NTDDI_VERSION >= WINXP) || defined(UNDER_CE)
/* The return buffer will contain SOCKADDR_IN for IPv4 */
#define RPC_P_ADDR_FORMAT_TCP_IPV4      1

/* The return buffer will contain SOCKADDR_STORAGE for IPv6 */
#define RPC_P_ADDR_FORMAT_TCP_IPV6      2

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqLocalConnAddress (
    IN RPC_BINDING_HANDLE Binding,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqRemoteConnAddress (
    IN RPC_BINDING_HANDLE Binding,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSessionStrictContextHandle (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcTurnOnEEInfoPropagation (
    void
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionInqSockBuffSize(
  OUT unsigned long __RPC_FAR * RecvBuffSize,
  OUT unsigned long __RPC_FAR * SendBuffSize
  );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionSetSockBuffSize(
   IN unsigned long RecvBuffSize,
   IN unsigned long SendBuffSize
   );

typedef
void
(*RPCLT_PDU_FILTER_FUNC) (
    IN void *Buffer,
    IN unsigned int BufferLength,
    IN int fDatagram
    );

typedef
void
(__cdecl *RPC_SETFILTER_FUNC) (
    IN RPCLT_PDU_FILTER_FUNC pfnFilter
    );

#ifndef WINNT
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStartListening(
    void * hWnd
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStopListening(
    void
    );

typedef RPC_STATUS (*RPC_BLOCKING_FN) (
    IN void * hWnd,
    IN void * Context,
    IN OPTIONAL void * hSyncEvent
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingSetAsync(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_BLOCKING_FN BlockingFn,
    IN unsigned long ServerTid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSetThreadParams(
    IN int fClientFree,
    IN OPTIONAL void *Context,
    IN OPTIONAL void * hWndClient
    );

RPCRTAPI
unsigned int
RPC_ENTRY
I_RpcWindowProc(
    IN void * hWnd,
    IN unsigned int Message,
    IN unsigned int wParam,
    IN unsigned long lParam
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointA (
    __in RPC_CSTR Protseq,
    __in RPC_CSTR Endpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointW (
    __in RPC_WSTR Protseq,
    __in RPC_WSTR Endpoint
    );

#ifdef UNICODE
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointW
#else
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointA
#endif
#endif // WINNT

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqTransportType(
    OUT unsigned int __RPC_FAR * Type
    );

RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );


#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#define RPC_C_OPT_SESSION_ID                (6)
#define RPC_C_OPT_COOKIE_AUTH                  (7)
#define RPC_C_OPT_RESOURCE_TYPE_UUID        (8)

typedef struct _RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR
{
    unsigned long BufferSize;   // Length of the buffer in bytes
    __field_bcount(BufferSize) char *Buffer;               // Zero-terminated string
} RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR;

typedef struct _RDR_CALLOUT_STATE
{
    // LastError is used for debugging only - don't use it for processing
    RPC_STATUS LastError;
    void *LastEEInfo;

    RPC_HTTP_REDIRECTOR_STAGE LastCalledStage;

    // the information accumulated throughout the stages
    unsigned short *ServerName;   // Allocated with MemAllocate
    unsigned short *ServerPort;   // Allocated with MemAllocate
    unsigned short *RemoteUser;   // Allocated with MemAllocate
    unsigned short *AuthType;     // Allocated with MemAllocate
    unsigned char ResourceTypePresent;
    unsigned char SessionIdPresent;
    unsigned char InterfacePresent;
    UUID ResourceType;
    UUID SessionId;
    RPC_SYNTAX_IDENTIFIER Interface;
    void *CertContext;            // Contains PCCERT_CONTEXT if cert is used for authentication. 
                                  // NULL otherwise. If allocated, CertFreeCertificateContext 
                                  // needs to be called on it when done
} RDR_CALLOUT_STATE;
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)
typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyIsValidMachineFn)
        (
        __in RPC_WSTR Machine,
        __in RPC_WSTR DotMachine,
        __in unsigned long PortNumber        
        );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyGetClientAddressFn)
        (
        IN void *Context,
        OUT char *Buffer,
        OUT unsigned long *BufferLength
        );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyGetConnectionTimeoutFn)
        (
        OUT unsigned long *ConnectionTimeout
        );

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
typedef RPC_STATUS
(RPC_ENTRY *I_RpcPerformCalloutFn) 
    (
    IN void *Context,
    IN RDR_CALLOUT_STATE *CallOutState,
    IN RPC_HTTP_REDIRECTOR_STAGE Stage
    );

typedef void
(RPC_ENTRY *I_RpcFreeCalloutStateFn)
    (
    IN RDR_CALLOUT_STATE *CallOutState
    );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyGetClientSessionAndResourceUUID)
        (
        __in void *Context,
        __out_opt int *SessionIdPresent,
        __out_opt UUID *SessionId,
        __out int *ResourceIdPresent,
        __out UUID *ResourceId
        );

#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyFilterIfFn) 
    (
    __in void *Context,
    __in UUID *IfUuid,
    __in unsigned short IfMajorVersion,
    __out int *fAllow
    );

typedef enum RpcProxyPerfCounters
{
    RpcCurrentUniqueUser = 1,    //Current Number of Unique Users
    RpcBackEndConnectionAttempts, // Number of Back-End Connection Attempts per Second
    RpcBackEndConnectionFailed, // Number of Failed Back-End Connection Attempts per Second
    RpcRequestsPerSecond, //RPC/HTTP Requests per Second
    RpcIncomingConnections, //Current Number of Incoming RPC over HTTP Connections
    RpcIncomingBandwidth, // Total Incoming Bandwidth from Back-End Servers
    RpcOutgoingBandwidth, // Total Outgoing Bandwidth to Back-End Servers
    RpcAttemptedLbsDecisions, // Attempted RPC Load Balancing Decisions per Second
    RpcFailedLbsDecisions, // Failed RPC Load Balancing Decisions per Second
    RpcAttemptedLbsMessages, //Attempted RPC Load Balancing Broker Requests per Second
    RpcFailedLbsMessages, // Failed RPC Load Balancing Broker Requests per Second
    RpcLastCounter 
} RpcPerfCounters;

typedef void
(RPC_ENTRY *I_RpcProxyUpdatePerfCounterFn)
    (
    __in RpcPerfCounters Counter,
    __in int ModifyTrend,
    __in unsigned long Size
    );

 typedef void
(RPC_ENTRY *I_RpcProxyUpdatePerfCounterBackendServerFn)
    (
    __in unsigned short* MachineName,
    __in int IsConnectEvent
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#define RPC_PROXY_CONNECTION_TYPE_IN_PROXY    0
#define RPC_PROXY_CONNECTION_TYPE_OUT_PROXY   1

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
typedef struct tagI_RpcProxyCallbackInterface
{
    I_RpcProxyIsValidMachineFn IsValidMachineFn;
    I_RpcProxyGetClientAddressFn GetClientAddressFn;
    I_RpcProxyGetConnectionTimeoutFn GetConnectionTimeoutFn;
    I_RpcPerformCalloutFn PerformCalloutFn;
    I_RpcFreeCalloutStateFn FreeCalloutStateFn;
    I_RpcProxyGetClientSessionAndResourceUUID GetClientSessionAndResourceUUIDFn;
#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
    I_RpcProxyFilterIfFn ProxyFilterIfFn;
    I_RpcProxyUpdatePerfCounterFn RpcProxyUpdatePerfCounterFn;
    I_RpcProxyUpdatePerfCounterBackendServerFn RpcProxyUpdatePerfCounterBackendServerFn;
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
} I_RpcProxyCallbackInterface;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcProxyNewConnection (
    IN unsigned long ConnectionType,
    IN unsigned short *ServerAddress,
    IN unsigned short *ServerPort,
    IN unsigned short *MinConnTimeout,
    IN void *ConnectionParameter,
    IN OPTIONAL RDR_CALLOUT_STATE *CallOutState, 
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface
    );
    
#else

typedef struct tagI_RpcProxyCallbackInterface
{
    I_RpcProxyIsValidMachineFn IsValidMachineFn;
    I_RpcProxyGetClientAddressFn GetClientAddressFn;
    I_RpcProxyGetConnectionTimeoutFn GetConnectionTimeoutFn;
} I_RpcProxyCallbackInterface;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcProxyNewConnection (
    IN unsigned long ConnectionType,
    IN unsigned short *ServerAddress,
    IN unsigned short *ServerPort,
    IN void *ConnectionParameter,
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
        
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReplyToClientWithStatus (
    IN void *ConnectionParameter,
    IN RPC_STATUS RpcStatus
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcRecordCalloutFailure (
    IN RPC_STATUS RpcStatus,
    IN RDR_CALLOUT_STATE *CallOutState,
    IN unsigned short *DllName
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCEP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcndr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

--*/

// This version of the rpcndr.h file corresponds to MIDL version 5.0.+
// used with Windows 2000/XP build 1700+


#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__        ( 500 )
#endif // __RPCNDR_H_VERSION__


#ifndef __RPCNDR_H__
#define __RPCNDR_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __REQUIRED_RPCNDR_H_VERSION__
    #if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
        #error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif


#include <pshpack8.h>
#include <basetsd.h>
#if !defined(_KRPCENV_)
#include <rpcnsip.h>
#endif

#include <rpcsal.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L
#define NDR_IBM_FLOAT                   (unsigned long)0X00000300L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif


/****************************************************************************
 *  Macros for targeted platforms
 ****************************************************************************/

#if defined (UNDER_CE)
#define _WIN32_DCOM	1
#endif

#if (0x600 <= _WIN32_WINNT)
#define TARGET_IS_NT60_OR_LATER                   1
#else
#define TARGET_IS_NT60_OR_LATER                   0
#endif

#if (0x501 <= _WIN32_WINNT)
#define TARGET_IS_NT51_OR_LATER                   1
#else
#define TARGET_IS_NT51_OR_LATER                   0
#endif

#if (0x500 <= _WIN32_WINNT) || defined(UNDER_CE)
#define TARGET_IS_NT50_OR_LATER                   1
#else
#define TARGET_IS_NT50_OR_LATER                   0
#endif

#if (defined(_WIN32_DCOM) || 0x400 <= _WIN32_WINNT)
#define TARGET_IS_NT40_OR_LATER                   1
#else
#define TARGET_IS_NT40_OR_LATER                   0
#endif

#if (0x400 <= WINVER)
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         1
#else
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         0
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef byte cs_byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef __RPC_WIN64__
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

__bcount_opt(size)
void  * __RPC_USER MIDL_user_allocate(size_t size);
void             __RPC_USER MIDL_user_free( __inout void  * );

__bcount_opt(size)
void * __RPC_USER I_RpcDefaultAllocate(
         handle_t bh, size_t size, void * (* RealAlloc)(size_t) );

void __RPC_USER I_RpcDefaultFree(
         handle_t bh, void *, void (*RealFree)(void *) );


#define RPC_VAR_ENTRY __cdecl


/* winnt only */
#if defined(_M_IX86) || defined(_M_AMD64) || defined(_M_IA64)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif




/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts.
 *
 ****************************************************************************/

typedef void  * NDR_CCONTEXT;

typedef struct
    {
    void  * pad[2];
    void  * userContext;
    }  * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER  * NDR_RUNDOWN)(void  * context);

typedef void (__RPC_USER  * NDR_NOTIFY_ROUTINE)(void);
typedef void (__RPC_USER  * NDR_NOTIFY2_ROUTINE)(boolean flag);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE,  * PSCONTEXT_QUEUE;

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT     CContext
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextMarshall (
    IN  NDR_CCONTEXT    CContext,
    OUT void  *pBuff
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall (
    __inout NDR_CCONTEXT        *   pCContext,
    __in  RPC_BINDING_HANDLE      hBinding,
    __in  void                *   pBuff,
    __in  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall2 (
    __inout NDR_CCONTEXT        *   pCContext,
    __in  RPC_BINDING_HANDLE      hBinding,
    __in  void                *   pBuff,
    __in  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall (
    IN  NDR_SCONTEXT    CContext,
    OUT void          * pBuff,
    IN  NDR_RUNDOWN     userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall (
    IN  void          * pBuff,
    IN  unsigned long   DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle,
    IN  NDR_SCONTEXT        CContext,
    OUT void              * pBuff,
    IN  NDR_RUNDOWN         userRunDownIn
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall2 (
    IN  RPC_BINDING_HANDLE  BindingHandle,
    IN  NDR_SCONTEXT        CContext,
    OUT void              * pBuff,
    IN  NDR_RUNDOWN         userRunDownIn,
    IN  void              * CtxGuard,
    IN unsigned long        Flags
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle,
    IN  void              * pBuff,
    IN  unsigned long       DataRepresentation
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall2(
    IN  RPC_BINDING_HANDLE  BindingHandle,
    IN  void              * pBuff,
    IN  unsigned long       DataRepresentation,
    IN  void              * CtxGuard,
    IN unsigned long        Flags
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDestroyClientContext (
    IN void  *  * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char  *  *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.

// RKK64
// these appear to be used in fossils inside MIDL
#define _midl_fa2( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+1) & ~0x1))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+3) & ~0x3))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+7) & ~0x7))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++)


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

// RKK64
// these appear to be used in fossils inside MIDL
#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))

#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))


#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)


// end of unused

#define NdrFieldOffset(s,f)     (LONG_PTR)(& (((s  *)0)->f))
#define NdrFieldPad(s,f,p,t)    ((unsigned long)(NdrFieldOffset(s,f) - NdrFieldOffset(s,p)) - sizeof(t))

#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)

//
// On the server side, the following exceptions are mapped to
// the bad stub data exception if -error stub_data is used.
//

#define RPC_BAD_STUB_DATA_EXCEPTION_FILTER  \
                 ( (RpcExceptionCode() == STATUS_ACCESS_VIOLATION)  || \
                   (RpcExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) || \
                   (RpcExceptionCode() == RPC_X_BAD_STUB_DATA) || \
                   (RpcExceptionCode() == RPC_S_INVALID_BOUND) )

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char  *    RPC_BUFPTR;
typedef unsigned long       RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER  * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE  * );

typedef const unsigned char  * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct
    {
    long              Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long  *  BufferConformanceMark;
    unsigned long  *  BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long  *  MaxCountArray;
    unsigned long  *  OffsetArray;
    unsigned long  *  ActualCountArray;
    } ARRAY_INFO,  *PARRAY_INFO;


typedef struct _NDR_ASYNC_MESSAGE *   PNDR_ASYNC_MESSAGE;
typedef struct _NDR_CORRELATION_INFO *PNDR_CORRELATION_INFO;

/*
 * MIDL Stub Message
 */

typedef const unsigned char  * PFORMAT_STRING;
typedef struct _MIDL_SYNTAX_INFO MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

struct NDR_ALLOC_ALL_NODES_CONTEXT;
struct NDR_POINTER_QUEUE_STATE;
struct _NDR_PROC_CONTEXT;

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE            RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char       *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char       *   BufferStart;
    unsigned char       *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char       *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long           BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long           MemorySize;

    /* Pointer to user memory. */
    unsigned char       *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    unsigned char           IsClient;
    unsigned char           Pad;
    unsigned short          uFlags2;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                     ReuseBuffer;

    /* Hold the context for allocate all nodes */
    struct NDR_ALLOC_ALL_NODES_CONTEXT *pAllocAllNodesContext;
    struct NDR_POINTER_QUEUE_STATE     *pPointerQueueState;

    /*
     * Stuff needed while handling complex structures
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                     IgnoreEmbeddedPointers;

    /*
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char       *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char           CorrDespIncrement;

    unsigned char           uFlags;
    unsigned short          UniquePtrCount;

    /*
     * Used internally by the Ndr routines.  Holds the max counts for
     * a conformant array.
     */
    ULONG_PTR               MaxCount;

    /*
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long           Offset;

    /*
     * Used internally by the Ndr routines.  Holds the actual counts for
     * a varying array.
     */
    unsigned long           ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void  *             ( __RPC_API * pfnAllocate)( size_t );
    void                    ( __RPC_API * pfnFree)(void  *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling
     * to hold the beginning of the parameter list on the stack.  Needed to
     * extract parameters which hold attribute values for top level arrays and
     * pointers.
     */
    unsigned char       *   StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char       *   pPresentedType;
    unsigned char       *   pTransmitType;

    /*
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC  * StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES  * FullPtrXlatTables;
    unsigned long                   FullPtrRefId;

    unsigned long                   PointerLength;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;
    int                             fHasExtensions    :1;
    int                             fHasNewCorrDesc   :1;
    int                             fIsIn             :1;
    int                             fIsOut            :1;
    int                             fIsOicf           :1;
    int                             fBufferValid      :1;
    int                             fHasMemoryValidateCallback: 1;
    int                             fInFree             :1;
    int                             fNeedMCCP         :1;
    int                             fUnused           :3;
    int                             fUnused2          :16;


    unsigned long                   dwDestContext;
    void  *                         pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer    *   pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;
    unsigned long           *       SizePtrCountArray;
    unsigned long           *       SizePtrOffsetArray;
    unsigned long           *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void                    *       pArgQueue;

    unsigned long                   dwStubPhase;

    void                    *       LowStackMark;

    /*
     *  Async message pointer, correlation data - NT 5.0 features.
     */
    PNDR_ASYNC_MESSAGE              pAsyncMsg;
    PNDR_CORRELATION_INFO           pCorrInfo;
    unsigned char *                 pCorrMemory;

    void *                          pMemoryList;

    /*
     *  Reserved fields up to this point present since the 3.50 release.
     *  Reserved fields below were introduced for Windows 2000 release.
     *  (but not used).
     */

    /*
     * International character support information - NT 5.1 feature.
     */
#if (NTDDI_VERSION >= NTDDI_WIN2K ) || defined(UNDER_CE)

    INT_PTR                         pCSInfo;

    unsigned char *                 ConformanceMark;
    unsigned char *                 VarianceMark;

#if defined(IA64)
    void                   *        BackingStoreLowMark;
#else
    INT_PTR                         Unused;
#endif

    struct _NDR_PROC_CONTEXT *      pContext;

    /*
     *  Reserved fields up to this point present since Windows 2000 release.
     *  Fields added for NT5.1
     *
     *  pUserMarshalList is used to keep a linked list of nodes pointing to 
     *  marshalled data to be freed.  This list can contain (as the name
     *  implies) User Marshalled data, but also can contain Interface Pointer
     *  data.   
     */

    void *                             ContextHandleHash;
    void *                             pUserMarshalList;
    INT_PTR                         Reserved51_3;
    INT_PTR                         Reserved51_4;
    INT_PTR                         Reserved51_5;


    /*
     *  Reserved fields up to this point present since NT5.1 release.
     */
#endif // (NTDDI_VERSION >= NTDDI_WIN2K ) || defined(UNDER_CE)
    } MIDL_STUB_MESSAGE,  *PMIDL_STUB_MESSAGE;


typedef  struct _MIDL_STUB_MESSAGE MIDL_STUB_MESSAGE,   *PMIDL_STUB_MESSAGE;

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void  *
        ( __RPC_API * GENERIC_BINDING_ROUTINE)
        (void  *);
typedef void
        ( __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void  *, unsigned char  *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR,  *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO
    {
    void  *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO,  *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above
// typedefs for xmit_as

#if (defined(_MSC_VER)) && !defined(MIDL_PASS)
// a Microsoft C++ compiler
#define NDR_SHAREABLE __inline
#else
#define NDR_SHAREABLE static
#endif


typedef void ( __RPC_USER * XMIT_HELPER_ROUTINE)
    ( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE,  *PXMIT_ROUTINE_QUINTUPLE;

typedef unsigned long
( __RPC_USER * USER_MARSHAL_SIZING_ROUTINE)
    (unsigned long  *,
     unsigned long,
     void  * );

typedef unsigned char  *
( __RPC_USER * USER_MARSHAL_MARSHALLING_ROUTINE)
    (unsigned long  *,
     unsigned char  * ,
     void  * );

typedef unsigned char  *
( __RPC_USER * USER_MARSHAL_UNMARSHALLING_ROUTINE)
    (unsigned long  *,
     unsigned char  *,
     void  * );

typedef void ( __RPC_USER * USER_MARSHAL_FREEING_ROUTINE)
    (unsigned long  *,
     void  * );

typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
    {
    USER_MARSHAL_SIZING_ROUTINE          pfnBufferSize;
    USER_MARSHAL_MARSHALLING_ROUTINE     pfnMarshall;
    USER_MARSHAL_UNMARSHALLING_ROUTINE   pfnUnmarshall;
    USER_MARSHAL_FREEING_ROUTINE         pfnFree;
    } USER_MARSHAL_ROUTINE_QUADRUPLE;

#define USER_MARSHAL_CB_SIGNATURE 'USRC'

typedef enum _USER_MARSHAL_CB_TYPE
{
    USER_MARSHAL_CB_BUFFER_SIZE,
    USER_MARSHAL_CB_MARSHALL,
    USER_MARSHAL_CB_UNMARSHALL,
    USER_MARSHAL_CB_FREE
} USER_MARSHAL_CB_TYPE;

typedef struct _USER_MARSHAL_CB
{
    unsigned long           Flags;
    PMIDL_STUB_MESSAGE      pStubMsg;
    PFORMAT_STRING          pReserve;
    unsigned long           Signature;
    USER_MARSHAL_CB_TYPE    CBType;
    PFORMAT_STRING          pFormat;
    PFORMAT_STRING          pTypeFormat;
} USER_MARSHAL_CB;


#define USER_CALL_CTXT_MASK(f)  ((f) & 0x00ff)
#define USER_CALL_AUX_MASK(f)   ((f) & 0xff00)
#define GET_USER_DATA_REP(f)    ((f) >> 16)

#define USER_CALL_IS_ASYNC              0x0100  /* aux flag: in an [async] call */
#define USER_CALL_NEW_CORRELATION_DESC  0x0200

typedef struct _MALLOC_FREE_STRUCT
    {
    void  *     ( __RPC_USER * pfnAllocate)(size_t);
    void        ( __RPC_USER * pfnFree)(void  *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * International character support definitions
 */

typedef enum _IDL_CS_CONVERT
    {
    IDL_CS_NO_CONVERT,
    IDL_CS_IN_PLACE_CONVERT,
    IDL_CS_NEW_BUFFER_CONVERT
    } IDL_CS_CONVERT;

typedef void
( __RPC_USER * CS_TYPE_NET_SIZE_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     unsigned long          ulLocalBufferSize,
     IDL_CS_CONVERT     *   conversionType,
     unsigned long      *   pulNetworkBufferSize,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_LOCAL_SIZE_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     unsigned long          ulNetworkBufferSize,
     IDL_CS_CONVERT     *   conversionType,
     unsigned long      *   pulLocalBufferSize,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_TO_NETCS_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     void               *   pLocalData,
     unsigned long          ulLocalDataLength,
     byte               *   pNetworkData,
     unsigned long      *   pulNetworkDataLength,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_FROM_NETCS_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     byte               *   pNetworkData,
     unsigned long          ulNetworkDataLength,
     unsigned long          ulLocalBufferSize,
     void               *   pLocalData,
     unsigned long      *   pulLocalDataLength,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TAG_GETTING_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     int                    fServerSide,
     unsigned long      *   pulSendingTag,
     unsigned long      *   pulDesiredReceivingTag,
     unsigned long      *   pulReceivingTag,
     error_status_t     *   pStatus);

void __RPC_USER
RpcCsGetTags(
     RPC_BINDING_HANDLE     hBinding,
     int                    fServerSide,
     unsigned long      *   pulSendingTag,
     unsigned long      *   pulDesiredReceivingTag,
     unsigned long      *   pulReceivingTag,
     error_status_t     *   pStatus);

typedef struct _NDR_CS_SIZE_CONVERT_ROUTINES
    {
    CS_TYPE_NET_SIZE_ROUTINE    pfnNetSize;
    CS_TYPE_TO_NETCS_ROUTINE    pfnToNetCs;
    CS_TYPE_LOCAL_SIZE_ROUTINE  pfnLocalSize;
    CS_TYPE_FROM_NETCS_ROUTINE  pfnFromNetCs;
    } NDR_CS_SIZE_CONVERT_ROUTINES;

typedef struct _NDR_CS_ROUTINES
    {
    NDR_CS_SIZE_CONVERT_ROUTINES   *pSizeConvertRoutines;
    CS_TAG_GETTING_ROUTINE         *pTagGettingRoutines;
    } NDR_CS_ROUTINES;

typedef struct _NDR_EXPR_DESC
{
    const unsigned short * pOffset;
    PFORMAT_STRING  pFormatExpr;
} NDR_EXPR_DESC;
/*
 * MIDL Stub Descriptor
 */

typedef struct _MIDL_STUB_DESC
    {
    void  *    RpcInterfaceInformation;

    void  *    ( __RPC_API * pfnAllocate)(size_t);
    void       ( __RPC_API * pfnFree)(void  *);

    union
        {
        handle_t  *             pAutoHandle;
        handle_t  *             pPrimitiveHandle;
        PGENERIC_BINDING_INFO   pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN  *                    apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR  *   aGenericBindingRoutinePairs;
    const EXPR_EVAL  *                      apfnExprEval;
    const XMIT_ROUTINE_QUINTUPLE  *         aXmitQuintuple;

    const unsigned char  *                  pFormatTypes;

    int                                     fCheckBounds;

    /* Ndr library version. */
    unsigned long                           Version;

    MALLOC_FREE_STRUCT  *                   pMallocFreeStruct;

    long                                    MIDLVersion;

    const COMM_FAULT_OFFSETS  *    CommFaultOffsets;

    // New fields for version 3.0+
    const USER_MARSHAL_ROUTINE_QUADRUPLE  * aUserMarshalQuadruple;

    // Notify routines - added for NT5, MIDL 5.0
    const NDR_NOTIFY_ROUTINE  *             NotifyRoutineTable;

    /*
     * Reserved for future use.
     */

    ULONG_PTR                               mFlags;

    // International support routines - added for 64bit post NT5
    const NDR_CS_ROUTINES *                 CsRoutineTables;

    void *                                  ProxyServerInfo;
    const NDR_EXPR_DESC *               pExprInfo;

    // Fields up to now present in win2000 release.

    } MIDL_STUB_DESC;


typedef const MIDL_STUB_DESC  * PMIDL_STUB_DESC;

typedef void  * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if defined(_MSC_EXTENSIONS)
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default:4200 )
#endif
#endif
#endif /* _MSC_EXTENSIONS */

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void ( __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

#ifndef _MANAGED
typedef long ( __RPC_API * SERVER_ROUTINE)();
#else
typedef long ( __RPC_API * SERVER_ROUTINE)(void);
#endif

/*
 * Server Interpreter's information strucuture.
 */
typedef struct  _MIDL_SERVER_INFO_
    {
    PMIDL_STUB_DESC                     pStubDesc;
    const SERVER_ROUTINE     *          DispatchTable;
    PFORMAT_STRING                      ProcString;
    const unsigned short *              FmtStringOffset;
    const STUB_THUNK *                  ThunkTable;
    PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
    ULONG_PTR                           nCount;
    PMIDL_SYNTAX_INFO                   pSyntaxInfo;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

#undef _MIDL_STUBLESS_PROXY_INFO

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short            *   FormatStringOffset;
    PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
    ULONG_PTR                           nCount;
    PMIDL_SYNTAX_INFO                   pSyntaxInfo;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO  * PMIDL_STUBLESS_PROXY_INFO;

/*
 *  Multiple transfer syntax information.
 */
typedef struct _MIDL_SYNTAX_INFO
{
RPC_SYNTAX_IDENTIFIER               TransferSyntax;
RPC_DISPATCH_TABLE *                DispatchTable;
PFORMAT_STRING                      ProcString;
const unsigned short *              FmtStringOffset;
PFORMAT_STRING                      TypeString;
const void           *              aUserMarshalQuadruple;
ULONG_PTR                           pReserved1;
ULONG_PTR                           pReserved2;
} MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

typedef unsigned short * PARAM_OFFSETTABLE, *PPARAM_OFFSETTABLE;

/*
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN
    {
    void  *         Pointer;
    LONG_PTR        Simple;
    } CLIENT_CALL_RETURN;

// BUGBUG: can we get rid of this defintion altogether, just leave void * here?
typedef enum
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

typedef struct _FULL_PTR_XLAT_TABLES
{
    void * RefIdToPointer;
    void * PointerToRefId;
    unsigned long           NextRefId;   
    XLAT_SIDE               XlatSide;
} FULL_PTR_XLAT_TABLES, *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

RPC_STATUS RPC_ENTRY
NdrClientGetSupportedSyntaxes(
    IN RPC_CLIENT_INTERFACE * pInf,
    OUT unsigned long       * pCount,
    OUT MIDL_SYNTAX_INFO   ** pArr );


RPC_STATUS RPC_ENTRY
NdrServerGetSupportedSyntaxes(
    IN RPC_SERVER_INTERFACE * pInf,
    OUT unsigned long       * pCount,
    OUT MIDL_SYNTAX_INFO   ** pArr,
    OUT unsigned long       * pPreferSyntaxIndex);

/*
 * Marshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    unsigned char           FormatChar
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrCsArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrCsTagMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrByteCountPointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrXmitOrRepAsMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrInterfacePointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_CCONTEXT            ContextHandle,
    int                     fCheck
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            ContextHandle,
    NDR_RUNDOWN             RundownRoutine
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextNewMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            ContextHandle,
    NDR_RUNDOWN             RundownRoutine,
    PFORMAT_STRING          pFormat
    );

/*
 * Unmarshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    unsigned char           FormatChar
    );

RPCRTAPI
unsigned char * RPC_ENTRY
RPC_ENTRY
NdrCsArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char * RPC_ENTRY
RPC_ENTRY
NdrCsTagUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char * RPC_ENTRY
NdrRangeUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationInitialize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    void  *                 pMemory,
    unsigned long           CacheSize,
    unsigned long           flags
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationPass(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationFree(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Structures */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Arrays */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Strings */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Unions */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Byte count pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrByteCountPointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrXmitOrRepAsUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* User_marshal */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Interface pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrInterfacePointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_CCONTEXT        *   pContextHandle,
    RPC_BINDING_HANDLE      BindHandle
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

/* New context handle flavors */

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrContextHandleInitialize(
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PFORMAT_STRING      pFormat
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextNewUnmarshall(
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PFORMAT_STRING      pFormat
    );

/*
 * Buffer sizing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsTagBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
void
RPC_ENTRY
NdrConformantStringBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonConformantStringBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count pointer */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

// Context Handle size
//
RPCRTAPI
void
RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/*
 * Memory sizing routines
 */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrContextHandleMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );


/* cs_char things */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrCsArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrCsTagMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned long
RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/*
 * Freeing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/*
 * Endian conversion routine.
 */

RPCRTAPI
void
RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    long                    NumberParams
    );

RPCRTAPI
void
RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

#define USER_MARSHAL_FC_BYTE         1
#define USER_MARSHAL_FC_CHAR         2
#define USER_MARSHAL_FC_SMALL        3
#define USER_MARSHAL_FC_USMALL       4
#define USER_MARSHAL_FC_WCHAR        5
#define USER_MARSHAL_FC_SHORT        6
#define USER_MARSHAL_FC_USHORT       7
#define USER_MARSHAL_FC_LONG         8
#define USER_MARSHAL_FC_ULONG        9
#define USER_MARSHAL_FC_FLOAT       10
#define USER_MARSHAL_FC_HYPER       11
#define USER_MARSHAL_FC_DOUBLE      12

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalSimpleTypeConvert(
    unsigned long *         pFlags,
    unsigned char *         pBuffer,
    unsigned char           FormatChar
    );

/*
 * Auxilary routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializePartial(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned long           RequestedBufferSize
    );

RPCRTAPI
void
RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    PRPC_MESSAGE            pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNsGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char *         pBufferEnd
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pBufferEnd,
    RPC_BINDING_HANDLE  *   pAutoHandle
    );

RPCRTAPI
void
RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrGetDcomProtocolVersion(
    PMIDL_STUB_MESSAGE      pStubMsg,
    RPC_VERSION *           pVersion );


/*
 * Interpreter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );


CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrAsyncClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrDcomAsyncClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;

struct IRpcStubBuffer;      // Forward declaration

// Raw RPC only
RPCRTAPI
void
RPC_ENTRY
NdrAsyncServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

// old dcom async scheme
RPCRTAPI
long
RPC_ENTRY
NdrAsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long *             pdwStubPhase
    );

// async uuid
RPCRTAPI
long
RPC_ENTRY
NdrDcomAsyncStubCall(
    struct IRpcStubBuffer    *  pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long            *  pdwStubPhase
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall2(
    void  *    pThis, // struct IRpcStubBuffer
    void  * pChannel, // struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall (
    void  *    pThis, // struct IRpcStubBuffer
    void  * pChannel, // struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
int
RPC_ENTRY
NdrServerUnmarshall(
    void  * pChannel, // Converted to struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    PMIDL_STUB_MESSAGE          pStubMsg,
    PMIDL_STUB_DESC             pStubDescriptor,
    PFORMAT_STRING              pFormat,
    void  *                     pParamList
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerMarshall(
    void  *    pThis, //Converted to struct IRpcStubBuffer
    void  * pChannel, // Converted to struct IRpcChannelBuffer
    PMIDL_STUB_MESSAGE          pStubMsg,
    PFORMAT_STRING              pFormat
    );

/* Comm and Fault status */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned long  *            pCommStatus,
    unsigned long  *            pFaultStatus,
    RPC_STATUS                  Status
    );



/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void  * RPC_SS_THREAD_HANDLE;

typedef void  * __RPC_API
RPC_CLIENT_ALLOC (
    IN size_t Size
    );

typedef void __RPC_API
RPC_CLIENT_FREE (
    IN void  * Ptr
    );

/*++
     RpcSs* package
--*/

RPCRTAPI
void  *
RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsFree (
    IN void  * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC  * ClientAlloc,
    IN RPC_CLIENT_FREE   * ClientFree
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC     * ClientAlloc,
    IN RPC_CLIENT_FREE      * ClientFree,
    OUT RPC_CLIENT_ALLOC *  * OldClientAlloc,
    OUT RPC_CLIENT_FREE  *  * OldClientFree
    );

/*++
     RpcSm* package
--*/

RPCRTAPI
void  *
RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS  *   pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmClientFree (
    IN  void        *   pNodeToFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDestroyClientContext (
    IN void         * * ContextHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmFree (
    IN void         *   NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS  *   pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC * ClientAlloc,
    IN RPC_CLIENT_FREE  * ClientFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC     *   ClientAlloc,
    IN RPC_CLIENT_FREE      *   ClientFree,
    OUT RPC_CLIENT_ALLOC    * * OldClientAlloc,
    OUT RPC_CLIENT_FREE     * * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void  *
RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmClientFree (
    IN void  * NodeToFree
    );

RPCRTAPI
void  *
RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void  * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

RPCRTAPI
PFULL_PTR_XLAT_TABLES
RPC_ENTRY
NdrFullPointerXlatInit(
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerXlatFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );


RPCRTAPI
void  *
RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len
    );

RPCRTAPI
void
RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void  *                 ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

RPCRTAPI
void  *
RPC_ENTRY
NdrOleAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrOleFree (
    IN void  * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif

/****************************************************************************
 * VC COM support 
 ****************************************************************************/

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef UNDER_CE
#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_UUID(x) __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#define MIDL_INTERFACE(x)   struct DECLSPEC_UUID(x) DECLSPEC_NOVTABLE
#else // UNDER_CE
// WinCE has some legacy pieces that redefine MIDL_INTERFACE to be the NT4
// era style definition.  Even though it works out to same as new defn,
// compiler throws error since it's not perfect match.

#if (_MSC_VER >= 1100)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#define MIDL_INTERFACE(x)   struct __declspec(uuid(x)) __declspec(novtable)
#else
#define DECLSPEC_UUID(x)
#define MIDL_INTERFACE(x)   struct
#endif

#endif // UNDER_CE

#if _MSC_VER >= 1100
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
  EXTERN_C const IID DECLSPEC_SELECTANY itf = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}
#else
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) EXTERN_C const IID itf
#endif

/****************************************************************************
 * UserMarshal information
 ****************************************************************************/

typedef struct _NDR_USER_MARSHAL_INFO_LEVEL1
{
    void *                      Buffer;
    unsigned long               BufferSize;
    void *(__RPC_API * pfnAllocate)(size_t);
    void (__RPC_API * pfnFree)(void *);
    struct IRpcChannelBuffer *  pRpcChannelBuffer;
    ULONG_PTR                   Reserved[5];
} NDR_USER_MARSHAL_INFO_LEVEL1;

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif

typedef struct _NDR_USER_MARSHAL_INFO
{
    unsigned long InformationLevel;
    union {
        NDR_USER_MARSHAL_INFO_LEVEL1 Level1;
#if !defined(UNDER_CE)
    } DUMMYUNIONNAME;
#else
	// Dummy union name not needed on CE, since CE compiler supports nameless union.
    };
#endif
} NDR_USER_MARSHAL_INFO;

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif

RPC_STATUS
RPC_ENTRY
NdrGetUserMarshalInfo (
    IN unsigned long        *   pFlags,
    IN unsigned long            InformationLevel,
    OUT NDR_USER_MARSHAL_INFO * pMarshalInfo
    );

/****************************************************************************
 * 64bit APIs
 ****************************************************************************/
RPC_STATUS RPC_ENTRY
NdrCreateServerInterfaceFromStub(
            IN struct IRpcStubBuffer* pStub,
            IN OUT RPC_SERVER_INTERFACE *pServerIf );

/*
 * Interpreter calls
 */
CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall3(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64AsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64DcomAsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

struct IRpcStubBuffer;      // Forward declaration

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall64(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCallAll(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
Ndr64AsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long *             pdwStubPhase
    );

/* async uuid */
RPCRTAPI
long
RPC_ENTRY
Ndr64DcomAsyncStubCall(
    struct IRpcStubBuffer    *  pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long            *  pdwStubPhase
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall3 (
    void  *    pThis, // struct IRpcStubBuffer
    void  * pChannel, // struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCallAll(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCallNdr64(
    PRPC_MESSAGE                pRpcMsg
    );


RPCRTAPI
void
RPC_ENTRY
NdrServerCall3(
    PRPC_MESSAGE                pRpcMsg
    );


/* [partial_ignore] functions*/
RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreClientMarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void *                      pMemory
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreServerUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void **                     ppMemory
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreClientBufferSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void *                      pMemory
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreServerInitialize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void **                     ppMemory,
    PFORMAT_STRING              pFormat
    );


void RPC_ENTRY
RpcUserFree( handle_t AsyncHandle, void * pBuffer );

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif /* __RPCNDR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcdce.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/

#pragma once

#ifndef __RPCDCE_H__
#define __RPCDCE_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

#include <specstrings.h>

typedef __nullterminated unsigned char __RPC_FAR * RPC_CSTR;
#if defined(RPC_USE_NATIVE_WCHAR) && defined(_NATIVE_WCHAR_T_DEFINED)
typedef __nullterminated wchar_t __RPC_FAR * RPC_WSTR;
#else
typedef __nullterminated unsigned short __RPC_FAR * RPC_WSTR;
#endif

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
#define rpc_binding_handle_t RPC_BINDING_HANDLE

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#ifndef UUID_DEFINED
#define UUID_DEFINED
typedef GUID UUID;
#ifndef uuid_t
#define uuid_t UUID
#endif
#endif

typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
#ifndef rpc_binding_vector_t
#define rpc_binding_vector_t RPC_BINDING_VECTOR
#endif

typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;
#ifndef uuid_vector_t
#define uuid_vector_t UUID_VECTOR
#endif

typedef void __RPC_FAR * RPC_IF_HANDLE;

#ifndef IFID_DEFINED
#define IFID_DEFINED
typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;
#endif

#define RPC_C_BINDING_INFINITE_TIMEOUT 10
#define RPC_C_BINDING_MIN_TIMEOUT 0
#define RPC_C_BINDING_DEFAULT_TIMEOUT 5
#define RPC_C_BINDING_MAX_TIMEOUT 9

#define RPC_C_CANCEL_INFINITE_TIMEOUT -1

#define RPC_C_LISTEN_MAX_CALLS_DEFAULT 1234
#define RPC_C_PROTSEQ_MAX_REQS_DEFAULT 10

// RPC_POLICY EndpointFlags.
#define RPC_C_BIND_TO_ALL_NICS          1
#define RPC_C_USE_INTERNET_PORT         0x1
#define RPC_C_USE_INTRANET_PORT         0x2
#define RPC_C_DONT_FAIL                 0x4
#define RPC_C_RPCHTTP_USE_LOAD_BALANCE  0x8

#if (NTDDI_VERSION < NTDDI_VISTA) && !defined(UNDER_CE)
// RPC_POLICY EndpointFlags specific to the Falcon/RPC transport (deprecated for LONGHORN)
#define RPC_C_MQ_TEMPORARY                  0x0000
#define RPC_C_MQ_PERMANENT                  0x0001
#define RPC_C_MQ_CLEAR_ON_OPEN              0x0002
#define RPC_C_MQ_USE_EXISTING_SECURITY      0x0004
#define RPC_C_MQ_AUTHN_LEVEL_NONE           0x0000
#define RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY  0x0008
#define RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY    0x0010

// Falcon/Rpc options are deprecated from LONGHORN
#define RPC_C_MQ_EXPRESS                0  // Client: RPC_C_MQ_DELIVERY.
#define RPC_C_MQ_RECOVERABLE            1

#define RPC_C_MQ_JOURNAL_NONE           0  // Client: RPC_C_MQ_JOURNAL.
#define RPC_C_MQ_JOURNAL_DEADLETTER     1
#define RPC_C_MQ_JOURNAL_ALWAYS         2

// Client: RpcBindingSetOption() values for the Falcon/RPC transport (some are deprecated from LONGHORN)

#define RPC_C_OPT_MQ_DELIVERY            1
#define RPC_C_OPT_MQ_PRIORITY            2
#define RPC_C_OPT_MQ_JOURNAL             3
#define RPC_C_OPT_MQ_ACKNOWLEDGE         4
#define RPC_C_OPT_MQ_AUTHN_SERVICE       5
#define RPC_C_OPT_MQ_AUTHN_LEVEL         6
#define RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE 7
#define RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED 8
#endif // (NTDDI_VERSION < NTDDI_VISTA) && !defined(UNDER_CE)

#define RPC_C_OPT_BINDING_NONCAUSAL      9
#define RPC_C_OPT_SECURITY_CALLBACK      10
#define RPC_C_OPT_UNIQUE_BINDING         11

#if (NTDDI_VERSION <= NTDDI_WIN2K) && !defined(UNDER_CE)
#define RPC_C_OPT_MAX_OPTIONS            12

#elif (NTDDI_VERSION <= NTDDI_WS03) && !defined(UNDER_CE)
#define RPC_C_OPT_CALL_TIMEOUT           12
#define RPC_C_OPT_DONT_LINGER            13
#define RPC_C_OPT_MAX_OPTIONS            14

#else
#define RPC_C_OPT_TRANS_SEND_BUFFER_SIZE 5
#define RPC_C_OPT_CALL_TIMEOUT           12
#define RPC_C_OPT_DONT_LINGER            13
#define RPC_C_OPT_TRUST_PEER             14
#define RPC_C_OPT_ASYNC_BLOCK            15
#define RPC_C_OPT_OPTIMIZE_TIME          16
#define RPC_C_OPT_MAX_OPTIONS            17

#endif // (NTDDI_VERSION <= NTDDI_WIN2K) && !defined(UNDER_CE)

// flags for RpcServerInqAuthClientEx
//
#define RPC_C_FULL_CERT_CHAIN 0x0001



#ifdef RPC_UNICODE_SUPPORTED
typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORW;

#ifdef UNICODE
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORW
#else /* UNICODE */
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

typedef struct _RPC_PROTSEQ_VECTOR
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTOR;

#endif /* RPC_UNICODE_SUPPORTED */
typedef struct _RPC_POLICY {
    unsigned int Length ;
    unsigned long EndpointFlags ;
    unsigned long NICFlags ;
    } RPC_POLICY,  __RPC_FAR *PRPC_POLICY ;

typedef void __RPC_USER
RPC_OBJECT_INQ_FN (
    __in UUID __RPC_FAR * ObjectUuid,
    __out UUID __RPC_FAR * TypeUuid,
    __out RPC_STATUS __RPC_FAR * Status
    );

__success(return == 0) /*RPC_S_OK*/
typedef RPC_STATUS RPC_ENTRY
RPC_IF_CALLBACK_FN (
    __in RPC_IF_HANDLE  InterfaceUuid,
    __in void *Context
    ) ;

typedef void RPC_ENTRY
RPC_SECURITY_CALLBACK_FN (
    __in void *Context
    ) ;

#define RPC_MGR_EPV void

typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;

#define RPC_C_STATS_CALLS_IN 0
#define RPC_C_STATS_CALLS_OUT 1
#define RPC_C_STATS_PKTS_IN 2
#define RPC_C_STATS_PKTS_OUT 3

typedef struct
{
  unsigned long Count;
  RPC_IF_ID __RPC_FAR * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCopy (
    __in RPC_BINDING_HANDLE SourceBinding,
    __out RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFree (
    __in OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetOption ( 
    __in RPC_BINDING_HANDLE hBinding,
    __in unsigned long      option,
    __in ULONG_PTR          optionValue 
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqOption (
    __in  RPC_BINDING_HANDLE hBinding,
    __in  unsigned long      option,
    __out ULONG_PTR         *pOptionValue 
    );

/* client */

#if !defined(_KRPCENV_) || defined(UNDER_CE)

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingA (    
    __in RPC_CSTR StringBinding,
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingW (
    __in RPC_WSTR StringBinding,        
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#ifdef UNICODE
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW
#else /* UNICODE */
#define RpcBindingFromStringBinding RpcBindingFromStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBinding (
    __in RPC_CSTR StringBinding    
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#endif /* RPC_UNICODE_SUPPORTED */

#endif /* _KRPCENV_ || UNDER_CE */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsGetContextBinding (
    __in void *ContextHandle,
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqObject (
    __in RPC_BINDING_HANDLE Binding,
    __out UUID __RPC_FAR * ObjectUuid
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingReset (
    __in RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetObject (
    __in RPC_BINDING_HANDLE Binding,
    __in UUID __RPC_FAR * ObjectUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqDefaultProtectLevel (
    __in  unsigned long AuthnSvc,
    __in unsigned long __RPC_FAR *AuthnLevel
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out RPC_CSTR __RPC_FAR * StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out RPC_WSTR __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcBindingToStringBinding RpcBindingToStringBindingW
#else /* UNICODE */
#define RpcBindingToStringBinding RpcBindingToStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBinding (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out RPC_CSTR __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingVectorFree (
    __deref_inout RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* client/server */

#if !defined(_KRPCENV_) || defined(UNDER_CE)

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeA (
    __in_opt RPC_CSTR ObjUuid,
    __in_opt RPC_CSTR ProtSeq,    
    __in_opt RPC_CSTR NetworkAddr,
    __in_opt RPC_CSTR Endpoint,
    __in_opt RPC_CSTR Options,
    __deref_opt_out RPC_CSTR __RPC_FAR * StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeW (
    __in_opt RPC_WSTR ObjUuid,
    __in_opt RPC_WSTR ProtSeq,    
    __in_opt RPC_WSTR NetworkAddr,
    __in_opt RPC_WSTR Endpoint,
    __in_opt RPC_WSTR Options,
    __deref_opt_out RPC_WSTR __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcStringBindingCompose RpcStringBindingComposeW
#else /* UNICODE */
#define RpcStringBindingCompose RpcStringBindingComposeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingCompose (
    __in_opt RPC_CSTR ObjUuid,
    __in_opt RPC_CSTR ProtSeq,    
    __in_opt RPC_CSTR NetworkAddr,
    __in_opt RPC_CSTR Endpoint,
    __in_opt RPC_CSTR Options,
    __deref_opt_out RPC_CSTR __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseA (
    __in RPC_CSTR StringBinding,    
    __deref_opt_out RPC_CSTR __RPC_FAR * ObjUuid,
    __deref_opt_out RPC_CSTR __RPC_FAR * Protseq,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkAddr,
    __deref_opt_out RPC_CSTR __RPC_FAR * Endpoint,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkOptions
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseW (
    __in RPC_WSTR StringBinding,    
    __deref_opt_out RPC_WSTR __RPC_FAR * ObjUuid,
    __deref_opt_out RPC_WSTR __RPC_FAR * Protseq,
    __deref_opt_out RPC_WSTR __RPC_FAR * NetworkAddr,
    __deref_opt_out RPC_WSTR __RPC_FAR * Endpoint,
    __deref_opt_out RPC_WSTR __RPC_FAR * NetworkOptions
    );

#ifdef UNICODE
#define RpcStringBindingParse RpcStringBindingParseW
#else /* UNICODE */
#define RpcStringBindingParse RpcStringBindingParseA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParse (
    __in RPC_CSTR StringBinding,    
    __deref_opt_out RPC_CSTR __RPC_FAR * ObjUuid,
    __deref_opt_out RPC_CSTR __RPC_FAR * Protseq,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkAddr,
    __deref_opt_out RPC_CSTR __RPC_FAR * Endpoint,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkOptions
    );

#endif /* RPC_UNICODE_SUPPORTED */

#endif /* _KRPCENV_  || UNDER_CE */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeA (
    __inout RPC_CSTR __RPC_FAR * String    
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeW (
    __inout RPC_WSTR __RPC_FAR * String
    );

#ifdef UNICODE
#define RpcStringFree RpcStringFreeW
#else /* UNICODE */
#define RpcStringFree RpcStringFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFree (
    __deref_inout RPC_CSTR __RPC_FAR * String
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfInqId (
    __in RPC_IF_HANDLE RpcIfHandle,
    __out RPC_IF_ID __RPC_FAR * RpcIfId
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidA (
    __in RPC_CSTR Protseq     
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidW (
    __in RPC_WSTR Protseq
    );

#ifdef UNICODE
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW
#else /* UNICODE */
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValid (
    __in RPC_CSTR Protseq
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqComTimeout (
    __in RPC_BINDING_HANDLE Binding,
    __out unsigned int __RPC_FAR * Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetComTimeout (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned int Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetCancelTimeout(
    __in long Timeout
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsA (
    __deref_out RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector    
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsW (
    __deref_out RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector    
    );

#ifdef UNICODE
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsW
#else /* UNICODE */
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqs (
    __deref_out RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectInqType (
    __in UUID __RPC_FAR * ObjUuid,
    __out_opt OPTIONAL UUID __RPC_FAR * TypeUuid
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetInqFn (
    __in RPC_OBJECT_INQ_FN __RPC_FAR * InquiryFn
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetType (
    __in UUID __RPC_FAR * ObjUuid,
    __in_opt OPTIONAL UUID __RPC_FAR * TypeUuid
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeA (
    __deref_inout RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeW (
    __deref_inout RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcProtseqVectorFree RpcProtseqVectorFreeW
#else /* UNICODE */
#define RpcProtseqVectorFree RpcProtseqVectorFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFree (
    __deref_inout RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqBindings (
    __deref_out RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqIf (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __deref_out RPC_MGR_EPV __RPC_FAR * __RPC_FAR * MgrEpv
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerListen (
    __in unsigned int MinimumCallThreads,
    __in unsigned int MaxCalls,
    __in unsigned int DontWait
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in_opt RPC_MGR_EPV __RPC_FAR * MgrEpv
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIfEx (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in_opt RPC_MGR_EPV __RPC_FAR * MgrEpv,
    __in unsigned int Flags,
    __in unsigned int MaxCalls,
    __in_opt RPC_IF_CALLBACK_FN __RPC_FAR *IfCallback
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf2 (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID * MgrTypeUuid,
    __in_opt RPC_MGR_EPV * MgrEpv,
    __in unsigned int Flags,
    __in unsigned int MaxCalls,
    __in unsigned int MaxRpcSize,
    __in_opt RPC_IF_CALLBACK_FN *IfCallbackFn
    );


/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIf (
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in unsigned int WaitForCallsToComplete
    );

#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)
/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIfEx (
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in int RundownContextHandles
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqs (
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsEx (
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIf (
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIfEx (
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseq RpcServerUseProtseqW
#define RpcServerUseProtseqEx RpcServerUseProtseqExW
#else /* UNICODE */
#define RpcServerUseProtseq RpcServerUseProtseqA
#define RpcServerUseProtseqEx RpcServerUseProtseqExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseq (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEx (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExW
#else /* UNICODE */
#define RpcServerUseProtseqEp RpcServerUseProtseqEpA
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEp (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpEx (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqIf RpcServerUseProtseqIfW
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExW
#else /* UNICODE */
#define RpcServerUseProtseqIf RpcServerUseProtseqIfA
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIf (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfEx (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
void
RPC_ENTRY
RpcServerYield (
    void
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStatsVectorFree (
    __inout RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqStats (
    __in_opt RPC_BINDING_HANDLE Binding,
    __deref_out RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtIsServerListening (
    __in_opt RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStopServerListening (
    __in_opt RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetServerStackSize (
    __in unsigned long ThreadStackSize
    );

/* server */
RPCRTAPI
void
RPC_ENTRY
RpcSsDontSerializeContext (
    void
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqIfIds (
    __in_opt RPC_BINDING_HANDLE Binding,
    __deref_out RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfIdVectorFree (
    __deref_inout RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameA (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in unsigned long AuthnSvc,
    __deref_out RPC_CSTR __RPC_FAR * ServerPrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameW (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * ServerPrincName
    );

#ifdef UNICODE
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameW
#else /* UNICODE */
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincName (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * ServerPrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameA (
    __in unsigned long AuthnSvc,
    __deref_out RPC_CSTR __RPC_FAR * PrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameW (
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * PrincName
    );

#ifdef UNICODE
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameW
#else /* UNICODE */
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincName (
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * PrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpResolveBinding (
    __in RPC_BINDING_HANDLE Binding,
    __in RPC_IF_HANDLE IfSpec
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameA (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __deref_out RPC_CSTR __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameW (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __deref_out RPC_WSTR __RPC_FAR * EntryName
    );

#ifdef UNICODE
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameW
#else /* UNICODE */
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryName (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __deref_out RPC_CSTR __RPC_FAR * EntryName
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_FAR * RPC_AUTH_IDENTITY_HANDLE;
typedef void __RPC_FAR * RPC_AUTHZ_HANDLE;

#define RPC_C_AUTHN_LEVEL_DEFAULT       0
#define RPC_C_AUTHN_LEVEL_NONE          1
#define RPC_C_AUTHN_LEVEL_CONNECT       2
#define RPC_C_AUTHN_LEVEL_CALL          3
#define RPC_C_AUTHN_LEVEL_PKT           4
#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6

#define RPC_C_IMP_LEVEL_DEFAULT      0
#define RPC_C_IMP_LEVEL_ANONYMOUS    1
#define RPC_C_IMP_LEVEL_IDENTIFY     2
#define RPC_C_IMP_LEVEL_IMPERSONATE  3
#define RPC_C_IMP_LEVEL_DELEGATE     4

#define RPC_C_QOS_IDENTITY_STATIC    0
#define RPC_C_QOS_IDENTITY_DYNAMIC   1

#define RPC_C_QOS_CAPABILITIES_DEFAULT                        0x0
#define RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH                    0x1
#define RPC_C_QOS_CAPABILITIES_MAKE_FULLSIC                   0x2
#define RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY                  0x4

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
#define RPC_C_QOS_CAPABILITIES_IGNORE_DELEGATE_FAILURE        0x8
#define RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT                 0x10
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPC_C_QOS_CAPABILITIES_SCHANNEL_FULL_AUTH_IDENTITY   0x20
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#define RPC_C_PROTECT_LEVEL_DEFAULT       (RPC_C_AUTHN_LEVEL_DEFAULT)
#define RPC_C_PROTECT_LEVEL_NONE          (RPC_C_AUTHN_LEVEL_NONE)
#define RPC_C_PROTECT_LEVEL_CONNECT       (RPC_C_AUTHN_LEVEL_CONNECT)
#define RPC_C_PROTECT_LEVEL_CALL          (RPC_C_AUTHN_LEVEL_CALL)
#define RPC_C_PROTECT_LEVEL_PKT           (RPC_C_AUTHN_LEVEL_PKT)
#define RPC_C_PROTECT_LEVEL_PKT_INTEGRITY (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
#define RPC_C_PROTECT_LEVEL_PKT_PRIVACY   (RPC_C_AUTHN_LEVEL_PKT_PRIVACY)

#define RPC_C_AUTHN_NONE          0
#define RPC_C_AUTHN_DCE_PRIVATE   1
#define RPC_C_AUTHN_DCE_PUBLIC    2
#define RPC_C_AUTHN_DEC_PUBLIC    4
#define RPC_C_AUTHN_GSS_NEGOTIATE 9
#define RPC_C_AUTHN_WINNT        10
#define RPC_C_AUTHN_GSS_SCHANNEL 14
#define RPC_C_AUTHN_GSS_KERBEROS 16
#define RPC_C_AUTHN_DPA          17
#define RPC_C_AUTHN_MSN          18
#if (NTDDI_VERSION >= WINXP) || defined(UNDER_CE)
#define RPC_C_AUTHN_DIGEST       21
#endif // (NTDDI_VERSION >= WINXP) || defined(UNDER_CE)
#define RPC_C_AUTHN_MQ          100
#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL

#define RPC_C_NO_CREDENTIALS ((RPC_AUTH_IDENTITY_HANDLE) MAXUINT_PTR)

#define RPC_C_SECURITY_QOS_VERSION      1L
#define RPC_C_SECURITY_QOS_VERSION_1    1L

typedef struct _RPC_SECURITY_QOS {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
} RPC_SECURITY_QOS, *PRPC_SECURITY_QOS;

#ifndef _AUTH_IDENTITY_DEFINED
#define _AUTH_IDENTITY_DEFINED

#define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  __field_bcount((UserLength+1)*sizeof(WCHAR)) unsigned short __RPC_FAR *User;
  unsigned long UserLength;
  __field_bcount((DomainLength+1)*sizeof(WCHAR)) unsigned short __RPC_FAR *Domain;
  unsigned long DomainLength;
  __field_bcount((PasswordLength+1)*sizeof(WCHAR)) unsigned short __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define _AUTH_IDENTITY_A_DEFINED
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  __field_ecount(UserLength+1) unsigned char __RPC_FAR *User;
  unsigned long UserLength;
  __field_ecount(DomainLength+1) unsigned char __RPC_FAR *Domain;
  unsigned long DomainLength;
  __field_ecount(PasswordLength+1) unsigned char __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;

#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W
#else // UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE

#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)

#define RPC_C_SECURITY_QOS_VERSION_2 2L

#define RPC_C_AUTHN_INFO_TYPE_HTTP                  1

#define RPC_C_HTTP_AUTHN_TARGET_SERVER              1
#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPC_C_HTTP_AUTHN_TARGET_PROXY               2
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#define RPC_C_HTTP_AUTHN_SCHEME_BASIC      0x00000001
#define RPC_C_HTTP_AUTHN_SCHEME_NTLM       0x00000002
#define RPC_C_HTTP_AUTHN_SCHEME_PASSPORT   0x00000004
#define RPC_C_HTTP_AUTHN_SCHEME_DIGEST     0x00000008
#define RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE  0x00000010
#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
#define RPC_C_HTTP_AUTHN_SCHEME_CERT       0x00010000
// 0x00020000 & 0x00040000 are reserved
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#define RPC_C_HTTP_FLAG_USE_SSL                     1
#define RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME       2
#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
#define RPC_C_HTTP_FLAG_IGNORE_CERT_CN_INVALID      8
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
#if (NTDDI_VERSION >= NTDDI_VISTASP1) || defined(UNDER_CE)
#define RPC_C_HTTP_FLAG_ENABLE_CERT_REVOCATION_CHECK 16
#endif // (NTDDI_VERSION >= NTDDI_VISTASP1) || defined(UNDER_CE)


typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_W
{
    SEC_WINNT_AUTH_IDENTITY_W *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned short __RPC_FAR *ServerCertificateSubject;
} RPC_HTTP_TRANSPORT_CREDENTIALS_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_W;

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_A
{
    SEC_WINNT_AUTH_IDENTITY_A *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned char __RPC_FAR *ServerCertificateSubject;
} RPC_HTTP_TRANSPORT_CREDENTIALS_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_A;

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
{
    SEC_WINNT_AUTH_IDENTITY_W *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    __field_ecount(NumberOfAuthnSchemes) unsigned long *AuthnSchemes;
    unsigned short __RPC_FAR *ServerCertificateSubject;
    SEC_WINNT_AUTH_IDENTITY_W *ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    __field_ecount(NumberOfProxyAuthnSchemes) unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
{
    SEC_WINNT_AUTH_IDENTITY_A *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned char __RPC_FAR *ServerCertificateSubject;
    SEC_WINNT_AUTH_IDENTITY_A *ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;

#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

typedef struct _RPC_SECURITY_QOS_V2_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
} RPC_SECURITY_QOS_V2_W, *PRPC_SECURITY_QOS_V2_W;

typedef struct _RPC_SECURITY_QOS_V2_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
} RPC_SECURITY_QOS_V2_A, *PRPC_SECURITY_QOS_V2_A;

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
#define RPC_C_SECURITY_QOS_VERSION_3 3L

typedef struct _RPC_SECURITY_QOS_V3_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
  void *Sid;
} RPC_SECURITY_QOS_V3_W, *PRPC_SECURITY_QOS_V3_W;

typedef struct _RPC_SECURITY_QOS_V3_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
  void *Sid;
} RPC_SECURITY_QOS_V3_A, *PRPC_SECURITY_QOS_V3_A;
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#define RPC_C_SECURITY_QOS_VERSION_4 4L

typedef struct _RPC_SECURITY_QOS_V4_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
  void *Sid;
  unsigned int EffectiveOnly;
} RPC_SECURITY_QOS_V4_W, *PRPC_SECURITY_QOS_V4_W;

typedef struct _RPC_SECURITY_QOS_V4_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
  void *Sid;
  unsigned int EffectiveOnly;
} RPC_SECURITY_QOS_V4_A, *PRPC_SECURITY_QOS_V4_A;

#endif // NTDDI_WINXP
#endif // _AUTH_IDENTITY_DEFINED 
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#if (NTDDI_VERSION >= WINXP) || defined(UNDER_CE)
#ifdef UNICODE

#define RPC_SECURITY_QOS_V2 RPC_SECURITY_QOS_V2_W
#define PRPC_SECURITY_QOS_V2 PRPC_SECURITY_QOS_V2_W
#define _RPC_SECURITY_QOS_V2 _RPC_SECURITY_QOS_V2_W

#define RPC_HTTP_TRANSPORT_CREDENTIALS RPC_HTTP_TRANSPORT_CREDENTIALS_W
#define PRPC_HTTP_TRANSPORT_CREDENTIALS PRPC_HTTP_TRANSPORT_CREDENTIALS_W
#define _RPC_HTTP_TRANSPORT_CREDENTIALS _RPC_HTTP_TRANSPORT_CREDENTIALS_W

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V2 RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V2 PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V2 _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
#define RPC_SECURITY_QOS_V3 RPC_SECURITY_QOS_V3_W
#define PRPC_SECURITY_QOS_V3 PRPC_SECURITY_QOS_V3_W
#define _RPC_SECURITY_QOS_V3 _RPC_SECURITY_QOS_V3_W
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPC_SECURITY_QOS_V4 RPC_SECURITY_QOS_V4_W
#define PRPC_SECURITY_QOS_V4 PRPC_SECURITY_QOS_V4_W
#define _RPC_SECURITY_QOS_V4 _RPC_SECURITY_QOS_V4_W
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#else // UNICODE

#define RPC_SECURITY_QOS_V2 RPC_SECURITY_QOS_V2_A
#define PRPC_SECURITY_QOS_V2 PRPC_SECURITY_QOS_V2_A
#define _RPC_SECURITY_QOS_V2 _RPC_SECURITY_QOS_V2_A

#define RPC_HTTP_TRANSPORT_CREDENTIALS RPC_HTTP_TRANSPORT_CREDENTIALS_A
#define PRPC_HTTP_TRANSPORT_CREDENTIALS PRPC_HTTP_TRANSPORT_CREDENTIALS_A
#define _RPC_HTTP_TRANSPORT_CREDENTIALS _RPC_HTTP_TRANSPORT_CREDENTIALS_A

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V2 RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V2 PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V2 _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
#define RPC_SECURITY_QOS_V3 RPC_SECURITY_QOS_V3_A
#define PRPC_SECURITY_QOS_V3 PRPC_SECURITY_QOS_V3_A
#define _RPC_SECURITY_QOS_V3 _RPC_SECURITY_QOS_V3_A
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPC_SECURITY_QOS_V4 RPC_SECURITY_QOS_V4_A
#define PRPC_SECURITY_QOS_V4 PRPC_SECURITY_QOS_V4_A
#define _RPC_SECURITY_QOS_V4 _RPC_SECURITY_QOS_V4_A
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#endif // UNICODE

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#define RPC_PROTSEQ_TCP                             (0x1)
#define RPC_PROTSEQ_NMP                             (0x2)
#define RPC_PROTSEQ_LRPC                            (0x3)
#define RPC_PROTSEQ_HTTP                            (0x4)

#define RPC_BHT_OBJECT_UUID_VALID                   (0x1)

#define RPC_BHO_NONCAUSAL                           (0x1)
#define RPC_BHO_DONTLINGER                          (0x2)
#define RPC_BHO_EXCLUSIVE_AND_GUARANTEED            (0x4)

typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_W {
    unsigned long Version;
    unsigned long Flags;
    unsigned long ProtocolSequence;
    unsigned short *NetworkAddress;
    unsigned short *StringEndpoint;
    union
    {
        unsigned short *Reserved;
    } u1;
    UUID ObjectUuid;
} RPC_BINDING_HANDLE_TEMPLATE_V1_W, *PRPC_BINDING_HANDLE_TEMPLATE_V1_W;

typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_A {
    unsigned long Version;
    unsigned long Flags;
    unsigned long ProtocolSequence;
    unsigned char *NetworkAddress;
    unsigned char *StringEndpoint;
    union
    {
        unsigned char *Reserved;
    } u1;
    UUID ObjectUuid;
} RPC_BINDING_HANDLE_TEMPLATE_V1_A, *PRPC_BINDING_HANDLE_TEMPLATE_V1_A;

typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_W {
    unsigned long Version;
    unsigned short *ServerPrincName;
    unsigned long AuthnLevel;
    unsigned long AuthnSvc;
    SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity;
    RPC_SECURITY_QOS *SecurityQos;
} RPC_BINDING_HANDLE_SECURITY_V1_W, *PRPC_BINDING_HANDLE_SECURITY_V1_W;

#ifdef _AUTH_IDENTITY_A_DEFINED

typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_A {
    unsigned long Version;
    unsigned char *ServerPrincName;
    unsigned long AuthnLevel;
    unsigned long AuthnSvc;
    SEC_WINNT_AUTH_IDENTITY_A *AuthIdentity;
    RPC_SECURITY_QOS *SecurityQos;
} RPC_BINDING_HANDLE_SECURITY_V1_A, *PRPC_BINDING_HANDLE_SECURITY_V1_A;

#endif // _AUTH_IDENTITY_A_DEFINED

typedef struct _RPC_BINDING_HANDLE_OPTIONS_V1 {
    unsigned long Version;
    unsigned long Flags;
    unsigned long ComTimeout;
    unsigned long CallTimeout;
} RPC_BINDING_HANDLE_OPTIONS_V1, *PRPC_BINDING_HANDLE_OPTIONS_V1;

#ifdef UNICODE

#define RPC_BINDING_HANDLE_TEMPLATE_V1 RPC_BINDING_HANDLE_TEMPLATE_V1_W
#define PRPC_BINDING_HANDLE_TEMPLATE_V1 PRPC_BINDING_HANDLE_TEMPLATE_V1_W
#define _RPC_BINDING_HANDLE_TEMPLATE_V1 _RPC_BINDING_HANDLE_TEMPLATE_V1_W

#define RPC_BINDING_HANDLE_SECURITY_V1 RPC_BINDING_HANDLE_SECURITY_V1_W
#define PRPC_BINDING_HANDLE_SECURITY_V1 PRPC_BINDING_HANDLE_SECURITY_V1_W
#define _RPC_BINDING_HANDLE_SECURITY_V1 _RPC_BINDING_HANDLE_SECURITY_V1_W

#else

#define RPC_BINDING_HANDLE_TEMPLATE_V1 RPC_BINDING_HANDLE_TEMPLATE_V1_A
#define PRPC_BINDING_HANDLE_TEMPLATE_V1 PRPC_BINDING_HANDLE_TEMPLATE_V1_A
#define _RPC_BINDING_HANDLE_TEMPLATE_V1 _RPC_BINDING_HANDLE_TEMPLATE_V1_A

#define RPC_BINDING_HANDLE_SECURITY_V1 RPC_BINDING_HANDLE_SECURITY_V1_A
#define PRPC_BINDING_HANDLE_SECURITY_V1 PRPC_BINDING_HANDLE_SECURITY_V1_A
#define _RPC_BINDING_HANDLE_SECURITY_V1 _RPC_BINDING_HANDLE_SECURITY_V1_A

#endif // !UNICODE

#ifdef _AUTH_IDENTITY_A_DEFINED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCreateA (
    __in RPC_BINDING_HANDLE_TEMPLATE_V1_A * Template,
    __in_opt RPC_BINDING_HANDLE_SECURITY_V1_A * Security,
    __in_opt RPC_BINDING_HANDLE_OPTIONS_V1 * Options,
    __out RPC_BINDING_HANDLE * Binding
    );

#endif // _AUTH_IDENTITY_A_DEFINED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCreateW (
    __in RPC_BINDING_HANDLE_TEMPLATE_V1_W * Template,
    __in_opt RPC_BINDING_HANDLE_SECURITY_V1_W * Security,
    __in_opt RPC_BINDING_HANDLE_OPTIONS_V1 * Options,
    __out RPC_BINDING_HANDLE * Binding
    );

#ifdef UNICODE
#define RpcBindingCreate RpcBindingCreateW
#else /* UNICODE */
#define RpcBindingCreate RpcBindingCreateA
#endif /* UNICODE */

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcBindingGetTrainingContextHandle (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out void ** ContextHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcServerInqBindingHandle (
    __out RPC_BINDING_HANDLE * Binding
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
typedef enum _RPC_HTTP_REDIRECTOR_STAGE
{
    RPCHTTP_RS_REDIRECT = 1,
    RPCHTTP_RS_ACCESS_1,
    RPCHTTP_RS_SESSION,
    RPCHTTP_RS_ACCESS_2,
    RPCHTTP_RS_INTERFACE
} RPC_HTTP_REDIRECTOR_STAGE;
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)
typedef RPC_STATUS
(__RPC_USER * RPC_NEW_HTTP_PROXY_CHANNEL) (
    __in RPC_HTTP_REDIRECTOR_STAGE RedirectorStage,
    __in RPC_WSTR ServerName,
    __in RPC_WSTR ServerPort,
    __in_opt RPC_WSTR RemoteUser,
    __in_opt RPC_WSTR AuthType,
    __in_opt void __RPC_FAR * ResourceUuid,
    __in_opt void __RPC_FAR * SessionId,
    __in_opt void __RPC_FAR * Interface,
    __in_opt void __RPC_FAR * Reserved,
    __in unsigned long Flags,
    __deref_opt_out RPC_WSTR __RPC_FAR * NewServerName,
    __deref_opt_out RPC_WSTR __RPC_FAR * NewServerPort
    );
    
#else

typedef RPC_STATUS
(__RPC_USER * RPC_NEW_HTTP_PROXY_CHANNEL) (
    IN unsigned short __RPC_FAR *ServerName,
    IN unsigned short __RPC_FAR *ServerPort,
    IN unsigned char __RPC_FAR *RemoteUser,
    OUT unsigned short __RPC_FAR **NewServerName
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03) || defined(UNDER_CE)

typedef void
(__RPC_USER * RPC_HTTP_PROXY_FREE_STRING) (
    __in RPC_WSTR String
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP)  || defined(UNDER_CE)

#define RPC_C_AUTHZ_NONE    0
#define RPC_C_AUTHZ_NAME    1
#define RPC_C_AUTHZ_DCE     2
#define RPC_C_AUTHZ_DEFAULT 0xffffffff

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    __in_opt RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    __in_opt RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    void
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientA (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientW (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExA (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExW (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoA (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_CSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExA (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_CSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc,
    __in_opt RPC_SECURITY_QOS * SecurityQos
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoW (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_WSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExW (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_WSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in_opt unsigned long AuthzSvc,
    __in_opt RPC_SECURITY_QOS * SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long RpcQosVersion,
    __out_opt RPC_SECURITY_QOS *SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in_opt  unsigned long RpcQosVersion,
    __out_opt RPC_SECURITY_QOS * SecurityQOS
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    __in void __RPC_FAR * Arg,
    __in RPC_WSTR ServerPrincName,
    __in unsigned long KeyVer,
    __deref_out void __RPC_FAR * __RPC_FAR * Key,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY 
RpcServerCompleteSecurityCallback(
    __in RPC_BINDING_HANDLE BindingHandle,
    __in RPC_STATUS Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoA (
    __in_opt RPC_CSTR ServerPrincName,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    __in_opt void __RPC_FAR * Arg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoW (
    __in_opt RPC_WSTR ServerPrincName,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    __in_opt void __RPC_FAR * Arg
    );

#ifdef UNICODE
#define RpcBindingInqAuthClient RpcBindingInqAuthClientW
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExW
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoW
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoW
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoW
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExW
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExW
#else /* UNICODE */
#define RpcBindingInqAuthClient RpcBindingInqAuthClientA
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExA
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoA
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoA
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoA
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExA
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClient (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientEx (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfo (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfo (
    __in RPC_BINDING_HANDLE Binding,
    __in RPC_CSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    __in void __RPC_FAR * Arg,
    __in unsigned char __RPC_FAR * ServerPrincName,
    __in unsigned long KeyVer,
    __out void __RPC_FAR * __RPC_FAR * Key,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfo (
    __in RPC_CSTR ServerPrincName,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    __in_opt OPTIONAL void __RPC_FAR * Arg
    );

#endif /* RPC_UNICODE_SUPPORTED */

#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)
#if !defined(_M_IA64)
typedef struct {
    unsigned char __RPC_FAR * UserName;
    unsigned char __RPC_FAR * ComputerName;
    unsigned short Privilege;
    unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1, __RPC_FAR * PRPC_CLIENT_INFORMATION1;
#endif 
#endif // (NTDDI_VERSION >= NTDDI_WINXP) || defined(UNDER_CE)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingServerFromClient (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    );

RPCRTAPI
DECLSPEC_NORETURN
void
RPC_ENTRY
RpcRaiseException (
    __in RPC_STATUS exception
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcTestCancel(
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerTestCancel (
    __in_opt RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThread(
    __in void * Thread
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThreadEx(
    __in void * Thread,
    __in long Timeout
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreate (
    __out UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateSequential (
    __out UUID __RPC_FAR * Uuid
    );

#ifdef RPC_UNICODE_SUPPORTED

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringA (
    __in const UUID __RPC_FAR * Uuid,
    __deref_out RPC_CSTR __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringA (
    __in_opt RPC_CSTR StringUuid,
    __out UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringW (
    __in const UUID __RPC_FAR * Uuid,
    __deref_out RPC_WSTR __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringW (
    __in_opt RPC_WSTR StringUuid,
    __out UUID __RPC_FAR * Uuid
    );

#ifdef UNICODE
#define UuidFromString UuidFromStringW
#define UuidToString UuidToStringW
#else /* UNICODE */
#define UuidFromString UuidFromStringA
#define UuidToString UuidToStringA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToString (
    __in const UUID __RPC_FAR * Uuid,
    __deref_out RPC_CSTR __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromString (
    __in_opt RPC_CSTR StringUuid,
    __out UUID __RPC_FAR * Uuid
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
signed int
RPC_ENTRY
UuidCompare (
    __in UUID __RPC_FAR * Uuid1,
    __in UUID __RPC_FAR * Uuid2,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateNil (
    __out UUID __RPC_FAR * NilUuid
    );

RPCRTAPI
int
RPC_ENTRY
UuidEqual (
    __in UUID __RPC_FAR * Uuid1,
    __in UUID __RPC_FAR * Uuid2,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
unsigned short
RPC_ENTRY
UuidHash (
    __in UUID __RPC_FAR * Uuid,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
int
RPC_ENTRY
UuidIsNil (
    __in UUID __RPC_FAR * Uuid,
    __out RPC_STATUS __RPC_FAR * Status
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceA (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceW (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_WSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterA (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterW (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_WSTR Annotation
    );

#ifdef UNICODE
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceW
#define RpcEpRegister RpcEpRegisterW
#else /* UNICODE */
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceA
#define RpcEpRegister RpcEpRegisterA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplace (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegister (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */


RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpUnregister(
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector
    );

#define DCE_C_ERROR_STRING_LEN 256

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextA (
    __in RPC_STATUS RpcStatus,
    __out_ecount(DCE_C_ERROR_STRING_LEN) RPC_CSTR ErrorText
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextW (
    __in RPC_STATUS RpcStatus,
    __out_ecount(DCE_C_ERROR_STRING_LEN) RPC_WSTR ErrorText
    );

#ifdef UNICODE
#define DceErrorInqText DceErrorInqTextW
#else /* UNICODE */
#define DceErrorInqText DceErrorInqTextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqText (
    __in RPC_STATUS RpcStatus,
    __out_ecount(DCE_C_ERROR_STRING_LEN) RPC_CSTR ErrorText
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef I_RPC_HANDLE * RPC_EP_INQ_HANDLE;

#define  RPC_C_EP_ALL_ELTS        0
#define  RPC_C_EP_MATCH_BY_IF     1
#define  RPC_C_EP_MATCH_BY_OBJ    2
#define  RPC_C_EP_MATCH_BY_BOTH   3

#define  RPC_C_VERS_ALL           1
#define  RPC_C_VERS_COMPATIBLE    2
#define  RPC_C_VERS_EXACT         3
#define  RPC_C_VERS_MAJOR_ONLY    4
#define  RPC_C_VERS_UPTO          5

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqBegin (
    __in OPTIONAL RPC_BINDING_HANDLE EpBinding,
    __in unsigned long InquiryType,
    __in_opt RPC_IF_ID __RPC_FAR * IfId,
    __in_opt unsigned long VersOption,
    __in_opt UUID __RPC_FAR * ObjectUuid,
    __out RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqDone (
    __inout RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextA (
    __in RPC_EP_INQ_HANDLE InquiryContext,
    __out RPC_IF_ID __RPC_FAR * IfId,
    __out_opt RPC_BINDING_HANDLE __RPC_FAR * Binding,
    __out_opt UUID __RPC_FAR * ObjectUuid,
    __deref_opt_out RPC_CSTR __RPC_FAR * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextW (
    __in RPC_EP_INQ_HANDLE InquiryContext,
    __out RPC_IF_ID __RPC_FAR * IfId,
    __out_opt RPC_BINDING_HANDLE __RPC_FAR * Binding,
    __out_opt UUID __RPC_FAR * ObjectUuid,
    __deref_opt_out RPC_WSTR __RPC_FAR * Annotation
    );

#ifdef UNICODE
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextW
#else /* UNICODE */
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNext (
    __in RPC_EP_INQ_HANDLE InquiryContext,
    __out RPC_IF_ID __RPC_FAR * IfId,
    __out_opt RPC_BINDING_HANDLE __RPC_FAR * Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpUnregister (
    __in_opt RPC_BINDING_HANDLE EpBinding,
    __in RPC_IF_ID __RPC_FAR * IfId,
    __in RPC_BINDING_HANDLE Binding,
    __in_opt UUID __RPC_FAR * ObjectUuid
    );

typedef int
(__RPC_API * RPC_MGMT_AUTHORIZATION_FN) (
    __in RPC_BINDING_HANDLE ClientBinding,
    __in unsigned long RequestedMgmtOperation,
    __out RPC_STATUS __RPC_FAR * Status
    );

#define RPC_C_MGMT_INQ_IF_IDS         0
#define RPC_C_MGMT_INQ_PRINC_NAME     1
#define RPC_C_MGMT_INQ_STATS          2
#define RPC_C_MGMT_IS_SERVER_LISTEN   3
#define RPC_C_MGMT_STOP_SERVER_LISTEN 4

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    __in RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    );

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
RPCRTAPI
int
RPC_ENTRY
RpcExceptionFilter (
    __in unsigned long ExceptionCode
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#define RPC_C_PARM_MAX_PACKET_LENGTH    1
#define RPC_C_PARM_BUFFER_LENGTH        2

#define RPC_IF_AUTOLISTEN                   0x0001
#define RPC_IF_OLE                          0x0002
#define RPC_IF_ALLOW_UNKNOWN_AUTHORITY      0x0004
#define RPC_IF_ALLOW_SECURE_ONLY            0x0008
#define RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH 0x0010
#define RPC_IF_ALLOW_LOCAL_ONLY             0x0020
#define RPC_IF_SEC_NO_CACHE                 0x0040
#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPC_IF_SEC_CACHE_PER_PROC           0x0080
#define RPC_IF_ASYNC_CALLBACK               0x0100
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#if (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)
#define RPC_FW_IF_FLAG_DCOM                 0x0001
#endif // (NTDDI_VERSION >= NTDDI_VISTA) || defined(UNDER_CE)

#include <rpcdcep.h>

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcnterr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*********************************************************/
/**               Microsoft LAN Manager                 **/
/**                                                     **/
/**     Rpc Error Codes from the compiler and runtime   **/
/**                                                     **/
/*********************************************************/
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcnterr.h

Abstract:

    Rpc Error Codes from the compiler and runtime

--*/

#pragma once

#ifndef __RPCNTERR_H__
#define __RPCNTERR_H__

#if !defined(_KRPCENV_) || defined(UNDER_CE)

#define RPC_S_OK                          ERROR_SUCCESS
#define RPC_S_INVALID_ARG                 ERROR_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY               ERROR_OUTOFMEMORY
#define RPC_S_OUT_OF_THREADS              ERROR_MAX_THRDS_REACHED
#define RPC_S_INVALID_LEVEL               ERROR_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL            ERROR_INSUFFICIENT_BUFFER
#define RPC_S_INVALID_SECURITY_DESC       ERROR_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED               ERROR_ACCESS_DENIED
#define RPC_S_SERVER_OUT_OF_MEMORY        ERROR_NOT_ENOUGH_SERVER_MEMORY
#define RPC_S_ASYNC_CALL_PENDING          ERROR_IO_PENDING
#define RPC_S_UNKNOWN_PRINCIPAL           ERROR_NONE_MAPPED
#define RPC_S_TIMEOUT                     ERROR_TIMEOUT
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_S_NOT_ENOUGH_QUOTA            ERROR_NOT_ENOUGH_QUOTA
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_X_NO_MEMORY                   RPC_S_OUT_OF_MEMORY
#define RPC_X_INVALID_BOUND               RPC_S_INVALID_BOUND
#define RPC_X_INVALID_TAG                 RPC_S_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE        RPC_X_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH         ERROR_INVALID_HANDLE
#define RPC_X_INVALID_BUFFER              ERROR_INVALID_USER_BUFFER
#define RPC_X_PIPE_APP_MEMORY             ERROR_OUTOFMEMORY
#define RPC_X_INVALID_PIPE_OPERATION      RPC_X_WRONG_PIPE_ORDER

#else   // _KRPCENV_ || UNDER_CE

#define RPC_S_OK                            STATUS_SUCCESS

#if defined(RPC_S_INVALID_STRING_BINDING)
#undef RPC_S_INVALID_STRING_BINDING
#endif
#define RPC_S_INVALID_STRING_BINDING        RPC_NT_INVALID_STRING_BINDING

#if defined(RPC_S_WRONG_KIND_OF_BINDING)
#undef RPC_S_WRONG_KIND_OF_BINDING
#endif
#define RPC_S_WRONG_KIND_OF_BINDING         RPC_NT_WRONG_KIND_OF_BINDING

#if defined(RPC_S_INVALID_BINDING)
#undef RPC_S_INVALID_BINDING
#endif
#define RPC_S_INVALID_BINDING               RPC_NT_INVALID_BINDING

#if defined(RPC_S_PROTSEQ_NOT_SUPPORTED)
#undef RPC_S_PROTSEQ_NOT_SUPPORTED
#endif
#define RPC_S_PROTSEQ_NOT_SUPPORTED         RPC_NT_PROTSEQ_NOT_SUPPORTED

#if defined(RPC_S_INVALID_RPC_PROTSEQ)
#undef RPC_S_INVALID_RPC_PROTSEQ
#endif
#define RPC_S_INVALID_RPC_PROTSEQ           RPC_NT_INVALID_RPC_PROTSEQ

#if defined(RPC_S_INVALID_STRING_UUID)
#undef RPC_S_INVALID_STRING_UUID
#endif
#define RPC_S_INVALID_STRING_UUID           RPC_NT_INVALID_STRING_UUID

#if defined(RPC_S_INVALID_ENDPOINT_FORMAT)
#undef RPC_S_INVALID_ENDPOINT_FORMAT
#endif
#define RPC_S_INVALID_ENDPOINT_FORMAT       RPC_NT_INVALID_ENDPOINT_FORMAT

#if defined(RPC_S_INVALID_NET_ADDR)
#undef RPC_S_INVALID_NET_ADDR
#endif
#define RPC_S_INVALID_NET_ADDR              RPC_NT_INVALID_NET_ADDR

#if defined(RPC_S_NO_ENDPOINT_FOUND)
#undef RPC_S_NO_ENDPOINT_FOUND
#endif
#define RPC_S_NO_ENDPOINT_FOUND             RPC_NT_NO_ENDPOINT_FOUND

#if defined(RPC_S_INVALID_TIMEOUT)
#undef RPC_S_INVALID_TIMEOUT
#endif
#define RPC_S_INVALID_TIMEOUT               RPC_NT_INVALID_TIMEOUT

#if defined(RPC_S_OBJECT_NOT_FOUND)
#undef RPC_S_OBJECT_NOT_FOUND
#endif
#define RPC_S_OBJECT_NOT_FOUND              RPC_NT_OBJECT_NOT_FOUND

#if defined(RPC_S_ALREADY_REGISTERED)
#undef RPC_S_ALREADY_REGISTERED
#endif
#define RPC_S_ALREADY_REGISTERED            RPC_NT_ALREADY_REGISTERED

#if defined(RPC_S_TYPE_ALREADY_REGISTERED)
#undef RPC_S_TYPE_ALREADY_REGISTERED
#endif
#define RPC_S_TYPE_ALREADY_REGISTERED       RPC_NT_TYPE_ALREADY_REGISTERED

#if defined(RPC_S_ALREADY_LISTENING)
#undef RPC_S_ALREADY_LISTENING
#endif
#define RPC_S_ALREADY_LISTENING             RPC_NT_ALREADY_LISTENING

#if defined(RPC_S_NO_PROTSEQS_REGISTERED)
#undef RPC_S_NO_PROTSEQS_REGISTERED
#endif
#define RPC_S_NO_PROTSEQS_REGISTERED        RPC_NT_NO_PROTSEQS_REGISTERED

#if defined(RPC_S_NOT_LISTENING)
#undef RPC_S_NOT_LISTENING
#endif
#define RPC_S_NOT_LISTENING                 RPC_NT_NOT_LISTENING

#if defined(RPC_S_UNKNOWN_MGR_TYPE)
#undef RPC_S_UNKNOWN_MGR_TYPE
#endif
#define RPC_S_UNKNOWN_MGR_TYPE              RPC_NT_UNKNOWN_MGR_TYPE

#if defined(RPC_S_UNKNOWN_IF)
#undef RPC_S_UNKNOWN_IF
#endif
#define RPC_S_UNKNOWN_IF                    RPC_NT_UNKNOWN_IF

#if defined(RPC_S_NO_BINDINGS)
#undef RPC_S_NO_BINDINGS
#endif
#define RPC_S_NO_BINDINGS                   RPC_NT_NO_BINDINGS

#if defined(RPC_S_NO_MORE_BINDINGS)
#undef RPC_S_NO_MORE_BINDINGS
#endif
#define RPC_S_NO_MORE_BINDINGS              RPC_NT_NO_MORE_BINDINGS

#if defined(RPC_S_NO_PROTSEQS)
#undef RPC_S_NO_PROTSEQS
#endif
#define RPC_S_NO_PROTSEQS                   RPC_NT_NO_PROTSEQS

#if defined(RPC_S_CANT_CREATE_ENDPOINT)
#undef RPC_S_CANT_CREATE_ENDPOINT
#endif
#define RPC_S_CANT_CREATE_ENDPOINT          RPC_NT_CANT_CREATE_ENDPOINT

#if defined(RPC_S_OUT_OF_RESOURCES)
#undef RPC_S_OUT_OF_RESOURCES
#endif
#define RPC_S_OUT_OF_RESOURCES              RPC_NT_OUT_OF_RESOURCES

#if defined(RPC_S_SERVER_UNAVAILABLE)
#undef RPC_S_SERVER_UNAVAILABLE
#endif
#define RPC_S_SERVER_UNAVAILABLE            RPC_NT_SERVER_UNAVAILABLE

#if defined(RPC_S_SERVER_TOO_BUSY)
#undef RPC_S_SERVER_TOO_BUSY
#endif
#define RPC_S_SERVER_TOO_BUSY               RPC_NT_SERVER_TOO_BUSY

#if defined(RPC_S_INVALID_NETWORK_OPTIONS)
#undef RPC_S_INVALID_NETWORK_OPTIONS
#endif
#define RPC_S_INVALID_NETWORK_OPTIONS       RPC_NT_INVALID_NETWORK_OPTIONS

#if defined(RPC_S_NO_CALL_ACTIVE)
#undef RPC_S_NO_CALL_ACTIVE
#endif
#define RPC_S_NO_CALL_ACTIVE                RPC_NT_NO_CALL_ACTIVE

#if defined(RPC_S_CALL_FAILED)
#undef RPC_S_CALL_FAILED
#endif
#define RPC_S_CALL_FAILED                   RPC_NT_CALL_FAILED

#if defined(RPC_S_CALL_CANCELLED)
#undef RPC_S_CALL_CANCELLED
#endif
#define RPC_S_CALL_CANCELLED                RPC_NT_CALL_CANCELLED

#if defined(RPC_S_CALL_FAILED_DNE)
#undef RPC_S_CALL_FAILED_DNE
#endif
#define RPC_S_CALL_FAILED_DNE               RPC_NT_CALL_FAILED_DNE

#if defined(RPC_S_PROTOCOL_ERROR)
#undef RPC_S_PROTOCOL_ERROR
#endif
#define RPC_S_PROTOCOL_ERROR                RPC_NT_PROTOCOL_ERROR

#if defined(RPC_S_UNSUPPORTED_TRANS_SYN)
#undef RPC_S_UNSUPPORTED_TRANS_SYN
#endif
#define RPC_S_UNSUPPORTED_TRANS_SYN         RPC_NT_UNSUPPORTED_TRANS_SYN

#if defined(RPC_S_SERVER_OUT_OF_MEMORY)
#undef RPC_S_SERVER_OUT_OF_MEMORY
#endif
#define RPC_S_SERVER_OUT_OF_MEMORY          STATUS_INSUFF_SERVER_RESOURCES

#if defined(RPC_S_UNSUPPORTED_TYPE)
#undef RPC_S_UNSUPPORTED_TYPE
#endif
#define RPC_S_UNSUPPORTED_TYPE              RPC_NT_UNSUPPORTED_TYPE

#if defined(RPC_S_INVALID_TAG)
#undef RPC_S_INVALID_TAG
#endif
#define RPC_S_INVALID_TAG                   RPC_NT_INVALID_TAG

#if defined(RPC_S_INVALID_BOUND)
#undef RPC_S_INVALID_BOUND
#endif
#define RPC_S_INVALID_BOUND                 RPC_NT_INVALID_BOUND

#if defined(RPC_S_NO_ENTRY_NAME)
#undef RPC_S_NO_ENTRY_NAME
#endif
#define RPC_S_NO_ENTRY_NAME                 RPC_NT_NO_ENTRY_NAME

#if defined(RPC_S_INVALID_NAME_SYNTAX)
#undef RPC_S_INVALID_NAME_SYNTAX
#endif
#define RPC_S_INVALID_NAME_SYNTAX           RPC_NT_INVALID_NAME_SYNTAX

#if defined(RPC_S_UNSUPPORTED_NAME_SYNTAX)
#undef RPC_S_UNSUPPORTED_NAME_SYNTAX
#endif
#define RPC_S_UNSUPPORTED_NAME_SYNTAX       RPC_NT_UNSUPPORTED_NAME_SYNTAX

#if defined(RPC_S_UUID_NO_ADDRESS)
#undef RPC_S_UUID_NO_ADDRESS
#endif
#define RPC_S_UUID_NO_ADDRESS               RPC_NT_UUID_NO_ADDRESS

#if defined(RPC_S_DUPLICATE_ENDPOINT)
#undef RPC_S_DUPLICATE_ENDPOINT
#endif
#define RPC_S_DUPLICATE_ENDPOINT            RPC_NT_DUPLICATE_ENDPOINT

#if defined(RPC_S_UNKNOWN_AUTHN_TYPE)
#undef RPC_S_UNKNOWN_AUTHN_TYPE
#endif
#define RPC_S_UNKNOWN_AUTHN_TYPE            RPC_NT_UNKNOWN_AUTHN_TYPE

#if defined(RPC_S_MAX_CALLS_TOO_SMALL)
#undef RPC_S_MAX_CALLS_TOO_SMALL
#endif
#define RPC_S_MAX_CALLS_TOO_SMALL           RPC_NT_MAX_CALLS_TOO_SMALL

#if defined(RPC_S_STRING_TOO_LONG)
#undef RPC_S_STRING_TOO_LONG
#endif
#define RPC_S_STRING_TOO_LONG               RPC_NT_STRING_TOO_LONG

#if defined(RPC_S_PROTSEQ_NOT_FOUND)
#undef RPC_S_PROTSEQ_NOT_FOUND
#endif
#define RPC_S_PROTSEQ_NOT_FOUND             RPC_NT_PROTSEQ_NOT_FOUND

#if defined(RPC_S_PROCNUM_OUT_OF_RANGE)
#undef RPC_S_PROCNUM_OUT_OF_RANGE
#endif
#define RPC_S_PROCNUM_OUT_OF_RANGE          RPC_NT_PROCNUM_OUT_OF_RANGE

#if defined(RPC_S_BINDING_HAS_NO_AUTH)
#undef RPC_S_BINDING_HAS_NO_AUTH
#endif
#define RPC_S_BINDING_HAS_NO_AUTH           RPC_NT_BINDING_HAS_NO_AUTH

#if defined(RPC_S_UNKNOWN_AUTHN_SERVICE)
#undef RPC_S_UNKNOWN_AUTHN_SERVICE
#endif
#define RPC_S_UNKNOWN_AUTHN_SERVICE         RPC_NT_UNKNOWN_AUTHN_SERVICE

#if defined(RPC_S_UNKNOWN_AUTHN_LEVEL)
#undef RPC_S_UNKNOWN_AUTHN_LEVEL
#endif
#define RPC_S_UNKNOWN_AUTHN_LEVEL           RPC_NT_UNKNOWN_AUTHN_LEVEL

#if defined(RPC_S_INVALID_AUTH_IDENTITY)
#undef RPC_S_INVALID_AUTH_IDENTITY
#endif
#define RPC_S_INVALID_AUTH_IDENTITY         RPC_NT_INVALID_AUTH_IDENTITY

#if defined(RPC_S_UNKNOWN_AUTHZ_SERVICE)
#undef RPC_S_UNKNOWN_AUTHZ_SERVICE
#endif
#define RPC_S_UNKNOWN_AUTHZ_SERVICE         RPC_NT_UNKNOWN_AUTHZ_SERVICE

#if defined(EPT_S_INVALID_ENTRY)
#undef EPT_S_INVALID_ENTRY
#endif
#define EPT_S_INVALID_ENTRY                 EPT_NT_INVALID_ENTRY

#if defined(EPT_S_CANT_PERFORM_OP)
#undef EPT_S_CANT_PERFORM_OP
#endif
#define EPT_S_CANT_PERFORM_OP               EPT_NT_CANT_PERFORM_OP

#if defined(EPT_S_NOT_REGISTERED)
#undef EPT_S_NOT_REGISTERED
#endif
#define EPT_S_NOT_REGISTERED                EPT_NT_NOT_REGISTERED

#if defined(RPC_S_NOTHING_TO_EXPORT)
#undef RPC_S_NOTHING_TO_EXPORT
#endif
#define RPC_S_NOTHING_TO_EXPORT             RPC_NT_NOTHING_TO_EXPORT

#if defined(RPC_S_INCOMPLETE_NAME)
#undef RPC_S_INCOMPLETE_NAME
#endif
#define RPC_S_INCOMPLETE_NAME               RPC_NT_INCOMPLETE_NAME

#if defined(RPC_S_INVALID_VERS_OPTION)
#undef RPC_S_INVALID_VERS_OPTION
#endif
#define RPC_S_INVALID_VERS_OPTION           RPC_NT_INVALID_VERS_OPTION

#if defined(RPC_S_NO_MORE_MEMBERS)
#undef RPC_S_NO_MORE_MEMBERS
#endif
#define RPC_S_NO_MORE_MEMBERS               RPC_NT_NO_MORE_MEMBERS

#if defined(RPC_S_NOT_ALL_OBJS_UNEXPORTED)
#undef RPC_S_NOT_ALL_OBJS_UNEXPORTED
#endif
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED       RPC_NT_NOT_ALL_OBJS_UNEXPORTED

#if defined(RPC_S_INTERFACE_NOT_FOUND)
#undef RPC_S_INTERFACE_NOT_FOUND
#endif
#define RPC_S_INTERFACE_NOT_FOUND           RPC_NT_INTERFACE_NOT_FOUND

#if defined(RPC_S_ENTRY_ALREADY_EXISTS)
#undef RPC_S_ENTRY_ALREADY_EXISTS
#endif
#define RPC_S_ENTRY_ALREADY_EXISTS          RPC_NT_ENTRY_ALREADY_EXISTS

#if defined(RPC_S_ENTRY_NOT_FOUND)
#undef RPC_S_ENTRY_NOT_FOUND
#endif
#define RPC_S_ENTRY_NOT_FOUND               RPC_NT_ENTRY_NOT_FOUND

#if defined(RPC_S_NAME_SERVICE_UNAVAILABLE)
#undef RPC_S_NAME_SERVICE_UNAVAILABLE
#endif
#define RPC_S_NAME_SERVICE_UNAVAILABLE      RPC_NT_NAME_SERVICE_UNAVAILABLE

#if defined(RPC_S_INVALID_NAF_ID)
#undef RPC_S_INVALID_NAF_ID
#endif
#define RPC_S_INVALID_NAF_ID                RPC_NT_INVALID_NAF_ID

#if defined(RPC_S_CANNOT_SUPPORT)
#undef RPC_S_CANNOT_SUPPORT
#endif
#define RPC_S_CANNOT_SUPPORT                RPC_NT_CANNOT_SUPPORT

#if defined(RPC_S_NO_CONTEXT_AVAILABLE)
#undef RPC_S_NO_CONTEXT_AVAILABLE
#endif
#define RPC_S_NO_CONTEXT_AVAILABLE          RPC_NT_NO_CONTEXT_AVAILABLE

#if defined(RPC_S_INTERNAL_ERROR)
#undef RPC_S_INTERNAL_ERROR
#endif
#define RPC_S_INTERNAL_ERROR                RPC_NT_INTERNAL_ERROR

#if defined(RPC_S_ZERO_DIVIDE)
#undef RPC_S_ZERO_DIVIDE
#endif
#define RPC_S_ZERO_DIVIDE                   RPC_NT_ZERO_DIVIDE

#if defined(RPC_S_ADDRESS_ERROR)
#undef RPC_S_ADDRESS_ERROR
#endif
#define RPC_S_ADDRESS_ERROR                 RPC_NT_ADDRESS_ERROR

#if defined(RPC_S_FP_DIV_ZERO)
#undef RPC_S_FP_DIV_ZERO
#endif
#define RPC_S_FP_DIV_ZERO                   RPC_NT_FP_DIV_ZERO

#if defined(RPC_S_FP_UNDERFLOW)
#undef RPC_S_FP_UNDERFLOW
#endif
#define RPC_S_FP_UNDERFLOW                  RPC_NT_FP_UNDERFLOW

#if defined(RPC_S_FP_OVERFLOW)
#undef RPC_S_FP_OVERFLOW
#endif
#define RPC_S_FP_OVERFLOW                   RPC_NT_FP_OVERFLOW

#if defined(RPC_S_PROXY_ACCESS_DENIED)
#undef RPC_S_PROXY_ACCESS_DENIED
#endif
#define RPC_S_PROXY_ACCESS_DENIED           RPC_NT_PROXY_ACCESS_DENIED

#if defined(RPC_X_NO_MORE_ENTRIES)
#undef RPC_X_NO_MORE_ENTRIES
#endif
#define RPC_X_NO_MORE_ENTRIES               RPC_NT_NO_MORE_ENTRIES

#if defined(RPC_X_SS_CHAR_TRANS_OPEN_FAIL)
#undef RPC_X_SS_CHAR_TRANS_OPEN_FAIL
#endif
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL       RPC_NT_SS_CHAR_TRANS_OPEN_FAIL

#if defined(RPC_X_SS_CHAR_TRANS_SHORT_FILE)
#undef RPC_X_SS_CHAR_TRANS_SHORT_FILE
#endif
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE      RPC_NT_SS_CHAR_TRANS_SHORT_FILE

#if defined(RPC_X_SS_IN_NULL_CONTEXT)
#undef RPC_X_SS_IN_NULL_CONTEXT
#endif
#define RPC_X_SS_IN_NULL_CONTEXT            RPC_NT_SS_IN_NULL_CONTEXT

#if defined(RPC_X_SS_CONTEXT_MISMATCH)
#undef RPC_X_SS_CONTEXT_MISMATCH
#endif
#define RPC_X_SS_CONTEXT_MISMATCH           RPC_NT_SS_CONTEXT_MISMATCH

#if defined(RPC_X_SS_CONTEXT_DAMAGED)
#undef RPC_X_SS_CONTEXT_DAMAGED
#endif
#define RPC_X_SS_CONTEXT_DAMAGED            RPC_NT_SS_CONTEXT_DAMAGED

#if defined(RPC_X_SS_HANDLES_MISMATCH)
#undef RPC_X_SS_HANDLES_MISMATCH
#endif
#define RPC_X_SS_HANDLES_MISMATCH           RPC_NT_SS_HANDLES_MISMATCH

#if defined(RPC_X_SS_CANNOT_GET_CALL_HANDLE)
#undef RPC_X_SS_CANNOT_GET_CALL_HANDLE
#endif
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE     RPC_NT_SS_CANNOT_GET_CALL_HANDLE

#if defined(RPC_X_NULL_REF_POINTER)
#undef RPC_X_NULL_REF_POINTER
#endif
#define RPC_X_NULL_REF_POINTER              RPC_NT_NULL_REF_POINTER

#if defined(RPC_X_ENUM_VALUE_OUT_OF_RANGE)
#undef RPC_X_ENUM_VALUE_OUT_OF_RANGE
#endif
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE       RPC_NT_ENUM_VALUE_OUT_OF_RANGE

#if defined(RPC_X_BYTE_COUNT_TOO_SMALL)
#undef RPC_X_BYTE_COUNT_TOO_SMALL
#endif
#define RPC_X_BYTE_COUNT_TOO_SMALL          RPC_NT_BYTE_COUNT_TOO_SMALL

#if defined(RPC_X_BAD_STUB_DATA)
#undef RPC_X_BAD_STUB_DATA
#endif
#define RPC_X_BAD_STUB_DATA                 RPC_NT_BAD_STUB_DATA

#if defined(RPC_S_CALL_IN_PROGRESS)
#undef RPC_S_CALL_IN_PROGRESS
#endif
#define RPC_S_CALL_IN_PROGRESS              RPC_NT_CALL_IN_PROGRESS

#if defined(RPC_S_GROUP_MEMBER_NOT_FOUND)
#undef RPC_S_GROUP_MEMBER_NOT_FOUND
#endif
#define RPC_S_GROUP_MEMBER_NOT_FOUND        RPC_NT_GROUP_MEMBER_NOT_FOUND

#if defined(EPT_S_CANT_CREATE)
#undef EPT_S_CANT_CREATE
#endif
#define EPT_S_CANT_CREATE                   EPT_NT_CANT_CREATE

#if defined(RPC_S_INVALID_OBJECT)
#undef RPC_S_INVALID_OBJECT
#endif
#define RPC_S_INVALID_OBJECT                RPC_NT_INVALID_OBJECT

#if defined(RPC_S_INVALID_ASYNC_HANDLE)
#undef RPC_S_INVALID_ASYNC_HANDLE
#endif
#define RPC_S_INVALID_ASYNC_HANDLE          RPC_NT_INVALID_ASYNC_HANDLE

#if defined(RPC_S_INVALID_ASYNC_CALL)
#undef RPC_S_INVALID_ASYNC_CALL
#endif
#define RPC_S_INVALID_ASYNC_CALL            RPC_NT_INVALID_ASYNC_CALL

#if defined(RPC_X_PIPE_CLOSED)
#undef RPC_X_PIPE_CLOSED
#endif
#define RPC_X_PIPE_CLOSED                   RPC_NT_PIPE_CLOSED

#if defined(RPC_X_PIPE_EMPTY)
#undef RPC_X_PIPE_EMPTY
#endif
#define RPC_X_PIPE_EMPTY                    RPC_NT_PIPE_EMPTY

#if defined(RPC_X_PIPE_DISCIPLINE_ERROR)
#undef RPC_X_PIPE_DISCIPLINE_ERROR
#endif
#define RPC_X_PIPE_DISCIPLINE_ERROR         RPC_NT_PIPE_DISCIPLINE_ERROR

#define RPC_S_INVALID_ARG                   STATUS_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY                 STATUS_NO_MEMORY
#define RPC_S_OUT_OF_THREADS                STATUS_NO_MEMORY
#define RPC_S_INVALID_LEVEL                 STATUS_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL              STATUS_BUFFER_TOO_SMALL
#define RPC_S_INVALID_SECURITY_DESC         STATUS_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED                 STATUS_ACCESS_DENIED
#define RPC_S_ASYNC_CALL_PENDING            STATUS_PENDING
#define RPC_S_UNKNOWN_PRINCIPAL             STATUS_NONE_MAPPED
#define RPC_S_NOT_ENOUGH_QUOTA              STATUS_QUOTA_EXCEEDED
#define RPC_X_NO_MEMORY                     STATUS_NO_MEMORY
#define RPC_X_INVALID_BOUND                 RPC_NT_INVALID_BOUND
#define RPC_X_INVALID_TAG                   RPC_NT_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE          RPC_NT_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH           RPC_NT_SS_CONTEXT_MISMATCH
#define RPC_X_INVALID_BUFFER                STATUS_INVALID_BUFFER_SIZE
#define RPC_X_PIPE_APP_MEMORY               STATUS_NO_MEMORY

#endif  // _KRPCENV_ || UNDER_CE

#endif /* __RPCNTERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcnsip.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcnsip.h

Abstract:

    This file contains the types and function definitions to use the
    to implement the autohandle features of the runtime.

--*/

#ifndef __RPCNSIP_H__
#define __RPCNSIP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
   RPC_NS_HANDLE        LookupContext;
   RPC_BINDING_HANDLE   ProposedHandle;
   RPC_BINDING_VECTOR * Bindings;

} RPC_IMPORT_CONTEXT_P, * PRPC_IMPORT_CONTEXT_P;


/* Stub Auto Binding routines. */

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsGetBuffer(
    IN PRPC_MESSAGE Message
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsSendReceive(
    IN PRPC_MESSAGE Message,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Handle
    );

RPCNSAPI
void
RPC_ENTRY
I_RpcNsRaiseException(
    IN PRPC_MESSAGE Message,
    IN RPC_STATUS Status
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcReBindBuffer(
    IN PRPC_MESSAGE Message
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_NsServerBindSearch(
    void
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_NsClientBindSearch(
    void
    );

RPCNSAPI
void
RPC_ENTRY
I_NsClientBindDone(
    void
    );

#ifdef __cplusplus
}
#endif

#endif /* __RPCNSIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcwince.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

 Copyright (c) Microsoft Corporation.  All rights reserved.

  Module name: 

    Rpcwince.h
  
  Abstract:

    Definitions for Windows CE specific RPC functions.
 
--*/
#ifndef __WINCERPC_H__
#define __WINCERPC_H__

#ifdef __cplusplus
extern "C" {
#endif

RPCRTAPI
RPC_STATUS
CeRpcImpersonateCurrentProcess();


RPCRTAPI
RPC_STATUS
CeRpcRevertToSelf();

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
CeRpcServerUnregisterProtseqEpW(
    __in WCHAR *Protseq,
    __in WCHAR *Endpoint
    );

#ifdef __cplusplus
}
#endif

#endif // __WINCERPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcwdt.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcwdt.h

Abstract:

    Optional prototypes definitions for user marshal routines related to WDT
    (Windows Data Types). Routines are exposed by ole32.dll.

Environment:

    Win32, Win64

Revision History:

--*/

#ifndef __RPCWDT_H__
#define __RPCWDT_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Windows Data Type support */

unsigned long  __RPC_USER
HGLOBAL_UserSize(
    unsigned long *,
    unsigned long,
    HGLOBAL       * );

unsigned char *  __RPC_USER
HGLOBAL_UserMarshal(
    unsigned long *,
    unsigned char *,
    HGLOBAL       * );

unsigned char *  __RPC_USER
HGLOBAL_UserUnmarshal(
    unsigned long *,
    unsigned char *,
    HGLOBAL       * );

void  __RPC_USER
HGLOBAL_UserFree(
    unsigned long *,
    HGLOBAL       * );

unsigned long  __RPC_USER
HBITMAP_UserSize(
    unsigned long *,
    unsigned long,
    HBITMAP       * );

unsigned char *  __RPC_USER
HBITMAP_UserMarshal(
    unsigned long *,
    __out unsigned char *,
    HBITMAP       * );

unsigned char *  __RPC_USER
HBITMAP_UserUnmarshal(
    unsigned long *,
    __in unsigned char *,
    HBITMAP       * );

void  __RPC_USER
HBITMAP_UserFree(
    unsigned long *,
    HBITMAP       * );

unsigned long  __RPC_USER
HENHMETAFILE_UserSize(
    unsigned long *,
    unsigned long,
    HENHMETAFILE  * );

unsigned char *  __RPC_USER
HENHMETAFILE_UserMarshal(
    unsigned long * pFlags,
    __out unsigned char * pBuffer,
    HENHMETAFILE  *  pHEnhMetafile);

unsigned char *  __RPC_USER
HENHMETAFILE_UserUnmarshal(
    unsigned long * pFlags,
    __in unsigned char * pBuffer,
    HENHMETAFILE  *  pHEnhMetafile);

void  __RPC_USER
HENHMETAFILE_UserFree(
    unsigned long *,
    HENHMETAFILE  * );

unsigned long  __RPC_USER
HMETAFILE_UserSize(
    unsigned long *,
    unsigned long,
    HMETAFILE     * );

unsigned char *  __RPC_USER
HMETAFILE_UserMarshal(
    unsigned long * pFlags,
    __out unsigned char * pBuffer,
    HMETAFILE     *  pHMetafile);

unsigned char *  __RPC_USER
HMETAFILE_UserUnmarshal(
    unsigned long * pFlags,
    __in unsigned char * pBuffer,
    HMETAFILE     *  pHMetafile);

void __RPC_USER
HMETAFILE_UserFree(
    unsigned long *,
    HMETAFILE     * );

unsigned long  __RPC_USER
HMETAFILEPICT_UserSize(
    unsigned long *,
    unsigned long,
    HMETAFILEPICT * );

unsigned char *  __RPC_USER
HMETAFILEPICT_UserMarshal(
    unsigned long * pFlags,
    __out unsigned char * pBuffer,
    HMETAFILEPICT *  pHMetaFilePict);

unsigned char *  __RPC_USER
HMETAFILEPICT_UserUnmarshal(
    unsigned long * pFlags,
    __in unsigned char * pBuffer,
    HMETAFILEPICT *  pHMetaFilePict);

void __RPC_USER
HMETAFILEPICT_UserFree(
    unsigned long *,
    HMETAFILEPICT * );

unsigned long  __RPC_USER
HPALETTE_UserSize(
    unsigned long *,
    unsigned long,
    HPALETTE      * );

unsigned char *  __RPC_USER
HPALETTE_UserMarshal(
    unsigned long * pFlags,
    __out unsigned char * pBuffer,
    HPALETTE      *  pHPalette);

unsigned char *  __RPC_USER
HPALETTE_UserUnmarshal(
    unsigned long * pFlags,
    __in unsigned char * pBuffer,
    HPALETTE      *  pHPalette);

void __RPC_USER
HPALETTE_UserFree(
    unsigned long *,
    HPALETTE      * );

unsigned long  __RPC_USER
STGMEDIUM_UserSize(
    unsigned long *,
    unsigned long,
    STGMEDIUM     * );

unsigned char *  __RPC_USER
STGMEDIUM_UserMarshal(
    unsigned long * pFlags,
    __out unsigned char * pBufferStart,
    STGMEDIUM     *  pStgmed);

unsigned char *  __RPC_USER
STGMEDIUM_UserUnmarshal(
    unsigned long * pFlags,
    __in unsigned char * pBuffer,
    STGMEDIUM     *  pStgmed);

void __RPC_USER
STGMEDIUM_UserFree(
    unsigned long *,
    STGMEDIUM     * );

unsigned long  __RPC_USER
SNB_UserSize(
    unsigned long *,
    unsigned long,
    SNB           * );

unsigned char *  __RPC_USER
SNB_UserMarshal(
    unsigned long *,
    unsigned char *,
    SNB           * );

unsigned char *  __RPC_USER
SNB_UserUnmarshal(
    unsigned long *,
    unsigned char *,
    SNB           * );

/* OLE automation Data Type support */

unsigned long  __RPC_USER
BSTR_UserSize(
    unsigned long *,
    unsigned long,
    BSTR          * );

unsigned char *  __RPC_USER
BSTR_UserMarshal(
    unsigned long *,
    unsigned char *,
    BSTR          * );

unsigned char *  __RPC_USER
BSTR_UserUnmarshal(
    unsigned long *,
    unsigned char *,
    BSTR          * );

void  __RPC_USER
BSTR_UserFree(
    unsigned long *,
    BSTR          * );

unsigned long  __RPC_USER
LPSAFEARRAY_UserSize(
    unsigned long *,
    unsigned long,
    LPSAFEARRAY   * );

unsigned char *  __RPC_USER
LPSAFEARRAY_UserMarshal(
    unsigned long *,
    unsigned char *,
    LPSAFEARRAY   * );

unsigned char *  __RPC_USER
LPSAFEARRAY_UserUnmarshal(
    unsigned long *,
    unsigned char *,
    LPSAFEARRAY   * );

void  __RPC_USER
LPSAFEARRAY_UserFree(
    unsigned long *,
    LPSAFEARRAY   * );


unsigned long  __RPC_USER
VARIANT_UserSize(
    unsigned long *,
    unsigned long,
    VARIANT       * );

unsigned char *  __RPC_USER
VARIANT_UserMarshal(
    unsigned long *,
    __out unsigned char *,
    VARIANT       * );

unsigned char *  __RPC_USER
VARIANT_UserUnmarshal(
    unsigned long *,
    __in unsigned char *,
    VARIANT       * );

void  __RPC_USER
VARIANT_UserFree(
    unsigned long *,
    VARIANT       * );


unsigned long  __RPC_USER
EXCEPINFO_UserSize(
    unsigned long *,
    unsigned long,
    EXCEPINFO     * );

unsigned char *  __RPC_USER
EXCEPINFO_UserMarshal(
    unsigned long *,
    unsigned char *,
    EXCEPINFO     * );

unsigned char *  __RPC_USER
EXCEPINFO_UserUnmarshal(
    unsigned long *,
    unsigned char *,
    EXCEPINFO     * );

void  __RPC_USER
EXCEPINFO_UserFree(
    unsigned long *,
    EXCEPINFO     * );

unsigned long  __RPC_USER
DISPPARAMS_UserSize(
    unsigned long *,
    unsigned long,
    DISPPARAMS    * );

unsigned char *  __RPC_USER
DISPPARAMS_UserMarshal(
    unsigned long *,
    unsigned char *,
    DISPPARAMS    * );

unsigned char *  __RPC_USER
DISPPARAMS_UserUnmarshal(
    unsigned long *,
    unsigned char *,
    DISPPARAMS    * );

void  __RPC_USER
DISPPARAMS_UserFree(
    unsigned long *,
    DISPPARAMS    * );

/* Other types: valid inproc only */

unsigned long  __RPC_USER
HWND_UserSize(
    unsigned long *,
    unsigned long,
    HWND          * );

unsigned char *  __RPC_USER
HWND_UserMarshal(
    unsigned long *,
    unsigned char *,
    HWND          * );

unsigned char *  __RPC_USER
HWND_UserUnmarshal(
    unsigned long *,
    unsigned char *,
    HWND          * );

void  __RPC_USER
HWND_UserFree(
    unsigned long *,
    HWND          * );

unsigned long  __RPC_USER
HACCEL_UserSize(
    unsigned long *,
    unsigned long,
    HACCEL        * );

unsigned char *  __RPC_USER
HACCEL_UserMarshal(
    unsigned long *,
    unsigned char *,
    HACCEL        * );

unsigned char *  __RPC_USER
HACCEL_UserUnmarshal(
    unsigned long *,
    unsigned char *,
    HACCEL        * );

void  __RPC_USER
HACCEL_UserFree(
    unsigned long *,
    HACCEL        * );

unsigned long  __RPC_USER
HMENU_UserSize(
    unsigned long *,
    unsigned long,
    HMENU         * );

unsigned char *  __RPC_USER
HMENU_UserMarshal(
    unsigned long *,
    unsigned char *,
    HMENU         * );

unsigned char *  __RPC_USER
HMENU_UserUnmarshal(
    unsigned long *,
    unsigned char *,
    HMENU         * );

void  __RPC_USER
HMENU_UserFree(
    unsigned long *,
    HMENU         * );

unsigned long  __RPC_USER
HBRUSH_UserSize(
    unsigned long *,
    unsigned long,
    HBRUSH        * );

unsigned char *  __RPC_USER
HBRUSH_UserMarshal(
    unsigned long * pFlags,
    __out unsigned char * pBuffer,
    HBRUSH        *  pH);

unsigned char *  __RPC_USER
HBRUSH_UserUnmarshal(
    unsigned long * pFlags,
    __in unsigned char * pBuffer,
    HBRUSH        *  pH);

void  __RPC_USER
HBRUSH_UserFree(
    unsigned long *,
    HBRUSH        * );

// ----------------------------------------------------------------------------
//
//  The NDR64 versions of the same routines.
//  Make them available on 32b and 64b platforms.
//

unsigned long  __RPC_USER
HGLOBAL_UserSize64(
    unsigned long *,
    unsigned long,
    HGLOBAL       * );

unsigned char *  __RPC_USER
HGLOBAL_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HGLOBAL       * );

unsigned char *  __RPC_USER
HGLOBAL_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HGLOBAL       * );

void  __RPC_USER
HGLOBAL_UserFree64(
    unsigned long *,
    HGLOBAL       * );

unsigned long  __RPC_USER
HBITMAP_UserSize64(
    unsigned long *,
    unsigned long,
    HBITMAP       * );

unsigned char *  __RPC_USER
HBITMAP_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HBITMAP       * );

unsigned char *  __RPC_USER
HBITMAP_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HBITMAP       * );

void  __RPC_USER
HBITMAP_UserFree64(
    unsigned long *,
    HBITMAP       * );

unsigned long  __RPC_USER
HENHMETAFILE_UserSize64(
    unsigned long *,
    unsigned long,
    HENHMETAFILE  * );

unsigned char *  __RPC_USER
HENHMETAFILE_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HENHMETAFILE  * );

unsigned char *  __RPC_USER
HENHMETAFILE_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HENHMETAFILE  * );

void  __RPC_USER
HENHMETAFILE_UserFree64(
    unsigned long *,
    HENHMETAFILE  * );

unsigned long  __RPC_USER
HMETAFILE_UserSize64(
    unsigned long *,
    unsigned long,
    HMETAFILE     * );

unsigned char *  __RPC_USER
HMETAFILE_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HMETAFILE     * );

unsigned char *  __RPC_USER
HMETAFILE_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HMETAFILE     * );

void __RPC_USER
HMETAFILE_UserFree64(
    unsigned long *,
    HMETAFILE     * );

unsigned long  __RPC_USER
HMETAFILEPICT_UserSize64(
    unsigned long *,
    unsigned long,
    HMETAFILEPICT * );

unsigned char *  __RPC_USER
HMETAFILEPICT_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HMETAFILEPICT * );

unsigned char *  __RPC_USER
HMETAFILEPICT_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HMETAFILEPICT * );

void __RPC_USER
HMETAFILEPICT_UserFree64(
    unsigned long *,
    HMETAFILEPICT * );

unsigned long  __RPC_USER
HPALETTE_UserSize64(
    unsigned long *,
    unsigned long,
    HPALETTE      * );

unsigned char *  __RPC_USER
HPALETTE_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HPALETTE      * );

unsigned char *  __RPC_USER
HPALETTE_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HPALETTE      * );

void __RPC_USER
HPALETTE_UserFree64(
    unsigned long *,
    HPALETTE      * );

unsigned long  __RPC_USER
STGMEDIUM_UserSize64(
    unsigned long *,
    unsigned long,
    STGMEDIUM     * );

unsigned char *  __RPC_USER
STGMEDIUM_UserMarshal64(
    unsigned long *,
    unsigned char *,
    STGMEDIUM     * );

unsigned char *  __RPC_USER
STGMEDIUM_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    STGMEDIUM     * );

void __RPC_USER
STGMEDIUM_UserFree64(
    unsigned long *,
    STGMEDIUM     * );

unsigned long  __RPC_USER
SNB_UserSize64(
    unsigned long *,
    unsigned long,
    SNB           * );

unsigned char *  __RPC_USER
SNB_UserMarshal64(
    unsigned long *,
    unsigned char *,
    SNB           * );

unsigned char *  __RPC_USER
SNB_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    SNB           * );

void  __RPC_USER  
SNB_UserFree64(     
    unsigned long *, 
    SNB * ); 

unsigned long  __RPC_USER  
CLIPFORMAT_UserSize64(     
    unsigned long * , 
    unsigned long   , 
    CLIPFORMAT * );

unsigned char * __RPC_USER  
CLIPFORMAT_UserMarshal64(  
    unsigned long *, 
    unsigned char *, 
    CLIPFORMAT * );

unsigned char * __RPC_USER  
CLIPFORMAT_UserUnmarshal64(
    unsigned long *, 
    unsigned char *, 
    CLIPFORMAT * );

void  __RPC_USER  
CLIPFORMAT_UserFree64(     
    unsigned long * , 
    CLIPFORMAT * );

unsigned long  __RPC_USER  
HDC_UserSize64(
    unsigned long *, 
    unsigned long  , 
    HDC * );

unsigned char * __RPC_USER  
HDC_UserMarshal64(  
    unsigned long *, 
    unsigned char * , 
    HDC * );

unsigned char * __RPC_USER  
HDC_UserUnmarshal64(
    unsigned long *, 
    unsigned char * , 
    HDC * );

void  __RPC_USER  
HDC_UserFree64(  
    unsigned long *, 
    HDC * );

unsigned long  __RPC_USER  
HICON_UserSize64(     
    unsigned long *, 
    unsigned long  , 
    HICON * );

unsigned char * __RPC_USER  
HICON_UserMarshal64(  
    unsigned long *, 
    unsigned char *, 
    HICON * );

unsigned char * __RPC_USER  
HICON_UserUnmarshal64(
    unsigned long *, 
    unsigned char *, 
    HICON * );

void  __RPC_USER  
HICON_UserFree64(     
    unsigned long *, 
    HICON * );

/* OLE automation Data Type support */

unsigned long  __RPC_USER
BSTR_UserSize64(
    unsigned long *,
    unsigned long,
    BSTR          * );

unsigned char *  __RPC_USER
BSTR_UserMarshal64(
    unsigned long *,
    unsigned char *,
    BSTR          * );

unsigned char *  __RPC_USER
BSTR_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    BSTR          * );

void  __RPC_USER
BSTR_UserFree64(
    unsigned long *,
    BSTR          * );

unsigned long  __RPC_USER
LPSAFEARRAY_UserSize64(
    unsigned long *,
    unsigned long,
    LPSAFEARRAY          * );

unsigned char *  __RPC_USER
LPSAFEARRAY_UserMarshal64(
    unsigned long *,
    unsigned char *,
    LPSAFEARRAY   * );

unsigned char *  __RPC_USER
LPSAFEARRAY_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    LPSAFEARRAY   * );

void  __RPC_USER
LPSAFEARRAY_UserFree64(
    unsigned long *,
    LPSAFEARRAY   * );


unsigned long  __RPC_USER
VARIANT_UserSize64(
    unsigned long *,
    unsigned long,
    VARIANT       * );

unsigned char *  __RPC_USER
VARIANT_UserMarshal64(
    unsigned long *,
    unsigned char *,
    VARIANT       * );

unsigned char *  __RPC_USER
VARIANT_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    VARIANT       * );

void  __RPC_USER
VARIANT_UserFree64(
    unsigned long *,
    VARIANT       * );


unsigned long  __RPC_USER
EXCEPINFO_UserSize64(
    unsigned long *,
    unsigned long,
    EXCEPINFO     * );

unsigned char *  __RPC_USER
EXCEPINFO_UserMarshal64(
    unsigned long *,
    unsigned char *,
    EXCEPINFO     * );

unsigned char *  __RPC_USER
EXCEPINFO_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    EXCEPINFO     * );

void  __RPC_USER
EXCEPINFO_UserFree64(
    unsigned long *,
    EXCEPINFO     * );

unsigned long  __RPC_USER
DISPPARAMS_UserSize64(
    unsigned long *,
    unsigned long,
    DISPPARAMS    * );

unsigned char *  __RPC_USER
DISPPARAMS_UserMarshal64(
    unsigned long *,
    unsigned char *,
    DISPPARAMS    * );

unsigned char *  __RPC_USER
DISPPARAMS_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    DISPPARAMS    * );

void  __RPC_USER
DISPPARAMS_UserFree64(
    unsigned long *,
    DISPPARAMS    * );

/* Other types: valid inproc only */

unsigned long  __RPC_USER
HWND_UserSize64(
    unsigned long *,
    unsigned long,
    HWND          * );

unsigned char *  __RPC_USER
HWND_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HWND          * );

unsigned char *  __RPC_USER
HWND_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HWND          * );

void  __RPC_USER
HWND_UserFree64(
    unsigned long *,
    HWND          * );

unsigned long  __RPC_USER
HACCEL_UserSize64(
    unsigned long *,
    unsigned long,
    HACCEL        * );

unsigned char *  __RPC_USER
HACCEL_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HACCEL        * );

unsigned char *  __RPC_USER
HACCEL_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HACCEL        * );

void  __RPC_USER
HACCEL_UserFree64(
    unsigned long *,
    HACCEL        * );

unsigned long  __RPC_USER
HMENU_UserSize64(
    unsigned long *,
    unsigned long,
    HMENU         * );

unsigned char *  __RPC_USER
HMENU_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HMENU         * );

unsigned char *  __RPC_USER
HMENU_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HMENU         * );

void  __RPC_USER
HMENU_UserFree64(
    unsigned long *,
    HMENU         * );

unsigned long  __RPC_USER
HBRUSH_UserSize64(
    unsigned long *,
    unsigned long,
    HBRUSH        * );

unsigned char *  __RPC_USER
HBRUSH_UserMarshal64(
    unsigned long *,
    unsigned char *,
    HBRUSH        * );

unsigned char *  __RPC_USER
HBRUSH_UserUnmarshal64(
    unsigned long *,
    unsigned char *,
    HBRUSH        * );

void  __RPC_USER
HBRUSH_UserFree64(
    unsigned long *,
    HBRUSH        * );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcproxy.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcproxy.h

Abstract:

    Definitions for rpc proxy  stubs.

Compiler switches:

    -DREGISTER_PROXY_DLL
        Generates DllMain, DllRegisterServer, and DllUnregisterServer functions
        for automatically registering a proxy DLL.

    -DPROXY_CLSID=clsid
        Specifies a class ID to be used by the proxy DLL.

    -DPROXY_CLSID_IS={0x6f11fe5c,0x2fc5,0x101b,{0x9e,0x45,0x00,0x00,0x0b,0x65,0xc7,0xef}}
        Specifies the value of the class ID to be used by the proxy DLL.

    -DENTRY_PREFIX=<prefix>
        String to be prepended on all the DllGetClassObject etc routines
        in dlldata.c.  This includes: DllGetClassObject, DllCanUnloadNow
        and DllMain, DllRegisterServer, and DllUnregisterServer.

    -DNT35_STRICT
        Specifies that the target platform is Windows NT 3.5. This switch disables
        the new functions added after the Windows NT 3.5 release.

--*/

// This version of the rpcndr.h file corresponds to MIDL version 5.0.+
// used with NT5 beta1+ env from build #1700 on.

#ifndef __RPCPROXY_H_VERSION__
#define __RPCPROXY_H_VERSION__      ( 475 )
#endif // __RPCPROXY_H_VERSION__

#if !defined(_KRPCENV_)

#ifndef __RPCPROXY_H__
#define __RPCPROXY_H__
#if _MSC_VER > 1000
#pragma once
#endif

#define __midl_proxy

#ifdef __REQUIRED_RPCPROXY_H_VERSION__
    #if ( __RPCPROXY_H_VERSION__ < __REQUIRED_RPCPROXY_H_VERSION__ )
        #error incorrect <rpcproxy.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif

// If this is the first file included __RPC_WIN64__ is not defined yet.
#if defined(_M_IA64) || defined(_M_AMD64)
#include <pshpack8.h>
#endif

#include <basetsd.h>

#ifdef UNDER_CE
// CEBUGBUG!  For some reason we get bogus compiler complaints in proxy's
// about generated fcn pIIDLookupRtn in struct below not having valid 
// sig unless we include windows.h 1st.
#include <windows.h>
#endif // UNDER_CE

#ifndef INC_OLE2
#define INC_OLE2
#endif

#if defined(WIN32) || defined(_M_AMD64)

//We need to define REFIID, REFCLSID, REFGUID, & REFFMTID here so that the
//proxy code won't get the const GUID *const definition.
#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#if defined(__cplusplus)
extern "C"
{
#endif

// forward declarations
struct tagCInterfaceStubVtbl;
struct tagCInterfaceProxyVtbl;

typedef struct tagCInterfaceStubVtbl *  PCInterfaceStubVtblList;
typedef struct tagCInterfaceProxyVtbl *  PCInterfaceProxyVtblList;
typedef const char *                    PCInterfaceName;
typedef int __stdcall IIDLookupRtn( const IID * pIID, int * pIndex );
typedef IIDLookupRtn * PIIDLookup;

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4610) // struct can never be instantiated - user defined constructor required
#pragma warning(disable:4510) // default constructor could not be generated
#pragma warning(disable:4512) // assignment operator could not be generated
#endif

// pointers to arrays of CInterfaceProxyVtbl's and CInterfaceStubVtbls
typedef struct tagProxyFileInfo
{
    const PCInterfaceProxyVtblList *pProxyVtblList;
    const PCInterfaceStubVtblList  *pStubVtblList;
    const PCInterfaceName *         pNamesArray;
    const IID **                    pDelegatedIIDs;
    const PIIDLookup                pIIDLookupRtn;
    unsigned short                  TableSize;
    unsigned short                  TableVersion;
    const IID **                    pAsyncIIDLookup;
    LONG_PTR                        Filler2;
    LONG_PTR                        Filler3;
    LONG_PTR                        Filler4;
}ProxyFileInfo;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

// extended info with list of interface names
typedef ProxyFileInfo ExtendedProxyFileInfo;

#include <rpc.h>
#include <rpcndr.h>
#include <string.h>
#include <memory.h>

typedef struct tagCInterfaceProxyHeader
{
    //
    // New fields should be added here, at the beginning of the structure.
    //
#ifdef USE_STUBLESS_PROXY
    const void *    pStublessProxyInfo;
#endif
    const IID *     piid;
} CInterfaceProxyHeader;

// Macro used for ANSI compatible stubs.

#define CINTERFACE_PROXY_VTABLE( n )  \
struct \
{                                     \
    CInterfaceProxyHeader header;     \
    void *Vtbl[ n ];                  \
}

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable:4200 )
typedef struct tagCInterfaceProxyVtbl
{
    CInterfaceProxyHeader header;
#if defined( _MSC_VER )
    void *Vtbl[];
#else
    void *Vtbl[1];
#endif
} CInterfaceProxyVtbl;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default:4200 )
#endif

typedef
void
(__RPC_STUB * PRPC_STUB_FUNCTION) (
    IRpcStubBuffer          *   This,
    IRpcChannelBuffer       *   _pRpcChannelBuffer,
    PRPC_MESSAGE                _pRpcMessage,
    DWORD *pdwStubPhase);

typedef struct tagCInterfaceStubHeader
{
    //New fields should be added here, at the beginning of the structure.
    const IID               *   piid;
    const MIDL_SERVER_INFO  *   pServerInfo;
    unsigned long               DispatchTableCount;
    const PRPC_STUB_FUNCTION *  pDispatchTable;
} CInterfaceStubHeader;

typedef struct tagCInterfaceStubVtbl
{
    CInterfaceStubHeader        header;
    IRpcStubBufferVtbl          Vtbl;
} CInterfaceStubVtbl;

typedef struct tagCStdStubBuffer
{
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
} CStdStubBuffer;

typedef struct tagCStdPSFactoryBuffer
{
    const IPSFactoryBufferVtbl  *   lpVtbl;
    long                            RefCount;
    const ProxyFileInfo **          pProxyFileList;
    long                            Filler1;  //Reserved for future use.
} CStdPSFactoryBuffer;

RPCRTAPI
void
RPC_ENTRY
NdrProxyInitialize(
    void *              This,
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    unsigned int        ProcNum );

RPCRTAPI
void
RPC_ENTRY
NdrProxyGetBuffer(
    void *              This,
    PMIDL_STUB_MESSAGE pStubMsg);

RPCRTAPI
void
RPC_ENTRY
NdrProxySendReceive(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

RPCRTAPI
void
RPC_ENTRY
NdrProxyFreeBuffer(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrProxyErrorHandler(
    DWORD dwExceptionCode);

RPCRTAPI
void
RPC_ENTRY
NdrStubInitialize(
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer);

RPCRTAPI
void
RPC_ENTRY
NdrStubInitializePartial(
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer,
    unsigned long       RequestedBufferSize);

void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD             * pdwStubPhase);

RPCRTAPI
void
RPC_ENTRY
NdrStubGetBuffer(
    IRpcStubBuffer *    This,
    IRpcChannelBuffer * pRpcChannelBuffer,
    PMIDL_STUB_MESSAGE  pStubMsg);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrStubErrorHandler(
    DWORD               dwExceptionCode);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(
    IRpcStubBuffer  *   This,
    REFIID              riid,
    void            **  ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(
    IRpcStubBuffer *    This);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_Release(
    IRpcStubBuffer *    This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer_Release(
    IRpcStubBuffer *    This,
    IPSFactoryBuffer *  pPSF);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(
    IRpcStubBuffer *    This,
    IUnknown *          pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(
    IRpcStubBuffer *    This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(
    IRpcStubBuffer  *   This,
    RPCOLEMESSAGE   *   pRpcMsg,
    IRpcChannelBuffer * pRpcChannelBuffer);

IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(
    IRpcStubBuffer  *   This,
    REFIID riid);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(
    IRpcStubBuffer  *   This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(
    IRpcStubBuffer  *   This,
    void **ppv);

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(
    IRpcStubBuffer  *   This,
    void *pv);

#define CStdStubBuffer_METHODS \
    CStdStubBuffer_QueryInterface,\
    CStdStubBuffer_AddRef, \
    CStdStubBuffer_Release, \
    CStdStubBuffer_Connect, \
    CStdStubBuffer_Disconnect, \
    CStdStubBuffer_Invoke, \
    CStdStubBuffer_IsIIDSupported, \
    CStdStubBuffer_CountRefs, \
    CStdStubBuffer_DebugServerQueryInterface, \
    CStdStubBuffer_DebugServerRelease

#define CStdAsyncStubBuffer_METHODS              0,0,0,0,0,0,0,0,0,0
#define CStdAsyncStubBuffer_DELEGATING_METHODS   0,0,0,0,0,0,0,0,0,0

//+-------------------------------------------------------------------------
//
//  Macro definitions for the proxy file
//
//--------------------------------------------------------------------------

#define IID_GENERIC_CHECK_IID(name,pIID,index) memcmp( pIID, name##_ProxyVtblList[ index ]->header.piid, 16 )

#define IID_BS_LOOKUP_SETUP     int result, low=-1;

#define IID_BS_LOOKUP_INITIAL_TEST(name, sz, split)   \
    result = name##_CHECK_IID( split );               \
    if ( result > 0 )                                 \
        { low = sz - split; }                         \
    else if ( !result )                               \
        { low = split; goto found_label; }

#define IID_BS_LOOKUP_NEXT_TEST(name, split )      \
        result = name##_CHECK_IID( low + split );  \
        if ( result >= 0 )                         \
        { low = low + split; if ( !result ) goto found_label; }

#define IID_BS_LOOKUP_RETURN_RESULT(name, sz, index )  \
    low = low + 1;                                     \
    if (low >= sz)                                     \
        goto not_found_label;                          \
    result = name##_CHECK_IID( low );                  \
    if (result)                                        \
        goto not_found_label;                          \
    found_label: (index) = low; return 1;              \
    not_found_label: return 0;

//+-------------------------------------------------------------------------
//
//  Macro and routine definitions for the dlldata file
//
//--------------------------------------------------------------------------

/****************************************************************************
 * Proxy Dll APIs
 ****************************************************************************/

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllGetClassObject (
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllCanUnloadNow(
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

// if the user specified a routine prefix, pick it up...
//     if not, add nothing

#ifndef ENTRY_PREFIX

#ifndef DllMain
#define DISABLE_THREAD_LIBRARY_CALLS(x) DisableThreadLibraryCalls(x)
#endif

#define ENTRY_PREFIX
#define DLLREGISTERSERVER_ENTRY DllRegisterServer
#define DLLUNREGISTERSERVER_ENTRY DllUnregisterServer
#define DLLMAIN_ENTRY DllMain

#define DLLGETCLASSOBJECT_ENTRY DllGetClassObject
#define DLLCANUNLOADNOW_ENTRY DllCanUnloadNow

#else   // ENTRY_PREFIX

#define __rpc_macro_expand2(a, b) a##b
#define __rpc_macro_expand(a, b) __rpc_macro_expand2(a,b)
#define DLLREGISTERSERVER_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllRegisterServer)
#define DLLUNREGISTERSERVER_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllUnregisterServer)
#define DLLMAIN_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllMain)

#define DLLGETCLASSOBJECT_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllGetClassObject)
#define DLLCANUNLOADNOW_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllCanUnloadNow)

#endif  // ENTRY_PREFIX

#ifndef DISABLE_THREAD_LIBRARY_CALLS
#define DISABLE_THREAD_LIBRARY_CALLS(x)
#endif

/*************************************************************************
The following new functions were added after the Windows NT 3.5 release.
*************************************************************************/

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllRegisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllUnregisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid);

#define REGISTER_PROXY_DLL_ROUTINES(pProxyFileList, pClsID) \
    \
    HINSTANCE hProxyDll = 0; \
    \
    /*DllMain saves the DLL module handle for later use by DllRegisterServer */ \
    BOOL WINAPI DLLMAIN_ENTRY( \
        HINSTANCE  hinstDLL, \
        DWORD  fdwReason, \
        LPVOID  lpvReserved) \
    { \
        UNREFERENCED_PARAMETER(lpvReserved); \
        if(fdwReason == DLL_PROCESS_ATTACH) \
            { \
            hProxyDll = hinstDLL; \
            DISABLE_THREAD_LIBRARY_CALLS(hinstDLL); \
            } \
        return TRUE; \
    } \
    \
    /* DllRegisterServer registers the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLREGISTERSERVER_ENTRY() \
    { \
        return NdrDllRegisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }  \
    \
    /* DllUnregisterServer unregisters the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLUNREGISTERSERVER_ENTRY() \
    { \
        return NdrDllUnregisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }

//Delegation support.
#define STUB_FORWARDING_FUNCTION        NdrStubForwardingFunction

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_Release(IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer2_Release(IRpcStubBuffer *This,IPSFactoryBuffer * pPSF);

#define CStdStubBuffer_DELEGATING_METHODS 0, 0, CStdStubBuffer2_Release, 0, 0, 0, 0, 0, 0, 0

/*************************************************************************
End of new functions.
*************************************************************************/

// PROXY_CLSID has precedence over PROXY_CLSID_IS

#ifdef PROXY_CLSID

#define CLSID_PSFACTORYBUFFER extern CLSID PROXY_CLSID;

#else // PROXY_CLSID

#ifdef PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER const CLSID CLSID_PSFactoryBuffer = PROXY_CLSID_IS;
#define PROXY_CLSID     CLSID_PSFactoryBuffer
#else // PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER
#endif //PROXY_CLSID_IS

#endif //PROXY_CLSID

// if the user specified an override for the class id, it is
// PROXY_CLSID at this point

#ifndef PROXY_CLSID
#define GET_DLL_CLSID   \
    ( aProxyFileList[0]->pStubVtblList[0] != 0 ? \
    aProxyFileList[0]->pStubVtblList[0]->header.piid : 0)
#else  //PROXY_CLSID
#define GET_DLL_CLSID   &PROXY_CLSID
#endif //PROXY_CLSID



#define EXTERN_PROXY_FILE(name) \
    EXTERN_C const ProxyFileInfo name##_ProxyFileInfo;

#define PROXYFILE_LIST_START    \
    const ProxyFileInfo  *  aProxyFileList[]    = {

#define REFERENCE_PROXY_FILE(name)  \
    & name##_ProxyFileInfo

#define PROXYFILE_LIST_END      \
    0 };

// return pointers to the class information

#define DLLDATA_GETPROXYDLLINFO(pPFList,pClsid) \
    void RPC_ENTRY GetProxyDllInfo( const ProxyFileInfo*** pInfo, const CLSID ** pId )  \
        {   \
        *pInfo  = pPFList;  \
        *pId    = pClsid;   \
        };

// ole entry points:
#define DLLGETCLASSOBJECTROUTINE(pPFlist, pClsid,pFactory)    \
 HRESULT STDAPICALLTYPE DLLGETCLASSOBJECT_ENTRY ( \
     REFCLSID rclsid, \
     REFIID riid, \
     void ** ppv ) \
        { \
        return  \
            NdrDllGetClassObject(rclsid,riid,ppv,pPFlist,pClsid,pFactory ); \
        }

#define DLLCANUNLOADNOW(pFactory)   \
 HRESULT STDAPICALLTYPE DLLCANUNLOADNOW_ENTRY()    \
    {   \
    return NdrDllCanUnloadNow( pFactory );    \
    }


#define DLLDUMMYPURECALL    \
    void __cdecl _purecall(void)    \
        {   \
        }

#define CSTDSTUBBUFFERRELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }   \

#ifdef PROXY_DELEGATION
#define CSTDSTUBBUFFER2RELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer2_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer2_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }
#else
#define CSTDSTUBBUFFER2RELEASE(pFactory)
#endif //PROXY_DELEGATION


#ifdef REGISTER_PROXY_DLL
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID ) REGISTER_PROXY_DLL_ROUTINES(pProxyFileList,pClsID )
#else
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID )
#endif //REGISTER_PROXY_DLL


// the dll entry points that must be defined
#define DLLDATA_ROUTINES(pProxyFileList,pClsID )    \
    \
    CLSID_PSFACTORYBUFFER \
    \
    CStdPSFactoryBuffer       gPFactory = {0,0,0,0};  \
    \
    DLLDATA_GETPROXYDLLINFO(pProxyFileList,pClsID) \
    \
    DLLGETCLASSOBJECTROUTINE(pProxyFileList,pClsID,&gPFactory)    \
    \
    DLLCANUNLOADNOW(&gPFactory)   \
    \
    CSTDSTUBBUFFERRELEASE(&gPFactory)   \
    \
    CSTDSTUBBUFFER2RELEASE(&gPFactory) \
    \
    DLLDUMMYPURECALL    \
    \
    DLLREGISTRY_ROUTINES(pProxyFileList, pClsID) \
    \

    // more code goes here...


#define DLLDATA_STANDARD_ROUTINES   \
    DLLDATA_ROUTINES( (const ProxyFileInfo**) pProxyFileList, &CLSID_PSFactoryBuffer )  \

#if defined(__cplusplus)
} // extern "C"
#endif

#endif // WIN32 or _WIN64_

#if defined(_M_IA64) || defined(_M_AMD64)
#include <poppack.h>
#endif

#endif // __RPCPROXY_H__

#endif // _KRPCENV_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\safeocx.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:15:46 2007
 */
/* Compiler settings for ..\safeocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __safeocx_h__
#define __safeocx_h__

/* Forward Declarations */ 

#ifndef __IActiveXSafetyProvider_FWD_DEFINED__
#define __IActiveXSafetyProvider_FWD_DEFINED__
typedef interface IActiveXSafetyProvider IActiveXSafetyProvider;
#endif 	/* __IActiveXSafetyProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "urlmon.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_safeocx_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//--------------------------------------------------------------------------

#pragma comment(lib,"uuid.lib")

DEFINE_GUID(CLSID_IActiveXSafetyProvider, 0xaaf8c6ce, 0xf972, 0x11d0, 0x97, 0xeb, 0x00, 0xaa, 0x00, 0x61, 0x53, 0x33);
DEFINE_GUID(IID_IActiveXSafetyProvider,   0x69ff5101, 0xfc63, 0x11d0, 0x97, 0xeb, 0x00, 0xaa, 0x00, 0x61, 0x53, 0x33);


extern RPC_IF_HANDLE __MIDL_itf_safeocx_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_safeocx_0000_v0_0_s_ifspec;

#ifndef __IActiveXSafetyProvider_INTERFACE_DEFINED__
#define __IActiveXSafetyProvider_INTERFACE_DEFINED__

/* interface IActiveXSafetyProvider */
/* [local][unique][uuid][object] */ 

typedef /* [unique] */ IActiveXSafetyProvider __RPC_FAR *LPACTIVEXSAFETYPROVIDER;


EXTERN_C const IID IID_IActiveXSafetyProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69ff5101-fc63-11d0-97eb-00aa00615333")
    IActiveXSafetyProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TreatControlAsUntrusted( 
            /* [in] */ BOOL fTreatAsTUntrusted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsControlUntrusted( 
            /* [out] */ BOOL __RPC_FAR *pfIsUntrusted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecurityManager( 
            /* [in] */ IInternetSecurityManager __RPC_FAR *pSecurityManager) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentURLA( 
            /* [in] */ LPCSTR szDocumentURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentURLW( 
            /* [in] */ LPCWSTR szDocumentURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetToDefaults( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SafeDllRegisterServerA( 
            /* [in] */ LPCSTR szServerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SafeDllRegisterServerW( 
            /* [in] */ LPCWSTR szServerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SafeDllUnregisterServerA( 
            /* [in] */ LPCSTR szServerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SafeDllUnregisterServerW( 
            /* [in] */ LPCWSTR szServerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SafeGetClassObject( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ LPVOID reserved,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SafeCreateInstance( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPUNKNOWN pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *pObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveXSafetyProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveXSafetyProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveXSafetyProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TreatControlAsUntrusted )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ BOOL fTreatAsTUntrusted);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsControlUntrusted )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsUntrusted);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecurityManager )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ IInternetSecurityManager __RPC_FAR *pSecurityManager);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDocumentURLA )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ LPCSTR szDocumentURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDocumentURLW )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ LPCWSTR szDocumentURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetToDefaults )( 
            IActiveXSafetyProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SafeDllRegisterServerA )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ LPCSTR szServerName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SafeDllRegisterServerW )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ LPCWSTR szServerName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SafeDllUnregisterServerA )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ LPCSTR szServerName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SafeDllUnregisterServerW )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ LPCWSTR szServerName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SafeGetClassObject )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ LPVOID reserved,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SafeCreateInstance )( 
            IActiveXSafetyProvider __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPUNKNOWN pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *pObj);
        
        END_INTERFACE
    } IActiveXSafetyProviderVtbl;

    interface IActiveXSafetyProvider
    {
        CONST_VTBL struct IActiveXSafetyProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveXSafetyProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveXSafetyProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveXSafetyProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveXSafetyProvider_TreatControlAsUntrusted(This,fTreatAsTUntrusted)	\
    (This)->lpVtbl -> TreatControlAsUntrusted(This,fTreatAsTUntrusted)

#define IActiveXSafetyProvider_IsControlUntrusted(This,pfIsUntrusted)	\
    (This)->lpVtbl -> IsControlUntrusted(This,pfIsUntrusted)

#define IActiveXSafetyProvider_SetSecurityManager(This,pSecurityManager)	\
    (This)->lpVtbl -> SetSecurityManager(This,pSecurityManager)

#define IActiveXSafetyProvider_SetDocumentURLA(This,szDocumentURL)	\
    (This)->lpVtbl -> SetDocumentURLA(This,szDocumentURL)

#define IActiveXSafetyProvider_SetDocumentURLW(This,szDocumentURL)	\
    (This)->lpVtbl -> SetDocumentURLW(This,szDocumentURL)

#define IActiveXSafetyProvider_ResetToDefaults(This)	\
    (This)->lpVtbl -> ResetToDefaults(This)

#define IActiveXSafetyProvider_SafeDllRegisterServerA(This,szServerName)	\
    (This)->lpVtbl -> SafeDllRegisterServerA(This,szServerName)

#define IActiveXSafetyProvider_SafeDllRegisterServerW(This,szServerName)	\
    (This)->lpVtbl -> SafeDllRegisterServerW(This,szServerName)

#define IActiveXSafetyProvider_SafeDllUnregisterServerA(This,szServerName)	\
    (This)->lpVtbl -> SafeDllUnregisterServerA(This,szServerName)

#define IActiveXSafetyProvider_SafeDllUnregisterServerW(This,szServerName)	\
    (This)->lpVtbl -> SafeDllUnregisterServerW(This,szServerName)

#define IActiveXSafetyProvider_SafeGetClassObject(This,rclsid,dwClsContext,reserved,riid,ppObj)	\
    (This)->lpVtbl -> SafeGetClassObject(This,rclsid,dwClsContext,reserved,riid,ppObj)

#define IActiveXSafetyProvider_SafeCreateInstance(This,rclsid,pUnkOuter,dwClsContext,riid,pObj)	\
    (This)->lpVtbl -> SafeCreateInstance(This,rclsid,pUnkOuter,dwClsContext,riid,pObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_TreatControlAsUntrusted_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ BOOL fTreatAsTUntrusted);


void __RPC_STUB IActiveXSafetyProvider_TreatControlAsUntrusted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_IsControlUntrusted_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsUntrusted);


void __RPC_STUB IActiveXSafetyProvider_IsControlUntrusted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_SetSecurityManager_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ IInternetSecurityManager __RPC_FAR *pSecurityManager);


void __RPC_STUB IActiveXSafetyProvider_SetSecurityManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_SetDocumentURLA_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ LPCSTR szDocumentURL);


void __RPC_STUB IActiveXSafetyProvider_SetDocumentURLA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_SetDocumentURLW_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ LPCWSTR szDocumentURL);


void __RPC_STUB IActiveXSafetyProvider_SetDocumentURLW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_ResetToDefaults_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This);


void __RPC_STUB IActiveXSafetyProvider_ResetToDefaults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_SafeDllRegisterServerA_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ LPCSTR szServerName);


void __RPC_STUB IActiveXSafetyProvider_SafeDllRegisterServerA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_SafeDllRegisterServerW_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ LPCWSTR szServerName);


void __RPC_STUB IActiveXSafetyProvider_SafeDllRegisterServerW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_SafeDllUnregisterServerA_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ LPCSTR szServerName);


void __RPC_STUB IActiveXSafetyProvider_SafeDllUnregisterServerA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_SafeDllUnregisterServerW_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ LPCWSTR szServerName);


void __RPC_STUB IActiveXSafetyProvider_SafeDllUnregisterServerW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_SafeGetClassObject_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ LPVOID reserved,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppObj);


void __RPC_STUB IActiveXSafetyProvider_SafeGetClassObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveXSafetyProvider_SafeCreateInstance_Proxy( 
    IActiveXSafetyProvider __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LPUNKNOWN pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *pObj);


void __RPC_STUB IActiveXSafetyProvider_SafeCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveXSafetyProvider_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rtlmisc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _RTLMISC_H_
#define _RTLMISC_H_

#pragma once

#include <wtypes.h>
#include <wdm.h>
#include <types.h>

typedef struct _OSVERSIONINFOEXA {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;

typedef struct _OSVERSIONINFOEXW {
    ULONG dwOSVersionInfoSize;
    ULONG dwMajorVersion;
    ULONG dwMinorVersion;
    ULONG dwBuildNumber;
    ULONG dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     // Maintenance string for PSS usage
    USHORT wServicePackMajor;
    USHORT wServicePackMinor;
    USHORT wSuiteMask;
    UCHAR wProductType;
    UCHAR wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
#ifdef UNICODE
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#else
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
#endif // UNICODE

typedef OSVERSIONINFOW RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;

#ifndef GET8
#define GET8(w)             ((ULONG)(((w) >> 8) & 0xff))
#endif

#ifndef GETHI4
#define GETHI4(w)           ((ULONG)(((w) >> 4) & 0xf))
#endif

#ifndef GETLO4
#define GETLO4(w)           ((ULONG)((w) & 0xf))
#endif

//
// Upcase data table
//

extern PUSHORT Nls844UnicodeUpcaseTable;
extern PUSHORT Nls844UnicodeLowercaseTable;

#define TRAVERSE844W(pTable, wch)                                               \
    ( (pTable)[(pTable)[(pTable)[GET8((wch))] + GETHI4((wch))] + GETLO4((wch))] )

#define NLS_UPCASE(wch) (                                                   \
    ((wch) < 'a' ?                                                          \
        (wch)                                                               \
    :                                                                       \
        ((wch) <= 'z' ?                                                     \
            (wch) - ('a'-'A')                                               \
        :                                                                   \
            ((WCHAR)((wch) + TRAVERSE844W(Nls844UnicodeUpcaseTable,(wch)))) \
        )                                                                   \
    )                                                                       \
)

#if 0  //  ntcompat
BOOLEAN
RtlEqualString(
    IN const STRING *String1,
    IN const STRING *String2,
    IN BOOLEAN CaseInSensitive
    );
#endif  //  ntcompat

NTSYSAPI
NTSTATUS
RtlGetVersion(
    OUT  PRTL_OSVERSIONINFOW lpVersionInformation
    );


#if 0
NTSTATUS RtlGUIDFromString(IN PUNICODE_STRING GuidString, OUT GUID *Guid);
#endif
// NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    );

NTSTATUS
RtlStringFromGUID(REFGUID Guid,
				  PUNICODE_STRING GuidString);

NTSTATUS
RtlIntegerToChar (
    __in ULONG Value,
    __in ULONG Base OPTIONAL,
    __in LONG OutputLength,
    __out_ecount(OutputLength) PSZ String
    );

NTSTATUS
RtlIntegerToUnicodeString (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );

#endif  //  _RTLMISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\rpcsal.h ===
/****************************************************************\
*                                                                *
* rpcsal.h - markers for documenting the semantics of RPC APIs   *
*                                                                *
* Version 1.0                                                    *
*                                                                *
* Copyright (c) 2004 Microsoft Corporation. All rights reserved. *
*                                                                *
\****************************************************************/

// -------------------------------------------------------------------------------
// Introduction
//
// rpcsal.h provides a set of annotations to describe how RPC functions use their
// parameters - the assumptions it makes about them, adn the guarantees it makes 
// upon finishing.  These annotations are similar to those found in specstrings.h,
// but are designed to be used by the MIDL compiler when it generates annotations
// enabled header files.
//
// IDL authors do not need to annotate their functions declarations.  The MIDL compiler
// will interpret the IDL directives and use one of the annotations contained 
// in this header.  This documentation is intended to help those trying to  understand 
// the MIDL-generated header files or those who maintain their own copies of these files.
//
// -------------------------------------------------------------------------------
// Differences between rpcsal.h and specstrings.h
// 
// There are a few important differences between the annotations found in rpcsal.h and
// those in specstrings.h:
// 
// 1. [in] parameters are not marked as read-only.  They may be used for scratch space 
// at the server and changes will not affect the client.
// 2. String versions of each macro alleviates the need for a special type definition
//
// -------------------------------------------------------------------------------
// Interpreting RPC Annotations
//
// These annotations are interpreted precisely in the same way as those in specstrings.h.  
// Please refer to that header for information related to general usage in annotations. 
//
// To construct an RPC annotation, concatenate the appropriate value from each category
// along with a leading __RPC_.  A typical annotation looks like "__RPC__in_string".
//
// |----------------------------------------------------------------------------------|
// | RPC Annotations                                                                  |
// |------------|------------|---------|--------|----------|----------|---------------|
// |   Level    |   Usage    |  Size   | Output | Optional |  String  |  Parameters   |
// |------------|------------|---------|--------|----------|----------|---------------|
// | <>         | <>         | <>      | <>     | <>       | <>       | <>            |
// | _deref     | _in        | _ecount | _full  | _opt     | _string  | (size)        |
// | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
// |            | _inout     |         |        |          |          |               |
// |            |            |         |        |          |          |               |
// |------------|------------|---------|--------|----------|----------|---------------|
//
// Level: Describes the buffer pointer's level of indirection from the parameter or
//          return value 'p'.
//
// <>         : p is the buffer pointer.
// _deref     : *p is the buffer pointer. p must not be NULL.
// _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
//                the annotation is ignored.
//
// Usage: Describes how the function uses the buffer.
//
// <>     : The buffer is not accessed. If used on the return value or with _deref, the
//            function will provide the buffer, and it will be uninitialized at exit.
//            Otherwise, the caller must provide the buffer. This should only be used
//            for alloc and free functions.
// _in    : The function will only read from the buffer. The caller must provide the
//            buffer and initialize it. Cannot be used with _deref.
// _out   : The function will only write to the buffer. If used on the return value or
//            with _deref, the function will provide the buffer and initialize it.
//            Otherwise, the caller must provide the buffer, and the function will
//            initialize it.
// _inout : The function may freely read from and write to the buffer. The caller must
//            provide the buffer and initialize it. If used with _deref, the buffer may
//            be reallocated by the function.
//
// Size: Describes the total size of the buffer. This may be less than the space actually
//         allocated for the buffer, in which case it describes the accessible amount.
//
// <>      : No buffer size is given. If the type specifies the buffer size (such as
//             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
//             element long. Must be used with _in, _out, or _inout.
// _ecount : The buffer size is an explicit element count.
// _bcount : The buffer size is an explicit byte count.
//
// Output: Describes how much of the buffer will be initialized by the function. For
//           _inout buffers, this also describes how much is initialized at entry. Omit this
//           category for _in buffers; they must be fully initialized by the caller.
//
// <>    : The type specifies how much is initialized. For instance, a function initializing
//           an LPWSTR must NULL-terminate the string.
// _full : The function initializes the entire buffer.
// _part : The function initializes part of the buffer, and explicitly indicates how much.
//
// Optional: Describes if the buffer itself is optional.
//
// <>   : The pointer to the buffer must not be NULL.
// _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.
//
// String: Describes if the buffer is NULL terminated
//
// <>      : The buffer is not assumed to be NULL terminated
// _string : The buffer is assumed to be NULL terminated once it has been initialized
//
// Parameters: Gives explicit counts for the size and length of the buffer.
//
// <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
// (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
// (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
//                   and _bcount_part.
//
// Notes:
//
// 1. Specifying two buffer annotations on a single parameter results in unspecified behavior
//    (e.g. __RPC__in_bcount(5) __RPC__out_bcount(6)
// 
// 2. The size of the buffer and the amount that has been initialized are separate concepts.  
//    Specify the size using _ecount or _bcount.  Specify the amount that is initialized using 
//    _full, _part, or _string.  As a special case, a single element buffer does not need 
//    _ecount, _bcount, _full, or _part
// 
// 3. The count may be less than the total size of the buffer in which case it describes the 
//    accessible portion. 
// 
// 4. "__RPC__opt" and "__RPC_deref" are not valid annotations.
// 
// 5. The placement of _opt when using _deref is important:
//      __RPC__deref_opt_...      : Input may be NULL
//      __RPC__deref_..._opt      : Output may be NULL
//      __RPC__deref_opt_..._opt  : Both input and output may be NULL
//

#pragma once

#include <specstrings.h>

#ifndef __RPCSAL_H_VERSION__
#define __RPCSAL_H_VERSION__        ( 100 )
#endif // __RPCSAL_H_VERSION__

#ifdef __REQUIRED_RPCSAL_H_VERSION__
    #if ( __RPCSAL_H_VERSION__ < __REQUIRED_RPCSAL_H_VERSION__ )
        #error incorrect <rpcsal.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif


#ifdef  __cplusplus
extern "C" {
#endif  // #ifdef __cplusplus

#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)


// [in]
#define __RPC__in                                   __pre __valid
#define __RPC__in_string                            __RPC__in   __pre __nullterminated
#define __RPC__in_ecount(size)                      __RPC__in __pre __elem_readableTo(size)
#define __RPC__in_ecount_full(size)                 __RPC__in_ecount(size)
#define __RPC__in_ecount_full_string(size)          __RPC__in_ecount_full(size) __pre __nullterminated
#define __RPC__in_ecount_part(size, length)         __RPC__in_ecount(length) __pre __elem_writableTo(size)
#define __RPC__in_ecount_full_opt(size)             __RPC__in_ecount_full(size) __pre __exceptthat  __maybenull
#define __RPC__in_ecount_full_opt_string(size)      __RPC__in_ecount_full_opt(size) __pre __nullterminated
#define __RPC__in_ecount_part_opt(size, length)     __RPC__in_ecount_part(size, length) __pre __exceptthat __maybenull


#define __RPC__deref_in                             __RPC__in __deref __notnull 
#define __RPC__deref_in_string                      __RPC__in   __pre __deref __nullterminated
#define __RPC__deref_in_opt                         __RPC__deref_in __deref __exceptthat __maybenull
#define __RPC__deref_opt_in                         __RPC__in __exceptthat __maybenull 
#define __RPC__deref_opt_in_opt                     __RPC__deref_opt_in  __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_ecount(size)                __RPC__in __pre __deref __elem_readableTo(size)
#define __RPC__deref_in_ecount_part(size, length)   __RPC__deref_in_ecount(size)  __pre __deref __elem_readableTo(length)
#define __RPC__deref_in_ecount_full(size)           __RPC__deref_in_ecount_part(size, size)
#define __RPC__deref_in_ecount_full_opt(size)       __RPC__deref_in_ecount_full(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_ecount_full_opt_string(size) __RPC__deref_in_ecount_full_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_ecount_full_string(size)    __RPC__deref_in_ecount_full(size) __pre __deref __nullterminated
#define __RPC__deref_in_ecount_opt(size)            __RPC__deref_in_ecount(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_ecount_opt_string(size)     __RPC__deref_in_ecount_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_ecount_part_opt(size, length) __RPC__deref_in_ecount_opt(size) __pre __deref __elem_readableTo(length)


// [out]
#define __RPC__out                                  __out
#define __RPC__out_ecount(size)                     __out_ecount(size)  __post  __elem_writableTo(size)
#define __RPC__out_ecount_string(size)              __RPC__out_ecount(size) __post __nullterminated
#define __RPC__out_ecount_part(size, length)        __RPC__out_ecount(size)  __post  __elem_readableTo(length)
#define __RPC__out_ecount_full(size)                __RPC__out_ecount_part(size, size)
#define __RPC__out_ecount_full_string(size)         __RPC__out_ecount_full(size) __post  __nullterminated

// [in,out] 
#define __RPC__inout                                __inout
#define __RPC__inout_string                         __RPC__inout  __pre __nullterminated __post __nullterminated
#define __RPC__inout_ecount(size)                   __inout_ecount(size)
#define __RPC__inout_ecount_part(size, length)      __inout_ecount_part(size, length)
#define __RPC__inout_ecount_full(size)              __RPC__inout_ecount_part(size, size)
#define __RPC__inout_ecount_full_string(size)       __RPC__inout_ecount_full(size) __pre __nullterminated __post __nullterminated

// [in,unique] 
#define __RPC__in_opt                               __RPC__in __pre __exceptthat __maybenull
#define __RPC__in_opt_string                        __RPC__in_opt   __pre __nullterminated
#define __RPC__in_ecount_opt(size)                  __RPC__in_ecount(size) __pre __exceptthat __maybenull
#define __RPC__in_ecount_opt_string(size)           __RPC__in_ecount_opt(size) __pre __nullterminated

// [in,out,unique] 
#define __RPC__inout_opt                            __inout_opt
#define __RPC__inout_ecount_opt(size)               __inout_ecount_opt(size)
#define __RPC__inout_ecount_part_opt(size, length) __inout_ecount_part_opt(size, length)
#define __RPC__inout_ecount_full_opt(size)          __RPC__inout_ecount_part_opt(size, size)
#define __RPC__inout_ecount_full_opt_string(size)   __RPC__inout_ecount_full_opt(size)  __pre __nullterminated __post __nullterminated

// [out] **
#define __RPC__deref_out                            __deref_out
#define __RPC__deref_out_string                     __RPC__deref_out    __post __deref __nullterminated
// Removed "__post __deref __exceptthat __maybenull" so return values from QueryInterface and the like can be trusted without an explicit NULL check.
// This is a temporary fix until midl.exe can be rev'd to produce more accurate annotations.
#define __RPC__deref_out_opt                        __RPC__deref_out
#define __RPC__deref_out_opt_string                 __RPC__deref_out_opt  __post __deref __nullterminated __pre __deref __null
#define __RPC__deref_out_ecount(size)               __deref_out_ecount(size) __post __deref __elem_writableTo(size)
#define __RPC__deref_out_ecount_part(size, length)  __RPC__deref_out_ecount(size) __post __deref __elem_readableTo(length)
#define __RPC__deref_out_ecount_full(size)          __RPC__deref_out_ecount_part(size,size)
#define __RPC__deref_out_ecount_full_string(size)   __RPC__deref_out_ecount_full(size) __post __deref __nullterminated

// [in,out] **, second pointer decoration. 
#define __RPC__deref_inout                          __deref_inout
#define __RPC__deref_inout_string                   __RPC__deref_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_inout_opt                      __deref_inout_opt
#define __RPC__deref_inout_opt_string               __RPC__deref_inout_opt __deref __nullterminated 
#define __RPC__deref_inout_ecount_opt(size)         __deref_inout_ecount_opt(size)
#define __RPC__deref_inout_ecount_part_opt(size, length) __deref_inout_ecount_part_opt(size , length)
#define __RPC__deref_inout_ecount_full_opt(size)    __RPC__deref_inout_ecount_part_opt(size, size)
#define __RPC__deref_inout_ecount_full(size)        __deref_inout_ecount_full(size)
#define __RPC__deref_inout_ecount_full_string(size) __RPC__deref_inout_ecount_full(size) __post __deref __nullterminated
#define __RPC__deref_inout_ecount_full_opt_string(size) __RPC__deref_inout_ecount_full_opt(size) __pre __deref __nullterminated __post __deref __nullterminated


// #define __RPC_out_opt    out_opt is not allowed in rpc

// [in,out,unique] 
#define __RPC__deref_opt_inout                          __deref_opt_inout
#define __RPC__deref_opt_inout_ecount(size)             __deref_opt_inout_ecount(size)
#define __RPC__deref_opt_inout_string                   __RPC__deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_opt_inout_ecount_part(size, length) __deref_opt_inout_ecount_part(size, length)
#define __RPC__deref_opt_inout_ecount_full(size)        __deref_opt_inout_ecount_full(size)
#define __RPC__deref_opt_inout_ecount_full_string(size)  __RPC__deref_opt_inout_ecount_full(size) __pre __deref __nullterminated __post __deref __nullterminated


// We don't need to specify __pre __deref __exceptthat __maybenull : this is default behavior. While this might not hold in SAL 1.1 syntax, SAL team 
// believes it's OK. We can revisit if SAL 1.1 can survive. 
#define __RPC__deref_out_ecount_opt(size)               __RPC__out_ecount(size) __post __deref __exceptthat __maybenull __pre __deref __null 
#define __RPC__deref_out_ecount_part_opt(size, length)  __RPC__deref_out_ecount_part(size, length) __post __deref __exceptthat __maybenull __pre __deref __null
#define __RPC__deref_out_ecount_full_opt(size)          __RPC__deref_out_ecount_part_opt(size, size) __pre __deref __null
#define __RPC__deref_out_ecount_full_opt_string(size)   __RPC__deref_out_ecount_part_opt(size, size) __post __deref __nullterminated __pre __deref __null

#define __RPC__deref_opt_inout_opt                      __deref_opt_inout_opt
#define __RPC__deref_opt_inout_opt_string               __RPC__deref_opt_inout_opt __pre __deref __nullterminated  __post __deref __nullterminated
#define __RPC__deref_opt_inout_ecount_opt(size)         __deref_opt_inout_ecount_opt(size)  
#define __RPC__deref_opt_inout_ecount_part_opt(size, length) __deref_opt_inout_ecount_part_opt(size, length)
#define __RPC__deref_opt_inout_ecount_full_opt(size)    __RPC__deref_opt_inout_ecount_part_opt(size, size)
#define __RPC__deref_opt_inout_ecount_full_opt_string(size)  __RPC__deref_opt_inout_ecount_full_opt(size) __pre __deref __nullterminated __post __deref __nullterminated

#define __RPC_full_pointer                              __maybenull 
#define __RPC_unique_pointer                            __maybenull
#define __RPC_ref_pointer                               __notnull
#define __RPC_string                                    __nullterminated

#define __RPC__range(min,max)                           __range(min,max)
#define __RPC__in_range(min,max)                        __in_range(min,max)

#else   // not prefast

#define __RPC__range(min,max)
#define __RPC__in_range(min,max)

#define __RPC__in           
#define __RPC__in_string
#define __RPC__in_opt_string
#define __RPC__deref_opt_in_opt
#define __RPC__opt_in_opt_string
#define __RPC__in_ecount(size) 
#define __RPC__in_ecount_full(size)
#define __RPC__in_ecount_full_string(size)
#define __RPC__in_ecount_part(size, length)
#define __RPC__in_ecount_full_opt(size)
#define __RPC__in_ecount_full_opt_string(size)
#define __RPC__inout_ecount_full_opt_string(size)
#define __RPC__in_ecount_part_opt(size, length)

#define __RPC__deref_in 
#define __RPC__deref_in_string
#define __RPC__deref_opt_in
#define __RPC__deref_in_opt
#define __RPC__deref_in_ecount(size) 
#define __RPC__deref_in_ecount_part(size, length) 
#define __RPC__deref_in_ecount_full(size) 
#define __RPC__deref_in_ecount_full_opt(size)
#define __RPC__deref_in_ecount_full_string(size)
#define __RPC__deref_in_ecount_full_opt_string(size)
#define __RPC__deref_in_ecount_opt(size) 
#define __RPC__deref_in_ecount_opt_string(size)
#define __RPC__deref_in_ecount_part_opt(size, length) 

// [out]
#define __RPC__out     
#define __RPC__out_ecount(size) 
#define __RPC__out_ecount_part(size, length) 
#define __RPC__out_ecount_full(size)
#define __RPC__out_ecount_full_string(size)

// [in,out] 
#define __RPC__inout                                   
#define __RPC__inout_string
#define __RPC__opt_inout
#define __RPC__inout_ecount(size)                     
#define __RPC__inout_ecount_part(size, length)    
#define __RPC__inout_ecount_full(size)          
#define __RPC__inout_ecount_full_string(size)          

// [in,unique] 
#define __RPC__in_opt       
#define __RPC__in_ecount_opt(size)   


// [in,out,unique] 
#define __RPC__inout_opt    
#define __RPC__inout_ecount_opt(size)  
#define __RPC__inout_ecount_part_opt(size, length) 
#define __RPC__inout_ecount_full_opt(size)     
#define __RPC__inout_ecount_full_string(size)

// [out] **
#define __RPC__deref_out   
#define __RPC__deref_out_string
#define __RPC__deref_out_opt 
#define __RPC__deref_out_opt_string
#define __RPC__deref_out_ecount(size) 
#define __RPC__deref_out_ecount_part(size, length) 
#define __RPC__deref_out_ecount_full(size)  
#define __RPC__deref_out_ecount_full_string(size)


// [in,out] **, second pointer decoration. 
#define __RPC__deref_inout    
#define __RPC__deref_inout_string
#define __RPC__deref_inout_opt 
#define __RPC__deref_inout_opt_string
#define __RPC__deref_inout_ecount_full(size)
#define __RPC__deref_inout_ecount_full_string(size)
#define __RPC__deref_inout_ecount_opt(size) 
#define __RPC__deref_inout_ecount_part_opt(size, length) 
#define __RPC__deref_inout_ecount_full_opt(size) 
#define __RPC__deref_inout_ecount_full_opt_string(size) 

// #define __RPC_out_opt    out_opt is not allowed in rpc

// [in,out,unique] 
#define __RPC__deref_opt_inout  
#define __RPC__deref_opt_inout_string
#define __RPC__deref_opt_inout_ecount(size)     
#define __RPC__deref_opt_inout_ecount_part(size, length) 
#define __RPC__deref_opt_inout_ecount_full(size) 
#define __RPC__deref_opt_inout_ecount_full_string(size)

#define __RPC__deref_out_ecount_opt(size) 
#define __RPC__deref_out_ecount_part_opt(size, length) 
#define __RPC__deref_out_ecount_full_opt(size) 
#define __RPC__deref_out_ecount_full_opt_string(size)

#define __RPC__deref_opt_inout_opt      
#define __RPC__deref_opt_inout_opt_string
#define __RPC__deref_opt_inout_ecount_opt(size)   
#define __RPC__deref_opt_inout_ecount_part_opt(size, length) 
#define __RPC__deref_opt_inout_ecount_full_opt(size) 
#define __RPC__deref_opt_inout_ecount_full_opt_string(size) 

#define __RPC_full_pointer  
#define __RPC_unique_pointer
#define __RPC_ref_pointer
#define __RPC_string                               


#endif

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\schnlsp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       schnlsp.h
//
//  Contents:   Public Definitions for SCHANNEL Security Provider
//
//  Classes:
//
//  Functions:
//
//----------------------------------------------------------------------------



#ifndef __SCHNLSP_H__
#define __SCHNLSP_H__
#define __SCHANNEL_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include <wincrypt.h>
#include <sslsock.h>    // Windows CE secure socket extensions

//
// Security package names.
//

#define UNISP_NAME_A    "Microsoft Unified Security Protocol Provider"
#define UNISP_NAME_W    L"Microsoft Unified Security Protocol Provider"

#define SSL2SP_NAME_A    "Microsoft SSL 2.0"
#define SSL2SP_NAME_W    L"Microsoft SSL 2.0"

#define SSL3SP_NAME_A    "Microsoft SSL 3.0"
#define SSL3SP_NAME_W    L"Microsoft SSL 3.0"

#define TLS1SP_NAME_A    "Microsoft TLS 1.0"
#define TLS1SP_NAME_W    L"Microsoft TLS 1.0"

#define PCT1SP_NAME_A    "Microsoft PCT 1.0"
#define PCT1SP_NAME_W    L"Microsoft PCT 1.0"


#ifdef UNICODE

#define UNISP_NAME  UNISP_NAME_W
#define PCT1SP_NAME  PCT1SP_NAME_W
#define SSL2SP_NAME  SSL2SP_NAME_W
#define SSL3SP_NAME  SSL3SP_NAME_W
#define TLS1SP_NAME  TLS1SP_NAME_W

#else

#define UNISP_NAME  UNISP_NAME_A
#define PCT1SP_NAME  PCT1SP_NAME_A
#define SSL2SP_NAME  SSL2SP_NAME_A
#define SSL3SP_NAME  SSL3SP_NAME_A
#define TLS1SP_NAME  TLS1SP_NAME_A

#endif


//
// RPC constants.
//

#define UNISP_RPC_ID    14


//
// QueryContextAttributes/QueryCredentialsAttribute extensions
//

#define SECPKG_ATTR_ISSUER_LIST          0x50   // (OBSOLETE) returns SecPkgContext_IssuerListInfo
#define SECPKG_ATTR_REMOTE_CRED          0x51   // (OBSOLETE) returns SecPkgContext_RemoteCredentialInfo

#define SECPKG_ATTR_LOCAL_CRED           0x52   // (OBSOLETE) returns SecPkgContext_LocalCredentialInfo
#define SECPKG_ATTR_REMOTE_CERT_CONTEXT  0x53   // returns PCCERT_CONTEXT
#define SECPKG_ATTR_LOCAL_CERT_CONTEXT   0x54   // returns PCCERT_CONTEXT
#define SECPKG_ATTR_ROOT_STORE           0x55   // returns HCERTCONTEXT to the root store
#define SECPKG_ATTR_SUPPORTED_ALGS       0x56   // returns SecPkgCred_SupportedAlgs
#define SECPKG_ATTR_CIPHER_STRENGTHS     0x57   // returns SecPkgCred_CipherStrengths
#define SECPKG_ATTR_SUPPORTED_PROTOCOLS  0x58   // returns SecPkgCred_SupportedProtocols
#define SECPKG_ATTR_ISSUER_LIST_EX       0x59   // returns SecPkgContext_IssuerListInfoEx
#define SECPKG_ATTR_CONNECTION_INFO      0x5a   // returns SecPkgContext_ConnectionInfo
#define SECPKG_ATTR_EAP_KEY_BLOCK        0x5b   // returns SecPkgContext_EapKeyBlock
#define SECPKG_ATTR_MAPPED_CRED_ATTR     0x5c   // returns SecPkgContext_MappedCredAttr
#define SECPKG_ATTR_CACHE_INFO_ATTR      0x5d   // returns SecPkgCred_CacheInfo


// OBSOLETE - included here for backward compatibility only
typedef struct _SecPkgContext_IssuerListInfo
{
    DWORD   cbIssuerList;
    PBYTE   pIssuerList;
} SecPkgContext_IssuerListInfo, *PSecPkgContext_IssuerListInfo;


// OBSOLETE - included here for backward compatibility only
typedef struct _SecPkgContext_RemoteCredentialInfo
{
    DWORD   cbCertificateChain;
    PBYTE   pbCertificateChain;
    DWORD   cCertificates;
    DWORD   fFlags;
    DWORD   dwBits;
} SecPkgContext_RemoteCredentialInfo, *PSecPkgContext_RemoteCredentialInfo;

typedef SecPkgContext_RemoteCredentialInfo SecPkgContext_RemoteCredenitalInfo, *PSecPkgContext_RemoteCredenitalInfo;

#define RCRED_STATUS_NOCRED          0x00000000
#define RCRED_CRED_EXISTS            0x00000001
#define RCRED_STATUS_UNKNOWN_ISSUER  0x00000002


// OBSOLETE - included here for backward compatibility only
typedef struct _SecPkgContext_LocalCredentialInfo
{
    DWORD   cbCertificateChain;
    PBYTE   pbCertificateChain;
    DWORD   cCertificates;
    DWORD   fFlags;
    DWORD   dwBits;
} SecPkgContext_LocalCredentialInfo, *PSecPkgContext_LocalCredentialInfo;

typedef SecPkgContext_LocalCredentialInfo SecPkgContext_LocalCredenitalInfo, *PSecPkgContext_LocalCredenitalInfo;

#define LCRED_STATUS_NOCRED          0x00000000
#define LCRED_CRED_EXISTS            0x00000001
#define LCRED_STATUS_UNKNOWN_ISSUER  0x00000002


typedef struct _SecPkgCred_SupportedAlgs
{
    DWORD		cSupportedAlgs;
    ALG_ID		*palgSupportedAlgs;
} SecPkgCred_SupportedAlgs, *PSecPkgCred_SupportedAlgs;


typedef struct _SecPkgCred_CipherStrengths
{
    DWORD       dwMinimumCipherStrength;
    DWORD       dwMaximumCipherStrength;
} SecPkgCred_CipherStrengths, *PSecPkgCred_CipherStrengths;


typedef struct _SecPkgCred_SupportedProtocols
{
    DWORD      	grbitProtocol;
} SecPkgCred_SupportedProtocols, *PSecPkgCred_SupportedProtocols;


typedef struct _SecPkgContext_IssuerListInfoEx
{
    PCERT_NAME_BLOB   	aIssuers;
    DWORD           	cIssuers;
} SecPkgContext_IssuerListInfoEx, *PSecPkgContext_IssuerListInfoEx;


typedef struct _SecPkgContext_ConnectionInfo
{
    DWORD   dwProtocol;
    ALG_ID  aiCipher;
    DWORD   dwCipherStrength;
    ALG_ID  aiHash;
    DWORD   dwHashStrength;
    ALG_ID  aiExch;
    DWORD   dwExchStrength;
} SecPkgContext_ConnectionInfo, *PSecPkgContext_ConnectionInfo;


typedef struct _SecPkgContext_EapKeyBlock
{
    BYTE    rgbKeys[128];
    BYTE    rgbIVs[64];
} SecPkgContext_EapKeyBlock, *PSecPkgContext_EapKeyBlock;


typedef struct _SecPkgContext_MappedCredAttr
{
    DWORD   dwAttribute;
    PVOID   pvBuffer;
} SecPkgContext_MappedCredAttr, *PSecPkgContext_MappedCredAttr;


typedef struct _SecPkgCred_CacheInfo
{
    DWORD cbBytesCommitted;
    DWORD cMaxCacheEntries;
    DWORD cEntries;
    DWORD cUsed;
    DWORD cOrphans;
    DWORD cExpiredOrphans;
    DWORD cExpiredAbortedOrphans;
    DWORD cHandshaking;
} SecPkgCred_CacheInfo, *PSecPkgCred_CacheInfo;


//
// Schannel credentials data structure.
//

#define SCH_CRED_V1              0x00000001
#define SCH_CRED_V2              0x00000002  // for legacy code
#define SCH_CRED_VERSION         0x00000002  // for legacy code
#define SCH_CRED_V3              0x00000003  // for legacy code
#define SCHANNEL_CRED_VERSION    0x00000004


struct _HMAPPER;

typedef struct _SCHANNEL_CRED
{
    DWORD           dwVersion;      // always SCHANNEL_CRED_VERSION
    DWORD           cCreds;
    PCCERT_CONTEXT *paCred;
    HCERTSTORE      hRootStore;

    DWORD           cMappers;
    struct _HMAPPER **aphMappers;

    DWORD           cSupportedAlgs;
    ALG_ID *        palgSupportedAlgs;

    DWORD           grbitEnabledProtocols;
    DWORD           dwMinimumCipherStrength;
    DWORD           dwMaximumCipherStrength;
    DWORD           dwSessionLifespan;
    DWORD           dwFlags;
    DWORD           reserved;
} SCHANNEL_CRED, *PSCHANNEL_CRED;


//+-------------------------------------------------------------------------
// Flags for use with SCHANNEL_CRED
//
// SCH_CRED_NO_SYSTEM_MAPPER
//      This flag is intended for use by server applications only. If this
//      flag is set, then schannel does *not* attempt to map received client
//      certificate chains to an NT user account using the built-in system
//      certificate mapper.This flag is ignored by non-NT5 versions of
//      schannel.
//
// SCH_CRED_NO_SERVERNAME_CHECK
//      This flag is intended for use by client applications only. If this
//      flag is set, then when schannel validates the received server
//      certificate chain, is does *not* compare the passed in target name
//      with the subject name embedded in the certificate. This flag is
//      ignored by non-NT5 versions of schannel. This flag is also ignored
//      if the SCH_CRED_MANUAL_CRED_VALIDATION flag is set.
//
// SCH_CRED_MANUAL_CRED_VALIDATION
//      This flag is intended for use by client applications only. If this
//      flag is set, then schannel will *not* automatically attempt to
//      validate the received server certificate chain. This flag is
//      ignored by non-NT5 versions of schannel, but all client applications
//      that wish to validate the certificate chain themselves should
//      specify this flag, so that there's at least a chance they'll run
//      correctly on NT5.
//
// SCH_CRED_NO_DEFAULT_CREDS
//      This flag is intended for use by client applications only. If this
//      flag is set, and the server requests client authentication, then
//      schannel will *not* attempt to automatically acquire a suitable
//      default client certificate chain. This flag is ignored by non-NT5
//      versions of schannel, but all client applications that wish to
//      manually specify their certicate chains should specify this flag,
//      so that there's at least a chance they'll run correctly on NT5.
//
// SCH_CRED_AUTO_CRED_VALIDATION
//      This flag is the opposite of SCH_CRED_MANUAL_CRED_VALIDATION.
//      Conservatively written client applications will always specify one
//      flag or the other.
//
// SCH_CRED_USE_DEFAULT_CREDS
//      This flag is the opposite of SCH_CRED_NO_DEFAULT_CREDS.
//      Conservatively written client applications will always specify one
//      flag or the other.
//
// SCH_CRED_REVOCATION_CHECK_END_CERT
// SCH_CRED_REVOCATION_CHECK_CHAIN
// SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT
//      These flags specify that when schannel automatically validates a
//      received certificate chain, some or all of the certificates are to
//      be checked for revocation. Only one of these flags may be specified.
//      See the CertGetCertificateChain function. These flags are ignored by
//      non-NT5 versions of schannel.
//
// SCH_CRED_IGNORE_NO_REVOCATION_CHECK
// SCH_CRED_IGNORE_REVOCATION_OFFLINE
//      These flags instruct schannel to ignore the
//      CRYPT_E_NO_REVOCATION_CHECK and CRYPT_E_REVOCATION_OFFLINE errors
//      respectively if they are encountered when attempting to check the
//      revocation status of a received certificate chain. These flags are
//      ignored if none of the above flags are set.
//
//+-------------------------------------------------------------------------
#define SCH_CRED_NO_SYSTEM_MAPPER                    0x00000002
#define SCH_CRED_NO_SERVERNAME_CHECK                 0x00000004
#define SCH_CRED_MANUAL_CRED_VALIDATION              0x00000008
#define SCH_CRED_NO_DEFAULT_CREDS                    0x00000010
#define SCH_CRED_AUTO_CRED_VALIDATION                0x00000020
#define SCH_CRED_USE_DEFAULT_CREDS                   0x00000040

#define SCH_CRED_REVOCATION_CHECK_END_CERT           0x00000100
#define SCH_CRED_REVOCATION_CHECK_CHAIN              0x00000200
#define SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT 0x00000400
#define SCH_CRED_IGNORE_NO_REVOCATION_CHECK          0x00000800
#define SCH_CRED_IGNORE_REVOCATION_OFFLINE           0x00001000


//
//
// ApplyControlToken PkgParams types
//
// These identifiers are the DWORD types
// to be passed into ApplyControlToken
// through a PkgParams buffer.

#define SCHANNEL_RENEGOTIATE    0   // renegotiate a connection
#define SCHANNEL_SHUTDOWN       1   // gracefully close down a connection
#define SCHANNEL_ALERT          2   // build an error message


// Alert token structure.
typedef struct _SCHANNEL_ALERT_TOKEN
{
    DWORD   dwTokenType;            // SCHANNEL_ALERT
    DWORD   dwAlertType;
    DWORD   dwAlertNumber;
} SCHANNEL_ALERT_TOKEN;

// Alert types.
#define TLS1_ALERT_WARNING              1
#define TLS1_ALERT_FATAL                2

// Alert messages.
#define TLS1_ALERT_CLOSE_NOTIFY         0       // warning
#define TLS1_ALERT_UNEXPECTED_MESSAGE   10      // error
#define TLS1_ALERT_BAD_RECORD_MAC       20      // error
#define TLS1_ALERT_DECRYPTION_FAILED    21      // error
#define TLS1_ALERT_RECORD_OVERFLOW      22      // error
#define TLS1_ALERT_DECOMPRESSION_FAIL   30      // error
#define TLS1_ALERT_HANDSHAKE_FAILURE    40      // error
#define TLS1_ALERT_BAD_CERTIFICATE      42      // warning or error
#define TLS1_ALERT_UNSUPPORTED_CERT     43      // warning or error
#define TLS1_ALERT_CERTIFICATE_REVOKED  44      // warning or error
#define TLS1_ALERT_CERTIFICATE_EXPIRED  45      // warning or error
#define TLS1_ALERT_CERTIFICATE_UNKNOWN  46      // warning or error
#define TLS1_ALERT_ILLEGAL_PARAMETER    47      // error
#define TLS1_ALERT_UNKNOWN_CA           48      // error
#define TLS1_ALERT_ACCESS_DENIED        49      // error
#define TLS1_ALERT_DECODE_ERROR         50      // error
#define TLS1_ALERT_DECRYPT_ERROR        51      // error
#define TLS1_ALERT_EXPORT_RESTRICTION   60      // error
#define TLS1_ALERT_PROTOCOL_VERSION     70      // error
#define TLS1_ALERT_INSUFFIENT_SECURITY  71      // error
#define TLS1_ALERT_INTERNAL_ERROR       80      // error
#define TLS1_ALERT_USER_CANCELED        90      // warning or error
#define TLS1_ALERT_NO_RENEGOTIATATION   100     // warning


//
//
// ADDITIONAL SCHANNEL CERTIFICATE PROPERTIES
//
//


// This property specifies the DER private key data associated with this
// certificate.  It is for use with legacy IIS style private keys.
//
// PBYTE
//
#define CERT_SCHANNEL_IIS_PRIVATE_KEY_PROP_ID  (CERT_FIRST_USER_PROP_ID + 0)

// The password used to crack the private key associated with the certificate.
// It is for use with legacy IIS style private keys.
//
// PBYTE
#define CERT_SCHANNEL_IIS_PASSWORD_PROP_ID  (CERT_FIRST_USER_PROP_ID + 1)

// This is the unique ID of a Server Gated Cryptography certificate associated
// with this certificate.
//
// CRYPT_BIT_BLOB
#define CERT_SCHANNEL_SGC_CERTIFICATE_PROP_ID  (CERT_FIRST_USER_PROP_ID + 2)



//
// Flags for identifying the various different protocols.
//

/* flag/identifiers for protocols we support */
#define SP_PROT_PCT1_SERVER             0x00000001
#define SP_PROT_PCT1_CLIENT             0x00000002
#define SP_PROT_PCT1                    (SP_PROT_PCT1_SERVER | SP_PROT_PCT1_CLIENT)

#define SP_PROT_SSL2_SERVER             0x00000004
#define SP_PROT_SSL2_CLIENT             0x00000008
#define SP_PROT_SSL2                    (SP_PROT_SSL2_SERVER | SP_PROT_SSL2_CLIENT)

#define SP_PROT_SSL3_SERVER             0x00000010
#define SP_PROT_SSL3_CLIENT             0x00000020
#define SP_PROT_SSL3                    (SP_PROT_SSL3_SERVER | SP_PROT_SSL3_CLIENT)

#define SP_PROT_TLS1_SERVER             0x00000040
#define SP_PROT_TLS1_CLIENT             0x00000080
#define SP_PROT_TLS1                    (SP_PROT_TLS1_SERVER | SP_PROT_TLS1_CLIENT)

#define SP_PROT_SSL3TLS1_CLIENTS        (SP_PROT_TLS1_CLIENT | SP_PROT_SSL3_CLIENT)
#define SP_PROT_SSL3TLS1_SERVERS        (SP_PROT_TLS1_SERVER | SP_PROT_SSL3_SERVER)
#define SP_PROT_SSL3TLS1                (SP_PROT_SSL3 | SP_PROT_TLS1)

#define SP_PROT_UNI_SERVER              0x40000000
#define SP_PROT_UNI_CLIENT              0x80000000
#define SP_PROT_UNI                     (SP_PROT_UNI_SERVER | SP_PROT_UNI_CLIENT)

#define SP_PROT_ALL                     0xffffffff
#define SP_PROT_NONE                    0
#define SP_PROT_CLIENTS                 (SP_PROT_PCT1_CLIENT | SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT | SP_PROT_UNI_CLIENT | SP_PROT_TLS1_CLIENT)
#define SP_PROT_SERVERS                 (SP_PROT_PCT1_SERVER | SP_PROT_SSL2_SERVER | SP_PROT_SSL3_SERVER | SP_PROT_UNI_SERVER | SP_PROT_TLS1_SERVER)


// A call for IIS to empty the cache.
BOOL
SslEmptyCache(VOID);


//
//
//  Support for legacy applications
//  NOTE: Do not use the following
//  API's and structures for new code.
//

#define SSLOLD_NAME_A    "Microsoft SSL"
#define SSLOLD_NAME_W    L"Microsoft SSL"
#define PCTOLD_NAME_A    "Microsoft PCT"
#define PCTOLD_NAME_W    L"Microsoft PCT"

#ifdef UNICODE
#define SSLOLD_NAME SSLOLD_NAME_W
#define PCTOLD_NAME PCTOLD_NAME_W
#else
#define SSLOLD_NAME SSLOLD_NAME_A
#define PCTOLD_NAME PCTOLD_NAME_A
#endif

#define NETWORK_DREP    0x00000000



// Structures for compatability with the
// NT 4.0 SP2 / IE 3.0 schannel interface, do
// not use.

typedef struct _SSL_CREDENTIAL_CERTIFICATE {
    DWORD   cbPrivateKey;
    PBYTE   pPrivateKey;
    DWORD   cbCertificate;
    PBYTE   pCertificate;
    PSTR    pszPassword;
} SSL_CREDENTIAL_CERTIFICATE, * PSSL_CREDENTIAL_CERTIFICATE;




// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
#define SCHANNEL_SECRET_TYPE_CAPI   0x00000001
#define SCHANNEL_SECRET_PRIVKEY     0x00000002
#define SCH_CRED_X509_CERTCHAIN     0x00000001
#define SCH_CRED_X509_CAPI          0x00000002
#define SCH_CRED_CERT_CONTEXT       0x00000003

struct _HMAPPER;
typedef struct _SCH_CRED
{
    DWORD     dwVersion;                // always SCH_CRED_VERSION.
    DWORD     cCreds;                   // Number of credentials.
    PVOID     *paSecret;                // Array of SCH_CRED_SECRET_* pointers
    PVOID     *paPublic;                // Array of SCH_CRED_PUBLIC_* pointers
    DWORD     cMappers;                 // Number of credential mappers.
    struct _HMAPPER   **aphMappers;     // pointer to an array of pointers to credential mappers
} SCH_CRED, * PSCH_CRED;

// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_SECRET_CAPI
{
    DWORD           dwType;      // SCHANNEL_SECRET_TYPE_CAPI
    HCRYPTPROV      hProv;       // credential secret information.

} SCH_CRED_SECRET_CAPI, * PSCH_CRED_SECRET_CAPI;


// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_SECRET_PRIVKEY
{
    DWORD           dwType;       // SCHANNEL_SECRET_PRIVKEY
    PBYTE           pPrivateKey;   // Der encoded private key
    DWORD           cbPrivateKey;
    PSTR            pszPassword;  // Password to crack the private key.

} SCH_CRED_SECRET_PRIVKEY, * PSCH_CRED_SECRET_PRIVKEY;


// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_PUBLIC_CERTCHAIN
{
    DWORD       dwType;
    DWORD       cbCertChain;
    PBYTE       pCertChain;
} SCH_CRED_PUBLIC_CERTCHAIN, *PSCH_CRED_PUBLIC_CERTCHAIN;

// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_PUBLIC_CAPI
{
    DWORD           dwType;      // SCH_CRED_X509_CAPI
    HCRYPTPROV      hProv;       // CryptoAPI handle (usually a token CSP)

} SCH_CRED_PUBLIC_CAPI, * PSCH_CRED_PUBLIC_CAPI;




// Structures needed for Pre NT4.0 SP2 calls.
typedef struct _PctPublicKey
{
    DWORD Type;
    DWORD cbKey;
    UCHAR pKey[1];
} PctPublicKey;

typedef struct _X509Certificate {
    DWORD           Version;
    DWORD           SerialNumber[4];
    ALG_ID          SignatureAlgorithm;
    FILETIME        ValidFrom;
    FILETIME        ValidUntil;
    PSTR            pszIssuer;
    PSTR            pszSubject;
    PctPublicKey    *pPublicKey;
} X509Certificate, * PX509Certificate;



// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
BOOL
SslGenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits );

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
VOID
SslGenerateRandomBits(
    PUCHAR      pRandomData,
    LONG        cRandomData
    );

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
BOOL
SslCrackCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    DWORD               dwFlags,
    PX509Certificate *  ppCertificate
    );

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
VOID
SslFreeCertificate(
    PX509Certificate    pCertificate
    );

DWORD
WINAPI
SslGetMaximumKeySize(
    DWORD   Reserved );

BOOL
SslGetDefaultIssuers(
    PBYTE pbIssuers,
    DWORD *pcbIssuers);

#define SSL_CRACK_CERTIFICATE_NAME  TEXT("SslCrackCertificate")
#define SSL_FREE_CERTIFICATE_NAME   TEXT("SslFreeCertificate")

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
typedef BOOL
(WINAPI * SSL_CRACK_CERTIFICATE_FN)
(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    BOOL                VerifySignature,
    PX509Certificate *  ppCertificate
);


// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
typedef VOID
(WINAPI * SSL_FREE_CERTIFICATE_FN)
(
    PX509Certificate    pCertificate
);

// Pre Windows CE 4.0. Do not use. Use SCHANNEL_CRED instead.
#define SSL_SET_PROTOCOLS_NAME TEXT("SslSetProtocols")
#define SSL_GET_PROTOCOLS_NAME TEXT("SslGetProtocols")

typedef BOOL
(WINAPI * SSL_SET_PROTOCOLS_FN)(
    DWORD rgbitsProtocols
    );

typedef DWORD
(WINAPI * SSL_GET_PROTOCOLS_FN)();

BOOL
WINAPI
SslSetProtocols(
    DWORD rgbitsProtocols
    );

DWORD
WINAPI
SslGetProtocols();

// Function for use by wininet
// Match passed in servername with subject names in cert

#define IS_SSL_SERVER_NAME TEXT("IsSSLServerName")

typedef BOOL
(WINAPI * IS_SSL_SERVER_NAME_FN)(
    IN PCCERT_CONTEXT pCertContext,
    IN LPCWSTR pwszServerName
);

BOOL IsSSLServerName(
    IN PCCERT_CONTEXT pCertContext,
    IN LPCWSTR pwszServerName
);

#endif //__SCHANNEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\schedule.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
//  SCHEDULE.H

#ifndef __CAMSchedule__
#define __CAMSchedule__

// CAdviseSentinel tracks the thread call stack of 
// CAMSchedule::AddAdvisePacket.  Can be used to locate callers who release 
// the advise event handle while registered with the scheduler.
#ifdef DEBUG
#define ADVISE_SENTINEL
#endif

#ifdef ADVISE_SENTINEL
const DWORD c_cAdviseSentinelFramesMax = 8;

class CAdviseSentinel
{
public:

    CAdviseSentinel();
    virtual ~CAdviseSentinel();

    HRESULT CaptureCallStackFrames(HANDLE hEvent);
    VOID DumpCallStackFrames();
    VOID Reset();

private:

    HANDLE m_hEvent;
    DWORD m_cFrames;
    DWORD m_rgdwFrames[c_cAdviseSentinelFramesMax];
};
#endif

class CAMSchedule : private CBaseObject
{
public:
    virtual ~CAMSchedule();
    // ev is the event we should fire if the advise time needs re-evaluating
    CAMSchedule( HANDLE ev );

    DWORD GetAdviseCount();
    REFERENCE_TIME GetNextAdviseTime();

    // We need a method for derived classes to add advise packets, we return the cookie
    DWORD_PTR AddAdvisePacket( const REFERENCE_TIME & time1, const REFERENCE_TIME & time2, HANDLE h, BOOL periodic );
    // And a way to cancel
    HRESULT Unadvise(DWORD_PTR dwAdviseCookie);

    // Tell us the time please, and we'll dispatch the expired events.  We return the time of the next event.
    // NB: The time returned will be "useless" if you start adding extra Advises.  But that's the problem of
    // whoever is using this helper class (typically a clock).
    REFERENCE_TIME Advise( const REFERENCE_TIME & rtTime );

    // Get the event handle which will be set if advise time requires re-evaluation.
    HANDLE GetEvent() const { return m_ev; }

private:
    // We define the nodes that will be used in our singly linked list
    // of advise packets.  The list is ordered by time, with the
    // elements that will expire first at the front.
    class CAdvisePacket
    {
    public:
        CAdvisePacket()
        {}

        CAdvisePacket * m_next;
        DWORD_PTR       m_dwAdviseCookie;
        REFERENCE_TIME  m_rtEventTime;      // Time at which event should be set
        REFERENCE_TIME  m_rtPeriod;         // Periodic time
        HANDLE          m_hNotify;          // Handle to event or semephore
        BOOL            m_bPeriodic;        // TRUE => Periodic event

#ifdef ADVISE_SENTINEL
        CAdviseSentinel m_sentinel;
#endif

        CAdvisePacket( CAdvisePacket * next, LONGLONG time ) : m_next(next), m_rtEventTime(time)
        {}

        void InsertAfter( CAdvisePacket * p )
        {
            p->m_next = m_next;
            m_next    = p;
        }

        int IsZ() const // That is, is it the node that represents the end of the list
        { return m_next == 0; }

        CAdvisePacket * RemoveNext()
        {
            CAdvisePacket *const next = m_next;
            CAdvisePacket *const new_next = next->m_next;
            m_next = new_next;
            return next;
        }

        void DeleteNext()
        {
            delete RemoveNext();
        }

        CAdvisePacket * Next() const
        {
            CAdvisePacket * result = m_next;
            if (result->IsZ()) result = 0;
            return result;
        }

        DWORD_PTR Cookie() const
        { return m_dwAdviseCookie; }
    };

    // Structure is:
    // head -> elmt1 -> elmt2 -> z -> null
    // So an empty list is:       head -> z -> null
    // Having head & z as links makes insertaion,
    // deletion and shunting much easier.
    CAdvisePacket   head, z;            // z is both a tail and a sentry

    volatile DWORD_PTR  m_dwNextCookie;     // Strictly increasing
    volatile DWORD  m_dwAdviseCount;    // Number of elements on list

    CCritSec        m_Serialize;

    // AddAdvisePacket: adds the packet, returns the cookie (0 if failed)
    DWORD_PTR AddAdvisePacket( CAdvisePacket * pPacket );
    // Event that we should set if the packed added above will be the next to fire.
    const HANDLE m_ev;

    // A Shunt is where we have changed the first element in the
    // list and want it re-evaluating (i.e. repositioned) in
    // the list.
    void ShuntHead();

    // Rather than delete advise packets, we cache them for future use
    CAdvisePacket * m_pAdviseCache;
    DWORD           m_dwCacheCount;
    enum { dwCacheMax = 5 };             // Don't bother caching more than five

    void Delete( CAdvisePacket * pLink );// This "Delete" will cache the Link

// Attributes and methods for debugging
public:
#ifdef DEBUG
    void DumpLinkedList();
#else
    void DumpLinkedList() {}
#endif

};

#endif // __CAMSchedule__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sdcard.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

// Copyright (c) 2002-2004 BSQUARE Corporation.  All rights reserved.
// DO NOT REMOVE --- BEGIN EXTERNALLY DEVELOPED SOURCE CODE ID 40973--- DO NOT REMOVE

// Header file for data types and definitions from the SD Card specification

#ifndef _SD_CARD_H_
#define _SD_CARD_H_

#define SD_BUS_INTERFACE_VERSION_MAJOR  2
#define SD_BUS_INTERFACE_VERSION_MINOR  0

// SD card bus commands
#define SD_CMD_GO_IDLE_STATE        0       // CMD0
#define SD_CMD_MMC_SEND_OPCOND      1       // CMD1
#define SD_CMD_ALL_SEND_CID         2       // CMD2
#define SD_CMD_MMC_SET_RCA          3       // CMD3
#define SD_CMD_SEND_RELATIVE_ADDR   3       // CMD3
#define SD_CMD_SET_DSR              4       // CMD4
#define SD_CMD_IO_OP_COND           5       // CMD5
#define SD_CMD_SWITCH_FUNCTION      6       // CMD6
#define SD_CMD_SELECT_DESELECT_CARD 7       // CMD7
#define SD_CMD_SEND_IF_COND         8       // CMD8
#define SD_CMD_MMC_SEND_EXT_CSD     8       // CMD8 
#define SD_CMD_SEND_CSD             9       // CMD9
#define SD_CMD_SEND_CID             10       // CMD10
#define SD_CMD_STOP_TRANSMISSION    12       // CMD12
#define SD_CMD_SEND_STATUS          13       // CMD13
#define SD_CMD_GO_INACTIVE_STATE    15       // CMD15
#define SD_CMD_SET_BLOCKLEN         16       // CMD16
#define SD_CMD_READ_SINGLE_BLOCK    17       // CMD17
#define SD_CMD_READ_MULTIPLE_BLOCK  18       // CMD18
#define SD_CMD_WRITE_BLOCK          24       // CMD24
#define SD_CMD_WRITE_MULTIPLE_BLOCK 25       // CMD25
#define SD_CMD_PROGRAM_CSD          27       // CMD27
#define SD_CMD_SET_WRITE_PROT       28       // CMD28
#define SD_CMD_CLR_WRITE_PROT       29       // CMD29
#define SD_CMD_SEND_WRITE_PROT      30       // CMD30
#define SD_CMD_ERASE_WR_BLK_START   32       // CMD32
#define SD_CMD_ERASE_WR_BLK_END     33       // CMD33
#define SD_CMD_ERASE                38       // CMD38
#define SD_CMD_LOCK_UNLOCK          42       // CMD42
#define SD_CMD_IO_RW_DIRECT         52       // CMD52
#define SD_CMD_IO_RW_EXTENDED       53       // CMD53
#define SD_CMD_APP_CMD              55       // CMD55
#define SD_CMD_GEN_CMD              56       // CMD56

// command packet byte indexes
#define SD_COMMAND_BYTE_INDEX           5   // command is byte 5
#define SD_COMMAND_ARG_BYTE0_INDEX      1   // argument byte 0 is in byte 1
#define SD_COMMAND_ARG_BYTE1_INDEX      2   // argument byte 1 is in byte 2
#define SD_COMMAND_ARG_BYTE2_INDEX      3   // argument byte 2 is in byte 3
#define SD_COMMAND_ARG_BYTE3_INDEX      4   // argument byte 3 is in byte 4

// application Specific commands
#define SD_ACMD_SET_BUS_WIDTH               6
#define SD_ACMD_SD_STATUS                   13
#define SD_ACMD_SEND_NUM_WR_BLOCKS          22
#define SD_ACMD_SET_WR_BLOCK_ERASE_COUNT    23
#define SD_ACMD_SD_SEND_OP_COND             41
#define SD_ACMD_SET_CLR_CARD_DETECT         42
#define SD_ACMD_SEND_SCR                    51

// arg definition for ACMD SET_BUS_WIDTH
#define SD_ACMD_ARG_SET_BUS_4BIT            0x00000002

// SDIO commands
#define SD_IO_RW_DIRECT                 SD_CMD_IO_RW_DIRECT
#define SD_IO_RW_EXTENDED               SD_CMD_IO_RW_EXTENDED

    // CMD53 Bits
#define SD_CMD53_RW_MASK                0x80000000
#define SD_CMD53_READ_OP                0
#define SD_CMD53_WRITE_OP               SD_CMD53_RW_MASK
#define SD_CMD53_FUNCTION_NUMBER        0x70000000
#define SD_CMD53_BLOCK_MODE             0x08000000
#define SD_CMD53_OPCODE                 0x04000000
#define SD_CMD53_REGISTER_ADDRESS       0x03fffe00
#define SD_CMD53_REGISTER_ADDRESS_POS   9
#define SD_CMD53_BLOCK_COUNT            (( 1 << SD_CMD53_REGISTER_ADDRESS_POS ) - 1 )

// card status bits
#define SD_STATUS_OUT_OF_RANGE          0x80000000
#define SD_STATUS_ADDRESS_ERROR         0x40000000
#define SD_STATUS_BLOCK_LEN_ERROR       0x20000000
#define SD_STATUS_ERASE_SEQ_ERROR       0x10000000
#define SD_STATUS_ERASE_PARAM           0x08000000
#define SD_STATUS_WP_VIOLATION          0x04000000
#define SD_STATUS_CARD_IS_LOCKED        0x02000000
#define SD_STATUS_LOCK_UNLOCK_FAILED    0x01000000
#define SD_STATUS_COM_CRC_ERROR         0x00800000
#define SD_STATUS_ILLEGAL_COMMAND       0x00400000
#define SD_STATUS_CARD_ECC_FAILED       0x00200000
#define SD_STATUS_CC_ERROR              0x00100000
#define SD_STATUS_ERROR                 0x00080000
#define SD_STATUS_CID_CSD_OVERWRITE     0x00010000
#define SD_STATUS_WP_ERASE_SKIP         0x00008000
#define SD_STATUS_CARD_ECC_DISABLED     0x00004000
#define SD_STATUS_ERASE_RESET           0x00002000

#define SD_STATUS_CURRENT_STATE_MASK    0x00001E00
#define SD_STATUS_CURRENT_STATE_SHIFT   9
#define SD_STATUS_CURRENT_STATE(sd_status) \
    (((sd_status)&SD_STATUS_CURRENT_STATE_MASK)>>SD_STATUS_CURRENT_STATE_SHIFT)

// states pulled out from the status word
#define SD_STATUS_CURRENT_STATE_IDLE    0
#define SD_STATUS_CURRENT_STATE_READY   1
#define SD_STATUS_CURRENT_STATE_IDENT   2
#define SD_STATUS_CURRENT_STATE_STDBY   3
#define SD_STATUS_CURRENT_STATE_TRAN    4
#define SD_STATUS_CURRENT_STATE_DATA    5
#define SD_STATUS_CURRENT_STATE_RCV     6
#define SD_STATUS_CURRENT_STATE_PRG     7
#define SD_STATUS_CURRENT_STATE_DIS     8

#define SD_STATUS_READY_FOR_DATA    0x00000100
#define SD_STATUS_APP_CMD           0x00000020
#define SD_STATUS_AKE_SEQ_ERROR     0x00000008

#define SD_STATUS_ERROR_MASK        0xFFF90008
#define SD_CARD_STATUS_SUCCESS(s)   (0 == ((s) & SD_STATUS_ERROR_MASK))



// defines for the SCR register
#define SCR_VERSION_1_0             0
#define SD_SCR_REGISTER_SIZE        8  // 64 bits
#define SD_SPEC_VERSION_1_0         0
#define SD_SECURITY_NONE            0
#define SD_SECURITY_PROTOCOL_1      1
#define SD_SECURITY_PROTOCOL_2      2
#define SD_BUS_WIDTH_1_BIT          0x1
#define SD_BUS_WIDTH_4_BIT          0x4

// defines for CSD register
#define SD_CSD_VERSION_1_0              0
#define SD_FILE_FORMAT_HARD_DISK_LIKE   0
#define SD_FILE_FORMAT_FLOPPY_LIKE      1
#define SD_FILE_FORMAT_UNIVERSAL        2
#define SD_FILE_FORMAT_OTHER            3

// define for the OCR register
#define SD_OCR_REGISTER_SIZE            4 // 32 bits
#define SD_IO_OCR_REGISTER_SIZE         3 // 24 bits
#define SD_VDD_WINDOW_1_6_TO_1_7        0x00000010      // 1.6 V to 1.7 Volts
#define SD_VDD_WINDOW_1_7_TO_1_8        0x00000020      // 1.7 V to 1.8 Volts
#define SD_VDD_WINDOW_1_8_TO_1_9        0x00000040      // 1.8 V to 1.9 Volts
#define SD_VDD_WINDOW_1_9_TO_2_0        0x00000080      // 1.9 V to 2.0 Volts
#define SD_VDD_WINDOW_2_0_TO_2_1        0x00000100      // 2.0 V to 2.1 Volts
#define SD_VDD_WINDOW_2_1_TO_2_2        0x00000200      // 2.1 V to 2.2 Volts
#define SD_VDD_WINDOW_2_2_TO_2_3        0x00000400      // 2.2 V to 2.3 Volts
#define SD_VDD_WINDOW_2_3_TO_2_4        0x00000800      // 2.3 V to 2.4 Volts
#define SD_VDD_WINDOW_2_4_TO_2_5        0x00001000      // 2.4 V to 2.5 Volts
#define SD_VDD_WINDOW_2_5_TO_2_6        0x00002000      // 2.5 V to 2.6 Volts
#define SD_VDD_WINDOW_2_6_TO_2_7        0x00004000      // 2.6 V to 2.7 Volts
#define SD_VDD_WINDOW_2_7_TO_2_8        0x00008000      // 2.7 V to 2.8 Volts
#define SD_VDD_WINDOW_2_8_TO_2_9        0x00010000      // 2.8 V to 2.9 Volts
#define SD_VDD_WINDOW_2_9_TO_3_0        0x00020000      // 2.9 V to 3.0 Volts
#define SD_VDD_WINDOW_3_0_TO_3_1        0x00040000      // 3.0 V to 3.1 Volts
#define SD_VDD_WINDOW_3_1_TO_3_2        0x00080000      // 3.1 V to 3.2 Volts
#define SD_VDD_WINDOW_3_2_TO_3_3        0x00100000      // 3.2 V to 3.3 Volts
#define SD_VDD_WINDOW_3_3_TO_3_4        0x00200000      // 3.3 V to 3.4 Volts
#define SD_VDD_WINDOW_3_4_TO_3_5        0x00400000      // 3.4 V to 3.5 Volts
#define SD_VDD_WINDOW_3_5_TO_3_6        0x00800000      // 3.5 V to 3.6 Volts
#define SD_CARD_POWER_UP_STATUS         0x80000000      // powerup finished indicator

// define for SWITCH_FUNCTION CMD6.
#define SD_SWITCH_FUNCTION_DATA_SIZE    (512/8)

// defines for SD IO Function Basic Information registers
#define SD_IO_NON_STANDARD_DEVICE_CODE  0

// defines for CIS tuples       
#define SD_CISTPL_NULL                  0x00
#define SD_CISTPL_CHECKSUM              0x10
#define SD_CISTPL_VERS_1                0x15
#define SD_CISTPL_ALTSTR                0x16
#define SD_CISTPL_MANFID                0x20
#define SD_CISTPL_FUNCID                0x21
#define SD_CISTPL_FUNCE                 0x22
#define SD_CISTPL_SDIO_STD              0x91
#define SD_CISTPL_SDIO_EXT              0x92
#define SD_CISTPL_END                   0xFF
#define SD_TUPLE_LINK_END               0xFF

#define SD_CISTPLE_MAX_BODY_SIZE        256
#define SD_CISTPL_FUNCID_BODY_SIZE      2
#define SD_CISTPL_MANFID_BODY_SIZE      4


#define SD_CISTPL_FUNCE_COMMON_TYPE     0x00
#define SD_CISTPL_FUNCE_FUNCTION_TYPE   0x01

#include <pshpack1.h>
typedef struct _SD_CISTPL_FUNCE_FUNCTION {
    BYTE  bType;
    union {
        struct {
            BYTE FN_WUS : 1;
        };
        BYTE  bFunctionInfo;
    };
    BYTE  bStdIORev;
    DWORD dwCardPSN;
    DWORD dwCSASize;
    BYTE  bCSAProperty;
    WORD  wMaxBlkSize;
    DWORD dwOCR;
    BYTE  bOpMinPwr;
    BYTE  bOpAvgPwr;
    BYTE  bOpMaxPwr;
    BYTE  bSbMinPwr;
    BYTE  bSbAvgPwr;
    BYTE  bSbMaxPwr;
    WORD  wMinBw;
    WORD  wOptBw;
}SD_CISTPL_FUNCE_FUNCTION, *PSD_CISTPL_FUNCE_FUNCTION;
#include <poppack.h>


// SD card status
typedef DWORD SD_CARD_STATUS;

// defines for Card IDentification (CID) register.
#define SD_CID_REGISTER_SIZE    16  // 128 bits
#define SD_CID_PSN_OFFSET       3
#define SD_CID_PRV_OFFSET       7
#define SD_CID_PNM_OFFSET       8
#define SD_CID_OID_OFFSET       13
#define SD_CID_MID_OFFSET       15
#define SD_CID_MDT_OFFSET       1
#define SD_CID_MONTH_MASK       0x0F
#define SD_CID_YEAR0_MASK       0xF0
#define SD_CID_YEAR_SHIFT       4
// some of the CID definitions are different for MMC cards...
#define MMC_CID_MDT_OFFSET      1
#define MMC_CID_PSN_OFFSET      2
#define MMC_CID_PRV_OFFSET      6
#define MMC_CID_PNM_OFFSET      7
#define MMC_CID_MONTH_MASK      0xF0
#define MMC_CID_YEAR_MASK       0x0F
#define MMC_CID_MONTH_SHIFT     4

// macros for Card Specific Data (CSD) register.
#define SD_CSD_REGISTER_SIZE                16      // 128 bits

// bit slice definitions
#define SD_CSD_VERSION_BIT_SLICE            126
#define SD_CSD_VERSION_SLICE_SIZE           2
#define SD_CSD_SPECVER_BIT_SLICE            122
#define SD_CSD_SPECVER_SLICE_SIZE           4
// 120-121, 2 reserved bits
#define SD_CSD_TAAC_BIT_SLICE               112
#define SD_CSD_TAAC_SLICE_SIZE              8
#define SD_CSD_NSAC_BIT_SLICE               104
#define SD_CSD_NSAC_SLICE_SIZE              8
#define SD_CSD_TRANS_SPEED_BIT_SLICE        96
#define SD_CSD_TRANS_SPEED_SLICE_SIZE       8
#define SD_CSD_CCC_BIT_SLICE                84
#define SD_CSD_CCC_SLICE_SIZE               12
#define SD_CSD_READ_BL_LEN_BIT_SLICE        80
#define SD_CSD_READ_BL_LEN_SLICE_SIZE       4
#define SD_CSD_READ_BL_PARTIAL_BIT_SLICE    79
#define SD_CSD_READ_BL_PARTIAL_SLICE_SIZE   1
#define SD_CSD_WRITE_BL_MISALIGN_BIT_SLICE  78
#define SD_CSD_WRITE_BL_MISALIGN_SLICE_SIZE 1
#define SD_CSD_READ_BL_MISALIGN_BIT_SLICE   77
#define SD_CSD_READ_BL_MISALIGN_SLICE_SIZE  1
#define SD_CSD_DSR_IMP_BIT_SLICE            76
#define SD_CSD_DSR_IMP_SLICE_SIZE           1
// 74-75, 2 reserved bits
#define SD_CSD_CSIZE_BIT_SLICE              62
#define SD_CSD_CSIZE_SLICE_SIZE             12
#define SD_CSD20_CSIZE_BIT_SLICE            48
#define SD_CSD20_CSIZE_SLICE_SIZE           22
#define SD_CSD_R_CURR_MIN_BIT_SLICE         59
#define SD_CSD_R_CURR_MIN_SLICE_SIZE        3
#define SD_CSD_R_CURR_MAX_BIT_SLICE         56
#define SD_CSD_R_CURR_MAX_SLICE_SIZE        3      
#define SD_CSD_W_CURR_MIN_BIT_SLICE         53
#define SD_CSD_W_CURR_MIN_SLICE_SIZE        3
#define SD_CSD_W_CURR_MAX_BIT_SLICE         50
#define SD_CSD_W_CURR_MAX_SLICE_SIZE        3
#define SD_CSD_CSIZE_MULT_BIT_SLICE         47
#define SD_CSD_CSIZE_MULT_SLICE_SIZE        3
#define SD_CSD_ERASE_BL_ENABLE_BIT_SLICE    46
#define SD_CSD_ERASE_BL_ENABLE_SLICE_SIZE   1
#define SD_CSD_ERASE_SECT_SIZE_BIT_SLICE    39
#define SD_CSD_ERASE_SECT_SIZE_SLICE_SIZE   7
#define SD_CSD_WP_GROUP_SIZE_BIT_SLICE      32
#define SD_CSD_WP_GROUP_SIZE_SLICE_SIZE     7
#define SD_CSD_WP_GRP_ENABLE_BIT_SLICE      31
#define SD_CSD_WP_GRP_ENABLE_SLICE_SIZE     1 
// 29-30, 3 reserved bits
#define SD_CSD_R2W_FACTOR_BIT_SLICE         26
#define SD_CSD_R2W_FACTOR_SLICE_SIZE        3
#define SD_CSD_WRITE_BL_LEN_BIT_SLICE       22
#define SD_CSD_WRITE_BL_LEN_SLICE_SIZE      4
#define SD_CSD_WRITE_BL_PARTIAL_BIT_SLICE   21
#define SD_CSD_WRITE_BL_PARTIAL_SLICE_SIZE  1
// 16-20, 5 reserved bits
#define SD_CSD_FILE_GROUP_BIT_SLICE         15
#define SD_CSD_FILE_GROUP_SLICE_SIZE        1
#define SD_CSD_COPY_FLAG_BIT_SLICE          14
#define SD_CSD_COPY_FLAG_SLICE_SIZE         1 
#define SD_CSD_PERM_WR_PROT_BIT_SLICE       13
#define SD_CSD_PERM_WR_PROT_SLICE_SIZE      1
#define SD_CSD_TEMP_WR_PROT_BIT_SLICE       12
#define SD_CSD_TEMP_WR_PROT_SLICE_SIZE      1
#define SD_CSD_FILE_FORMAT_BIT_SLICE        10 
#define SD_CSD_FILE_FORMAT_SLICE_SIZE       2
// 8-9, 2 reserved bits
#define SD_CSD_CRC_BIT_SLICE                1
#define SD_CSD_CRC_SLICE_SIZE               7

// CSD Card Command Classes (CCC)
#define SD_CSD_CCC_BASIC                    (0 << 0)
#define SD_CSD_CCC_RESERVED1                (1 << 1)
#define SD_CSD_CCC_BLOCK_READ               (1 << 2)
#define SD_CSD_CCC_RESERVED3                (1 << 3)
#define SD_CSD_CCC_BLOCK_WRITE              (1 << 4)
#define SD_CSD_CCC_ERASE                    (1 << 5)
#define SD_CSD_CCC_WRITE_PROTECTION         (1 << 6)
#define SD_CSD_CCC_LOCK_CARD                (1 << 7)
#define SD_CSD_CCC_APPLICATION_SPECIFIC     (1 << 8)
#define SD_CSD_CCC_RESERVED9                (1 << 9)
#define SD_CSD_CCC_RESERVED10               (1 << 10)
#define SD_CSD_CCC_RESERVED11               (1 << 11)

// CSD definitions for MMC cards
#define MMC_CSD_ER_GRP_SIZE_BIT_SLICE       42
#define MMC_CSD_ER_GRP_SIZE_SLICE_SIZE      5
#define MMC_CSD_ER_GRP_MULT_BIT_SLICE       37
#define MMC_CSD_ER_GRP_MULT_SLICE_SIZE      5
#define MMC_CSD_WP_GROUP_SIZE_BIT_SLICE     32
#define MMC_CSD_WP_GROUP_SIZE_SLICE_SIZE    5

// macros for bit shifting and masking in the CSD register
#define SD_CSD_TRANS_SPEED_VALUE_SHIFT      3
#define SD_CSD_TRANS_SPEED_VALUE_MASK       0x78
#define SD_CSD_TRANS_SPEED_UNIT_MASK        0x07
#define SD_CSD_TAAC_VALUE_MASK              0x78
#define SD_CSD_TAAC_VALUE_SHIFT             3
#define SD_CSD_TAAC_UNIT_MASK               0x07

// SCR register
#define SD_SCR_VERSION_BIT_SLICE            60
#define SD_SCR_VERSION_SLICE_SIZE           4
#define SD_SCR_SD_SPEC_BIT_SLICE            56
#define SD_SCR_SD_SPEC_SLICE_SIZE           4
#define SD_SCR_DATA_STAT_ERASE_BIT_SLICE    55
#define SD_SCR_DATA_STAT_ERASE_SLICE_SIZE   1
#define SD_SCR_SECURITY_SUPPORT_BIT_SLICE   52
#define SD_SCR_SECURITY_SUPPORT_SLICE_SIZE  3
#define SD_SCR_BUS_WIDTH_BIT_SLICE          48
#define SD_SCR_BUS_WIDTH_SLICE_SIZE         4
// bits 0 - 47 reserved   

#define SD_SCR_BUS_WIDTH_1_BIT  0x01    // bit 0
#define SD_SCR_BUS_WIDTH_4_BIT  0x04    // bit 4

#define SD_DSR_REGISTER_SIZE 2

// definitions for IO RW Register and Extended Arguments
#define SD_IO_OP_READ           0   // Read_Write
#define SD_IO_OP_WRITE          1   // Read_Write
#define SD_IO_RW_NORMAL         0   // RAW
#define SD_IO_RW_RAW            1   // RAW
#define SD_IO_BYTE_MODE         0   // BlockMode
#define SD_IO_BLOCK_MODE        1   // BlockMode
#define SD_IO_FIXED_ADDRESS     0   // IncrementAddress
#define SD_IO_INCREMENT_ADDRESS 1   // IncrementAddress

// macro to build RW_Direct Argument
//    Read_Write = 1 (write) or 0 (read)
//    RAW        = 1 (read after write) or 0 (echo write data)
//    Function   = function number 0-7
//    Address    = register address 0-1FFFF
//    Data       = data to write (set to 0 if read)
#define BUILD_IO_RW_DIRECT_ARG(Read_Write, RAW, Function, Address, Data) \
    (((Read_Write & 1) << 31) | ((Function & 0x7) << 28) | \
    ((RAW & 1) << 27) | ((Address & 0x1FFFF) << 9) | \
    (Data & 0xFF))

// macros to split the RW_Direct argument up again
#define IO_RW_DIRECT_ARG_RW(Arg)    (((Arg)>>31)&1)
#define IO_RW_DIRECT_ARG_RAW(Arg)   (((Arg)>>27)&1)
#define IO_RW_DIRECT_ARG_FUNC(Arg)  ((UCHAR)(((Arg)>>28)&0x7))
#define IO_RW_DIRECT_ARG_ADDR(Arg)  (((Arg)>>9)&0x1FFFF)
#define IO_RW_DIRECT_ARG_DATA(Arg)  ((UCHAR)((Arg)&0xFF))


// macro to build RW Extended
//    Read_Write = 1 (write) or 0 (read)
//    BlockMode  = 1 = Block Mode or 0 = byte mode
//    Function   = function number 0-7
//    Address    = register address 0-1FFFF
//    IncrementAddress = 1 = Card should increment the register address
//                       0 = Card should keep the address register fixed
//    count       = 9 bit Block or Byte Count
#define BUILD_IO_RW_EXTENDED_ARG(Read_Write, BlockMode, Function, Address, IncrementAddress, Count) \
    (((Read_Write & 1) << 31) | ((Function & 0x7) << 28) | \
    ((BlockMode & 1) << 27) | ((IncrementAddress & 1) << 26) | ((Address & 0x1FFFF) << 9) | \
    (Count & 0x1FF))

// macros to split the RW_Extended argument up again
#define IO_RW_EXTENDED_ARG_RW(Arg)      IO_RW_DIRECT_ARG_RW(Arg)
#define IO_RW_EXTENDED_ARG_BLK(Arg)     (((Arg)>>27)&1)
#define IO_RW_EXTENDED_ARG_OP(Arg)      (((Arg)>>26)&1)
#define IO_RW_EXTENDED_ARG_FUNC(Arg)    IO_RW_DIRECT_ARG_FUNC(Arg)
#define IO_RW_EXTENDED_ARG_ADDR(Arg)    IO_RW_DIRECT_ARG_ADDR(Arg) 
#define IO_RW_EXTENDED_ARG_CNT(Arg)     ((Arg)&0x1FF)


#define SDIO_CCCR_SPEC_REV_MASK     0x0F
#define SDIO_CCCR_SPEC_REV_1_0      0x00
#define SDIO_CCCR_SPEC_REV_1_1      0x01
#define SDIO_CCCR_SPEC_REV_1_2      0x02

// SDIO register offsets in the Common Register Area
#define SD_IO_REG_CCCR              0x00
#define SD_IO_REG_SPEC_REV          0x01
#define SD_IO_REG_ENABLE            0x02
#define SD_IO_REG_IO_READY          0x03
#define SD_IO_REG_INT_ENABLE        0x04
#define SD_IO_REG_INT_PENDING       0x05
#define SD_IO_REG_IO_ABORT          0x06
#define SD_IO_REG_BUS_CONTROL       0x07
#define SD_IO_REG_CARD_CAPABILITY   0x08
#define SD_IO_REG_COMMON_CIS_POINTER 0x09   // extends to 0xA, 0xB for 24 bits total 
#define SD_IO_REG_BUS_SUSPEND        0x0C
#define SD_IO_REG_FUNCTION_SELECT    0x0D
#define SD_IO_REG_EXEC_FLAGS         0x0E
#define SD_IO_REG_READY_FLAGS        0x0F
#define SD_IO_REG_FB0_BLOCK_SIZE     0x10   // extends to 0x11, for 16 bits total
#define SD_IO_REG_POWER_CONTROL      0x12   // Power Control


#define SD_IO_CIS_PTR_BYTES          3
#define SD_IO_CSA_PTR_BYTES          3

// FBR Definitions
#define SD_IO_FBR_1_OFFSET           0x100  // Function Basic Information Register offset
#define SD_IO_FBR_DEVICE_CODE        0x0    // Device code offset from FBR base
#define SD_IO_FBR_DEVICE_CODE_EXT    0x1    // Device code extention offset (1.1 only devices)
#define SD_IO_FBR_POWER_SELECT       0x2    // Power Control offset (1.1 only devices)
#define SD_IO_FBR_CISP_BYTE_0        0x9    // CIS Pointer byte 0 offset from FBR base
#define SD_IO_FBR_CISP_BYTE_1        0xA    // CIS Pointer byte 1 offset from FBR base
#define SD_IO_FBR_CISP_BYTE_2        0xB    // CIS Pointer byte 2 offset from FBR base
#define SD_IO_FBR_CSAP_BYTE_0        0xC    // CSA pointer byte 0 offerst from FBR
#define SD_IO_FBR_CSAP_BYTE_1        0xD    // CSA pointer byte 1 offerst from FBR
#define SD_IO_FBR_CSAP_BYTE_2        0xE    // CSA pointer byte 2 offerst from FBR
#define SD_IO_FBR_DATA_ACCESS        0xF    // CSA data access offset
#define SD_IO_FBR_IO_BLOCK_SIZE      0x10   // I/O block size, spans 2 bytes
#define SD_IO_FBR_LENGTH             0x100  // FBR register length

// I/O Abort register Bit definitions
#define SD_IO_REG_IO_ABORT_RES       (1 << 3)
#define SD_IO_REG_IO_ABORT_AS2       (1 << 2)
#define SD_IO_REG_IO_ABORT_AS1       (1 << 1)
#define SD_IO_REG_IO_ABORT_AS0       (1 << 0)

// Card Capability Bit definitions
#define SD_IO_CARD_CAP_4_BIT_LOW_SPEED             (1 << 7)
#define SD_IO_CARD_CAP_LOW_SPEED                   (1 << 6)
#define SD_IO_CARD_CAP_ENABLE_INTS_4_BIT_MB_MODE   (1 << 5)
#define SD_IO_CARD_CAP_SUPPORTS_INTS_4_BIT_MB_MODE (1 << 4)
#define SD_IO_CARD_CAP_SUPPORTS_SUSPEND_RESUME     (1 << 3)
#define SD_IO_CARD_CAP_SUPPORTS_READ_WAIT          (1 << 2)
#define SD_IO_CARD_CAP_SUPPORTS_MULTI_BLOCK_TRANS  (1 << 1)
#define SD_IO_CARD_CAP_SUPPORTS_DIRECT_COMMAND     (1 << 0)

#define SD_IO_CARD_POWER_CONTROL_SUPPORT        (1 << 0)
#define SD_IO_CARD_POWER_CONTROL_ENABLE         (1 << 1)

#define SD_IO_FUNCTION_POWER_SELECT_SUPPORT    (1 << 0)
#define SD_IO_FUNCTION_POWER_SELECT_STATE      (1 << 1)

#define SD_MASK_FOR_33V_POWER_CONTROL_TUPLE     0x00FF8000      // 3.6 V to 2.7 Volts


// device code mask 
#define SDIO_DEV_CODE_MASK           0x0F
// device I/O extension token
#define SDIO_DEV_CODE_USES_EXTENSION 0x0F

// bit definitions for BUS CONTROL registers
#define SD_IO_BUS_CONTROL_CD_DETECT_DISABLE        (1 << 7)
#define SD_IO_BUS_CONTROL_BUS_WIDTH_1BIT           0x00
#define SD_IO_BUS_CONTROL_BUS_WIDTH_4BIT           0x02

// bit definition for Interrupt enable register
#define SD_IO_INT_ENABLE_MASTER_ENABLE       (1 << 0)
#define SD_IO_INT_ENABLE_ALL_FUNCTIONS       0xFE

// response flag bits
#define SD_IO_R5_RESPONSE_FLAGS_BYTE_OFFSET  0x02
#define SD_IO_R5_RESPONSE_DATA_BYTE_OFFSET   0x01

#define SD_IO_R5_RESPONSE_ERROR_MASK         0xCB  // bits 7,6,3,1,0
#define SD_IO_COM_CRC_ERROR                  0x80
#define SD_IO_ILLEGAL_COMMAND                0x40
#define SD_IO_GENERAL_ERROR                  0x08
#define SD_IO_INVALID_FUNCTION               0x02
#define SD_IO_ARG_OUT_OF_RANGE               0x01

#define SD_IO_R5_RESPONSE_ERROR(r)  ((r) & SD_IO_R5_RESPONSE_ERROR_MASK)

#define SDCARD_COMMAND_BUFFER_BYTES     6           // 48 bit commands
#define SDCARD_RESPONSE_BUFFER_BYTES    17          // max 136 bits
#define SD_DEFAULT_CARD_ID_CLOCK_RATE   100000      // 100 khz 
#define SD_FULL_SPEED_RATE              25000000    // 25 Mhz
#define MMC_FULL_SPEED_RATE             20000000    // 20 Mhz
#define SD_LOW_SPEED_RATE               400000      // 400 khz
#define SD_HIGH_SPEED_RATE              50000000    // 50 Mhz
#define MMC_HIGH_SPEED_RATE           52000000    // 52 Mhz

#endif _SDCARD_H_

// DO NOT REMOVE --- END EXTERNALLY DEVELOPED SOURCE CODE ID --- DO NOT REMOVE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sdcardddk.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

// Copyright (c) 2002-2004 BSQUARE Corporation.  All rights reserved.
// DO NOT REMOVE --- BEGIN EXTERNALLY DEVELOPED SOURCE CODE ID 40973--- DO NOT REMOVE

// Core header file for SD Card DDK

#ifndef _SDCARD_DDK_DEFINED
#define _SDCARD_DDK_DEFINED


#include <windows.h>
#include <types.h>
#include <linklist.h>
#include <ceddk.h>

#include "SDMem.h"
#include "SDCard.h"
#define SD_CSD_VERSION_CODE_1_0         0
#define SD_CSD_VERSION_CODE_2_0         1
#define SD_CSD_VERSION_CODE_SUPPORTED   SD_CSD_VERSION_CODE_2_0 

#define MMC_CSD_VERSION_CODE_1_0        0
#define MMC_CSD_VERSION_CODE_1_1        1
#define MMC_CSD_VERSION_CODE_1_2        2
#define MMC_CSD_VERSION_CODE_EXT        3
#define MMC_CSD_VERSION_CODE_SUPPORTED  MMC_CSD_VERSION_CODE_EXT

#define MMC_SPEC_VERSION_1_PLUS         0
#define MMC_SPEC_VERSION_1_4               1
#define MMC_SPEC_VERSION_2_PLUS         2
#define MMC_SPEC_VERSION_3_PLUS         3
#define MMC_SPEC_VERSION_4_PLUS         4

typedef PVOID SD_DEVICE_HANDLE;

// typedef for API Status codes
typedef LONG SD_API_STATUS;

// transfer class enum, indicates whether a bus request is read,write or a command
typedef enum { 
    SD_READ = 0,         // block read
    SD_WRITE = 1,        // block write
    SD_COMMAND = 2,      // command only
} SD_TRANSFER_CLASS;

// SDIO Read/Write Enum
typedef enum { 
    SD_IO_READ = 0, 
    SD_IO_WRITE = 1,  
} SD_IO_TRANSFER_TYPE;

// indicates Interface being used for a card
typedef enum {  
    SD_INTERFACE_SD_MMC_1BIT = 0, 
    SD_INTERFACE_SD_4BIT = 1,
    SD_INTERFACE_MMC_8BIT = 2
} SD_INTERFACE_MODE;


typedef union {
    struct {
        ULONG sd4Bit:1;
        ULONG sdHighSpeed:1;
        ULONG mmc8Bit:1;
        ULONG :27;
        ULONG sdWriteProtected:1;
        ULONG sdHighCapacity:1;
    } bit;
    ULONG uInterfaceMode;
} SD_INTERFACE_MODE_EX,*PSD_INTERFACE_MODE_EX;
// enum for querying card information, some of this information is cached
typedef enum { 
    SD_INFO_REGISTER_OCR = 0,       // 32-bit OCR cached value for MMC/SDMemory Cards
    SD_INFO_REGISTER_CID,           // CID for MMC/SDMemory Cards
    SD_INFO_REGISTER_CSD,           // CSD for MMC/SDMemory Cards
    SD_INFO_REGISTER_RCA,           // RCA data type for MMC/SDMemory/SD IO Cards
    SD_INFO_REGISTER_IO_OCR,        // 24 bit IO-OCR register for SDIO Cards
    SD_INFO_CARD_INTERFACE,         // card interface for all card types
    SD_INFO_CARD_STATUS,            // card status for MMC/SD Memory cards
    SD_INFO_SDIO,                   // SDIO information (SD IO only)
    SD_INFO_HOST_IF_CAPABILITIES,   // SD Host Interface Capabilities
    SD_INFO_HOST_BLOCK_CAPABILITY,  // SD Host Block Length Capabilities
    SD_INFO_HIGH_CAPACITY_SUPPORT,  // SD Memory High Capacity
    SD_INFO_TYPE_COUNT,             // number of SD_INFO_TYPEs
    SD_INFO_CARD_INTERFACE_EX,      // CARD extension bit after 1.10
    SD_INFO_SWITCH_FUNCTION         // SWITCH Function, Read Current Supported Function.
} SD_INFO_TYPE;

// enum for device type
typedef enum _SDCARD_DEVICE_TYPE {
    Device_Unknown = 0,
    Device_MMC = 1,
    Device_SD_Memory = 2,
    Device_SD_IO = 3,
    Device_SD_Combo = 4  // combo is only an intermediate device type reserved only for the bus driver
}SDCARD_DEVICE_TYPE, *PSDCARD_DEVICE_TYPE;

// enum for setting SD Card Features
typedef enum { 
    SD_IO_FUNCTION_ENABLE = 0,          // enable I/O Function, uses SD_IO_FUNCTION_ENABLE_INFO
    SD_IO_FUNCTION_DISABLE,             // disable I/O Function - no structure required
    SD_IO_FUNCTION_SET_BLOCK_SIZE,      // set the SDIO Function block size,takes a DWORD parameter
    SD_SET_DATA_TRANSFER_CLOCKS,        // set read and write data transfer clocks
    SD_SET_CARD_INTERFACE,              // set the physical card interface
    SD_SET_CLOCK_STATE_DURING_IDLE,     // set the clock state during the idle state
    SD_IS_SOFT_BLOCK_AVAILABLE,         // Determine if Soft-Block is available in the SD Bus driver.
    SD_SOFT_BLOCK_FORCE_UTILIZATION,    // Always use Soft-Block (testing use only).
    SD_SOFT_BLOCK_DEFAULT_UTILIZATON,   // Enable Soft-Block use.
	SD_CARD_SELECT_REQUEST,             // request the card to be selected
	SD_CARD_DESELECT_REQUEST,           // request the card to be deselected
	SD_CARD_FORCE_RESET,                // force the card to be reset
    SD_IS_FAST_PATH_AVAILABLE,          // Determine if Fast-Path is available in the SD Bus driver.
    SD_FAST_PATH_DISABLE,               // Disable Fast-Path use (testing use only).
    SD_FAST_PATH_ENABLE,                // Enable Fast-Path use.
    SD_IO_FUNCTION_HIGH_POWER,          // Select High Power mode for Function
    SD_IO_FUNCTION_LOW_POWER,           // Select Low Power mode for Function
    SD_INFO_POWER_CONTROL_STATE,        // Get functions power state
    SD_SET_CARD_INTERFACE_EX,           // set the physical card interface with extended structure SD_CARD_INTERFACE_EX.
    SD_SET_SWITCH_FUNCTION,             // For 1.1 Memory card to switch Function.
    SD_DMA_ALLOC_PHYS_MEM,              // Optional, Allocate DMAable Physical Memory,
    SD_DMA_FREE_PHYS_MEM                // Optional, Free DMAable Pysical Memor located by SD_DMA_ALLOC_PHYS_MEM
} SD_SET_FEATURE_TYPE, *PSD_SET_FEATURE_TYPE;

// structure for SD_IO_FUNCTION_ENABLE card feature
typedef struct _SD_IO_FUNCTION_ENABLE_INFO{
    ULONG   ReadyRetryCount;    // number of retries to check the ready bit in the function
    ULONG   Interval;           // interval in milliseconds to check
}SD_IO_FUNCTION_ENABLE_INFO, *PSD_IO_FUNCTION_ENABLE_INFO;

// info for SD_SET_DATA_TRANSFER_CLOCKS card feature
typedef struct _SD_DATA_TRANSFER_CLOCKS {
    ULONG   ReadClocks;         // the worst case number of read clocks before read data is sent 
    ULONG   WriteClocks;        // number of clocks that busy signal can remain assrted
} SD_DATA_TRANSFER_CLOCKS, *PSD_DATA_TRANSFER_CLOCKS;

// structure for information about a card's interface
typedef struct _SD_CARD_INTERFACE {
    SD_INTERFACE_MODE   InterfaceMode;  // interface mode
    ULONG               ClockRate;      // clock rate
    BOOL                WriteProtected; // write protect flag (SD Memory cards)
} SD_CARD_INTERFACE, *PSD_CARD_INTERFACE;

// structure for information about a card's interface
typedef struct _SD_CARD_INTERFACE_EX {
    SD_INTERFACE_MODE_EX InterfaceModeEx;  // Extended interface mode
    ULONG               ClockRate;      // clock rate
    ULONG               Reserved[6];    // Reserved should be zero.
} SD_CARD_INTERFACE_EX, *PSD_CARD_INTERFACE_EX;

// structure for SDIO device information
typedef struct _SDIO_CARD_INFO{
    UCHAR   FunctionNumber;   // SDIO function number
    UCHAR   DeviceCode;       // device interface code for this function
    DWORD   CISPointer;       // CIS pointer for this function
    DWORD   CSAPointer;       // CSA pointer for this function
    UCHAR   CardCapability;   // common card capabilities
} SDIO_CARD_INFO, *PSDIO_CARD_INFO;

// structure for SD_INFO_HOST_BLOCK_CAPABILITY card information
typedef struct _SD_HOST_BLOCK_CAPABILITY{
    USHORT  ReadBlockSize;   // block size for read requests
    USHORT  WriteBlockSize;  // block size for write requests
    USHORT  ReadBlocks;      // number of blocks for each read request
    USHORT  WriteBlocks;     // number of blocks for each write request
} SD_HOST_BLOCK_CAPABILITY, *PSD_HOST_BLOCK_CAPABILITY;

// structure for SDHCAllocateDMABuffer and SDHCFreeDMABuffer
typedef struct {
    ULONG               Length;
    BOOLEAN             CacheEnabled;
    PVOID               VirtualAddress;
    PHYSICAL_ADDRESS    LogicalAddress;
} SD_HOST_ALLOC_FREE_DMA_BUFFER,*PSD_HOST_ALLOC_FREE_DMA_BUFFER;

typedef struct _SD_CARD_SWITCH_FUNCTION {
    DWORD   dwSelectedFunction; // 6 function group. each one has 4 bits.
    DWORD   dwMaxCurrentAllowed;// Only allow dwMaxCurrentAllowed mA for switch to new Function
    DWORD   dwTimeOut;          // Ticks for time out the select.
    BYTE    clientData[512/8];    // Client Data which is provided by Switch function.
} SD_CARD_SWITCH_FUNCTION, *PSD_CARD_SWITCH_FUNCTION;
// enum for response types
typedef enum  _SD_RESPONSE_TYPE {
    NoResponse  = 0,
    ResponseR1  = 1,
    ResponseR1b = 2,
    ResponseR2  = 3,
    ResponseR3  = 4, 
    ResponseR4  = 5,
    ResponseR5  = 6,
    ResponseR6  = 7,
    ResponseR7  = 8
} SD_RESPONSE_TYPE, *PSD_RESPONSE_TYPE;

// fast path event callback event types
typedef enum _SD_SLOT_EVENT_TYPE {
    SDCardEjected = 1,              // card ejected
	SDCardSelected = 2,             // card selected
	SDCardDeselected = 3,           // card deselected
	SDCardBeginSelectDeselect = 4,  // Start to do Select_Deselect 
	SDCardDeselectRequest = 5,      // bus driver received card deselect request
	SDCardSelectRequest = 6         // bus driver received card select request
}SD_SLOT_EVENT_TYPE, *PSD_SLOT_EVENT_TYPE;


// maximum length of a debug string
#define MAXIMUM_DEBUG_STRING_LENGTH 384
#define MAX_KEY_NAME_LENGTH    32
#define MAX_KEY_PATH_LENGTH    256
#define MAX_SDCARD_CLIENT_NAME 32
#define MAX_FILE_NAME_LENGTH   256

// 64K debug file
#define DEFAULT_MAX_DEBUG_FILE_LENGTH 0x10000

// forward declaration
typedef struct _SD_BUS_REQUEST *PSD_BUS_REQUEST;

// typedef for bus request completion callback
typedef VOID (*PSD_BUS_REQUEST_CALLBACK) (SD_DEVICE_HANDLE,
                                          PSD_BUS_REQUEST,
                                          PVOID,
                                          DWORD);

typedef struct _SD_COMMAND_RESPONSE {
    SD_RESPONSE_TYPE ResponseType;                                  // response type
    UCHAR            ResponseBuffer[SDCARD_RESPONSE_BUFFER_BYTES];  // largest possible reponse buffer
}SD_COMMAND_RESPONSE, *PSD_COMMAND_RESPONSE;

typedef struct __PHYS_BUFF_LIST {
    PHYSICAL_ADDRESS    PhysAddr;
    UINT32              PhysLen;
} PHYS_BUFF_LIST , *PPHYS_BUFF_LIST;

// structure to identify a bus request, used to cancel/track request
typedef struct _SD_BUS_REQUEST {
    LIST_ENTRY  ListEntry;          // list entry
    SD_DEVICE_HANDLE hDevice;       // the device this request belongs to
    ULONG       SystemFlags;        // system flags
    SD_TRANSFER_CLASS TransferClass; // transfer class
    UCHAR       CommandCode;        // command code
    DWORD       CommandArgument;    // command argument 
    SD_COMMAND_RESPONSE CommandResponse;  // command response
    DWORD       RequestParam;       // optional request parameter
    SD_API_STATUS Status;           // completion status
    ULONG       NumBlocks;          // number of blocks
    ULONG       BlockSize;          // size of each block   
    DWORD       HCParam;            // host controller parameter, reserved for HC drivers
    PUCHAR      pBlockBuffer;       // buffer holding block data
    PSD_BUS_REQUEST_CALLBACK pCallback;  // callback when the request completes
    DWORD       DataAccessClocks;   // data access clocks for data transfers (READ or WRITE), reserved for HC driver
    // for reads, this is the typical clock delay for the first read data byte
    // for writes, this is the typical clock delay for the write operation to finish
    DWORD       Flags;              // request flags
    DWORD       cbSizeOfPhysList;
    PPHYS_BUFF_LIST pPhysBuffList;
} SD_BUS_REQUEST, *PSD_BUS_REQUEST;

// request flags
#define SD_AUTO_ISSUE_CMD12     0x00000001  // automatically issue CMD12 after the command
#define SD_SDIO_AUTO_IO_ABORT   0x00000002  // (SDIO Only) automatically abort I/O using CMD52 

// unspecified access clocks 
#define SD_UNSPECIFIED_ACCESS_CLOCKS 0xFFFFFFFF

// some macros to get fields from the bus request structure
#define SD_BUS_REQUEST_RESPONSE(request) ((request)->CommandResponse)
#define SD_BUS_REQUEST_STATUS(request)   ((request)->Status)
#define SD_SYNCHRONOUS_REQUEST  0x00000004  // This is a synchronous request from the bus driver.
#define SD_SLOTRESET_REQUEST    0x00000008  // This is a request for resetting the slot

    // bus request System Flags
    //     Bits 27-0 are defined in SDBusDriver.h
#define SD_FAST_PATH_AVAILABLE  0x80000000  // Fast-Path is available for this request.
#define SD_SET_EVENT_FLAG       0x40000000  // Set the event flag upon request completion.

#define SD_BUS_REQUEST_PHYS_BUFFER 0x00008000

// request queue
typedef struct _SD_REQUEST_QUEUE {
    LIST_ENTRY      ListHead;           // list head for all bus requests
    ULONG           QueueCount;         // number of entries
}SD_REQUEST_QUEUE, *PSD_REQUEST_QUEUE;

// definition of interrupt callback for SDIO cards
typedef SD_API_STATUS (*PSD_INTERRUPT_CALLBACK) (SD_DEVICE_HANDLE,   // device handle
                                                 PVOID);             // device context

// typedef for fast-path slot event callback
typedef VOID (*PSD_SLOT_EVENT_CALLBACK) (SD_DEVICE_HANDLE,           // handle
                                         PVOID,                      // device context
                                         SD_SLOT_EVENT_TYPE,         // slot event type
                                         PVOID,                      // slot event data (optional)
                                         DWORD);                     // slot event data size (optional

// bit fields for client registration flags    
#define SD_CLIENT_HANDLES_RETRY 0x00000001         // client driver handles retries

// client registration structure
typedef struct _SDCARD_CLIENT_REGISTRATION_INFO {
    TCHAR                       ClientName[MAX_SDCARD_CLIENT_NAME]; // client name
    PSD_SLOT_EVENT_CALLBACK     pSlotEventCallBack;                 // slot event callback
    DWORD                       ClientFlags;                        // flags
    DWORD                       Reserved1;                          // future use
    DWORD                       Reserved2;                          // future use        
}SDCARD_CLIENT_REGISTRATION_INFO, *PSDCARD_CLIENT_REGISTRATION_INFO;

// parsed CID structure
typedef struct _SD_PARSED_REGISTER_CID{
    UCHAR  ManufacturerID;              // 8 bit manufacturer ID
    CHAR   OEMApplicationID[3];         // 2 character ASCII string NULL terminated
    CHAR   ProductName[7];              // product name string 6 (to accomodate MMC cards) ASCII chars + 1 nul char
    UCHAR  MajorProductRevision;        // 4 bit major
    UCHAR  MinorProductRevision;        // 4 bit minor rev
    DWORD  ProductSerialNumber;         // 32 bit product serial number
    UCHAR  ManufacturingMonth;          // Month, 1=Jan, 12=Dec
    USHORT ManufacturingYear;           // Decoded year, range 2000 upwards
    UCHAR  RawCIDRegister[16];          // raw data
} SD_PARSED_REGISTER_CID, *PSD_PARSED_REGISTER_CID;

// file System type present on card
typedef enum {
    SD_FS_FAT_PARTITION_TABLE,
    SD_FS_FAT_NO_PARTITION_TABLE,
    SD_FS_UNIVERSAL,
    SD_FS_OTHER
} SD_FS_TYPE, *PSD_FS_TYPE;

// parsed CSD structure
typedef struct _SD_PARSED_REGISTER_CSD {
    UCHAR CSDVersion;               // 2 bit CSD version
    UCHAR SpecVersion;              // 4 bit Spec version	
    struct {
        DOUBLE TAAC;                // The TAAC field in units of nano-seconds
        USHORT NSAC;                // The NSAC field in units of clock-cycle 
    } DataAccessTime;
    ULONG MaxDataTransferRate;      // In units of kbit/s
    USHORT CardCommandClasses;      // 12 bit command class support indicators
    USHORT MaxReadBlockLength;      // In units of bytes
    BOOLEAN ReadBlockPartial;       // Partial Block Read allowed ?
    BOOLEAN WriteBlockMisalign;     // Misaligned Block Writes allowed ?
    BOOLEAN ReadBlockMisalign;      // Misaligned Block Reads allowed ?
    BOOLEAN DSRImplemented;         // DSR Register implemented ?
    ULONG DeviceSize;               // Calculated device memory size in bytes
    USHORT VDDReadCurrentMin;       // in units of milliamps
    USHORT VDDReadCurrentMax;       // in units of milliamps
    USHORT VDDWriteCurrentMin;      // in units of milliamps
    USHORT VDDWriteCurrentMax;      // in units of milliamps
    BOOLEAN EraseBlockEnable;       // Erase in multiples of MaxWriteBlockLength ?
    UCHAR EraseSectorSize;          // Size of an erase sector in blocks (SECTOR_SIZE+1)
    UCHAR WPGroupSize;              // Size of a WP group in erase sectors (WP_GRP_SIZE+1)
    UCHAR WPGroupEnable;            // Group Write Protection possible ?
    UCHAR WriteSpeedFactor;         // Block Write time as multiple of Read access time
    USHORT MaxWriteBlockLength;     // In units of bytes
    BOOLEAN WriteBlockPartial;      // Partial block writes allowed ?
    BOOLEAN CopyFlag;               // Copy control flag
    BOOLEAN PermanentWP;            // Permanent Write Protect flag
    BOOLEAN TemporaryWP;            // Temporary Write Protect flag
    SD_FS_TYPE FileSystem;          // File System type
    UCHAR RawCSDRegister[16];       // raw data
} SD_PARSED_REGISTER_CSD, *PSD_PARSED_REGISTER_CSD;

#include <pshpack1.h>
typedef struct _SD_REGISTER_SCR {
    DWORD ReservedForManufacturer:32;
    WORD  Reserverd:16;
    BYTE  SD_BUS_WIDTHS:4;
    BYTE  SD_SECURITY:3;
    BYTE  DATA_STAT_AFTER_ERASE:1;
    BYTE  SD_SPEC:4;
    BYTE  SCR_STRUCTURE:4;
} SD_REGISTER_SCR, *PSD_REGISTER_SCR;
#include <poppack.h>


typedef USHORT SD_CARD_RCA;         // card RCA
typedef DWORD  SD_CARD_STATUS;      // card status

typedef struct _SLOT_POWER_DATA {
    UCHAR       Functions;      	        // Number of functions for the card
    BOOL        fCardSupportsPowerControl;  // True if card supports power control
    BOOL        fPowerControlEnabled;       // True if power control is enabled
    DWORD       CurrentDrawOfSlot;          // Maximum possible current draw in mA 
                                            // allocated at the slot

    DWORD       OperatingVoltage;           // bit mask similar to OCR register
    DWORD 		CurrentTupleVoltageRange;  // bit mask similar to OCR register

    UCHAR 		NumberOfHighPowerTuples;    // For SDIO 1.1 this is 1
    DWORD		SizeOfFunctionRecord;       // Size of data per function
} SLOT_POWER_DATA, *PSLOT_POWER_DATA;


typedef struct _SD_FUNCTION_POWER_DRAW {
        //for SDIO 1.0 cards
    USHORT		OpMinPower;     // Minimum current when this function is operating
    USHORT		OpAvePower;	    // Average current when this function is operating
    USHORT		OpMaxPower;	    // Maximum current when this function is operating
                                                  
        //for SDIO 1.1 cards    Note: EMPC reffers to the EMPC bit of the CCCR register "Power Control"   
        //                            EPS  reffers to the EPS  bit of the FBR  register for Power Selection 
    USHORT		SpAvePower33;	//Ave current if EMPC is not set. (Same as OpAvePower)
    USHORT		SpMaxPower33;   //Max current if EMPC is not set. (Same as OpAvePower)

    USHORT		HpAvePower33;   //Ave current if EMPC is set, and ESP is clear. (High Power)
    USHORT		HpMaxPower33;   //Max current if EMPC is set, and ESP is clear. (High Power)

    USHORT		LpAvePower33;   //Ave current if EMPC is set, and ESP is set. (Low Power)
    USHORT		LpMaxPower33;   //Max current if EMPC is set, and ESP is set. (Low Power)

        //future tuples will require six USHORTs each.
} SD_FUNCTION_POWER_DRAW, *PSD_FUNCTION_POWER_DRAW;

typedef struct _FUNCTION_POWER_STATE {
    BOOL    fPowerControlSupport;   // Does card support Power Control
    BOOL    fPowerControlEnabled;   // Is cards power control enabled
    BOOL    fFunctionEnabled;       // Enable state of the Function
    BOOL    fSupportsPowerSelect;   // Is power selection is supported for this function
    BOOL    fLowPower;              // Function is in the Low or High power state

    DWORD   OperatingVoltage;       // Operating voltage given as an OCR register value
    USHORT  CurrentDrawNow;         // current draw of the function now
    INT     EnableDelta;            // change in current if enabled state changed
    INT     SelectDelta;            // change in current if High/Low power select state changed
} FUNCTION_POWER_STATE, *PFUNCTION_POWER_STATE;


typedef struct _FUNCTION_POWER_DATA {
    TCHAR                   ClientName[MAX_SDCARD_CLIENT_NAME]; // client name, if the functions registered witha client
    FUNCTION_POWER_STATE    PowerState;
    SD_FUNCTION_POWER_DRAW  PowerTuples;
} FUNCTION_POWER_DATA, *PFUNCTION_POWER_DATA;


typedef struct _BUS_DRIVER_IN_SLOT_FUNCTION_POWER {
    DWORD		SlotIndex;      // Slots start at 0
    DWORD		FunctionNumber; // Functions start at 1
} BUS_DRIVER_IN_SLOT_FUNCTION_POWER, *PBUS_DRIVER_IN_SLOT_FUNCTION_POWER;

// DDK api status codes
#define SD_API_STATUS_SUCCESS                          ((SD_API_STATUS)0x00000000L)
#define SD_API_STATUS_PENDING                          ((SD_API_STATUS)0x00000001L)
#define SD_API_STATUS_FAST_PATH_SUCCESS                ((SD_API_STATUS)0x00000002L)
#define SD_API_STATUS_FAST_PATH_OPT_SUCCESS            ((SD_API_STATUS)0x00000003L)
#define SD_API_STATUS_BUFFER_OVERFLOW                  ((SD_API_STATUS)0xC0000001L)
#define SD_API_STATUS_DEVICE_BUSY                      ((SD_API_STATUS)0xC0000002L)
#define SD_API_STATUS_UNSUCCESSFUL                     ((SD_API_STATUS)0xC0000003L)
#define SD_API_STATUS_NOT_IMPLEMENTED                  ((SD_API_STATUS)0xC0000004L)
#define SD_API_STATUS_ACCESS_VIOLATION                 ((SD_API_STATUS)0xC0000005L)
#define SD_API_STATUS_INVALID_HANDLE                   ((SD_API_STATUS)0xC0000006L)
#define SD_API_STATUS_INVALID_PARAMETER                ((SD_API_STATUS)0xC0000007L)
#define SD_API_STATUS_NO_SUCH_DEVICE                   ((SD_API_STATUS)0xC0000008L)
#define SD_API_STATUS_INVALID_DEVICE_REQUEST           ((SD_API_STATUS)0xC0000009L)
#define SD_API_STATUS_NO_MEMORY                        ((SD_API_STATUS)0xC000000AL)
#define SD_API_STATUS_BUS_DRIVER_NOT_READY             ((SD_API_STATUS)0xC000000BL)
#define SD_API_STATUS_DATA_ERROR                       ((SD_API_STATUS)0xC000000CL)
#define SD_API_STATUS_CRC_ERROR                        ((SD_API_STATUS)0xC000000DL)
#define SD_API_STATUS_INSUFFICIENT_RESOURCES           ((SD_API_STATUS)0xC000000EL)
#define SD_API_STATUS_DEVICE_NOT_CONNECTED             ((SD_API_STATUS)0xC0000010L)
#define SD_API_STATUS_DEVICE_REMOVED                   ((SD_API_STATUS)0xC0000011L)
#define SD_API_STATUS_DEVICE_NOT_RESPONDING            ((SD_API_STATUS)0xC0000012L)
#define SD_API_STATUS_CANCELED                         ((SD_API_STATUS)0xC0000013L)
#define SD_API_STATUS_RESPONSE_TIMEOUT                 ((SD_API_STATUS)0xC0000014L)
#define SD_API_STATUS_DATA_TIMEOUT                     ((SD_API_STATUS)0xC0000015L)
#define SD_API_STATUS_DEVICE_RESPONSE_ERROR            ((SD_API_STATUS)0xC0000016L)
#define SD_API_STATUS_DEVICE_UNSUPPORTED               ((SD_API_STATUS)0xC0000017L)
#define SD_API_STATUS_SHUT_DOWN                        ((SD_API_STATUS)0xC0000018L)
#define SD_API_STATUS_INSUFFICIENT_HOST_POWER          ((SD_API_STATUS)0xC0000019L)


// macro to test for success
#define SD_API_SUCCESS(Status) ((SD_API_STATUS)(Status) >= 0)

// macro to test for success where a SD_API_STATUS_TIMEOUT is okay
#define SD_API_SUCCESS_RESPONSE_TIMEOUT_OK(Status) (((SD_API_STATUS)(Status) >= 0) || (SD_API_STATUS_RESPONSE_TIMEOUT == (SD_API_STATUS)(Status)))

// macro to test explicitly for time out 
#define SD_API_RESPONSE_TIMEOUT(Status) (SD_API_STATUS_RESPONSE_TIMEOUT == (SD_API_STATUS)(Status))

// debug zone slot IDs - user assignable slots
#define SDCARD_ZONESLOT_0             0
#define SDCARD_ZONESLOT_1             1
#define SDCARD_ZONESLOT_2             2
#define SDCARD_ZONESLOT_3             3
#define SDCARD_ZONESLOT_4             4
#define SDCARD_ZONESLOT_5             5
#define SDCARD_ZONESLOT_6             6
#define SDCARD_ZONESLOT_7             7
#define SDCARD_ZONESLOT_8             8
#define SDCARD_ZONESLOT_9             9
#define SDCARD_ZONESLOT_CELOG         10
// reserved slots
#define SDCARD_ZONESLOT_FUNC          11
#define SDCARD_ZONESLOT_INFO          12
#define SDCARD_ZONESLOT_INIT          13
#define SDCARD_ZONESLOT_WARN          14
#define SDCARD_ZONESLOT_ERROR         15

// zone enable bit definitions
#define ZONE_ENABLE_0               (1 << SDCARD_ZONESLOT_0)
#define ZONE_ENABLE_1               (1 << SDCARD_ZONESLOT_1)
#define ZONE_ENABLE_2               (1 << SDCARD_ZONESLOT_2)
#define ZONE_ENABLE_3               (1 << SDCARD_ZONESLOT_3)
#define ZONE_ENABLE_4               (1 << SDCARD_ZONESLOT_4)
#define ZONE_ENABLE_5               (1 << SDCARD_ZONESLOT_5)
#define ZONE_ENABLE_6               (1 << SDCARD_ZONESLOT_6)
#define ZONE_ENABLE_7               (1 << SDCARD_ZONESLOT_7)
#define ZONE_ENABLE_8               (1 << SDCARD_ZONESLOT_8)
#define ZONE_ENABLE_9               (1 << SDCARD_ZONESLOT_9)
#define ZONE_ENABLE_CELOG           (1 << SDCARD_ZONESLOT_CELOG)
#define ZONE_ENABLE_FUNC            (1 << SDCARD_ZONESLOT_FUNC)
#define ZONE_ENABLE_INFO            (1 << SDCARD_ZONESLOT_INFO)
#define ZONE_ENABLE_INIT            (1 << SDCARD_ZONESLOT_INIT)
#define ZONE_ENABLE_WARN            (1 << SDCARD_ZONESLOT_WARN)
#define ZONE_ENABLE_ERROR           (1 << SDCARD_ZONESLOT_ERROR)

// debug zones masks macros
#define SDCARD_ZONE_0          DEBUGZONE(SDCARD_ZONESLOT_0)
#define SDCARD_ZONE_1          DEBUGZONE(SDCARD_ZONESLOT_1)
#define SDCARD_ZONE_2          DEBUGZONE(SDCARD_ZONESLOT_2)
#define SDCARD_ZONE_3          DEBUGZONE(SDCARD_ZONESLOT_3)
#define SDCARD_ZONE_4          DEBUGZONE(SDCARD_ZONESLOT_4)
#define SDCARD_ZONE_5          DEBUGZONE(SDCARD_ZONESLOT_5)
#define SDCARD_ZONE_6          DEBUGZONE(SDCARD_ZONESLOT_6)
#define SDCARD_ZONE_7          DEBUGZONE(SDCARD_ZONESLOT_7)
#define SDCARD_ZONE_8          DEBUGZONE(SDCARD_ZONESLOT_8)
#define SDCARD_ZONE_9          DEBUGZONE(SDCARD_ZONESLOT_9)
#define SDCARD_ZONE_CELOG      DEBUGZONE(SDCARD_ZONESLOT_CELOG)
#define SDCARD_ZONE_FUNC       DEBUGZONE(SDCARD_ZONESLOT_FUNC)
#define SDCARD_ZONE_INFO       DEBUGZONE(SDCARD_ZONESLOT_INFO)
#define SDCARD_ZONE_INIT       DEBUGZONE(SDCARD_ZONESLOT_INIT)
#define SDCARD_ZONE_WARN       DEBUGZONE(SDCARD_ZONESLOT_WARN)
#define SDCARD_ZONE_ERROR      DEBUGZONE(SDCARD_ZONESLOT_ERROR)


#define SDCARD_WAKE_ON_SDIO_INTERRUPTS_VALNAME  _T("WakeOnSDIOInterrupts")
#define SDCARD_WAKE_ON_SDIO_INTERRUPTS_VALTYPE  REG_DWORD


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

    //  SDRegisterClient()
    typedef SD_API_STATUS (*PSD_REGISTER_CLIENT) (SD_DEVICE_HANDLE, 
        PVOID, 
        PSDCARD_CLIENT_REGISTRATION_INFO);

    //  SDSynchronousBusRequest 
    typedef SD_API_STATUS (*PSD_SYNCHRONOUS_BUS_REQUEST) (SD_DEVICE_HANDLE, 
        UCHAR,
        DWORD,
        SD_TRANSFER_CLASS,
        SD_RESPONSE_TYPE,
        PSD_COMMAND_RESPONSE ,
        ULONG,
        ULONG,
        PUCHAR,
        DWORD,
        DWORD,
        PPHYS_BUFF_LIST);

    //  SDBusRequest 
    typedef SD_API_STATUS (*PSDBUS_REQUEST) (SD_DEVICE_HANDLE ,
        UCHAR,
        DWORD,
        SD_TRANSFER_CLASS ,
        SD_RESPONSE_TYPE ,
        ULONG ,
        ULONG ,
        PUCHAR ,
        PSD_BUS_REQUEST_CALLBACK,
        DWORD,
        PSD_BUS_REQUEST*,
        DWORD,
        DWORD,
        PPHYS_BUFF_LIST);


    //  SDCancelBusRequest 
    typedef BOOLEAN (*PSD_CANCEL_BUS_REQUEST) (PSD_BUS_REQUEST);


    //  SDFreeBusRequest
    typedef VOID (*PSD_FREE_BUS_REQUEST) (PSD_BUS_REQUEST);


    //  SDCardRegistersQuery 
    typedef SD_API_STATUS (*PSD_CARD_INFO_QUERY) (SD_DEVICE_HANDLE,
        SD_INFO_TYPE,
        PVOID,
        ULONG);


    //  SDReadWriteRegisterDirect
    typedef SD_API_STATUS (*PSD_READ_WRITE_REGISTER_DIRECT)(SD_DEVICE_HANDLE,
        SD_IO_TRANSFER_TYPE,
        UCHAR,
        DWORD,
        BOOLEAN,
        PUCHAR,
        ULONG);
    // SDGetTuple
    typedef SD_API_STATUS (*PSD_GET_TUPLE)(SD_DEVICE_HANDLE,
        UCHAR,
        PUCHAR,
        PULONG,
        BOOL);

    // SDIOConnectInterrupt
    typedef SD_API_STATUS (*PSD_IO_CONNECT_INTERRUPT) (SD_DEVICE_HANDLE, 
        PSD_INTERRUPT_CALLBACK);

    // SDIODisconnectInterrupt
    typedef VOID (*PSD_IO_DISCONNECT_INTERRUPT) (SD_DEVICE_HANDLE);

    //  SDSetCardFeature
    typedef SD_API_STATUS (*PSD_SET_CARD_FEATURE) (SD_DEVICE_HANDLE,
        SD_SET_FEATURE_TYPE,
        PVOID,
        ULONG);

    typedef SD_API_STATUS (*PSD_BUS_REQUEST_RESPONSE)(HANDLE, PSD_COMMAND_RESPONSE );
    
    // SD Card Api function structure definition
    typedef struct _SDCARD_API_FUNCTIONS {
        DWORD                           dwSize;
        PSD_REGISTER_CLIENT             pSDRegisterClient;
        PSD_SYNCHRONOUS_BUS_REQUEST     pSDSynchronousBusRequest;
        PSDBUS_REQUEST                  pSDBusRequest;
        PSD_FREE_BUS_REQUEST            pSDFreeBusRequest;
        PSD_CARD_INFO_QUERY             pSDCardInfoQuery;
        PSD_READ_WRITE_REGISTER_DIRECT  pSDReadWriteRegistersDirect;
        PSD_CANCEL_BUS_REQUEST          pSDCancelBusRequest;
        PSD_GET_TUPLE                   pSDGetTuple;
        PSD_IO_CONNECT_INTERRUPT        pSDIOConnectInterrupt;
        PSD_IO_DISCONNECT_INTERRUPT     pSDIODisconnectInterrupt;
        PSD_SET_CARD_FEATURE            pSDSetCardFeature;
        PSD_BUS_REQUEST_RESPONSE        pSdBusRequestResponse;
    }SDCARD_API_FUNCTIONS, *PSDCARD_API_FUNCTIONS;

    // global variable containing function pointers to SD Card api
    extern SDCARD_API_FUNCTIONS g_SDClientApiFunctions;

    // debug output function
    VOID SDCardDebugOutput(TCHAR *pDebugText, ...);

#ifdef DEBUG

    //  SDRegisterDebugZones - register a client device
    //  Input:  hDevice - device handle
    //          pRegPath - pointer to registry path
    //          
    //  Output:
    //  Return: 
    //  Notes:  
    //
    VOID SDRegisterDebugZones(SD_DEVICE_HANDLE hDevice, PTSTR);

#else

#define SDRegisterDebugZones(hDevice, reserved)

#endif // DEBUG


    // Sending debug output to a file is no longer supported.
#define SDInitializeOutputToFile(pFileName, MaxFileLength)
#define SDDeinitializeOutputToFile()
#define SDSwitchDebugOutput(OutputToFile)
#define SD_CHECK_OUTPUT_TO_FILE(pPath)


    //  SDInitializeQueue - initialize a driver allocated request queue
    //  Input:  pQueue - queue to initialize        
    //  Output: 
    //  Return: 
    //  Notes:
    //
    VOID SDInitializeQueue(PSD_REQUEST_QUEUE pQueue);

    //  SDQueueBusRequest - queue a request (FIFO order)
    //  Input:  pQueue - queue to use
    //          pRequest - request to add to queue        
    //  Output: 
    //  Return: 
    //  Notes:
    //
    VOID SDQueueBusRequest(PSD_REQUEST_QUEUE pQueue, PSD_BUS_REQUEST pRequest); 

    //  SDDequeueBusRequest - de-queue a request (FIFO order)
    //  Input:  pQueue - the queue        
    //  Output: 
    //  Return: the first request queued , otherwise NULL if request queue is empty 
    //  Notes:
    //
    PSD_BUS_REQUEST SDDequeueBusRequest(PSD_REQUEST_QUEUE pQueue);


    //  SDGetCurrentRequest - Get the current request at the front of the queue
    //                        but do not remove it from the queue
    //  Input:  pQueue - the queue        
    //  Output: 
    //  Return: the current request that is at the front of the queue (FIFO orer)
    //          NULL if the queue is empty
    //  Notes:
    //
    PSD_BUS_REQUEST SDGetCurrentRequest(PSD_REQUEST_QUEUE pQueue);


    //  SDRemoveEntryFromQueue - remove an entry from the queue
    //  Input:  pQueue - queue to use
    //          pRequest - request to be removed       
    //  Output: 
    //  Return: 
    //  Notes:
    //
    VOID SDRemoveEntryFromQueue(PSD_REQUEST_QUEUE pQueue, PSD_BUS_REQUEST pRequest); 

    //  GetBitSlice - Get a bit slice from a byte buffer
    //  Input:  pBuffer - buffer containing data 
    //          BufferSize - size of buffer in bytes
    //          BitOffset - bit offset from start of buffer
    //          NumberOfBits - number of bits (less than or equal to 32)
    //  Output: 
    //
    //  Return: returns a DWORD contain the bit slice shifted to fill the least significant bits
    //  Notes:  
    //
    DWORD GetBitSlice(PUCHAR pBuffer, ULONG BufferSize, DWORD BitOffset, UCHAR NumberOfBits);

    //  SDGetDeviceHandle - Get the device handle from the context passed in
    //                      XXX_Init
    //  Input:  InitContext - Context passed in XXX_Init
    //          
    //  Output: ppRegPath - registry path of device (optional)
    //  Return: SD_DEVICE_HANDLE
    //  Notes:  
    //      returns SD Client Device Handle or NULL on failure
    //      Caller must free ppRegPath using SDFreeMemory()
    //
    SD_DEVICE_HANDLE SDGetDeviceHandle(DWORD InitContext, PWCHAR *ppRegPath);

    //  SDGetCardStatusFromResponse - get the card status from a response
    //  Input:  pCardResponse - the card response
    //          
    //  Output:
    //  Return: 
    //  Notes:  
    //     the response must be of type R1 or R1b
    //

#define SDGetCardStatusFromResponse(pCardResponse, pCardStatus) \
    memcpy((pCardStatus), &(pCardResponse)->ResponseBuffer[1], sizeof(SD_CARD_STATUS))

    //  SDRegisterClient - register a client device
    //  Input:  hDevice - device handle
    //          pDeviceContext  - device specific context allocated by driver
    //          pInfo  - registration information
    //          
    //  Output: 
    //  Return: SD API Status
    //  Notes:
    //     
    //      
    SD_API_STATUS SDRegisterClient(SD_DEVICE_HANDLE                 hDevice, 
        PVOID                            pDeviceContext, 
        PSDCARD_CLIENT_REGISTRATION_INFO pInfo);


    //  SDGetRegPathFromInitContext - Get the real device registry path from the context 
    //                                passed in XXX_Init
    //  Input:  pActivePath - the active path
    //          Length      - length in bytes of pRegPath
    //  Output: pRegPath - caller supplied storage for the registry path
    //
    //  Return: SD API Status
    //  Notes:  
    //      For streams drivers the InitContext passed in the XXX_Init entry point
    //      is the active registry path and not the real path of the device.
    //      This function can be used to retrieve the real path.
    //
    //      returns WIN32 Error
    //
    DWORD SDGetRegPathFromInitContext(PWCHAR pActivePath, PWCHAR pRegPath, ULONG Length);


    //  SDGetClientFunctions - get the client function table
    //  Input:  pClientFunctions - function table
    //  Return: SD API Status
    //
    SD_API_STATUS SDGetClientFunctions(PSDCARD_API_FUNCTIONS pClientFunctions);


    //  SDSynchronousBusRequest - send an SD Bus request synchronously
    //  Input:  hDevice -  device handle
    //          Command - command to send
    //          Argument - argument for command
    //          TransferClass - Command only, or associated with read/write data
    //          ResponseType - expected response
    //          NumBlocks   - number of blocks
    //          BlockSize   - block size
    //          pBuffer     - block buffer
    //          Flags       - request flags
    //          
    //  Output: pResponse - caller allocated storage for the return response 
    //  Return: SD API Status    
    //  Notes:  
    //        This function provides a synchronous (blocking) call to perform a 
    //        bus request.  This function should not be called in a bus request callback
    //        which can be called in a dispatch context.  Calling this function
    //        within a Bus Request callback will result in a deadlock.
    //
#define SDSynchronousBusRequest(hDevice, \
    Command, \
    Argument, \
    TransferClass, \
    ResponseType, \
    pResponse, \
    NumBlocks, \
    BlockSize, \
    pBuffer,   \
    Flags)     \
    g_SDClientApiFunctions.pSDSynchronousBusRequest((hDevice),(Command),(Argument),(TransferClass), \
    (ResponseType),(pResponse), \
    (NumBlocks), (BlockSize), (pBuffer), ((Flags)&~SD_BUS_REQUEST_PHYS_BUFFER),0,NULL)

    //  SDBusRequest - send command over SD bus
    //  Input:  hDevice       - SD device handle
    //          Command       - SD command to send over bus
    //          Argument      - 32 bit argument specific to the command
    //          TransferClass - Command only, or associated with read/write data
    //          ResponseType  - the response type for the command
    //          NumBlocks     - Number of data blocks in pBlockArray, can be zero
    //                          if transfer class is not read or write
    //          BlockSize     - Size of data blocks in pBlockArray. All blocks
    //                          must be same size.
    //          pBuffer       - Pointer to buffer containing BlockSize*NumBlocks bytes
    //          pCallback     - completion callback
    //          RequestParam  - optional driver specific parameter for this request
    //          Flags         - bus request flags
    //  Output: pRequest      - newly allocated request
    //  Return: SD API Status
    //  Notes:  
    //          Must call free request in the completion callback
    //
#define  SDBusRequest(hDevice, \
    Command, \
    Argument, \
    TransferClass, \
    ResponseType, \
    NumBlocks, \
    BlockSize, \
    pBuffer,   \
    pCallback, \
    RequestParam,\
    pRequest,    \
    Flags)       \
    g_SDClientApiFunctions.pSDBusRequest((hDevice),(Command),(Argument),(TransferClass), \
    (ResponseType),(NumBlocks),(BlockSize), \
    (pBuffer), (pCallback), (RequestParam), (pRequest), ((Flags)&~SD_BUS_REQUEST_PHYS_BUFFER),0,NULL)

    //  SDSynchronousBusRequest - send an SD Bus request synchronously
    //  Input:  hDevice -  device handle
    //          Command - command to send
    //          Argument - argument for command
    //          TransferClass - Command only, or associated with read/write data
    //          ResponseType - expected response
    //          NumBlocks   - number of blocks
    //          BlockSize   - block size
    //          pBuffer     - block buffer
    //          Flags       - request flags
    //          cbSize        - pPyysBuffList structure size in byte. it only valid when SD_BUS_REQUEST_PHYS_BUFFER is set in Flags
    //          pPhysBuffList - physical buffer list.
    //          
    //  Output: pResponse - caller allocated storage for the return response 
    //  Return: SD API Status    
    //  Notes:  
    //        This function provides a synchronous (blocking) call to perform a 
    //        bus request.  This function should not be called in a bus request callback
    //        which can be called in a dispatch context.  Calling this function
    //        within a Bus Request callback will result in a deadlock.
    //
#define SDSynchronousBusRequestEx(hDevice, \
    Command, \
    Argument, \
    TransferClass, \
    ResponseType, \
    pResponse, \
    NumBlocks, \
    BlockSize, \
    pBuffer,   \
    Flags, \
    cbSize, \
    pPhysBuffList)     \
    g_SDClientApiFunctions.pSDSynchronousBusRequest((hDevice),(Command),(Argument),(TransferClass), \
    (ResponseType),(pResponse), \
    (NumBlocks), (BlockSize), (pBuffer), (Flags),(cbSize),(pPhysBuffList))

    //  SDBusRequestEx - send command over SD bus with physical buffer
    //  Input:  hDevice       - SD device handle
    //          Command       - SD command to send over bus
    //          Argument      - 32 bit argument specific to the command
    //          TransferClass - Command only, or associated with read/write data
    //          ResponseType  - the response type for the command
    //          NumBlocks     - Number of data blocks in pBlockArray, can be zero
    //                          if transfer class is not read or write
    //          BlockSize     - Size of data blocks in pBlockArray. All blocks
    //                          must be same size.
    //          pBuffer       - Pointer to buffer containing BlockSize*NumBlocks bytes
    //          pCallback     - completion callback
    //          RequestParam  - optional driver specific parameter for this request
    //          Flags         - bus request flags
    //          cbSize        - pPyysBuffList structure size in byte. it only valid when SD_BUS_REQUEST_PHYS_BUFFER is set in Flags
    //          pPhysBuffList - physical buffer list.
    //  Output: pRequest      - newly allocated request
    //  Return: SD API Status
    //  Notes:  
    //          Must call free request in the completion callback
    //
#define  SDBusRequestEx(hDevice, \
    Command, \
    Argument, \
    TransferClass, \
    ResponseType, \
    NumBlocks, \
    BlockSize, \
    pBuffer,   \
    pCallback, \
    RequestParam,\
    pRequest,    \
    Flags, \
    cbSize, \
    pPhysBuffList)     \
    g_SDClientApiFunctions.pSDBusRequest((hDevice),(Command),(Argument),(TransferClass), \
    (ResponseType),(NumBlocks),(BlockSize), \
    (pBuffer), (pCallback), (RequestParam), (pRequest), (Flags),(cbSize),(pPhysBuffList))
    //  SDCancelBusRequest - Cancel an outstanding bus request
    //  Input:  
    //          pRequest - request to cancel,(returned from SDBusRequest)
    //  Output: 
    //  Return: TRUE if request was cancelled , FALSE if the request is still pending
    //  Notes:
    //
#define SDCancelBusRequest(pRequest) g_SDClientApiFunctions.pSDCancelBusRequest((pRequest))


    //  SDFreeBusRequest - free a bus request
    //  Input:  pRequest        
    //  Output: 
    //  Return: 
    //  Notes:
    //          this function should be called when the request has completed, 
    //          typically in the completion callback
    //
#define SDFreeBusRequest(pRequest) g_SDClientApiFunctions.pSDFreeBusRequest((pRequest))

    //  SDCardInfoQuery        - Obtain Card information
    //  Input:  hDevice        - SD Device Handle
    //          InfoType       - information to get
    //          StructureSize  - size of info structure
    //  Output: pCardInfo      - Information specific structure 
    //  Return: SD_API_STATUS code
    //  Notes:  pCardInfo must point to sufficient memory for the informtaion type
    //    
#define SDCardInfoQuery(hDevice,         \
    InfoType,        \
    pCardInfo,       \
    StructureSize)   \
    g_SDClientApiFunctions.pSDCardInfoQuery((hDevice), (InfoType), (pCardInfo), \
    (StructureSize))


    //  SDReadWriteRegistersDirect - Read/Write I/O register(s) direct
    //  Input:  hDevice - the device handle
    //          ReadWrite - read write flag 
    //          Function - Function number
    //          Address -  starting address
    //          ReadAfterWrite - flag to instruct card to read after write
    //          pBuffer -   buffer to hold value of registers
    //          Length - number of bytes to read/write
    //      
    //  Output: 
    //  Return: SD_API_STATUS code
    //  Notes:  
    //          This function can be called to read or write multiple contiguous registers synchronously
    //          using the SDIO RW_DIRECT command. This function issues multiple commands to transfer
    //          to or from the user's buffer
    //          If ReadAfterWrite is set to 1, the operation will instruct the card
    //          to return the new value of the register in the response.  
    //
#define SDReadWriteRegistersDirect(hDevice,          \
    ReadWrite,        \
    Function,         \
    Address,          \
    ReadAfterWrite,   \
    pBuffer,          \
    Length)           \
    g_SDClientApiFunctions.pSDReadWriteRegistersDirect((hDevice), (ReadWrite), (Function),     \
    (Address), (ReadAfterWrite), (pBuffer), \
    (Length))


    //  SDGetTuple - Get tuple data from CIS
    //  Input:  hDevice   - SD device handle
    //          TupleCode - Tuple code
    //          pBufferSize - size of buffer to store Tuple Data
    //  Output: pBuffer   - Tuple data is copied here (optional)
    //          pBufferSize - if pBuffer is NULL, this will store the size of the
    //          CommonCIS - flag indicating common or function CIS
    //  Return: SD_API_STATUS code
    //          
    //  Notes: The caller should initially call this function with a NULL buffer
    //         to determine the size of the tuple.  The variable pBufferSize points
    //         to the caller supplied storage for this result.   If no bus errors occurs
    //         the function returns SD_API_STATUS_SUCCESS.   The caller must check 
    //         the value of the buffer size returned.  If the value is non-zero, the
    //         tuple exists and can be fetched by calling this function again with a
    //         non-zero buffer.
    //
#define  SDGetTuple(hDevice,    \
    TupleCode,  \
    pBuffer,    \
    pBufferSize,\
    CommonCIS)  \
    g_SDClientApiFunctions.pSDGetTuple((hDevice), (TupleCode), (pBuffer), (pBufferSize),(CommonCIS))

    //  SDIOConnectInterrupt  - Associate an interrupt service routine for an SDIO
    //                          peripheral interrupt
    //  Input:  hDevice   - SD device handle
    //          pIsrFunction - the Interrupt service routine
    //  Output: 
    //  Return: SD_API_STATUS code
    //          
    //  Notes: This function is provided for an SDIO peripheral driver to 
    //         register an interrupt routine for the device. 
    //         The interrupt function has the form of PSD_INTERRUPT_CALLBACK.
    //         The caller should call SDIODisconnectInterrupt when cleaning up
    //         the device. The bus driver will enable the interrupt for the function in the
    //         card's CCCR area prior to returning from this function. 
    //         The interrupt callback is called whenever the device function is 
    //         interrupting. The bus driver will determine the interrupting function,
    //         disable the interrupt on the card and call the callback.  Upon return 
    //         from the callback the bus driver will reenable the interrupt in the
    //         card's CCCR.
    //
#define SDIOConnectInterrupt(hDevice,      \
    pIsrFunction) \
    g_SDClientApiFunctions.pSDIOConnectInterrupt((hDevice), (pIsrFunction))

    //  SDIODisconnectInterrupt  - disconnect the interrupt 
    //  Input:  hDevice   - SD device handle
    //  Output: 
    //  Return: 
    //          
    //  Notes: This function should be called to disconnect the interrupt
    //         from the device. The bus driver will disable the interrupt in the
    //         card's CCCR area
    //
#define SDIODisconnectInterrupt(hDevice) \
    g_SDClientApiFunctions.pSDIODisconnectInterrupt((hDevice))

    //  SDSetCardFeature       - Set card feature
    //  Input:  hDevice        - SD Device Handle
    //          CardFeature    - Card Feature to set
    //          StructureSize  - size of card feature structure
    //  Output: pCardInfo      - Information for the feature
    //  Return: SD_API_STATUS code
    //  Notes:  This function is provided to set various card features
    //          in a thread safe manner.  SDIO cards utilize shared register sets
    //          between functions. This requires that the 
    //          register state be preserved between functions that can be 
    //          controlled in separate thread contexts.
    //          This function can potentially block by issuing synchronous bus 
    //          request.  This function must not be called from a bus request callback
    //
#define SDSetCardFeature(hDevice,         \
    CardFeature,     \
    pCardInfo,       \
    StructureSize)   \
    g_SDClientApiFunctions.pSDSetCardFeature((hDevice), (CardFeature), (pCardInfo), \
    (StructureSize))

    //  SDFreeBusRequest - free a bus request
    //  Input:  pRequest        
    //  Output: 
    //  Return: 
    //  Notes:
    //          this function should be called when the request has completed, 
    //          typically in the completion callback
    //
#define SdBusRequestResponse(pRequest,pSdCmdResp) g_SDClientApiFunctions.pSdBusRequestResponse(pRequest,pSdCmdResp)


    //  SDPerformSafeCopy - perform a safe memory copy
    //  Input:  pSource   - source data
    //          Length    - number of bytes to copy
    //  Output: pDestination - Destination of the copy
    //  Return:  returns TRUE if the copy succeeded, FALSE if an exception  occured
    //  Notes:  
    BOOLEAN SDPerformSafeCopy(
        __out_bcount(Length)    PVOID pDestination, 
        __in_bcount(Length)     const VOID *pSource,
                                ULONG Length);

    //  SDProcessException - main SD exception handler
    //  Input:  
    //          pException - exception record passed in from the kernel
    //  Output: 
    //  Return:
    //  Notes:  
    DWORD SDProcessException(LPEXCEPTION_POINTERS pException);

    // macro to set the process permissions to the specified access key
    // caller must call RESTORE_PROC_PERMISSIONS in braces

//  SDOutputBuffer - dump buffer to debugger
//  Input:  
//          pBuffer - the buffer to dump
//          BufferSize - size of buffer in bytes
//  Output: 
//  Notes:  
//          This function prints the buffer to the debugger using
//          16 bytes per line and displays the ASCII character respresentation 
//          per line, if the character is not displayable, a '.' is used
//
VOID SDOutputBuffer(PVOID pBuffer, ULONG BufferSize);


#ifdef __cplusplus
}
#endif //__cplusplus


#ifdef DEBUG

// register zones macro
// Input: hInstance - Dll hInstance 
//        pPath   - registry path for ZoneMask override value
// get initial zone override value from register if one exists
// use this value to overide the initial zone value
#define SD_DEBUG_ZONE_REGISTER(hInstance, reserved)    DEBUGREGISTER(hInstance)

// this macro instantiates the global debug variable
#define SD_DEBUG_INSTANTIATE_ZONES(ModuleName, InitialValue, Slot0, Slot1, Slot2, Slot3, Slot4, Slot5, Slot6, Slot7, Slot8, Slot9, Slot10) \
    DBGPARAM dpCurSettings =        \
{                               \
    ModuleName,                 \
{                           \
    Slot0,                  \
    Slot1,                  \
    Slot2,                  \
    Slot3,                  \
    Slot4,                  \
    Slot5,                  \
    Slot6,                  \
    Slot7,                  \
    Slot8,                  \
    Slot9,                  \
    TEXT("CELOGMSG"),       \
    TEXT("Functions"),      \
    TEXT("Information"),    \
    TEXT("Init"),           \
    TEXT("Warnings"),       \
    TEXT("Errors"),         \
},                          \
    (InitialValue)              \
};


#define DbgPrintZo(m, s) \
    ((void)((m)?(SDCardDebugOutput s),1:0))

#else   // no DEBUG
#define SD_DEBUG_ZONE_REGISTER(hInstance, reserved) 
#define SD_DEBUG_INSTANTIATE_ZONES(ModuleName, InitialValue, Slot0, Slot1, Slot2, Slot3, Slot4, Slot5, Slot6, Slot7, Slot8, Slot9, Slot10)
#define DbgPrintZo(m, s)
#endif  // DEBUG

#ifndef SHIP_BUILD
#define DbgPrintRetail(s)   SDCardDebugOutput s
#else
#define DbgPrintRetail(s)
#endif


#if DEBUG

// will break into the debugger if the expression is false
// Input:  an expression to test
// Output: 
#define DEBUG_ASSERT(t) DEBUGCHK(t)

#define DEBUG_CHECK(t,s)\
    if (!(t)) {\
    DbgPrintZo(-1,s); \
    DebugBreak();\
    }

#else   // DEBUG

#define DEBUG_ASSERT(t)
#define DEBUG_CHECK(t,s)

#endif  // DEBUG


#define MAX_SD_DESCRIPTION_STRING (MAX_SDCARD_CLIENT_NAME*2)

// bus driver name
#define SDCARD_BUS_DRIVER_DEVICE_NAME TEXT("SDC1:")

// bus driver ioctls
// Note: 0 and 1 are reserved.

// Output: DWORD - number of slots in the system
//
#define IOCTL_SD_BUS_DRIVER_GET_SLOT_COUNT\
    CTL_CODE(0, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Output: BUS_DRIVER_SLOT_INFO array
#define IOCTL_SD_BUS_DRIVER_GET_SLOT_INFO\
    CTL_CODE(0, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Output: DWORD, Upper 16 bits = Version Major, Lower 16 bits = Version Minor
#define IOCTL_SD_BUS_DRIVER_GET_VERSION\
    CTL_CODE(0, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

    // Reset SD/MMC/SDIO/Combo/Multifunction card
#define IOCTL_SD_BUS_DRIVER_SLOT_CARD_RESET\
            CTL_CODE(0, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

    // Select SD/MMC/SDIO/Combo/Multifunction card 
#define IOCTL_SD_BUS_DRIVER_SLOT_CARD_SELECT\
            CTL_CODE(0, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

    // Deselect SD/MMC/SDIO/Combo/Multifunction card
#define IOCTL_SD_BUS_DRIVER_SLOT_CARD_DESELECT\
            CTL_CODE(0, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)

    // Output: Power Control Slot or Function Data  
#define IOCTL_SD_BUS_DRIVER_GET_SLOT_POWER_CONTROL\
            CTL_CODE(0, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)

   // Disable power control for slot on next insertion (if supported)  
#define IOCTL_SD_BUS_DRIVER_DISABLE_SLOT_POWER_CONTROL\
            CTL_CODE(0, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)

   // Enable power control for slot on next insertion (if supported)  
#define IOCTL_SD_BUS_DRIVER_ENABLE_SLOT_POWER_CONTROL\
            CTL_CODE(0, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_SD_BUS_DRIVER_GET_BUS_VERSION  \
    CTL_CODE(0, 11, METHOD_BUFFERED, FILE_READ_ACCESS)

// Output: BUS_DRIVER_SLOT_INFO_EX array
#define IOCTL_SD_BUS_DRIVER_GET_SLOT_INFO_EX\
    CTL_CODE(0, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)

// slot info structure (one per slot)
typedef struct _BUS_DRIVER_SLOT_INFO {
    DWORD              HostIndex;       // host controller index
    DWORD              SlotIndex;       // slot index in host controller
    BOOL               CardPresent;     // card is present
    SDCARD_DEVICE_TYPE DeviceType;
    WCHAR              Description[MAX_SD_DESCRIPTION_STRING]; // device description string
    SD_CARD_INTERFACE  CardInterface;   // card interface
}BUS_DRIVER_SLOT_INFO, *PBUS_DRIVER_SLOT_INFO;

// EX version of slot info structure  (one per slot)
typedef struct _BUS_DRIVER_SLOT_INFO_EX {
    DWORD              HostIndex;       // host controller index
    DWORD              SlotIndex;       // slot index in host controller
    BOOL               CardPresent;     // card is present
    SDCARD_DEVICE_TYPE DeviceType;
    WCHAR              Description[MAX_SD_DESCRIPTION_STRING]; // device description string
    SD_CARD_INTERFACE_EX  CardInterfaceEx;   // card interfaceEx
}BUS_DRIVER_SLOT_INFO_EX, *PBUS_DRIVER_SLOT_INFO_EX;


#ifndef dim
// Prefer to use _countof() directly, replacing dim()
#pragma deprecated("dim")
#define dim(x) _countof(x)
#endif

#endif

// DO NOT REMOVE --- END EXTERNALLY DEVELOPED SOURCE CODE ID --- DO NOT REMOVE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sddl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    sddl.w

Abstract:

    This module defines the support and conversions routines necessary for SDDL.

Revision History:

--*/

#ifndef __SDDL_H__
#define __SDDL_H__


#ifdef __cplusplus
extern "C" {
#endif

//
// SDDL Version information
//
#define SDDL_REVISION_1     1
#define SDDL_REVISION       SDDL_REVISION_1

//
// SDDL Component tags
//
#define SDDL_OWNER                          TEXT("O")       // Owner tag
#define SDDL_GROUP                          TEXT("G")       // Group tag
#define SDDL_DACL                           TEXT("D")       // DACL tag
#define SDDL_SACL                           TEXT("S")       // SACL tag

//
// SDDL Security descriptor controls
//
#define SDDL_PROTECTED                      TEXT("P")       // DACL or SACL Protected
#define SDDL_AUTO_INHERIT_REQ               TEXT("AR")      // Auto inherit request
#define SDDL_AUTO_INHERITED                 TEXT("AI")      // DACL/SACL are auto inherited
#define SDDL_NULL_ACL                       TEXT("NO_ACCESS_CONTROL")    // Null ACL

//
// SDDL Ace types
//
#define SDDL_ACCESS_ALLOWED                 TEXT("A")   // Access allowed
#define SDDL_ACCESS_DENIED                  TEXT("D")   // Access denied
#define SDDL_OBJECT_ACCESS_ALLOWED          TEXT("OA")  // Object access allowed
#define SDDL_OBJECT_ACCESS_DENIED           TEXT("OD")  // Object access denied
#define SDDL_AUDIT                          TEXT("AU")  // Audit
#define SDDL_ALARM                          TEXT("AL")  // Alarm
#define SDDL_OBJECT_AUDIT                   TEXT("OU")  // Object audit
#define SDDL_OBJECT_ALARM                   TEXT("OL")  // Object alarm
#define SDDL_MANDATORY_LABEL                TEXT("ML")  // Integrity label

//
// SDDL Ace flags
//
#define SDDL_CONTAINER_INHERIT              TEXT("CI")  // Container inherit
#define SDDL_OBJECT_INHERIT                 TEXT("OI")  // Object inherit
#define SDDL_NO_PROPAGATE                   TEXT("NP")  // Inherit no propagate
#define SDDL_INHERIT_ONLY                   TEXT("IO")  // Inherit only
#define SDDL_INHERITED                      TEXT("ID")  // Inherited
#define SDDL_AUDIT_SUCCESS                  TEXT("SA")  // Audit success
#define SDDL_AUDIT_FAILURE                  TEXT("FA")  // Audit failure


//
// SDDL Rights
//
#define SDDL_READ_PROPERTY                  TEXT("RP")
#define SDDL_WRITE_PROPERTY                 TEXT("WP")
#define SDDL_CREATE_CHILD                   TEXT("CC")
#define SDDL_DELETE_CHILD                   TEXT("DC")
#define SDDL_LIST_CHILDREN                  TEXT("LC")
#define SDDL_SELF_WRITE                     TEXT("SW")
#define SDDL_LIST_OBJECT                    TEXT("LO")
#define SDDL_DELETE_TREE                    TEXT("DT")
#define SDDL_CONTROL_ACCESS                 TEXT("CR")
#define SDDL_READ_CONTROL                   TEXT("RC")
#define SDDL_WRITE_DAC                      TEXT("WD")
#define SDDL_WRITE_OWNER                    TEXT("WO")
#define SDDL_STANDARD_DELETE                TEXT("SD")
#define SDDL_GENERIC_ALL                    TEXT("GA")
#define SDDL_GENERIC_READ                   TEXT("GR")
#define SDDL_GENERIC_WRITE                  TEXT("GW")
#define SDDL_GENERIC_EXECUTE                TEXT("GX")
#define SDDL_FILE_ALL                       TEXT("FA")
#define SDDL_FILE_READ                      TEXT("FR")
#define SDDL_FILE_WRITE                     TEXT("FW")
#define SDDL_FILE_EXECUTE                   TEXT("FX")
#define SDDL_KEY_ALL                        TEXT("KA")
#define SDDL_KEY_READ                       TEXT("KR")
#define SDDL_KEY_WRITE                      TEXT("KW")
#define SDDL_KEY_EXECUTE                    TEXT("KX")
#define SDDL_NO_WRITE_UP                    TEXT("NW")
#define SDDL_NO_READ_UP                     TEXT("NR")
#define SDDL_NO_EXECUTE_UP                  TEXT("NX")


//
// SDDL User alias max size
//      - currently, upto two supported eg. "DA"
//      - modify this if more WCHARs need to be there in future e.g. "DAX"
//

#define SDDL_ALIAS_SIZE                     2

//
// SDDL User aliases
//
#define SDDL_DOMAIN_ADMINISTRATORS          TEXT("DA")      // Domain admins
#define SDDL_DOMAIN_GUESTS                  TEXT("DG")      // Domain guests
#define SDDL_DOMAIN_USERS                   TEXT("DU")      // Domain users
#define SDDL_ENTERPRISE_DOMAIN_CONTROLLERS  TEXT("ED")      // Enterprise domain controllers
#define SDDL_DOMAIN_DOMAIN_CONTROLLERS      TEXT("DD")      // Domain domain controllers
#define SDDL_DOMAIN_COMPUTERS               TEXT("DC")      // Domain computers
#define SDDL_BUILTIN_ADMINISTRATORS         TEXT("BA")      // Builtin (local ) administrators
#define SDDL_BUILTIN_GUESTS                 TEXT("BG")      // Builtin (local ) guests
#define SDDL_BUILTIN_USERS                  TEXT("BU")      // Builtin (local ) users
#define SDDL_LOCAL_ADMIN                    TEXT("LA")      // Local administrator account
#define SDDL_LOCAL_GUEST                    TEXT("LG")      // Local group account
#define SDDL_ACCOUNT_OPERATORS              TEXT("AO")      // Account operators
#define SDDL_BACKUP_OPERATORS               TEXT("BO")      // Backup operators
#define SDDL_PRINTER_OPERATORS              TEXT("PO")      // Printer operators
#define SDDL_SERVER_OPERATORS               TEXT("SO")      // Server operators
#define SDDL_AUTHENTICATED_USERS            TEXT("AU")      // Authenticated users
#define SDDL_PERSONAL_SELF                  TEXT("PS")      // Personal self
#define SDDL_CREATOR_OWNER                  TEXT("CO")      // Creator owner
#define SDDL_CREATOR_GROUP                  TEXT("CG")      // Creator group
#define SDDL_LOCAL_SYSTEM                   TEXT("SY")      // Local system
#define SDDL_POWER_USERS                    TEXT("PU")      // Power users
#define SDDL_EVERYONE                       TEXT("WD")      // Everyone ( World )
#define SDDL_REPLICATOR                     TEXT("RE")      // Replicator
#define SDDL_INTERACTIVE                    TEXT("IU")      // Interactive logon user
#define SDDL_NETWORK                        TEXT("NU")      // Nework logon user
#define SDDL_SERVICE                        TEXT("SU")      // Service logon user
#define SDDL_RESTRICTED_CODE                TEXT("RC")      // Restricted code
#define SDDL_WRITE_RESTRICTED_CODE          TEXT("WR")      // Write Restricted code
#define SDDL_ANONYMOUS                      TEXT("AN")      // Anonymous Logon
#define SDDL_SCHEMA_ADMINISTRATORS          TEXT("SA")      // Schema Administrators
#define SDDL_CERT_SERV_ADMINISTRATORS       TEXT("CA")      // Certificate Server Administrators
#define SDDL_RAS_SERVERS                    TEXT("RS")      // RAS servers group
#define SDDL_ENTERPRISE_ADMINS              TEXT("EA")      // Enterprise administrators
#define SDDL_GROUP_POLICY_ADMINS            TEXT("PA")      // Group Policy administrators
#define SDDL_ALIAS_PREW2KCOMPACC            TEXT("RU")      // alias to allow previous windows 2000
#define SDDL_LOCAL_SERVICE                  TEXT("LS")      // Local service account (for services)
#define SDDL_NETWORK_SERVICE                TEXT("NS")      // Network service account (for services)
#define SDDL_REMOTE_DESKTOP                 TEXT("RD")      // Remote desktop users (for terminal server)
#define SDDL_NETWORK_CONFIGURATION_OPS      TEXT("NO")      // Network configuration operators ( to manage configuration of networking features)
#define SDDL_PERFMON_USERS                  TEXT("MU")      // Performance Monitor Users
#define SDDL_PERFLOG_USERS                  TEXT("LU")      // Performance Log Users
#define SDDL_IIS_USERS                      TEXT("IS")      // Anonymous Internet Users
#define SDDL_CRYPTO_OPERATORS               TEXT("CY")      // Crypto Operators
#define SDDL_OWNER_RIGHTS                   TEXT("OW")      // Owner Rights SID
#define SDDL_EVENT_LOG_READERS              TEXT("ER")      // Event log readers

//
// Integrity Labels
//
#define SDDL_ML_LOW                         TEXT("LW")      // Low mandatory level
#define SDDL_ML_MEDIUM                      TEXT("ME")      // Medium mandatory level
#define SDDL_ML_HIGH                        TEXT("HI")      // High mandatory level
#define SDDL_ML_SYSTEM                      TEXT("SI")      // System mandatory level

//
// SDDL Seperators - character version
//
#define SDDL_SEPERATORC                     TEXT(';')
#define SDDL_DELIMINATORC                   TEXT(':')
#define SDDL_ACE_BEGINC                     TEXT('(')
#define SDDL_ACE_ENDC                       TEXT(')')

//
// SDDL Seperators - string version
//
#define SDDL_SEPERATOR                     TEXT(";")
#define SDDL_DELIMINATOR                   TEXT(":")
#define SDDL_ACE_BEGIN                     TEXT("(")
#define SDDL_ACE_END                       TEXT(")")

#if !defined(_NTDDK_)

#if(_WIN32_WINNT >= 0x0500)

BOOL
WINAPI
ConvertSidToStringSidA(
    IN  PSID     Sid,
    __out_ecount(1) LPSTR  *StringSid
    );
BOOL
WINAPI
ConvertSidToStringSidW(
    IN  PSID     Sid,
    __out_ecount(1) LPWSTR  *StringSid
    );
#ifdef UNICODE
#define ConvertSidToStringSid  ConvertSidToStringSidW
#else
#define ConvertSidToStringSid  ConvertSidToStringSidA
#endif // !UNICODE

BOOL
WINAPI
ConvertStringSidToSidA(
    IN LPCSTR   StringSid,
    OUT PSID   *Sid
    );
BOOL
WINAPI
ConvertStringSidToSidW(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid
    );
#ifdef UNICODE
#define ConvertStringSidToSid  ConvertStringSidToSidW
#else
#define ConvertStringSidToSid  ConvertStringSidToSidA
#endif // !UNICODE

BOOL
WINAPI
ConvertStringSecurityDescriptorToSecurityDescriptorA(
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );
BOOL
WINAPI
ConvertStringSecurityDescriptorToSecurityDescriptorW(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );
#ifdef UNICODE
#define ConvertStringSecurityDescriptorToSecurityDescriptor  ConvertStringSecurityDescriptorToSecurityDescriptorW
#else
#define ConvertStringSecurityDescriptorToSecurityDescriptor  ConvertStringSecurityDescriptorToSecurityDescriptorA
#endif // !UNICODE


BOOL
WINAPI
ConvertSecurityDescriptorToStringSecurityDescriptorA(
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    __out_ecount(1) LPSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );
BOOL
WINAPI
ConvertSecurityDescriptorToStringSecurityDescriptorW(
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    __out_ecount(1) LPWSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );
#ifdef UNICODE
#define ConvertSecurityDescriptorToStringSecurityDescriptor  ConvertSecurityDescriptorToStringSecurityDescriptorW
#else
#define ConvertSecurityDescriptorToStringSecurityDescriptor  ConvertSecurityDescriptorToStringSecurityDescriptorA
#endif // !UNICODE

#endif /* _WIN32_WINNT >=  0x0500 */

#endif /* !defined(_NTDDK_) */


#ifdef __cplusplus
}
#endif

#endif  // endif __SDDL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sal.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*sal.h - markers for documenting the semantics of APIs
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/

#pragma once
/*==========================================================================

   The macros are defined in 3 layers:

   _In_\_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_\_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_\_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ\Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.
   
   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2
   
   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/

#define __ATTR_SAL

// choose attribute or __declspec implementation
#ifndef _USE_DECLSPECS_FOR_SAL
#define _USE_DECLSPECS_FOR_SAL 0
#endif

#if _USE_DECLSPECS_FOR_SAL
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 0
#elif !defined(_USE_ATTRIBUTES_FOR_SAL)
#if _MSC_VER >= 1400
#define _USE_ATTRIBUTES_FOR_SAL 1
#else
#define _USE_ATTRIBUTES_FOR_SAL 0
#endif
#endif

#ifdef _PREFAST_

#if !_USE_DECLSPECS_FOR_SAL
#if !_USE_ATTRIBUTES_FOR_SAL
#if _MSC_VER >= 1400
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 1
#else
#undef _USE_DECLSPECS_FOR_SAL
#define _USE_DECLSPECS_FOR_SAL  1
#endif
#endif
#endif

#endif // #ifdef _PREFAST

// safeguard for MIDL and RC builds
#if _USE_DECLSPECS_FOR_SAL && ( defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) || !defined(_PREFAST_) )
#undef _USE_DECLSPECS_FOR_SAL
#define _USE_DECLSPECS_FOR_SAL 0
#endif
#if _USE_ATTRIBUTES_FOR_SAL && ( !defined(_MSC_EXTENSIONS) || defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) )
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 0
#endif

//============================================================================
//   _In_\_Out_ Layer:
//============================================================================

// 'in' parameters --------------------------

// input pointer parameter
// e.g. void SetPoint( _In_ const POINT* pPT );
#define _In_                           _Pre1_impl_(_$notnull) _Deref_pre2_impl_(_$valid, _$readaccess)
#define _In_opt_                       _Pre_opt_valid_ _Deref_pre_readonly_

// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _In_z_                         _Pre_z_      _Deref_pre_readonly_
#define _In_opt_z_                     _Pre_opt_z_  _Deref_pre_readonly_

// 'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter
#define _In_count_(size)              _Pre_count_(size)         _Deref_pre_readonly_
#define _In_opt_count_(size)          _Pre_opt_count_(size)     _Deref_pre_readonly_
#define _In_bytecount_(size)          _Pre_bytecount_(size)     _Deref_pre_readonly_
#define _In_opt_bytecount_(size)      _Pre_opt_bytecount_(size) _Deref_pre_readonly_

// valid buffer extent described by a constant extression
#define _In_count_c_(size)            _Pre_count_c_(size)         _Deref_pre_readonly_
#define _In_opt_count_c_(size)        _Pre_opt_count_c_(size)     _Deref_pre_readonly_
#define _In_bytecount_c_(size)        _Pre_bytecount_c_(size)     _Deref_pre_readonly_
#define _In_opt_bytecount_c_(size)    _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_

// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter
#define _In_z_count_(size)              _Pre_z_ _Pre_count_(size)         _Deref_pre_readonly_
#define _In_opt_z_count_(size)          _Pre_opt_z_ _Pre_opt_count_(size)     _Deref_pre_readonly_
#define _In_z_bytecount_(size)          _Pre_z_ _Pre_bytecount_(size)     _Deref_pre_readonly_
#define _In_opt_z_bytecount_(size)      _Pre_opt_z_ _Pre_opt_bytecount_(size) _Deref_pre_readonly_

// nullterminated valid buffer extent described by a constant extression
#define _In_z_count_c_(size)            _Pre_z_ _Pre_count_c_(size)         _Deref_pre_readonly_
#define _In_opt_z_count_c_(size)        _Pre_opt_z_ _Pre_opt_count_c_(size)     _Deref_pre_readonly_
#define _In_z_bytecount_c_(size)        _Pre_z_ _Pre_bytecount_c_(size)     _Deref_pre_readonly_
#define _In_opt_z_bytecount_c_(size)    _Pre_opt_z_ _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_

// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _In_ptrdiff_count_(size)      _Pre_ptrdiff_count_(size)     _Deref_pre_readonly_
#define _In_opt_ptrdiff_count_(size)  _Pre_opt_ptrdiff_count_(size) _Deref_pre_readonly_

// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );
#define _In_count_x_(size)            _Pre_count_x_(size)         _Deref_pre_readonly_
#define _In_opt_count_x_(size)        _Pre_opt_count_x_(size)     _Deref_pre_readonly_
#define _In_bytecount_x_(size)        _Pre_bytecount_x_(size)     _Deref_pre_readonly_
#define _In_opt_bytecount_x_(size)    _Pre_opt_bytecount_x_(size) _Deref_pre_readonly_

// 'out' parameters --------------------------

// output pointer parameter
// e.g. void GetPoint( _Out_ POINT* pPT );
#define _Out_                            _Pre_cap_c_(1)            _Pre_invalid_
#define _Out_opt_                        _Pre_opt_cap_c_(1)        _Pre_invalid_

// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter
#define _Out_cap_(size)                  _Pre_cap_(size)           _Pre_invalid_
#define _Out_opt_cap_(size)              _Pre_opt_cap_(size)       _Pre_invalid_
#define _Out_bytecap_(size)              _Pre_bytecap_(size)       _Pre_invalid_
#define _Out_opt_bytecap_(size)          _Pre_opt_bytecap_(size)   _Pre_invalid_

// buffer capacity is described by a constant expression
#define _Out_cap_c_(size)                _Pre_cap_c_(size)         _Pre_invalid_
#define _Out_opt_cap_c_(size)            _Pre_opt_cap_c_(size)     _Pre_invalid_
#define _Out_bytecap_c_(size)            _Pre_bytecap_c_(size)     _Pre_invalid_
#define _Out_opt_bytecap_c_(size)        _Pre_opt_bytecap_c_(size) _Pre_invalid_

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Out_cap_m_(mult,size)           _Pre_cap_m_(mult,size)     _Pre_invalid_
#define _Out_opt_cap_m_(mult,size)       _Pre_opt_cap_m_(mult,size) _Pre_invalid_
#define _Out_z_cap_m_(mult,size)         _Pre_cap_m_(mult,size)     _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_m_(mult,size)     _Pre_opt_cap_m_(mult,size) _Pre_invalid_ _Post_z_

// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _Out_ptrdiff_cap_(size)          _Pre_ptrdiff_cap_(size)     _Pre_invalid_
#define _Out_opt_ptrdiff_cap_(size)      _Pre_opt_ptrdiff_cap_(size) _Pre_invalid_

// buffer capacity is described by a complex expression
#define _Out_cap_x_(size)                _Pre_cap_x_(size)         _Pre_invalid_
#define _Out_opt_cap_x_(size)            _Pre_opt_cap_x_(size)     _Pre_invalid_
#define _Out_bytecap_x_(size)            _Pre_bytecap_x_(size)     _Pre_invalid_
#define _Out_opt_bytecap_x_(size)        _Pre_opt_bytecap_x_(size) _Pre_invalid_

// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter
#define _Out_z_cap_(size)                _Pre_cap_(size)           _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_(size)            _Pre_opt_cap_(size)       _Pre_invalid_ _Post_z_
#define _Out_z_bytecap_(size)            _Pre_bytecap_(size)       _Pre_invalid_ _Post_z_
#define _Out_opt_z_bytecap_(size)        _Pre_opt_bytecap_(size)   _Pre_invalid_ _Post_z_

// buffer capacity is described by a constant expression
#define _Out_z_cap_c_(size)              _Pre_cap_c_(size)         _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_c_(size)          _Pre_opt_cap_c_(size)     _Pre_invalid_ _Post_z_
#define _Out_z_bytecap_c_(size)          _Pre_bytecap_c_(size)     _Pre_invalid_ _Post_z_
#define _Out_opt_z_bytecap_c_(size)      _Pre_opt_bytecap_c_(size) _Pre_invalid_ _Post_z_

// buffer capacity is described by a complex expression
#define _Out_z_cap_x_(size)              _Pre_cap_x_(size)         _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_x_(size)          _Pre_opt_cap_x_(size)     _Pre_invalid_ _Post_z_
#define _Out_z_bytecap_x_(size)          _Pre_bytecap_x_(size)     _Pre_invalid_ _Post_z_
#define _Out_opt_z_bytecap_x_(size)      _Pre_opt_bytecap_x_(size) _Pre_invalid_ _Post_z_

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );
#define _Out_cap_post_count_(cap,count)               _Pre_cap_(cap)         _Pre_invalid_ _Post_count_(count)
#define _Out_opt_cap_post_count_(cap,count)           _Pre_opt_cap_(cap)     _Pre_invalid_ _Post_count_(count)
#define _Out_bytecap_post_bytecount_(cap,count)       _Pre_bytecap_(cap)     _Pre_invalid_ _Post_bytecount_(count)
#define _Out_opt_bytecap_post_bytecount_(cap,count)   _Pre_opt_bytecap_(cap) _Pre_invalid_ _Post_bytecount_(count)

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );
#define _Out_z_cap_post_count_(cap,count)              _Pre_cap_(cap)         _Pre_invalid_ _Post_z_count_(count)
#define _Out_opt_z_cap_post_count_(cap,count)          _Pre_opt_cap_(cap)     _Pre_invalid_ _Post_z_count_(count)
#define _Out_z_bytecap_post_bytecount_(cap,count)      _Pre_bytecap_(cap)     _Pre_invalid_ _Post_z_bytecount_(count)
#define _Out_opt_z_bytecap_post_bytecount_(cap,count)  _Pre_opt_bytecap_(cap) _Pre_invalid_ _Post_z_bytecount_(count)

// only use with dereferenced arguments e.g. '*pcch' 
#define _Out_capcount_(capcount)            _Pre_cap_(capcount)         _Pre_invalid_ _Post_count_(capcount)
#define _Out_opt_capcount_(capcount)        _Pre_opt_cap_(capcount)     _Pre_invalid_ _Post_count_(capcount)
#define _Out_bytecapcount_(capcount)        _Pre_bytecap_(capcount)     _Pre_invalid_ _Post_bytecount_(capcount)
#define _Out_opt_bytecapcount_(capcount)    _Pre_opt_bytecap_(capcount) _Pre_invalid_ _Post_bytecount_(capcount)

#define _Out_capcount_x_(capcount)          _Pre_cap_x_(capcount)         _Pre_invalid_ _Post_count_x_(capcount)
#define _Out_opt_capcount_x_(capcount)      _Pre_opt_cap_x_(capcount)     _Pre_invalid_ _Post_count_x_(capcount)
#define _Out_bytecapcount_x_(capcount)      _Pre_bytecap_x_(capcount)     _Pre_invalid_ _Post_bytecount_x_(capcount)
#define _Out_opt_bytecapcount_x_(capcount)  _Pre_opt_bytecap_x_(capcount) _Pre_invalid_ _Post_bytecount_x_(capcount)

// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );
#define _Out_z_capcount_(capcount)          _Pre_cap_(capcount)         _Pre_invalid_ _Post_z_count_(capcount)
#define _Out_opt_z_capcount_(capcount)      _Pre_opt_cap_(capcount)     _Pre_invalid_ _Post_z_count_(capcount)
#define _Out_z_bytecapcount_(capcount)      _Pre_bytecap_(capcount)     _Pre_invalid_ _Post_z_bytecount_(capcount)
#define _Out_opt_z_bytecapcount_(capcount)  _Pre_opt_bytecap_(capcount) _Pre_invalid_ _Post_z_bytecount_(capcount)

// inout parameters ----------------------------

// inout pointer parameter
// e.g. void ModifyPoint( _Inout_ POINT* pPT );
#define _Inout_                          _Prepost_valid_
#define _Inout_opt_                      _Prepost_opt_valid_

// string buffers
// e.g. void toupper( _Inout_z_ char* sz );
#define _Inout_z_                        _Prepost_z_
#define _Inout_opt_z_                    _Prepost_opt_z_

// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
#define _Inout_count_(size)              _Prepost_count_(size)
#define _Inout_opt_count_(size)          _Prepost_opt_count_(size)
#define _Inout_bytecount_(size)          _Prepost_bytecount_(size)
#define _Inout_opt_bytecount_(size)      _Prepost_opt_bytecount_(size)

#define _Inout_count_c_(size)            _Prepost_count_c_(size)
#define _Inout_opt_count_c_(size)        _Prepost_opt_count_c_(size)
#define _Inout_bytecount_c_(size)        _Prepost_bytecount_c_(size)
#define _Inout_opt_bytecount_c_(size)    _Prepost_opt_bytecount_c_(size)

// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
#define _Inout_z_count_(size)              _Prepost_z_ _Prepost_count_(size)
#define _Inout_opt_z_count_(size)          _Prepost_z_ _Prepost_opt_count_(size)
#define _Inout_z_bytecount_(size)          _Prepost_z_ _Prepost_bytecount_(size)
#define _Inout_opt_z_bytecount_(size)      _Prepost_z_ _Prepost_opt_bytecount_(size)

#define _Inout_z_count_c_(size)            _Prepost_z_ _Prepost_count_c_(size)
#define _Inout_opt_z_count_c_(size)        _Prepost_z_ _Prepost_opt_count_c_(size)
#define _Inout_z_bytecount_c_(size)        _Prepost_z_ _Prepost_bytecount_c_(size)
#define _Inout_opt_z_bytecount_c_(size)    _Prepost_z_ _Prepost_opt_bytecount_c_(size)

#define _Inout_ptrdiff_count_(size)      _Pre_ptrdiff_count_(size)
#define _Inout_opt_ptrdiff_count_(size)  _Pre_opt_ptrdiff_count_(size)

#define _Inout_count_x_(size)            _Prepost_count_x_(size)
#define _Inout_opt_count_x_(size)        _Prepost_opt_count_x_(size)
#define _Inout_bytecount_x_(size)        _Prepost_bytecount_x_(size)
#define _Inout_opt_bytecount_x_(size)    _Prepost_opt_bytecount_x_(size)

// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );
#define _Inout_cap_(size)                _Pre_valid_cap_(size)           _Post_valid_
#define _Inout_opt_cap_(size)            _Pre_opt_valid_cap_(size)       _Post_valid_
#define _Inout_bytecap_(size)            _Pre_valid_bytecap_(size)       _Post_valid_
#define _Inout_opt_bytecap_(size)        _Pre_opt_valid_bytecap_(size)   _Post_valid_

#define _Inout_cap_c_(size)              _Pre_valid_cap_c_(size)         _Post_valid_
#define _Inout_opt_cap_c_(size)          _Pre_opt_valid_cap_c_(size)     _Post_valid_
#define _Inout_bytecap_c_(size)          _Pre_valid_bytecap_c_(size)     _Post_valid_
#define _Inout_opt_bytecap_c_(size)      _Pre_opt_valid_bytecap_c_(size) _Post_valid_

#define _Inout_cap_x_(size)              _Pre_valid_cap_x_(size)         _Post_valid_
#define _Inout_opt_cap_x_(size)          _Pre_opt_valid_cap_x_(size)     _Post_valid_
#define _Inout_bytecap_x_(size)          _Pre_valid_bytecap_x_(size)     _Post_valid_
#define _Inout_opt_bytecap_x_(size)      _Pre_opt_valid_bytecap_x_(size) _Post_valid_

// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _Inout_z_cap_(size)                 _Pre_z_cap_(size)            _Post_z_
#define _Inout_opt_z_cap_(size)             _Pre_opt_z_cap_(size)        _Post_z_
#define _Inout_z_bytecap_(size)             _Pre_z_bytecap_(size)        _Post_z_
#define _Inout_opt_z_bytecap_(size)         _Pre_opt_z_bytecap_(size)    _Post_z_

#define _Inout_z_cap_c_(size)               _Pre_z_cap_c_(size)          _Post_z_
#define _Inout_opt_z_cap_c_(size)           _Pre_opt_z_cap_c_(size)      _Post_z_
#define _Inout_z_bytecap_c_(size)           _Pre_z_bytecap_c_(size)      _Post_z_
#define _Inout_opt_z_bytecap_c_(size)       _Pre_opt_z_bytecap_c_(size)  _Post_z_

#define _Inout_z_cap_x_(size)               _Pre_z_cap_x_(size)          _Post_z_
#define _Inout_opt_z_cap_x_(size)           _Pre_opt_z_cap_x_(size)      _Post_z_
#define _Inout_z_bytecap_x_(size)           _Pre_z_bytecap_x_(size)      _Post_z_
#define _Inout_opt_z_bytecap_x_(size)       _Pre_opt_z_bytecap_x_(size)  _Post_z_

// return values -------------------------------

// returning pointers to valid objects
#define _Ret_                  _Ret_valid_
#define _Ret_opt_              _Ret_opt_valid_

// More _Ret_ annotations are defined below

// Pointer to pointers -------------------------

// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );
#define _Deref_out_            _Out_ _Deref_pre_invalid_ _Deref_post_valid_
#define _Deref_out_opt_        _Out_ _Deref_pre_invalid_ _Deref_post_opt_valid_
#define _Deref_opt_out_        _Out_opt_ _Deref_pre_invalid_ _Deref_post_valid_
#define _Deref_opt_out_opt_    _Out_opt_ _Deref_pre_invalid_ _Deref_post_opt_valid_

// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );
#define _Deref_out_z_          _Out_ _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_out_opt_z_      _Out_ _Deref_pre_invalid_ _Deref_post_opt_z_
#define _Deref_opt_out_z_      _Out_opt_ _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_opt_out_opt_z_  _Out_opt_ _Deref_pre_invalid_ _Deref_post_opt_z_

// More _Deref_ annotations are defined below

// Other annotations

// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();
#define _Check_return_          _Check_return_impl_

// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );
#define _Printf_format_string_ _Printf_format_string_impl_
#define _Scanf_format_string_  _Scanf_format_string_impl_
#define _Scanf_s_format_string_ _Scanf_s_format_string_impl_

// <expr> indicates whether post conditions apply
#define _Success_(expr)     _Success_impl_(expr)

// annotations to express 'boundedness' of integral value parameter
#define _In_bound_          _In_bound_impl_
#define _Out_bound_         _Out_bound_impl_
#define _Ret_bound_         _Ret_bound_impl_
#define _Deref_in_bound_    _Deref_in_bound_impl_
#define _Deref_out_bound_   _Deref_out_bound_impl_
#define _Deref_inout_bound_ _Deref_in_bound_ _Deref_out_bound_
#define _Deref_ret_bound_   _Deref_ret_bound_impl_

// annotations to express upper and lower bounds of integral value parameter
#define _In_range_(lb,ub)          _In_range_impl_(lb,ub)
#define _Out_range_(lb,ub)         _Out_range_impl_(lb,ub)
#define _Ret_range_(lb,ub)         _Ret_range_impl_(lb,ub)
#define _Deref_in_range_(lb,ub)    _Deref_in_range_impl_(lb,ub)
#define _Deref_out_range_(lb,ub)   _Deref_out_range_impl_(lb,ub)
#define _Deref_ret_range_(lb,ub)   _Deref_ret_range_impl_(lb,ub)

//============================================================================
//   _Pre_\_Post_ Layer:
//============================================================================

//
// _Pre_ annotation ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string
#define _Pre_z_                          _Pre2_impl_(_$notnull,  _$zterm) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_                      _Pre2_impl_(_$maybenull,_$zterm) _Deref_pre1_impl_(_$valid)

// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter
#define _Pre_cap_(size)                  _Pre2_impl_(_$notnull,  _$cap(size))
#define _Pre_opt_cap_(size)              _Pre2_impl_(_$maybenull,_$cap(size))
#define _Pre_bytecap_(size)              _Pre2_impl_(_$notnull,  _$bytecap(size))
#define _Pre_opt_bytecap_(size)          _Pre2_impl_(_$maybenull,_$bytecap(size))

// buffer capacity described by a constant expression
#define _Pre_cap_c_(size)                _Pre2_impl_(_$notnull,  _$cap_c(size))
#define _Pre_opt_cap_c_(size)            _Pre2_impl_(_$maybenull,_$cap_c(size))
#define _Pre_bytecap_c_(size)            _Pre2_impl_(_$notnull,  _$bytecap_c(size))
#define _Pre_opt_bytecap_c_(size)        _Pre2_impl_(_$maybenull,_$bytecap_c(size))

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Pre_cap_m_(mult,size)           _Pre2_impl_(_$notnull,  _$mult(mult,size))
#define _Pre_opt_cap_m_(mult,size)       _Pre2_impl_(_$maybenull,_$mult(mult,size))

// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);
#define _Pre_cap_for_(param)             _Pre2_impl_(_$notnull,  _$cap_for(param))
#define _Pre_opt_cap_for_(param)         _Pre2_impl_(_$maybenull,_$cap_for(param))

// buffer capacity described by a complex condition
#define _Pre_cap_x_(size)                _Pre2_impl_(_$notnull,  _$cap_x(size))
#define _Pre_opt_cap_x_(size)            _Pre2_impl_(_$maybenull,_$cap_x(size))
#define _Pre_bytecap_x_(size)            _Pre2_impl_(_$notnull,  _$bytecap_x(size))
#define _Pre_opt_bytecap_x_(size)        _Pre2_impl_(_$maybenull,_$bytecap_x(size))

// buffer capacity described by the difference to another pointer parameter
#define _Pre_ptrdiff_cap_(ptr)           _Pre2_impl_(_$notnull,  _$cap_x(__ptrdiff(ptr)))
#define _Pre_opt_ptrdiff_cap_(ptr)       _Pre2_impl_(_$maybenull,_$cap_x(__ptrdiff(ptr)))

// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );
#define _Pre_z_cap_(size)                _Pre3_impl_(_$notnull,  _$zterm,_$cap(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_cap_(size)            _Pre3_impl_(_$maybenull,_$zterm,_$cap(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_z_bytecap_(size)            _Pre3_impl_(_$notnull,  _$zterm,_$bytecap(size))   _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_bytecap_(size)        _Pre3_impl_(_$maybenull,_$zterm,_$bytecap(size))   _Deref_pre1_impl_(_$valid)

#define _Pre_z_cap_c_(size)              _Pre3_impl_(_$notnull,  _$zterm,_$cap_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_cap_c_(size)          _Pre3_impl_(_$maybenull,_$zterm,_$cap_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_z_bytecap_c_(size)          _Pre3_impl_(_$notnull,  _$zterm,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_bytecap_c_(size)      _Pre3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid)

#define _Pre_z_cap_x_(size)              _Pre3_impl_(_$notnull,  _$zterm,_$cap_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_cap_x_(size)          _Pre3_impl_(_$maybenull,_$zterm,_$cap_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_z_bytecap_x_(size)          _Pre3_impl_(_$notnull,  _$zterm,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_bytecap_x_(size)      _Pre3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid)

// known capacity and valid but unknown readable extent
#define _Pre_valid_cap_(size)            _Pre2_impl_(_$notnull,  _$cap(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_cap_(size)        _Pre2_impl_(_$maybenull,_$cap(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_valid_bytecap_(size)        _Pre2_impl_(_$notnull,  _$bytecap(size))   _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_bytecap_(size)    _Pre2_impl_(_$maybenull,_$bytecap(size))   _Deref_pre1_impl_(_$valid)

#define _Pre_valid_cap_c_(size)          _Pre2_impl_(_$notnull,  _$cap_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_cap_c_(size)      _Pre2_impl_(_$maybenull,_$cap_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_valid_bytecap_c_(size)      _Pre2_impl_(_$notnull,  _$bytecap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_bytecap_c_(size)  _Pre2_impl_(_$maybenull,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid)

#define _Pre_valid_cap_x_(size)          _Pre2_impl_(_$notnull,  _$cap_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_cap_x_(size)      _Pre2_impl_(_$maybenull,_$cap_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_valid_bytecap_x_(size)      _Pre2_impl_(_$notnull,  _$bytecap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_bytecap_x_(size)  _Pre2_impl_(_$maybenull,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid)

// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter
#define _Pre_count_(size)                _Pre2_impl_(_$notnull,  _$count(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_opt_count_(size)            _Pre2_impl_(_$maybenull,_$count(size))       _Deref_pre1_impl_(_$valid)
#define _Pre_bytecount_(size)            _Pre2_impl_(_$notnull,  _$bytecount(size))   _Deref_pre1_impl_(_$valid)
#define _Pre_opt_bytecount_(size)        _Pre2_impl_(_$maybenull,_$bytecount(size))   _Deref_pre1_impl_(_$valid)

// Valid buffer extent described by a constant expression
#define _Pre_count_c_(size)              _Pre2_impl_(_$notnull,  _$count_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_count_c_(size)          _Pre2_impl_(_$maybenull,_$count_c(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_bytecount_c_(size)          _Pre2_impl_(_$notnull,  _$bytecount_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_bytecount_c_(size)      _Pre2_impl_(_$maybenull,_$bytecount_c(size)) _Deref_pre1_impl_(_$valid)

// Valid buffer extent described by a complex expression
#define _Pre_count_x_(size)              _Pre2_impl_(_$notnull,  _$count_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_opt_count_x_(size)          _Pre2_impl_(_$maybenull,_$count_x(size))     _Deref_pre1_impl_(_$valid)
#define _Pre_bytecount_x_(size)          _Pre2_impl_(_$notnull,  _$bytecount_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_bytecount_x_(size)      _Pre2_impl_(_$maybenull,_$bytecount_x(size)) _Deref_pre1_impl_(_$valid)

// Valid buffer extent described by the difference to another pointer parameter
#define _Pre_ptrdiff_count_(ptr)         _Pre2_impl_(_$notnull,  _$count_x(__ptrdiff(ptr))) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_ptrdiff_count_(ptr)     _Pre2_impl_(_$maybenull,_$count_x(__ptrdiff(ptr))) _Deref_pre1_impl_(_$valid)

// valid size unknown or indicated by type (e.g.:LPSTR)
#define _Pre_valid_                      _Pre1_impl_(_$notnull)   _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_                  _Pre1_impl_(_$maybenull) _Deref_pre1_impl_(_$valid)

#define _Pre_invalid_                    _Deref_pre1_impl_(_$notvalid)

// used with allocated but not yet initialized objects
#define _Pre_notnull_                    _Pre1_impl_(_$notnull)
#define _Pre_maybenull_                  _Pre1_impl_(_$maybenull)
#define _Pre_null_                       _Pre1_impl_(_$null)

// restrict access rights
#define _Pre_readonly_                   _Pre1_impl_(_$readaccess)
#define _Pre_writeonly_                  _Pre1_impl_(_$writeaccess)
//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call
#define _Post_z_                        _Post1_impl_(_$zterm) _Deref_post1_impl_(_$valid)

// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call
#define _Post_maybez_                   _Post1_impl_(_$maybezterm)

// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );
#define _Post_cap_(size)                _Post1_impl_(_$cap(size))
#define _Post_bytecap_(size)            _Post1_impl_(_$bytecap(size))

// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );
#define _Post_count_(size)              _Post1_impl_(_$count(size))       _Deref_post1_impl_(_$valid)
#define _Post_bytecount_(size)          _Post1_impl_(_$bytecount(size))   _Deref_post1_impl_(_$valid)
#define _Post_count_c_(size)            _Post1_impl_(_$count_c(size))     _Deref_post1_impl_(_$valid)
#define _Post_bytecount_c_(size)        _Post1_impl_(_$bytecount_c(size)) _Deref_post1_impl_(_$valid)
#define _Post_count_x_(size)            _Post1_impl_(_$count_x(size))     _Deref_post1_impl_(_$valid)
#define _Post_bytecount_x_(size)        _Post1_impl_(_$bytecount_x(size)) _Deref_post1_impl_(_$valid)

// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );
#define _Post_z_count_(size)            _Post2_impl_(_$zterm,_$count(size))       _Deref_post1_impl_(_$valid)
#define _Post_z_bytecount_(size)        _Post2_impl_(_$zterm,_$bytecount(size))   _Deref_post1_impl_(_$valid)
#define _Post_z_count_c_(size)          _Post2_impl_(_$zterm,_$count_c(size))     _Deref_post1_impl_(_$valid)
#define _Post_z_bytecount_c_(size)      _Post2_impl_(_$zterm,_$bytecount_c(size)) _Deref_post1_impl_(_$valid)
#define _Post_z_count_x_(size)          _Post2_impl_(_$zterm,_$count_x(size))     _Deref_post1_impl_(_$valid)
#define _Post_z_bytecount_x_(size)      _Post2_impl_(_$zterm,_$bytecount_x(size)) _Deref_post1_impl_(_$valid)

// e.g. void free( _Post_invalid_ void* pv );
#define _Post_valid_                    _Deref_post1_impl_(_$valid)
#define _Post_invalid_                  _Deref_post1_impl_(_$notvalid)

// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );
#define _Post_notnull_                  _Post1_impl_(_$notnull)

//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const throw();
#define _Ret_z_                          _Ret2_impl_(_$notnull,  _$zterm) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_                      _Ret2_impl_(_$maybenull,_$zterm) _Deref_ret1_impl_(_$valid)

// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter
#define _Ret_cap_(size)                  _Ret2_impl_(_$notnull,  _$cap(size))
#define _Ret_opt_cap_(size)              _Ret2_impl_(_$maybenull,_$cap(size))
#define _Ret_bytecap_(size)              _Ret2_impl_(_$notnull,  _$bytecap(size))
#define _Ret_opt_bytecap_(size)          _Ret2_impl_(_$maybenull,_$bytecap(size))

// Buffer capacity is described by a constant expression
#define _Ret_cap_c_(size)                _Ret2_impl_(_$notnull,  _$cap_c(size))
#define _Ret_opt_cap_c_(size)            _Ret2_impl_(_$maybenull,_$cap_c(size))
#define _Ret_bytecap_c_(size)            _Ret2_impl_(_$notnull,  _$bytecap_c(size))
#define _Ret_opt_bytecap_c_(size)        _Ret2_impl_(_$maybenull,_$bytecap_c(size))

// Buffer capacity is described by a complex condition
#define _Ret_cap_x_(size)                _Ret2_impl_(_$notnull,  _$cap_x(size))
#define _Ret_opt_cap_x_(size)            _Ret2_impl_(_$maybenull,_$cap_x(size))
#define _Ret_bytecap_x_(size)            _Ret2_impl_(_$notnull,  _$bytecap_x(size))
#define _Ret_opt_bytecap_x_(size)        _Ret2_impl_(_$maybenull,_$bytecap_x(size))

// return value is nullterminated and capacity is given by another parameter
#define _Ret_z_cap_(size)                _Ret3_impl_(_$notnull,  _$zterm,_$cap(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_cap_(size)            _Ret3_impl_(_$maybenull,_$zterm,_$cap(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_z_bytecap_(size)            _Ret3_impl_(_$notnull,  _$zterm,_$bytecap(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_bytecap_(size)        _Ret3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref_ret1_impl_(_$valid)

// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter
#define _Ret_count_(size)                _Ret2_impl_(_$notnull,  _$count(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_count_(size)            _Ret2_impl_(_$maybenull,_$count(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_bytecount_(size)            _Ret2_impl_(_$notnull,  _$bytecount(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_bytecount_(size)        _Ret2_impl_(_$maybenull,_$bytecount(size)) _Deref_ret1_impl_(_$valid)

// Valid Buffer extent is described by a constant expression
#define _Ret_count_c_(size)              _Ret2_impl_(_$notnull,  _$count_c(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_count_c_(size)          _Ret2_impl_(_$maybenull,_$count_c(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_bytecount_c_(size)          _Ret2_impl_(_$notnull,  _$bytecount_c(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_bytecount_c_(size)      _Ret2_impl_(_$maybenull,_$bytecount_c(size)) _Deref_ret1_impl_(_$valid)

// Valid Buffer extent is described by a complex expression
#define _Ret_count_x_(size)              _Ret2_impl_(_$notnull,  _$count_x(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_count_x_(size)          _Ret2_impl_(_$maybenull,_$count_x(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_bytecount_x_(size)          _Ret2_impl_(_$notnull,  _$bytecount_x(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_bytecount_x_(size)      _Ret2_impl_(_$maybenull,_$bytecount_x(size)) _Deref_ret1_impl_(_$valid)

// return value is nullterminated and length is given by another parameter
#define _Ret_z_count_(size)              _Ret3_impl_(_$notnull,  _$zterm,_$count(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_count_(size)          _Ret3_impl_(_$maybenull,_$zterm,_$count(size))     _Deref_ret1_impl_(_$valid)
#define _Ret_z_bytecount_(size)          _Ret3_impl_(_$notnull,  _$zterm,_$bytecount(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_bytecount_(size)      _Ret3_impl_(_$maybenull,_$zterm,_$bytecount(size)) _Deref_ret1_impl_(_$valid)

// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );
#define _Ret_valid_                      _Ret1_impl_(_$notnull)   _Deref_ret1_impl_(_$valid)
#define _Ret_opt_valid_                  _Ret1_impl_(_$maybenull) _Deref_ret1_impl_(_$valid)

// used with allocated but not yet initialized objects
#define _Ret_notnull_                    _Ret1_impl_(_$notnull)
#define _Ret_maybenull_                  _Ret1_impl_(_$maybenull)
#define _Ret_null_                       _Ret1_impl_(_$null)

//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );
#define _Deref_pre_z_                          _Deref_pre2_impl_(_$notnull,  _$zterm) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_                      _Deref_pre2_impl_(_$maybenull,_$zterm) _Deref2_pre1_impl_(_$valid)

// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter
#define _Deref_pre_cap_(size)                  _Deref_pre2_impl_(_$notnull,  _$cap(size))
#define _Deref_pre_opt_cap_(size)              _Deref_pre2_impl_(_$maybenull,_$cap(size))
#define _Deref_pre_bytecap_(size)              _Deref_pre2_impl_(_$notnull,  _$bytecap(size))
#define _Deref_pre_opt_bytecap_(size)          _Deref_pre2_impl_(_$maybenull,_$bytecap(size))

// buffer capacity is described by a constant expression
#define _Deref_pre_cap_c_(size)                _Deref_pre2_impl_(_$notnull,  _$cap_c(size))
#define _Deref_pre_opt_cap_c_(size)            _Deref_pre2_impl_(_$maybenull,_$cap_c(size))
#define _Deref_pre_bytecap_c_(size)            _Deref_pre2_impl_(_$notnull,  _$bytecap_c(size))
#define _Deref_pre_opt_bytecap_c_(size)        _Deref_pre2_impl_(_$maybenull,_$bytecap_c(size))

// buffer capacity is described by a complex condition
#define _Deref_pre_cap_x_(size)                _Deref_pre2_impl_(_$notnull,  _$cap_x(size))
#define _Deref_pre_opt_cap_x_(size)            _Deref_pre2_impl_(_$maybenull,_$cap_x(size))
#define _Deref_pre_bytecap_x_(size)            _Deref_pre2_impl_(_$notnull,  _$bytecap_x(size))
#define _Deref_pre_opt_bytecap_x_(size)        _Deref_pre2_impl_(_$maybenull,_$bytecap_x(size))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_pre_z_cap_(size)                _Deref_pre3_impl_(_$notnull,  _$zterm,_$cap(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_cap_(size)            _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_z_bytecap_(size)            _Deref_pre3_impl_(_$notnull,  _$zterm,_$bytecap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_bytecap_(size)        _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_z_cap_c_(size)              _Deref_pre3_impl_(_$notnull,  _$zterm,_$cap_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_cap_c_(size)          _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_z_bytecap_c_(size)          _Deref_pre3_impl_(_$notnull,  _$zterm,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_bytecap_c_(size)      _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_z_cap_x_(size)              _Deref_pre3_impl_(_$notnull,  _$zterm,_$cap_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_cap_x_(size)          _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_z_bytecap_x_(size)          _Deref_pre3_impl_(_$notnull,  _$zterm,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_bytecap_x_(size)      _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)

// known capacity and valid but unknown readable extent
#define _Deref_pre_valid_cap_(size)            _Deref_pre2_impl_(_$notnull,  _$cap(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_cap_(size)        _Deref_pre2_impl_(_$maybenull,_$cap(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_valid_bytecap_(size)        _Deref_pre2_impl_(_$notnull,  _$bytecap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_bytecap_(size)    _Deref_pre2_impl_(_$maybenull,_$bytecap(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_valid_cap_c_(size)          _Deref_pre2_impl_(_$notnull,  _$cap_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_cap_c_(size)      _Deref_pre2_impl_(_$maybenull,_$cap_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_valid_bytecap_c_(size)      _Deref_pre2_impl_(_$notnull,  _$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_bytecap_c_(size)  _Deref_pre2_impl_(_$maybenull,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_valid_cap_x_(size)          _Deref_pre2_impl_(_$notnull,  _$cap_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_cap_x_(size)      _Deref_pre2_impl_(_$maybenull,_$cap_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_valid_bytecap_x_(size)      _Deref_pre2_impl_(_$notnull,  _$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_bytecap_x_(size)  _Deref_pre2_impl_(_$maybenull,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)

// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n ); 
// valid buffer extent is described by another parameter
#define _Deref_pre_count_(size)                _Deref_pre2_impl_(_$notnull,  _$count(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_count_(size)            _Deref_pre2_impl_(_$maybenull,_$count(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_bytecount_(size)            _Deref_pre2_impl_(_$notnull,  _$bytecount(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_bytecount_(size)        _Deref_pre2_impl_(_$maybenull,_$bytecount(size)) _Deref2_pre1_impl_(_$valid)

// valid buffer extent is described by a constant expression
#define _Deref_pre_count_c_(size)              _Deref_pre2_impl_(_$notnull,  _$count_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_count_c_(size)          _Deref_pre2_impl_(_$maybenull,_$count_c(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_bytecount_c_(size)          _Deref_pre2_impl_(_$notnull,  _$bytecount_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_bytecount_c_(size)      _Deref_pre2_impl_(_$maybenull,_$bytecount_c(size)) _Deref2_pre1_impl_(_$valid)

// valid buffer extent is described by a complex expression
#define _Deref_pre_count_x_(size)              _Deref_pre2_impl_(_$notnull,  _$count_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_count_x_(size)          _Deref_pre2_impl_(_$maybenull,_$count_x(size))     _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_bytecount_x_(size)          _Deref_pre2_impl_(_$notnull,  _$bytecount_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_bytecount_x_(size)      _Deref_pre2_impl_(_$maybenull,_$bytecount_x(size)) _Deref2_pre1_impl_(_$valid)

// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );
#define _Deref_pre_valid_                      _Deref_pre1_impl_(_$notnull)   _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_                  _Deref_pre1_impl_(_$maybenull) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_invalid_                    _Deref2_pre1_impl_(_$notvalid)

#define _Deref_pre_notnull_                    _Deref_pre1_impl_(_$notnull)
#define _Deref_pre_maybenull_                  _Deref_pre1_impl_(_$maybenull)
#define _Deref_pre_null_                       _Deref_pre1_impl_(_$null)

// restrict access rights
#define _Deref_pre_readonly_                   _Deref_pre1_impl_(_$readaccess)
#define _Deref_pre_writeonly_                  _Deref_pre1_impl_(_$writeaccess)

//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );
#define _Deref_post_z_                          _Deref_post2_impl_(_$notnull,  _$zterm) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_                      _Deref_post2_impl_(_$maybenull,_$zterm) _Deref2_post1_impl_(_$valid)

// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter
#define _Deref_post_cap_(size)                  _Deref_post2_impl_(_$notnull,  _$cap(size))
#define _Deref_post_opt_cap_(size)              _Deref_post2_impl_(_$maybenull,_$cap(size))
#define _Deref_post_bytecap_(size)              _Deref_post2_impl_(_$notnull,  _$bytecap(size))
#define _Deref_post_opt_bytecap_(size)          _Deref_post2_impl_(_$maybenull,_$bytecap(size))

// buffer capacity is described by a constant expression
#define _Deref_post_cap_c_(size)                _Deref_post2_impl_(_$notnull,  _$cap_z(size))
#define _Deref_post_opt_cap_c_(size)            _Deref_post2_impl_(_$maybenull,_$cap_z(size))
#define _Deref_post_bytecap_c_(size)            _Deref_post2_impl_(_$notnull,  _$bytecap_z(size))
#define _Deref_post_opt_bytecap_c_(size)        _Deref_post2_impl_(_$maybenull,_$bytecap_z(size))

// buffer capacity is described by a complex expression
#define _Deref_post_cap_x_(size)                _Deref_post2_impl_(_$notnull,  _$cap_x(size))
#define _Deref_post_opt_cap_x_(size)            _Deref_post2_impl_(_$maybenull,_$cap_x(size))
#define _Deref_post_bytecap_x_(size)            _Deref_post2_impl_(_$notnull,  _$bytecap_x(size))
#define _Deref_post_opt_bytecap_x_(size)        _Deref_post2_impl_(_$maybenull,_$bytecap_x(size))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_post_z_cap_(size)                _Deref_post3_impl_(_$notnull,  _$zterm,_$cap(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_cap_(size)            _Deref_post3_impl_(_$maybenull,_$zterm,_$cap(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_z_bytecap_(size)            _Deref_post3_impl_(_$notnull,  _$zterm,_$bytecap(size))   _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_bytecap_(size)        _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap(size))   _Deref2_post1_impl_(_$valid)

#define _Deref_post_z_cap_c_(size)              _Deref_post3_impl_(_$notnull,  _$zterm,_$cap_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_cap_c_(size)          _Deref_post3_impl_(_$maybenull,_$zterm,_$cap_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_z_bytecap_c_(size)          _Deref_post3_impl_(_$notnull,  _$zterm,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_bytecap_c_(size)      _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid)

#define _Deref_post_z_cap_x_(size)              _Deref_post3_impl_(_$notnull,  _$zterm,_$cap_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_cap_x_(size)          _Deref_post3_impl_(_$maybenull,_$zterm,_$cap_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_z_bytecap_x_(size)          _Deref_post3_impl_(_$notnull,  _$zterm,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_bytecap_x_(size)      _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid)

// known capacity and valid but unknown readable extent
#define _Deref_post_valid_cap_(size)            _Deref_post2_impl_(_$notnull,  _$cap(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_cap_(size)        _Deref_post2_impl_(_$maybenull,_$cap(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_valid_bytecap_(size)        _Deref_post2_impl_(_$notnull,  _$bytecap(size))   _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_bytecap_(size)    _Deref_post2_impl_(_$maybenull,_$bytecap(size))   _Deref2_post1_impl_(_$valid)
                                                
#define _Deref_post_valid_cap_c_(size)          _Deref_post2_impl_(_$notnull,  _$cap_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_cap_c_(size)      _Deref_post2_impl_(_$maybenull,_$cap_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_valid_bytecap_c_(size)      _Deref_post2_impl_(_$notnull,  _$bytecap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_bytecap_c_(size)  _Deref_post2_impl_(_$maybenull,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid)
                                                
#define _Deref_post_valid_cap_x_(size)          _Deref_post2_impl_(_$notnull,  _$cap_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_cap_x_(size)      _Deref_post2_impl_(_$maybenull,_$cap_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_valid_bytecap_x_(size)      _Deref_post2_impl_(_$notnull,  _$bytecap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_bytecap_x_(size)  _Deref_post2_impl_(_$maybenull,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid)

// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter
#define _Deref_post_count_(size)                _Deref_post2_impl_(_$notnull,  _$count(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_count_(size)            _Deref_post2_impl_(_$maybenull,_$count(size))       _Deref2_post1_impl_(_$valid)
#define _Deref_post_bytecount_(size)            _Deref_post2_impl_(_$notnull,  _$bytecount(size))   _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_bytecount_(size)        _Deref_post2_impl_(_$maybenull,_$bytecount(size))   _Deref2_post1_impl_(_$valid)

// buffer capacity is described by a constant expression
#define _Deref_post_count_c_(size)              _Deref_post2_impl_(_$notnull,  _$count_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_count_c_(size)          _Deref_post2_impl_(_$maybenull,_$count_c(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_bytecount_c_(size)          _Deref_post2_impl_(_$notnull,  _$bytecount_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_bytecount_c_(size)      _Deref_post2_impl_(_$maybenull,_$bytecount_c(size)) _Deref2_post1_impl_(_$valid)

// buffer capacity is described by a complex expression
#define _Deref_post_count_x_(size)              _Deref_post2_impl_(_$notnull,  _$count_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_count_x_(size)          _Deref_post2_impl_(_$maybenull,_$count_x(size))     _Deref2_post1_impl_(_$valid)
#define _Deref_post_bytecount_x_(size)          _Deref_post2_impl_(_$notnull,  _$bytecount_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_bytecount_x_(size)      _Deref_post2_impl_(_$maybenull,_$bytecount_x(size)) _Deref2_post1_impl_(_$valid)

// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );
#define _Deref_post_valid_                      _Deref_post1_impl_(_$notnull)   _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_                  _Deref_post1_impl_(_$maybenull) _Deref2_post1_impl_(_$valid)

#define _Deref_post_notnull_                    _Deref_post1_impl_(_$notnull)
#define _Deref_post_maybenull_                  _Deref_post1_impl_(_$maybenull)
#define _Deref_post_null_                       _Deref_post1_impl_(_$null)

//
// _Deref_ret_ ---
//

#define _Deref_ret_z_                           _Deref_ret2_impl_(_$notnull,  _$zterm)
#define _Deref_ret_opt_z_                       _Deref_ret2_impl_(_$maybenull,_$zterm)

//
// special _Deref_ ---
//
#define _Deref2_pre_readonly_                   _Deref2_pre1_impl_(_$readaccess)

// Convenience macros for more concise annotations

//
// _Pre_post ---
//
// describing conditions that hold before and after the function call

#define _Prepost_z_                      _Pre_z_      _Post_z_
#define _Prepost_opt_z_                  _Pre_opt_z_  _Post_z_

#define _Prepost_count_(size)           _Pre_count_(size)           _Post_count_(size)
#define _Prepost_opt_count_(size)       _Pre_opt_count_(size)       _Post_count_(size)
#define _Prepost_bytecount_(size)       _Pre_bytecount_(size)       _Post_bytecount_(size)
#define _Prepost_opt_bytecount_(size)   _Pre_opt_bytecount_(size)   _Post_bytecount_(size)
#define _Prepost_count_c_(size)         _Pre_count_c_(size)         _Post_count_c_(size)
#define _Prepost_opt_count_c_(size)     _Pre_opt_count_c_(size)     _Post_count_c_(size)
#define _Prepost_bytecount_c_(size)     _Pre_bytecount_c_(size)     _Post_bytecount_c_(size)
#define _Prepost_opt_bytecount_c_(size) _Pre_opt_bytecount_c_(size) _Post_bytecount_c_(size)
#define _Prepost_count_x_(size)         _Pre_count_x_(size)         _Post_count_x_(size)
#define _Prepost_opt_count_x_(size)     _Pre_opt_count_x_(size)     _Post_count_x_(size)
#define _Prepost_bytecount_x_(size)     _Pre_bytecount_x_(size)     _Post_bytecount_x_(size)
#define _Prepost_opt_bytecount_x_(size) _Pre_opt_bytecount_x_(size) _Post_bytecount_x_(size)

#define _Prepost_valid_                  _Pre_valid_     _Post_valid_
#define _Prepost_opt_valid_              _Pre_opt_valid_ _Post_valid_

//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call

#define _Deref_prepost_z_                        _Deref_pre_z_      _Deref_post_z_
#define _Deref_prepost_opt_z_                    _Deref_pre_opt_z_  _Deref_post_opt_z_

#define _Deref_prepost_cap_(size)                _Deref_pre_cap_(size)                _Deref_post_cap_(size)
#define _Deref_prepost_opt_cap_(size)            _Deref_pre_opt_cap_(size)            _Deref_post_opt_cap_(size)
#define _Deref_prepost_bytecap_(size)            _Deref_pre_bytecap_(size)            _Deref_post_bytecap_(size)
#define _Deref_prepost_opt_bytecap_(size)        _Deref_pre_opt_bytecap_(size)        _Deref_post_opt_bytecap_(size)

#define _Deref_prepost_cap_x_(size)              _Deref_pre_cap_x_(size)              _Deref_post_cap_x_(size)             
#define _Deref_prepost_opt_cap_x_(size)          _Deref_pre_opt_cap_x_(size)          _Deref_post_opt_cap_x_(size)         
#define _Deref_prepost_bytecap_x_(size)          _Deref_pre_bytecap_x_(size)          _Deref_post_bytecap_x_(size)             
#define _Deref_prepost_opt_bytecap_x_(size)      _Deref_pre_opt_bytecap_x_(size)      _Deref_post_opt_bytecap_x_(size)         

#define _Deref_prepost_z_cap_(size)              _Deref_pre_z_cap_(size)              _Deref_post_z_cap_(size)             
#define _Deref_prepost_opt_z_cap_(size)          _Deref_pre_opt_z_cap_(size)          _Deref_post_opt_z_cap_(size)         
#define _Deref_prepost_z_bytecap_(size)          _Deref_pre_z_bytecap_(size)          _Deref_post_z_bytecap_(size)         
#define _Deref_prepost_opt_z_bytecap_(size)      _Deref_pre_opt_z_bytecap_(size)      _Deref_post_opt_z_bytecap_(size)     

#define _Deref_prepost_valid_cap_(size)          _Deref_pre_valid_cap_(size)          _Deref_post_valid_cap_(size)             
#define _Deref_prepost_opt_valid_cap_(size)      _Deref_pre_opt_valid_cap_(size)      _Deref_post_opt_valid_cap_(size)         
#define _Deref_prepost_valid_bytecap_(size)      _Deref_pre_valid_bytecap_(size)      _Deref_post_valid_bytecap_(size)         
#define _Deref_prepost_opt_valid_bytecap_(size)  _Deref_pre_opt_valid_bytecap_(size)  _Deref_post_opt_valid_bytecap_(size)     

#define _Deref_prepost_valid_cap_x_(size)          _Deref_pre_valid_cap_x_(size)          _Deref_post_valid_cap_x_(size)             
#define _Deref_prepost_opt_valid_cap_x_(size)      _Deref_pre_opt_valid_cap_x_(size)      _Deref_post_opt_valid_cap_x_(size)         
#define _Deref_prepost_valid_bytecap_x_(size)      _Deref_pre_valid_bytecap_x_(size)      _Deref_post_valid_bytecap_x_(size)         
#define _Deref_prepost_opt_valid_bytecap_x_(size)  _Deref_pre_opt_valid_bytecap_x_(size)  _Deref_post_opt_valid_bytecap_x_(size)     

#define _Deref_prepost_count_(size)            _Deref_pre_count_(size)            _Deref_post_count_(size)
#define _Deref_prepost_opt_count_(size)        _Deref_pre_opt_count_(size)        _Deref_post_opt_count_(size)
#define _Deref_prepost_bytecount_(size)        _Deref_pre_bytecount_(size)        _Deref_post_bytecount_(size)
#define _Deref_prepost_opt_bytecount_(size)    _Deref_pre_opt_bytecount_(size)    _Deref_post_opt_bytecount_(size)

#define _Deref_prepost_count_x_(size)          _Deref_pre_count_x_(size)          _Deref_post_count_x_(size)
#define _Deref_prepost_opt_count_x_(size)      _Deref_pre_opt_count_x_(size)      _Deref_post_opt_count_x_(size)
#define _Deref_prepost_bytecount_x_(size)      _Deref_pre_bytecount_x_(size)      _Deref_post_bytecount_x_(size)
#define _Deref_prepost_opt_bytecount_x_(size)  _Deref_pre_opt_bytecount_x_(size)  _Deref_post_opt_bytecount_x_(size)

#define _Deref_prepost_valid_                   _Deref_pre_valid_     _Deref_post_valid_
#define _Deref_prepost_opt_valid_               _Deref_pre_opt_valid_ _Deref_post_opt_valid_

//
// _Deref_<miscellaneous>
//
// used with references to arrays

#define _Deref_out_z_cap_c_(size) _Deref_pre_cap_c_(size) _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_inout_z_cap_c_(size) _Deref_pre_z_cap_c_(size) _Deref_post_z_
#define _Deref_out_z_bytecap_c_(size) _Deref_pre_bytecap_c_(size) _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_inout_z_bytecap_c_(size) _Deref_pre_z_bytecap_c_(size) _Deref_post_z_
#define _Deref_inout_z_ _Deref_prepost_z_

//============================================================================
//   Implementation Layer:
//============================================================================

#if _USE_ATTRIBUTES_FOR_SAL

#include "codeanalysis\sourceannotations.h"

#define _Check_return_impl_ [returnvalue:SA_Post(MustCheck=SA_Yes)]

#define _Success_impl_(expr) [SA_Success(Condition=#expr)]

#define _Printf_format_string_impl_   [SA_FormatString(Style="printf")]
#define _Scanf_format_string_impl_    [SA_FormatString(Style="scanf")]
#define _Scanf_s_format_string_impl_  [SA_FormatString(Style="scanf_s")]

#define _In_bound_impl_           [SA_PreBound(Deref=0)]
#define _Out_bound_impl_          [SA_PostBound(Deref=0)]
#define _Ret_bound_impl_          [returnvalue:SA_PostBound(Deref=0)]
#define _Deref_in_bound_impl_     [SA_PreBound(Deref=1)]
#define _Deref_out_bound_impl_    [SA_PostBound(Deref=1)]
#define _Deref_ret_bound_impl_    [returnvalue:SA_PostBound(Deref=1)]

#define _In_range_impl_(min,max)        [SA_PreRange(MinVal=#min,MaxVal=#max)]
#define _Out_range_impl_(min,max)       [SA_PostRange(MinVal=#min,MaxVal=#max)]
#define _Ret_range_impl_(min,max)       [returnvalue:SA_PostRange(MinVal=#min,MaxVal=#max)]
#define _Deref_in_range_impl_(min,max)  [SA_PreRange(Deref=1,MinVal=#min,MaxVal=#max)]
#define _Deref_out_range_impl_(min,max) [SA_PostRange(Deref=1,MinVal=#min,MaxVal=#max)]
#define _Deref_ret_range_impl_(min,max) [returnvalue:SA_PostRange(Deref=1,MinVal=#min,MaxVal=#max)]

#define _$valid       Valid=SA_Yes
#define _$maybevalid  Valid=SA_Maybe
#define _$notvalid    Valid=SA_No

#define _$null        Null=SA_Yes
#define _$maybenull   Null=SA_Maybe
#define _$notnull     Null=SA_No

#define _$zterm       NullTerminated=SA_Yes
#define _$maybezterm  NullTerminated=SA_Maybe
#define _$notzterm    NullTerminated=SA_No

#define _$readaccess  Access=SA_Read
#define _$writeaccess Access=SA_Write

#define _$cap(size)      WritableElements=#size
#define _$cap_c(size)    WritableElementsConst=size
#define _$cap_for(param) WritableElementsLength=#param
#define _$cap_x(size)    WritableElements="\n@"#size

#define _$bytecap(size)   WritableBytes=#size
#define _$bytecap_c(size) WritableBytesConst=size
#define _$bytecap_x(size) WritableBytes="\n@"#size

#define _$mult(mult,size) ElementSizeConst=mult,_$cap(size)

#define _$count(size)   ValidElements=#size
#define _$count_c(size) ValidElementsConst=size
#define _$count_x(size) ValidElements="\n@"#size

#define _$bytecount(size)   ValidBytes=#size
#define _$bytecount_c(size) ValidBytesConst=size
#define _$bytecount_x(size) ValidBytes="\n@"#size

#define _Pre1_impl_(p1)                    [SA_Pre(p1)]
#define _Pre2_impl_(p1,p2)                 [SA_Pre(p1,p2)]
#define _Pre3_impl_(p1,p2,p3)              [SA_Pre(p1,p2,p3)]

#define _Post1_impl_(p1)                   [SA_Post(p1)]
#define _Post2_impl_(p1,p2)                [SA_Post(p1,p2)]
#define _Post3_impl_(p1,p2,p3)             [SA_Post(p1,p2,p3)]

#define _Ret1_impl_(p1)                    [returnvalue:SA_Post(p1)]
#define _Ret2_impl_(p1,p2)                 [returnvalue:SA_Post(p1,p2)]
#define _Ret3_impl_(p1,p2,p3)              [returnvalue:SA_Post(p1,p2,p3)]

#define _Deref_pre1_impl_(p1)              [SA_Pre(Deref=1,p1)]
#define _Deref_pre2_impl_(p1,p2)           [SA_Pre(Deref=1,p1,p2)]
#define _Deref_pre3_impl_(p1,p2,p3)        [SA_Pre(Deref=1,p1,p2,p3)]

#define _Deref_post1_impl_(p1)             [SA_Post(Deref=1,p1)]
#define _Deref_post2_impl_(p1,p2)          [SA_Post(Deref=1,p1,p2)]
#define _Deref_post3_impl_(p1,p2,p3)       [SA_Post(Deref=1,p1,p2,p3)]

#define _Deref_ret1_impl_(p1)              [returnvalue:SA_Post(Deref=1,p1)]
#define _Deref_ret2_impl_(p1,p2)           [returnvalue:SA_Post(Deref=1,p1,p2)]
#define _Deref_ret3_impl_(p1,p2,p3)        [returnvalue:SA_Post(Deref=1,p1,p2,p3)]

#define _Deref2_pre1_impl_(p1)             [SA_Pre(Deref=2,p1)]
#define _Deref2_post1_impl_(p1)            [SA_Post(Deref=2,p1)]
#define _Deref2_ret1_impl_(p1)             [returnvalue:SA_Post(Deref=2,p1)]

#elif _USE_DECLSPECS_FOR_SAL

#define _$SPECSTRIZE( x ) #x

#define _Check_return_impl_ __declspec("SAL_checkReturn")

#define _Success_impl_(expr) __declspec("SAL_success("_$SPECSTRIZE(expr)")")

#define _Printf_format_string_impl_
#define _Scanf_format_string_impl_
#define _Scanf_s_format_string_impl_

#define _In_bound_impl_           _$pre _$bound
#define _Out_bound_impl_          _$post _$bound
#define _Ret_bound_impl_          _$post _$bound
#define _Deref_in_bound_impl_     _$derefpre _$bound
#define _Deref_out_bound_impl_    _$derefpost _$bound
#define _Deref_ret_bound_impl_    _$derefpost bound

#define _In_range_impl_(min,max)        _$pre _$range(min,max)
#define _Out_range_impl_(min,max)       _$post _$range(min,max)
#define _Ret_range_impl_(min,max)       _$post _$range(min,max)
#define _Deref_in_range_impl_(min,max)  _$derefpre _$range(min,max)
#define _Deref_out_range_impl_(min,max) _$derefpost _$range(min,max)
#define _Deref_ret_range_impl_(min,max) _$derefpost _$range(min,max)

#define _$valid             __declspec("SAL_valid")
#define _$maybevalid        __declspec("SAL_maybevalid")
#define _$notvalid          __declspec("SAL_notvalid")

#define _$null              __declspec("SAL_null")
#define _$maybenull         __declspec("SAL_maybenull")
#define _$notnull           __declspec("SAL_notnull")

#define _$zterm             __declspec("SAL_readableTo(sentinel(0))")
#define _$maybezterm
#define _$notzterm

#define _$readaccess        __declspec("SAL_readonly")
#define _$writeaccess       __declspec("SAL_notreadonly")

#define _$cap(size)         __declspec("SAL_writableTo(elementCount("_$SPECSTRIZE(size)"))")
#define _$cap_c(size)       __declspec("SAL_writableTo(elementCount("_$SPECSTRIZE(size)"))")
#define _$cap_for(param)    __declspec("SAL_writableTo(needsCountFor("_$SPECSTRIZE(param)"))")
#define _$cap_x(size)       __declspec("SAL_writableTo(inexpressibleCount('"_$SPECSTRIZE(size)"'))")

#define _$bytecap(size)     __declspec("SAL_writableTo(byteCount("_$SPECSTRIZE(size)"))")
#define _$bytecap_c(size)   __declspec("SAL_writableTo(byteCount("_$SPECSTRIZE(size)"))")
#define _$bytecap_x(size)   __declspec("SAL_writableTo(inexpressibleCount('"_$SPECSTRIZE(size)"'))")

#define _$mult(mult,size)   __declspec("SAL_writableTo(inexpressibleCount("_$SPECSTRIZE(mult)"*"_$SPECSTRIZE(size)"))")

#define _$count(size)       __declspec("SAL_readableTo(elementCount("_$SPECSTRIZE(size)"))")
#define _$count_c(size)     __declspec("SAL_readableTo(elementCount("_$SPECSTRIZE(size)"))")
#define _$count_x(size)     __declspec("SAL_readableTo(inexpressibleCount('"_$SPECSTRIZE(size)"'))")

#define _$bytecount(size)   __declspec("SAL_readableTo(byteCount("_$SPECSTRIZE(size)"))")
#define _$bytecount_c(size) __declspec("SAL_readableTo(byteCount("_$SPECSTRIZE(size)"))")
#define _$bytecount_x(size) __declspec("SAL_readableTo(inexpressibleCount('"_$SPECSTRIZE(size)"'))")

#define _$pre        __declspec("SAL_pre")
#define _$post       __declspec("SAL_post")
#define _$deref_pre  __declspec("SAL_pre")  __declspec("SAL_deref")
#define _$deref_post __declspec("SAL_post") __declspec("SAL_deref")

#define _$bound          __declspec("SAL_bound")
#define _$range(min,max) __declspec("SAL_range("_$SPECSTRIZE(min)","_$SPECSTRIZE(max)")")

#define _Pre1_impl_(p1)                    _$pre p1
#define _Pre2_impl_(p1,p2)                 _$pre p1 _$pre p2
#define _Pre3_impl_(p1,p2,p3)              _$pre p1 _$pre p2 _$pre p3

#define _Post1_impl_(p1)                   _$post p1
#define _Post2_impl_(p1,p2)                _$post p1 _$post p2
#define _Post3_impl_(p1,p2,p3)             _$post p1 _$post p2 _$post p3

#define _Ret1_impl_(p1)                    _$post p1
#define _Ret2_impl_(p1,p2)                 _$post p1 _$post p2
#define _Ret3_impl_(p1,p2,p3)              _$post p1 _$post p2 _$post p3

#define _Deref_pre1_impl_(p1)              _$deref_pre p1
#define _Deref_pre2_impl_(p1,p2)           _$deref_pre p1 _$deref_pre p2
#define _Deref_pre3_impl_(p1,p2,p3)        _$deref_pre p1 _$deref_pre p2 _$deref_pre p3

#define _Deref_post1_impl_(p1)             _$deref_post p1
#define _Deref_post2_impl_(p1,p2)          _$deref_post p1 _$deref_post p2
#define _Deref_post3_impl_(p1,p2,p3)       _$deref_post p1 _$deref_post p2 _$deref_post p3

#define _Deref_ret1_impl_(p1)              _$deref_post p1
#define _Deref_ret2_impl_(p1,p2)           _$deref_post p1 _$deref_post p2
#define _Deref_ret3_impl_(p1,p2,p3)        _$deref_post p1 _$deref_post p2 _$deref_post p3

#define _Deref2_pre1_impl_(p1)             _$deref_pre __declspec("SAL_deref") p1
#define _Deref2_post1_impl_(p1)            _$deref_post __declspec("SAL_deref") p1
#define _Deref2_ret1_impl_(p1)             _$deref_post __declspec("SAL_deref") p1

#elif defined(_MSC_EXTENSIONS) && !defined( MIDL_PASS ) && !defined(__midl) && !defined(RC_INVOKED) && defined(_PFT_VER) && _MSC_VER >= 1400

// minimum attribute expansion for foreground build

#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#ifdef __cplusplus
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  // !__cplusplus
#define SA( id ) SA_##id
#define REPEATABLE
#endif  // !__cplusplus

REPEATABLE
[source_annotation_attribute( SA( Parameter ) )]
struct _$P
{
#ifdef __cplusplus
   _$P();
#endif
   int _$d;
};
typedef struct _$P _$P;

REPEATABLE
[source_annotation_attribute( SA( ReturnValue ) )]
struct _$R
{
#ifdef __cplusplus
   _$R();
#endif
   int _$d;
};
typedef struct _$R _$R;

[source_annotation_attribute( SA( Method ) )]
struct _$M
{
#ifdef __cplusplus
   _$M();
#endif
   int _$d;
};
typedef struct _$M _$M;

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )

#define _Check_return_impl_ [returnvalue:_$R(_$d=0)]

#define _Success_impl_(expr) [_$M(_$d=0)]

#define _Printf_format_string_impl_   [_$P(_$d=0)]
#define _Scanf_format_string_impl_    [_$P(_$d=0)]
#define _Scanf_s_format_string_impl_  [_$P(_$d=0)]

#define _In_bound_impl_           [_$P(_$d=0)]
#define _Out_bound_impl_          [_$P(_$d=0)]
#define _Ret_bound_impl_          [returnvalue:_$R(_$d=0)]
#define _Deref_in_bound_impl_     [_$P(_$d=0)]
#define _Deref_out_bound_impl_    [_$P(_$d=0)]
#define _Deref_ret_bound_impl_    [returnvalue:_$R(_$d=0)]

#define _In_range_impl_(min,max)        [_$P(_$d=0)]
#define _Out_range_impl_(min,max)       [_$P(_$d=0)]
#define _Ret_range_impl_(min,max)       [returnvalue:_$R(_$d=0)]
#define _Deref_in_range_impl_(min,max)  [_$P(_$d=0)]
#define _Deref_out_range_impl_(min,max) [_$P(_$d=0)]
#define _Deref_ret_range_impl_(min,max) [returnvalue:_$R(_$d=0)]

#define _Pre1_impl_(p1)          [_$P(_$d=0)]
#define _Pre2_impl_(p1,p2)       [_$P(_$d=0)]
#define _Pre3_impl_(p1,p2,p3)    [_$P(_$d=0)]

#define _Post1_impl_(p1)         [_$P(_$d=0)]
#define _Post2_impl_(p1,p2)      [_$P(_$d=0)]
#define _Post3_impl_(p1,p2,p3)   [_$P(_$d=0)]

#define _Ret1_impl_(p1)          [returnvalue:_$R(_$d=0)]
#define _Ret2_impl_(p1,p2)       [returnvalue:_$R(_$d=0)]
#define _Ret3_impl_(p1,p2,p3)    [returnvalue:_$R(_$d=0)]

#define _Deref_pre1_impl_(p1)        [_$P(_$d=0)]
#define _Deref_pre2_impl_(p1,p2)     [_$P(_$d=0)]
#define _Deref_pre3_impl_(p1,p2,p3)  [_$P(_$d=0)]

#define _Deref_post1_impl_(p1)       [_$P(_$d=0)]
#define _Deref_post2_impl_(p1,p2)    [_$P(_$d=0)]
#define _Deref_post3_impl_(p1,p2,p3) [_$P(_$d=0)]

#define _Deref_ret1_impl_(p1)        [returnvalue:_$R(_$d=0)]
#define _Deref_ret2_impl_(p1,p2)     [returnvalue:_$R(_$d=0)]
#define _Deref_ret3_impl_(p1,p2,p3)  [returnvalue:_$R(_$d=0)]

#define _Deref2_pre1_impl_(p1)       //[_$P(_$d=0)]
#define _Deref2_post1_impl_(p1)      //[_$P(_$d=0)]
#define _Deref2_ret1_impl_(p1)       //[_$P(_$d=0)]

#else

#define _Check_return_impl_

#define _Success_impl_(expr)

#define _Printf_format_string_impl_
#define _Scanf_format_string_impl_
#define _Scanf_s_format_string_impl_

#define _In_bound_impl_
#define _Out_bound_impl_
#define _Ret_bound_impl_
#define _Deref_in_bound_impl_
#define _Deref_out_bound_impl_
#define _Deref_ret_bound_impl_

#define _In_range_impl_(min,max)
#define _Out_range_impl_(min,max)
#define _Ret_range_impl_(min,max)
#define _Deref_in_range_impl_(min,max)
#define _Deref_out_range_impl_(min,max)
#define _Deref_ret_range_impl_(min,max)

#define _Pre1_impl_(p1)
#define _Pre2_impl_(p1,p2)
#define _Pre3_impl_(p1,p2,p3)

#define _Post1_impl_(p1)       
#define _Post2_impl_(p1,p2)
#define _Post3_impl_(p1,p2,p3)

#define _Ret1_impl_(p1)      
#define _Ret2_impl_(p1,p2)
#define _Ret3_impl_(p1,p2,p3)

#define _Deref_pre1_impl_(p1)       
#define _Deref_pre2_impl_(p1,p2)
#define _Deref_pre3_impl_(p1,p2,p3)

#define _Deref_post1_impl_(p1)
#define _Deref_post2_impl_(p1,p2)
#define _Deref_post3_impl_(p1,p2,p3)

#define _Deref_ret1_impl_(p1)
#define _Deref_ret2_impl_(p1,p2)
#define _Deref_ret3_impl_(p1,p2,p3)

#define _Deref2_pre1_impl_(p1)
#define _Deref2_post1_impl_(p1)
#define _Deref2_ret1_impl_(p1)

#endif

// This section contains the deprecated annotations

/* 
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz   : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     LPCSTR pszString,                    -- No annotation required, const implies __in.
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     LPCSTR pszSrc,                       -- No annotation required, const implies __in.
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return == TRUE) LWSTDAPI_(BOOL) 
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/

#define __specstrings

#ifdef  __cplusplus
#ifndef __nothrow
# define __nothrow __declspec(nothrow)
#endif
extern "C" {
#else
#ifndef __nothrow
# define __nothrow
#endif
#endif  /* #ifdef __cplusplus */


/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/

/*
The helper annotations are only understood by the compiler version used by various
defect detection tools. When the regular compiler is running, they are defined into
nothing, and do not affect the compiled code.
*/

#if !defined(__midl) && defined(_PREFAST_) 

    /*
     In the primitive __declspec("SAL_*") annotations "SAL" stands for Standard
     Annotation Language.  These __declspec("SAL_*") annotations are the
     primitives the compiler understands and all high-level SpecString MACROs
     will decompose into these primivates.
    */

    #define SPECSTRINGIZE( x ) #x

    /*
     __null p
     __notnull p
     __maybenull p
    
     Annotates a pointer p. States that pointer p is null. Commonly used
     in the negated form __notnull or the possibly null form __maybenull.
    */

    #define __null                  __declspec("SAL_null")
    #define __notnull               __declspec("SAL_notnull")
    #define __maybenull             __declspec("SAL_maybenull")

    /*
     __readonly l
     __notreadonly l
     __mabyereadonly l
    
     Annotates a location l. States that location l is not modified after
     this point.  If the annotation is placed on the precondition state of
     a function, the restriction only applies until the postcondition state
     of the function.  __maybereadonly states that the annotated location
     may be modified, whereas __notreadonly states that a location must be
     modified.
    */

    #define __readonly              __declspec("SAL_readonly")
    #define __notreadonly           __declspec("SAL_notreadonly")
    #define __maybereadonly         __declspec("SAL_maybereadonly")

    /*
     __valid v
     __notvalid v
     __maybevalid v
    
     Annotates any value v. States that the value satisfies all properties of
     valid values of its type. For example, for a string buffer, valid means
     that the buffer pointer is either NULL or points to a NULL-terminated string.
    */

    #define __valid                 __declspec("SAL_valid")
    #define __notvalid              __declspec("SAL_notvalid")
    #define __maybevalid            __declspec("SAL_maybevalid")

    /*
     __readableTo(extent) p
    
     Annotates a buffer pointer p.  If the buffer can be read, extent describes
     how much of the buffer is readable. For a reader of the buffer, this is
     an explicit permission to read up to that amount, rather than a restriction to
     read only up to it.
    */

    #define __readableTo(extent)    __declspec("SAL_readableTo("SPECSTRINGIZE(extent)")")

    /*
    
     __elem_readableTo(size)
    
     Annotates a buffer pointer p as being readable to size elements.
    */

    #define __elem_readableTo(size)   __declspec("SAL_readableTo(elementCount("SPECSTRINGIZE(size)"))")
    
    /*
     __byte_readableTo(size)
    
     Annotates a buffer pointer p as being readable to size bytes.
    */
    #define __byte_readableTo(size)   __declspec("SAL_readableTo(byteCount("SPECSTRINGIZE(size)"))")
    
    /*
     __writableTo(extent) p
    
     Annotates a buffer pointer p. If the buffer can be modified, extent
     describes how much of the buffer is writable (usually the allocation
     size). For a writer of the buffer, this is an explicit permission to
     write up to that amount, rather than a restriction to write only up to it.
    */
    #define __writableTo(size)   __declspec("SAL_writableTo("SPECSTRINGIZE(size)")")

    /*
     __elem_writableTo(size)
    
     Annotates a buffer pointer p as being writable to size elements.
    */
    #define __elem_writableTo(size)   __declspec("SAL_writableTo(elementCount("SPECSTRINGIZE(size)"))")
    
    /*
     __byte_writableTo(size)
    
     Annotates a buffer pointer p as being writable to size bytes.
    */
    #define __byte_writableTo(size)   __declspec("SAL_writableTo(byteCount("SPECSTRINGIZE(size)"))")

    /*
     __deref p
    
     Annotates a pointer p. The next annotation applies one dereference down
     in the type. If readableTo(p, size) then the next annotation applies to
     all elements *(p+i) for which i satisfies the size. If p is a pointer
     to a struct, the next annotation applies to all fields of the struct.
    */
    #define __deref                 __declspec("SAL_deref")
    
    /*
     __pre __next_annotation
    
     The next annotation applies in the precondition state
    */
    #define __pre                   __declspec("SAL_pre")
    
    /*
     __post __next_annotation
    
     The next annotation applies in the postcondition state
    */
    #define __post                  __declspec("SAL_post")
    
    /*
     __precond(<expr>)
    
     When <expr> is true, the next annotation applies in the precondition state
     (currently not enabled)
    */
    #define __precond(expr)         __pre

    /*
     __postcond(<expr>)
    
     When <expr> is true, the next annotation applies in the postcondition state
     (currently not enabled)
    */
    #define __postcond(expr)        __post

    /*
     __exceptthat
    
     Given a set of annotations Q containing __exceptthat maybeP, the effect of
     the except clause is to erase any P or notP annotations (explicit or
     implied) within Q at the same level of dereferencing that the except
     clause appears, and to replace it with maybeP.
    
      Example 1: __valid __exceptthat __maybenull on a pointer p means that the
                 pointer may be null, and is otherwise valid, thus overriding
                 the implicit notnull annotation implied by __valid on
                 pointers.
    
      Example 2: __valid __deref __exceptthat __maybenull on an int **p means
                 that p is not null (implied by valid), but the elements
                 pointed to by p could be null, and are otherwise valid. 
    */
    #define __exceptthat                __declspec("SAL_except")
    #define __execeptthat               __exceptthat
 
    /*
     _refparam
    
     Added to all out parameter macros to indicate that they are all reference
     parameters.
    */
    #define __refparam                  __deref __notreadonly

    /*
     __inner_*
    
     Helper macros that directly correspond to certain high-level annotations.
    
    */

    /*
     Macros to classify the entrypoints and indicate their category.
    
     Pre-defined control point categories include: RPC, LPC, DeviceDriver, UserToKernel, ISAPI, COM.
    
    */
    #define __inner_control_entrypoint(category) __declspec("SAL_entrypoint(controlEntry, "SPECSTRINGIZE(category)")")

    /*
     Pre-defined data entry point categories include: Registry, File, Network.
    */
    #define __inner_data_entrypoint(category)    __declspec("SAL_entrypoint(dataEntry, "SPECSTRINGIZE(category)")")

    #define __inner_success(expr)               __declspec("SAL_success("SPECSTRINGIZE(expr)")")
    #define __inner_checkReturn                 __declspec("SAL_checkReturn")
    #define __inner_typefix(ctype)              __declspec("SAL_typefix("SPECSTRINGIZE(ctype)")")
    #define __inner_override                    __declspec("__override")
    #define __inner_callback                    __declspec("__callback")
    #define __inner_blocksOn(resource)          __declspec("SAL_blocksOn("SPECSTRINGIZE(resource)")")
    #define __inner_fallthrough_dec             __inline __nothrow void __FallThrough() {}
    #define __inner_fallthrough                 __FallThrough();

#else
    #define __null
    #define __notnull
    #define __maybenull
    #define __readonly
    #define __notreadonly
    #define __maybereadonly
    #define __valid
    #define __notvalid
    #define __maybevalid
    #define __readableTo(extent)
    #define __elem_readableTo(size)
    #define __byte_readableTo(size)
    #define __writableTo(size)
    #define __elem_writableTo(size)
    #define __byte_writableTo(size)
    #define __deref
    #define __pre
    #define __post
    #define __precond(expr)
    #define __postcond(expr)
    #define __exceptthat
    #define __execeptthat
    #define __inner_success(expr)
    #define __inner_checkReturn
    #define __inner_typefix(ctype)
    #define __inner_override
    #define __inner_callback
    #define __inner_blocksOn(resource)
    #define __inner_fallthrough_dec
    #define __inner_fallthrough
    #define __refparam
    #define __inner_control_entrypoint(category)
    #define __inner_data_entrypoint(category)
#endif /* #if !defined(__midl) && defined(_PREFAST_) */

/* 
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/

#define __ecount(size)                                          __notnull __elem_writableTo(size)
#define __bcount(size)                                          __notnull __byte_writableTo(size)
#define __in                                                    __pre __valid __pre __deref __readonly
#define __in_ecount(size)                                       __in __pre __elem_readableTo(size)
#define __in_bcount(size)                                       __in __pre __byte_readableTo(size)
#define __in_z                                                  __in __pre __nullterminated
#define __in_ecount_z(size)                                     __in_ecount(size) __pre __nullterminated
#define __in_bcount_z(size)                                     __in_bcount(size) __pre __nullterminated
#define __in_nz                                                 __in
#define __in_ecount_nz(size)                                    __in_ecount(size)
#define __in_bcount_nz(size)                                    __in_bcount(size)
#define __out                                                   __ecount(1) __post __valid __refparam
#define __out_ecount(size)                                      __ecount(size) __post __valid __refparam
#define __out_bcount(size)                                      __bcount(size) __post __valid __refparam
#define __out_ecount_part(size,length)                          __out_ecount(size) __post __elem_readableTo(length)
#define __out_bcount_part(size,length)                          __out_bcount(size) __post __byte_readableTo(length)
#define __out_ecount_full(size)                                 __out_ecount_part(size,size)
#define __out_bcount_full(size)                                 __out_bcount_part(size,size)
#define __out_z                                                 __post __valid __refparam __post __nullterminated
#define __out_z_opt                                             __post __valid __refparam __post __nullterminated __exceptthat __maybenull
#define __out_ecount_z(size)                                    __ecount(size) __post __valid __refparam __post __nullterminated
#define __out_bcount_z(size)                                    __bcount(size) __post __valid __refparam __post __nullterminated
#define __out_ecount_part_z(size,length)                        __out_ecount_part(size,length) __post __nullterminated
#define __out_bcount_part_z(size,length)                        __out_bcount_part(size,length) __post __nullterminated
#define __out_ecount_full_z(size)                               __out_ecount_full(size) __post __nullterminated
#define __out_bcount_full_z(size)                               __out_bcount_full(size) __post __nullterminated
#define __out_nz                                                __post __valid __refparam __post
#define __out_nz_opt                                            __post __valid __refparam __post __exceptthat __maybenull
#define __out_ecount_nz(size)                                   __ecount(size) __post __valid __refparam
#define __out_bcount_nz(size)                                   __bcount(size) __post __valid __refparam
#define __inout                                                 __pre __valid __post __valid __refparam
#define __inout_ecount(size)                                    __out_ecount(size) __pre __valid
#define __inout_bcount(size)                                    __out_bcount(size) __pre __valid
#define __inout_ecount_part(size,length)                        __out_ecount_part(size,length) __pre __valid __pre __elem_readableTo(length)
#define __inout_bcount_part(size,length)                        __out_bcount_part(size,length) __pre __valid __pre __byte_readableTo(length)
#define __inout_ecount_full(size)                               __inout_ecount_part(size,size)
#define __inout_bcount_full(size)                               __inout_bcount_part(size,size)
#define __inout_z                                               __inout __pre __nullterminated __post __nullterminated
#define __inout_ecount_z(size)                                  __inout_ecount(size) __pre __nullterminated __post __nullterminated
#define __inout_bcount_z(size)                                  __inout_bcount(size) __pre __nullterminated __post __nullterminated
#define __inout_nz                                              __inout
#define __inout_ecount_nz(size)                                 __inout_ecount(size) 
#define __inout_bcount_nz(size)                                 __inout_bcount(size) 
#define __ecount_opt(size)                                      __ecount(size)                              __exceptthat __maybenull
#define __bcount_opt(size)                                      __bcount(size)                              __exceptthat __maybenull
#define __in_opt                                                __in                                        __exceptthat __maybenull
#define __in_ecount_opt(size)                                   __in_ecount(size)                           __exceptthat __maybenull
#define __in_bcount_opt(size)                                   __in_bcount(size)                           __exceptthat __maybenull
#define __in_z_opt                                              __in_opt __pre __nullterminated 
#define __in_ecount_z_opt(size)                                 __in_ecount_opt(size) __pre __nullterminated 
#define __in_bcount_z_opt(size)                                 __in_bcount_opt(size) __pre __nullterminated
#define __in_nz_opt                                             __in_opt                                     
#define __in_ecount_nz_opt(size)                                __in_ecount_opt(size)                         
#define __in_bcount_nz_opt(size)                                __in_bcount_opt(size)                         
#define __out_opt                                               __out                                       __exceptthat __maybenull
#define __out_ecount_opt(size)                                  __out_ecount(size)                          __exceptthat __maybenull
#define __out_bcount_opt(size)                                  __out_bcount(size)                          __exceptthat __maybenull
#define __out_ecount_part_opt(size,length)                      __out_ecount_part(size,length)              __exceptthat __maybenull
#define __out_bcount_part_opt(size,length)                      __out_bcount_part(size,length)              __exceptthat __maybenull
#define __out_ecount_full_opt(size)                             __out_ecount_full(size)                     __exceptthat __maybenull
#define __out_bcount_full_opt(size)                             __out_bcount_full(size)                     __exceptthat __maybenull
#define __out_ecount_z_opt(size)                                __out_ecount_opt(size) __post __nullterminated
#define __out_bcount_z_opt(size)                                __out_bcount_opt(size) __post __nullterminated
#define __out_ecount_part_z_opt(size,length)                    __out_ecount_part_opt(size,length) __post __nullterminated
#define __out_bcount_part_z_opt(size,length)                    __out_bcount_part_opt(size,length) __post __nullterminated
#define __out_ecount_full_z_opt(size)                           __out_ecount_full_opt(size) __post __nullterminated
#define __out_bcount_full_z_opt(size)                           __out_bcount_full_opt(size) __post __nullterminated
#define __out_ecount_nz_opt(size)                               __out_ecount_opt(size) __post __nullterminated                       
#define __out_bcount_nz_opt(size)                               __out_bcount_opt(size) __post __nullterminated                        
#define __inout_opt                                             __inout                                     __exceptthat __maybenull
#define __inout_ecount_opt(size)                                __inout_ecount(size)                        __exceptthat __maybenull
#define __inout_bcount_opt(size)                                __inout_bcount(size)                        __exceptthat __maybenull
#define __inout_ecount_part_opt(size,length)                    __inout_ecount_part(size,length)            __exceptthat __maybenull
#define __inout_bcount_part_opt(size,length)                    __inout_bcount_part(size,length)            __exceptthat __maybenull
#define __inout_ecount_full_opt(size)                           __inout_ecount_full(size)                   __exceptthat __maybenull
#define __inout_bcount_full_opt(size)                           __inout_bcount_full(size)                   __exceptthat __maybenull
#define __inout_z_opt                                           __inout_opt __pre __nullterminated __post __nullterminated
#define __inout_ecount_z_opt(size)                              __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated
#define __inout_ecount_z_opt(size)                              __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated
#define __inout_bcount_z_opt(size)                              __inout_bcount_opt(size) 
#define __inout_nz_opt                                          __inout_opt
#define __inout_ecount_nz_opt(size)                             __inout_ecount_opt(size)
#define __inout_bcount_nz_opt(size)                             __inout_bcount_opt(size)
#define __deref_ecount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __elem_writableTo(size)
#define __deref_bcount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __byte_writableTo(size)
#define __deref_out                                             __deref_ecount(1) __post __deref __valid __refparam
#define __deref_out_ecount(size)                                __deref_ecount(size) __post __deref __valid __refparam
#define __deref_out_bcount(size)                                __deref_bcount(size) __post __deref __valid __refparam
#define __deref_out_ecount_part(size,length)                    __deref_out_ecount(size) __post __deref __elem_readableTo(length)
#define __deref_out_bcount_part(size,length)                    __deref_out_bcount(size) __post __deref __byte_readableTo(length)
#define __deref_out_ecount_full(size)                           __deref_out_ecount_part(size,size)
#define __deref_out_bcount_full(size)                           __deref_out_bcount_part(size,size)
#define __deref_out_z                                           __post __deref __valid __refparam __post __deref __nullterminated
#define __deref_out_ecount_z(size)                              __deref_out_ecount(size) __post __deref __nullterminated  
#define __deref_out_bcount_z(size)                              __deref_out_ecount(size) __post __deref __nullterminated  
#define __deref_out_nz                                          __deref_out
#define __deref_out_ecount_nz(size)                             __deref_out_ecount(size)   
#define __deref_out_bcount_nz(size)                             __deref_out_ecount(size)   
#define __deref_inout                                           __notnull __elem_readableTo(1) __pre __deref __valid __post __deref __valid __refparam
#define __deref_inout_z                                         __deref_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_ecount(size)                              __deref_inout __pre __deref __elem_writableTo(size) __post __deref __elem_writableTo(size)
#define __deref_inout_bcount(size)                              __deref_inout __pre __deref __byte_writableTo(size) __post __deref __byte_writableTo(size)
#define __deref_inout_ecount_part(size,length)                  __deref_inout_ecount(size) __pre __deref __elem_readableTo(length) __post __deref __elem_readableTo(length)
#define __deref_inout_bcount_part(size,length)                  __deref_inout_bcount(size) __pre __deref __byte_readableTo(length) __post __deref __byte_readableTo(length)
#define __deref_inout_ecount_full(size)                         __deref_inout_ecount_part(size,size)
#define __deref_inout_bcount_full(size)                         __deref_inout_bcount_part(size,size)
#define __deref_inout_z                                         __deref_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_ecount_z(size)                            __deref_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_bcount_z(size)                            __deref_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_nz                                        __deref_inout
#define __deref_inout_ecount_nz(size)                           __deref_inout_ecount(size)   
#define __deref_inout_bcount_nz(size)                           __deref_inout_ecount(size)   
#define __deref_ecount_opt(size)                                __deref_ecount(size)                        __post __deref __exceptthat __maybenull
#define __deref_bcount_opt(size)                                __deref_bcount(size)                        __post __deref __exceptthat __maybenull
#define __deref_out_opt                                         __deref_out                                 __post __deref __exceptthat __maybenull
#define __deref_out_ecount_opt(size)                            __deref_out_ecount(size)                    __post __deref __exceptthat __maybenull
#define __deref_out_bcount_opt(size)                            __deref_out_bcount(size)                    __post __deref __exceptthat __maybenull
#define __deref_out_ecount_part_opt(size,length)                __deref_out_ecount_part(size,length)        __post __deref __exceptthat __maybenull
#define __deref_out_bcount_part_opt(size,length)                __deref_out_bcount_part(size,length)        __post __deref __exceptthat __maybenull
#define __deref_out_ecount_full_opt(size)                       __deref_out_ecount_full(size)               __post __deref __exceptthat __maybenull
#define __deref_out_bcount_full_opt(size)                       __deref_out_bcount_full(size)               __post __deref __exceptthat __maybenull
#define __deref_out_z_opt                                       __post __deref __valid __refparam __execeptthat __maybenull __post __deref __nullterminated
#define __deref_out_ecount_z_opt(size)                          __deref_out_ecount_opt(size) __post __deref __nullterminated
#define __deref_out_bcount_z_opt(size)                          __deref_out_bcount_opt(size) __post __deref __nullterminated
#define __deref_out_nz_opt                                      __deref_out_opt
#define __deref_out_ecount_nz_opt(size)                         __deref_out_ecount_opt(size)
#define __deref_out_bcount_nz_opt(size)                         __deref_out_bcount_opt(size)
#define __deref_inout_opt                                       __deref_inout                               __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_opt(size)                          __deref_inout_ecount(size)                  __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_opt(size)                          __deref_inout_bcount(size)                  __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_part_opt(size,length)              __deref_inout_ecount_part(size,length)      __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_part_opt(size,length)              __deref_inout_bcount_part(size,length)      __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_full_opt(size)                     __deref_inout_ecount_full(size)             __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_full_opt(size)                     __deref_inout_bcount_full(size)             __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_z_opt                                     __deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_ecount_z_opt(size)                        __deref_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_bcount_z_opt(size)                        __deref_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_nz_opt                                    __deref_inout_opt 
#define __deref_inout_ecount_nz_opt(size)                       __deref_inout_ecount_opt(size)
#define __deref_inout_bcount_nz_opt(size)                       __deref_inout_bcount_opt(size)
#define __deref_opt_ecount(size)                                __deref_ecount(size)                        __exceptthat __maybenull
#define __deref_opt_bcount(size)                                __deref_bcount(size)                        __exceptthat __maybenull
#define __deref_opt_out                                         __deref_out                                 __exceptthat __maybenull
#define __deref_opt_out_z                                       __deref_opt_out __post __deref __nullterminated
#define __deref_opt_out_ecount(size)                            __deref_out_ecount(size)                    __exceptthat __maybenull
#define __deref_opt_out_bcount(size)                            __deref_out_bcount(size)                    __exceptthat __maybenull
#define __deref_opt_out_ecount_part(size,length)                __deref_out_ecount_part(size,length)        __exceptthat __maybenull
#define __deref_opt_out_bcount_part(size,length)                __deref_out_bcount_part(size,length)        __exceptthat __maybenull
#define __deref_opt_out_ecount_full(size)                       __deref_out_ecount_full(size)               __exceptthat __maybenull
#define __deref_opt_out_bcount_full(size)                       __deref_out_bcount_full(size)               __exceptthat __maybenull
#define __deref_opt_inout                                       __deref_inout                               __exceptthat __maybenull
#define __deref_opt_inout_ecount(size)                          __deref_inout_ecount(size)                  __exceptthat __maybenull
#define __deref_opt_inout_bcount(size)                          __deref_inout_bcount(size)                  __exceptthat __maybenull
#define __deref_opt_inout_ecount_part(size,length)              __deref_inout_ecount_part(size,length)      __exceptthat __maybenull
#define __deref_opt_inout_bcount_part(size,length)              __deref_inout_bcount_part(size,length)      __exceptthat __maybenull
#define __deref_opt_inout_ecount_full(size)                     __deref_inout_ecount_full(size)             __exceptthat __maybenull
#define __deref_opt_inout_bcount_full(size)                     __deref_inout_bcount_full(size)             __exceptthat __maybenull
#define __deref_opt_inout_z                                     __deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_ecount_z(size)                        __deref_opt_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_bcount_z(size)                        __deref_opt_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_nz                                    __deref_opt_inout
#define __deref_opt_inout_ecount_nz(size)                       __deref_opt_inout_ecount(size)
#define __deref_opt_inout_bcount_nz(size)                       __deref_opt_inout_bcount(size)
#define __deref_opt_ecount_opt(size)                            __deref_ecount_opt(size)                    __exceptthat __maybenull
#define __deref_opt_bcount_opt(size)                            __deref_bcount_opt(size)                    __exceptthat __maybenull
#define __deref_opt_out_opt                                     __deref_out_opt                             __exceptthat __maybenull
#define __deref_opt_out_ecount_opt(size)                        __deref_out_ecount_opt(size)                __exceptthat __maybenull
#define __deref_opt_out_bcount_opt(size)                        __deref_out_bcount_opt(size)                __exceptthat __maybenull
#define __deref_opt_out_ecount_part_opt(size,length)            __deref_out_ecount_part_opt(size,length)    __exceptthat __maybenull
#define __deref_opt_out_bcount_part_opt(size,length)            __deref_out_bcount_part_opt(size,length)    __exceptthat __maybenull
#define __deref_opt_out_ecount_full_opt(size)                   __deref_out_ecount_full_opt(size)           __exceptthat __maybenull
#define __deref_opt_out_bcount_full_opt(size)                   __deref_out_bcount_full_opt(size)           __exceptthat __maybenull
#define __deref_opt_out_z_opt                                   __post __deref __valid __refparam __exceptthat __maybenull __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull __post __deref __nullterminated
#define __deref_opt_out_ecount_z_opt(size)                      __deref_opt_out_ecount_opt(size) __post __deref __nullterminated
#define __deref_opt_out_bcount_z_opt(size)                      __deref_opt_out_bcount_opt(size) __post __deref __nullterminated
#define __deref_opt_out_nz_opt                                  __deref_opt_out_opt
#define __deref_opt_out_ecount_nz_opt(size)                     __deref_opt_out_ecount_opt(size)    
#define __deref_opt_out_bcount_nz_opt(size)                     __deref_opt_out_bcount_opt(size)    
#define __deref_opt_inout_opt                                   __deref_inout_opt                           __exceptthat __maybenull
#define __deref_opt_inout_ecount_opt(size)                      __deref_inout_ecount_opt(size)              __exceptthat __maybenull
#define __deref_opt_inout_bcount_opt(size)                      __deref_inout_bcount_opt(size)              __exceptthat __maybenull
#define __deref_opt_inout_ecount_part_opt(size,length)          __deref_inout_ecount_part_opt(size,length)  __exceptthat __maybenull
#define __deref_opt_inout_bcount_part_opt(size,length)          __deref_inout_bcount_part_opt(size,length)  __exceptthat __maybenull
#define __deref_opt_inout_ecount_full_opt(size)                 __deref_inout_ecount_full_opt(size)         __exceptthat __maybenull
#define __deref_opt_inout_bcount_full_opt(size)                 __deref_inout_bcount_full_opt(size)         __exceptthat __maybenull
#define __deref_opt_inout_z_opt                                 __deref_opt_inout_opt  __pre __deref __nullterminated __post __deref __nullterminated             
#define __deref_opt_inout_ecount_z_opt(size)                    __deref_opt_inout_ecount_opt(size)  __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_bcount_z_opt(size)                    __deref_opt_inout_bcount_opt(size)  __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_nz_opt                                __deref_opt_inout_opt               
#define __deref_opt_inout_ecount_nz_opt(size)                   __deref_opt_inout_ecount_opt(size)  
#define __deref_opt_inout_bcount_nz_opt(size)                   __deref_opt_inout_bcount_opt(size)  

/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/

#define __success(expr)                     __inner_success(expr)
#define __nullterminated                    __readableTo(sentinel(0))
#define __nullnullterminated
#define __reserved                          __pre __null
#define __checkReturn                       __inner_checkReturn
#define __typefix(ctype)                    __inner_typefix(ctype)
#define __override                          __inner_override
#define __callback                          __inner_callback
#define __format_string
#define __blocksOn(resource)                __inner_blocksOn(resource)
#define __control_entrypoint(category)      __inner_control_entrypoint(category)
#define __data_entrypoint(category)         __inner_data_entrypoint(category)

#ifndef __fallthrough
    __inner_fallthrough_dec
    #define __fallthrough __inner_fallthrough
#endif

#ifndef __analysis_assume
#ifdef _PREFAST_
#define __analysis_assume(expr) __assume(expr)
#else
#define __analysis_assume(expr) 
#endif
#endif

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sdkddkver.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sdkddkver.h

Abstract:

    Master include file for versioning windows SDK/DDK.

*/

#ifndef _INC_SDKDDKVER
#define _INC_SDKDDKVER

#pragma once

//
// _WIN32_WINNT version constants
//
#define _WIN32_WINNT_NT4                    0x0400
#define _WIN32_WINNT_WIN2K                  0x0500
#define _WIN32_WINNT_WINXP                  0x0501
#define _WIN32_WINNT_WS03                   0x0502
#define _WIN32_WINNT_WIN6                   0x0600
#define _WIN32_WINNT_VISTA                  0x0600
#define _WIN32_WINNT_WS08                   0x0600
#define _WIN32_WINNT_LONGHORN               0x0600

//
// _WIN32_IE_ version constants
//
#define _WIN32_IE_IE20                      0x0200
#define _WIN32_IE_IE30                      0x0300
#define _WIN32_IE_IE302                     0x0302
#define _WIN32_IE_IE40                      0x0400
#define _WIN32_IE_IE401                     0x0401
#define _WIN32_IE_IE50                      0x0500
#define _WIN32_IE_IE501                     0x0501
#define _WIN32_IE_IE55                      0x0550
#define _WIN32_IE_IE60                      0x0600
#define _WIN32_IE_IE60SP1                   0x0601
#ifndef _WIN32_IE_IE60SP2
#define _WIN32_IE_IE60SP2                   0x0603
#endif
#define _WIN32_IE_IE70                      0x0700

//
// IE <-> OS version mapping
//
// NT4 supports IE versions 2.0 -> 6.0 SP1
#define _WIN32_IE_NT4                       _WIN32_IE_IE20
#define _WIN32_IE_NT4SP1                    _WIN32_IE_IE20
#define _WIN32_IE_NT4SP2                    _WIN32_IE_IE20
#define _WIN32_IE_NT4SP3                    _WIN32_IE_IE302
#define _WIN32_IE_NT4SP4                    _WIN32_IE_IE401
#define _WIN32_IE_NT4SP5                    _WIN32_IE_IE401
#define _WIN32_IE_NT4SP6                    _WIN32_IE_IE50
// Win98 supports IE versions 4.01 -> 6.0 SP1
#define _WIN32_IE_WIN98                     _WIN32_IE_IE401
// Win98SE supports IE versions 5.0 -> 6.0 SP1
#define _WIN32_IE_WIN98SE                   _WIN32_IE_IE50
// WinME supports IE versions 5.5 -> 6.0 SP1
#define _WIN32_IE_WINME                     _WIN32_IE_IE55
// Win2k supports IE versions 5.01 -> 6.0 SP1
#define _WIN32_IE_WIN2K                     _WIN32_IE_IE501
#define _WIN32_IE_WIN2KSP1                  _WIN32_IE_IE501
#define _WIN32_IE_WIN2KSP2                  _WIN32_IE_IE501
#define _WIN32_IE_WIN2KSP3                  _WIN32_IE_IE501
#define _WIN32_IE_WIN2KSP4                  _WIN32_IE_IE501
#define _WIN32_IE_XP                        _WIN32_IE_IE60
#define _WIN32_IE_XPSP1                     _WIN32_IE_IE60SP1
#define _WIN32_IE_XPSP2                     _WIN32_IE_IE60SP2
#define _WIN32_IE_WS03                      0x0602
#define _WIN32_IE_WS03SP1                   _WIN32_IE_IE60SP2
#define _WIN32_IE_WIN6                      _WIN32_IE_IE70
#define _WIN32_IE_LONGHORN                  _WIN32_IE_IE70


//
// NTDDI version constants
//
#define NTDDI_WIN2K                         0x05000000
#define NTDDI_WIN2KSP1                      0x05000100
#define NTDDI_WIN2KSP2                      0x05000200
#define NTDDI_WIN2KSP3                      0x05000300
#define NTDDI_WIN2KSP4                      0x05000400

#define NTDDI_WINXP                         0x05010000
#define NTDDI_WINXPSP1                      0x05010100
#define NTDDI_WINXPSP2                      0x05010200
#define NTDDI_WINXPSP3                      0x05010300
#define NTDDI_WINXPSP4                      0x05010400

#define NTDDI_WS03                          0x05020000
#define NTDDI_WS03SP1                       0x05020100
#define NTDDI_WS03SP2                       0x05020200
#define NTDDI_WS03SP3                       0x05020300
#define NTDDI_WS03SP4                       0x05020400

#define NTDDI_WIN6                          0x06000000
#define NTDDI_WIN6SP1                       0x06000100
#define NTDDI_WIN6SP2                       0x06000200
#define NTDDI_WIN6SP3                       0x06000300
#define NTDDI_WIN6SP4                       0x06000400

#define NTDDI_VISTA                         NTDDI_WIN6   
#define NTDDI_VISTASP1                      NTDDI_WIN6SP1
#define NTDDI_VISTASP2                      NTDDI_WIN6SP2
#define NTDDI_VISTASP3                      NTDDI_WIN6SP3
#define NTDDI_VISTASP4                      NTDDI_WIN6SP4
					    
#define NTDDI_WS08                          NTDDI_WIN6SP1
#define NTDDI_WS08SP2                       NTDDI_WIN6SP2
#define NTDDI_WS08SP3                       NTDDI_WIN6SP3
#define NTDDI_WS08SP4                       NTDDI_WIN6SP4

#define NTDDI_LONGHORN  NTDDI_VISTA

//
// masks for version macros
//
#define OSVERSION_MASK      0xFFFF0000
#define SPVERSION_MASK      0x0000FF00
#define SUBVERSION_MASK     0x000000FF


//
// macros to extract various version fields from the NTDDI version
//
#define OSVER(Version)  ((Version) & OSVERSION_MASK)
#define SPVER(Version)  (((Version) & SPVERSION_MASK) >> 8)
#define SUBVER(Version) (((Version) & SUBVERSION_MASK) )


#if defined(DECLSPEC_DEPRECATED_DDK)

// deprecate in 2k or later
#if (NTDDI_VERSION >= NTDDI_WIN2K)
#define DECLSPEC_DEPRECATED_DDK_WIN2K DECLSPEC_DEPRECATED_DDK
#else
#define DECLSPEC_DEPRECATED_DDK_WIN2K
#endif

// deprecate in XP or later
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define DECLSPEC_DEPRECATED_DDK_WINXP DECLSPEC_DEPRECATED_DDK
#else
#define DECLSPEC_DEPRECATED_DDK_WINXP
#endif

// deprecate in WS03 or later
#if (NTDDI_VERSION >= NTDDI_WS03)
#define DECLSPEC_DEPRECATED_DDK_WIN2003 DECLSPEC_DEPRECATED_DDK
#else
#define DECLSPEC_DEPRECATED_DDK_WIN2003
#endif

// deprecate in WIN6 or later
#if (NTDDI_VERSION >= NTDDI_WIN6)
#define DECLSPEC_DEPRECATED_DDK_WIN6 DECLSPEC_DEPRECATED_DDK
#else
#define DECLSPEC_DEPRECATED_DDK_WIN6
#endif

#define DECLSPEC_DEPRECATED_DDK_LONGHORN DECLSPEC_DEPRECATED_DDK_WIN6

#endif // defined(DECLSPEC_DEPRECATED_DDK)


//
// if versions aren't already defined, default to most current
//

#define NTDDI_VERSION_FROM_WIN32_WINNT2(ver)    ver##0000
#define NTDDI_VERSION_FROM_WIN32_WINNT(ver)     NTDDI_VERSION_FROM_WIN32_WINNT2(ver)

#if !defined(_WIN32_WINNT) && !defined(_CHICAGO_)
#define  _WIN32_WINNT   0x0600
#endif

#ifndef NTDDI_VERSION
#ifdef _WIN32_WINNT
// set NTDDI_VERSION based on _WIN32_WINNT
#define NTDDI_VERSION   NTDDI_VERSION_FROM_WIN32_WINNT(_WIN32_WINNT)
#else
#define NTDDI_VERSION   0x06000100
#endif
#endif

#ifndef WINVER
#ifdef _WIN32_WINNT
// set WINVER based on _WIN32_WINNT
#define WINVER          _WIN32_WINNT
#else
#define WINVER          0x0600
#endif
#endif

// CE 7 starts with IE7.  
#ifndef _WIN32_IE
#define _WIN32_IE       0x0700
#endif 

//
// Sanity check for compatible versions
//
#if defined(_WIN32_WINNT) && !defined(MIDL_PASS) && !defined(RC_INVOKED)

#if (defined(WINVER) && (WINVER < 0x0400) && (_WIN32_WINNT > 0x0400))
#error WINVER setting conflicts with _WIN32_WINNT setting
#endif

#if (((OSVERSION_MASK & NTDDI_VERSION) == NTDDI_WIN2K) && (_WIN32_WINNT != _WIN32_WINNT_WIN2K))
#error NTDDI_VERSION setting conflicts with _WIN32_WINNT setting
#endif

#if (((OSVERSION_MASK & NTDDI_VERSION) == NTDDI_WINXP) && (_WIN32_WINNT != _WIN32_WINNT_WINXP))
#error NTDDI_VERSION setting conflicts with _WIN32_WINNT setting
#endif

#if (((OSVERSION_MASK & NTDDI_VERSION) == NTDDI_WS03) && (_WIN32_WINNT != _WIN32_WINNT_WS03))
#error NTDDI_VERSION setting conflicts with _WIN32_WINNT setting
#endif

#if (((OSVERSION_MASK & NTDDI_VERSION) == NTDDI_VISTA) && (_WIN32_WINNT != _WIN32_WINNT_VISTA))
#error NTDDI_VERSION setting conflicts with _WIN32_WINNT setting
#endif

#ifndef UNDER_CE
#if ((_WIN32_WINNT < _WIN32_WINNT_WIN2K) && (_WIN32_IE > _WIN32_IE_IE60SP1))
#error _WIN32_WINNT settings conflicts with _WIN32_IE setting
#endif
#endif

#endif  // defined(_WIN32_WINNT) && !defined(MIDL_PASS) && !defined(_WINRESRC_)


#endif  // !_INC_SDKDDKVER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\schannel.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+---------------------------------------------------------------------------
//
//  File:       schannel.h
//
//  Contents:   Public Definitions for SCHANNEL Security Provider
//
//  Classes:
//
//  Functions:
//
//----------------------------------------------------------------------------



#ifndef __SCHANNEL_H__
#define __SCHANNEL_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include <wincrypt.h>


//
// Security package names.
//

#define UNISP_NAME_A    "Microsoft Unified Security Protocol Provider"
#define UNISP_NAME_W    L"Microsoft Unified Security Protocol Provider"

#define SSL2SP_NAME_A    "Microsoft SSL 2.0"
#define SSL2SP_NAME_W    L"Microsoft SSL 2.0"

#define SSL3SP_NAME_A    "Microsoft SSL 3.0"
#define SSL3SP_NAME_W    L"Microsoft SSL 3.0"

#define TLS1SP_NAME_A    "Microsoft TLS 1.0"
#define TLS1SP_NAME_W    L"Microsoft TLS 1.0"

#define PCT1SP_NAME_A    "Microsoft PCT 1.0"
#define PCT1SP_NAME_W    L"Microsoft PCT 1.0"

#define SCHANNEL_NAME_A  "Schannel"
#define SCHANNEL_NAME_W  L"Schannel"


#ifdef UNICODE

#define UNISP_NAME  UNISP_NAME_W
#define PCT1SP_NAME  PCT1SP_NAME_W
#define SSL2SP_NAME  SSL2SP_NAME_W
#define SSL3SP_NAME  SSL3SP_NAME_W
#define TLS1SP_NAME  TLS1SP_NAME_W
#define SCHANNEL_NAME  SCHANNEL_NAME_W

#else

#define UNISP_NAME  UNISP_NAME_A
#define PCT1SP_NAME  PCT1SP_NAME_A
#define SSL2SP_NAME  SSL2SP_NAME_A
#define SSL3SP_NAME  SSL3SP_NAME_A
#define TLS1SP_NAME  TLS1SP_NAME_A
#define SCHANNEL_NAME  SCHANNEL_NAME_A

#endif


//
// RPC constants.
//

#define UNISP_RPC_ID    14


//
// QueryContextAttributes/QueryCredentialsAttribute extensions
//

#define SECPKG_ATTR_ISSUER_LIST          0x50   // (OBSOLETE) returns SecPkgContext_IssuerListInfo
#define SECPKG_ATTR_REMOTE_CRED          0x51   // (OBSOLETE) returns SecPkgContext_RemoteCredentialInfo
#define SECPKG_ATTR_LOCAL_CRED           0x52   // (OBSOLETE) returns SecPkgContext_LocalCredentialInfo
#define SECPKG_ATTR_REMOTE_CERT_CONTEXT  0x53   // returns PCCERT_CONTEXT
#define SECPKG_ATTR_LOCAL_CERT_CONTEXT   0x54   // returns PCCERT_CONTEXT
#define SECPKG_ATTR_ROOT_STORE           0x55   // returns HCERTCONTEXT to the root store
#define SECPKG_ATTR_SUPPORTED_ALGS       0x56   // returns SecPkgCred_SupportedAlgs
#define SECPKG_ATTR_CIPHER_STRENGTHS     0x57   // returns SecPkgCred_CipherStrengths
#define SECPKG_ATTR_SUPPORTED_PROTOCOLS  0x58   // returns SecPkgCred_SupportedProtocols
#define SECPKG_ATTR_ISSUER_LIST_EX       0x59   // returns SecPkgContext_IssuerListInfoEx
#define SECPKG_ATTR_CONNECTION_INFO      0x5a   // returns SecPkgContext_ConnectionInfo
#define SECPKG_ATTR_EAP_KEY_BLOCK        0x5b   // returns SecPkgContext_EapKeyBlock
#define SECPKG_ATTR_MAPPED_CRED_ATTR     0x5c   // returns SecPkgContext_MappedCredAttr
#define SECPKG_ATTR_SESSION_INFO         0x5d   // returns SecPkgContext_SessionInfo
#define SECPKG_ATTR_APP_DATA             0x5e   // sets/returns SecPkgContext_SessionAppData
#define SECPKG_ATTR_REMOTE_CERTIFICATES  0x5F   // returns SecPkgContext_Certificates
#define SECPKG_ATTR_CLIENT_CERT_POLICY   0x60   // sets    SecPkgCred_ClientCertCtlPolicy
#define SECPKG_ATTR_CC_POLICY_RESULT     0x61   // returns SecPkgContext_ClientCertPolicyResult
#define SECPKG_ATTR_USE_NCRYPT           0x62   // Sets the CRED_FLAG_USE_NCRYPT_PROVIDER FLAG on cred group
#define SECPKG_ATTR_LOCAL_CERT_INFO      0x63   // returns SecPkgContext_CertInfo
#define SECPKG_ATTR_CIPHER_INFO          0x64   // returns new CNG SecPkgContext_CipherInfo
#define SECPKG_ATTR_EAP_PRF_INFO         0x65   // sets    SecPkgContext_EapPrfInfo


// OBSOLETE - included here for backward compatibility only
typedef struct _SecPkgContext_RemoteCredentialInfo
{
    DWORD   cbCertificateChain;
    PBYTE   pbCertificateChain;
    DWORD   cCertificates;
    DWORD   fFlags;
    DWORD   dwBits;
} SecPkgContext_RemoteCredentialInfo, *PSecPkgContext_RemoteCredentialInfo;

typedef SecPkgContext_RemoteCredentialInfo SecPkgContext_RemoteCredenitalInfo, *PSecPkgContext_RemoteCredenitalInfo;

#define RCRED_STATUS_NOCRED          0x00000000
#define RCRED_CRED_EXISTS            0x00000001
#define RCRED_STATUS_UNKNOWN_ISSUER  0x00000002


// OBSOLETE - included here for backward compatibility only
typedef struct _SecPkgContext_LocalCredentialInfo
{
    DWORD   cbCertificateChain;
    PBYTE   pbCertificateChain;
    DWORD   cCertificates;
    DWORD   fFlags;
    DWORD   dwBits;
} SecPkgContext_LocalCredentialInfo, *PSecPkgContext_LocalCredentialInfo;

typedef SecPkgContext_LocalCredentialInfo SecPkgContext_LocalCredenitalInfo, *PSecPkgContext_LocalCredenitalInfo;

#define LCRED_STATUS_NOCRED          0x00000000
#define LCRED_CRED_EXISTS            0x00000001
#define LCRED_STATUS_UNKNOWN_ISSUER  0x00000002


typedef struct _SecPkgCred_SupportedAlgs
{
    DWORD		cSupportedAlgs;
    ALG_ID		*palgSupportedAlgs;
} SecPkgCred_SupportedAlgs, *PSecPkgCred_SupportedAlgs;


typedef struct _SecPkgCred_CipherStrengths
{
    DWORD       dwMinimumCipherStrength;
    DWORD       dwMaximumCipherStrength;
} SecPkgCred_CipherStrengths, *PSecPkgCred_CipherStrengths;


typedef struct _SecPkgCred_SupportedProtocols
{
    DWORD      	grbitProtocol;
} SecPkgCred_SupportedProtocols, *PSecPkgCred_SupportedProtocols;


typedef struct _SecPkgCred_ClientCertPolicy
{
    DWORD   dwFlags;
    GUID    guidPolicyId;
    DWORD   dwCertFlags;
    DWORD   dwUrlRetrievalTimeout;
    BOOL    fCheckRevocationFreshnessTime;
    DWORD   dwRevocationFreshnessTime;
    BOOL    fOmitUsageCheck;
    LPWSTR  pwszSslCtlStoreName;
    LPWSTR  pwszSslCtlIdentifier;
} SecPkgCred_ClientCertPolicy, *PSecPkgCred_ClientCertPolicy;


typedef struct _SecPkgContext_ClientCertPolicyResult
{
    HRESULT dwPolicyResult;
    GUID    guidPolicyId;
} SecPkgContext_ClientCertPolicyResult, *PSecPkgContext_ClientCertPolicyResult;


typedef struct _SecPkgContext_IssuerListInfoEx
{
    PCERT_NAME_BLOB   	aIssuers;
    DWORD           	cIssuers;
} SecPkgContext_IssuerListInfoEx, *PSecPkgContext_IssuerListInfoEx;


typedef struct _SecPkgContext_ConnectionInfo
{
    DWORD   dwProtocol;
    ALG_ID  aiCipher;
    DWORD   dwCipherStrength;
    ALG_ID  aiHash;
    DWORD   dwHashStrength;
    ALG_ID  aiExch;
    DWORD   dwExchStrength;
} SecPkgContext_ConnectionInfo, *PSecPkgContext_ConnectionInfo;

#define SZ_ALG_MAX_SIZE 64
#define SECPKGCONTEXT_CIPHERINFO_V1 1

typedef struct _SecPkgContext_CipherInfo
{

    DWORD dwVersion;
    DWORD dwProtocol;
    DWORD dwCipherSuite;
    DWORD dwBaseCipherSuite;
    WCHAR szCipherSuite[SZ_ALG_MAX_SIZE];
    WCHAR szCipher[SZ_ALG_MAX_SIZE];
    DWORD dwCipherLen;
    DWORD dwCipherBlockLen;    // in bytes
    WCHAR szHash[SZ_ALG_MAX_SIZE];
    DWORD dwHashLen;
    WCHAR szExchange[SZ_ALG_MAX_SIZE];
    DWORD dwMinExchangeLen;
    DWORD dwMaxExchangeLen;
    WCHAR szCertificate[SZ_ALG_MAX_SIZE];
    DWORD dwKeyType;
} SecPkgContext_CipherInfo, *PSecPkgContext_CipherInfo;



typedef struct _SecPkgContext_EapKeyBlock
{
    BYTE    rgbKeys[128];
    BYTE    rgbIVs[64];
} SecPkgContext_EapKeyBlock, *PSecPkgContext_EapKeyBlock;


typedef struct _SecPkgContext_MappedCredAttr
{
    DWORD   dwAttribute;
    PVOID   pvBuffer;
} SecPkgContext_MappedCredAttr, *PSecPkgContext_MappedCredAttr;


// Flag values for SecPkgContext_SessionInfo
#define SSL_SESSION_RECONNECT   1

typedef struct _SecPkgContext_SessionInfo
{
    DWORD dwFlags;
    DWORD cbSessionId;
    BYTE  rgbSessionId[32];
} SecPkgContext_SessionInfo, *PSecPkgContext_SessionInfo;


typedef struct _SecPkgContext_SessionAppData
{
    DWORD dwFlags;
    DWORD cbAppData;
    __field_bcount(cbAppData) PBYTE pbAppData;
} SecPkgContext_SessionAppData, *PSecPkgContext_SessionAppData;

typedef struct _SecPkgContext_EapPrfInfo
{
    DWORD dwVersion;
    DWORD cbPrfData;
    __field_bcount(cbPrfData) PBYTE pbPrfData;
} SecPkgContext_EapPrfInfo, *PSecPkgContext_EapPrfInfo;


//
// This property returns the raw binary certificates that were received 
// from the remote party. The format of the buffer that's returned is as 
// follows.
// 
//     <4 bytes> length of certificate #1
//     <n bytes> certificate #1
//     <4 bytes> length of certificate #2
//     <n bytes> certificate #2
//     ...
//
// After this data is processed, the caller of QueryContextAttributes 
// must free the pbCertificateChain buffer using FreeContextBuffer.
//
typedef struct _SecPkgContext_Certificates
{
    DWORD   cCertificates;
    DWORD   cbCertificateChain;
    PBYTE   pbCertificateChain;
} SecPkgContext_Certificates, *PSecPkgContext_Certificates;


//
// This property returns information about a certificate. In particular 
// it is useful (and only available) in the kernel where CAPI2 is not
// available.
//
typedef struct _SecPkgContext_CertInfo
{
    DWORD   dwVersion;
    DWORD   cbSubjectName;
    LPWSTR  pwszSubjectName;
    DWORD   cbIssuerName;
    LPWSTR  pwszIssuerName;
    DWORD   dwKeySize;
} SecPkgContext_CertInfo, *PSecPkgContext_CertInfo;

#define KERN_CONTEXT_CERT_INFO_V1 0x00000000

//
// Schannel credentials data structure.
//

#define SCH_CRED_V1              0x00000001
#define SCH_CRED_V2              0x00000002  // for legacy code
#define SCH_CRED_VERSION         0x00000002  // for legacy code
#define SCH_CRED_V3              0x00000003  // for legacy code
#define SCHANNEL_CRED_VERSION    0x00000004


struct _HMAPPER;

typedef struct _SCHANNEL_CRED
{
    DWORD           dwVersion;      // always SCHANNEL_CRED_VERSION
    DWORD           cCreds;
    PCCERT_CONTEXT *paCred;
    HCERTSTORE      hRootStore;

    DWORD           cMappers;
    struct _HMAPPER **aphMappers;

    DWORD           cSupportedAlgs;
    ALG_ID *        palgSupportedAlgs;

    DWORD           grbitEnabledProtocols;
    DWORD           dwMinimumCipherStrength;
    DWORD           dwMaximumCipherStrength;
    DWORD           dwSessionLifespan;
    DWORD           dwFlags;
    DWORD           dwCredFormat;
} SCHANNEL_CRED, *PSCHANNEL_CRED;


// Values for SCHANNEL_CRED dwCredFormat field.
#define SCH_CRED_FORMAT_CERT_CONTEXT    0x00000000
#define SCH_CRED_FORMAT_CERT_HASH       0x00000001
#define SCH_CRED_FORMAT_CERT_HASH_STORE 0x00000002

#define SCH_CRED_MAX_STORE_NAME_SIZE    128
#define SCH_CRED_MAX_SUPPORTED_ALGS     256
#define SCH_CRED_MAX_SUPPORTED_CERTS    100

typedef struct _SCHANNEL_CERT_HASH
{
    DWORD           dwLength;
    DWORD           dwFlags;
    HCRYPTPROV      hProv;
    BYTE            ShaHash[20];
} SCHANNEL_CERT_HASH, *PSCHANNEL_CERT_HASH;

typedef struct _SCHANNEL_CERT_HASH_STORE
{
    DWORD           dwLength;
    DWORD           dwFlags;
    HCRYPTPROV      hProv;
    BYTE            ShaHash[20];
    WCHAR           pwszStoreName[SCH_CRED_MAX_STORE_NAME_SIZE];
} SCHANNEL_CERT_HASH_STORE, *PSCHANNEL_CERT_HASH_STORE;

// Values for SCHANNEL_CERT_HASH dwFlags field.
#define SCH_MACHINE_CERT_HASH           0x00000001


//+-------------------------------------------------------------------------
// Flags for use with SCHANNEL_CRED
//
// SCH_CRED_NO_SYSTEM_MAPPER
//      This flag is intended for use by server applications only. If this
//      flag is set, then schannel does *not* attempt to map received client
//      certificate chains to an NT user account using the built-in system
//      certificate mapper.This flag is ignored by non-NT5 versions of
//      schannel.
//
// SCH_CRED_NO_SERVERNAME_CHECK
//      This flag is intended for use by client applications only. If this
//      flag is set, then when schannel validates the received server
//      certificate chain, is does *not* compare the passed in target name
//      with the subject name embedded in the certificate. This flag is
//      ignored by non-NT5 versions of schannel. This flag is also ignored
//      if the SCH_CRED_MANUAL_CRED_VALIDATION flag is set.
//
// SCH_CRED_MANUAL_CRED_VALIDATION
//      This flag is intended for use by client applications only. If this
//      flag is set, then schannel will *not* automatically attempt to
//      validate the received server certificate chain. This flag is
//      ignored by non-NT5 versions of schannel, but all client applications
//      that wish to validate the certificate chain themselves should
//      specify this flag, so that there's at least a chance they'll run
//      correctly on NT5.
//
// SCH_CRED_NO_DEFAULT_CREDS
//      This flag is intended for use by client applications only. If this
//      flag is set, and the server requests client authentication, then
//      schannel will *not* attempt to automatically acquire a suitable
//      default client certificate chain. This flag is ignored by non-NT5
//      versions of schannel, but all client applications that wish to
//      manually specify their certicate chains should specify this flag,
//      so that there's at least a chance they'll run correctly on NT5.
//
// SCH_CRED_AUTO_CRED_VALIDATION
//      This flag is the opposite of SCH_CRED_MANUAL_CRED_VALIDATION.
//      Conservatively written client applications will always specify one
//      flag or the other.
//
// SCH_CRED_USE_DEFAULT_CREDS
//      This flag is the opposite of SCH_CRED_NO_DEFAULT_CREDS.
//      Conservatively written client applications will always specify one
//      flag or the other.
//
// SCH_CRED_DISABLE_RECONNECTS
//      This flag is intended for use by server applications only. If this 
//      flag is set, then full handshakes performed with this credential 
//      will not be marked suitable for reconnects. A cache entry will still 
//      be created, however, so the session can be made resumable later
//      via a call to ApplyControlToken.
//      
//
// SCH_CRED_REVOCATION_CHECK_END_CERT
// SCH_CRED_REVOCATION_CHECK_CHAIN
// SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT
//      These flags specify that when schannel automatically validates a
//      received certificate chain, some or all of the certificates are to
//      be checked for revocation. Only one of these flags may be specified.
//      See the CertGetCertificateChain function. These flags are ignored by
//      non-NT5 versions of schannel.
//
// SCH_CRED_IGNORE_NO_REVOCATION_CHECK
// SCH_CRED_IGNORE_REVOCATION_OFFLINE
//      These flags instruct schannel to ignore the
//      CRYPT_E_NO_REVOCATION_CHECK and CRYPT_E_REVOCATION_OFFLINE errors
//      respectively if they are encountered when attempting to check the
//      revocation status of a received certificate chain. These flags are
//      ignored if none of the above flags are set.
//
// SCH_CRED_CACHE_ONLY_URL_RETRIEVAL_ON_CREATE
//      This flag instructs schannel to pass CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL
//      flags to CertGetCertificateChain when validating the specified
//      credentials during a call to AcquireCredentialsHandle. The default for 
//      vista is to not specify CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL. Use 
//      SCH_CRED_CACHE_ONLY_URL_RETRIEVAL_ON_CREATE to override this behavior.
//      NOTE: Prior to Vista, this flag(CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL) was
//      specified by default. 
//
//  SCH_SEND_ROOT_CERT
//      This flag instructs schannel to send the root cert as part of the 
//      certificate message.
//+-------------------------------------------------------------------------
#define SCH_CRED_NO_SYSTEM_MAPPER                    0x00000002
#define SCH_CRED_NO_SERVERNAME_CHECK                 0x00000004
#define SCH_CRED_MANUAL_CRED_VALIDATION              0x00000008
#define SCH_CRED_NO_DEFAULT_CREDS                    0x00000010
#define SCH_CRED_AUTO_CRED_VALIDATION                0x00000020
#define SCH_CRED_USE_DEFAULT_CREDS                   0x00000040
#define SCH_CRED_DISABLE_RECONNECTS                  0x00000080

#define SCH_CRED_REVOCATION_CHECK_END_CERT           0x00000100
#define SCH_CRED_REVOCATION_CHECK_CHAIN              0x00000200
#define SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT 0x00000400
#define SCH_CRED_IGNORE_NO_REVOCATION_CHECK          0x00000800
#define SCH_CRED_IGNORE_REVOCATION_OFFLINE           0x00001000

#define SCH_CRED_RESTRICTED_ROOTS                    0x00002000
#define SCH_CRED_REVOCATION_CHECK_CACHE_ONLY         0x00004000
#define SCH_CRED_CACHE_ONLY_URL_RETRIEVAL            0x00008000

#define SCH_CRED_MEMORY_STORE_CERT                   0x00010000

#define SCH_CRED_CACHE_ONLY_URL_RETRIEVAL_ON_CREATE  0x00020000

#define SCH_SEND_ROOT_CERT                           0x00040000

//
//
// ApplyControlToken PkgParams types
//
// These identifiers are the DWORD types
// to be passed into ApplyControlToken
// through a PkgParams buffer.

#define SCHANNEL_RENEGOTIATE    0   // renegotiate a connection
#define SCHANNEL_SHUTDOWN       1   // gracefully close down a connection
#define SCHANNEL_ALERT          2   // build an error message
#define SCHANNEL_SESSION        3   // session control


// Alert token structure.
typedef struct _SCHANNEL_ALERT_TOKEN
{
    DWORD   dwTokenType;            // SCHANNEL_ALERT
    DWORD   dwAlertType;
    DWORD   dwAlertNumber;
} SCHANNEL_ALERT_TOKEN;

// Alert types.
#define TLS1_ALERT_WARNING              1
#define TLS1_ALERT_FATAL                2

// Alert messages.
#define TLS1_ALERT_CLOSE_NOTIFY         0       // warning
#define TLS1_ALERT_UNEXPECTED_MESSAGE   10      // error
#define TLS1_ALERT_BAD_RECORD_MAC       20      // error
#define TLS1_ALERT_DECRYPTION_FAILED    21      // error
#define TLS1_ALERT_RECORD_OVERFLOW      22      // error
#define TLS1_ALERT_DECOMPRESSION_FAIL   30      // error
#define TLS1_ALERT_HANDSHAKE_FAILURE    40      // error
#define TLS1_ALERT_BAD_CERTIFICATE      42      // warning or error
#define TLS1_ALERT_UNSUPPORTED_CERT     43      // warning or error
#define TLS1_ALERT_CERTIFICATE_REVOKED  44      // warning or error
#define TLS1_ALERT_CERTIFICATE_EXPIRED  45      // warning or error
#define TLS1_ALERT_CERTIFICATE_UNKNOWN  46      // warning or error
#define TLS1_ALERT_ILLEGAL_PARAMETER    47      // error
#define TLS1_ALERT_UNKNOWN_CA           48      // error
#define TLS1_ALERT_ACCESS_DENIED        49      // error
#define TLS1_ALERT_DECODE_ERROR         50      // error
#define TLS1_ALERT_DECRYPT_ERROR        51      // error
#define TLS1_ALERT_EXPORT_RESTRICTION   60      // error
#define TLS1_ALERT_PROTOCOL_VERSION     70      // error
#define TLS1_ALERT_INSUFFIENT_SECURITY  71      // error
#define TLS1_ALERT_INTERNAL_ERROR       80      // error
#define TLS1_ALERT_USER_CANCELED        90      // warning or error
#define TLS1_ALERT_NO_RENEGOTIATION    100      // warning


// Session control flags
#define SSL_SESSION_ENABLE_RECONNECTS   1
#define SSL_SESSION_DISABLE_RECONNECTS  2

// Session control token structure.
typedef struct _SCHANNEL_SESSION_TOKEN
{
    DWORD   dwTokenType;        // SCHANNEL_SESSION
    DWORD   dwFlags;
} SCHANNEL_SESSION_TOKEN;


typedef struct _SCHANNEL_CLIENT_SIGNATURE
{
    DWORD       cbLength;
    ALG_ID      aiHash;
    DWORD       cbHash;
    BYTE        HashValue[36];
    BYTE        CertThumbprint[20];
} SCHANNEL_CLIENT_SIGNATURE, *PSCHANNEL_CLIENT_SIGNATURE;


//
// Flags for identifying the various different protocols.
//

/* flag/identifiers for protocols we support */
#define SP_PROT_PCT1_SERVER             0x00000001
#define SP_PROT_PCT1_CLIENT             0x00000002
#define SP_PROT_PCT1                    (SP_PROT_PCT1_SERVER | SP_PROT_PCT1_CLIENT)

#define SP_PROT_SSL2_SERVER             0x00000004
#define SP_PROT_SSL2_CLIENT             0x00000008
#define SP_PROT_SSL2                    (SP_PROT_SSL2_SERVER | SP_PROT_SSL2_CLIENT)

#define SP_PROT_SSL3_SERVER             0x00000010
#define SP_PROT_SSL3_CLIENT             0x00000020
#define SP_PROT_SSL3                    (SP_PROT_SSL3_SERVER | SP_PROT_SSL3_CLIENT)

#define SP_PROT_TLS1_SERVER             0x00000040
#define SP_PROT_TLS1_CLIENT             0x00000080
#define SP_PROT_TLS1                    (SP_PROT_TLS1_SERVER | SP_PROT_TLS1_CLIENT)

#define SP_PROT_SSL3TLS1_CLIENTS        (SP_PROT_TLS1_CLIENT | SP_PROT_SSL3_CLIENT)
#define SP_PROT_SSL3TLS1_SERVERS        (SP_PROT_TLS1_SERVER | SP_PROT_SSL3_SERVER)
#define SP_PROT_SSL3TLS1                (SP_PROT_SSL3 | SP_PROT_TLS1)

#define SP_PROT_UNI_SERVER              0x40000000
#define SP_PROT_UNI_CLIENT              0x80000000
#define SP_PROT_UNI                     (SP_PROT_UNI_SERVER | SP_PROT_UNI_CLIENT)

#define SP_PROT_ALL                     0xffffffff
#define SP_PROT_NONE                    0
#define SP_PROT_CLIENTS                 (SP_PROT_PCT1_CLIENT | SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT | SP_PROT_UNI_CLIENT | SP_PROT_TLS1_CLIENT)
#define SP_PROT_SERVERS                 (SP_PROT_PCT1_SERVER | SP_PROT_SSL2_SERVER | SP_PROT_SSL3_SERVER | SP_PROT_UNI_SERVER | SP_PROT_TLS1_SERVER)


//
// Helper function used to flush the SSL session cache.
//

typedef BOOL
(WINAPI * SSL_EMPTY_CACHE_FN_A)(
    LPSTR  pszTargetName,
    DWORD  dwFlags);

BOOL 
WINAPI
SslEmptyCacheA(__in LPSTR  pszTargetName,
               __in DWORD  dwFlags);

typedef BOOL
(WINAPI * SSL_EMPTY_CACHE_FN_W)(
    LPWSTR pszTargetName,
    DWORD  dwFlags);

BOOL 
WINAPI
SslEmptyCacheW(__in LPWSTR pszTargetName,
               __in DWORD  dwFlags);

#ifdef UNICODE
#define SSL_EMPTY_CACHE_FN SSL_EMPTY_CACHE_FN_W
#define SslEmptyCache SslEmptyCacheW
#else
#define SSL_EMPTY_CACHE_FN SSL_EMPTY_CACHE_FN_A
#define SslEmptyCache SslEmptyCacheA
#endif



// Structures for compatability with the
// NT 4.0 SP2 / IE 3.0 schannel interface, do
// not use.

typedef struct _SSL_CREDENTIAL_CERTIFICATE {
    DWORD   cbPrivateKey;
    PBYTE   pPrivateKey;
    DWORD   cbCertificate;
    PBYTE   pCertificate;
    PSTR    pszPassword;
} SSL_CREDENTIAL_CERTIFICATE, * PSSL_CREDENTIAL_CERTIFICATE;




// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
#define SCHANNEL_SECRET_TYPE_CAPI   0x00000001
#define SCHANNEL_SECRET_PRIVKEY     0x00000002
#define SCH_CRED_X509_CERTCHAIN     0x00000001
#define SCH_CRED_X509_CAPI          0x00000002
#define SCH_CRED_CERT_CONTEXT       0x00000003

struct _HMAPPER;
typedef struct _SCH_CRED
{
    DWORD     dwVersion;                // always SCH_CRED_VERSION.
    DWORD     cCreds;                   // Number of credentials.
    PVOID     *paSecret;                // Array of SCH_CRED_SECRET_* pointers
    PVOID     *paPublic;                // Array of SCH_CRED_PUBLIC_* pointers
    DWORD     cMappers;                 // Number of credential mappers.
    struct _HMAPPER   **aphMappers;     // pointer to an array of pointers to credential mappers
} SCH_CRED, * PSCH_CRED;

// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_SECRET_CAPI
{
    DWORD           dwType;      // SCHANNEL_SECRET_TYPE_CAPI
    HCRYPTPROV      hProv;       // credential secret information.

} SCH_CRED_SECRET_CAPI, * PSCH_CRED_SECRET_CAPI;


// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_SECRET_PRIVKEY
{
    DWORD           dwType;       // SCHANNEL_SECRET_PRIVKEY
    PBYTE           pPrivateKey;   // Der encoded private key
    DWORD           cbPrivateKey;
    PSTR            pszPassword;  // Password to crack the private key.

} SCH_CRED_SECRET_PRIVKEY, * PSCH_CRED_SECRET_PRIVKEY;


// Structures for use with the
// NT 4.0 SP3 Schannel interface,
// do not use.
typedef struct _SCH_CRED_PUBLIC_CERTCHAIN
{
    DWORD       dwType;
    DWORD       cbCertChain;
    PBYTE       pCertChain;
} SCH_CRED_PUBLIC_CERTCHAIN, *PSCH_CRED_PUBLIC_CERTCHAIN;


// Structures needed for Pre NT4.0 SP2 calls.
typedef struct _PctPublicKey
{
    DWORD Type;
    DWORD cbKey;
    UCHAR pKey[1];
} PctPublicKey;

typedef struct _X509Certificate {
    DWORD           Version;
    DWORD           SerialNumber[4];
    ALG_ID          SignatureAlgorithm;
    FILETIME        ValidFrom;
    FILETIME        ValidUntil;
    PSTR            pszIssuer;
    PSTR            pszSubject;
    PctPublicKey    *pPublicKey;
} X509Certificate, * PX509Certificate;



// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
BOOL
WINAPI
SslGenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits );

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
VOID
WINAPI
SslGenerateRandomBits(
    PUCHAR      pRandomData,
    LONG        cRandomData
    );

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
BOOL
WINAPI
SslCrackCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    DWORD               dwFlags,
    PX509Certificate *  ppCertificate
    );

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
VOID
WINAPI
SslFreeCertificate(
    PX509Certificate    pCertificate
    );

DWORD
WINAPI
SslGetMaximumKeySize(
    DWORD   Reserved );

BOOL
WINAPI
SslGetDefaultIssuers(
    PBYTE pbIssuers,
    DWORD *pcbIssuers);

#define SSL_CRACK_CERTIFICATE_NAME  TEXT("SslCrackCertificate")
#define SSL_FREE_CERTIFICATE_NAME   TEXT("SslFreeCertificate")

// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
typedef BOOL
(WINAPI * SSL_CRACK_CERTIFICATE_FN)
(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    BOOL                VerifySignature,
    PX509Certificate *  ppCertificate
);


// Pre NT4.0 SP2 calls.  Call CAPI1 or CAPI2
// to get the same functionality instead.
typedef VOID
(WINAPI * SSL_FREE_CERTIFICATE_FN)
(
    PX509Certificate    pCertificate
);


#endif //__SCHANNEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sdmem.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

// Copyright (c) 2002-2004 BSQUARE Corporation.  All rights reserved.
// DO NOT REMOVE --- BEGIN EXTERNALLY DEVELOPED SOURCE CODE ID 40973--- DO NOT REMOVE

// Types and variables used for Memory Lists and Memory Tagging   

#ifndef SDMEM_DEFINED
#define SDMEM_DEFINED


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//  SDInitializeCardLib - initializes the card library
//  Input:
//  Output:
//  Return: success or failure
//  Notes:  call this in your DLL entry upon attach to
//          avoid race conditions in the memory subsystem
//
BOOL SDInitializeCardLib();


//  SDDeinitializeCardLib - initializes the card library
//  Input:
//  Output:
//  Return: success or failure
//  Notes:  call this in your DLL entry upon detach to
//          avoid race conditions in the memory subsystem
//
BOOL SDDeinitializeCardLib();


//  SDAllocateMemoryWithTag - allocates memory with a tag
//  Input:  Size - size of the allocation
//          Tag - tag in the form of 4 ASCII characters to track the allocation
//  Output:
//  Return:
//  Notes:  returns a pointer to the allocated memory
//          must use SDFreeMemory
//
PVOID SDAllocateMemoryWithTag(ULONG Size,
    ULONG Tag);


//  SDFreeMemory - frees memory allocated with SDAllocateMemoryWithTag
//  Input:  pMemory - the memory to free
//  Output:
//  Return:
//  Notes:  
//
VOID SDFreeMemory(PVOID pMemory);


// memory list handle is an opaque structure
typedef PVOID SD_MEMORY_LIST_HANDLE;

//  SDDeleteMemhList - delete a memory list
//      
//  Input:
//          hList - memory list to delete
//        
//  Output:
//  Return: 
//          
//  Notes:  
//          
VOID SDDeleteMemList(SD_MEMORY_LIST_HANDLE hList);


//  SDCreateMemoryList - create a memory list
//      
//  Input:  Tag      - Memory Tag
//          Depth    - threshold of committed memory list size, also initial number of 
//                     entries
//          EntrySize - Size of each entry/block
//          
//  Output: 
//  Return: handle to memory list        
//  Notes:  
//          Initializes a mem list structure for use in allocating and deallocating
//          fixed blocks of memory.  This is a mechanism to reduce heap fragmentation.  
//          Allocations are dynamic (i.e. the list grows to accomodate allocations), 
//          however, deallocated blocks are recycled rather than returned to the process heap.
//          
//          The  depth specifies the maximum number of heap committed allocations.  Additional
//          allocations beyond the maximum depth are allocated normally, but returned to the heap rather
//          than re-cycled.
// 
//            
//          Must call SDDeleteMemList to free the list.
//          Returns Memory hList Object handle, otherwise NULL
//
SD_MEMORY_LIST_HANDLE SDCreateMemoryList(ULONG Tag,
    ULONG Depth,
    ULONG EntrySize);


//  SDFreeToMemList - free a block of memory to the memory list
//      
//  Input:  hList - mem list object
//          pMemory - block of memory to free 
//  Output: 
//  Return:
//          
//  Notes:  
//          returns memory block to mem list
//
VOID SDFreeToMemList(SD_MEMORY_LIST_HANDLE hList,
    PVOID                 pMemory);


//  SDAllocateFromMemhList - Allocate a block from the memory list
//      
//  Input:
//          hList - memory list
//        
//  Output: 
//  Return: returns pointer to memory block, NULL if system is out of memory         
//  Notes:  
//          returns memory block from mem list
//
PVOID SDAllocateFromMemList(SD_MEMORY_LIST_HANDLE hList);


// The following routines are no longer supported.
#define SDCheckMemoryTags(LogFileName) (TRUE)
#define SDDumpMemoryTagState()
#define SDInitializeMemoryTagging(Tags, pModuleName) (TRUE)
#define SDDeleteMemoryTagging()


#ifdef __cplusplus
}
#endif //__cplusplus

#endif

// DO NOT REMOVE --- END EXTERNALLY DEVELOPED SOURCE CODE ID --- DO NOT REMOVE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\searchguid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#pragma once

// {A43D885E-721A-481b-8DEB-5D3CEA0F3B98}
DEFINE_GUID(IID_ISupplierWrapper,
    0xa43d885e, 0x721a, 0x481b, 0x8d, 0xeb, 0x5d, 0x3c, 0xea, 0xf, 0x3b, 0x98);

// {2C1D03A9-B6E0-4671-AF44-7EEB522CB266}
DEFINE_GUID(IID_ICategorizedDataItemFactory, 
    0x2c1d03a9, 0xb6e0, 0x4671, 0xaf, 0x44, 0x7e, 0xeb, 0x52, 0x2c, 0xb2, 0x66);

// {3B67CF78-8441-4eac-9DFA-2596A17411B8}
DEFINE_GUID(IID_ISearchQuery, 
    0x3b67cf78, 0x8441, 0x4eac, 0x9d, 0xfa, 0x25, 0x96, 0xa1, 0x74, 0x11, 0xb8);

// {2E8431B0-A219-4d3f-A935-B58F73335592}
DEFINE_GUID(IID_IDataItemBulkOperations, 
    0x2e8431b0, 0xa219, 0x4d3f, 0xa9, 0x35, 0xb5, 0x8f, 0x73, 0x33, 0x55, 0x92);


// {CFA2DC4D-AB9F-4ede-B0AF-9C843FE69170}
DEFINE_GUID(IID_IItemPropertyMappingResult, 
    0xcfa2dc4d, 0xab9f, 0x4ede, 0xb0, 0xaf, 0x9c, 0x84, 0x3f, 0xe6, 0x91, 0x70);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\security.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: security.h

Purpose: Top-level include file for security aware components.

--*/

// This file will go out and pull in all the header files that you need,
// based on defines that you issue.  The following macros are used.

// NOTE:  Update this section if you add new files:
//
// SECURITY_KERNEL      Use the kernel interface, not the usermode
// SECURITY_PACKAGE     Include defines necessary for security packages
// SECURITY_KERBEROS    Include everything needed to talk to the kerberos pkg.
// SECURITY_NTLM        Include everything to talk to ntlm package.
// SECURITY_OBJECTS     Include all Security Admin Object definitions.

//
// Each of the files included here are surrounded by guards, so you don't
// need to worry about including this file multiple times with different
// flags defined
//

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef SSPI_PROXY_CLASS
#define SSPI_PROXY_CLASS    PROXY_CLASS
#endif

#include <windows.h>

#include <sspi.h>

//#include <secext.h>

//
// Include the error codes:
//

//#include <issperr.h>


// Include security package headers:


#ifdef SECURITY_NTLM

// #include <ntlmsp.h>

#endif // SECURITY_NTLM


// Include security object definitions


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\seekpt.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
#ifndef __seekpt_h__
#define __seekpt_h__


class CSeekingPassThru : public ISeekingPassThru, public CUnknown
{
public:
    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    CSeekingPassThru(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);
    ~CSeekingPassThru();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP Init(BOOL bSupportRendering, IPin *pPin);

private:
    CPosPassThru              *m_pPosPassThru;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\secpol.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// System Security Policies
// Please keep them in numerical order.
//

// This policy setting determines whether applications stored on an MMC card are allowed to
// auto-run when inserted into the device.
//      0x00000000 - Applications ARE allowed to auto-run (default)
//      0x00000001 - Applications are NOT allowed to auto-run
#define SECPOLICY_CFAUTORUN                     0x00000002

#define POLICYVAL_CFAUTORUN_ALLOWED             0x00000000
#define POLICYVAL_CFAUTORUN_DISABLED            0x00000001

// This policy setting determines APPS Policy
#define POLICYVAL_APPS_DISALLOW                 0
#define POLICYVAL_APPS_ALLOW                    1

// This policy setting enforces whether RAPI calls can be used on the device
#define SECPOLICY_RAPI                          0x1001

#define SECPOLICY_RAPI_DISABLED                 0
#define SECPOLICY_RAPI_ALLOWED                  1
#define SECPOLICY_RAPI_RESTRICTED_MODE          2

// This policy setting determines the role mask for unsigned cabs
#define SECPOLICY_UNSIGNEDCABS                  0x1005

// This policy setting enforces whether unsigned applications 
// are allowed to run on the device.
#define SECPOLICY_UNSIGNEDAPPS                  0x1006

// This policy setting determines the role mask for processing .xml file for .hme and .tsk files
#define SECPOLICY_UNSIGNEDTHEMES                0x1007

// This policy setting determines whether carriers are allowed 
// to be assigned Trusted Provisioning Server (TPS) role.
#define SECPOLICY_TPSCARRIERROLE                0x1008

// This policy setting defines the maximum number allowed of retry 
// times for the user to authenticate a WAP pin-signed message.
#define SECPOLICY_MAXAUTHENTICATIONRETRY        0x1009

// SECPOLICY_WAPSIGNEDMSG is deprecated. Use SECPOLICY_OMACPNETWPINMSG, SECPOLICY_OMACPUSERPINMSG and SECPOLICY_OMACPUSERNETWPINMSG instead

// This policy setting determines how SL signed messages 
// should be processed based on origin.
#define SECPOLICY_SL_MESSAGE                    0x100c

// This policy setting determines how SI signed messages 
// should be processed based on origin.
#define SECPOLICY_SI_MESSAGE                    0x100d

// This policy setting determines whether to accept non WAP-signed and 
// non ESP-encrypted messages, processed by the default security provider 
// in Security Module, based on their origin.
#define SECPOLICY_UNAUTHMESSAGES                0x100e

// This policy setting determines which provisioning messages are accepted 
// by cfghost based on the message's role(s).  This policy is used to limit 
// provisioning messages that come from Push Router.
#define SECPOLICY_OTAPROVISIONING               0x100f

// This policy setting determines whether routing of WSP notifications 
// from WAP stack is allowed.
#define SECPOLICY_WSPNOTIFICATIONS              0x1011

// This policy allows granting other roles administrative privileges to the system 
// without having to explicitly acquire the manager role.  
#define SECPOLICY_GRANTMANAGER                  0x1017

// This policy allows other roles to impersonate the User Auth role.
#define SECPOLICY_GRANTUSERAUTH                 0x1018

// This policy specifies the level of permissions required to create, modify, 
// and delete a trusted push proxy gateway (PPG).
#define SECPOLICY_TRUSTED_WAP_PROXY             0x1019

// This policy controls whether the user will be prompted with a Yes/No
// dialog before an unsigned application is allowed to install or execute.
// If the policy is equal to 1, then the user is never prompted.
#define SECPOLICY_UNSIGNEDPROMPT                0x101a

// SL security policy
// Operator can override https to use http or wsps to wsp.
// Value of 0 means we need to use https or wsps
// Value of 1 means we can use http or wsp
#define SECPOLICY_SLSECUREDOWNLOAD              0x101c

// This policy determines whether software certificates can be used to
// sign outgoing messages.  A value of 0 indicates that software certificates
// CANNOT be used to sign messages, and a value of 1 indicates that they CAN.
#define SECPOLICY_SOFTCERTS                     0x101f

// This policy determines which DRM rights messages are accepted by the DRM engine
// based on the message's role(s).
#define SECPOLICY_DRM_WAPRIGHTS                 0x1021

// This policy determines whether the OMA device management transport client 
// will enforce SSL usage when connecting to a server, no matter what is bootstrapped.  
// By default, the client always uses SSL.
#define SECPOLICY_OMADMSSLCONN                  0x1022

#define POLICYVAL_OMADMSSLCONN_NO_ENFORCE       0x1

// This policy specifies if a password must be configured 
// on the device (if it is not already configured).
//     0 - Password is required
//     Any other value - Password is not required
#define SECPOLICY_LASS_PWD_REQUIRED             0x1023

#define POLICYVAL_LASS_PWD_REQUIRED             0x0


// This policy determines whether to display a prompt for network-pin-signed
// WAP provisioning messages.
#define SECPOLICY_WAP_NETWPIN_PROMPT            0x1024

#define POLICYVAL_WAP_NETWPIN_PROMPT            0x0

#define POLICYVAL_WAP_NETWPIN_NO_PROMPT         0x1


// This policy specifies how desktop should handle device authentication.
// 0 - User must authenticate on device if locked upon connect
// 1 - User can authenticate through PIN on desktop
//
// Note: This policy is now obsolete for WM6 and greater devices. 
//       These devices can not be unlocked by a PIN from the desktop 
//       See new policy (SECPOLICY_LASS_DESKTOP_QUICK_CONNECT)
 
#define SECPOLICY_LASS_DESKTOP                  0x1025
 
#define POLICYVAL_LASS_DESKTOP_NO_AUTH          0x0
#define POLICYVAL_LASS_DESKTOP_AUTH_ALLOWED     0x1


// This policy specifies if the user is allowed to change mobile encryption
// settings for removable storage.
// 0 - User can NOT change settings
// 1 - User CAN change settings

#define SECPOLICY_MENCRYPT_REMOVABLE            0x1026
 
#define POLICYVAL_MENCRYPT_REMOVABLE_NO_USER    0x0
#define POLICYVAL_MENCRYPT_REMOVABLE_USER_ALLOW 0x1

// This policy is used to determine if a bluetooth enabled device is allowed
// to be searched by other devices

#define SECPOLICY_BLUETOOTH                     0x1027

#define POLICYVAL_BLUETOOTH_VISIBLE_BLOCKED  0x0
#define POLICYVAL_BLUETOOTH_VISIBLE_ALLOWED  0x1

// This policy specifies whether message transports can handle HTML messages
// 0 - HTML message is disabled. Message is processed as plain text
// 1 - HTML message is enabled. 
#define SECPOLICY_HTML_MESSAGE                  0x1028

#define POLICYVAL_HTML_MESSAGE_DISABLED         0
#define POLICYVAL_HTML_MESSAGE_ENABLED          1

// This policy determines whether the Inbox app will send all messages 
// signed.
#define SECPOLICY_SMIMESIGNING                  0x1029

#define POLICYVAL_SMIMESIGNING_FORCED           0x00000000
#define POLICYVAL_SMIMESIGNING_OPTIONAL         0x00000001

// This policy determines whether the Inbox app will send all messages 
// encrypted.
#define SECPOLICY_SMIMEENCRYPTION               0x102A

#define POLICYVAL_SMIMEENCRYPTION_FORCED        0x00000000
#define POLICYVAL_SMIMEENCRYPTION_OPTIONAL      0x00000001

// This policy determines which algorithm will be used by the Inbox app 
// when a message is to be signed.
// Uses same value range specified for SECPOLICY_USESIGN policy.
// Algorithm specified by SECPOLICY_USESIGN overrides this policy.
#define SECPOLICY_SMIMESIGNINGALGORITHM         0x102B

#define POLICYVAL_SMIMESIGNINGALGORITHM_DEFAULT 0x00000000
#define POLICYVAL_SMIMESIGNINGALGORITHM_SHA_1   0x00000002
#define POLICYVAL_SMIMESIGNINGALGORITHM_MD5     0x00000003
#define POLICYVAL_SMIMESIGNINGALGORITHM_SHA_256 0x00000004
#define POLICYVAL_SMIMESIGNINGALGORITHM_SHA_384 0x00000005
#define POLICYVAL_SMIMESIGNINGALGORITHM_SHA_512 0x00000006

// This policy determines which algorithm will be used by the Inbox app 
// when a message is to be encrypted.
// Uses same value range specified for SECPOLICY_USEENCRYPT policy.
// Algorithm specified by SECPOLICY_USEENCRYPT overrides this policy.
#define SECPOLICY_SMIMEENCRYPTIONALGORITHM      0x102C

#define POLICYVAL_SMIMEENCRYPTIONALGORITHM_DEFAULT  0x00000000
#define POLICYVAL_SMIMEENCRYPTIONALGORITHM_3DES     0x00000002
#define POLICYVAL_SMIMEENCRYPTIONALGORITHM_DES      0x00000003
#define POLICYVAL_SMIMEENCRYPTIONALGORITHM_RC2_128  0x00000004
#define POLICYVAL_SMIMEENCRYPTIONALGORITHM_RC2_64   0x00000005
#define POLICYVAL_SMIMEENCRYPTIONALGORITHM_RC2_40   0x00000006
#define POLICYVAL_SMIMEENCRYPTIONALGORITHM_AES_128  0x00000007
#define POLICYVAL_SMIMEENCRYPTIONALGORITHM_AES_192  0x00000008
#define POLICYVAL_SMIMEENCRYPTIONALGORITHM_AES_256  0x00000009

// These policies replace SECPOLICY_WAPSIGNEDMSG
// These policies determine which origin roles are allowed for the various WAP authentication methods (NETWPIN, USERPIN/USERPINMAC and USERNETWPIN)
// Based on WAP authentication method, the message's role mask is AND-ed with the corresponding policy's role mask. 
// If the result is non-zero, the message is allowed for authentication

#define SECPOLICY_OMACPNETWPINMSG               0x102d
#define SECPOLICY_OMACPUSERPINMSG               0x102e
#define SECPOLICY_OMACPUSERNETWPINMSG           0x102f


// This policy determines if messaging can negotiate to another 
// encryption algorithm during SMIME encryption, if a recipient's 
// certificate is not supporting desired encryption algorithm. 
#define SECPOLICY_SMIMEENCRYPTIONNEGOTIATION    0x1030

#define POLICYVAL_SMIMEENCRYPTIONNEGOTIATION_NONE            0x00000000
#define POLICYVAL_SMIMEENCRYPTIONNEGOTIATION_ALLOWSTRONG     0x00000001
#define POLICYVAL_SMIMEENCRYPTIONNEGOTIATION_ALLOWALL        0x00000002
#define POLICYVAL_SMIMEENCRYPTIONNEGOTIATION_ALLOWAESONLY    0x00000003

// SECPOLICY_SHAREPOINTUNCPROTOCOLACCESS - so that IT admins can turn off
// sharepoint for devices but not OWA; also gives them an escape hatch if
// this turns out to be a bad user experience in some network environments.
#define SECPOLICY_SHAREPOINTUNCPROTOCOLACCESS   0x1031
#define POLICYVAL_SHAREPOINTUNCPROTOCOLACCESS_DISALLOW      0x00000000
#define POLICYVAL_SHAREPOINTUNCPROTOCOLACCESS_ALLOW         0x00000001


// This policy specifies how desktop should handle quick connect authentication.
// 0 - User must authenticate on device upon connect, if device lock is active.
// 1 - User can quick authenticate to the desktop
#define SECPOLICY_LASS_DESKTOP_QUICK_CONNECT             0x1032
 
#define POLICYVAL_LASS_DESKTOP_QUICK_CONNECT_DISALLOWED  0x0
#define POLICYVAL_LASS_DESKTOP_QUICK_CONNECT_ALLOWED     0x1

// Retrieve value of the specified security policy.
EXTERN_C HRESULT WINAPI QueryPolicy(DWORD dwPolicyId, __out PDWORD pdwPolicyValue);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\searchapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

#include <vrtldata.h>
#include <searchobj.h>
#include <searchguid.h>
#include <commctrl.h>
#include <datamodelschema.h>

///<file_doc_scope tref="datamodel" visibility="sdk"/>

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////////
//
// Helper APIs to manipulate virtual lists

///<topic name="vrtlistmanipulation" displayname="Virtual List Manipulation APIs">
///<summary>
///    APIs used to manipulate (e.g.: combine) virtual lists in various ways
///</summary>
///</topic>
///<topic_scope tref="vrtlistmanipulation">

///<summary>
///  <see cref="__LISTDESCRIPTOR"/>.pszDisplayName and
///  <see cref="__LISTDESCRIPTOR"/>.cchDisplayName contain valid data
///</summary>
#define LISTDESCVALID_DISPLAYNAME       0x0001

///<summary>
///  <see cref="__LISTDESCRIPTOR"/>.pszDisplayImage and
///  <see cref="__LISTDESCRIPTOR"/>.cchDisplayImage contain valid data
///</summary>
#define LISTDESCVALID_DISPLAYIMAGE      0x0002

///<summary>
///  <see cref="__LISTDESCRIPTOR"/>.clsid contains valid data
///</summary>
#define LISTDESCVALID_CLSID             0x0004

#define LISTDESCVALID_MASK              0x00FF

///<summary>
///  Describes properties for one single list and specifies how to combine it
///  with other lists.
///</summary>
///<seealso cref="ConcatenateVirtualLists"/>
typedef struct __LISTDESCRIPTOR
{
    ///<summary>
    ///  A combination of LISTDESCVALID_* flags
    ///</summary>
    DWORD dwFlags;

    ///<summary>
    ///  List to combine with others.
    ///  <para>
    ///    Must always be valid.
    ///  </para>
    ///</summary>
    IVirtualList *pList;

    ///<summary>
    ///  Display name for list.
    ///  <para>
    ///    Is valid when LISTDESCVALID_DISPLAYNAME is specified in dwFlags.
    ///  </para>
    ///  <para>
    ///    This will be used as the name displayed to represent the whole set of
    ///    items in pList.
    ///  </para>
    ///</summary>
    LPCTSTR pszDisplayName;

    ///<summary>
    ///  Number of characters in pszDisplayName, including NULL terminating character.
    ///  <para>
    ///    Is valid when LISTDESCVALID_DISPLAYNAME is specified in dwFlags.
    ///  </para>
    ///</summary>
    UINT cchDisplayName;

    ///<summary>
    ///  Display image for list
    ///  <para>
    ///    Is valid when LISTDESCVALID_DISPLAYIMAGE is specified in dwFlags.
    ///  </para>
    ///  <para>
    ///    This will be used as the image displayed to represent the whole set of
    ///    items in pList.
    ///  </para>
    ///</summary>
    LPCTSTR pszDisplayImage;

    ///<summary>
    ///  Number of characters in pszDisplayImage, including NULL terminating character.
    ///  <para>
    ///    Is valid when LISTDESCVALID_DISPLAYIMAGE is specified in dwFlags.
    ///  </para>
    ///</summary>
    UINT cchDisplayImage;

    ///<summary>
    ///  COM CLSID that uniquely identifies this list.
    ///  <para>
    ///    Not all lists will have a CLSID, so this member only contains valid
    ///    data if LISTDESCVALID_CLSID is specified in dwFlags.
    ///  </para>
    ///</summary>
    CLSID clsid;
} LISTDESCRIPTOR;

HRESULT ConcatenateVirtualLists(__in_ecount(cLists) LISTDESCRIPTOR *rgListDescriptors,
                                UINT cListDescriptors,
                                __deref_out IGroupedVirtualList **ppGroupedList);

///</topic_scope> vrtlistmanipulation


////////////////////////////////////////////////////////////////////////////////
//
// Data Model DLL initialization APIs

///<topic name="datamodeldll" displayname="Data Model DLL initialization APIs">
///<summary>
///  APIs used to initialize/uninitialize the datamodel DLL data.
///</summary>
///</topic>

HRESULT DatamodelInitialize();
HRESULT DatamodelUninitialize();

HRESULT DatamodelGetObjectCache(__deref_out IObjectCache** ppCache);

////////////////////////////////////////////////////////////////////////////////
//
// Data Model search APIs

///<topic name="datamodelsearch" displayname="Data Model Search APIs">
///<summary>
///    APIs used to find appropriate suppliers to service client
///    queries for relevant data.
///</summary>
///</topic>
///<topic_scope tref="datamodelsearch">

// Flags that control the behavior of GetMatchingItems APIs

///<summary>
///  Concatenate data coming from various data suppliers into one single list.
///</summary>
///<remarks>
///  If there are three suppliers: A, B and C then all the data from
///  supplier A will appear first, then the data from supplier B and
///  then the data from supplier C. The data coming from each supplier
///  will be sorted in the specified sort order
///</remarks>
///<seealso cref="ISearchQuery.GetMatchingItems"/>
///<seealso cref="DatamodelGetMatchingItems"/>
#define GMICOMBINE_CONCATENATE  0x0000

#define GMICOMBINE_MASK         0x000F


#undef INTERFACE
#define INTERFACE ISearchQuery

///<summary>
///  Statically represents a query (i.e., search query objects don't
///  actively search for data, but can instantiate supplier objects that do)
///  and allows addition or removal of data from query in various ways.
///</summary>
DECLARE_INTERFACE_(ISearchQuery, IUnknown)
{
    ///<summary>
    ///  Start query from a known, blank state representing no data
    ///</summary>
    ///<returns>
    ///  <para>
    ///    S_OK if query was cleared successfully
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    STDMETHOD(Clear)(THIS) PURE;

    ///<summary>
    ///  Add to query all suppliers registered to return data for specified category
    ///  and sub-categories
    ///</summary>
    ///<param name="pszResultCategory">
    ///  [in] Data category for which data will be added to query
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if category was successfully added to query.
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if <paramref name="pszResultCategory"/> is not a valid, already
    ///    registered data category.
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    ///<remarks>
    ///  If query does not change as a result of this addition, the method
    ///  call still succeeds.
    ///</remarks>
    STDMETHOD(AddResultCategory)(THIS_ __in LPCOLESTR pszResultCategory) PURE;

    ///<summary>
    ///  Remove from query all suppliers registered to return data for specified
    ///  category and sub-categories
    ///</summary>
    ///<param name="pszResultCategory">
    ///  [in] Data category for which data will be removed from query
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if category was successfully removed from query.
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if <paramref name="pszResultCategory"/> is not a valid, already
    ///    registered data category.
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    ///<remarks>
    ///  If query does not change as a result of this subtraction, the method
    ///  call still succeeds.
    ///</remarks>
    STDMETHOD(SubtractResultCategory)(THIS_ __in LPCOLESTR pszResultCategory) PURE;

    ///<summary>
    ///  Add specified supplier to query
    ///</summary>
    ///<param name="clsidSupplier">
    ///  [in] COM CLSID for supplier being added to query. COM object with this
    ///  CLSID must support the <see cref="IItemSupplier"/> interface
    ///  (IID_IItemSupplier).
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if supplier was successfully added to query.
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if <paramref name="clsidSupplier"/> does not represent
    ///    a registered COM CLSID.
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    ///<remarks>
    ///  If query does not change as a result of this addition (e.g., a supplier
    ///  with CLSID equal to <paramref name="clsidSupplier"/> was already included
    ///  in query), the method call still succeeds.
    ///</remarks>
    STDMETHOD(AddSupplier)(THIS_ __in REFCLSID clsidSupplier) PURE;

    ///<summary>
    ///  Remove specified supplier from query
    ///</summary>
    ///<param name="clsidSupplier">
    ///  [in] COM CLSID for supplier being removed from query.
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if supplier was successfully removed from query.
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    ///<remarks>
    ///  If query does not change as a result of this subtraction (e.g., no
    ///  supplier with CLSID equal to <paramref name="clsidSupplier"/> was found
    ///  in query), the method call still succeeds.
    ///</remarks>
    STDMETHOD(SubtractSupplier)(THIS_ __in REFCLSID clsidSupplier) PURE;

    ///<summary>
    ///  Specify an item to use as a template for query results
    ///</summary>
    ///<param name="pResultTemplate">
    ///  [in]Item representing restrictions placed on the data returned by
    ///  suppliers. E.g.: Date range (generally applicable), unread only
    ///  (applicable to message results), company equals "contoso" (applicable
    ///  to contacts results), etc.
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if template was successfully set
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    ///<remarks>
    ///  <para>
    ///    If <paramref name="pResultTemplate"/> is NULL, any previously set
    ///    template will be removed.
    ///  </para>
    ///  <para>
    ///    Success does not mean that the template has been applied successfully
    ///    to suppliers servicing query, since query does not instantiate suppliers
    ///    until call to <see cref="GetMatchingItems"/>.
    ///    Rather, it means that template has been successfully saved with query,
    ///    to be applied whenever suppliers are instantiated.
    ///  </para>
    ///  <para>
    ///    The template properties supported depend on the kind of data being
    ///    returned by suppliers, and only some data categories are guaranteed to
    ///    support templates (e.g.: contacts and messages). Please refer to the
    ///    documentation for the result category in question to understand what
    ///    kinds of templates it supports, and don't rely on template
    ///    functionality when querying for data in broad categories (e.g.: object)
    ///    that don't make explicit template guarantees.
    ///  </para>
    ///</remarks>
    STDMETHOD(SetResultTemplate)(THIS_ __in IItemTemplate *pResultTemplate) PURE;

    ///<summary>
    ///  Retrieve current result template for query, if any is set
    ///</summary>
    ///<param name="ppResultTemplate">
    ///  [out] Address to receive result template
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if template was successfully retrieved
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if <paramref name="ppResultTemplate"/> is NULL
    ///  </para>
    ///  <para>
    ///    E_NOT_FOUND if no result template was previously set on query
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    STDMETHOD(GetResultTemplate)(THIS_ __deref_out IItemTemplate **ppResultTemplate) PURE;

    ///<summary>
    ///  Specify a related item that all suppliers in query should apply.
    ///</summary>
    ///<param name="pRelatedItem">
    ///  [in, opt] Item that should be related to all results returned by query.
    ///  All suppliers in query should be registered to support the related
    ///  item's category as a search category
    ///  (See <see cref="SearchSupplier_RegisterCapability"/>).
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if search term was successfully set.
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if <paramref name="pRelatedItem"/>'s category is
    ///    not a valid, already registered data category.
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    ///<remarks>
    ///  <para>
    ///    If <paramref name="pRelatedItem"/> is NULL, any previously set related
    ///    item will be removed. This is equivalent to specifying a search
    ///    category of CATEGORYNAME_EMPTY.
    ///  </para>
    ///  <para>
    ///    Success does not mean that the related item has been applied
    ///    successfully to suppliers servicing query, since query does not
    ///    instantiate suppliers until call to <see cref="GetMatchingItems"/>.
    ///    Rather, it means that related item has been successfully saved
    ///    with query, to be applied whenever suppliers are instantiated.
    ///  </para>
    ///</remarks>
    STDMETHOD(SetRelatedItem)(THIS_ __in_opt ICategorizedVirtualItem *pRelatedItem) PURE;

    ///<summary>
    ///  Retrieve current related item for query, if any is set
    ///</summary>
    ///<param name="ppRelatedItem">
    ///  [out] Address to receive related item
    ///</param>
    ///<results>
    ///  <para>
    ///    S_OK if related item was successfully retrieved
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if <paramref name="ppRelatedItem"/> is NULL
    ///  </para>
    ///  <para>
    ///    E_NOT_FOUND if no related item was previously set on query
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</results>
    STDMETHOD(GetRelatedItem)(THIS_ __deref_out ICategorizedVirtualItem **ppRelatedItem) PURE;

    ///<summary>
    ///  Find and instantiate suppliers that will service query, combine their
    ///  data in the way specified and return one list containing the items
    ///  from all suppliers.
    ///</summary>
    ///<param name="dwFlags">
    ///  [in] Options specifying how items coming from various suppliers should be
    ///  returned. E.g.: GMICOMBINE_* flags
    ///</param>
    ///<param name="ppMatchingItemList">
    ///  [out] Address to receive list that aggregates data from suppliers in query.
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if items were successfully retrieved
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if <paramref name="ppMatchingItemList"/> is NULL
    ///  </para>
    ///  <para>
    ///    E_NOT_SUPPORTED if one or more of the options specified in
    ///    <paramref name="dwFlags"/> is not supported.
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    ///<remarks>
    ///  <para>
    ///    If any supplier instantiated to service the query didn't in fact succeed
    ///    when applying either the search term or result template specified (if any),
    ///    it will be disposed and its items will not appear in the query.
    ///  </para>
    ///  <para>
    ///    If <paramref name="dwFlags"/> is equal to GMICOMBINE_CONCATENATE, the
    ///    returned list *<paramref name="ppMatchingItemList"/> will support
    ///    QueryInterface for IID_IGroupedVirtualList interface.
    ///  </para>
    ///  <para>
    ///    LISTPROPID_ITEMCATEGORY is not supported for the returned list.
    ///    That is, calling
    ///    (*<paramref name="ppMatchingItemList"/>)->GetProperty(LISTPROPID_ITEMCATEGORY, &var)
    ///    is not guaranteed to return a valid property value.
    ///  </para>
    ///  <para>
    ///     The object returned through <paramref name="ppMatchingItemList"/> will be a proxy
    ///     for an actual supplier. Instead of loading the supplier before returning from this
    ///     function, this proxy will lazy-initialize the supplier the first time that a
    ///     client attempts to configure the supplier or retrieve data from it. If the
    ///     supplier can't be loaded, this function may succeed but then one of the following
    ///     data retrieval and/or configuration functions might fail with error code
    ///     E_SUPPLIERNOTLOADED whenever a proxy fails to lazy-initialize the supplier:
    ///       <list type="bullet">
    ///         <item>GetCount</item>
    ///         <item>GetItem</item>
    ///         <item>CacheItemsHint</item>
    ///         <item>GetVerbSource<item>
    ///         <item>GetProperty</item>
    ///         <item>ApplySort</item>
    ///         <item>RemoveSort</item>
    ///         <item>SetFilterString</item>
    ///         <item>SetRawFilterString</item>
    ///         <item>SetRelatedItem</item>
    ///         <item>SetResultTemplates</item>
    ///       </list>
    ///   </para>
    ///</remarks>
    STDMETHOD(GetMatchingItems)(THIS_ DWORD dwFlags,
                                __deref_out ISearchableVirtualList **ppMatchingItemList) PURE;

    ///<summary>
    ///  Return each supplier that can service query as a searchable list of items
    ///</summary>
    ///<param name="prgSupplierDescriptors">
    ///  [out] Address to hold array of supplier descriptors returned
    ///</param>
    ///<param name="pcSupplierDescriptors">
    ///  [out] Address to hold number of suppliers returned in array
    ///  <paramref name="prgSupplierDescriptors"/>
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if suppliers were retrieved successfully
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if either <paramref name="prgSupplierDescriptors"/> or
    ///    <paramref name="pcSupplierDescriptors"/> is NULL
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    ///<remarks>
    ///  <para>
    ///    If method was successful, caller should remember to free
    ///    <paramref name="prgSupplierDescriptors"/> after it no longer needs it, using
    ///    <see cref="FreeSuppliers"/> method.
    ///  </para>
    ///  <para>
    ///    Caller will be able to call 
    ///    (*prgSupplierDescriptors)[i].pList->QueryInterface(IID_ISearchableVirtualList, &punk)
    ///    successfully for all suppliers returned.
    ///    Suppliers are returned in <see cref="__LISTDESCRIPTOR"/>s in order to be
    ///    compatible with <see cref="ConcatenateVirtualLists"/>.
    ///  </para>
    ///  <para>
    ///    Each element of <paramref name="prgSupplierDescriptors"/> will have a valid value
    ///    for LISTPROPID_ITEMCATEGORY. That is, calling
    ///    (*<paramref name="prgSupplierDescriptors"/>)[i].pList->GetProperty(LISTPROPID_ITEMCATEGORY, &var)
    ///    should return a valid property value.
    ///  </para>
    ///  <para>
    ///     The IVirtualList objects returned through <paramref name="prgSupplierDescriptors"/>
    ///     will be proxies for the actual suppliers. Instead of loading the suppliers before
    ///     returning from this function, these proxies will lazy-initialize the suppliers the
    ///     first time that a client attempts to configure a supplier or retrieve data from it.
    ///     If a supplier can't be loaded, this function may succeed but then one of the
    ///     following data retrieval and/or configuration functions might fail with error code
    ///     E_SUPPLIERNOTLOADED whenever a proxy fails to lazy-initialize the supplier:
    ///       <list type="bullet">
    ///         <item>GetCount</item>
    ///         <item>GetItem</item>
    ///         <item>CacheItemsHint</item>
    ///         <item>GetVerbSource<item>
    ///         <item>GetProperty</item>
    ///         <item>ApplySort</item>
    ///         <item>RemoveSort</item>
    ///         <item>SetFilterString</item>
    ///         <item>SetRawFilterString</item>
    ///         <item>SetRelatedItem</item>
    ///         <item>SetResultTemplates</item>
    ///       </list>
    ///   </para>
    ///</remarks>
    STDMETHOD(GetMatchingSuppliers)(THIS_ __deref_out_ecount(*pcSupplierDescriptors) LISTDESCRIPTOR **prgSupplierDescriptors,
                                    __out UINT *pcSupplierDescriptors) PURE;

    ///<summary>
    ///  Free array of suppliers returned from <see cref="GetSuppliers"/>
    ///</summary>
    ///<param name="rgSupplierDescriptors">
    ///  [out] Array of suppliers to free
    ///</param>
    ///<param name="cSupplierDescriptors">
    ///  [out] Number of suppliers in array <paramref name="rgSupplierDescriptors"/>
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if suppliers were successfully freed
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if <paramref name="rgSupplierDescriptors"/> is NULL
    ///  </para>
    ///  <para>E_FAIL on unspecified error conditions</para>
    ///</returns>
    ///<seealso cref="GetMatchingSuppliers"/>
    STDMETHOD(FreeSuppliers)(THIS_ __in_ecount(cSupplierDescriptors) LISTDESCRIPTOR *rgSupplierDescriptors,
                             UINT cSupplierDescriptors) PURE;

};


/// <summary>
///   Find all suppliers that can service the specified search request
///   (related category/result item category combination)
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="pszRelatedCategory">
///   [in] related category for which search should be performed
/// </param>
/// <param name="pszResultCategory">
///   [in] Category of result items returned by the virtual lists
/// </param>
/// <param name="pcSuppliers">
///   [out] Number of suppliers returned in array <paramref name="prgpSuppliers"/>
/// </param>
/// <param name="prgpSuppliers">
///   [out] Array of suppliers that can do queries by specified related and 
///   result item category
/// </param>
/// <returns>
///   <para>
///     S_OK if applicable suppliers were retrieved successfully
///   </para>
///   <para>
///     E_INVALIDARG <paramref name="pcSuppliers"/> or
///     <paramref name="prgpSuppliers"/> are NULL.
///   </para>
///   <para>
///     Unspecified failure code otherwise
///   </para>
/// </returns>
/// <remarks>
///   <para>
///     If <paramref name="pszResultCategory"/> is NULL, its value will be used as
///     equivalent to CATEGORYNAME_EMPTY, which will result in zero lists being
///     returned.
///   </para>
///   <para>
///     Caller should free <paramref name="prgpSuppliers"/> using
///     SearchSession_FreeSearchableLists whenever it is done with array.
///   </para>
///   <para>
///     Internally, this API will use the datamodel cache (see 
///     <see cref="DatamodelGetObjectCache"/> to store objects meant to be reused
///     throughout an application, such as item supplier factories and item
///     inspectors. Whenever such an object is needed the datamodel APIs will
///     first look in object cache to determine whether it is already present
///     there. If it is present, then the object is reused but if it is not
///     present then a new object will be created and stored in cache.
///   </para>
///   <para>
///     Each element of <paramref name="prgpSuppliers"/> will have a valid value
///     for LISTPROPID_ITEMCATEGORY. That is, calling
///     (*<paramref name="prgpSuppliers"/>)[i]->GetProperty(LISTPROPID_ITEMCATEGORY, &var)
///     should return a valid property value.
///   </para>
///   <para>
///     The objects returned through <paramref name="prgpSuppliers"/> will be proxies for
///     the actual suppliers. Instead of loading the suppliers before returning from this
///     function, these proxies will lazy-initialize the suppliers the first time that a
///     client attempts to configure a supplier or retrieve data from it. If a supplier
///     can't be loaded, this function may succeed but then one of the following data
///     retrieval and/or configuration functions might fail with error code
///     E_SUPPLIERNOTLOADED whenever a proxy fails to lazy-initialize the supplier:
///       <list type="bullet">
///         <item>GetCount</item>
///         <item>GetItem</item>
///         <item>CacheItemsHint</item>
///         <item>GetVerbSource<item>
///         <item>GetProperty</item>
///         <item>ApplySort</item>
///         <item>RemoveSort</item>
///         <item>SetFilterString</item>
///         <item>SetRawFilterString</item>
///         <item>SetRelatedItem</item>
///         <item>SetResultTemplates</item>
///       </list>
///   </para>
/// </remarks>
HRESULT DatamodelGetSearchableLists(
               __in LPCOLESTR pszRelatedCategory,
               __in LPCOLESTR pszResultCategory,
               __out UINT *pcSuppliers,
               __deref_out_ecount(*pcSuppliers) ISearchableVirtualList ***prgpSuppliers);

/// <summary>
///     Free an array of suppliers allocated by the Search Session API
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="cSuppliers">
///     Number of suppliers in array to free
/// </param>
/// <param name="rgpsvlSuppliers">
///     Array of suppliers to free
/// </param>
/// <returns>
///     <para>
///         S_OK if suppliers array was freed successfully
///     </para>
///     <para>
 ///         E_INVALIDARG if <paramref name="rgpsvlSuppliers"/> is NULL when
 ///         <paramref name="cSuppliers"/> is greater than zero.
///     </para>
/// </returns>
HRESULT DatamodelFreeSearchableLists(__in UINT cSuppliers,
                                     __in_ecount(cSuppliers) ISearchableVirtualList **rgpsvlSuppliers);

/// <summary>
///   Find all suppliers that can service the specified search request
///   (related/result item category combination)
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="pRelatedItem">
///   [in, opt] related. All suppliers instantiated to serve this request
///   should support the related's category.
///   (See <see cref="SearchSupplier_RegisterCapability"/>).
///   If <paramref name="pRelatedItem"/> is NULL, CATEGORYNAME_EMPTY will be
///   assumed.
/// </param>
/// <param name="pszResultCategory">
///   [in] Result item category that all suppliers instantiated to serve this request
///   should support. (See <see cref="SearchSupplier_RegisterCapability"/>).
/// </param>
/// <param name="dwFlags">
///   [in] Options specifying how items coming from various suppliers should be
///   returned. E.g.: GMICOMBINE_* flags
/// </param>
/// <param name="ppMatchingItemList">
///   [out] Address to receive list that aggregates data from suppliers that can
///   service this request.
/// </param>
/// <returns>
///   <para>
///     S_OK if applicable suppliers were retrieved successfully
///   </para>
///   <para>
///     E_INVALIDARG if <paramref name="pszResultCategory"/> or 
///     <paramref name="ppMatchingItemList"/> are NULL.
///   </para>
///   <para>
///     E_NOT_SUPPORTED if one or more of the options specified in
///     <paramref name="dwFlags"/> is not supported.
///   </para>
///     <para>
///       E_NOTFOUND if no items were found that matched the criteria
///     </para>
///   <para>E_FAIL on unspecified error conditions</para>
/// </returns>
/// <remarks>
///   <para>
///     Internally, this API will use the datamodel cache (see 
///     <see cref="DatamodelGetObjectCache"/> to store objects meant to be reused
///     throughout an application, such as item supplier factories and item
///     inspectors. Whenever such an object is needed the datamodel APIs will
///     first look in object cache to determine whether it is already present
///     there. If it is present, then the object is reused but if it is not
///     present then a new object will be created and stored in cache.
///   </para>
///   <para>
///     If <paramref name="dwFlags"/> is equal to GMICOMBINE_CONCATENATE, the
///     returned list *<paramref name="ppMatchingItemList"/> will support
///     QueryInterface for IID_IGroupedVirtualList interface.
///   </para>
///   <para>
///     LISTPROPID_ITEMCATEGORY is not supported for the returned list.
///     That is, calling
///     (*<paramref name="ppMatchingItemList"/>)->GetProperty(LISTPROPID_ITEMCATEGORY, &var)
///     is not guaranteed to return a valid property value.
///   </para>
///   <para>
///     The object returned through <paramref name="ppMatchingItemList"/> will be a proxy
///     for an actual supplier. Instead of loading the supplier before returning from this
///     function, this proxy will lazy-initialize the supplier the first time that a
///     client attempts to configure the supplier or retrieve data from it. If the
///     supplier can't be loaded, this function may succeed but then one of the following
///     data retrieval and/or configuration functions might fail with error code
///     E_SUPPLIERNOTLOADED whenever a proxy fails to lazy-initialize the supplier:
///       <list type="bullet">
///         <item>GetCount</item>
///         <item>GetItem</item>
///         <item>CacheItemsHint</item>
///         <item>GetVerbSource<item>
///         <item>GetProperty</item>
///         <item>ApplySort</item>
///         <item>RemoveSort</item>
///         <item>SetFilterString</item>
///         <item>SetRawFilterString</item>
///         <item>SetRelatedItem</item>
///         <item>SetResultTemplates</item>
///       </list>
///   </para>
/// </remarks>
HRESULT DatamodelGetMatchingItems(__in_opt ICategorizedVirtualItem *pRelatedItem,
                                  __in LPCOLESTR pszResultCategory,
                                  DWORD dwFlags, 
                                  __deref_out ISearchableVirtualList **ppMatchingItemList);

/// <summary>
///   Create a query object that can be used to add and remove items or entire
///   suppliers from the result set in various ways.
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="ppQuery">
///   [out] Address to receive query object
/// </param>
/// <returns>
///   <para>
///     S_OK if query was created successfully
///   </para>
///   <para>
///     E_INVALIDARG if <paramref name="ppQuery"/> is NULL.
///   </para>
///   <para>E_FAIL on unspecified error conditions</para>
/// </returns>
/// <remarks>
///   <para>
///     Internally, this API will use the datamodel cache (see 
///     <see cref="DatamodelGetObjectCache"/> to store objects meant to be reused
///     throughout an application, such as item supplier factories and item
///     inspectors. Whenever such an object is needed the datamodel APIs will
///     first look in object cache to determine whether it is already present
///     there. If it is present, then the object is reused but if it is not
///     present then a new object will be created and stored in cache.
///   </para>
/// </remarks>
HRESULT DatamodelCreateQuery(__deref_out ISearchQuery **ppQuery);

// These APIs to interact with object cache are added for convenience

/// <summary>
///     Explicitly add a class factory to object cache
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="pCache">
///   [in, opt] Object Cache. If NULL, the default datamodel object cache will be
///   used.
/// </param>
/// <param name="rclsidSupplier">
///   [in] CLSID used to identify class factory being cached
/// </param>
/// <param name="pclsfactSupplier">
///   [in] Class factory being cached
/// </param>
/// <returns>
///     <para>
///         S_OK if <paramref name="pclsfactSupplier"/> was added successfully to cache.
///         If so, AddRef will be called on the object.
///     </para>
///     <para>
///         E_INVALIDARG if <paramref name="pclsfactSupplier"/> is NULL
///     </para>
///     <para>
///         E_ALREADYEXISTS if <paramref name="rclsidSupplier"/> already has a
///         cached class factory.
///     </para>
/// </returns>
/// <remarks>
///     <para>
///         This function is meant to enable application writers to make suppliers available
///         for querying from any particular object cache even if the suppliers are not
///         fully COM registered.
///     </para>
///     <para>
///         This is particularly useful for testing and also for other cases where we might
///         have multiple dynamically populated search lists that are all really implemented
///         by the same class underneath, but we want to be able to list their contents
///         separately.
///     </para>
///     <para>
///         For example, if we have "CSimpleList", which implements both IClassFactory and
///         ISearchableVirtualList, and we want some quick and dirty in-memory lists it is
///         simpler to just
///         <list>
///             <item>
///                 Create a few instances of CSimpleList in memory
///             </item>
///             <item>
///                 Populate each instance with different data
///             </item>
///             <item>
///                 Add each instance to the cache so that subsequent calls to
///                 SearchSession_GetSearchableLists can use these instances directly,
///                 with the same in-memory data
///             </item>
///         </list>
///         
///         instead of having a different class called CRegisteredList
///         
///         <list>
///             <item>
///                 Create a few instances of CRegisteredList
///             </item>
///             <item>
///                 Populate each instance with different data
///             </item>
///             <item>
///                 Make the data populated into each instance separately available to
///                 class factories created from different CLSIDs through CoGetClassObject,
///                 which requires implementing some form of data persistence instead of
///                 just keeping in-memory data.
///             </item>
///         </list>
///     </para>
/// </remarks>
HRESULT DatamodelAddFactoryToCache(__in_opt IObjectCache *pCache,
                                   REFCLSID rclsidSupplier,
                                   __in IClassFactory *pclsfactSupplier);

/// <summary>
///     Explicitly remove a class factory from object cache
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="pCache">
///   [in, opt] Object Cache. If NULL, the default datamodel object cache will be
///   used.
/// </param>
/// <param name="rclsidSupplier">
///   [in] CLSID used to identify class factory to remove
/// </param>
/// <returns>
///     <para>
///         S_OK if factory was successfully removed from cache.
///         If so, Release will be called on the object.
///     </para>
///     <para>
///         E_NOTFOUND if <paramref name="rclsidSupplier"/> does not represent
///         a factory currently being cached.
///     </para>
/// </returns>
HRESULT DatamodelRemoveFactoryFromCache(__in_opt IObjectCache *pCache,
                                        REFCLSID rclsidSupplier);

/// <summary>
///     Explicitly add a data item inspector to object cache
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="pCache">
///   [in, opt] Object Cache. If NULL, the default datamodel object cache will be
///   used.
/// </param>
/// <param name="pszItemCategory">
///   [in] Item category name used to identify item inspector being cached
/// </param>
/// <param name="pinspectorCategory">
///   [in] Item inspector being cached
/// </param>
/// <returns>
///     <para>
///         S_OK if <paramref name="pinspectorCategory"/> was added successfully to cache.
///         If so, AddRef will be called on the object.
///     </para>
///     <para>
///         E_INVALIDARG if <paramref name="pinspectorCategory"/> is NULL
///     </para>
///     <para>
///         E_ALREADYEXISTS if <paramref name="pszItemCategory"/> already has an
///         associated item inspector cached.
///     </para>
/// </returns>
/// <remarks>
///     <para>
///         This function is meant to enable application writers to make item
///         inspectors available for querying from any particular object cache
///         even if the inspectors are not fully COM registered.
///     </para>
/// </remarks>
HRESULT DatamodelAddInspectorToCache(__in_opt IObjectCache *pCache,
                                     __in LPCTSTR pszItemCategory,
                                     __in IItemInspector *pinspectorCategory);

/// <summary>
///     Explicitly remove a data item inspector from object cache
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="pCache">
///   [in, opt] Object Cache. If NULL, the default datamodel object cache will be
///   used.
/// </param>
/// <param name="pszItemCategory">
///   [in] Item category name used to identify item inspector to remove
/// </param>
/// <returns>
///     <para>
///         S_OK if inspector was successfully removed from cache.
///         If so, Release will be called on the object.
///     </para>
///     <para>
///         E_NOTFOUND if <paramref name="pszItemCategory"/> does not represent
///         an inspector currently being cached.
///     </para>
/// </returns>
HRESULT DatamodelRemoveInspectorFromCache(__in_opt IObjectCache *pCache,
                                          __in LPCTSTR pszItemCategory);

///</topic_scope> datamodelsearch


////////////////////////////////////////////////////////////////////////////////
//
// Data Category APIs

///<topic name="datacatreg" displayname="Data Category Registration">
///<summary>
///  APIs used to register and query for global data categories and data
///  category properties, to enable system-wide context sensitivity
///</summary>
///</topic>
///<topic_scope tref="datacatreg">


HRESULT DataCategory_Register(__in LPCTSTR pszCategory);

HRESULT DataCategory_Remove(__in LPCTSTR pszCategory);

HRESULT DataCategory_Exists(__in LPCTSTR pszCategory, __out BOOL *pfExists);

HRESULT DataCategory_SetDisplayName(__in LPCTSTR pszCategory,
                                    __in_bcount(cbDisplayName) LPCTSTR szDisplayName,
                                    UINT cbDisplayName);

HRESULT DataCategory_GetDisplayName(__in LPCTSTR pszCategory,
                                    __out_bcount(*pcbDisplayName) LPTSTR szDisplayName,
                                    UINT *pcbDisplayName);

HRESULT DataCategory_SetDefaultIcon(__in LPCTSTR pszCategory,
                                    __in_bcount(cbDefaultIcon) LPCTSTR szDefaultIcon,
                                    UINT cbDefaultIcon);

HRESULT DataCategory_GetDefaultIcon(__in LPCTSTR pszCategory,
                                    __out_bcount(*pcbDefaultIcon) LPTSTR szDefaultIcon,
                                    UINT *pcbDefaultIcon);

HRESULT DataCategory_AddDirectSuperCategory(__in LPCTSTR pszCategory,
                                            __in LPCTSTR pszSuperCategory);

HRESULT DataCategory_RemoveDirectSuperCategory(__in LPCTSTR pszCategory,
                                               __in LPCTSTR pszSuperCategory);

HRESULT DataCategory_IsSuperCategory(__in LPCTSTR pszCategory, __in LPCTSTR pszSuperCategory,
                                     __out BOOL *pfIsSuper);

HRESULT DataCategory_AreEqual(__in LPCTSTR pszCategory, __in LPCTSTR pszOtherCategory,
                              __out BOOL *pfAreEqual);

///</topic_scope> datacatreg

////////////////////////////////////////////////////////////////////////////////
//
// Search Supplier APIs

///<topic name="supplierreg" displayname="Search Supplier Registration">
///<summary>
///    APIs used to register and query for search supplier capabilities,
///    which are the core of the Association Engine's value
///</summary>
///</topic>

///<topic_scope tref="supplierreg">

// Supplier does not implement string filtering and datamodel should provide
// default support
#define SUPPLIERCAPABILITYFLAG_STRINGFILTERING_DEFAULT  0x00000000

// Supplier has a custom implementation of string filtering, so datamodel should
// not provide default support
#define SUPPLIERCAPABILITYFLAG_STRINGFILTERING_CUSTOM   0x00000001

// Supplier does not implement string filtering and doesn't want datamodel to
// provide default support
#define SUPPLIERCAPABILITYFLAG_STRINGFILTERING_NONE     0x00000002

// Bit mask for string filtering capability flags
#define SUPPLIERCAPABILITYFLAG_STRINGFILTERING_MASK     0x0000000F

///<summary>
///   Represents a registered supplier capablity
///</summary>
typedef struct _SUPPLIERCAPABILITY
{
    ///<summary>Supplier CLSID</summary>
    CLSID clsidSupplier;
    ///<summary>
    ///  String representing Supplier CLSID
    ///  <para>
    ///    This as well as the actual CLSID for the supplier is initialized
    ///    because clients often will need this string version, and this
    ///    saves clients the extra work of recomputing this.
    ///  </para>
    ///</summary>
    LPTSTR pszClsidSupplier;
    ///<summary>Related category for capability</summary>
    LPTSTR pszRelatedCategory;
    ///<summary>result item category for capability</summary>
    LPTSTR pszResultCategory;
    ///<summary>
    ///  Flags that specify supplier characteristics. Can be one of the following:
    ///  <list type="table">
    ///    <item>
    ///      <term>SUPPLIERCAPABILITYFLAG_STRINGFILTERING_DEFAULT</term>
    ///      <description>
    ///        Supplier does not implement string filtering and datamodel should
    ///        provide default support
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>SUPPLIERCAPABILITYFLAG_STRINGFILTERING_CUSTOM</term>
    ///      <description>
    ///        Supplier has a custom implementation of string filtering, so
    ///        datamodel should not provide default support
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>SUPPLIERCAPABILITYFLAG_STRINGFILTERING_NONE</term>
    ///      <description>
    ///        Supplier does not implement string filtering and doesn't want
    ///        datamodel to provide default support
    ///      </description>
    ///    </item>
    ///  </list>
    ///</summary>
    DWORD dwFlags;
} SUPPLIERCAPABILITY;

/// <summary>
///     Add a new supplier capability to the system
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="rclsidSupplier">
///     [IN]CLSID of supplier to which capability applies
/// </param>
/// <param name="pszRelatedCategory">
///     [IN]related category of capability
/// </param>
/// <param name="pszResultItemCategory">
///     [IN]Result item category of capability
/// </param>
/// <param name="dwFlags">
///   Flags that specify supplier characteristics. Can be one of the following:
///   <list type="table">
///     <item>
///       <term>SUPPLIERCAPABILITYFLAG_STRINGFILTERING_DEFAULT</term>
///       <description>
///         Supplier does not implement string filtering and datamodel should
///         provide default support
///       </description>
///     </item>
///     <item>
///       <term>SUPPLIERCAPABILITYFLAG_STRINGFILTERING_CUSTOM</term>
///       <description>
///         Supplier has a custom implementation of string filtering, so
///         datamodel should not provide default support
///       </description>
///     </item>
///     <item>
///       <term>SUPPLIERCAPABILITYFLAG_STRINGFILTERING_NONE</term>
///       <description>
///         Supplier does not implement string filtering and doesn't want
///         datamodel to provide default support
///       </description>
///     </item>
///   </list>
///   <para>
///     Specifying 0 (zero) for this parameter will always result in the default
///     behavior.
///   </para>
/// </param>
/// <returns>
///     <para>
///         S_OK if capability registration was successful
///     </para>
///     <para>
///         E_INVALIDARG if <paramref name="pszResultItemCategory"/> is NULL or
///         equal to CATEGORYNAME_EMPTY, if either
///         <paramref name="pszRelatedCategory"/> or
///         <paramref name="pszResultItemCategory"/> are equal to CATEGORYNAME_OBJECT
///         or if either <paramref name="pszRelatedCategory"/> or
///         <paramref name="pszResultItemCategory"/> are not registered yet.
///     </para>
///     <para>
///         E_NOTSUPPORTED if <paramref name="dwFlags"/> includes unsupported flag
///         values.
///     </para>
///     <para>
///         E_ALREADYEXISTS if specified capability is already registered for
///         <paramref name="rclsidSupplier"/>
///     </para>
/// </returns>
/// <remarks>
///     <para>
///         Creates an association between the related category and the
///         result item category specified, in which the supplier represented
///         by <paramref name="rclsidSupplier"/> advertises that it is capable
///         of returning items of category <paramref name="pszResultItemCategory"/>
///         in response to searches done starting from a related of
///         category <paramref name="pszRelatedCategory"/>
///     </para>
///     <para>
///         NULL related categories are valid input and are equivalent to
///         specifying CATEGORYNAME_EMPTY. This means that supplier being registered
///         is capable or returning a context-less list of items (i.e., a list of
///         items with no associated related item). However, a supplier can't
///         register itself to return NULL or CATEGORYNAME_EMPTY results because
///         that would mean that the supplier can never return any results, which
///         would not be a valuable registered supplier.
///     </para>
/// </remarks>
HRESULT SearchSupplier_RegisterCapability(__in REFCLSID rclsidSupplier,
                                          __in LPCTSTR pszRelatedCategory,
                                          __in LPCTSTR pszResultItemCategory,
                                          DWORD dwFlags);

/// <summary>
///     Remove a supplier capability from the system (can remove all capabilities
///     at once from one single supplier)
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="rclsidSupplier">
///     [IN]CLSID of supplier from which to remove the capability
/// </param>
/// <param name="pszRelatedCategory">
///     [IN]related category of capability to remove
/// </param>
/// <param name="pszResultItemCategory">
///     [IN]Result item category of capability to remove
/// </param>
/// <returns>
///     <para>
///         S_OK if capability removal was successful
///     </para>
///     <para>
///         E_INVALIDARG if <paramref name="rclsidSupplier"/>
///         is NULL
///     </para>
///     <para>
///         E_DOESNOTEXIST if <paramref name="rclsidSupplier"/> is not
///         registered or if no registered capabilities match the specified
///         capability parameters
///     </para>
/// </returns>
/// <remarks>
///     <para>
///         If <paramref name="pszResultItemCategory"/> is NULL, then all
///         capabilities with related category as specified in
///         <paramref name="pszRelatedCategory"/> will be removed.
///     </para>
///     <para>
///         If <paramref name="pszRelatedCategory"/> is NULL, then all
///         capabilities with result item category as specified in
///         <paramref name="pszResultItemCategory"/> will be removed.
///     </para>
///     <para>
///         If both <paramref name="pszRelatedCategory"/> and
///         <paramref name="pszResultItemCategory"/> are NULL, then all
///         capabilities for specified supplier are removed.
///     </para>
///     <para>
///         If a capability involving the "empty" category wants to be removed
///         it needs to be explicitly specified as "empty", since a NULL
///         value for <paramref name="pszRelatedCategory"/> will result in
///         the deletion of all capabilities with specified result item
///         category.
///     </para>
/// </remarks>
HRESULT SearchSupplier_RemoveCapability(__in REFCLSID rclsidSupplier,
                                        __in LPCTSTR pszRelatedCategory,
                                        __in LPCTSTR pszResultItemCategory);

/// <summary>
///     Return all supplier capabilities that support capabilities where the search
///     ternm data category is a supercategory of the specified filter data category
///     and the result item category for the same capability is a subcategory of the
///     specified result data category
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="pszRelatedCategory">
///     [IN]related category by which supplier capabilities will be matched
/// </param>
/// <param name="pszResultItemCategory">
///     [IN]Result item category by which supplier capabilities will be matched
/// </param>
/// <param name="pcCapabilities">
///     [OUT] Number of supplier capabilities returned in array
///     <paramref name="prgscapCapabilities"/>
/// </param>
/// <param name="prgscapCapabilities">
///     [OUT] Array of supplier capabilities that can do queries by specified result
///     item category
/// </param>
/// <returns>
///     <para>
///         S_OK if applicable supplier capabilities were retrieved successfully
///     </para>
///     <para>
///         E_INVALIDARG if <paramref name="pcCapabilities"/> or
///         <paramref name="prgscapCapabilities"/> are NULL.
///     </para>
/// </returns>
/// <remarks>
///     <para>
///       If <paramref name="pszRelatedCategory"/> is NULL, its value will be used as
///       equivalent to CATEGORYNAME_EMPTY.
///     </para>
///     <para>
///       If <paramref name="pszResultItemCategory"/> is NULL, its value will be used as
///       equivalent to CATEGORYNAME_EMPTY, which will result in zero suppliers
///       being returned.
///     </para>
///     <para>
///       If <paramref name="pszRelatedCategory"/> or
///       <paramref name="pszResultItemCategory"/> represent unrecognized category
///       names, zero suppliers will be returned but function will not report failure.
///     </para>
///     <para>
///       Caller should free <paramref name="prgscapCapabilities"/> using
///       SearchSupplier_FreeCapabilityArray whenever it is done with array.
///     </para>
/// </remarks>
HRESULT SearchSupplier_GetByCapabilities(__in LPCTSTR pszRelatedCategory,
                                         __in LPCTSTR pszResultItemCategory,
                                         __out UINT *pcCapabilities,
                                         __deref_out_ecount(*pcCapabilities) SUPPLIERCAPABILITY **prgscapCapabilities);

/// <summary>
///     Free an array of supplier capabilities allocated by the Search Supplier API
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="cCapabilities">
///     Number of suppliers in array to free
/// </param>
/// <param name="rgscapCapabilities">
///     Array of supplier capabilities to free
/// </param>
/// <returns>
///     <para>
///         S_OK if supplier capabilities array was freed successfully
///     </para>
///     <para>
///         E_INVALIDARG if <paramref name="rgscapCapabilities"/> is NULL
///         when <paramref name="cCapabilities"/> is greater than zero
///     </para>
/// </returns>
HRESULT SearchSupplier_FreeCapabilityArray(__in UINT cCapabilities,
                                           __in_ecount(cCapabilities) SUPPLIERCAPABILITY *rgscapCapabilities);

///</topic_scope> supplierreg


///<topic name="supplierproxy" displayname="Supplier Proxy">
///<summary>
///  Proxy object used by AE to wrap around the actual supplier implementation and
///  provide added value such as threading and object cache association.
///</summary>
///</topic>
///<topic_scope tref="supplierproxy">

#undef INTERFACE
#define INTERFACE ISupplierWrapper

//$TODO: Consider either:
//$TODO: (a) making ISupplierWrapper private or
//$TODO: (b) expanding its interface to be more widely useful

///<summary>
///  Object that wraps a supplier object
///</summary>
///<seealso cref="SupplierProxy_CreateInstance"/>
DECLARE_INTERFACE_(ISupplierWrapper, IUnknown)
{
    /// <summary>
    ///   Retrieve supplier wrapped by this object
    /// </summary>
    /// <param name="ppSupplier">
    ///   [out] Address to receive pointer to wrapped supplier
    /// </param>
    /// <returns>
    ///   <para>S_OK on success</para>
    ///   <para>
    ///     E_INVALIDARG if <paramref name="ppSupplier"/> is NULL
    ///   </para>
    ///   <para>
    ///     E_NOT_FOUND if no supplier is associated with object
    ///   </para>
    /// </returns>
    STDMETHOD(GetWrappedSupplier)(THIS_ __deref_out IItemSupplier **ppSupplier) PURE;
};


// Maximum time interval between supplier proxy change updates when there are
// changes pending is 400 milliseconds
#define CUITIME_UPDATE_INTERVAL 400

// Maximum item difference between supplier proxy change updates when there are
// changes pending
#define CUIITEMS_UPDATE_INTERVAL 100


/// <summary>
///     Create an instance of our CSupplierProxy implementation
///     from the specified supplier and object cache
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="pSupplier">
///     [in] Supplier to wrap with the proxy
/// </param>
/// <param name="pCache">
///     [in] Object Cache for the proxy to use
/// </param>
/// <param name="ppsvlSupplierProxy">
///     [out] Address to receive the supplier proxy
/// </param>
/// <returns>
///     <para>
///         S_OK if successful
///     </para>
///     <para>
///         E_INVALIDARG if <paramref name="pSupplier"/> or
///         <paramref name="ppsvlSupplierProxy"/> are NULL
///     </para>
///     <para>
///         E_FAIL on unspecified error conditions
///     </para>
/// </returns>
HRESULT SupplierProxy_CreateInstance(__in IItemSupplier *pSupplier,
                                     __in IObjectCache *pCache,
                                     __deref_out ISearchableVirtualList **ppsvlSupplierProxy);

/// <summary>
///     Create an instance of our supplier proxy implementation
///     from the specified supplier CLSID and object cache
/// </summary>
/// <doc_scope visibility="sdk"/>
/// <param name="clsidSupplier">
///     [in] CLSID that names an object that supports the IID_IItemSupplier
///     interface.
/// </param>
/// <param name="pCache">
///     [in] Object Cache for the proxy to use
/// </param>
/// <param name="ppsvlSupplierProxy">
///     [out] Address to receive the supplier proxy
/// </param>
/// <returns>
///     <para>
///         S_OK if successful
///     </para>
///     <para>
///         E_INVALIDARG if <paramref name="ppsvlSupplierProxy"/> is NULL
///     </para>
///     <para>
///         E_FAIL on unspecified error conditions
///     </para>
/// </returns>
HRESULT SupplierProxy_CreateInstanceFromCLSID(REFCLSID clsidSupplier,
                                              __in IObjectCache *pCache,
                                              __deref_out ISearchableVirtualList **ppsvlSupplierProxy);

///</topic_scope> supplierproxy

////////////////////////////////////////////////////////////////////////////////
//
// Data item default implementation

///<topic name="dataitem" displayname="Data Item Default Implementation">
///<summary>
///    Default Association Engine implementation of ICategorizedDataItem interface,
///    and also APIs for instantiating a data item object
///</summary>
///</topic>

///<topic_scope tref="dataitem">

#undef INTERFACE
#define INTERFACE IDisposable

///<summary>
///  Lightweight object that encapsulates a resource that should be explicitly disposed
///</summary>
///<remarks>
///  Unlike <see cref="IUnknown"/>, IDisposable objects are not refcounted. The disposable
///  resource is released the first time that <see cref="IDisposable.Dispose"/> is called.
///</remarks>
DECLARE_INTERFACE(IDisposable) 
{
    ///<summary>
    ///  Disposes/Releases/frees the resource(s) encapsulated by this object, and itself.
    ///</summary>
    ///<returns>
    ///  <para>
    ///    S_OK if resource was successfully disposed
    ///  </para>
    ///  <para>
    ///    Unspecified failure code otherwise.
    ///  </para>
    ///</returns>
    ///<remarks>
    ///  It is not valid to call this method more than once, because the first time that it is
    ///  called it will result in the disposal of the resources being encapsulated by object
    ///  as well as the destruction of the IDisposable object itself.
    ///</remarks>
    STDMETHOD(Dispose)(THIS) PURE;
};

class DisposeProcessHeapMemory : public IDisposable
{
private:
    LPVOID m_pMem;
    HANDLE m_hHeap;

public:
    /////////////////////////////////
    // Constructor
    DisposeProcessHeapMemory()
    {
        m_hHeap = GetProcessHeap();
        m_pMem = NULL;
    }

    /////////////////////////////////
    // Initialize
    void Initialize(LPVOID pMem)
    {
        m_pMem = pMem;
    }

    /////////////////////////////////
    // IDisposable members
    STDMETHODIMP Dispose()
    {
        if ((NULL != m_pMem) && (NULL != m_hHeap))
        {        
            HeapFree(m_hHeap, 0, m_pMem);
        }

        delete this;

        return S_OK;
    }
};

#undef INTERFACE
#define INTERFACE IDataItemBulkOperations

///<summary>
///  Used to retrieve or modify many data item properties at once
///</summary>
DECLARE_INTERFACE_(IDataItemBulkOperations, IDataItem)
{
    /// <summary>
    ///   Set the specified property values on item
    /// </summary>
    /// <param name="rgdwPropertyIDs">
    ///   [in] Array of property IDs to set
    /// </param>
    /// <param name="rgPropertyValues">
    ///   [in] Array of property values to set
    /// </param>
    /// <param name="cProperties">
    ///   [in] Number of elements in <paramref name="rgdwPropertyIDs"/> and
    ///   <paramref name="rgPropertyValues"/> arrays
    /// </param>
    /// <param name="pPropertyData">
    ///   [in] Object used to dispose of all the allocated resources (memory, files, etc.) used
    ///   by the property values specified in <paramref name="rgPropertyValues"/>.
    /// </param>
    /// <returns>
    ///   <para>
    ///     S_OK if properties were set successfully
    ///   </para>
    ///   <para>
    ///     E_INVALIDARG if <paramref name="rgdwPropertyIDs"/> is NULL,
    ///     if <paramref name="rgPropertyValues"/> is NULL or if
    ///     <paramref name="cProperties"/> is zero.
    ///   </para>
    ///   <para>
    ///     Unspecified failure code otherwise
    ///   </para>
    /// </returns>
    /// <remarks>
    ///   <para>
    ///     If the variant type of one of the elements of <paramref name="rgPropertyValues"/>
    ///     array is VT_ERROR and the PROPVARIANT.scode is equal to E_NOTFOUND, this function
    ///     negatively caches the fact that this property was not found.
    ///   </para>
    ///   <para>
    ///     This function does not provide a way to completely remove all cached information
    ///     (i.e., removing caches of both positive and negative information) for a specific
    ///     property ID. A client has the option of removing individual properties through
    ///     <see cref="IDataItem.SetProperty"/>(NULL) or to release all properties through
    ///     <see cref="IUnknown.Release"/>.
    ///   </para>
    ///   <para>
    ///     If <paramref name="pPropertyData"/> is NULL, this function will result in
    ///     the same behavior as calling SetProperty multiple times in a row, with the
    ///     item copying PROPVARIANT data as appropriate, so it can own the memory
    ///     used to store this data.
    ///   </para>
    ///   <para>
    ///     If <paramref name="pPropertyData"/> is non-NULL, this function will not
    ///     allocate new PROPVARIANT data, but will only allocate new PROPVARIANT
    ///     elements that only keep a reference of the real data passed in by caller.
    ///     In this case, caller needs to completely rescind ownership of the
    ///     PROPVARIANT memory being handed to item, and guarantee that the data
    ///     will only be freed when the item itself calls <paramref name="pPropertyData"/>.Dispose
    ///   </para>
    ///   <para>
    ///     Also when <paramref name="pPropertyData"/> is non-NULL, the item will
    ///     take care of calling <paramref name="pPropertyData"/>.Dispose even in case of failure
    ///     so that caller can feel comfortable with completely rescinding ownership of
    ///     the memory in question when calling this function
    ///   </para>
    /// </remarks>
    STDMETHOD(SetProperties)(THIS_ __in_ecount(cProperties) const DWORD *rgdwPropertyIDs,
                             __in_ecount(cProperties) PROPVARIANT *rgPropertyValues,
                             UINT cProperties,
                             __in_opt IDisposable *pPropertyData) PURE;
};

#undef INTERFACE
#define INTERFACE ICategorizedDataItemFactory

///<summary>
///  Helps manage a number of items belonging to the same category.
///  Reduces memory footprint per item by having one single instance of
///  attributes shared by all items
///</summary>
DECLARE_INTERFACE_(ICategorizedDataItemFactory, IObjectWithCache)
{
    ///<summary>
    ///  Create a data item that shares common data with other items in the factory
    ///</summary>
    ///<param name="ppcdiNew">
    ///  [out] Address to receive the data item
    ///</param>
    ///<returns>
    ///  <para>
    ///    S_OK if successful
    ///  </para>
    ///  <para>
    ///    E_INVALIDARG if <paramref name="ppcdiNew"/> is NULL
    ///  </para>
    ///  <para>
    ///    E_FAIL on unspecified error conditions
    ///  </para>
    ///</returns>
    STDMETHOD(CreateItemInstance)(THIS_ __deref_out ICategorizedDataItem **ppcdiNew) PURE;
};


HRESULT ItemFactory_CreateInstance(__in LPCOLESTR pszCategory, __deref_out ICategorizedDataItemFactory **ppNewFactory);



// Helpers for minimizing database reads when caching data into items

#undef INTERFACE
#define INTERFACE IItemPropertyMappingResult

///<summary>
///  Maps a property ID to a list of other property IDs
///</summary>
typedef struct _PROPMAPSPEC 
{
    ///<summary>
    ///  Property ID which, if present as part of the mapping source property IDs,
    ///  should be mapped to the specified target properties
    ///</summary>
    DWORD idSourceProperty;

    ///<summary>
    ///  Number of elements in rgidTargetProperties array
    ///</summary>
    UINT cTargetProperties;

    ///<summary>
    ///  Array of property IDs that idSourceProperty maps to.
    ///</summary>
    const DWORD *rgidTargetProperties;
} PROPMAPSPEC;


///<summary>
///  Represents the result of an item property mapping performed by
///  <see cref="DatamodelMapItemProperties"/>
///</summary>
DECLARE_INTERFACE_(IItemPropertyMappingResult, IUnknown)
{
    /// <summary>
    ///   Returns the subset of source property IDs that ended up being mapped by
    ///   a property mapping, e.g., via <see cref="DatamodelMapItemProperties"/>
    /// </summary>
    /// <param name="pcProps">
    ///   [out] Address to hold number of elements in property ID array
    ///   (*<paramref name="prgProps"/>)
    /// </param>
    /// <param name="prgProps">
    ///   [out] Address to hold property ID array
    /// </param>
    /// <returns>
    ///   <para>
    ///     S_OK if properties were retrieved successfully
    ///   </para>
    ///   <para>
    ///     E_INVALIDARG if <paramref name="pcProps"/> was NULL
    ///   </para>
    ///   <para>
    ///     E_NOTFOUND if no properties were mapped.
    ///   </para>
    ///   <para>
    ///     Unspecified failure code otherwise
    ///   </para>
    /// </returns>
    /// <remarks>
    ///   <para>
    ///     The property array returned is immutable and memory for it is managed
    ///     internally by the <see cref="IItemPropertyMappingResult"/> object, so
    ///     caller does not need to release memory explicitly after retrieving value
    ///     (memory is released implicitly whenever
    ///     <see cref="IItemPropertyMappingResult"/> object is released).
    ///     However, caller does need to keep an active reference to the
    ///     <see cref="IItemPropertyMappingResult"/> object for as long as the
    ///     mapped property array returned is intended to be used.
    ///   </para>
    ///   <para>
    ///     If caller needs to mutate array returned it should make a copy and
    ///     make the necessary modifications to the copy.
    ///   </para>
    /// </remarks>
    STDMETHOD(GetSourcePropertiesMappedByReference)(THIS_ __out UINT *pcProps, __deref_out_ecount(*pcProps) DWORD **prgProps) PURE;

    /// <summary>
    ///   Returns the set of property IDs that are the final result of a property
    ///   mapping, e.g., via <see cref="DatamodelMapItemProperties"/>
    /// </summary>
    /// <param name="pcProps">
    ///   [out] Address to hold number of elements in property ID array
    ///   (*<paramref name="prgProps"/>)
    /// </param>
    /// <param name="prgProps">
    ///   [out] Address to hold property ID array
    /// </param>
    /// <returns>
    ///   <para>
    ///     S_OK if properties were retrieved successfully
    ///   </para>
    ///   <para>
    ///     E_INVALIDARG if <paramref name="pcProps"/> was NULL
    ///   </para>
    ///   <para>
    ///     E_NOTFOUND if the final property mapping result had zero properties
    ///   </para>
    ///   <para>
    ///     Unspecified failure code otherwise
    ///   </para>
    /// </returns>
    /// <remarks>
    ///   <para>
    ///     The property array returned is immutable and memory for it is managed
    ///     internally by the <see cref="IItemPropertyMappingResult"/> object, so
    ///     caller does not need to release memory explicitly after retrieving value
    ///     (memory is released implicitly whenever
    ///     <see cref="IItemPropertyMappingResult"/> object is released).
    ///     However, caller does need to keep an active reference to the
    ///     <see cref="IItemPropertyMappingResult"/> object for as long as the
    ///     mapped property array returned is intended to be used.
    ///   </para>
    ///   <para>
    ///     If caller needs to mutate array returned it should make a copy and
    ///     make the necessary modifications to the copy.
    ///   </para>
    /// </remarks>
    STDMETHOD(GetTargetPropertiesByReference)(THIS_ __out UINT *pcProps, __deref_out_ecount(*pcProps) DWORD **prgProps) PURE;
};


/// <summary>
///   Map item property IDs from one domain into another. E.g.: from the domain
///   of properties understood by a data item client into the domain of properties
///   understood by a database providing data for the item.
/// </summary>
/// <param name="rgdwPropertyIDs">
///   [in] Array of property IDs to be mapped.
/// </param>
/// <param name="cPropertyIDs">
///   [in] Number of elements in <paramref name="rgdwPropertyIDs"/> array.
/// </param>
/// <param name="rgDomainMappings">
///   [in] Array of property mapping specifications
/// </param>
/// <param name="cDomainMappings">
///   [in] Number of elements in <paramref name="rgDomainMappings"/> array.
/// </param>
/// <param name="pItemExclude">
///   [in, optional] If non-NULL, the properties already present in item should be
///   excluded from the mapping results.
/// </param>
/// <param name="ppResult">
///   [out] Results of mapping
/// </param>
/// <returns>
///   <para>
///     S_OK if mapping was successful
///   </para>
///   <para>
///     E_INVALIDARG if <paramref name="rgdwPropertyIDs"/>,
///     <paramref name="rgDomainMappings"/> or <paramref name="ppResult"/> are NULL
///   </para>
///   <para>
///     Unspecified failure code otherwise
///   </para>
/// </returns>
///<remarks>
///  <para>
///    This function facilitates having a level of indirection between property
///    IDs used by a client and property IDs used by an underlying data provider
///    module, e.g.: a database.
///  </para>
///  <para>
///    Any property ID in <paramref name="rgdwPropertyIDs"/> that does not appear
///    as the source property ID of any mapping specified in
///    <paramref name="rgDomainMappings"/> will be unchanged by the mapping, and
///    will appear in the mapping results unless it is present in
///    <paramref name="pItemExclude"/>
///  </para>
///</remarks>
HRESULT DatamodelMapItemProperties(__in_ecount(cPropertyIDs) const DWORD *rgdwPropertyIDs, UINT cPropertyIDs,
                                   __in_ecount(cDomainMappings) const PROPMAPSPEC* rgDomainMappings, UINT cDomainMappings,
                                   __in_opt ICategorizedVirtualItem *pItemExclude,
                                   __deref_out IItemPropertyMappingResult **ppResult);
    
///</topic_scope> dataitem


/// <summary>
///   Creaes a supplier that supports filtering by string and basic template filtering
///   (on one single template recognized by item inspector), which that wraps a simpler
///   IItemSupplier that doesn't support filtering by string.
/// </summary>
/// <param name="pDataSource">
///   [in] Reference to an IItemSupplier instance that doesn't support filtering by string
/// </param>
/// <param name="ppIncrementalFilter">
///   [out] Object resulting from wrapping <paramref name="pDataSource"/> with the incremental filter.
/// </param>
/// <returns>
///   <para>
///     S_OK if successful
///   </para>
///   <para>
///     E_INVALIDARG if <paramref name="ppIncrementalFilter"/> is NULL.
///   </para>
///   <para>
///     Other errors codes for unknown errors or S_OK for success.
///   </para>
/// </returns>
/// <remarks>
///   Upon successful return, <paramref name="ppIncrementalFilter"/> should contain an object that supports
///   both IItemSupplier, including SetFilterString method, and IRestrictableItemSupplier interfaces.
/// </remarks>
HRESULT WrapSupplierWithIncrementalFilter(IItemSupplier *pSource, __deref_out IUnknown** ppIncrementalFilter);


////////////////////////////////////////////////////////////////////////////////
//
// Data model APIs for cross-process communication

///<topic name="datamodelremote" displayname="APIs needed for remoting Data Model objects">
///<summary>
///  APIs used to set up and tear down data model object servers and to establish
///  client connections to data model object servers.
///</summary>
///<remarks>
///  <para>
///    These APIs will be useful as long as we don't have support for DCOM or another
///    similar API for object-remoting/marshaling.
///  </para>
///  <para>
///    The datamodel remoting APIs only support cross-process communication for objects
///    of the following types:
///    <list type="bullet">
///      <item>IVirtualList</item>
///      <item>ISearchableVirtualList</item>
///      <item>IVirtualItem</item>
///      <item>IVerbSource</item>
///      <item>IEvent</item>
///      <item>IEventDelegate</item>
///    </list>
///  </para>
///  <para>
///    Only multithreaded COM object use and creation (COINIT_MULTITHREADED) is supported
///    by this set of APIs.
///  </para>
///</remarks>
///</topic>


///<doc_scope tref="datamodelremote">

HRESULT DatamodelRemotePrepareConnection(__in REFGUID rguidServer);

HRESULT DatamodelRemoteMarshalInterface(__in REFIID riid, __in IUnknown *punkObj, __out BLOB *pblobMarshaled);
HRESULT DatamodelRemoteUnmarshalInterface(__in BLOB *pblobMarshaled, __in REFIID riid, __deref_out void **ppvProxyObj);

HRESULT DatamodelRemoteServerRegisterClassObject(__in REFCLSID rclsid, __in IClassFactory *pfact);
HRESULT DatamodelRemoteProxyCreateInstance(__in REFGUID rguidServer, __in REFCLSID rclsid, __in REFIID riid,  void **ppvProxyObj);

///</doc_scope> datamodelremote


///<summary>
///  Abstraction that encapsulates a function able to retrieve properties from a CEDB-like
///  data store.
///</summary>
interface IGetProps
{
public:
    /// <summary>
    ///   Get properties from a data store record implied by the object instance.
    /// </summary>
    /// <param name="rgPropIDsToRead">
    ///   [in] Pointer to an array of property identifiers for the properties to be retrieved. 
    /// </param>
    /// <param name="ulFlags">
    ///   [in] Specifies read flags. The following flags are accepted:
    ///   <list type="table">
    ///     <item>
    ///       <term> 0 </term>
    ///       <description>
    ///         There are no special instructions for handling the read process.
    ///       </description>
    ///     </item>
    ///     <item>
    ///       <term> CEDB_ALLOWREALLOC </term>
    ///       <description>
    ///         The LocalAlloc function was used to allocate the buffer specified by
    ///         <paramref name="prgVals"/>. The server can reallocate the buffer if it is not large
    ///         enough to hold the requested properties
    ///       </description>
    ///     </item>
    ///   </list>
    /// </param>
    /// <param name="cPropsToRead">
    ///   [in] Number of properties in <paramref name="rgPropIDsToRead"/> array
    /// </param>
    /// <param name="prgVals">
    ///   [in, out] Pointer to the address of a pointer to a buffer that receives the requested
    ///   properties. If the dwFlags parameter includes the CEDB_ALLOWREALLOC flag, the buffer may
    ///   be reallocated if necessary, even if the function fails. If the CEDB_ALLOWREALLOC flag
    ///   is specified and the pointer pointed to by <paramref name="prgVals"/> is not null it will
    ///   be released by a call to LocalFree. If the pointer pointed to by <paramref name="prgVals"/>
    ///   is NULL, the server allocates a buffer of the appropriate size in the caller's address
    ///   space and returns a pointer to the buffer. 
    /// </param>
    /// <param name="pcbBuffer">
    ///   [in, out] Pointer to a variable that contains the size, in bytes, of the buffer specified
    ///   by <paramref name="pcbBuffer"/>. When the function returns, <paramref name="pcbBuffer"/>
    ///   receives a value that indicates the actual size of the data copied to the buffer. If the
    ///   buffer was too small to contain the data and CEDB_ALLOWREALLOC was not specified,
    ///   this parameter can be used to calculate the amount of memory to allocate for the buffer. 
    /// </param>
    /// <param name="hHeap">
    ///   [in] Handle to an application-created heap to be used when reallocating memory. This
    ///   parameter is only meaningful if the CEDB_ALLOWREALLOC flag is set.
    /// </param>
    /// <returns>
    ///   <para>
    ///     S_OK if properties were retrieved successfully
    ///   </para>
    ///   <para>
    ///     Unspecified failure code otherwise
    ///   </para>
    /// </returns>
    /// <remarks>
    ///   Modeled after CeReadRecordPropsEx
    /// </remarks>
    virtual HRESULT GetProps(__in_ecount(cPropsToRead) const CEPROPID *rgPropIDsToRead,
                             ULONG ulFlags,
                             WORD cPropsToRead,
                             __inout CEPROPVAL **prgVals,
                             __inout ULONG *pcbBuffer, 
                             HANDLE hHeap) = 0;
};

HRESULT ReadPropertiesIntoItem(IGetProps &igetprops,
                               __in_ecount(cPropIDs) const CEPROPID *rgPropIDsToRead,
                               __in_ecount(cPropIDs) const CEPROPID *rgPropIDsToWrite,
                               UINT cPropIDs,
                               __inout ICategorizedDataItem *pItem);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\searchobj.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for searchobj.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __searchobj_h__
#define __searchobj_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IItemTemplate_FWD_DEFINED__
#define __IItemTemplate_FWD_DEFINED__
typedef interface IItemTemplate IItemTemplate;
#endif 	/* __IItemTemplate_FWD_DEFINED__ */


#ifndef __IMatchReasonsCollection_FWD_DEFINED__
#define __IMatchReasonsCollection_FWD_DEFINED__
typedef interface IMatchReasonsCollection IMatchReasonsCollection;
#endif 	/* __IMatchReasonsCollection_FWD_DEFINED__ */


#ifndef __IComparableVirtualItem_FWD_DEFINED__
#define __IComparableVirtualItem_FWD_DEFINED__
typedef interface IComparableVirtualItem IComparableVirtualItem;
#endif 	/* __IComparableVirtualItem_FWD_DEFINED__ */


#ifndef __IFilterableVirtualItem_FWD_DEFINED__
#define __IFilterableVirtualItem_FWD_DEFINED__
typedef interface IFilterableVirtualItem IFilterableVirtualItem;
#endif 	/* __IFilterableVirtualItem_FWD_DEFINED__ */


#ifndef __ICategorizedItemComparer_FWD_DEFINED__
#define __ICategorizedItemComparer_FWD_DEFINED__
typedef interface ICategorizedItemComparer ICategorizedItemComparer;
#endif 	/* __ICategorizedItemComparer_FWD_DEFINED__ */


#ifndef __ISearchableVirtualList_FWD_DEFINED__
#define __ISearchableVirtualList_FWD_DEFINED__
typedef interface ISearchableVirtualList ISearchableVirtualList;
#endif 	/* __ISearchableVirtualList_FWD_DEFINED__ */


#ifndef __ISupplierThreadWorker_FWD_DEFINED__
#define __ISupplierThreadWorker_FWD_DEFINED__
typedef interface ISupplierThreadWorker ISupplierThreadWorker;
#endif 	/* __ISupplierThreadWorker_FWD_DEFINED__ */


#ifndef __ISupplierThreadWorkerScheduler_FWD_DEFINED__
#define __ISupplierThreadWorkerScheduler_FWD_DEFINED__
typedef interface ISupplierThreadWorkerScheduler ISupplierThreadWorkerScheduler;
#endif 	/* __ISupplierThreadWorkerScheduler_FWD_DEFINED__ */


#ifndef __IItemSupplier_FWD_DEFINED__
#define __IItemSupplier_FWD_DEFINED__
typedef interface IItemSupplier IItemSupplier;
#endif 	/* __IItemSupplier_FWD_DEFINED__ */


#ifndef __IRestrictableItemSupplier_FWD_DEFINED__
#define __IRestrictableItemSupplier_FWD_DEFINED__
typedef interface IRestrictableItemSupplier IRestrictableItemSupplier;
#endif 	/* __IRestrictableItemSupplier_FWD_DEFINED__ */


#ifndef __IItemSupplierWithRawStringFiltering_FWD_DEFINED__
#define __IItemSupplierWithRawStringFiltering_FWD_DEFINED__
typedef interface IItemSupplierWithRawStringFiltering IItemSupplierWithRawStringFiltering;
#endif 	/* __IItemSupplierWithRawStringFiltering_FWD_DEFINED__ */


#ifndef __IObjectWithProperties_FWD_DEFINED__
#define __IObjectWithProperties_FWD_DEFINED__
typedef interface IObjectWithProperties IObjectWithProperties;
#endif 	/* __IObjectWithProperties_FWD_DEFINED__ */


#ifndef __IPausableObject_FWD_DEFINED__
#define __IPausableObject_FWD_DEFINED__
typedef interface IPausableObject IPausableObject;
#endif 	/* __IPausableObject_FWD_DEFINED__ */


/* header files for imported files */
#include "vrtldata.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_searchobj_0000_0000 */
/* [local] */ 

typedef 
enum _PROPERTYOPERATION
    {	PROPOP_NOOP	= 0,
	PROPOP_EQ	= ( PROPOP_NOOP + 1 ) ,
	PROPOP_NEQ	= ( PROPOP_EQ + 1 ) ,
	PROPOP_GT	= ( PROPOP_NEQ + 1 ) ,
	PROPOP_GE	= ( PROPOP_GT + 1 ) ,
	PROPOP_LT	= ( PROPOP_GE + 1 ) ,
	PROPOP_LE	= ( PROPOP_LT + 1 ) ,
	PROPOP_CONTAINS	= ( PROPOP_LE + 1 ) ,
	PROPOP_PREFIX	= ( PROPOP_CONTAINS + 1 ) ,
	PROPOP_EMPTY	= ( PROPOP_PREFIX + 1 ) ,
	PROPOP_NOTEMPTY	= ( PROPOP_EMPTY + 1 ) ,
	PROPOP_NUMOPS	= ( PROPOP_NOTEMPTY + 1 ) 
    } 	PROPERTYOPERATION;

typedef struct _PROPERTYRESTRICTION
    {
    DWORD dwID;
    PROPERTYOPERATION operation;
    PROPVARIANT varValue;
    } 	PROPERTYRESTRICTION;



extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0000_v0_0_s_ifspec;

#ifndef __IItemTemplate_INTERFACE_DEFINED__
#define __IItemTemplate_INTERFACE_DEFINED__

/* interface IItemTemplate */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IItemTemplate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4675825d-0165-4a5b-86c8-73246812b273")
    IItemTemplate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPropertyRestriction( 
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ PROPERTYOPERATION operation,
            /* [in] */ const PROPVARIANT *pPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyRestriction( 
            /* [in] */ DWORD dwPropertyID,
            /* [out] */ PROPERTYOPERATION *poperation,
            /* [out] */ PROPVARIANT *pPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyRestrictionRef( 
            /* [in] */ DWORD dwPropertyID,
            /* [out] */ PROPERTYOPERATION *poperation,
            /* [out] */ PROPVARIANT *pPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllRestrictions( 
            /* [out] */ PROPERTYRESTRICTION **prgRestrictions,
            /* [out] */ UINT *pcRestrictions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeRestrictions( 
            /* [size_is][in] */ PROPERTYRESTRICTION *rgRestrictions,
            /* [in] */ UINT cRestrictions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryRef( 
            /* [out] */ LPOLESTR *ppszCategory,
            /* [out] */ UINT *pcchCategory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemTemplateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IItemTemplate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IItemTemplate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IItemTemplate * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyRestriction )( 
            IItemTemplate * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ PROPERTYOPERATION operation,
            /* [in] */ const PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyRestriction )( 
            IItemTemplate * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out] */ PROPERTYOPERATION *poperation,
            /* [out] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyRestrictionRef )( 
            IItemTemplate * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out] */ PROPERTYOPERATION *poperation,
            /* [out] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllRestrictions )( 
            IItemTemplate * This,
            /* [out] */ PROPERTYRESTRICTION **prgRestrictions,
            /* [out] */ UINT *pcRestrictions);
        
        HRESULT ( STDMETHODCALLTYPE *FreeRestrictions )( 
            IItemTemplate * This,
            /* [size_is][in] */ PROPERTYRESTRICTION *rgRestrictions,
            /* [in] */ UINT cRestrictions);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategoryRef )( 
            IItemTemplate * This,
            /* [out] */ LPOLESTR *ppszCategory,
            /* [out] */ UINT *pcchCategory);
        
        END_INTERFACE
    } IItemTemplateVtbl;

    interface IItemTemplate
    {
        CONST_VTBL struct IItemTemplateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItemTemplate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IItemTemplate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IItemTemplate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IItemTemplate_SetPropertyRestriction(This,dwPropertyID,operation,pPropertyValue)	\
    ( (This)->lpVtbl -> SetPropertyRestriction(This,dwPropertyID,operation,pPropertyValue) ) 

#define IItemTemplate_GetPropertyRestriction(This,dwPropertyID,poperation,pPropertyValue)	\
    ( (This)->lpVtbl -> GetPropertyRestriction(This,dwPropertyID,poperation,pPropertyValue) ) 

#define IItemTemplate_GetPropertyRestrictionRef(This,dwPropertyID,poperation,pPropertyValue)	\
    ( (This)->lpVtbl -> GetPropertyRestrictionRef(This,dwPropertyID,poperation,pPropertyValue) ) 

#define IItemTemplate_GetAllRestrictions(This,prgRestrictions,pcRestrictions)	\
    ( (This)->lpVtbl -> GetAllRestrictions(This,prgRestrictions,pcRestrictions) ) 

#define IItemTemplate_FreeRestrictions(This,rgRestrictions,cRestrictions)	\
    ( (This)->lpVtbl -> FreeRestrictions(This,rgRestrictions,cRestrictions) ) 

#define IItemTemplate_GetCategoryRef(This,ppszCategory,pcchCategory)	\
    ( (This)->lpVtbl -> GetCategoryRef(This,ppszCategory,pcchCategory) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IItemTemplate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_searchobj_0000_0001 */
/* [local] */ 

HRESULT ItemTemplate_CreateInstance( 
    /* [optional][in] */ LPCOLESTR pszCategory,
    /* [retval][out] */ IItemTemplate **ppNewTemplate);


#define DATAMODEL_MATCHREASON_CCHREASONMAX 128

#define DATAMODEL_MATCHREASON_CCHDELIMMAX 4



extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0001_v0_0_s_ifspec;

#ifndef __IMatchReasonsCollection_INTERFACE_DEFINED__
#define __IMatchReasonsCollection_INTERFACE_DEFINED__

/* interface IMatchReasonsCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMatchReasonsCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7599739d-1b57-4585-8961-dab8b283318a")
    IMatchReasonsCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCurrentFilterLength( 
            /* [in] */ UINT cchFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentFilterLength( 
            /* [retval][out] */ UINT *pcchFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TruncateAt( 
            /* [in] */ UINT cchFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaximumAccumulatorSize( 
            /* [in] */ UINT cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaximumAccumulatorSize( 
            /* [retval][out] */ UINT *pcchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDelimiter( 
            /* [in] */ LPCWSTR pwszDelim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDelimiter( 
            /* [size_is][out] */ LPWSTR pwszDelim,
            /* [in] */ UINT cchDelim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSkippableCharacterSet( 
            /* [in] */ LPCWSTR pwszSkippable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRedundantReason( 
            /* [in] */ LPCWSTR pwszRedundant) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMatchReason( 
            /* [size_is][in] */ LPCWSTR pwszReason,
            /* [in] */ UINT cchReason,
            /* [in] */ UINT iItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMatchReasonForFilterLength( 
            /* [in] */ UINT cchFilter,
            /* [size_is][in] */ LPCWSTR pwszReason,
            /* [in] */ UINT cchReason,
            /* [in] */ UINT iItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAccumulatedMatchReasonsToCollection( 
            /* [in] */ UINT cchFilter,
            /* [in] */ UINT iFirstItem,
            /* [in] */ IMatchReasonsCollection *pReasonsDestination) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAccumulatorFull( 
            /* [in] */ UINT cchFilter,
            /* [out] */ BOOL *pfIsFull) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccumulatedMatchReasons( 
            /* [in] */ UINT cchFilter,
            /* [size_is][out] */ LPWSTR pwszReasons,
            /* [in] */ UINT cchReasons) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasMatchReasons( 
            /* [in] */ UINT cchFilter,
            /* [retval][out] */ BOOL *pfHasReasons) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemAdded( 
            /* [in] */ UINT iItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemDeleted( 
            /* [in] */ UINT iItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemChanged( 
            /* [in] */ UINT iItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnItemMoved( 
            /* [in] */ UINT iNewItem,
            /* [in] */ UINT iOldItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeNotificationEvent( 
            /* [out] */ IEvent **ppEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMatchReasonsCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMatchReasonsCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMatchReasonsCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMatchReasonsCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentFilterLength )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT cchFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentFilterLength )( 
            IMatchReasonsCollection * This,
            /* [retval][out] */ UINT *pcchFilter);
        
        HRESULT ( STDMETHODCALLTYPE *TruncateAt )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT cchFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaximumAccumulatorSize )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT cchMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaximumAccumulatorSize )( 
            IMatchReasonsCollection * This,
            /* [retval][out] */ UINT *pcchMax);
        
        HRESULT ( STDMETHODCALLTYPE *SetDelimiter )( 
            IMatchReasonsCollection * This,
            /* [in] */ LPCWSTR pwszDelim);
        
        HRESULT ( STDMETHODCALLTYPE *GetDelimiter )( 
            IMatchReasonsCollection * This,
            /* [size_is][out] */ LPWSTR pwszDelim,
            /* [in] */ UINT cchDelim);
        
        HRESULT ( STDMETHODCALLTYPE *SetSkippableCharacterSet )( 
            IMatchReasonsCollection * This,
            /* [in] */ LPCWSTR pwszSkippable);
        
        HRESULT ( STDMETHODCALLTYPE *SetRedundantReason )( 
            IMatchReasonsCollection * This,
            /* [in] */ LPCWSTR pwszRedundant);
        
        HRESULT ( STDMETHODCALLTYPE *AddMatchReason )( 
            IMatchReasonsCollection * This,
            /* [size_is][in] */ LPCWSTR pwszReason,
            /* [in] */ UINT cchReason,
            /* [in] */ UINT iItem);
        
        HRESULT ( STDMETHODCALLTYPE *AddMatchReasonForFilterLength )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT cchFilter,
            /* [size_is][in] */ LPCWSTR pwszReason,
            /* [in] */ UINT cchReason,
            /* [in] */ UINT iItem);
        
        HRESULT ( STDMETHODCALLTYPE *AddAccumulatedMatchReasonsToCollection )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT cchFilter,
            /* [in] */ UINT iFirstItem,
            /* [in] */ IMatchReasonsCollection *pReasonsDestination);
        
        HRESULT ( STDMETHODCALLTYPE *IsAccumulatorFull )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT cchFilter,
            /* [out] */ BOOL *pfIsFull);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccumulatedMatchReasons )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT cchFilter,
            /* [size_is][out] */ LPWSTR pwszReasons,
            /* [in] */ UINT cchReasons);
        
        HRESULT ( STDMETHODCALLTYPE *HasMatchReasons )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT cchFilter,
            /* [retval][out] */ BOOL *pfHasReasons);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemAdded )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT iItem);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemDeleted )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT iItem);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemChanged )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT iItem);
        
        HRESULT ( STDMETHODCALLTYPE *OnItemMoved )( 
            IMatchReasonsCollection * This,
            /* [in] */ UINT iNewItem,
            /* [in] */ UINT iOldItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IMatchReasonsCollection * This,
            /* [out] */ IEvent **ppEvent);
        
        END_INTERFACE
    } IMatchReasonsCollectionVtbl;

    interface IMatchReasonsCollection
    {
        CONST_VTBL struct IMatchReasonsCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMatchReasonsCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMatchReasonsCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMatchReasonsCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMatchReasonsCollection_SetCurrentFilterLength(This,cchFilter)	\
    ( (This)->lpVtbl -> SetCurrentFilterLength(This,cchFilter) ) 

#define IMatchReasonsCollection_GetCurrentFilterLength(This,pcchFilter)	\
    ( (This)->lpVtbl -> GetCurrentFilterLength(This,pcchFilter) ) 

#define IMatchReasonsCollection_TruncateAt(This,cchFilter)	\
    ( (This)->lpVtbl -> TruncateAt(This,cchFilter) ) 

#define IMatchReasonsCollection_SetMaximumAccumulatorSize(This,cchMax)	\
    ( (This)->lpVtbl -> SetMaximumAccumulatorSize(This,cchMax) ) 

#define IMatchReasonsCollection_GetMaximumAccumulatorSize(This,pcchMax)	\
    ( (This)->lpVtbl -> GetMaximumAccumulatorSize(This,pcchMax) ) 

#define IMatchReasonsCollection_SetDelimiter(This,pwszDelim)	\
    ( (This)->lpVtbl -> SetDelimiter(This,pwszDelim) ) 

#define IMatchReasonsCollection_GetDelimiter(This,pwszDelim,cchDelim)	\
    ( (This)->lpVtbl -> GetDelimiter(This,pwszDelim,cchDelim) ) 

#define IMatchReasonsCollection_SetSkippableCharacterSet(This,pwszSkippable)	\
    ( (This)->lpVtbl -> SetSkippableCharacterSet(This,pwszSkippable) ) 

#define IMatchReasonsCollection_SetRedundantReason(This,pwszRedundant)	\
    ( (This)->lpVtbl -> SetRedundantReason(This,pwszRedundant) ) 

#define IMatchReasonsCollection_AddMatchReason(This,pwszReason,cchReason,iItem)	\
    ( (This)->lpVtbl -> AddMatchReason(This,pwszReason,cchReason,iItem) ) 

#define IMatchReasonsCollection_AddMatchReasonForFilterLength(This,cchFilter,pwszReason,cchReason,iItem)	\
    ( (This)->lpVtbl -> AddMatchReasonForFilterLength(This,cchFilter,pwszReason,cchReason,iItem) ) 

#define IMatchReasonsCollection_AddAccumulatedMatchReasonsToCollection(This,cchFilter,iFirstItem,pReasonsDestination)	\
    ( (This)->lpVtbl -> AddAccumulatedMatchReasonsToCollection(This,cchFilter,iFirstItem,pReasonsDestination) ) 

#define IMatchReasonsCollection_IsAccumulatorFull(This,cchFilter,pfIsFull)	\
    ( (This)->lpVtbl -> IsAccumulatorFull(This,cchFilter,pfIsFull) ) 

#define IMatchReasonsCollection_GetAccumulatedMatchReasons(This,cchFilter,pwszReasons,cchReasons)	\
    ( (This)->lpVtbl -> GetAccumulatedMatchReasons(This,cchFilter,pwszReasons,cchReasons) ) 

#define IMatchReasonsCollection_HasMatchReasons(This,cchFilter,pfHasReasons)	\
    ( (This)->lpVtbl -> HasMatchReasons(This,cchFilter,pfHasReasons) ) 

#define IMatchReasonsCollection_OnItemAdded(This,iItem)	\
    ( (This)->lpVtbl -> OnItemAdded(This,iItem) ) 

#define IMatchReasonsCollection_OnItemDeleted(This,iItem)	\
    ( (This)->lpVtbl -> OnItemDeleted(This,iItem) ) 

#define IMatchReasonsCollection_OnItemChanged(This,iItem)	\
    ( (This)->lpVtbl -> OnItemChanged(This,iItem) ) 

#define IMatchReasonsCollection_OnItemMoved(This,iNewItem,iOldItem)	\
    ( (This)->lpVtbl -> OnItemMoved(This,iNewItem,iOldItem) ) 

#define IMatchReasonsCollection_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMatchReasonsCollection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_searchobj_0000_0002 */
/* [local] */ 



// Match reasons tracked by collection have changed
#define MATCHREASONSEVENT_REASONSCHANGED         0x00000000

// Collection configuration (delimiter, max size, skippable
// characters, etc) has changed
#define MATCHREASONSEVENT_CONFIGURATIONCHANGED   0x00000001

HRESULT MatchReasonsCollection_CreateInstance( 
    /* [retval][out] */ IMatchReasonsCollection **ppMatchReasonsCollection);

/// <topic name="propertymatch" displayname="Property Matching">
///   <topic_scope tref="searchobj"/>
/// <summary>
///   Represents the type of comparison operation that will be done between a
///   string used as a filter and another string, i.e., the match target string,
///   that is being filtered (most likely as part of a larger set of strings).
/// </summary>
/// </topic>

/// <topic_scope tref="propertymatch">

///<summary>
///  The entity performing the match should try to autodetect what kind of string
///  the match target is, and perform the match operation accordingly.
///</summary>
#define DATAMODEL_PROPERTYMATCH_TYPEAUTORECOGNIZE  0x00

///<summary>
///  <para>
///    The filter target is the name of a person (e.g.: 'Last, First').
///  </para>
///  <para>
///    Each word (where word tokens are separated by whitespace or punctuation)
///    in the name will be taken as a possible starting point for matching
///    against the filter, and filter matching will wrap around back to the
///    first word if filter ends up going off the end of the string (e.g.:
///    if the first token that matched the filter was the last word in the
///    string).
///  </para>
///</summary>
#define DATAMODEL_PROPERTYMATCH_TYPENAME                  0x01

///<summary>
///  <para>
///    The match target is a phone number (e.g.: '(425) 123-4567')
///  </para>
///  <para>
///    The filter string will match the target string whether it matches the
///    number starting with the area code or whether it matches the number
///    skipping the area code. E.g.: filters '4251' and '1234' will both
///    match the target '(425) 123-4567'.
///  </para>
///</summary>
#define DATAMODEL_PROPERTYMATCH_TYPENUMBER              0x02

///<summary>
///  <para>
///    The match target is plain text with no special semantics.
///  </para>
///  <para>
///    Each word (where word tokens are separated by whitespace or punctuation)
///    in the name will be taken as a possible starting point for matching
///    against the filter. Filter matching will not wrap around back to the
///    first word if filter ends up going off the end of the string (unlike
///    for DATAMODEL_PROPERTYMATCH_TYPENAME                   type of matching)
///  </para>
///</summary>
#define DATAMODEL_PROPERTYMATCH_TYPETEXT                  0x03

#define DATAMODEL_PROPERTYMATCH_TYPEMASK                  0xFF

///<summary>
///  <para>
///    Indicates that any existing highlights in the DataItem should not be cleared
///  </para>
///  <para>
///    The Match method by default will delete any existing highlights on the item. This
///    flag overrides that behavior.
///  </para>
///</summary>
#define DATAMODEL_PROPERTYMATCH_KEEPHIGHLIGHTS 0x100

/// </topic_scope> propertymatch



extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0002_v0_0_s_ifspec;

#ifndef __IComparableVirtualItem_INTERFACE_DEFINED__
#define __IComparableVirtualItem_INTERFACE_DEFINED__

/* interface IComparableVirtualItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IComparableVirtualItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73c07453-86a6-4342-8475-b372e7e3a5bc")
    IComparableVirtualItem : public ICategorizedVirtualItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompareTo( 
            /* [in] */ ICategorizedVirtualItem *pOther,
            /* [in] */ DWORD dwComparisonPropertyID,
            /* [retval][out] */ LONG *plResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComparableVirtualItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IComparableVirtualItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IComparableVirtualItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IComparableVirtualItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            IComparableVirtualItem * This,
            /* [retval][out] */ BOOL *pfValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IComparableVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out][in] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *CachePropertiesHint )( 
            IComparableVirtualItem * This,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IComparableVirtualItem * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IComparableVirtualItem * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyRef )( 
            IComparableVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            IComparableVirtualItem * This,
            /* [size_is][out] */ LPOLESTR pszDataCategory,
            /* [out][in] */ UINT *pcchDataCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategoryRef )( 
            IComparableVirtualItem * This,
            /* [out] */ LPOLESTR *ppszDataCategory,
            /* [out] */ UINT *pcchDataCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueID )( 
            IComparableVirtualItem * This,
            /* [size_is][out] */ BYTE *rgbUniqueID,
            /* [out][in] */ UINT *pcbUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueIDRef )( 
            IComparableVirtualItem * This,
            /* [out] */ BYTE **prgbUniqueID,
            /* [out] */ UINT *pcbUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayTextFieldCount )( 
            IComparableVirtualItem * This,
            /* [out] */ UINT *pcDisplayFieldCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayTextField )( 
            IComparableVirtualItem * This,
            /* [in] */ UINT iDisplayField,
            /* [size_is][out] */ LPOLESTR pszDisplayField,
            /* [out][in] */ UINT *pcchDisplayField);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayImageCount )( 
            IComparableVirtualItem * This,
            /* [out] */ UINT *pcDisplayImageCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayImage )( 
            IComparableVirtualItem * This,
            /* [in] */ UINT iDisplayImage,
            /* [size_is][out] */ LPOLESTR pszDisplayImage,
            /* [out][in] */ UINT *pcchDisplayImage);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllProperties )( 
            IComparableVirtualItem * This,
            /* [out] */ ITEMPROPERTY **prgProperties,
            /* [out] */ UINT *pcProperties);
        
        HRESULT ( STDMETHODCALLTYPE *FreeProperties )( 
            IComparableVirtualItem * This,
            /* [size_is][in] */ ITEMPROPERTY *rgProperties,
            /* [in] */ UINT cProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyInformation )( 
            IComparableVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [retval][out] */ VIPRINFO *pvipriInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CompareTo )( 
            IComparableVirtualItem * This,
            /* [in] */ ICategorizedVirtualItem *pOther,
            /* [in] */ DWORD dwComparisonPropertyID,
            /* [retval][out] */ LONG *plResult);
        
        END_INTERFACE
    } IComparableVirtualItemVtbl;

    interface IComparableVirtualItem
    {
        CONST_VTBL struct IComparableVirtualItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComparableVirtualItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IComparableVirtualItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IComparableVirtualItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IComparableVirtualItem_IsValid(This,pfValid)	\
    ( (This)->lpVtbl -> IsValid(This,pfValid) ) 

#define IComparableVirtualItem_GetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwPropertyID,pPropertyValue) ) 

#define IComparableVirtualItem_CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions)	\
    ( (This)->lpVtbl -> CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions) ) 

#define IComparableVirtualItem_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IComparableVirtualItem_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define IComparableVirtualItem_GetPropertyRef(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetPropertyRef(This,dwPropertyID,pPropertyValue) ) 

#define IComparableVirtualItem_GetCategory(This,pszDataCategory,pcchDataCategory)	\
    ( (This)->lpVtbl -> GetCategory(This,pszDataCategory,pcchDataCategory) ) 

#define IComparableVirtualItem_GetCategoryRef(This,ppszDataCategory,pcchDataCategory)	\
    ( (This)->lpVtbl -> GetCategoryRef(This,ppszDataCategory,pcchDataCategory) ) 

#define IComparableVirtualItem_GetUniqueID(This,rgbUniqueID,pcbUniqueID)	\
    ( (This)->lpVtbl -> GetUniqueID(This,rgbUniqueID,pcbUniqueID) ) 

#define IComparableVirtualItem_GetUniqueIDRef(This,prgbUniqueID,pcbUniqueID)	\
    ( (This)->lpVtbl -> GetUniqueIDRef(This,prgbUniqueID,pcbUniqueID) ) 

#define IComparableVirtualItem_GetDisplayTextFieldCount(This,pcDisplayFieldCount)	\
    ( (This)->lpVtbl -> GetDisplayTextFieldCount(This,pcDisplayFieldCount) ) 

#define IComparableVirtualItem_GetDisplayTextField(This,iDisplayField,pszDisplayField,pcchDisplayField)	\
    ( (This)->lpVtbl -> GetDisplayTextField(This,iDisplayField,pszDisplayField,pcchDisplayField) ) 

#define IComparableVirtualItem_GetDisplayImageCount(This,pcDisplayImageCount)	\
    ( (This)->lpVtbl -> GetDisplayImageCount(This,pcDisplayImageCount) ) 

#define IComparableVirtualItem_GetDisplayImage(This,iDisplayImage,pszDisplayImage,pcchDisplayImage)	\
    ( (This)->lpVtbl -> GetDisplayImage(This,iDisplayImage,pszDisplayImage,pcchDisplayImage) ) 

#define IComparableVirtualItem_GetAllProperties(This,prgProperties,pcProperties)	\
    ( (This)->lpVtbl -> GetAllProperties(This,prgProperties,pcProperties) ) 

#define IComparableVirtualItem_FreeProperties(This,rgProperties,cProperties)	\
    ( (This)->lpVtbl -> FreeProperties(This,rgProperties,cProperties) ) 

#define IComparableVirtualItem_GetPropertyInformation(This,dwPropertyID,pvipriInfo)	\
    ( (This)->lpVtbl -> GetPropertyInformation(This,dwPropertyID,pvipriInfo) ) 


#define IComparableVirtualItem_CompareTo(This,pOther,dwComparisonPropertyID,plResult)	\
    ( (This)->lpVtbl -> CompareTo(This,pOther,dwComparisonPropertyID,plResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComparableVirtualItem_INTERFACE_DEFINED__ */


#ifndef __IFilterableVirtualItem_INTERFACE_DEFINED__
#define __IFilterableVirtualItem_INTERFACE_DEFINED__

/* interface IFilterableVirtualItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IFilterableVirtualItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d087d38-c4cd-4acf-9a49-c11821235df9")
    IFilterableVirtualItem : public ICategorizedVirtualItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsMatch( 
            /* [optional][in] */ LPCOLESTR pszFilter,
            /* [optional][in] */ GUID *pguidKeyboard,
            /* [optional][in] */ ICategorizedVirtualItem *pRelatedItem,
            /* [size_is][optional][in] */ IItemTemplate **rgpTemplates,
            /* [optional][in] */ UINT cTemplates,
            /* [retval][out] */ BOOL *pfIsMatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchPropertyWithString( 
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LPCWSTR pwszFilter,
            /* [in] */ GUID *pguidKeyboard,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ BOOL *pfIsMatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReasonsFromLastStringMatch( 
            /* [in] */ IMatchReasonsCollection *pMatchReasons,
            /* [in] */ UINT iItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearMatchReasons( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterableVirtualItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterableVirtualItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterableVirtualItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterableVirtualItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            IFilterableVirtualItem * This,
            /* [retval][out] */ BOOL *pfValid);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IFilterableVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out][in] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *CachePropertiesHint )( 
            IFilterableVirtualItem * This,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IFilterableVirtualItem * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IFilterableVirtualItem * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyRef )( 
            IFilterableVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [out] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            IFilterableVirtualItem * This,
            /* [size_is][out] */ LPOLESTR pszDataCategory,
            /* [out][in] */ UINT *pcchDataCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategoryRef )( 
            IFilterableVirtualItem * This,
            /* [out] */ LPOLESTR *ppszDataCategory,
            /* [out] */ UINT *pcchDataCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueID )( 
            IFilterableVirtualItem * This,
            /* [size_is][out] */ BYTE *rgbUniqueID,
            /* [out][in] */ UINT *pcbUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueIDRef )( 
            IFilterableVirtualItem * This,
            /* [out] */ BYTE **prgbUniqueID,
            /* [out] */ UINT *pcbUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayTextFieldCount )( 
            IFilterableVirtualItem * This,
            /* [out] */ UINT *pcDisplayFieldCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayTextField )( 
            IFilterableVirtualItem * This,
            /* [in] */ UINT iDisplayField,
            /* [size_is][out] */ LPOLESTR pszDisplayField,
            /* [out][in] */ UINT *pcchDisplayField);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayImageCount )( 
            IFilterableVirtualItem * This,
            /* [out] */ UINT *pcDisplayImageCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayImage )( 
            IFilterableVirtualItem * This,
            /* [in] */ UINT iDisplayImage,
            /* [size_is][out] */ LPOLESTR pszDisplayImage,
            /* [out][in] */ UINT *pcchDisplayImage);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllProperties )( 
            IFilterableVirtualItem * This,
            /* [out] */ ITEMPROPERTY **prgProperties,
            /* [out] */ UINT *pcProperties);
        
        HRESULT ( STDMETHODCALLTYPE *FreeProperties )( 
            IFilterableVirtualItem * This,
            /* [size_is][in] */ ITEMPROPERTY *rgProperties,
            /* [in] */ UINT cProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyInformation )( 
            IFilterableVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [retval][out] */ VIPRINFO *pvipriInfo);
        
        HRESULT ( STDMETHODCALLTYPE *IsMatch )( 
            IFilterableVirtualItem * This,
            /* [optional][in] */ LPCOLESTR pszFilter,
            /* [optional][in] */ GUID *pguidKeyboard,
            /* [optional][in] */ ICategorizedVirtualItem *pRelatedItem,
            /* [size_is][optional][in] */ IItemTemplate **rgpTemplates,
            /* [optional][in] */ UINT cTemplates,
            /* [retval][out] */ BOOL *pfIsMatch);
        
        HRESULT ( STDMETHODCALLTYPE *MatchPropertyWithString )( 
            IFilterableVirtualItem * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LPCWSTR pwszFilter,
            /* [in] */ GUID *pguidKeyboard,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ BOOL *pfIsMatch);
        
        HRESULT ( STDMETHODCALLTYPE *GetReasonsFromLastStringMatch )( 
            IFilterableVirtualItem * This,
            /* [in] */ IMatchReasonsCollection *pMatchReasons,
            /* [in] */ UINT iItem);
        
        HRESULT ( STDMETHODCALLTYPE *ClearMatchReasons )( 
            IFilterableVirtualItem * This);
        
        END_INTERFACE
    } IFilterableVirtualItemVtbl;

    interface IFilterableVirtualItem
    {
        CONST_VTBL struct IFilterableVirtualItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterableVirtualItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterableVirtualItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterableVirtualItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterableVirtualItem_IsValid(This,pfValid)	\
    ( (This)->lpVtbl -> IsValid(This,pfValid) ) 

#define IFilterableVirtualItem_GetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwPropertyID,pPropertyValue) ) 

#define IFilterableVirtualItem_CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions)	\
    ( (This)->lpVtbl -> CachePropertiesHint(This,rgdwPropertyIDs,cPropertyIDs,dwOptions) ) 

#define IFilterableVirtualItem_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IFilterableVirtualItem_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define IFilterableVirtualItem_GetPropertyRef(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetPropertyRef(This,dwPropertyID,pPropertyValue) ) 

#define IFilterableVirtualItem_GetCategory(This,pszDataCategory,pcchDataCategory)	\
    ( (This)->lpVtbl -> GetCategory(This,pszDataCategory,pcchDataCategory) ) 

#define IFilterableVirtualItem_GetCategoryRef(This,ppszDataCategory,pcchDataCategory)	\
    ( (This)->lpVtbl -> GetCategoryRef(This,ppszDataCategory,pcchDataCategory) ) 

#define IFilterableVirtualItem_GetUniqueID(This,rgbUniqueID,pcbUniqueID)	\
    ( (This)->lpVtbl -> GetUniqueID(This,rgbUniqueID,pcbUniqueID) ) 

#define IFilterableVirtualItem_GetUniqueIDRef(This,prgbUniqueID,pcbUniqueID)	\
    ( (This)->lpVtbl -> GetUniqueIDRef(This,prgbUniqueID,pcbUniqueID) ) 

#define IFilterableVirtualItem_GetDisplayTextFieldCount(This,pcDisplayFieldCount)	\
    ( (This)->lpVtbl -> GetDisplayTextFieldCount(This,pcDisplayFieldCount) ) 

#define IFilterableVirtualItem_GetDisplayTextField(This,iDisplayField,pszDisplayField,pcchDisplayField)	\
    ( (This)->lpVtbl -> GetDisplayTextField(This,iDisplayField,pszDisplayField,pcchDisplayField) ) 

#define IFilterableVirtualItem_GetDisplayImageCount(This,pcDisplayImageCount)	\
    ( (This)->lpVtbl -> GetDisplayImageCount(This,pcDisplayImageCount) ) 

#define IFilterableVirtualItem_GetDisplayImage(This,iDisplayImage,pszDisplayImage,pcchDisplayImage)	\
    ( (This)->lpVtbl -> GetDisplayImage(This,iDisplayImage,pszDisplayImage,pcchDisplayImage) ) 

#define IFilterableVirtualItem_GetAllProperties(This,prgProperties,pcProperties)	\
    ( (This)->lpVtbl -> GetAllProperties(This,prgProperties,pcProperties) ) 

#define IFilterableVirtualItem_FreeProperties(This,rgProperties,cProperties)	\
    ( (This)->lpVtbl -> FreeProperties(This,rgProperties,cProperties) ) 

#define IFilterableVirtualItem_GetPropertyInformation(This,dwPropertyID,pvipriInfo)	\
    ( (This)->lpVtbl -> GetPropertyInformation(This,dwPropertyID,pvipriInfo) ) 


#define IFilterableVirtualItem_IsMatch(This,pszFilter,pguidKeyboard,pRelatedItem,rgpTemplates,cTemplates,pfIsMatch)	\
    ( (This)->lpVtbl -> IsMatch(This,pszFilter,pguidKeyboard,pRelatedItem,rgpTemplates,cTemplates,pfIsMatch) ) 

#define IFilterableVirtualItem_MatchPropertyWithString(This,dwPropertyID,pwszFilter,pguidKeyboard,dwFlags,pfIsMatch)	\
    ( (This)->lpVtbl -> MatchPropertyWithString(This,dwPropertyID,pwszFilter,pguidKeyboard,dwFlags,pfIsMatch) ) 

#define IFilterableVirtualItem_GetReasonsFromLastStringMatch(This,pMatchReasons,iItem)	\
    ( (This)->lpVtbl -> GetReasonsFromLastStringMatch(This,pMatchReasons,iItem) ) 

#define IFilterableVirtualItem_ClearMatchReasons(This)	\
    ( (This)->lpVtbl -> ClearMatchReasons(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterableVirtualItem_INTERFACE_DEFINED__ */


#ifndef __ICategorizedItemComparer_INTERFACE_DEFINED__
#define __ICategorizedItemComparer_INTERFACE_DEFINED__

/* interface ICategorizedItemComparer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICategorizedItemComparer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da944e0f-305c-4be7-a869-bb98279b830c")
    ICategorizedItemComparer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoesItemMatch( 
            /* [in] */ ICategorizedVirtualItem *pMatchTarget,
            /* [optional][in] */ LPCOLESTR pszFilter,
            /* [optional][in] */ GUID *pguidKeyboard,
            /* [optional][in] */ ICategorizedVirtualItem *pRelatedItem,
            /* [size_is][optional][in] */ IItemTemplate **rgpTemplates,
            /* [optional][in] */ UINT cTemplates,
            /* [retval][out] */ BOOL *pfIsMatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ ICategorizedVirtualItem *pLeftItem,
            /* [in] */ ICategorizedVirtualItem *pRightItem,
            /* [in] */ DWORD dwComparisonPropertyID,
            /* [retval][out] */ LONG *plResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICategorizedItemComparerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICategorizedItemComparer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICategorizedItemComparer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICategorizedItemComparer * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoesItemMatch )( 
            ICategorizedItemComparer * This,
            /* [in] */ ICategorizedVirtualItem *pMatchTarget,
            /* [optional][in] */ LPCOLESTR pszFilter,
            /* [optional][in] */ GUID *pguidKeyboard,
            /* [optional][in] */ ICategorizedVirtualItem *pRelatedItem,
            /* [size_is][optional][in] */ IItemTemplate **rgpTemplates,
            /* [optional][in] */ UINT cTemplates,
            /* [retval][out] */ BOOL *pfIsMatch);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            ICategorizedItemComparer * This,
            /* [in] */ ICategorizedVirtualItem *pLeftItem,
            /* [in] */ ICategorizedVirtualItem *pRightItem,
            /* [in] */ DWORD dwComparisonPropertyID,
            /* [retval][out] */ LONG *plResult);
        
        END_INTERFACE
    } ICategorizedItemComparerVtbl;

    interface ICategorizedItemComparer
    {
        CONST_VTBL struct ICategorizedItemComparerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICategorizedItemComparer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICategorizedItemComparer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICategorizedItemComparer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICategorizedItemComparer_DoesItemMatch(This,pMatchTarget,pszFilter,pguidKeyboard,pRelatedItem,rgpTemplates,cTemplates,pfIsMatch)	\
    ( (This)->lpVtbl -> DoesItemMatch(This,pMatchTarget,pszFilter,pguidKeyboard,pRelatedItem,rgpTemplates,cTemplates,pfIsMatch) ) 

#define ICategorizedItemComparer_Compare(This,pLeftItem,pRightItem,dwComparisonPropertyID,plResult)	\
    ( (This)->lpVtbl -> Compare(This,pLeftItem,pRightItem,dwComparisonPropertyID,plResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICategorizedItemComparer_INTERFACE_DEFINED__ */


#ifndef __ISearchableVirtualList_INTERFACE_DEFINED__
#define __ISearchableVirtualList_INTERFACE_DEFINED__

/* interface ISearchableVirtualList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISearchableVirtualList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0473399d-abd0-4183-a97d-f559bd6c3999")
    ISearchableVirtualList : public IVirtualList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetResultTemplates( 
            /* [size_is][in] */ IItemTemplate **rgpTemplates,
            /* [in] */ UINT cTemplates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultTemplates( 
            /* [out] */ IItemTemplate ***prgpTemplates,
            /* [out] */ UINT *pcTemplates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeResultTemplates( 
            /* [size_is][in] */ IItemTemplate **rgpTemplates,
            /* [in] */ UINT cTemplates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelatedItem( 
            /* [in] */ ICategorizedVirtualItem *pRelatedItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelatedItem( 
            /* [retval][out] */ ICategorizedVirtualItem **ppRelatedItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRawFilterString( 
            /* [in] */ LPCWSTR pszDeterminedFilterChars,
            /* [in] */ LPCWSTR pszUndeterminedFilterChars,
            /* [in] */ GUID *pguidKeyboard) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPaused( 
            /* [retval][out] */ BOOL *pfIsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsBackgroundProcessing( 
            /* [retval][out] */ BOOL *pfIsProcessing) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchableVirtualListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchableVirtualList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchableVirtualList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchableVirtualList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ISearchableVirtualList * This,
            /* [retval][out] */ UINT *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            ISearchableVirtualList * This,
            /* [in] */ UINT iItem,
            /* [retval][out] */ IVirtualItem **ppviItem);
        
        HRESULT ( STDMETHODCALLTYPE *CacheItemsHint )( 
            ISearchableVirtualList * This,
            /* [in] */ UINT iFirstItem,
            /* [in] */ UINT cItems,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ISearchableVirtualList * This,
            /* [in] */ DWORD dwListPropertyID,
            /* [retval][out] */ PROPVARIANT *pListPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterString )( 
            ISearchableVirtualList * This,
            /* [size_is][out] */ LPOLESTR pszFilter,
            /* [out][in] */ UINT *pcchFilter);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterString )( 
            ISearchableVirtualList * This,
            /* [in] */ LPCOLESTR pszFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortPropertyID )( 
            ISearchableVirtualList * This,
            /* [retval][out] */ DWORD *pdwPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDirection )( 
            ISearchableVirtualList * This,
            /* [retval][out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortCount )( 
            ISearchableVirtualList * This,
            /* [retval][out] */ UINT *pcSort);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortPropertyID )( 
            ISearchableVirtualList * This,
            /* [in] */ UINT iSortProperty,
            /* [retval][out] */ DWORD *pdwSortPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortDirection )( 
            ISearchableVirtualList * This,
            /* [in] */ UINT iSortProperty,
            /* [out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *ApplySort )( 
            ISearchableVirtualList * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LISTSORTDIRECTION lsdir);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSort )( 
            ISearchableVirtualList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            ISearchableVirtualList * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            ISearchableVirtualList * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetResultTemplates )( 
            ISearchableVirtualList * This,
            /* [size_is][in] */ IItemTemplate **rgpTemplates,
            /* [in] */ UINT cTemplates);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultTemplates )( 
            ISearchableVirtualList * This,
            /* [out] */ IItemTemplate ***prgpTemplates,
            /* [out] */ UINT *pcTemplates);
        
        HRESULT ( STDMETHODCALLTYPE *FreeResultTemplates )( 
            ISearchableVirtualList * This,
            /* [size_is][in] */ IItemTemplate **rgpTemplates,
            /* [in] */ UINT cTemplates);
        
        HRESULT ( STDMETHODCALLTYPE *SetRelatedItem )( 
            ISearchableVirtualList * This,
            /* [in] */ ICategorizedVirtualItem *pRelatedItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelatedItem )( 
            ISearchableVirtualList * This,
            /* [retval][out] */ ICategorizedVirtualItem **ppRelatedItem);
        
        HRESULT ( STDMETHODCALLTYPE *SetRawFilterString )( 
            ISearchableVirtualList * This,
            /* [in] */ LPCWSTR pszDeterminedFilterChars,
            /* [in] */ LPCWSTR pszUndeterminedFilterChars,
            /* [in] */ GUID *pguidKeyboard);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ISearchableVirtualList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            ISearchableVirtualList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            ISearchableVirtualList * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsPaused )( 
            ISearchableVirtualList * This,
            /* [retval][out] */ BOOL *pfIsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *IsBackgroundProcessing )( 
            ISearchableVirtualList * This,
            /* [retval][out] */ BOOL *pfIsProcessing);
        
        END_INTERFACE
    } ISearchableVirtualListVtbl;

    interface ISearchableVirtualList
    {
        CONST_VTBL struct ISearchableVirtualListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchableVirtualList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchableVirtualList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchableVirtualList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchableVirtualList_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define ISearchableVirtualList_GetItem(This,iItem,ppviItem)	\
    ( (This)->lpVtbl -> GetItem(This,iItem,ppviItem) ) 

#define ISearchableVirtualList_CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs)	\
    ( (This)->lpVtbl -> CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs) ) 

#define ISearchableVirtualList_GetProperty(This,dwListPropertyID,pListPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwListPropertyID,pListPropertyValue) ) 

#define ISearchableVirtualList_GetFilterString(This,pszFilter,pcchFilter)	\
    ( (This)->lpVtbl -> GetFilterString(This,pszFilter,pcchFilter) ) 

#define ISearchableVirtualList_SetFilterString(This,pszFilter)	\
    ( (This)->lpVtbl -> SetFilterString(This,pszFilter) ) 

#define ISearchableVirtualList_GetSortPropertyID(This,pdwPropertyID)	\
    ( (This)->lpVtbl -> GetSortPropertyID(This,pdwPropertyID) ) 

#define ISearchableVirtualList_GetSortDirection(This,plsdir)	\
    ( (This)->lpVtbl -> GetSortDirection(This,plsdir) ) 

#define ISearchableVirtualList_GetSupportedSortCount(This,pcSort)	\
    ( (This)->lpVtbl -> GetSupportedSortCount(This,pcSort) ) 

#define ISearchableVirtualList_GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID)	\
    ( (This)->lpVtbl -> GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID) ) 

#define ISearchableVirtualList_GetSupportedSortDirection(This,iSortProperty,plsdir)	\
    ( (This)->lpVtbl -> GetSupportedSortDirection(This,iSortProperty,plsdir) ) 

#define ISearchableVirtualList_ApplySort(This,dwPropertyID,lsdir)	\
    ( (This)->lpVtbl -> ApplySort(This,dwPropertyID,lsdir) ) 

#define ISearchableVirtualList_RemoveSort(This)	\
    ( (This)->lpVtbl -> RemoveSort(This) ) 

#define ISearchableVirtualList_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define ISearchableVirtualList_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define ISearchableVirtualList_SetResultTemplates(This,rgpTemplates,cTemplates)	\
    ( (This)->lpVtbl -> SetResultTemplates(This,rgpTemplates,cTemplates) ) 

#define ISearchableVirtualList_GetResultTemplates(This,prgpTemplates,pcTemplates)	\
    ( (This)->lpVtbl -> GetResultTemplates(This,prgpTemplates,pcTemplates) ) 

#define ISearchableVirtualList_FreeResultTemplates(This,rgpTemplates,cTemplates)	\
    ( (This)->lpVtbl -> FreeResultTemplates(This,rgpTemplates,cTemplates) ) 

#define ISearchableVirtualList_SetRelatedItem(This,pRelatedItem)	\
    ( (This)->lpVtbl -> SetRelatedItem(This,pRelatedItem) ) 

#define ISearchableVirtualList_GetRelatedItem(This,ppRelatedItem)	\
    ( (This)->lpVtbl -> GetRelatedItem(This,ppRelatedItem) ) 

#define ISearchableVirtualList_SetRawFilterString(This,pszDeterminedFilterChars,pszUndeterminedFilterChars,pguidKeyboard)	\
    ( (This)->lpVtbl -> SetRawFilterString(This,pszDeterminedFilterChars,pszUndeterminedFilterChars,pguidKeyboard) ) 

#define ISearchableVirtualList_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define ISearchableVirtualList_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define ISearchableVirtualList_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define ISearchableVirtualList_IsPaused(This,pfIsPaused)	\
    ( (This)->lpVtbl -> IsPaused(This,pfIsPaused) ) 

#define ISearchableVirtualList_IsBackgroundProcessing(This,pfIsProcessing)	\
    ( (This)->lpVtbl -> IsBackgroundProcessing(This,pfIsProcessing) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchableVirtualList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_searchobj_0000_0006 */
/* [local] */ 

HRESULT ResetSearchState( 
    /* [in] */ ISearchableVirtualList *pList);



// Searchable list has started doing background processing
#define VSEARCHLISTEVENT_BACKGROUNDPROCSTART     0x00000020

// Searchable list has finished doing background processing
#define VSEARCHLISTEVENT_BACKGROUNDPROCEND       0x00000021


// Failure code meaning that no more data is available
#define E_NO_MORE_ITEMS                 HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)



extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0006_v0_0_s_ifspec;

#ifndef __ISupplierThreadWorker_INTERFACE_DEFINED__
#define __ISupplierThreadWorker_INTERFACE_DEFINED__

/* interface ISupplierThreadWorker */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISupplierThreadWorker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bf62e5cc-471a-4257-ac63-47201bf9602d")
    ISupplierThreadWorker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoWorkUnit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISupplierThreadWorkerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISupplierThreadWorker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISupplierThreadWorker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISupplierThreadWorker * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin )( 
            ISupplierThreadWorker * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoWorkUnit )( 
            ISupplierThreadWorker * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            ISupplierThreadWorker * This);
        
        END_INTERFACE
    } ISupplierThreadWorkerVtbl;

    interface ISupplierThreadWorker
    {
        CONST_VTBL struct ISupplierThreadWorkerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISupplierThreadWorker_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISupplierThreadWorker_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISupplierThreadWorker_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISupplierThreadWorker_Begin(This)	\
    ( (This)->lpVtbl -> Begin(This) ) 

#define ISupplierThreadWorker_DoWorkUnit(This)	\
    ( (This)->lpVtbl -> DoWorkUnit(This) ) 

#define ISupplierThreadWorker_End(This)	\
    ( (This)->lpVtbl -> End(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISupplierThreadWorker_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_searchobj_0000_0007 */
/* [local] */ 


// Default ID for thread worker objects scheduled through
// ISupplierThreadWorkerScheduler.ScheduleThreadWorker
#define GUID_THREADWORKREQUEST_DEFAULT       GUID_NULL




extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_searchobj_0000_0007_v0_0_s_ifspec;

#ifndef __ISupplierThreadWorkerScheduler_INTERFACE_DEFINED__
#define __ISupplierThreadWorkerScheduler_INTERFACE_DEFINED__

/* interface ISupplierThreadWorkerScheduler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISupplierThreadWorkerScheduler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4da71e54-8395-4bc7-80fd-80508ee6902a")
    ISupplierThreadWorkerScheduler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScheduleThreadWorker( 
            /* [in] */ ISupplierThreadWorker *pWorker,
            /* [in] */ REFGUID guidRequest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISupplierThreadWorkerSchedulerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISupplierThreadWorkerScheduler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISupplierThreadWorkerScheduler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISupplierThreadWorkerScheduler * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScheduleThreadWorker )( 
            ISupplierThreadWorkerScheduler * This,
            /* [in] */ ISupplierThreadWorker *pWorker,
            /* [in] */ REFGUID guidRequest);
        
        END_INTERFACE
    } ISupplierThreadWorkerSchedulerVtbl;

    interface ISupplierThreadWorkerScheduler
    {
        CONST_VTBL struct ISupplierThreadWorkerSchedulerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISupplierThreadWorkerScheduler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISupplierThreadWorkerScheduler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISupplierThreadWorkerScheduler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISupplierThreadWorkerScheduler_ScheduleThreadWorker(This,pWorker,guidRequest)	\
    ( (This)->lpVtbl -> ScheduleThreadWorker(This,pWorker,guidRequest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISupplierThreadWorkerScheduler_INTERFACE_DEFINED__ */


#ifndef __IItemSupplier_INTERFACE_DEFINED__
#define __IItemSupplier_INTERFACE_DEFINED__

/* interface IItemSupplier */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IItemSupplier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0fcc1fa9-b9f0-453c-9621-acce9d841f4c")
    IItemSupplier : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ UINT *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ UINT iItem,
            /* [retval][out] */ ICategorizedVirtualItem **ppcviItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CacheItemsHint( 
            /* [in] */ UINT iFirstItem,
            /* [in] */ UINT cItems,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE Unlock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD dwListPropertyID,
            /* [retval][out] */ PROPVARIANT *pListPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedSortCount( 
            /* [retval][out] */ UINT *pcSort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedSortPropertyID( 
            /* [in] */ UINT iSortProperty,
            /* [retval][out] */ DWORD *pdwSortPropertyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedSortDirection( 
            /* [in] */ UINT iSortProperty,
            /* [out] */ LISTSORTDIRECTION *plsdir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadWorkerScheduler( 
            /* [in] */ ISupplierThreadWorkerScheduler *pThreadWorkerScheduler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplySort( 
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LISTSORTDIRECTION lsdir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilterString( 
            /* [in] */ LPCOLESTR pszFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbSource( 
            /* [retval][out] */ IVerbSource **ppVerbSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeNotificationEvent( 
            /* [out] */ IEvent **ppEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemSupplierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IItemSupplier * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IItemSupplier * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IItemSupplier * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IItemSupplier * This,
            /* [retval][out] */ UINT *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IItemSupplier * This,
            /* [in] */ UINT iItem,
            /* [retval][out] */ ICategorizedVirtualItem **ppcviItem);
        
        HRESULT ( STDMETHODCALLTYPE *CacheItemsHint )( 
            IItemSupplier * This,
            /* [in] */ UINT iFirstItem,
            /* [in] */ UINT cItems,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs);
        
        /* [local] */ void ( STDMETHODCALLTYPE *Lock )( 
            IItemSupplier * This);
        
        /* [local] */ void ( STDMETHODCALLTYPE *Unlock )( 
            IItemSupplier * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IItemSupplier * This,
            /* [in] */ DWORD dwListPropertyID,
            /* [retval][out] */ PROPVARIANT *pListPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortCount )( 
            IItemSupplier * This,
            /* [retval][out] */ UINT *pcSort);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortPropertyID )( 
            IItemSupplier * This,
            /* [in] */ UINT iSortProperty,
            /* [retval][out] */ DWORD *pdwSortPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortDirection )( 
            IItemSupplier * This,
            /* [in] */ UINT iSortProperty,
            /* [out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadWorkerScheduler )( 
            IItemSupplier * This,
            /* [in] */ ISupplierThreadWorkerScheduler *pThreadWorkerScheduler);
        
        HRESULT ( STDMETHODCALLTYPE *ApplySort )( 
            IItemSupplier * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LISTSORTDIRECTION lsdir);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSort )( 
            IItemSupplier * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterString )( 
            IItemSupplier * This,
            /* [in] */ LPCOLESTR pszFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IItemSupplier * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IItemSupplier * This,
            /* [out] */ IEvent **ppEvent);
        
        END_INTERFACE
    } IItemSupplierVtbl;

    interface IItemSupplier
    {
        CONST_VTBL struct IItemSupplierVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItemSupplier_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IItemSupplier_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IItemSupplier_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IItemSupplier_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IItemSupplier_GetItem(This,iItem,ppcviItem)	\
    ( (This)->lpVtbl -> GetItem(This,iItem,ppcviItem) ) 

#define IItemSupplier_CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs)	\
    ( (This)->lpVtbl -> CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs) ) 

#define IItemSupplier_Lock(This)	\
    ( (This)->lpVtbl -> Lock(This) ) 

#define IItemSupplier_Unlock(This)	\
    ( (This)->lpVtbl -> Unlock(This) ) 

#define IItemSupplier_GetProperty(This,dwListPropertyID,pListPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwListPropertyID,pListPropertyValue) ) 

#define IItemSupplier_GetSupportedSortCount(This,pcSort)	\
    ( (This)->lpVtbl -> GetSupportedSortCount(This,pcSort) ) 

#define IItemSupplier_GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID)	\
    ( (This)->lpVtbl -> GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID) ) 

#define IItemSupplier_GetSupportedSortDirection(This,iSortProperty,plsdir)	\
    ( (This)->lpVtbl -> GetSupportedSortDirection(This,iSortProperty,plsdir) ) 

#define IItemSupplier_SetThreadWorkerScheduler(This,pThreadWorkerScheduler)	\
    ( (This)->lpVtbl -> SetThreadWorkerScheduler(This,pThreadWorkerScheduler) ) 

#define IItemSupplier_ApplySort(This,dwPropertyID,lsdir)	\
    ( (This)->lpVtbl -> ApplySort(This,dwPropertyID,lsdir) ) 

#define IItemSupplier_RemoveSort(This)	\
    ( (This)->lpVtbl -> RemoveSort(This) ) 

#define IItemSupplier_SetFilterString(This,pszFilter)	\
    ( (This)->lpVtbl -> SetFilterString(This,pszFilter) ) 

#define IItemSupplier_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IItemSupplier_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IItemSupplier_INTERFACE_DEFINED__ */


#ifndef __IRestrictableItemSupplier_INTERFACE_DEFINED__
#define __IRestrictableItemSupplier_INTERFACE_DEFINED__

/* interface IRestrictableItemSupplier */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRestrictableItemSupplier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("efabebaa-1664-46bd-bd26-2d72bfcec71c")
    IRestrictableItemSupplier : public IItemSupplier
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetResultTemplates( 
            /* [size_is][in] */ IItemTemplate **rgpTemplates,
            /* [in] */ UINT cTemplates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelatedItem( 
            /* [in] */ ICategorizedVirtualItem *pRelatedItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRestrictableItemSupplierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRestrictableItemSupplier * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRestrictableItemSupplier * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRestrictableItemSupplier * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IRestrictableItemSupplier * This,
            /* [retval][out] */ UINT *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IRestrictableItemSupplier * This,
            /* [in] */ UINT iItem,
            /* [retval][out] */ ICategorizedVirtualItem **ppcviItem);
        
        HRESULT ( STDMETHODCALLTYPE *CacheItemsHint )( 
            IRestrictableItemSupplier * This,
            /* [in] */ UINT iFirstItem,
            /* [in] */ UINT cItems,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs);
        
        /* [local] */ void ( STDMETHODCALLTYPE *Lock )( 
            IRestrictableItemSupplier * This);
        
        /* [local] */ void ( STDMETHODCALLTYPE *Unlock )( 
            IRestrictableItemSupplier * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IRestrictableItemSupplier * This,
            /* [in] */ DWORD dwListPropertyID,
            /* [retval][out] */ PROPVARIANT *pListPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortCount )( 
            IRestrictableItemSupplier * This,
            /* [retval][out] */ UINT *pcSort);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortPropertyID )( 
            IRestrictableItemSupplier * This,
            /* [in] */ UINT iSortProperty,
            /* [retval][out] */ DWORD *pdwSortPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortDirection )( 
            IRestrictableItemSupplier * This,
            /* [in] */ UINT iSortProperty,
            /* [out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadWorkerScheduler )( 
            IRestrictableItemSupplier * This,
            /* [in] */ ISupplierThreadWorkerScheduler *pThreadWorkerScheduler);
        
        HRESULT ( STDMETHODCALLTYPE *ApplySort )( 
            IRestrictableItemSupplier * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LISTSORTDIRECTION lsdir);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSort )( 
            IRestrictableItemSupplier * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterString )( 
            IRestrictableItemSupplier * This,
            /* [in] */ LPCOLESTR pszFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IRestrictableItemSupplier * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IRestrictableItemSupplier * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetResultTemplates )( 
            IRestrictableItemSupplier * This,
            /* [size_is][in] */ IItemTemplate **rgpTemplates,
            /* [in] */ UINT cTemplates);
        
        HRESULT ( STDMETHODCALLTYPE *SetRelatedItem )( 
            IRestrictableItemSupplier * This,
            /* [in] */ ICategorizedVirtualItem *pRelatedItem);
        
        END_INTERFACE
    } IRestrictableItemSupplierVtbl;

    interface IRestrictableItemSupplier
    {
        CONST_VTBL struct IRestrictableItemSupplierVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRestrictableItemSupplier_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRestrictableItemSupplier_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRestrictableItemSupplier_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRestrictableItemSupplier_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IRestrictableItemSupplier_GetItem(This,iItem,ppcviItem)	\
    ( (This)->lpVtbl -> GetItem(This,iItem,ppcviItem) ) 

#define IRestrictableItemSupplier_CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs)	\
    ( (This)->lpVtbl -> CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs) ) 

#define IRestrictableItemSupplier_Lock(This)	\
    ( (This)->lpVtbl -> Lock(This) ) 

#define IRestrictableItemSupplier_Unlock(This)	\
    ( (This)->lpVtbl -> Unlock(This) ) 

#define IRestrictableItemSupplier_GetProperty(This,dwListPropertyID,pListPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwListPropertyID,pListPropertyValue) ) 

#define IRestrictableItemSupplier_GetSupportedSortCount(This,pcSort)	\
    ( (This)->lpVtbl -> GetSupportedSortCount(This,pcSort) ) 

#define IRestrictableItemSupplier_GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID)	\
    ( (This)->lpVtbl -> GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID) ) 

#define IRestrictableItemSupplier_GetSupportedSortDirection(This,iSortProperty,plsdir)	\
    ( (This)->lpVtbl -> GetSupportedSortDirection(This,iSortProperty,plsdir) ) 

#define IRestrictableItemSupplier_SetThreadWorkerScheduler(This,pThreadWorkerScheduler)	\
    ( (This)->lpVtbl -> SetThreadWorkerScheduler(This,pThreadWorkerScheduler) ) 

#define IRestrictableItemSupplier_ApplySort(This,dwPropertyID,lsdir)	\
    ( (This)->lpVtbl -> ApplySort(This,dwPropertyID,lsdir) ) 

#define IRestrictableItemSupplier_RemoveSort(This)	\
    ( (This)->lpVtbl -> RemoveSort(This) ) 

#define IRestrictableItemSupplier_SetFilterString(This,pszFilter)	\
    ( (This)->lpVtbl -> SetFilterString(This,pszFilter) ) 

#define IRestrictableItemSupplier_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IRestrictableItemSupplier_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define IRestrictableItemSupplier_SetResultTemplates(This,rgpTemplates,cTemplates)	\
    ( (This)->lpVtbl -> SetResultTemplates(This,rgpTemplates,cTemplates) ) 

#define IRestrictableItemSupplier_SetRelatedItem(This,pRelatedItem)	\
    ( (This)->lpVtbl -> SetRelatedItem(This,pRelatedItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRestrictableItemSupplier_INTERFACE_DEFINED__ */


#ifndef __IItemSupplierWithRawStringFiltering_INTERFACE_DEFINED__
#define __IItemSupplierWithRawStringFiltering_INTERFACE_DEFINED__

/* interface IItemSupplierWithRawStringFiltering */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IItemSupplierWithRawStringFiltering;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a8726587-c87e-4216-a83b-312cedb0f9c6")
    IItemSupplierWithRawStringFiltering : public IItemSupplier
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRawFilterString( 
            /* [in] */ LPCWSTR pszDeterminedFilterChars,
            /* [in] */ LPCWSTR pszUndeterminedFilterChars,
            /* [in] */ GUID *pguidKeyboard) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemSupplierWithRawStringFilteringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IItemSupplierWithRawStringFiltering * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IItemSupplierWithRawStringFiltering * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [retval][out] */ UINT *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ UINT iItem,
            /* [retval][out] */ ICategorizedVirtualItem **ppcviItem);
        
        HRESULT ( STDMETHODCALLTYPE *CacheItemsHint )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ UINT iFirstItem,
            /* [in] */ UINT cItems,
            /* [size_is][in] */ const DWORD *rgdwPropertyIDs,
            /* [in] */ UINT cPropertyIDs);
        
        /* [local] */ void ( STDMETHODCALLTYPE *Lock )( 
            IItemSupplierWithRawStringFiltering * This);
        
        /* [local] */ void ( STDMETHODCALLTYPE *Unlock )( 
            IItemSupplierWithRawStringFiltering * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ DWORD dwListPropertyID,
            /* [retval][out] */ PROPVARIANT *pListPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortCount )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [retval][out] */ UINT *pcSort);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortPropertyID )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ UINT iSortProperty,
            /* [retval][out] */ DWORD *pdwSortPropertyID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedSortDirection )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ UINT iSortProperty,
            /* [out] */ LISTSORTDIRECTION *plsdir);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadWorkerScheduler )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ ISupplierThreadWorkerScheduler *pThreadWorkerScheduler);
        
        HRESULT ( STDMETHODCALLTYPE *ApplySort )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ LISTSORTDIRECTION lsdir);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSort )( 
            IItemSupplierWithRawStringFiltering * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterString )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ LPCOLESTR pszFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [retval][out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetRawFilterString )( 
            IItemSupplierWithRawStringFiltering * This,
            /* [in] */ LPCWSTR pszDeterminedFilterChars,
            /* [in] */ LPCWSTR pszUndeterminedFilterChars,
            /* [in] */ GUID *pguidKeyboard);
        
        END_INTERFACE
    } IItemSupplierWithRawStringFilteringVtbl;

    interface IItemSupplierWithRawStringFiltering
    {
        CONST_VTBL struct IItemSupplierWithRawStringFilteringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItemSupplierWithRawStringFiltering_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IItemSupplierWithRawStringFiltering_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IItemSupplierWithRawStringFiltering_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IItemSupplierWithRawStringFiltering_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IItemSupplierWithRawStringFiltering_GetItem(This,iItem,ppcviItem)	\
    ( (This)->lpVtbl -> GetItem(This,iItem,ppcviItem) ) 

#define IItemSupplierWithRawStringFiltering_CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs)	\
    ( (This)->lpVtbl -> CacheItemsHint(This,iFirstItem,cItems,rgdwPropertyIDs,cPropertyIDs) ) 

#define IItemSupplierWithRawStringFiltering_Lock(This)	\
    ( (This)->lpVtbl -> Lock(This) ) 

#define IItemSupplierWithRawStringFiltering_Unlock(This)	\
    ( (This)->lpVtbl -> Unlock(This) ) 

#define IItemSupplierWithRawStringFiltering_GetProperty(This,dwListPropertyID,pListPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwListPropertyID,pListPropertyValue) ) 

#define IItemSupplierWithRawStringFiltering_GetSupportedSortCount(This,pcSort)	\
    ( (This)->lpVtbl -> GetSupportedSortCount(This,pcSort) ) 

#define IItemSupplierWithRawStringFiltering_GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID)	\
    ( (This)->lpVtbl -> GetSupportedSortPropertyID(This,iSortProperty,pdwSortPropertyID) ) 

#define IItemSupplierWithRawStringFiltering_GetSupportedSortDirection(This,iSortProperty,plsdir)	\
    ( (This)->lpVtbl -> GetSupportedSortDirection(This,iSortProperty,plsdir) ) 

#define IItemSupplierWithRawStringFiltering_SetThreadWorkerScheduler(This,pThreadWorkerScheduler)	\
    ( (This)->lpVtbl -> SetThreadWorkerScheduler(This,pThreadWorkerScheduler) ) 

#define IItemSupplierWithRawStringFiltering_ApplySort(This,dwPropertyID,lsdir)	\
    ( (This)->lpVtbl -> ApplySort(This,dwPropertyID,lsdir) ) 

#define IItemSupplierWithRawStringFiltering_RemoveSort(This)	\
    ( (This)->lpVtbl -> RemoveSort(This) ) 

#define IItemSupplierWithRawStringFiltering_SetFilterString(This,pszFilter)	\
    ( (This)->lpVtbl -> SetFilterString(This,pszFilter) ) 

#define IItemSupplierWithRawStringFiltering_GetVerbSource(This,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,ppVerbSource) ) 

#define IItemSupplierWithRawStringFiltering_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 


#define IItemSupplierWithRawStringFiltering_SetRawFilterString(This,pszDeterminedFilterChars,pszUndeterminedFilterChars,pguidKeyboard)	\
    ( (This)->lpVtbl -> SetRawFilterString(This,pszDeterminedFilterChars,pszUndeterminedFilterChars,pguidKeyboard) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IItemSupplierWithRawStringFiltering_INTERFACE_DEFINED__ */


#ifndef __IObjectWithProperties_INTERFACE_DEFINED__
#define __IObjectWithProperties_INTERFACE_DEFINED__

/* interface IObjectWithProperties */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObjectWithProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3730D9E2-BFA5-4bd2-81D5-EC2990FB6B08")
    IObjectWithProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD dwPropertyID,
            /* [retval][out] */ PROPVARIANT *pPropertyValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ const PROPVARIANT *pPropertyValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectWithProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectWithProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectWithProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IObjectWithProperties * This,
            /* [in] */ DWORD dwPropertyID,
            /* [retval][out] */ PROPVARIANT *pPropertyValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IObjectWithProperties * This,
            /* [in] */ DWORD dwPropertyID,
            /* [in] */ const PROPVARIANT *pPropertyValue);
        
        END_INTERFACE
    } IObjectWithPropertiesVtbl;

    interface IObjectWithProperties
    {
        CONST_VTBL struct IObjectWithPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithProperties_GetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwPropertyID,pPropertyValue) ) 

#define IObjectWithProperties_SetProperty(This,dwPropertyID,pPropertyValue)	\
    ( (This)->lpVtbl -> SetProperty(This,dwPropertyID,pPropertyValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithProperties_INTERFACE_DEFINED__ */


#ifndef __IPausableObject_INTERFACE_DEFINED__
#define __IPausableObject_INTERFACE_DEFINED__

/* interface IPausableObject */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPausableObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("187bc38c-bfa0-437a-b49f-9ede30faf94f")
    IPausableObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPaused( 
            /* [retval][out] */ BOOL *pfIsPaused) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPausableObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPausableObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPausableObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPausableObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IPausableObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IPausableObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsPaused )( 
            IPausableObject * This,
            /* [retval][out] */ BOOL *pfIsPaused);
        
        END_INTERFACE
    } IPausableObjectVtbl;

    interface IPausableObject
    {
        CONST_VTBL struct IPausableObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPausableObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPausableObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPausableObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPausableObject_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IPausableObject_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IPausableObject_IsPaused(This,pfIsPaused)	\
    ( (This)->lpVtbl -> IsPaused(This,pfIsPaused) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPausableObject_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\search.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/***
*search.h - declarations for searcing/sorting routines
*
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\servprov.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:15:49 2007
 */
/* Compiler settings for ..\servprov.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __servprov_h__
#define __servprov_h__

/* Forward Declarations */ 

#ifndef __IServiceProvider_FWD_DEFINED__
#define __IServiceProvider_FWD_DEFINED__
typedef interface IServiceProvider IServiceProvider;
#endif 	/* __IServiceProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_servprov_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ServProv.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IServiceProvider Interfaces.




extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_v0_0_s_ifspec;

#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED__

/* interface IServiceProvider */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IServiceProvider __RPC_FAR *LPSERVICEPROVIDER;

#if (_MSC_VER >= 1100) && defined(__cplusplus) && !defined(CINTERFACE)
    EXTERN_C const IID IID_IServiceProvider;
    extern "C++"
    {
        MIDL_INTERFACE("6d5140c1-7436-11ce-8034-00aa006009fa")
        IServiceProvider : public IUnknown
        {
        public:
            virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
                /* [in] */ REFGUID guidService,
                /* [in] */ REFIID riid,
                /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
            
            template <class Q>
            HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, Q** pp)
            {
                return QueryService(guidService, __uuidof(Q), (void **)pp);
            }
        };
    }

    /* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
        IServiceProvider __RPC_FAR * This,
        /* [in] */ REFGUID guidService,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);

    void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);

#else // VC6 Hack

EXTERN_C const IID IID_IServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d5140c1-7436-11ce-8034-00aa006009fa")
    IServiceProvider : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServiceProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServiceProvider __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryService )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } IServiceProviderVtbl;

    interface IServiceProvider
    {
        CONST_VTBL struct IServiceProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServiceProvider_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServiceProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_servprov_0057 */
/* [local] */ 

#endif // VC6 Hack


extern RPC_IF_HANDLE __MIDL_itf_servprov_0057_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0057_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Stub( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\setjmp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#include "stdlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\shappmgr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Tue Jan 23 14:31:01 2007
 */
/* Compiler settings for ..\shappmgr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shappmgr_h__
#define __shappmgr_h__

/* Forward Declarations */ 

#ifndef __IShellApp_FWD_DEFINED__
#define __IShellApp_FWD_DEFINED__
typedef interface IShellApp IShellApp;
#endif 	/* __IShellApp_FWD_DEFINED__ */


#ifndef __IPublishedApp_FWD_DEFINED__
#define __IPublishedApp_FWD_DEFINED__
typedef interface IPublishedApp IPublishedApp;
#endif 	/* __IPublishedApp_FWD_DEFINED__ */


#ifndef __IPublishedApp2_FWD_DEFINED__
#define __IPublishedApp2_FWD_DEFINED__
typedef interface IPublishedApp2 IPublishedApp2;
#endif 	/* __IPublishedApp2_FWD_DEFINED__ */


#ifndef __IEnumPublishedApps_FWD_DEFINED__
#define __IEnumPublishedApps_FWD_DEFINED__
typedef interface IEnumPublishedApps IEnumPublishedApps;
#endif 	/* __IEnumPublishedApps_FWD_DEFINED__ */


#ifndef __IAppPublisher_FWD_DEFINED__
#define __IAppPublisher_FWD_DEFINED__
typedef interface IAppPublisher IAppPublisher;
#endif 	/* __IAppPublisher_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "appmgmt.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_shappmgr_0000 */
/* [local] */ 

#ifndef _SHAPPMGR_H_
#define _SHAPPMGR_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgr_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgr_0000_v0_0_s_ifspec;

#ifndef __IShellApp_INTERFACE_DEFINED__
#define __IShellApp_INTERFACE_DEFINED__

/* interface IShellApp */
/* [object][uuid] */ 

typedef 
enum _tagAppInfoFlags
    {	AIM_DISPLAYNAME	= 0x1,
	AIM_VERSION	= 0x2,
	AIM_PUBLISHER	= 0x4,
	AIM_PRODUCTID	= 0x8,
	AIM_REGISTEREDOWNER	= 0x10,
	AIM_REGISTEREDCOMPANY	= 0x20,
	AIM_LANGUAGE	= 0x40,
	AIM_SUPPORTURL	= 0x80,
	AIM_SUPPORTTELEPHONE	= 0x100,
	AIM_HELPLINK	= 0x200,
	AIM_INSTALLLOCATION	= 0x400,
	AIM_INSTALLSOURCE	= 0x800,
	AIM_INSTALLDATE	= 0x1000,
	AIM_CONTACT	= 0x4000,
	AIM_COMMENTS	= 0x8000,
	AIM_IMAGE	= 0x20000,
	AIM_READMEURL	= 0x40000,
	AIM_UPDATEINFOURL	= 0x80000
    }	APPINFODATAFLAGS;

typedef struct _AppInfoData
    {
    DWORD cbSize;
    DWORD dwMask;
    LPWSTR pszDisplayName;
    LPWSTR pszVersion;
    LPWSTR pszPublisher;
    LPWSTR pszProductID;
    LPWSTR pszRegisteredOwner;
    LPWSTR pszRegisteredCompany;
    LPWSTR pszLanguage;
    LPWSTR pszSupportUrl;
    LPWSTR pszSupportTelephone;
    LPWSTR pszHelpLink;
    LPWSTR pszInstallLocation;
    LPWSTR pszInstallSource;
    LPWSTR pszInstallDate;
    LPWSTR pszContact;
    LPWSTR pszComments;
    LPWSTR pszImage;
    LPWSTR pszReadmeUrl;
    LPWSTR pszUpdateInfoUrl;
    }	APPINFODATA;

typedef struct _AppInfoData __RPC_FAR *PAPPINFODATA;

typedef 
enum _tagAppActionFlags
    {	APPACTION_INSTALL	= 0x1,
	APPACTION_UNINSTALL	= 0x2,
	APPACTION_MODIFY	= 0x4,
	APPACTION_REPAIR	= 0x8,
	APPACTION_UPGRADE	= 0x10,
	APPACTION_CANGETSIZE	= 0x20,
	APPACTION_MODIFYREMOVE	= 0x80,
	APPACTION_ADDLATER	= 0x100,
	APPACTION_UNSCHEDULE	= 0x200
    }	APPACTIONFLAGS;

typedef struct _tagSlowAppInfo
    {
    ULONGLONG ullSize;
    FILETIME ftLastUsed;
    int iTimesUsed;
    LPWSTR pszImage;
    }	SLOWAPPINFO;

typedef struct _tagSlowAppInfo __RPC_FAR *PSLOWAPPINFO;


EXTERN_C const IID IID_IShellApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3E14960-935F-11D1-B8B8-006008059382")
    IShellApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAppInfo( 
            /* [out][in] */ PAPPINFODATA pai) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPossibleActions( 
            /* [out] */ DWORD __RPC_FAR *pdwActions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSlowAppInfo( 
            /* [in] */ PSLOWAPPINFO psaid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedSlowAppInfo( 
            /* [in] */ PSLOWAPPINFO psaid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsInstalled( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAppInfo )( 
            IShellApp __RPC_FAR * This,
            /* [out][in] */ PAPPINFODATA pai);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPossibleActions )( 
            IShellApp __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwActions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSlowAppInfo )( 
            IShellApp __RPC_FAR * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCachedSlowAppInfo )( 
            IShellApp __RPC_FAR * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsInstalled )( 
            IShellApp __RPC_FAR * This);
        
        END_INTERFACE
    } IShellAppVtbl;

    interface IShellApp
    {
        CONST_VTBL struct IShellAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellApp_GetAppInfo(This,pai)	\
    (This)->lpVtbl -> GetAppInfo(This,pai)

#define IShellApp_GetPossibleActions(This,pdwActions)	\
    (This)->lpVtbl -> GetPossibleActions(This,pdwActions)

#define IShellApp_GetSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetSlowAppInfo(This,psaid)

#define IShellApp_GetCachedSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetCachedSlowAppInfo(This,psaid)

#define IShellApp_IsInstalled(This)	\
    (This)->lpVtbl -> IsInstalled(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellApp_GetAppInfo_Proxy( 
    IShellApp __RPC_FAR * This,
    /* [out][in] */ PAPPINFODATA pai);


void __RPC_STUB IShellApp_GetAppInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellApp_GetPossibleActions_Proxy( 
    IShellApp __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwActions);


void __RPC_STUB IShellApp_GetPossibleActions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellApp_GetSlowAppInfo_Proxy( 
    IShellApp __RPC_FAR * This,
    /* [in] */ PSLOWAPPINFO psaid);


void __RPC_STUB IShellApp_GetSlowAppInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellApp_GetCachedSlowAppInfo_Proxy( 
    IShellApp __RPC_FAR * This,
    /* [in] */ PSLOWAPPINFO psaid);


void __RPC_STUB IShellApp_GetCachedSlowAppInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellApp_IsInstalled_Proxy( 
    IShellApp __RPC_FAR * This);


void __RPC_STUB IShellApp_IsInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellApp_INTERFACE_DEFINED__ */


#ifndef __IPublishedApp_INTERFACE_DEFINED__
#define __IPublishedApp_INTERFACE_DEFINED__

/* interface IPublishedApp */
/* [object][uuid] */ 

typedef 
enum _tagPublishedAppInfoFlags
    {	PAI_SOURCE	= 0x1,
	PAI_ASSIGNEDTIME	= 0x2,
	PAI_PUBLISHEDTIME	= 0x4,
	PAI_SCHEDULEDTIME	= 0x8,
	PAI_EXPIRETIME	= 0x10
    }	PUBAPPINFOFLAGS;

typedef struct _PubAppInfo
    {
    DWORD cbSize;
    DWORD dwMask;
    LPWSTR pszSource;
    SYSTEMTIME stAssigned;
    SYSTEMTIME stPublished;
    SYSTEMTIME stScheduled;
    SYSTEMTIME stExpire;
    }	PUBAPPINFO;

typedef struct _PubAppInfo __RPC_FAR *PPUBAPPINFO;


EXTERN_C const IID IID_IPublishedApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BC752E0-9046-11D1-B8B3-006008059382")
    IPublishedApp : public IShellApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Install( 
            /* [in] */ LPSYSTEMTIME pstInstall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPublishedAppInfo( 
            /* [out][in] */ PPUBAPPINFO ppai) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unschedule( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPublishedAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPublishedApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPublishedApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPublishedApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAppInfo )( 
            IPublishedApp __RPC_FAR * This,
            /* [out][in] */ PAPPINFODATA pai);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPossibleActions )( 
            IPublishedApp __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwActions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSlowAppInfo )( 
            IPublishedApp __RPC_FAR * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCachedSlowAppInfo )( 
            IPublishedApp __RPC_FAR * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsInstalled )( 
            IPublishedApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Install )( 
            IPublishedApp __RPC_FAR * This,
            /* [in] */ LPSYSTEMTIME pstInstall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPublishedAppInfo )( 
            IPublishedApp __RPC_FAR * This,
            /* [out][in] */ PPUBAPPINFO ppai);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unschedule )( 
            IPublishedApp __RPC_FAR * This);
        
        END_INTERFACE
    } IPublishedAppVtbl;

    interface IPublishedApp
    {
        CONST_VTBL struct IPublishedAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPublishedApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPublishedApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPublishedApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPublishedApp_GetAppInfo(This,pai)	\
    (This)->lpVtbl -> GetAppInfo(This,pai)

#define IPublishedApp_GetPossibleActions(This,pdwActions)	\
    (This)->lpVtbl -> GetPossibleActions(This,pdwActions)

#define IPublishedApp_GetSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetSlowAppInfo(This,psaid)

#define IPublishedApp_GetCachedSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetCachedSlowAppInfo(This,psaid)

#define IPublishedApp_IsInstalled(This)	\
    (This)->lpVtbl -> IsInstalled(This)


#define IPublishedApp_Install(This,pstInstall)	\
    (This)->lpVtbl -> Install(This,pstInstall)

#define IPublishedApp_GetPublishedAppInfo(This,ppai)	\
    (This)->lpVtbl -> GetPublishedAppInfo(This,ppai)

#define IPublishedApp_Unschedule(This)	\
    (This)->lpVtbl -> Unschedule(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPublishedApp_Install_Proxy( 
    IPublishedApp __RPC_FAR * This,
    /* [in] */ LPSYSTEMTIME pstInstall);


void __RPC_STUB IPublishedApp_Install_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublishedApp_GetPublishedAppInfo_Proxy( 
    IPublishedApp __RPC_FAR * This,
    /* [out][in] */ PPUBAPPINFO ppai);


void __RPC_STUB IPublishedApp_GetPublishedAppInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublishedApp_Unschedule_Proxy( 
    IPublishedApp __RPC_FAR * This);


void __RPC_STUB IPublishedApp_Unschedule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPublishedApp_INTERFACE_DEFINED__ */


#ifndef __IPublishedApp2_INTERFACE_DEFINED__
#define __IPublishedApp2_INTERFACE_DEFINED__

/* interface IPublishedApp2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_IPublishedApp2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12B81347-1B3A-4A04-AA61-3F768B67FD7E")
    IPublishedApp2 : public IPublishedApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Install2( 
            /* [unique][in] */ LPSYSTEMTIME pstInstall,
            /* [unique][in] */ HWND hwndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPublishedApp2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPublishedApp2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPublishedApp2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPublishedApp2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAppInfo )( 
            IPublishedApp2 __RPC_FAR * This,
            /* [out][in] */ PAPPINFODATA pai);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPossibleActions )( 
            IPublishedApp2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwActions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSlowAppInfo )( 
            IPublishedApp2 __RPC_FAR * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCachedSlowAppInfo )( 
            IPublishedApp2 __RPC_FAR * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsInstalled )( 
            IPublishedApp2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Install )( 
            IPublishedApp2 __RPC_FAR * This,
            /* [in] */ LPSYSTEMTIME pstInstall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPublishedAppInfo )( 
            IPublishedApp2 __RPC_FAR * This,
            /* [out][in] */ PPUBAPPINFO ppai);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unschedule )( 
            IPublishedApp2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Install2 )( 
            IPublishedApp2 __RPC_FAR * This,
            /* [unique][in] */ LPSYSTEMTIME pstInstall,
            /* [unique][in] */ HWND hwndParent);
        
        END_INTERFACE
    } IPublishedApp2Vtbl;

    interface IPublishedApp2
    {
        CONST_VTBL struct IPublishedApp2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPublishedApp2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPublishedApp2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPublishedApp2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPublishedApp2_GetAppInfo(This,pai)	\
    (This)->lpVtbl -> GetAppInfo(This,pai)

#define IPublishedApp2_GetPossibleActions(This,pdwActions)	\
    (This)->lpVtbl -> GetPossibleActions(This,pdwActions)

#define IPublishedApp2_GetSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetSlowAppInfo(This,psaid)

#define IPublishedApp2_GetCachedSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetCachedSlowAppInfo(This,psaid)

#define IPublishedApp2_IsInstalled(This)	\
    (This)->lpVtbl -> IsInstalled(This)


#define IPublishedApp2_Install(This,pstInstall)	\
    (This)->lpVtbl -> Install(This,pstInstall)

#define IPublishedApp2_GetPublishedAppInfo(This,ppai)	\
    (This)->lpVtbl -> GetPublishedAppInfo(This,ppai)

#define IPublishedApp2_Unschedule(This)	\
    (This)->lpVtbl -> Unschedule(This)


#define IPublishedApp2_Install2(This,pstInstall,hwndParent)	\
    (This)->lpVtbl -> Install2(This,pstInstall,hwndParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPublishedApp2_Install2_Proxy( 
    IPublishedApp2 __RPC_FAR * This,
    /* [unique][in] */ LPSYSTEMTIME pstInstall,
    /* [unique][in] */ HWND hwndParent);


void __RPC_STUB IPublishedApp2_Install2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPublishedApp2_INTERFACE_DEFINED__ */


#ifndef __IEnumPublishedApps_INTERFACE_DEFINED__
#define __IEnumPublishedApps_INTERFACE_DEFINED__

/* interface IEnumPublishedApps */
/* [object][uuid] */ 


EXTERN_C const IID IID_IEnumPublishedApps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0B124F8C-91F0-11D1-B8B5-006008059382")
    IEnumPublishedApps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ IPublishedApp __RPC_FAR *__RPC_FAR *pia) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPublishedAppsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumPublishedApps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumPublishedApps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumPublishedApps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumPublishedApps __RPC_FAR * This,
            /* [out] */ IPublishedApp __RPC_FAR *__RPC_FAR *pia);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumPublishedApps __RPC_FAR * This);
        
        END_INTERFACE
    } IEnumPublishedAppsVtbl;

    interface IEnumPublishedApps
    {
        CONST_VTBL struct IEnumPublishedAppsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPublishedApps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPublishedApps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPublishedApps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPublishedApps_Next(This,pia)	\
    (This)->lpVtbl -> Next(This,pia)

#define IEnumPublishedApps_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPublishedApps_Next_Proxy( 
    IEnumPublishedApps __RPC_FAR * This,
    /* [out] */ IPublishedApp __RPC_FAR *__RPC_FAR *pia);


void __RPC_STUB IEnumPublishedApps_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPublishedApps_Reset_Proxy( 
    IEnumPublishedApps __RPC_FAR * This);


void __RPC_STUB IEnumPublishedApps_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPublishedApps_INTERFACE_DEFINED__ */


#ifndef __IAppPublisher_INTERFACE_DEFINED__
#define __IAppPublisher_INTERFACE_DEFINED__

/* interface IAppPublisher */
/* [object][uuid] */ 


EXTERN_C const IID IID_IAppPublisher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07250A10-9CF9-11D1-9076-006008059382")
    IAppPublisher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfCategories( 
            /* [out] */ DWORD __RPC_FAR *pdwCat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategories( 
            /* [out] */ APPCATEGORYINFOLIST __RPC_FAR *pAppCategoryList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfApps( 
            /* [out] */ DWORD __RPC_FAR *pdwApps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumApps( 
            /* [unique][in] */ GUID __RPC_FAR *pAppCategoryId,
            /* [out] */ IEnumPublishedApps __RPC_FAR *__RPC_FAR *ppepa) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppPublisherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAppPublisher __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAppPublisher __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAppPublisher __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfCategories )( 
            IAppPublisher __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCategories )( 
            IAppPublisher __RPC_FAR * This,
            /* [out] */ APPCATEGORYINFOLIST __RPC_FAR *pAppCategoryList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfApps )( 
            IAppPublisher __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwApps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumApps )( 
            IAppPublisher __RPC_FAR * This,
            /* [unique][in] */ GUID __RPC_FAR *pAppCategoryId,
            /* [out] */ IEnumPublishedApps __RPC_FAR *__RPC_FAR *ppepa);
        
        END_INTERFACE
    } IAppPublisherVtbl;

    interface IAppPublisher
    {
        CONST_VTBL struct IAppPublisherVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppPublisher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppPublisher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppPublisher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppPublisher_GetNumberOfCategories(This,pdwCat)	\
    (This)->lpVtbl -> GetNumberOfCategories(This,pdwCat)

#define IAppPublisher_GetCategories(This,pAppCategoryList)	\
    (This)->lpVtbl -> GetCategories(This,pAppCategoryList)

#define IAppPublisher_GetNumberOfApps(This,pdwApps)	\
    (This)->lpVtbl -> GetNumberOfApps(This,pdwApps)

#define IAppPublisher_EnumApps(This,pAppCategoryId,ppepa)	\
    (This)->lpVtbl -> EnumApps(This,pAppCategoryId,ppepa)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAppPublisher_GetNumberOfCategories_Proxy( 
    IAppPublisher __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCat);


void __RPC_STUB IAppPublisher_GetNumberOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppPublisher_GetCategories_Proxy( 
    IAppPublisher __RPC_FAR * This,
    /* [out] */ APPCATEGORYINFOLIST __RPC_FAR *pAppCategoryList);


void __RPC_STUB IAppPublisher_GetCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppPublisher_GetNumberOfApps_Proxy( 
    IAppPublisher __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwApps);


void __RPC_STUB IAppPublisher_GetNumberOfApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppPublisher_EnumApps_Proxy( 
    IAppPublisher __RPC_FAR * This,
    /* [unique][in] */ GUID __RPC_FAR *pAppCategoryId,
    /* [out] */ IEnumPublishedApps __RPC_FAR *__RPC_FAR *ppepa);


void __RPC_STUB IAppPublisher_EnumApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppPublisher_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shappmgr_0153 */
/* [local] */ 

#endif // _SHAPPMGR_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgr_0153_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgr_0153_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\settings.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for Settings.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __Settings_h__
#define __Settings_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICplController_FWD_DEFINED__
#define __ICplController_FWD_DEFINED__
typedef interface ICplController ICplController;
#endif 	/* __ICplController_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_Settings_0000_0000 */
/* [local] */ 

/*+-------------------------------------------------------------------------
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  Automatically generated by Midl from settings.idl
 *
 *  DO NOT EDIT THIS FILE.
 *
*/
#define E_CANCELLED     HRESULT_FROM_WIN32(ERROR_CANCELLED)

// ID for the setting application's central menu button.
// Applications that need to add custom menu items
// may use this ID to access the central menu.
#define SETTINGS_MENU   0x63

// ID sent in a WM_COMMAND message to the CPL window
// when the window is about to timeout, discarding changes.
#define ID_CPLTIMEOUT   WM_APP + 100

typedef 
enum tagCPL_TYPE
    {	CPL_TYPE_XML	= 0,
	CPL_TYPE_EXE	= 0x1,
	CPL_TYPE_LIST	= 0x2,
	CPL_TYPE_MAX	= CPL_TYPE_LIST
    } 	CPL_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_Settings_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_Settings_0000_0000_v0_0_s_ifspec;

#ifndef __ICplController_INTERFACE_DEFINED__
#define __ICplController_INTERFACE_DEFINED__

/* interface ICplController */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICplController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8BD6EEDA-8942-467d-8242-2E5EA57EC7AE")
    ICplController : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessDialogMessage( 
            /* [in] */ HWND hwndDlg,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [retval][out] */ VARIANT_BOOL *pfHandled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICplControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICplController * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICplController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICplController * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessDialogMessage )( 
            ICplController * This,
            /* [in] */ HWND hwndDlg,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [retval][out] */ VARIANT_BOOL *pfHandled);
        
        END_INTERFACE
    } ICplControllerVtbl;

    interface ICplController
    {
        CONST_VTBL struct ICplControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICplController_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICplController_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICplController_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICplController_ProcessDialogMessage(This,hwndDlg,uMsg,wParam,lParam,pfHandled)	\
    ( (This)->lpVtbl -> ProcessDialogMessage(This,hwndDlg,uMsg,wParam,lParam,pfHandled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICplController_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\shellapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
*                                                                             *
\*****************************************************************************/

#pragma once

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI


//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI


#include <pshpack1.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


// @CESYSGEN IF GWES_ICONCMN

#define EIRESID(x) (-1 * (int)(x))

#ifndef ExtractIconExA
HICON WINAPI ExtractIconExA(LPCSTR lpszFile, int nIconIndex, __out_opt HICON *phiconLarge, __out_opt HICON *phiconSmall, UINT nIcons);
#endif

#ifndef ExtractIconExW
HICON WINAPI ExtractIconExW(__in LPCWSTR lpszFile, int nIconIndex, __out_opt HICON *phiconLarge, __out_opt HICON *phiconSmall, UINT nIcons);
#endif

#ifdef UNICODE
#define ExtractIconEx  ExtractIconExW
#else
#define ExtractIconEx  ExtractIconExA
#endif // !UNICODE

// @CESYSGEN ENDIF


////
//// Shell File Operations
////

#ifndef FO_MOVE //these need to be kept in sync with the ones in shlobj.h

#define FO_MOVE           0x0001
#define FO_COPY           0x0002
#define FO_DELETE         0x0003
#define FO_RENAME         0x0004

#define FOF_MULTIDESTFILES         0x0001
#define FOF_CONFIRMMOUSE           0x0002
#define FOF_SILENT                 0x0004  // don't create progress/report
#define FOF_RENAMEONCOLLISION      0x0008
#define FOF_NOCONFIRMATION         0x0010  // Don't prompt the user.
#define FOF_WANTMAPPINGHANDLE      0x0020  // Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings
#define FOF_ALLOWUNDO              0x0040
#define FOF_FILESONLY              0x0080  // on *.*, do only files
#define FOF_SIMPLEPROGRESS         0x0100  // means don't show names of files
#define FOF_NOCONFIRMMKDIR         0x0200  // don't confirm making any needed dirs
#define FOF_NOERRORUI              0x0400  // don't put up error UI
#define FOF_NOCOPYSECURITYATTRIBS  0x0800  // dont copy NT file Security Attributes
#define FOF_NORECURSION            0x1000  // don't recurse into directories.

typedef WORD FILEOP_FLAGS;

#define PO_DELETE       0x0013  // printer is being deleted
#define PO_RENAME       0x0014  // printer is being renamed
#define PO_PORTCHANGE   0x0020  // port this printer connected to is being changed
                                // if this id is set, the strings received by
                                // the copyhook are a doubly-null terminated
                                // list of strings.  The first is the printer
                                // name and the second is the printer port.
#define PO_REN_PORT     0x0034  // PO_RENAME and PO_PORTCHANGE at same time.

// no POF_ flags currently defined

typedef WORD PRINTEROP_FLAGS;

#endif // FO_MOVE

// implicit parameters are:
//      if pFrom or pTo are unqualified names the current directories are
//      taken from the global current drive/directory settings managed
//      by Get/SetCurrentDrive/Directory
//
//      the global confirmation settings

#ifndef UNICODE_ONLY
typedef struct _SHFILEOPSTRUCTA
{
        HWND            hwnd;
        UINT            wFunc;
        LPCSTR          pFrom;
        LPCSTR          pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCSTR           lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS
} SHFILEOPSTRUCTA, FAR *LPSHFILEOPSTRUCTA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _SHFILEOPSTRUCTW
{
        HWND            hwnd;
        UINT            wFunc;
        LPCWSTR         pFrom;
        LPCWSTR         pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCWSTR          lpszProgressTitle; // only used if FOF_SIMPLEPROGRESS
} SHFILEOPSTRUCTW, FAR *LPSHFILEOPSTRUCTW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef SHFILEOPSTRUCTW SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTW LPSHFILEOPSTRUCT;
#else
typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTA LPSHFILEOPSTRUCT;
#endif // UNICODE

#ifndef UNICODE_ONLY
WINSHELLAPI int WINAPI SHFileOperationA(__inout LPSHFILEOPSTRUCTA lpFileOp);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
WINSHELLAPI int WINAPI SHFileOperationW(__inout LPSHFILEOPSTRUCTW lpFileOp);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define SHFileOperation  SHFileOperationW
#else
#define SHFileOperation  SHFileOperationA
#endif // !UNICODE


////
////  Begin ShellExecuteEx and family
////
// @CESYSGEN IF COREDLL_SHEXEC

/* regular WinExec() codes */
#define SE_ERR_FNF              2       // file not found
#define SE_ERR_PNF              3       // path not found
#define SE_ERR_ACCESSDENIED     5       // access denied
#define SE_ERR_OOM              8       // out of memory
#define SE_ERR_DLLNOTFOUND              32

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE                    26
#define SE_ERR_ASSOCINCOMPLETE          27
#define SE_ERR_DDETIMEOUT               28
#define SE_ERR_DDEFAIL                  29
#define SE_ERR_DDEBUSY                  30
#define SE_ERR_NOASSOC                  31

// values for the fMask field
#define SEE_MASK_CLASSNAME        0x00000001
#define SEE_MASK_HOTKEY           0x00000020
#define SEE_MASK_NOCLOSEPROCESS   0x00000040
#define SEE_MASK_FLAG_NO_UI       0x00000400

typedef struct _SHELLEXECUTEINFO
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCTSTR lpVerb;
        LPCTSTR lpFile;
        LPCTSTR lpParameters;
        LPCTSTR lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCTSTR lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        HANDLE hIcon;
        HANDLE hProcess;
} SHELLEXECUTEINFO, FAR *LPSHELLEXECUTEINFO;

WINSHELLAPI BOOL WINAPI ShellExecuteEx(__inout LPSHELLEXECUTEINFO lpExecInfo);

// @CESYSGEN ENDIF
////
////  End ShellExecuteEx and family
////


// These APIs are sysgened out if the system is to run Shell-less
// @CESYSGEN IF COREDLL_SHELLAPIS
//
//// Tray notification definitions
typedef struct _NOTIFYICONDATAA {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        CHAR  szTip[64];
} NOTIFYICONDATAA, *PNOTIFYICONDATAA;

typedef struct _NOTIFYICONDATAW {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        WCHAR  szTip[64];
} NOTIFYICONDATAW, *PNOTIFYICONDATAW;
#ifdef UNICODE
typedef NOTIFYICONDATAW NOTIFYICONDATA;
typedef PNOTIFYICONDATAW PNOTIFYICONDATA;
#else
typedef NOTIFYICONDATAA NOTIFYICONDATA;
typedef PNOTIFYICONDATAA PNOTIFYICONDATA;
#endif // UNICODE

#define NIM_ADD         0x00000000
#define NIM_MODIFY      0x00000001
#define NIM_DELETE      0x00000002

#define NIF_MESSAGE     0x00000001
#define NIF_ICON        0x00000002
#define NIF_TIP         0x00000004

BOOL WINAPI Shell_NotifyIcon(DWORD dwMessage, __in PNOTIFYICONDATA lpData);
////
//// End Tray Notification Icons
////
// @CESYSGEN ENDIF


////
//// Begin SHGetFileInfo
////
// @CESYSGEN IF COREDLL_FILEINFO
/*
 * The SHGetFileInfo API provides an easy way to get attributes
 * for a file given a pathname.
 *
 *   PARAMETERS
 *
 *     pszPath              file name to get info about
 *     dwFileAttributes     file attribs, only used with SHGFI_USEFILEATTRIBUTES
 *     psfi                 place to return file info
 *     cbFileInfo           size of structure
 *     uFlags               flags
 *
 *   RETURN
 *     TRUE if things worked
 */

#ifndef UNICODE_ONLY
typedef struct _SHFILEINFOA
{
        HICON       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        DWORD       dwAttributes;               // out: SFGAO_ flags
        CHAR        szDisplayName[MAX_PATH];    // out: display name (or path)
        CHAR        szTypeName[80];             // out: type name
} SHFILEINFOA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _SHFILEINFOW
{
        HICON       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        DWORD       dwAttributes;               // out: SFGAO_ flags
        WCHAR       szDisplayName[MAX_PATH];    // out: display name (or path)
        WCHAR       szTypeName[80];             // out: type name
} SHFILEINFOW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef SHFILEINFOW SHFILEINFO;
#else
typedef SHFILEINFOA SHFILEINFO;
#endif // UNICODE

// supported SHGetFileInfo input flags
#define SHGFI_ICON              0x000000100     // get icon
#define SHGFI_DISPLAYNAME       0x000000200     // get display name
#define SHGFI_TYPENAME          0x000000400     // get type name
#define SHGFI_ATTRIBUTES        0x000000800     // get attributes
#define SHGFI_SYSICONINDEX      0x000004000     // get system icon index
#define SHGFI_SELECTICON        0x000040000     // get icon specifying selection state
#define SHGFI_LARGEICON         0x000000000     // get large icon
#define SHGFI_SMALLICON         0x000000001     // get small icon
#define SHGFI_USEFILEATTRIBUTES 0x000000010     // use passed dwFileAttribute

// supported SHGetFileInfo output attributes
#define SFGAO_LINK              0x00010000L     // Shortcut (link)
#define SFGAO_READONLY          0x00040000L     // read-only
#define SFGAO_FOLDER            0x20000000L     // It's a folder.

DWORD WINAPI SHGetFileInfo(LPCTSTR pszPath, DWORD dwFileAttributes,
                           __out_bcount(cbFileInfo) SHFILEINFOW *psfi,
                           UINT cbFileInfo, UINT uFlags);

// supported SHGetSpecialFolderPath nFolder ids
#define CSIDL_DESKTOP                   0x0000
#define CSIDL_PROGRAMS                  0x0002
#define CSIDL_PERSONAL                  0x0005
#define CSIDL_FAVORITES                 0x0006
#define CSIDL_STARTUP                   0x0007
#define CSIDL_RECENT                    0x0008
#define CSIDL_STARTMENU                 0x000b
#define CSIDL_MYMUSIC                   0x000d
#define CSIDL_MYVIDEO                   0x000e
#define CSIDL_DESKTOPDIRECTORY          0x0010
#define CSIDL_FONTS                     0x0014
#define CSIDL_APPDATA                   0x001a
#define CSIDL_WINDOWS                   0x0024
#define CSIDL_PROGRAM_FILES             0x0026
#define CSIDL_MYPICTURES                0x0027
#define CSIDL_PROFILE                   0x0028
#define CSIDL_MYRINGTONES               0x003e
#define CSIDL_THEMES                    0x003f

BOOL WINAPI SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath,
                                   int nFolder, BOOL fCreate);

// @CESYSGEN ENDIF
////
//// End SHGetFileInfo
////


//
// SHAddToRecentDocs
//
// @CESYSGEN IF COREDLL_SHELLAPIS
#define SHARD_PIDL      0x00000001L
#define SHARD_PATH      0x00000002L
void WINAPI SHAddToRecentDocs(UINT uFlags, LPCVOID pv);
// @CESYSGEN ENDIF

// @CESYSGEN IF COREDLL_SHORTCUT
DWORD WINAPI SHCreateShortcut(LPTSTR pszShortcut, LPTSTR pszTarget);
DWORD WINAPI SHCreateShortcutEx(LPTSTR pszDir, LPTSTR pszTarget, LPTSTR pszShortcut, LPDWORD pcchShortcut);
BOOL WINAPI SHGetShortcutTarget(LPCTSTR pszShortcut, LPTSTR pszTarget, int cchTarget);
BOOL WINAPI SHGetShortcutTargetEx(LPCTSTR pszShortcut, LPTSTR pszTarget, int cchTarget, LPTSTR * ppszIcon, LPTSTR * ppszAltIcon);
BOOL WINAPI SHGetShortcutTargetClassName(LPCTSTR pszShortcut, LPTSTR pszClassName, int cchClassName);

// @CESYSGEN ENDIF

// @CESYSGEN IF COREDLL_SHMISC
int WINAPI SHShowOutOfMemory(HWND hwndOwner, UINT grfFlags);
HBITMAP WINAPI SHLoadDIBitmap(LPCTSTR szFileName);
HRESULT WINAPI SHLoadIndirectString(LPCWSTR pszSource, LPWSTR pszOutBuf, UINT cchOutBuf, void ** ppvReserved);
// @CESYSGEN ENDIF

typedef enum tagSIPSTATE
{
    SIP_UP = 0,
    SIP_DOWN,
    SIP_FORCEDOWN,
    SIP_UNCHANGED,
    SIP_INPUTDIALOG,
} SIPSTATE;

#ifndef UNDER_NT
#ifdef WINCEOEM
#ifdef WINCEMACRO
#include <mshellap.h>
#endif
#endif
#endif


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include <poppack.h>

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\sherrors.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*****************************************************************************\
*                                                                             *
* sherror.h -  error codes specific to shell APIs                             *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#ifndef _SHERROR_
#define _SHERROR_
#if defined (_MSC_VER) && (_MSC_VER >= 1020) && !defined(__midl)
#pragma once
#endif
#include <winerror.h>

//  COPYENGINE codes use FACILITY_SHELL and 0 in the second lowest byte
// Success/Informational codes
#define COPYENGINE_S_YES                         _HRESULT_TYPEDEF_(0x00270001L)
#define COPYENGINE_S_NOT_HANDLED                 _HRESULT_TYPEDEF_(0x00270003L)
#define COPYENGINE_S_USER_RETRY                  _HRESULT_TYPEDEF_(0x00270004L)
#define COPYENGINE_S_USER_IGNORED                _HRESULT_TYPEDEF_(0x00270005L)
#define COPYENGINE_S_MERGE                       _HRESULT_TYPEDEF_(0x00270006L)
#define COPYENGINE_S_DONT_PROCESS_CHILDREN       _HRESULT_TYPEDEF_(0x00270008L)
#define COPYENGINE_S_ALREADY_DONE                _HRESULT_TYPEDEF_(0x0027000AL)
#define COPYENGINE_S_PENDING                     _HRESULT_TYPEDEF_(0x0027000BL)
#define COPYENGINE_S_KEEP_BOTH                   _HRESULT_TYPEDEF_(0x0027000CL)
#define COPYENGINE_S_CLOSE_PROGRAM               _HRESULT_TYPEDEF_(0x0027000DL) // Close the program using the current file

// Failure/Error codes
#define COPYENGINE_E_USER_CANCELLED      _HRESULT_TYPEDEF_(0x80270000L)  // User wants to canceled entire job
#define COPYENGINE_E_CANCELLED           _HRESULT_TYPEDEF_(0x80270001L)  // Engine wants to canceled entire job, don't set the CANCELLED bit
#define COPYENGINE_E_REQUIRES_ELEVATION  _HRESULT_TYPEDEF_(0x80270002L)  // Need to elevate the process to complete the operation

#define COPYENGINE_E_SAME_FILE           _HRESULT_TYPEDEF_(0x80270003L)  // Source and destination file are the same
#define COPYENGINE_E_DIFF_DIR            _HRESULT_TYPEDEF_(0x80270004L)  // Trying to rename a file into a different location, use move instead
#define COPYENGINE_E_MANY_SRC_1_DEST     _HRESULT_TYPEDEF_(0x80270005L)  // One source specified, multiple destinations

#define COPYENGINE_E_DEST_SUBTREE        _HRESULT_TYPEDEF_(0x80270009L)  // The destination is a sub-tree of the source
#define COPYENGINE_E_DEST_SAME_TREE      _HRESULT_TYPEDEF_(0x8027000AL)  // The destination is the same folder as the source

#define COPYENGINE_E_FLD_IS_FILE_DEST    _HRESULT_TYPEDEF_(0x8027000BL)  // Existing destination file with same name as folder
#define COPYENGINE_E_FILE_IS_FLD_DEST    _HRESULT_TYPEDEF_(0x8027000CL)  // Existing destination folder with same name as file

#define COPYENGINE_E_FILE_TOO_LARGE      _HRESULT_TYPEDEF_(0x8027000DL)  // File too large for destination file system
#define COPYENGINE_E_REMOVABLE_FULL      _HRESULT_TYPEDEF_(0x8027000EL)  // Destination device is full and happens to be removable

#define COPYENGINE_E_DEST_IS_RO_CD       _HRESULT_TYPEDEF_(0x8027000FL)  // Destination is a Read-Only CDRom, possibly unformatted
#define COPYENGINE_E_DEST_IS_RW_CD       _HRESULT_TYPEDEF_(0x80270010L)  // Destination is a Read/Write CDRom, possibly unformatted
#define COPYENGINE_E_DEST_IS_R_CD        _HRESULT_TYPEDEF_(0x80270011L)  // Destination is a Recordable (AudioL) CDRom, possibly unformatted

#define COPYENGINE_E_DEST_IS_RO_DVD      _HRESULT_TYPEDEF_(0x80270012L)  // Destination is a Read-Only DVD, possibly unformatted
#define COPYENGINE_E_DEST_IS_RW_DVD      _HRESULT_TYPEDEF_(0x80270013L)  // Destination is a Read/Wrote DVD, possibly unformatted
#define COPYENGINE_E_DEST_IS_R_DVD       _HRESULT_TYPEDEF_(0x80270014L)  // Destination is a Recordable (AudioL) DVD, possibly unformatted

#define COPYENGINE_E_SRC_IS_RO_CD        _HRESULT_TYPEDEF_(0x80270015L)  // Source is a Read-Only CDRom, possibly unformatted
#define COPYENGINE_E_SRC_IS_RW_CD        _HRESULT_TYPEDEF_(0x80270016L)  // Source is a Read/Write CDRom, possibly unformatted
#define COPYENGINE_E_SRC_IS_R_CD         _HRESULT_TYPEDEF_(0x80270017L)  // Source is a Recordable (AudioL) CDRom, possibly unformatted

#define COPYENGINE_E_SRC_IS_RO_DVD       _HRESULT_TYPEDEF_(0x80270018L)  // Source is a Read-Only DVD, possibly unformatted
#define COPYENGINE_E_SRC_IS_RW_DVD       _HRESULT_TYPEDEF_(0x80270019L)  // Source is a Read/Wrote DVD, possibly unformatted
#define COPYENGINE_E_SRC_IS_R_DVD        _HRESULT_TYPEDEF_(0x8027001AL)  // Source is a Recordable (AudioL) DVD, possibly unformatted

#define COPYENGINE_E_INVALID_FILES_SRC   _HRESULT_TYPEDEF_(0x8027001BL)  // Invalid source path
#define COPYENGINE_E_INVALID_FILES_DEST  _HRESULT_TYPEDEF_(0x8027001CL)  // Invalid destination path
#define COPYENGINE_E_PATH_TOO_DEEP_SRC   _HRESULT_TYPEDEF_(0x8027001DL)  // Source Files within folders where the overall path is longer than MAX_PATH
#define COPYENGINE_E_PATH_TOO_DEEP_DEST  _HRESULT_TYPEDEF_(0x8027001EL)  // Destination files would be within folders where the overall path is longer than MAX_PATH
#define COPYENGINE_E_ROOT_DIR_SRC        _HRESULT_TYPEDEF_(0x8027001FL)  // Source is a root directory, cannot be moved or renamed
#define COPYENGINE_E_ROOT_DIR_DEST       _HRESULT_TYPEDEF_(0x80270020L)  // Destination is a root directory, cannot be renamed
#define COPYENGINE_E_ACCESS_DENIED_SRC   _HRESULT_TYPEDEF_(0x80270021L)  // Security problem on source
#define COPYENGINE_E_ACCESS_DENIED_DEST  _HRESULT_TYPEDEF_(0x80270022L)  // Security problem on destination
#define COPYENGINE_E_PATH_NOT_FOUND_SRC  _HRESULT_TYPEDEF_(0x80270023L)  // Source file does not exist, or is unavailable
#define COPYENGINE_E_PATH_NOT_FOUND_DEST _HRESULT_TYPEDEF_(0x80270024L)  // Destination file does not exist, or is unavailable
#define COPYENGINE_E_NET_DISCONNECT_SRC  _HRESULT_TYPEDEF_(0x80270025L)  // Source file is on a disconnected network location
#define COPYENGINE_E_NET_DISCONNECT_DEST        _HRESULT_TYPEDEF_(0x80270026L)  // Destination file is on a disconnected network location
#define COPYENGINE_E_SHARING_VIOLATION_SRC      _HRESULT_TYPEDEF_(0x80270027L)  // Sharing Violation on source
#define COPYENGINE_E_SHARING_VIOLATION_DEST     _HRESULT_TYPEDEF_(0x80270028L)  // Sharing Violation on destination

#define COPYENGINE_E_ALREADY_EXISTS_NORMAL      _HRESULT_TYPEDEF_(0x80270029L) // Destination exists, cannot replace
#define COPYENGINE_E_ALREADY_EXISTS_READONLY    _HRESULT_TYPEDEF_(0x8027002AL) // Destination with read-only attribute exists, cannot replace
#define COPYENGINE_E_ALREADY_EXISTS_SYSTEM      _HRESULT_TYPEDEF_(0x8027002BL) // Destination with system attribute exists, cannot replace
#define COPYENGINE_E_ALREADY_EXISTS_FOLDER      _HRESULT_TYPEDEF_(0x8027002CL) // Destination folder exists, cannot replace
#define COPYENGINE_E_STREAM_LOSS                _HRESULT_TYPEDEF_(0x8027002DL) // Secondary Stream information would be lost
#define COPYENGINE_E_EA_LOSS                    _HRESULT_TYPEDEF_(0x8027002EL) // Extended Attributes would be lost
#define COPYENGINE_E_PROPERTY_LOSS              _HRESULT_TYPEDEF_(0x8027002FL) // Property would be lost
#define COPYENGINE_E_PROPERTIES_LOSS            _HRESULT_TYPEDEF_(0x80270030L) // Properties would be lost
#define COPYENGINE_E_ENCRYPTION_LOSS            _HRESULT_TYPEDEF_(0x80270031L) // Encryption would be lost
#define COPYENGINE_E_DISK_FULL                  _HRESULT_TYPEDEF_(0x80270032L) // Entire operation likely won't fit
#define COPYENGINE_E_DISK_FULL_CLEAN            _HRESULT_TYPEDEF_(0x80270033L) // Entire operation likely won't fit, clean-up wizard available
#define COPYENGINE_E_CANT_REACH_SOURCE          _HRESULT_TYPEDEF_(0x80270035L) // Can't reach source folder")

#define COPYENGINE_E_RECYCLE_UNKNOWN_ERROR      _HRESULT_TYPEDEF_(0x80270035L) // ???
#define COPYENGINE_E_RECYCLE_FORCE_NUKE         _HRESULT_TYPEDEF_(0x80270036L) // Recycling not available (usually turned offL)
#define COPYENGINE_E_RECYCLE_SIZE_TOO_BIG       _HRESULT_TYPEDEF_(0x80270037L) // Item is too large for the recycle-bin
#define COPYENGINE_E_RECYCLE_PATH_TOO_LONG      _HRESULT_TYPEDEF_(0x80270038L) // Folder is too deep to fit in the recycle-bin
#define COPYENGINE_E_RECYCLE_BIN_NOT_FOUND      _HRESULT_TYPEDEF_(0x8027003AL) // Recycle bin could not be found or is unavailable
#define COPYENGINE_E_NEWFILE_NAME_TOO_LONG      _HRESULT_TYPEDEF_(0x8027003BL) // Name of the new file being created is too long
#define COPYENGINE_E_NEWFOLDER_NAME_TOO_LONG    _HRESULT_TYPEDEF_(0x8027003CL) // Name of the new folder being created is too long
#define COPYENGINE_E_DIR_NOT_EMPTY              _HRESULT_TYPEDEF_(0x8027003DL) // The directory being processed is not empty

//  error codes without a more specific group use FACILITY_SHELL and 0x01 in the second lowest byte.
#define NETCACHE_E_NEGATIVE_CACHE           _HRESULT_TYPEDEF_(0x80270100L) // The item requested is in the negative net parsing cache
#define EXECUTE_E_LAUNCH_APPLICATION        _HRESULT_TYPEDEF_(0x80270101L) // for returned by command delegates to indicate that they did no work 
#define SHELL_E_WRONG_BITDEPTH              _HRESULT_TYPEDEF_(0x80270102L) // returned when trying to create a thumbnail extractor at too low a bitdepth for high fidelity

#endif //  _SHERROR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\service.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

service.h

Abstract:  
	Defines programming model for Windows CE Services
	
Notes: 


--*/
#if ! defined (__service_H__)
#define __service_H__		1

#include <winioctl.h>

//
//	Return codes
//
#define SERVICE_SUCCESS				0

//
//	Service states
//
#define SERVICE_STATE_OFF           0
#define SERVICE_STATE_ON            1
#define SERVICE_STATE_STARTING_UP   2
#define SERVICE_STATE_SHUTTING_DOWN 3
#define SERVICE_STATE_UNLOADING     4
#define SERVICE_STATE_UNINITIALIZED 5
#define SERVICE_STATE_UNKNOWN       0xffffffff

//
// Service startup state (value passed on xxx_Init())
//
#define SERVICE_INIT_STARTED	         0x00000000
// Service is a super-service, should not spin its own accept() threads.
#define SERVICE_INIT_STOPPED	         0x00000001
// Service is being run in an isolated services.exe.  Interprocess communication 
// via IOCTLs or streaming interface is not supported in this configuration.
// NOTE: SERVICE_INIT_STANDALONE is no longer supported
// #define SERVICE_INIT_STANDALONE          0x00000002
// Services.exe should spin a thread to periodically call CoFreeUnusedLibraries
#define SERVICE_COFREE_UNUSED_THREAD     0x00000004
// Services.exe should spin a thread to notify services of local network adapters changing
#define SERVICE_NET_ADDR_CHANGE_THREAD   0x00000008

// 
// Service may need to know whether it was called from device.exe or services.exe or elsewhere.
//
#define SERVICE_CALLER_PROCESS_SERVICES_EXE      1
#define SERVICE_CALLER_PROCESS_DEVICE_EXE        2
#define	SERVICE_CALLER_PROCESS_OTHER_EXE         100

#define SERVICE_SERVICES_EXE_PROCNAME            L"servicesd.exe"
// NOTE: In CE 6.0 and above device.exe no longer exists.
#define SERVICE_DEVICE_EXE_PROCNAME              L"device.exe"


typedef struct _ServiceEnumInfo {
	WCHAR   szPrefix[6];     
	WCHAR   *szDllName;
	HANDLE  hServiceHandle;
	DWORD   dwServiceState;   // one of SERVICE_STATE_XXX values above.
} ServiceEnumInfo;

// NOTE: SERVICE_FIND_CALLER is deprecated.  In previous OS versions services 
// could more easily move between being device drivers & services.  In CE 6.0 
// and after, the differences are radical enough to make this impractical.  
// This function is only included for rudimentary backward compat.

// Called from service on initialization to determine where it's running from

#define SERVICE_FIND_CALLER(callerProc) { \
		WCHAR szCallerModName[MAX_PATH]; \
		if (GetModuleFileName((HINSTANCE)GetCurrentProcess(),szCallerModName,sizeof(szCallerModName)/sizeof(WCHAR)))  { \
			if (wcsstr(szCallerModName,SERVICE_DEVICE_EXE_PROCNAME))  { \
				(callerProc) = SERVICE_CALLER_PROCESS_DEVICE_EXE; \
			} \
			else if (wcsstr(szCallerModName,SERVICE_SERVICES_EXE_PROCNAME)) { \
				(callerProc) = SERVICE_CALLER_PROCESS_SERVICES_EXE; \
			} \
			else { \
				(callerProc) = SERVICE_CALLER_PROCESS_OTHER_EXE; \
			} \
		} \
		else \
			(callerProc) = SERVICE_CALLER_PROCESS_OTHER_EXE; \
	}

//
//	Service is interfaced via series of IOCTL calls that define service life cycle.
//	Actual implementation is service-specific.
//

//
//	Start the service that has been in inactive state. Return code: SERVICE_SUCCESS or error code.
//
#define IOCTL_SERVICE_START		CTL_CODE(FILE_DEVICE_SERVICE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Stop service, but do not unload service's DLL
//
#define IOCTL_SERVICE_STOP		CTL_CODE(FILE_DEVICE_SERVICE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Refresh service's state from registry or other configuration storage
//
#define IOCTL_SERVICE_REFRESH	CTL_CODE(FILE_DEVICE_SERVICE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Have service configure its registry for auto-load
//
#define IOCTL_SERVICE_INSTALL	CTL_CODE(FILE_DEVICE_SERVICE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Remove registry configuration
//
#define IOCTL_SERVICE_UNINSTALL	CTL_CODE(FILE_DEVICE_SERVICE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Unload the service which should be stopped.
//
#define IOCTL_SERVICE_UNLOAD	CTL_CODE(FILE_DEVICE_SERVICE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Supply a configuration or command string and code to the service.
//
#define IOCTL_SERVICE_CONTROL	CTL_CODE(FILE_DEVICE_SERVICE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Return service status.
//
#define IOCTL_SERVICE_STATUS	CTL_CODE(FILE_DEVICE_SERVICE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Set service's debug zone mask (parameter is sizeof(DWORD) and contains the mask)
//
#define IOCTL_SERVICE_DEBUG	CTL_CODE(FILE_DEVICE_SERVICE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Toggle service's console on/off (string "on" on no parameters is ON, "off" means off)
//
#define IOCTL_SERVICE_CONSOLE	CTL_CODE(FILE_DEVICE_SERVICE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Notify service a service request has arrived.  Input contains connected socket.
//
#define IOCTL_SERVICE_REGISTER_SOCKADDR   CTL_CODE(FILE_DEVICE_SERVICE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Notify service a service request has arrived.  For now all sockets associated with service will be closed at once.
//
#define IOCTL_SERVICE_DEREGISTER_SOCKADDR   CTL_CODE(FILE_DEVICE_SERVICE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Notify service a another socket has bound to it.  Input contains an accepted socket.
//
#define IOCTL_SERVICE_CONNECTION   CTL_CODE(FILE_DEVICE_SERVICE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Service has finished initial control setup.  Ready to start.
//
#define IOCTL_SERVICE_STARTED      CTL_CODE(FILE_DEVICE_SERVICE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Service is called with IOCTL_SERVICE_CAN_DEINIT immediatly before xxx_Deinit is called during DeregisterService.  
// If xxx_IOControl returns TRUE and sets buffer in pBufOut to zero, service instance will remain loaded and 
// xxx_Deinit will not be called.
//
#define IOCTL_SERVICE_QUERY_CAN_DEINIT   CTL_CODE(FILE_DEVICE_SERVICE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// If iphlpapi is present, services receive this notification when table that 
// maps IP addresses changes.
// Input contains PIP_ADAPTER_ADDRESSES retrieved from a call to GetAdaptersAddresses().
// As soon as the service returns from this call, this buffer is not valid.  The buffer
// must not be pointed to and it MUST NOT BE COPIED (because internally it has pointers
// to other structures inside it).  If this data is required after the service returns,
// the service must make its own call to GetAdaptersAddresses().
#define IOCTL_SERVICE_NOTIFY_ADDR_CHANGE  CTL_CODE(FILE_DEVICE_SERVICE, 16, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// Services.exe supports a set of callbacks that can only be called from a running service (not API).
// pBufIn data structure contains a pointer to ServiceCallbackFunctions data structure
// IOCTL_SERVICE_CALLBACKS will sent to service during its initial load, and only if there
// are supported callbacks for service's mode of operation.
//
#define IOCTL_SERVICE_CALLBACK_FUNCTIONS  CTL_CODE(FILE_DEVICE_SERVICE, 17, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// Service returns a DWORD containing a set of flags that specify what options it supports.
// The meaning of the flags is service specific.
//
#define IOCTL_SERVICE_SUPPORTED_OPTIONS   CTL_CODE(FILE_DEVICE_SERVICE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// In previous versions, a service could be configured via this IOCTL & services.exe cmd line parser
// (i.e. "services command HTP0: Arg1 Arg2 Arg3...")
// Args were passed to service as ServicesExeCommandLineParams struct as the pBufIn paramater.
// This is no longer supported.
//
// #define IOCTL_SERVICE_COMMAND_LINE_PARAMS CTL_CODE(FILE_DEVICE_SERVICE, 19, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// In previous versions, this IOCTL could be used to retrieve a string
// to be given to user to help them configure the service (in conjunction
// with IOCTL_SERVICE_COMMAND_LINE_PARAMS).
// This is no longer supported
//
// #define IOCTL_SERVICE_COMMAND_LINE_HELP CTL_CODE(FILE_DEVICE_SERVICE, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)

#ifdef __cplusplus
extern "C" {
#endif

HANDLE ActivateService(LPCWSTR lpszDevKey, DWORD dwClientInfo);
HANDLE RegisterService(LPCWSTR lpszType, DWORD dwIndex, LPCWSTR lpszLib, DWORD dwInfo);
BOOL DeregisterService(HANDLE hDevice);
// void CloseAllServiceHandles(HANDLE proc);  // not supported
HANDLE CreateServiceHandle(LPCWSTR lpNew, DWORD dwAccess, DWORD dwShareMode, HANDLE hProc);
BOOL GetServiceByIndex(DWORD dwIndex, LPWIN32_FIND_DATA lpFindFileData);
BOOL ServiceIoControl(HANDLE hService, DWORD dwIoControlCode, LPVOID lpInBuf, DWORD nInBufSize, LPVOID lpOutBuf, DWORD nOutBufSize, 
                          LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);

#if defined (_WINSOCKAPI_) || defined (_WINSOCK2API_)
BOOL ServiceAddPort(HANDLE hService, SOCKADDR *pSockAddr, int cbSockAddr, int iProtocol, WCHAR *szRegWritePath);
BOOL ServiceClosePort(HANDLE hService, SOCKADDR *pSockAddr, int cbSockAddr, int iProtocol, BOOL fRemoveFromRegistry);
#endif

BOOL ServiceUnbindPorts(HANDLE hService);
BOOL EnumServices(PBYTE pBuffer, DWORD *pdwServiceEntries, DWORD *pdwBufferLen);
HANDLE GetServiceHandle(LPWSTR szPrefix, LPWSTR szDllName, DWORD *pdwDllBuf);


#ifdef __cplusplus
}
#endif

#if defined(WINCEOEM) && defined(UNDER_CE)
#ifdef WINCEMACRO
#include <mwinbase.h>
#endif
#endif


#endif	/* __service_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\shintr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*shintr.h - definitions and declarations for SH intrinisc library
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the SH intrinisc subroutine library.
*
****/

#ifndef _INC_SHINTR
#define _INC_SHINTR

#ifdef _M_SH

#ifdef __cplusplus
extern "C" {
#endif

float * _Xform4dV(float *retval, float *vector, float *matrix);
float * _Xform3dV(float *retval, float *vector, float *matrix);
float * _XDXform4dV(float *src, float *dst);
float * _XDXform3dV(float *src, float *dst);
float  _Dot4dV(float *vector1, float *vector2);
float  _Dot3dVW0(float *vector1, float *vector2);
float  _Dot3dVW1(float *vector1, float *vector2);
float * _Multiply4dM(float *retval, float *m4x4m1, float *m4x4m2);
void _XDMultMatrix(float *matrix);
float * _LoadMatrix(float *matrix);
float * _SaveMatrix(float *matrix);
float __fmac(float i, float m, float n);
void __movca(unsigned long value, unsigned long *addr);
float _Convolve(int nelement, float *pstart, float *pend, 
                float *pdata, float *pfilter);

#pragma intrinsic(_Xform4dV,_Xform3dV,_XDXform4dV,_XDXform3dV)
#pragma intrinsic(_Dot4dV,_Dot3dVW0,_Dot3dVW1,_Multiply4dM)
#pragma intrinsic(_XDMultMatrix,_LoadMatrix,_SaveMatrix)
#pragma intrinsic(__fmac,__movca,_Convolve)

#ifdef __cplusplus
}
#endif

#endif // _M_SH

#endif //_INC_SHINTR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\shellctrls.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*****************************************************************************

This file describes the functions, structures, messages and notifications necessary
to create and use the following controls:

PivotHeader Control
VirtualListView Control
PivotControl Control

*****************************************************************************/

#pragma once
#include "windows.h"

/// <summary>
/// Registers the new shell controls.
/// </summary>
BOOL ShellCtrlsInitialize();

/// <summary>
/// Unregisters the new shell controls.
/// </summary>
BOOL ShellCtrlsUninitialize();

/// <summary>
/// Specifies the information related to a pivot page.
/// It is a member of the PVCPAGE structure.
/// </summary>
typedef struct tagPHITEM 
{
    /// <summary>
    /// Pointer to a null-terminated string that contains the item text when 
    /// item information is being set. If item information is being retrieved,
    /// this member specifies the address of the buffer that receives the item text.
    /// </summary>
    TCHAR szTitle[MAX_PATH];
    /// <summary>
    /// A path to the unselected icon. (May be a filename or resource.dll#resource id)
    /// </summary>
    TCHAR szIconSelected[MAX_PATH];
    /// <summary>
    /// A path to the unselected icon. (May be a filename or resource.dll#resource id)
    /// </summary>
    TCHAR szIconUnselected[MAX_PATH];
    /// <summary>
    /// The item id of the item to create or modify.
    /// </summary>
    int iItemId;
    /// <summary>
    /// Reserved. Set to 0.
    /// </summary>   
    DWORD dwFlags;
    /// <summary>
    /// Application-defined data associated with the pivot control item. 
    /// </summary>  
    LPARAM lParam; 
    /// <summary>
    /// Indicates whether the page needs exclusive focus, rather than focus shared
    /// with the pivot control.
    /// </summary>    
    BOOL fExclusiveFocus;
} PHITEM;


typedef enum tagITEMTYPE

{
    IT_ITEM         = 0x0,
    IT_GROUPHEADER  = 0x1,
} ITEMTYPE;

/// <summary>
/// Invalid item index.
/// </summary>
#define VLV_INVALIDIDX   ((UINT)-1)

/// <summary>
/// This structure is used for focus change notification 
/// </summary>
typedef struct tagNMVLVFOCUSCHANGE
{
    NMHDR hdr;
    /// <summary>
    /// Index of the new item in focus. VLV_INVALIDIDX if nothing is in focus anymore (i.e. list became empty)
    /// </summary>
    UINT uNewItemIndex;
    /// <summary>
    /// If uNewItemIndex is valid (i.e. not equal to VLV_INVALIDIDX), the type of item that is in focus.
    /// </summary>
    ITEMTYPE itNewItemType;
    /// <summary>
    /// Greater than 0 is animating forward. 
    /// Less than 0 is animating backward.
    /// 0 means the item was tapped on or a different reason caused the item to get in focus. 
    /// (i.e. The item that used to be in focus got deleted)
    /// </summary>
    int iScrollDirection;
} NMVLVFOCUSCHANGE;


/// <summary>
/// Possible results to a focus change virtual list view notification.
/// </summary>
typedef enum tagVLV_FOCUSNOTIFICATIONRESULT
{
    /// <summary>
    /// Activation change is allowed.
    /// </summary>
    VLV_FOCUSNOTIFICATIONRESULT_ALLOW = 0x0,
    /// <summary>
    /// Activation change is disallowed.
    /// </summary>
    VLV_FOCUSNOTIFICATIONRESULT_DONTALLOW = 0x01,
} VLV_FOCUSNOTIFICATIONRESULT;

/// <summary>
/// Possible results to an activation pivot control notification.
/// </summary>
typedef enum tagPC_ACTIVATIONNOTIFICATIONRESULT
{
    /// <summary>
    /// Activation change is allowed.
    /// </summary>
    PC_ACTIVATIONNOTIFICATIONRESULT_ALLOW = VLV_FOCUSNOTIFICATIONRESULT_ALLOW,
    /// <summary>
    /// Activation change is disallowed.
    /// </summary>
    PC_ACTIVATIONNOTIFICATIONRESULT_DONTALLOW = VLV_FOCUSNOTIFICATIONRESULT_DONTALLOW,
} PC_ACTIVATIONNOTIFICATIONRESULT;

/// <summary>
/// Possible results to an pivot control page animation notification.
/// </summary>
typedef enum tagPC_PAGEANIMATIONNOTIFICATIONRESULT
{
    /// <summary>
    /// Animation is not handled by the page.
    /// </summary>
    PC_PAGEANIMATIONNOTIFICATIONRESULT_NOTHANDLED = 0x0,
    /// <summary>
    /// Animation is handled by the page.
    /// </summary>
    PC_PAGEANIMATIONNOTIFICATIONRESULT_HANDLED = 0x1,
} PC_PAGEANIMATIONNOTIFICATIONRESULT;


// Define the virtual data components.
#ifdef NO_VIRTUAL_DATA
interface IVirtualList;
interface IVirtualItem;
#else
#include "vrtldata.h"
#endif

// VirtualListview class name
#define WC_VIRTUALITEMLISTVIEW           L"VirtualItemListView"

// ListView Control messages
#define VLVM_FIRST               0x1300      // VirtualListView messages

#define VLVN_FIRST               (0U-1600U)       // virtual list view reserved
#define VLVN_LAST                (0U-1699U)

/// <summary>
/// Virtual List View control return value definitions.
/// </summary>
#define VLV_ERR             LB_ERR

/// <summary>
/// Structure used to request a property for a given item.
/// </summary>
typedef struct tagNMVLVPROPINFO
{
    /// <summary>
    /// This structure contains information about a message.
    /// </summary>
    NMHDR hdr;
    /// <summary>
    /// The index of the item in the virtual list.
    /// </summary>
    UINT uItemIndex;
    /// <summary>
    /// The property id.
    /// </summary>
    DWORD dwPropertyId;
    /// <summary>
    /// The property value. Should be set by the recipient of the message.
    /// </summary> 
    PROPVARIANT* pVarPropValue;
} NMVLVPROPINFO, * PNMVLVPROPINFO ;


typedef struct tagNMVLVCOUNT {
  /// <summary>
  /// This structure contains information about a message.
  /// </summary>
  NMHDR hdr;

  /// <summary>
  /// The property value. Should be set by the recipient of the message.
  /// </summary> 
  UINT  uCount;
} NMVLVCOUNT, *PNMVLVCOUNT;


/// <summary>
/// This structure is used whenever something occurs to an item. (i.e. VLVN_ITEMACTIVATED)
/// </summary>
typedef struct tagNMVLVITEM {
    NMHDR hdr;
    /// <summary>
    /// The index of the item or group header.
    /// </summary>
    UINT  uItemIndex;
    /// <summary>
    /// Describes what type of item that is acted on.
    /// </summary>
    ITEMTYPE it;
    /// <summary>
    /// Notification information.
    /// </summary>
    DWORD dwNotificationInfo;    
} NMVLVITEM, *PNMVLVITEM;

/// <summary>
/// Used to notify a change in the virtual list.
/// </summary>
typedef enum tagVLV_LISTCHANGE

{
    /// <summary>
    /// An item in the list was deleted.
    /// </summary>
    VLV_LISTCHANGE_ITEMDELETED = 0x0,
    /// <summary>
    /// An item in the list was added.
    /// </summary>
    VLV_LISTCHANGE_ITEMADDED = 0x1,
    /// <summary>
    /// An item in the list was updated.
    /// </summary>
    VLV_LISTCHANGE_ITEMCHANGED = 0x2,
    /// <summary>
    /// An item moved within the list.
    /// </summary>    
    VLV_LISTCHANGE_ITEMMOVED = 0x3,
    /// <summary>
    /// The list should be reset (A major changed ocurred. For instance, The list was      
    /// resorted)
    /// </summary>
    VLV_LISTCHANGE_LISTRESET = 0x4
} VLV_LISTCHANGE;

/// </summary> 
/// Range guard entry, lower limit of VLV_LISTCHANGE value  
/// <summary>
#define VLV_LISTCHANGE_FIRST VLV_LISTCHANGE_ITEMDELETED 

/// <summary>
/// Range guard entry, upper limit of VLV_LISTCHANGE value  
/// </summary>
#define VLV_LISTCHANGE_LAST VLV_LISTCHANGE_LISTRESET 
        
/// <summary>
/// Used to notify a type of change in the virtual list.
/// </summary>
typedef struct tagVLVLISTCHANGE
{
    NMHDR hdr;
    /// <summary>
    /// Describes the change in the virtual list.
    /// </summary>
    VLV_LISTCHANGE  vlcListChange;
    /// <summary>
    /// For VLV_LISTCHANGE_ITEMDELETED, VLV_LISTCHANGE_ITEMADDED and VLV_LISTCHANGE_ITEMCHANGED:
    ///   Index where the change occurs
    /// For VLV_LISTCHANGE_ITEMMOVED:

    ///   Index where the item moved to.
    /// </summary>
    UINT nIndex;
    /// <summary>
    /// For VLV_LISTCHANGE_ITEMMOVED:
    ///   Index where the item moved from.
    /// </summary>
    UINT nOldIndex;    
} NMVLVLISTCHANGE;


/// <summary>
/// This structure is used whenever an item is pressed and held . (i.e. NMVLVITEMPRESSEDANDHELD)
/// </summary>
typedef struct tagNMVLVITEMPRESSEDANDHELD{
    NMHDR hdr;
    /// <summary>
    /// The index of the item or group header.
    /// </summary>
    UINT  uItemIndex;
    /// <summary>
    /// Describes what type of item that is acted on.
    /// </summary>
    ITEMTYPE it;
    /// <summary>
    /// Describes the x,y coordinates of the  mouse pointer, in screen coordinates.
    /// </summary>
    POINT ptsLocation;
    /// <summary>
    /// Notification information.
    /// </summary>
    DWORD dwNotificationInfo;    
} NMVLVITEMPRESSEDANDHELD, *PNMVLVITEMPRESSEDANDHELD ;


// Flags that can be used as the dwFlags member of VLVCREATESTRUCT

/// <summary>
/// Set if the listview should show group headers. Only supported in some layouts.
/// </summary>
#define VLVCSF_SHOWGROUPHEADERS    0x00000001 
/// <summary>
/// Allows the list to focus on headers.
/// </summary>
#define VLVCSF_ALLOWFOCUSONHEADERS 0x00000002 
/// <summary>
/// Allows the list to wrap when scrolling up/down at the beginning/end of the list.
/// </summary>
#define VLVCSF_ENABLEWRAPPING      0x00000004
/// <summary>
/// Allow multi-select.
/// </summary>
#define VLVCSF_MULTISELECT         0x00000008
/// <summary>
/// If VLVCSF_ENABLEQUICKSEARCH is set, the list will allow the user to go directly to
/// a header or to the first element that starts with a given letter.
/// If VLVCSF_ENABLEQUICKSEARCH is set:
/// If group headers are shown, the list will allow scrolling directly to a header.
/// If group headers are not shown, the PROPID_TEXT0 field of each of the elements must be
/// sorted alphabetically using CompareString using the LOCALE_SYSTEM_DEFAULT locale id.
/// If the list is not sorted, QuickSearch will not work appropriately.
/// </summary>
#define VLVCSF_ENABLEQUICKSEARCH   0x00000010



// Flags that are used represent the state of an item.
// (See VLVM_GETITEMSTATE)

/// <summary>
/// The item is selected.
/// </summary>
#define VLV_ITEMSTATE_SELECTED   0x40000000
/// <summary>
/// The item is currently in focus.
/// </summary>
#define VLV_ITEMSTATE_FOCUSED    0x80000000



/// <summary>
/// Virtual List View Layout definitions used by VLVM_SETLAYOUT and VLVM_GETLAYOUT
/// </summary>
typedef enum tagVLV_LAYOUT
{
    /// <summary>
    /// Single line with no images.
    /// </summary>
    VLV_LAYOUT_SINGLELINEBASIC = 0x1,
    /// <summary>
    /// Single line with 1 icon.
    /// </summary>
    VLV_LAYOUT_SINGLELINE1ICON = 0x2,
    /// <summary>
    /// Single line with 1 icon and 2 labels.
    /// </summary>
    VLV_LAYOUT_SINGLELINE1ICON2TEXT = 0x3,
    /// <summary>
    /// Single line with 3 icons and 2 labels.
    /// </summary>
    VLV_LAYOUT_SINGLELINE3ICON2TEXT = 0x4,
       /// <summary>
    /// Single line layout (category view)
    /// </summary>
    VLV_LAYOUT_SINGLELINECATEGORIES = 0x5,
    /// <summary>
    /// Basic double line layout.
    /// </summary>
    VLV_LAYOUT_DOUBLELINE  = 0x6,    
    /// <summary>
    /// Double line layout with 3 labels and 1 icon.
    /// </summary>
    VLV_LAYOUT_DOUBLELINE1ICON = 0x7,
    /// <summary>
    /// Double line layout with 4 labels and 5 icons.
    /// </summary>
    VLV_LAYOUT_DOUBLELINE5ICON4TEXT = 0x8,
    /// <summary>
    /// Basic Grid layout. (One image shown)
    /// </summary>
    VLV_LAYOUT_GRID = 0x9,    
    /// <summary>
    /// Horizontal filmstrip layout.
    /// </summary>    
    VLV_LAYOUT_HORIZONTALFILMSTRIP = 0x0A,   
} VLV_LAYOUT;


/// <summary>
/// A mapping between two property IDs.
/// </summary>
typedef struct tagPROPIDMAP
{
    DWORD dwPropIdSource;
    DWORD dwPropIdDestination;
} PROPIDMAP;

/// <summary>
/// Optional creation structure. 
/// May be passed as the lpCreateParams member of the CREATESTRUCT.
/// </summary>
typedef struct tagVLVCREATESTRUCT
{ 
    /// <summary>
    /// The size of this structure.
    /// </summary>    
    UINT cbSize; 
    /// <summary>
    /// The layout that should be used for the Virtual List View.
    /// </summary>    
    VLV_LAYOUT vlvLayout;
    /// <summary>
    /// Creation flags. See VLVCSF_* definitions.
    /// </summary>    
    DWORD dwFlags;
    /// <summary>
    /// pDataSource will be used as the data source to the control. 
    /// Set to NULL if the parent of the window will provide the data.
    /// </summary>
    IVirtualList* pDataSource;
    /// <summary>
    ///  The number of property PROPIDMAPs in rgPropIds. 
    /// </summary>
    UINT cPropIds;
    /// <summary>
    ///  An array of PROPIDMAP structures that override the properties requested from the data source.
    ///  If cPropIds is 0, it should be set to NULL.
    /// </summary>
    PROPIDMAP* rgPropIds;
} VLVCREATESTRUCT, *PVLVCREATESTRUCT; 




// Supported property IDs
#define VLVP_LBL_IDX_MIN     (PROPID_TEXT0)
#define VLVP_LBL_IDX_MAX     (PROPID_TEXT9)

#define VLVP_IMG_IDX_MIN     (PROPID_IMAGE0)
#define VLVP_IMG_IDX_MAX     (PROPID_IMAGE9)

// Data Related Notifications

/// <summary>
/// This notification is sent when the virtual list requires a virtual item's property value.
/// </summary>
/// <param name="pnmv "> pnmvlvPropInfo = (NMVLVPROPINFO *) lParam;
/// On input, the uItemIndex and dwPropertyId members of the structure specify 
/// the property being queried. (index and property name). 
/// Use the pVarPropValue member to return the property value.
/// <returns>
/// The application receiving this message should return 0.
/// </returns>
#define VLVN_GETITEMPROPERTY       (VLVN_FIRST - 1) 


/// <summary>
/// This notification is sent when the virtual list requires the virtual items count.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam">pnmvlvCount = (NMVLVCOUNT *) lParam;
/// The iCount menmber of the NMVLVCOUNT structure should be filled with the item count in the virtual list.
/// </param>
/// <returns>
/// the application receiving this message should return 0.
/// </returns>
#define VLVN_GETITEMCOUNT        (VLVN_FIRST - 2)


// List Related Notifications.

/// <summary>
/// This notification is sent when the virtual list selection has changed.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam"> Not used. <param>
/// <returns>
/// The application receiving this message should return 0. 
/// </returns>
/// <remarks>
/// If the application wants the list of currently selected items, it can issue a VLVM_GETSELECTEDITEMS.
/// </remarks>
#define VLVN_SELECTIONCHANGED          (VLVN_FIRST - 4)


/// <summary>
/// This notification is sent when the position of the focus in the list is about to change.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam"> pnmvlvFocusChange = (NMVLVFOCUSCHANGE *) lParam;
/// It will contain information on the item receiving the focus, and the old item that had the focus.
/// <param>
/// <returns>
/// If the owner doesn't want to allow the item to receive focus it can return 
/// VLV_FOCUSNOTIFICATIONRESULT_DONTALLOW to keep the focus on the old item.
/// Otherwise the owner should return VLV_FOCUSNOTIFICATIONRESULT_ALLOW.
/// </returns>
#define VLVN_FOCUSCHANGING        (VLVN_FIRST - 5)

/// <summary>
/// This notification is sent when the position of the focus in the list has changed.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam"> pnmvlvFocusChange = (NMVLVFOCUSCHANGE *) lParam;
/// It will contain information on the item that received the focus, and the old item that had the focus.
/// <param>
/// <returns>
/// The application receiving this message should return 0. 
/// </returns>
#define VLVN_FOCUSCHANGED          (VLVN_FIRST - 6)

/// <summary>
/// This notification is sent when an item in the virtual list is activated.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam"> pnmvlvItem = (NMVLVITEM *) lParam;
/// It will contain information on the item activated.
/// <param>
/// <returns>
/// The application receiving this message should return 0. 
/// </returns>
#define VLVN_ITEMACTIVATED          (VLVN_FIRST - 7)


/// <summary>
/// This notification is sent when the list changes.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam"> pnmvlvListChange = (NMVLVLISTCHANGE *) lParam;
/// It will contain information on the change that ocurred to the list. (item deleted, list reset, etc.)
/// <param>
/// <returns>
/// The application receiving this message should return 0. 
/// </returns>
#define VLVN_LISTCHANGED          (VLVN_FIRST - 8)

/// <summary>
/// This notification is sent when an item in the virtual list is pressed and held.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam"> pnmvlvItemHeld = (NMVLVITEMPRESSEDANDHELD*) lParam;
/// It will contain press and hold information on the item.
/// <param>
/// <returns>
/// The application receiving this message should return 0. 
/// </returns>
#define VLVN_ITEMPRESSEDANDHELD     (VLVN_FIRST - 9)


/// <summary>
/// Gets the number of items in the list.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam">Receives the number of items in the list.
///   puItemCount = (UINT *) lParam ; 
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_GETITEMCOUNT        (VLVM_FIRST + 1)

/// <summary>
/// This message sets the layout (view style) that is currently in use for the
/// virtual list view.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam"> Specifies the layout to use. </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_SETLAYOUT    (VLVM_FIRST + 2)


/// <summary>
/// This message retrieves the layout (view style) that is currently in use for the
/// virtual list view.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">Not used. </param>
/// <returns>
/// Returns a DWORD value that represents the layout used to display the list.
/// It returns 0 if the layout is a custom layout or if there was a failure.
/// </returns>
#define VLVM_GETLAYOUT    (VLVM_FIRST + 3)

/// <summary>
/// This message sets the data source for the virtual list view.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">A pointer to an IVirtualList interface. The Virtual 
/// List View will release the COM object when it no longer needs it.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_SETDATASOURCE    (VLVM_FIRST + 4)


/// <summary>
/// This message gets the data source for the virtual list view.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam"> 
/// [out] Pointer to an IVirtualList*. On return it will point to the list data source. 
/// The caller is responsible for releasing the data source when it no longer needs it.
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
/// <remarks>
/// If there is no datasource set, lParam will be set to NULL and the message will return succesfully.
/// </remarks>
#define VLVM_GETDATASOURCE    (VLVM_FIRST + 5)

/// <summary>
/// Selects an item at a given index.
/// </summary>
/// <param name="wParam">The index of the item (UINT).</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_SELECTITEM    (VLVM_FIRST + 6)

/// <summary>
/// Unselect the item at a given index.
/// </summary>
/// <param name="wParam">The index of the item (UINT).</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_UNSELECTITEM    (VLVM_FIRST + 7)

/// <summary>
/// Gets the number of selected items.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam">Receives the number of selected items.
/// puSelectedItemCount = (UINT *) lParam ; </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_GETSELECTEDITEMSCOUNT  (VLVM_FIRST + 8)

/// <summary>
/// Get the array of selected IVirtualItem objects.
/// </summary>
/// <param name="wParam">Pass UINT* that will receive the count of IVirtualItem* objects. </param>
/// <param name="lParam">Pass IVirtualItem*** that will receive a pointer to an array of IVirtualItem* objects.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
/// <remarks>
/// The caller is responsible for releasing each of the IVirtualItems it receives and then freeing the array of pointers.
/// i.e. LocalFree(*prgItems);
/// </remarks>
#define VLVM_GETSELECTEDITEMS (VLVM_FIRST + 9)

/// <summary>
/// Get the array of selected indices.
/// </summary>
/// <param name="wParam">Pass UINT* that will receive the count of indices. (cIndices) </param>
/// <param name="lParam">Pass UINT** that will receive a pointer to an array of indices. (prgnIndices)</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
/// <remarks>
/// The caller is responsible for freeing the array of indices.
/// i.e. LocalFree(*prgnIndices);
/// </remarks>
#define VLVM_GETSELECTEDINDICES    (VLVM_FIRST + 10)

/// <summary>
/// Sets whether multiple items can be selected in the list.
/// </summary>
/// <param name="wParam">BOOL that describes whether multiselect is set or not.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_SETMULTISELECT   (VLVM_FIRST + 11)

/// <summary>
/// Gets whether multiple items can be selected in the list.
/// </summary>
/// <param name="wParam">BOOL* that receives whether multiselect is set or not.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_GETMULTISELECT  (VLVM_FIRST + 12)


/// <summary>
/// Message sent to notify the list control that the list has changed.
/// </summary>
/// <param name="wParam">VLV_LISTCHANGE that describes the type of change.</param>
/// <param name="lParam">A pointer to a VLISTEVENTPARAMS structure that describe the index of the change (iNewItem), and if VLV_LISTCHANGE is
/// VLV_LISTCHANGE_ITEMMOVED, the old index of the item that moved (iOldItem). </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_LISTCHANGED  (VLVM_FIRST + 13)

/// <summary>
/// Message sent to notify the list control to focus on a specific item.
/// </summary>
/// <param name="wParam">The index of the item to focus on.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure. It will return FALSE if an invalid index is passed or if
/// the focus is hidden.
/// </returns>
#define VLVM_FOCUSITEM  (VLVM_FIRST + 14)


/// <summary>
/// Message sent to set whether the list should remember selection and focus when list reset occurs.
/// </summary>
/// <param name="wParam">BOOL that describes whether selection and focus should persist on a LISTRESET.</param>
/// <param name="lParam">Not used.</param>
/// <remarks>
/// Focus and selection can be persisted on a RESET only if the data provider is an IVirtualList that supports
/// unique identifiers.(See LISTPROPID_SUPPORTSUNIQUEID).
/// </remarks>
/// <returns>
/// TRUE indicates success. FALSE indicates failure. 
/// </returns>
#define VLVM_KEEPSELECTIONANDFOCUSONRESET   (VLVM_FIRST + 15)

/// <summary>
/// Gets the index of the item in focus.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
///  Returns the index of the item in focus. It will return VLV_ERR if no item is in focus 
/// (i.e. The focus is in a group header)
/// </returns>
#define VLVM_GETFOCUSEDITEMINDEX (VLVM_FIRST + 16)

/// <summary>
/// If a group is in focus, it will return the index of the group in focus.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
///  Returns the index of the group header in focus. It will return VLV_ERR if no group header is in focus. 
/// (i.e. Group header is not in focus.)
/// </returns>
#define VLVM_GETFOCUSEDGROUPINDEX (VLVM_FIRST + 17)


/// <summary>
/// Message sent to describe whether the focus bar should be visible or not.
/// </summary>
/// <param name="wParam">if wParam == TRUE it will show the focusbar, otherwise it will hide it.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE otherwise.
/// </returns>
/// <remarks>
/// Not all layouts support hiding the focus bar (only those that have a moving focus bar). 
/// If a layout does not have a focus bar, the message will be ignored.
/// </remarks>
#define VLVM_SHOWFOCUSBAR  (VLVM_FIRST + 18)


/// <summary>
/// Message sent to describe whether the group headers should be visible or not.
/// </summary>
/// <param name="wParam">if wParam == TRUE it will show the group headers, otherwise it will hide them.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE otherwise.
/// If the current layout does not support headers, FALSE will be returned.
/// </returns>
/// <remarks>
/// Not all layouts support displaying headers. If a layout does not support displaying headers, the message
/// will not have any effect.
/// </remarks>
#define VLVM_SHOWGROUPHEADERS (VLVM_FIRST + 19)

/// <summary>
/// Message sent to describe whether the group headers can receive focus or not.
/// </summary>
/// <param name="wParam">if wParam == TRUE it will enable focusing on group headers, 
/// otherwise it will skip group headers.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE otherwise.
/// If the current layout does not support headers, FALSE will be returned.
/// </returns>
/// <remarks>
/// Not all layouts support headers. If a layout does not support displaying headers, the message
/// will not have any effect.
/// </remarks>
#define VLVM_ALLOWFOCUSONHEADERS (VLVM_FIRST+ 20)

/// <summary>
/// Message sent to notify the list control to focus on a group header.
/// </summary>
/// <param name="wParam">(UINT) The index of the group header to focus on.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure. 
/// It will return FALSE if no data source is set,if the focus is not shown, 
/// if an invalid index is passed or if the list layout currently used does not show group headers.
/// </returns>
#define VLVM_FOCUSHEADER  (VLVM_FIRST + 21)


/// <summary>
/// Gets the state of a given item.
/// </summary>
/// <param name="wParam">UINT that contains the item to query.</param>
/// <param name="lParam">DWORD* that receives the item state as a set of flags.
/// See VLV_ITEMSTATE_SELECTED and VLV_ITEMSTATE_FOCUSED flags.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_GETITEMSTATE (VLVM_FIRST + 22)


/// <summary>
/// Sets the text to display when the list is empty.
/// </summary>
/// <param name="wParam">The text to display when the list is empty. 
/// The string can be up to MAX_PATH characters long.
///  pszEmptyListText = (LPCTSTR) wParam;
/// </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE otherwise.
/// </returns>
/// <remarks>
/// Not all layouts support showing empty text when the list is empty.
/// </remarks>
#define VLVM_SETEMPTYLISTTEXT  (VLVM_FIRST + 23)


/// <summary>
/// Sets whether the user should be allowed to "wrap" in the list when scrolling
/// past the first / last element in the list.
/// </summary>
/// <param name="wParam">TRUE if wrapping should be enabled, FALSE if wrapping should be disabled.
/// </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE otherwise.
/// </returns>
#define VLVM_SETENABLEWRAPPING  (VLVM_FIRST + 24)

/// <summary>
/// Gets whether the user should be allowed to "wrap" in the list when scrolling
/// past the first / last element in the list.
/// </summary>
/// <param name="wParam">Receives wether wrapping is enabled.
/// pfResult = (BOOL*) wParam;
/// </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE otherwise.
/// </returns>
#define VLVM_GETENABLEWRAPPING  (VLVM_FIRST + 25)

/// <summary>
/// Gets whether group header items are visible or not
/// </summary>
/// <param name="wParam">BOOL* that receives whether group headers are visible.</param>
/// <param name="lParam">not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_GETGROUPHEADERSSHOWN (VLVM_FIRST + 26)

/// <summary>
/// Gets whether group headers will receive focus.
/// </summary>
/// <param name="wParam">BOOL* that receives whether focus on group header is allowed.</param>
/// <param name="lParam">not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VLVM_GETALLOWFOCUSONHEADERS (VLVM_FIRST + 27)

/// RESERVED MESSAGES
// VLVM_FIRST + 150 to VLVM_FIRST + 170 

#define VLVM_LAST   (VLVM_FIRST + 0xFF)


// Virtual Item View control notification range 
#define VIVN_FIRST               (0U-1700U)
#define VIVN_LAST                (0U-1729U)


// VirtualItemView class name
#define WC_VIRTUALITEMVIEW           L"VirtualItemView"

/// <summary>
/// Virtual Item View Layout definitions used by VIVM_SETLAYOUT and VIVM_GETLAYOUT
/// </summary>
typedef enum tagVIV_LAYOUT
{
    /// <summary>
    /// Single line with no images.
    /// </summary>
    VIV_LAYOUT_SINGLELINEBASIC = 0x1,
    /// <summary>
    /// Double line layout with no images.
    /// </summary>
    VIV_LAYOUT_DOUBLELINE = 0x2,    
    /// <summary>
    /// Double line layout with an image on the left and two small images on the right side.
    /// </summary>
    VIV_LAYOUT_DOUBLELINE3ICON = 0x3,        
} VIV_LAYOUT;

/// <summary>
/// This message sets the data source for the virtual item view.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">A pointer to an IVirtualItem interface. The Virtual Item View will 
/// release the COM object when it no longer needs it.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VIVM_SETDATASOURCE    VLVM_SETDATASOURCE

/// <summary>
/// This message gets the data source for the virtual item view.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">(LPARAM)(IVirtualItem **) It will receive a pointer to an IVirtualItem interface. 
/// The caller is responsible for releasing the object when it no longer needs it.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
/// <remarks>
/// If there is no datasource set, lParam will be set to NULL and the message will return succesfully.
/// </remarks>
#define VIVM_GETDATASOURCE    VLVM_GETDATASOURCE

/// <summary>
/// This message gets the layout (view style) that is currently in use for the
/// virtual item view.
/// </summary>
/// <param name="wParam">Not used. Set to NULL.</param>
/// <param name="lParam">Not used. Set to NULL. </param>
/// <returns>
/// Returns the layout id of the control.
/// </returns>
#define VIVM_GETLAYOUT       VLVM_GETLAYOUT    

/// <summary>
/// This message sets the layout (view style) that is currently in use for the
/// virtual item view.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam"> Specifies the layout to use. </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define VIVM_SETLAYOUT        VLVM_SETLAYOUT    

// Data Related Virtual Item Notifications
/// <summary>
/// This notification is sent when a virtual item is activated.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam"> pnmvlvItemActivated = (NMVLVITEM*) lParam;
/// It will contain tap information on the item.
/// uItemIndex will be set to 0 and ITEMTYPE will be set to IT_ITEM
/// <param>
/// <returns>
/// The application receiving this message should return 0. 
/// </returns>
#define VIVN_ITEMACTIVATED         (VIVN_FIRST - 1)

/// <summary>
/// This notification is sent when a virtual item  is pressed and held.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam"> pnmvlvItemHeld = (NMVLVITEMPRESSEDANDHELD*) lParam;
/// It will contain hold information on the item.
/// uItemIndex will be set to 0 and ITEMTYPE will be set to IT_ITEM
/// <param>
/// <returns>
/// The application receiving this message should return 0. 
/// </returns>
#define VIVN_ITEMPRESSEDANDHELD   (VIVN_FIRST - 2)




// PivotControl class name
#define WC_PIVOTCONTROL               L"SysPivotControl"


/// <summary>
/// The following structure is used to add a page to the PivotControl
/// </summary>
typedef struct tagPVCPAGE
{
    /// <summary>
    /// Size of the structure. 
    /// </summary>
    UINT cbSize;

    /// <summary>
    /// A handle to the window hosted in this page.
    /// </summary>
    HWND hwndUser;

    /// <summary>
    /// PHITEM structure configuring a PivotHeader item of for this page.
    /// </summary>
    PHITEM hItem;
} PVCPAGE; 


/// <summary>
/// Pivot Control Layout definitions.
/// </summary>
typedef enum tagPC_LAYOUT
{
    /// <summary>
    /// Default layout.
    /// </summary>
    PC_LAYOUT_DEFAULT = 0x1,
} PC_LAYOUT;

/// <summary>
///    If PVCF_GETHWND_NOINIT is used, NULL will be returned if the window handle was not set at 
///    initialization and a PVCN_GETPAGEHWND notification has not been issued for that window.
/// </summary>
#define PVCF_GETHWND_NOINIT         0x20000000

/// PivotControl Style
/// <summary>
///   This style can be used when the window gets created, to force layout updates
///   to be delayed until a WM_SETREDRAW (with a TRUE value for WPARAM) is sent to the control.
/// </summary>
#define PVCS_DELAYDRAW             0x200       

// PivotControl Messages
#define PVCM_FIRST                  0x1600

/// <summary>
/// Pivot control return value definitions.
/// </summary>
#define PVC_ERR             LB_ERR

/// <summary>
/// This message retrieves the number of pages.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// Count of pages in the PivotControl control.
/// </returns>
#define PVCM_GETPAGECOUNT            (PVCM_FIRST + 1)

/// <summary>
/// This message retrieves information about a pivot control page.
/// </summary>
/// <param name="wParam"> The page id.
/// (WPARAM)(int) iPageId; 
/// </param>
/// <param name="lParam"> 
/// Pointer to a PHITEM that receives the information about the item.
/// lParam = (LPARAM)(PHITEM *) pitem;
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define PVCM_GETPAGEINFOBYID         (PVCM_FIRST + 2)

/// <summary>
/// This message sets the information related to a pivot control page.
/// </summary>
/// <param name="wParam"> Not used.
/// </param>
/// <param name="lParam"> A pointer to a PHITEM structure that describes 
/// the page to set. The caller should allocate the PHITEM.
/// lParam = (LPARAM)(PHITEM *) &item;
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// If the page with the specified id is not already in the control, 
/// FALSE will be returned.
/// </returns>
#define PVCM_SETPAGEINFOBYID         (PVCM_FIRST + 3)

/// <summary>
/// This message retrieves information about a pivot control page.
/// </summary>
/// <param name="wParam"> Index of the page. 
/// (WPARAM) (UINT) uPageIdx;
/// </param>
/// <param name="lParam">
/// Pointer to a PHITEM that receives the information about the item.
/// lParam = (LPARAM)(PHITEM *) pitem;
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define PVCM_GETPAGEINFOFROMPOSITION   (PVCM_FIRST + 4)

/// <summary>
/// This message inserts a page to the pivot control after another page.
/// If the position does not exist, the item will not be inserted and FALSE will be returned.
/// </summary>
/// <param name="wParam">ID of the page that the inserted page will follow. </param>
/// <param name="lParam">A pointer to a PVCPAGE structure. The PVCPAGE 
/// contains information on the attributes to set..
/// (LPARAM)(PVCPAGE *) pPage;</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define PVCM_INSERTPAGE_AFTER        (PVCM_FIRST + 5)


/// <summary>
/// This message adds a page to the pivot control.
/// </summary>
/// <param name="wParam">Not used. </param>
/// <param name="lParam">A pointer to a PVCPAGE structure. The PVCPAGE 
/// contains information on the attributes to set.
/// lParam = (LPARAM)(PVCPAGE *) pPage; </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define PVCM_INSERTPAGE              (PVCM_FIRST + 6)

/// <summary>
/// This message removes a page from the PivotControl.
/// </summary>
/// <param name="wParam">The page id, wParam = (WPARAM)(int) iPageId;  </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// The windows handle of the page removed. If there was a failure or if there is no window handle
/// for the given id, NULL will be returned.
/// </returns>
/// <remarks>
/// If a valid window handle is returned, the caller is responsible for destroying the window.
///</remarks>
#define PVCM_REMOVEPAGEBYID          (PVCM_FIRST + 7)

/// <summary>
/// This message removes all pages.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
/// <remarks>
/// All the windows previously in the pivot control will be destroyed.
///</remarks>
#define PVCM_DELETEALLPAGES          (PVCM_FIRST + 8)


/// <summary>
/// This message gets the id of the currently selected page.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// (int)iPageId, PVC_ERR (-1) if the API failed.
/// </returns>
#define PVCM_GETACTIVEPAGEID         (PVCM_FIRST + 9)


/// <summary>
/// This message selects and displays a page by id
/// </summary>
/// <param name="wParam"> The page id.
/// (WPARAM)(int) iPageId;
/// </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define PVCM_ACTIVATEPAGEBYID        (PVCM_FIRST + 10)


/// <summary>
/// Get the handle to a the data area of a PivotControl page. The application
/// can send messages directly to the window that occupies the data area
/// of the PivotControl page.
/// </summary>
/// <param name="wParam">  The page id.
/// (WPARAM)(int) iPageId;
/// </param>
/// <param name="lParam">
/// Flags.  Use PVCF_GETHWND_NOINIT to return without forcing initialization.
/// </param>
/// <returns>
/// HWND of the data window, or NULL if the window doesn't exist.
/// </returns>
#define PVCM_GETHWNDBYID             (PVCM_FIRST + 11)


/// <summary>
/// Get the handle to the selected data area. 
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// The window handle to the currently active window. NULL if there is no active window.
/// </returns>
#define PVCM_GETACTIVEHWND           (PVCM_FIRST + 12)

/// <summary>
/// This message gets the style currently used for PivotControl.
/// Valid styles defined by the PC_LAYOUT enum.
/// </summary>
/// <param name="wParam">
/// Not used.
/// </param>
/// <param name="lParam">
/// Not used.
///</param>
/// <returns>
/// Returns the layout id of the control.
/// </returns>
#define PVCM_GETLAYOUT               (PVCM_FIRST + 15)

/// <summary>
/// This message sets the style for PivotControl.
/// Valid styles defined by the PC_LAYOUT enum.
/// </summary>
/// <param name="wParam">
/// Not used.
/// </param>
/// <param name="lParam">
/// Style.  Valid style values are defined by the PC_LAYOUT enum.
///</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define PVCM_SETLAYOUT               (PVCM_FIRST + 16)

/// <summary>
/// Retrieve the rectangle of the area that the pivot control uses to display pages.
/// </summary>
/// <param name="wParam">
/// Not used.
/// </param>
/// <param name="lParam">
/// Pointer to RECT that receives the page rectangle.
///</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define PVCM_GETPAGERECT          (PVCM_FIRST + 17)

/// <summary>
/// Enable/disable pivoting on the control.
/// </summary>
/// <param name="wParam">
/// (BOOL) TRUE allows pivoting on the control, 
/// FALSE sets the focus on the hosted page, and disables pivoting.
/// </param>
/// <param name="lParam">
/// Not used.
///</param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define PVCM_ENABLEPIVOTING     (PVCM_FIRST + 18)

/// <summary>
/// Retrieve the ID of the next page.
/// </summary>
/// <param name="wParam">
/// [IN] (INT) the ID of the current page.
/// </param>
/// <param name="lParam"> Not used. 
/// </param>
/// <returns>
/// If succesfull, it returns the Item Id of the item next to the item
/// described in the wParam. 
/// If wParam is PVC_ERR, it will return the id of the first element.
/// If not succesful, it will return PVC_ERR.
/// </returns>
#define PVCM_GETNEXTPAGEID          (PVCM_FIRST + 19)

/// <summary>
/// Retrieve the ID of the previous page.
/// </summary>
/// <param name="wParam">
/// [IN] (INT) the ID of the current page.
/// </param>
/// <param name="lParam"> Not used.
/// </param>
/// <returns>
/// If succesfull, it returns the Item Id of the item previous to the item
/// described in the wParam. 
/// If wParam is PVC_ERR, it will return the id of the first element.
/// If not succesful, it will return PVC_ERR.
/// </returns>
#define PVCM_GETPREVIOUSPAGEID      (PVCM_FIRST + 20)

/// <summary>
/// Get the page position in the list of pivot pages from page ID.
/// </summary>
/// <param name="wParam">
/// [IN] (INT) Page ID.
/// </param>
/// <param name="lParam">
/// [OUT] (UINT *) Pointer to the UINT value receiving the page position.
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define PVCM_GETPOSITIONFROMPAGEID  (PVCM_FIRST + 21)

/// <summary>
/// Play the pivot activation animation. 
/// </summary>
/// <param name="wParam"> Not used. 
/// </param>
/// <param name="lParam"> Not used. 
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
/// <remarks>
/// This message should be sent synchronously so that the pivot
/// has a chance to initialize its animation before it's displayed.
/// </remarks>
#define PVCM_ANIMATEACTIVATION      (PVCM_FIRST + 22)

/// RESERVED MESSAGES
// PVCM_FIRST + 80 to PVCM_LAST + 100 
#define PVCM_LAST                   (PVCM_FIRST + 0xFF)

// PivotControl Notifications

#define PVCN_FIRST               (0U-910U)   // PivotControl notification
                                             // range.
#define PVCN_LAST                (0U-929U)   

/// <summary>
/// Structure containing the notification information sent from the PivotControl
/// to the PivotControl's parent when the Pivot control changes the item with
/// focus.
/// </summary>
typedef struct _NM_PVCPIVOT
{
    /// <summary>
    /// NMHDR structure that contains information about the message. 
    /// </summary>
    NMHDR hdr;
    /// <summary>
    /// Larger then 0 is animating forward. Less then 0 is animating backward.
    /// 0 means the item was tapped on.
    /// </summary>
    int iScrollDirection;
    /// <summary>
    /// Id of the item previously in focus or PVC_ERR if an id cannot be determined.
    /// previously.
    /// </summary>
    int iOldActiveItemId;
    /// <summary>
    /// Index of the new item in focus or PVC_ERR if an id cannot be determined.
    /// </summary>
    int iNewActiveItemId;
} NMPVCPIVOT;


/// <summary>
/// Structure that the PivotControl uses to notify its hosted pages of status changes.
/// </summary>
typedef struct _NM_PVCPAGE
{
    /// <summary>
    /// NMHDR structure that contains information about the message. 
    /// </summary>
    NMHDR hdr;
    /// <summary>
    /// Handle to the window occupying the data display area of the PivotControl
    /// page. 
    /// </summary>
    HWND hwndPage;
    /// <summary>
    /// PivotControl page ID. 
    /// </summary>
    int iPageId;
} NMPVCPAGE;

/// <summary>
/// Structure that the PivotControl uses to request its hosted pages execute custom
/// animation if supported.
/// </summary>
typedef struct _NM_PVCPAGEANIMATION
{
    /// <summary>
    /// NMHDR structure that contains information about the message. 
    /// </summary>
    NMHDR hdr;
    /// <summary>
    /// The direction the window should animate, right < 0 and left >= 0.
    /// </summary>
    int nDirection;
    /// <summary>
    /// The amount of milliseconds after which the window should begin the animation.
    /// </summary>
    DWORD dwBeginTime;
    /// <summary>
    /// The amount of milliseconds the animation should play.
    /// </summary>
    DWORD dwDuration;
} NMPVCPAGEANIMATION;

/// <summary>
/// Notification structure that the PivotControl received non-navigation 
/// keyboard input. 
/// </summary>
typedef struct _NM_PVCINPUT
{
    /// <summary>
    /// NMHDR structure that contains information about the message.
    /// </summary>
    NMHDR hdr;

    /// <summary>
    /// Input message ID (such as WM_CHAR, etc)
    /// </summary>
    UINT  uMsg;

    /// <summary>
    /// WPARAM corresponding to the message ID
    /// </summary>
    WPARAM wParam;

    /// <summary>
    /// LPARAM corresponding to the message ID
    /// </summary>
    LPARAM lParam;
} NMPVCINPUT;

/// <summary>
/// This message notifies the PivotControl's parent window that the currently
/// active page is about to change. It is sent in the form of a WM_NOTIFY message.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPIVOT *) lParam;
/// Long pointer to an NMPVCPIVOT structure. The hwndFrom member is the handle
/// to the PivotControl. The code member is PVCN_ACTIVEPAGECHANGING. The
/// idFrom member is the ID of the PivotControl. iOldActiveItemId will be the ID 
/// of the active page before the change, and iNewActiveItemId will be the ID of 
/// the active page after the change. If there is no information for the page IDs 
/// (i.e. The new page ID does not exist because all pages have been removed from 
/// the pivot), PVC_ERR will be returned.
/// </param>
/// <returns>
/// If the owner doesn't want to allow the active page to change, the owner
/// can return PC_ACTIVATIONNOTIFICATIONRESULT_DONTALLOW.  
/// Otherwise the owner should return PC_ACTIVATIONNOTIFICATIONRESULT_ALLOW.
/// If the PVCN_ACTIVEPAGECHANGING got triggered because the active page 
/// got deleted, the return value will be ignored, and the page change will occur.
/// </returns>
#define PVCN_ACTIVEPAGECHANGING         (PVCN_FIRST - 1)

/// <summary>
/// This message notifies the PivotControl's parent window that the 
/// currently active page has changed.  It is sent in the form of a 
/// WM_NOTIFY message.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPIVOT *) lParam;
/// Long pointer to an NMPVCPIVOT structure. The hwndFrom member is the handle
/// to the PivotControl. The code member is PVCN_ACTIVEPAGECHANGED. The
/// idFrom member is the ID of the PivotControl. The iScrollDirection and
/// iPageId will identify the active page and how it was selected. 
/// </param>
/// <returns> None </returns>
#define PVCN_ACTIVEPAGECHANGED       (PVCN_FIRST - 2)

/// <summary>
/// This message notifies a PivotControl page that it is about to 
/// lose focus. It is sent in the form of a WM_NOTIFY message.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPAGE *) lParam; 
/// Long pointer to an NMPVCPAGE structure. The hwndFrom member is the handle
/// to the PivotControl. The code member is PVCN_KILLACTIVE.  The hwndPage
/// member is the window handle to the data display area, iPageId is the ID
/// of the PivotControl page.
/// </param>
/// <returns> None </returns>
#define PVCN_KILLACTIVE              (PVCN_FIRST - 3)

/// <summary>
/// This message notifies a PivotControl page that it is about to gain 
/// focus. It is sent in the form of a WM_NOTIFY message.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPAGE *) lParam; 
/// Long pointer to an NMPVCPAGE structure. The hwndFrom member is the handle
/// to the PivotControl. The code member is PVCN_SETACTIVE.  The hwndPage
/// member is the window handle to the data display area, iPageId is the ID
/// of the PivotControl page.
/// </param>
/// <returns> None </returns>
#define PVCN_SETACTIVE               (PVCN_FIRST - 4)

/// <summary>
/// This message notifies the sink window of the active page (or the parent window 
/// of the PivotControl if there is no sink window specified) of keyboard input 
/// messages that were not handled by either the PivotControl or the active page.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCINPUT *) lParam; 
/// Long pointer to an NMPVCPAGE structure. The hwndFrom member is the handle
/// to the PivotControl. The code member is PVCN_KEYINPUT. The uMsg is the
/// input message ID. wParam and lParam depend on uMsg
/// </param>
/// <returns> None </returns>
#define PVCN_KEYINPUT                (PVCN_FIRST - 5)

/// <summary>
/// This message is sent to the active pivot page telling it
/// to play its entrance animation if supported.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPAGEANIMATION *) lParam; 
/// Long pointer to an NMPVCPAGEANIMATION structure. The hwndFrom member is 
/// the handle to the PivotControl. The code member is PVCN_ANIMATEPAGEENTRANCE. 
/// The nDirection indicates which direction the page should animate. The 
/// dwBeginTime indicates the delay that should be used before the animation
/// plays. The dwDuration indicates how long the animation should play.
/// </param>
/// <returns>
/// If the pivot page supports this animation and is successful in queuing 
/// this animation then it should return PC_PAGEANIMATIONNOTIFICATIONRESULT_HANDLED. 
/// Otherwise, the page should return PC_PAGEANIMATIONNOTIFICATIONRESULT_NOTHANDLED, 
/// in which case the pivot control will play the default animation.
/// </returns>
#define PVCN_ANIMATEPAGEENTRANCE     (PVCN_FIRST - 6)

/// <summary>
/// This message is sent to the active pivot page telling it
/// to play its exit animation if supported.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPAGEANIMATION *) lParam; 
/// Long pointer to an NMPVCPAGEANIMATION structure. The hwndFrom member is 
/// the handle to the PivotControl. The code member is PVCN_ANIMATEPAGEEXIT. 
/// The nDirection indicates which direction the page should animate. The 
/// dwBeginTime indicates the delay that should be used before the animation
/// plays. The dwDuration indicates how long the animation should play.
/// </param>
/// <returns> 
/// If the pivot page supports this animation and is successful in queuing 
/// this animation then it should return PC_PAGEANIMATIONNOTIFICATIONRESULT_HANDLED. 
/// Otherwise, the page should return PC_PAGEANIMATIONNOTIFICATIONRESULT_NOTHANDLED, 
/// in which case the pivot control will play the default animation.
/// </returns>
#define PVCN_ANIMATEPAGEEXIT         (PVCN_FIRST - 7)

/// <summary>
/// This message is sent to the active pivot page in response to the pivot
/// control receiving a PVCM_ANIMATEACTIVATION telling the active page 
/// to play its activation animation if supported.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPAGEANIMATION *) lParam; 
/// Long pointer to an NMPVCPAGEANIMATION structure. The hwndFrom member is 
/// the handle to the PivotControl. The code member is PVCN_ANIMATEPAGEACTIVATION. 
/// The nDirection member of this struct is not used for this command. The 
/// dwBeginTime indicates the delay that should be used before the animation
/// plays. The dwDuration indicates how long the animation should play.
/// </param>
/// <returns> 
/// If the pivot page supports this animation and is successful in queuing 
/// this animation then it should return PC_PAGEANIMATIONNOTIFICATIONRESULT_HANDLED. 
/// Otherwise, the page should return PC_PAGEANIMATIONNOTIFICATIONRESULT_NOTHANDLED, 
/// in which case the pivot control will play the default animation.
/// </returns>
#define PVCN_ANIMATEPAGEACTIVATION   (PVCN_FIRST - 8)


/// <summary>
/// This message notifies the PivotControl's parent window that the window handle
/// for one of its pages is needed. 
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPAGE *) lParam; 
/// Long pointer to an NMPVCPAGE structure. The hwndFrom member is the handle
/// to the PivotControl. The code member is PVCN_GETPAGEHWND.  The hwndPage
/// member is not set, iPageId is the ID of the page that needs to be associated with
/// a correct window handle.
/// </param>
/// <returns> 
/// The parent window should return the window handle that is to be associated
/// with the iPageId. The window will become a child of the pivot control, and the pivot
/// control will take ownership of the window, until it is removed from the pivot.
/// </returns>
#define PVCN_GETPAGEHWND (PVCN_FIRST - 9)

/// <summary>
/// This message informs a pivot page that a pivot pan has started.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPAGE *) lParam; 
/// Long pointer to an NMPVCPAGE structure. The hwndFrom member is the handle
/// to the PivotControl. The code member is PVCN_PANSTARTED.  The hwndPage
/// member is the window handle to the data display area, iPageId is the ID
/// of the PivotControl page.
/// </param>
/// <returns> 
/// The return value is ignored
/// </returns>
#define PVCN_PANSTARTED          (PVCN_FIRST - 10)

/// <summary>
/// This message informs a pivot page that a pivot pan has ended.
/// </summary>
/// <param name="lParam"> lpnm = (NMPVCPAGE *) lParam; 
/// Long pointer to an NMPVCPAGE structure. The hwndFrom member is the handle
/// to the PivotControl. The code member is PVCN_PANENDED.  The hwndPage
/// member is the window handle to the data display area, iPageId is the ID
/// of the PivotControl page.
/// </param>
/// <returns> 
/// The return value is ignored
/// </returns>
#define PVCN_PANENDED            (PVCN_FIRST - 11)


// Wizard class name
#define WC_WIZARD            L"SysWizard"

#define WIZN_FIRST          (0U-1000U)  // Wizard Framework notification range.
#define WIZN_LAST           (0U-1019U)   

#define WIZM_FIRST           0x1500     // Wizard Framework messages


/// <summary>
/// Possible user actions for a wizard page.
/// By default, the start page has Next and Cancel, subsequent pages
/// have Back/Next/Cancel, except the last page of the wizard, which 
/// has Back/Finish/Cancel. Skip can be added on to a page if the page 
/// marks itself as allowing the verb.
/// </summary>
typedef enum tagWIZARD_VERB
{
    /// <summary>
    /// Verb that causes wizard framework to save data on current page and
    /// transition to the next page.
    /// </summary>
    WIZARD_VERB_NEXT = 0x1,
    
    /// <summary>
    /// Verb that causes wizard framework to return to the previous page.
    /// </summary>
    WIZARD_VERB_BACK = 0x2,
    
    /// <summary>
    /// Verb that causes wizard framework to skip current page and transition
    /// to next page.
    /// </summary>    
    WIZARD_VERB_SKIP = 0x4,
    
    /// <summary>
    /// Verb that causes wizard framework to abandon all pages and close.
    /// </summary>    
    WIZARD_VERB_CANCEL = 0x8,
    
    /// <summary>
    /// Verb that causes wizard framework to save all pages and close.
    /// </summary>
    WIZARD_VERB_FINISH = 0x10,
    
} WIZARD_VERB;

/// <summary>
/// This structure is used for wizard verb notifications
/// </summary>
typedef struct tagNMWIZARDVERB
{
    /// <summary>
    /// Structure containing information about a message.
    /// </summary>
    NMHDR hdr;
    
    /// <summary>
    /// Verb type
    /// </summary>
    WIZARD_VERB wizVerb;
    
    /// <summary>
    /// [in/out] Window handle of the next page in the flow if the wizard 
    /// knows it. This value is NULL if the wizard needs the app to tell
    /// it where to transition to next or INVALID_HANDLE_VALUE if the wizard
    /// is about to end.
    /// </summary>
    HWND hwndNext;
    
} NMWIZARDVERB; 

/// <summary>
/// This notification is sent when the user hits a verb on the menu
/// Menu verbs: Next, Back, Skip, Cancel, Finish
/// </summary>
/// <param name="wParam"> Not used.</param>
/// <param name="lParam"> [in/out] pnmwizVerb = (NMWIZARDVERB *) lParam;
/// The wizVerb element of the NMWIZARDVERB structure contains the
/// verb that the notification is about.
/// The hwndNext element of the NMWIZARDVERB structure contains the 
/// window handle the wizard should transition to next. If the wizard
/// framework needs this window handle from the app, this value is NULL.
/// If there is no further flow in the wizard (cancel, finish), this value
/// is INVALID_HANDLE_VALUE.
/// </param>
/// <returns>
/// If the hwndNext value is NULL for a Next/Skip notification, the owner 
/// app must fill in a valid hwndNext value. The owner app can also 
/// overwrite a non-null hwndNext value provided by the wizard to change
/// the page sequence.
/// The return value for this notification should be 0 on success, -1
/// on failure (in which case, the verb will not be executed and the wizard
/// framework will stay on the current active page)
/// </returns>
#define    WIZN_ONVERB             (WIZN_FIRST - 1)

/// <summary>
/// This notification is sent to all wizard pages when the wizard has to 
/// close unexpectedly due to external events 
/// (Eg. User gets an incoming call while in a non-modal wizard)
/// </summary>
/// <param name="wParam"> Not used.</param>
/// <param name="lParam"> [in] pnmhdr = (NMHDR *) lParam;</param>
/// <returns>
/// The owner app should return 0 - the owner could also choose to save
/// incomplete data at this point. The wizard framework closes all pages
/// after this notification.
/// </returns>
#define    WIZN_ONABORT              (WIZN_FIRST - 2)

/// <summary>
/// Load types for a wizard page.
/// </summary>
typedef enum tagWIZARD_PAGELOADTYPE
{
    /// <summary>
    /// Wizard page being loaded for the first time.
    /// </summary>
    WIZARD_PAGELOADTYPE_INITIALLOAD = 0x0,
    
    /// <summary>
    /// Wizard page being reloaded while the user is moving forward in the wizard.
    /// </summary>
    WIZARD_PAGELOADTYPE_FORWARDRELOAD = 0x01,
    
    /// <summary>
    /// Wizard page being reloaded while the user is moving backwards through
    /// the wizard.
    /// </summary>    
    WIZARD_PAGELOADTYPE_REVERSERELOAD = 0x02,
    
} WIZARD_PAGELOADTYPE;

/// <summary>
/// This structure is used for page load notifications - pages are loaded
/// for the first time when they get added to the wizard, and then can 
/// be reloaded if the user navigates backwards and forwards through open
/// wizard pages.
/// </summary>
typedef struct tagNMWIZARDPAGELOAD
{
    /// <summary>
    /// Structure containing information about a message.
    /// </summary>
    NMHDR hdr;
    
    /// <summary>
    /// Load type information.
    /// </summary>
    WIZARD_PAGELOADTYPE wizPageLoadType;
    
    /// <summary>
    /// [in/out] DWORD containing page property flags.
    /// </summary>
    DWORD dwFlags;
    
} NMWIZARDPAGELOAD; 

/// <summary>
/// Wizard results after launch. These values are 
/// returned after a call to WIZM_LAUNCHWIZARD
/// </summary>
typedef enum tagWIZARD_RESULT
{
    /// <summary>
    /// Wizard did not run successfully.
    /// </summary>
    WIZARD_RESULT_ERROR = 0x00,

    /// <summary>
    /// Wizard finished successfully.
    /// </summary>
    WIZARD_RESULT_FINISH = 0x01,
    
    /// <summary>
    /// Wizard was canceled by the user.
    /// </summary>
    WIZARD_RESULT_CANCEL = 0x02,
    
    /// <summary>
    /// Wizard had to be forcefully closed as an abort. 
    /// </summary>    
    WIZARD_RESULT_ABORT = 0x03,
} WIZARD_RESULT;


// Page property flags
#define  WIZF_PAGE_START       0x0001  // Page with no Back option
#define  WIZF_PAGE_MIDFLOW     0x0002  // Page with both Next and Back options
#define  WIZF_PAGE_FINISH      0x0004  // Page with Finish instead of Next
#define  WIZF_PAGE_ALLOW_SKIP  0x0008  // Page with additional Skip option
#define  WIZF_PAGE_NORETURN    0x0010  // Page that does not allow the user to 
                                       // come Back to it once Next/Skip is hit
#define  WIZF_PAGE_CHAINLINK   0x0020  // Last page of a wizard in the wizard chain
                                       // but links to the first page of the next
                                       // wizard in the chain - can only be set with
                                       // WIZF_PAGE_FINISH

/// <summary>
/// This notification is sent to a page when it is being made visible to
/// the user, either for the first time or on a reload.
/// </summary>
/// <param name="wParam"> Not used.</param>
/// <param name="lParam"> [in/out] pnmhdr = (NMWIZARDPAGELOAD *) lParam;
/// The wizPageLoadType value in the NMWIZARDPAGELOAD struct informs the page 
/// whether this is the very first time the user is seeing the page or whether 
/// the page has already been visited before, and also the direction the user
/// is moving in through the wizard if this is a reload. The dwFlags contain
/// information about the page and its properties.
/// </param>
/// <returns>
/// -1 if the page does not want to be loaded and should be skipped over.
/// 0 if the page is ok being loaded. The page can set its property flags
/// in the dwFlags entry of the NMWIZARDPAGELOAD struct.
/// </returns>
#define    WIZN_ONPAGELOAD           (WIZN_FIRST - 3)

/// <summary>
/// This notification is sent to the wizard chain owner when the finish page
/// of the wizard is reached so that the chain owner can tell the framework 
/// whether the wizard chain is expected to continue or not.
/// </summary>
/// <param name="wParam"> Not used.</param>
/// <param name="lParam"> [in/out] pnmhdr = (NMWIZARDPAGELOAD *) lParam;
/// The wizPageLoadType value in the NMWIZARDPAGELOAD struct informs the page 
/// whether this is the very first time the user is seeing the page or whether 
/// the page has already been visited before, and also the direction the user
/// is moving in through the wizard if this is a reload. The dwFlags contain
/// information about the page and its properties.
/// </param>
/// <returns>
/// To inform the wizard framework that the wizard chain continues, the 
/// WIZF_PAGE_CHAINLINK flag should be set in the dwFlags entry of the
/// NMWIZARDPAGELOAD struct. If the wizard chain ends at this page, the 
/// flag should be cleared.
/// </returns>
#define    WIZN_ONFINISHPAGELOAD              (WIZN_FIRST - 4)


/// <summary>
/// This message sets the start page of the wizard and launches the wizard.
/// A SendMessage on this is a synchronous call that does not return till
/// the wizard closes.
/// </summary>
/// <param name="wParam"> [in] Window handle for the start page.
/// wParam = (WPARAM)(HWND) hwndStartPage; 
/// </param>
/// <param name="lParam"> Not used.
/// </param>
/// <returns>
/// WIZARD_RESULT denoting wizard state on close.
/// </returns>
#define    WIZM_LAUNCHWIZARD         (WIZM_FIRST + 1)

/// <summary>
/// This message allows the owner application to enable or disable user
/// actions (Back, Next, Cancel, Finish, Skip) on the current active page.
/// </summary>
/// <param name="wParam"> [in] Mask that specifies verbs that should be
/// changed. Use same constants used in the description of 
/// <paramref name="dwWizVerbsEnable"/>.
/// wParam = (WPARAM)(DWORD) dwWizVerbsMask; 
/// </param>
/// <param name="lParam"> [in] Bit field of verbs to enable. Verbs specified in
/// <paramref name="dwWizVerbsMask"/> that are not present in 
/// <paramref name="dwWizVerbsEnable"/> will be disabled.
/// wParam = (LPARAM)(DWORD) dwWizVerbsEnable; 
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
/// <remarks>
/// If the owner application disables verbs on a page, it is the owner
/// app's responsibility to re-enable the verbs appropriately so that
/// the user can proceed with the wizard.
/// <para> Sample usage: To disable Back and Cancel and enable Next: 
/// </para>
/// <para> 
/// PostMessage(hwndWizard, WIZM_CHANGEVERBS, 
/// (WPARAM)(WIZARD_VERB_BACK | WIZARD_VERB_CANCEL | WIZARD_VERB_NEXT), 
/// (LPARAM)(WIZARD_VERB_NEXT)); 
/// </para>
/// </remarks>
#define    WIZM_CHANGEVERBS          (WIZM_FIRST + 2)

/// <summary>
/// This message allows the owner application to trigger a wizard verb.
/// </summary>
/// <param name="wParam"> [in] Wizard verb code. 
///     Example: wParam = (WPARAM) WIZARD_VERB_BACK; 
/// </param>
/// <param name="lParam"> NULL.
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define    WIZM_DOVERB               (WIZM_FIRST + 3)

/// <summary>
/// This message allows the owner application to retrieve page properties.
/// </summary>
/// <param name="wParam"> [in] A mask that specifies the bit flags to 
/// be changed. Use the same constants shown in the description of dwFlags. 
/// wParam = (WPARAM)(DWORD) dwMask; 
/// </param>
/// <param name="lParam"> [in] Set of bit flags that specifies properties of 
/// the wizard page.
/// lParam = (LPARAM)(DWORD) dwFlags; 
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
#define    WIZM_GETPAGEPROPERTIES    (WIZM_FIRST + 4)

/// <summary>
/// This message allows the owner application to set page property bit flags.
/// </summary>
/// <param name="wParam"> Not used.
/// </param>
/// <param name="lParam"> Not used.
/// </param>
/// <returns>
/// DWORD containing page property flags.
/// </returns>
#define    WIZM_SETPAGEPROPERTIES    (WIZM_FIRST + 5)

/// <summary>
/// This message allows the owner application to mark a wizard as the start
/// of a wizard chain.
/// </summary>
/// <param name="wParam"> [in] Window handle for the chain owner.
/// wParam = (WPARAM)(HWND) hwndChainOwner; 
/// </param>
/// <param name="lParam"> Not used.
/// </param>
/// <returns>
/// TRUE indicates success. FALSE indicates failure.
/// </returns>
/// <remarks>
/// The chain owner window gets notified when the last page of a wizard is
/// loaded and should inform the framework whether there is a wizard in the
/// chain after the current one. If there is, the last page of the current
/// wizard shows up with Next on the softkey instead of Finish, and transitions
/// to the first page of the next wizard in the chain. The chain owner 
/// gets the "Next" notification and is required to provide the handle to 
/// the first page of the next wizard.
/// </remarks>
#define    WIZM_STARTWIZARDCHAIN    (WIZM_FIRST + 6)


// Spinner class name
#define WC_SPINNER           L"SysSpinner"

// Spinner control specific notification range.
#define SPNN_FIRST          (0U-1350U)
#define SPNN_LAST           (0U-1399U)

// Spinner Control specific messages
#define SPNM_FIRST          0x1700

/// <summary>
/// Spinner style - Notifies the parent window when the state of spinner
//  has been changed.
/// </summary>
#define SPNS_NOTIFY             LBS_NOTIFY

/// <summary>
/// Spinner style - The user can select any number of strings.
/// </summary>
#define SPNS_MULTIPLESEL        LBS_MULTIPLESEL

/// <summary>
/// This message is sent by an application to add a string to a spinner.
/// The string is added to the end of the spinner.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">
/// (LPARAM)(LPCTSTR) lpsz
/// Long pointer to the null-terminated string to be added. 
/// Control will only cach up to 260 characters (MAX_PATH).
/// </param>
/// <returns>
/// The zero-based index of the string in the spinner indicates success. 
/// SPN_ERR indicates that an error has occurred.
/// </returns>
#define SPNM_ADDSTRING          LB_ADDSTRING

/// <summary>
/// This message is sent by an application to insert a string into a spinner.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) index;
/// Zero-based index of the position at which to insert the string.
/// If this parameter is -1, the string is added to the end of the spinner. 
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM)(LPCTSTR) lpsz;
/// Long pointer to the null-terminated string to be inserted. 
/// Control will only cach up to 260 characters (MAX_PATH).
/// </param>
/// <returns>
/// The index of the position at which the string was inserted indicates success.
/// SPN_ERR indicates that an error has occurred. 
/// </returns>
#define SPNM_INSERTSTRING       LB_INSERTSTRING

/// <summary>
/// This message is sent by an application to delete a string in a spinner. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) index;
/// Zero-based index of the string to be deleted. 
/// </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// A count of the strings remaining in the spinner indicates success. 
/// SPN_ERR indicates that the index parameter specifies an index
/// greater than the number of items in the spinner.
/// </returns>
#define SPNM_DELETESTRING       LB_DELETESTRING

/// <summary>
/// This message is sent by an application to remove all items from a spinner. 
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// Always returns 1.
/// </returns>
#define SPNM_RESETCONTENT       LB_RESETCONTENT

/// <summary>
/// This message is sent by an application to select a string in a multiple-selection
/// spinner
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) (BOOL) fSelect; 
/// Boolean that specifies how to set the selection. If set to TRUE, the string is
/// selected. If set to FALSE, the string is no longer selected.
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM) (UINT) index;
/// Zero-based index of the string to set. If index is -1, the selection is added to
/// or removed from all strings, depending on the value of fSelect.
/// </param>
/// <returns>
/// SPN_ERR indicates that an error has occurred.
/// </returns>
#define SPNM_SETSEL             LB_SETSEL

/// <summary>
/// This message is sent by an application to select a string.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) index; 
/// Zero-based index of the string that is selected.
/// </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// SPN_ERR indicates that an error has occurred.
/// </returns>
#define SPNM_SETCURSEL          LB_SETCURSEL

/// <summary>
/// This message is sent by an application to retrieve the selection state of an item. 
/// </summary>
/// <param "wParam">
/// wParam = (WPARAM) index
/// Zero-based index of the item.
/// </param>
/// <param "lParam">Not used.</param>
/// <returns>
/// A value greater than zero indicates that an item has been selected. Zero indicates
/// otherwise. SPN_ERR indicates that an error has occurred.
/// </returns>
#define SPNM_GETSEL             LB_GETSEL

/// <summary>
/// This message is sent by an application to retrieve the index of the currently
/// selected item.
/// </summary>
/// <param "wParam">Not used.</param>
/// <param "lParam">Not used.</param>
/// <returns>
/// The return value will be SPN_ERR if spinner control is empty. Otherwise,
/// it will be zero-based index of the currently selected item.
/// </returns>
#define SPNM_GETCURSEL          LB_GETCURSEL

/// <summary>
/// This message is sent by an application to retrieve a string from a spinner. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) index;
/// Zero-based index of the string to retrieve. 
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM)(LPCTSTR) lpszBuffer;
/// Long pointer to the buffer to receive the string.
/// The buffer must have sufficient space for the string and a terminating null
/// character.
/// An SPNM_GETTEXTLEN message can be sent before the SPNM_GETTEXT message to retrieve
/// the length, in characters, of the string. 
/// </param>
/// <returns>
/// The length of the string, in characters and excluding the terminating null
/// character, indicates success.
/// SPN_ERR indicates that index does not specify a valid index. 
/// </returns>
#define SPNM_GETTEXT            LB_GETTEXT

/// <summary>
/// This message is sent by an application to retrieve the length of a string in a
/// spinner. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) index;
/// Zero-based index of the string. 
/// </param>
/// <param name="lParam"> Not used.</param>
/// <returns>
/// The length of the string, in characters and excluding the terminating null
/// character, indicates success.
/// SPN_ERR indicates that the index parameter does not specify a valid index.
/// </returns>
#define SPNM_GETTEXTLEN         LB_GETTEXTLEN

/// <summary>
/// This message is sent by an application to retrieve the number of items in a
/// spinner. 
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// The number of items in the spinner indicates success. 
/// SPN_ERR indicates that an error has occurred.
/// </returns>
#define SPNM_GETCOUNT           LB_GETCOUNT

/// <summary>
/// This message is sent by an application to search a spinner for an item that
/// begins with the characters in a specified string. If a exactly matching item
/// is found, the item is selected. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) indexStart;
/// Zero-based index of the item before the first item to be searched.
/// When the search reaches the bottom of the spinner,
/// it continues from the top of the spinner back to the item specified by the
/// indexStart parameter.
/// If indexStart is -1, the entire spinner is searched from the beginning. 
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM)(LPCTSTR) lpszFind;
/// Long pointer to the null-terminated string that contains the prefix to search for.
/// The search is case independent, so this string can contain any combination
/// of uppercase and lowercase letters.
/// </param>
/// <returns>
/// The index of the selected item indicates a successful search. 
/// SPN_ERR indicates an unsuccessful search; the current selection is not changed.
/// </returns>
#define SPNM_SELECTSTRING       LB_SELECTSTRING

/// <summary>
/// This message is sent by an application to find the first exactly macth string
/// in a spinner that contains the specified prefix. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) indexStart;
/// Zero-based index of the item before the first item to be searched.
/// When the search reaches the bottom of the spinner, it continues from the top
/// of the spinner back to the item specified by the indexStart parameter.
/// If indexStart is -1, the entire list box is searched from the beginning.
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM)(LPCTSTR) lpszFind;
/// Long pointer to the null-terminated string that contains the prefix to search for.
/// The search is case independent, so this string can contain any combination
/// of uppercase and lowercase letters.
/// </param>
/// <returns>
/// The zero-based index of the matching item indicates success.
/// SPN_ERR indicates an unsuccessful search.
/// </returns>
#define SPNM_FINDSTRING         LB_FINDSTRING

/// <summary>
/// This message is sent by an application to find the first spinner string that
/// matches the string specified in the lpszFind parameter. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) indexStart;
/// Zero-based index of the item before the first item to be searched.
/// When the search reaches the bottom of the spinner, it continues from the top
/// of the spinner back to the item specified by the indexStart parameter.
/// If indexStart is -1, the entire list box is searched from the beginning.
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM)(LPCTSTR) lpszFind;
/// Long pointer to the null-terminated string that contains the prefix to search for.
/// The search is case independent, so this string can contain any combination
/// of uppercase and lowercase letters.
/// </param>
/// <returns>
/// The zero-based index of the matching item indicates success.
/// SPN_ERR indicates an unsuccessful search.
/// </returns>
#define SPNM_FINDSTRINGEXACT    LB_FINDSTRINGEXACT

/// <summary>
/// This message is sent by an application to retrieve the total number of selected
/// items in a multiple-selection spinner.
/// </summary>
/// <param name="wParam">Not used.</param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// The count of selected items in the spinner indicates success. SPN_ERR indicates
/// that the spinner is a single-selection spinner. 
/// </returns>
#define SPNM_GETSELCOUNT        LB_GETSELCOUNT

/// <summary>
/// This message is sent by an application to fill a buffer with an array of integers
/// that specify the item numbers of selected items in a multiple-selection spinner. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) cItems;
/// Specifies the maximum number of selected items whose item numbers are to be placed
/// in the buffer.
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM)(LPINT) lpnItems;
/// Long pointer to a buffer large enough for the number of integers specified by the
/// cItems parameter.
/// </param>
/// <returns>
/// The return value is the number of items placed in the buffer. If the spinner is
/// single-selection, the return value is SPN_ERR. This message will also return
/// SPN_ERR if you pass invalid parameters for a multi-selection spinner. 
/// </returns>
#define SPNM_GETSELITEMS        LB_GETSELITEMS

/// <summary>
/// This message is sent by an application to retrieve the application-defined
/// 32-bit value associated with the specified spinner item. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) index;
/// Index of the item. 
/// </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// The return value is the 32-bit value associated with the item,
/// or SPN_ERR if an error occurs.
/// </returns>
#define SPNM_GETITEMDATA        LB_GETITEMDATA

/// <summary>
/// This message is sent by an application to set a 32-bit value associated with
/// the specified item in a spinner.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) index; 
/// Zero-based index of the item.
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM)(DWORD) dwData;
/// Specifies the 32-bit value to be associated with the item.
/// </param>
/// <returns>
/// SPN_ERR indicates that an error has occurred.
/// </returns>
#define SPNM_SETITEMDATA        LB_SETITEMDATA

/// <summary>
/// This message is sent by an application to select one or more consecutive items in
/// a multiple-selection spinner. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM)(BOOL) fSelect;
/// Boolean that specifies how to set the selection. If set to a nonzero value, the
/// string is selected. If set to zero, the string is no longer selected.
/// </param>
/// <param name="lParam">
/// lParam = MAKELPARAM(wFirst, wLast);
/// wFirst  Zero-based index of the first item to select. 
/// wLast   Zero-based index of the last item to select. 
/// </param>
/// <returns>
/// SPN_ERR indicates that an error has occurred.
/// </returns>
/// <remarks>
/// Use this message only with multiple-selection spinner. 
/// This message can select a range only within the first 65,536 items. 
/// </remarks>
#define SPNM_SELITEMRANGE       LB_SELITEMRANGE

/// <summary>
/// This message is sent by an application to select one or more consecutive items in
/// a multiple-selection spinner. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) wFirst;
/// Zero-based index of the first item to select. 
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM) wLast;
/// Zero-based index of the last item to select. 
/// </param>
/// <returns>
/// SPN_ERR indicates that an error has occurred.
/// </returns>
/// <remarks>
/// If the wFirst parameter is less than the wLast parameter, the specified range of
/// items is selected.
/// If wFirst is greater than wLast, the selection is removed from the specified range
/// of items. 
/// Use this message only with multiple-selection spinner. 
/// This message can select a range only within the first 65,536 items. 
/// </remarks>
#define SPNM_SELITEMRANGEEX     LB_SELITEMRANGEEX

/// <summary>
/// This message is sent by an application to set the focus item at the specified index
/// in a spinner control.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) index;
/// Zero-based index of the spinner item that is to receive the focus.
/// </param>
/// <param name="lParam">Not Used.</param>
/// <returns>
/// SPN_ERR indicates that an error has occurred. Otherwise, control will return SPN_OKAY.
/// </returns>
#define SPNM_SETCARETINDEX      LB_SETCARETINDEX

/// <summary>
/// This message is sent by an application to determine the index of the item that has
/// the focus in a spinner control. The item may or may not be selected.
/// </summary>
/// <param name="wParam">Not Used.</param>
/// <param name="lParam">Not Used.</param>
/// <returns>
/// The return value is the zero-based index of the spinner item that has the focus.
/// If the spinner control is a single-selection spinner control, the return value is
/// the zero-based index of the item selected, if any. 
/// </returns>
#define SPNM_GETCARETINDEX      LB_GETCARETINDEX

/// <summary>
/// This message is sent by an application to set static text in a multiple-selection
/// spinner. 
/// </summary>
/// <param name="wParam">Not Used.</param>
/// <param name="lParam">
/// lParam = (LPARAM)(LPTSTR) pszText;
/// A pointer to the static text. NULL indicates removing static text.
/// </param>
/// <returns>
/// SPN_ERR indicates that an error has occurred.
/// If the spinner is single-selection, the return value is SPN_ERR.
/// </returns>
#define SPNM_SETSTATICTEXT      (SPNM_FIRST + 1)

/// <summary>
/// This message is sent by an application to receive static text in a multiple-
/// selection spinner. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) cchBuffer;
/// Specifies the maximum number of characters in the passed in buffer, the pszBuffer
/// parameter.
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM)(LPTSTR) pszBuffer;
/// Pointer to a buffer large enough for the number of charachter specified by the
/// cchBuffer parameter. This is buffer is for receiving static text in multi-
/// selection spinner.
/// </param>
/// <returns>
/// The number of characters copied into pszBuffer parameter. Otherwise, SPN_ERR
/// indicates that an error has occurred.
/// If the spinner is single-selection, the return value is SPN_ERR.
/// </returns>
#define SPNM_GETSTATICTEXT      (SPNM_FIRST + 2)

/// <summary>
/// This message is sent by an application to receive static text length in a
/// multiple-selection spinner. 
/// </summary>
/// <param name="wParam">Not Used.</param>
/// <param name="lParam">Not Used.</param>
/// <returns>
/// The length of static text.
/// SPN_ERR indicates that an error has occurred.
/// If the spinner is single-selection, the return value is SPN_ERR.
/// </returns>
#define SPNM_GETSTATICTEXTLEN   (SPNM_FIRST + 3)

/// <summary>
/// Spinner control return value.
/// </summary>
/// <remarks>
/// These values are coresponding to Listbox's return values.
/// </remarks>
#define SPN_OKAY            LB_OKAY
#define SPN_ERR             LB_ERR
#define SPN_ERRSPACE        LB_ERRSPACE

/// <summary>
/// This message is sent by spinner control to application when the selection in
/// spinner control is about to change. The parent window of the spinner control
/// receives this message through the WM_COMMAND message. 
/// </summary>
/// <param name="wParam">
/// idSpinner = (int)LOWORD(wParam);
/// Identifier of the spinner.
/// </param>
/// <param name="lParam">
/// hwndSpinner = (HWND) lParam;
/// Handle to the spinner.
/// </param>
/// <returns>
/// None.
/// </returns>
#define SPNN_SELCHANGE          LBN_SELCHANGE

/// <summary>
/// This message is sent by spinner control to application when spinner control
/// receives the keyboard focus. The parent window of the spinner control receives
/// this message through the WM_COMMAND message. 
/// </summary>
/// <param name="wParam">
/// idSpinner = (int)LOWORD(wParam);
/// Identifier of the spinner. 
/// </param>
/// <param name="lParam">
/// hwndSpinner = (HWND) lParam;
/// Handle to the spinner.
/// </param>
/// <returns>
/// None.
/// </returns>
#define SPNN_SETFOCUS           LBN_SETFOCUS

/// <summary>
/// This message is sent by spinner control to application when spinner control
/// loses the keyboard focus. The parent window of the spinner control receives
/// this message through the WM_COMMAND message. 
/// </summary>
/// <param name="wParam">
/// idSpinner = (int)LOWORD(wParam);
/// Identifier of the spinner. 
/// </param>
/// <param name="lParam">
/// hwndSpinner = (HWND) lParam;
/// Handle to the spinner.
/// </param>
/// <returns>
/// None.
/// </returns>
#define SPNN_KILLFOCUS          LBN_KILLFOCUS

/// <summary>
/// This message notifies the owner window of keyboard input messages that were
/// not handled by the spinner control.
/// </summary>
/// <param name="wParam">Not Used.</param>
/// <param name="lParam">
/// lpnm = (NMSPNINPUT *) lParam; 
/// Long pointer to an NMSPNINPUT structure. The hwndFrom member is the handle
/// to the spinner. The code member is SPNN_KEYINPUT. The uMsg is the
/// input message ID. wParam and lParam depend on uMsg
/// </param>
/// <returns>
/// None.
/// </returns>
#define SPNN_KEYINPUT           (SPNN_FIRST - 1)

/// <summary>
/// Notification structure that the spinner control received non-navigation 
/// keyboard input. 
/// </summary>
typedef struct _NM_SPNINPUT
{
    /// <summary>
    /// NMHDR structure that contains information about the message.
    /// </summary>
    NMHDR hdr;

    /// <summary>
    /// Input message ID (such as WM_CHAR, etc)
    /// </summary>
    UINT  uMsg;

    /// <summary>
    /// WPARAM corresponding to the message ID
    /// </summary>
    WPARAM wParam;

    /// <summary>
    /// LPARAM corresponding to the message ID
    /// </summary>
    LPARAM lParam;
} NMSPNINPUT;

/// <summary>
/// This message notifies the owner window that spinner control is about to bring
/// up the picker dialog to pick item.
/// </summary>
/// <param name="wParam">Not Used.</param>
/// <param name="lParam"> 
/// lpnm = (NMSPNPICKITEM *) lParam; 
/// Long pointer to an NMSPNPICKITEM structure. The hwndFrom member is the handle
/// to the spinner. The code member is SPNN_PICKITEM. The pDataSource is the an
/// IVirtualList object pointing to the data source stores in spinner.
/// </param>
/// <returns>
/// An application should return non-Zero value if it processes this message.
/// If the owner of spinner is a dialog box, it will need to set the result value
/// via SetWindowLong(hDlg, DWL_MSGRESULT, 1) and also return TRUE.
/// </returns>
#define SPNN_PICKITEM           (SPNN_FIRST - 2)

/// <summary>
/// Notification structure that the spinner control received non-navigation 
/// keyboard input. 
/// </summary>
typedef struct _NM_SPNPICKITEM
{
    /// <summary>
    /// NMHDR structure that contains information about the message.
    /// </summary>
    NMHDR hdr;

    /// <summary>
    /// Long pointer to the data source, an IVirtualList.
    /// </summary>
    IVirtualList* pDataSource;
} NMSPNPICKITEM;


// ===================== Task Dialog =========================

/// <summary>
/// The TaskDialogCallbackProc function is an application-defined function used with
/// the TaskDialogIndirect function.
/// It receives messages from the task dialog when various events occur.
/// </summary>
/// <param name="hwnd">
/// [in] Handle to the TaskDialog window.
/// Do not continue sending messages to hwnd after the callback procedure returns from
/// having been called with TDN_DESTROYED. 
/// </param>
/// <param name="uNotification">
/// [in] One of the following notifications.
///     TDN_CREATED              Indicates that the task dialog has been created. 
///     TDN_BUTTON_CLICKED       Indicates that a button has been selected. 
///     TDN_DESTROYED            Indicates that the task dialog has been destroyed. 
///     TDN_RADIO_BUTTON_CLICKED Indicates that a radio button has been selected. 
///     TDN_DIALOG_CONSTRUCTED   Indicates that the task dialog has been constructed.
///     TDN_VERIFICATION_CLICKED Indicates that the check box has been clicked.
/// </param>
/// <param name="wParam">
/// [in] Specifies additional notification information.
/// The contents of this parameter depend on the value of the uNotification parameter.
/// </param>
/// <param name="lParam">
/// [in] Specifies additional notification information.
/// The contents of this parameter depend on the value of the uNotification parameter.
/// </param>
/// <param name="lpRefData">
/// [in] Pointer to application specific data.
/// This is the data pointed to by the lpCallbackData member of structure
/// TASKDIALOGCONFIG used to create the task dialog.
/// </param>
/// <retruns>
/// The return value is specific to the notification being processed.
/// </returns>
typedef HRESULT (CALLBACK *PFTASKDIALOGCALLBACK)(__in HWND hwnd, __in UINT uNotification, __in WPARAM wParam, __in LPARAM lParam, __in LONG_PTR lpRefData);


/// <summary>
/// Specify the behavior of the task dialog.
/// </summary>
/// <remarks>
/// The following values defined in Vista won't be supported.
///     TDF_ENABLE_HYPERLINKS           = 0x0001
///     TDF_USE_HICON_FOOTER            = 0x0004
///     TDF_ALLOW_DIALOG_CANCELLATION   = 0x0008
///     TDF_USE_COMMAND_LINKS           = 0x0010
///     TDF_EXPAND_FOOTER_AREA          = 0x0040
///     TDF_EXPANDED_BY_DEFAULT         = 0x0080
///     TDF_SHOW_PROGRESS_BAR           = 0x0200
///     TDF_SHOW_MARQUEE_PROGRESS_BAR   = 0x0400
///     TDF_CALLBACK_TIMER              = 0x0800
///     TDF_POSITION_RELATIVE_TO_WINDOW = 0x1000
///     TDF_CAN_BE_MINIMIZED            = 0x8000
/// </remarks>
enum _TASKDIALOG_FLAGS
{
    /// <summary>
    /// Indicates that the dialog should use the icon referenced by the handle in the
    /// hMainIcon member as the primary icon in the task dialog.
    /// If this flag is specified, the pszMainIcon member is ignored. 
    /// </summary>
    TDF_USE_HICON_MAIN              = 0x0002,
    /// <summary>
    /// Indicates that the buttons specified in the pButtons member which its ID value
    /// is with TDCBID_COMMANDLINK_FIRST and TBCBID_COMMANDLINK_LAST range should be
    /// displayed as command links (using a standard task dialog glyph) instead of
    /// menu items in central menu or soft keys.
    /// This flag is ignored if the cButtons member is zero.
    /// </summary>
    TDF_USE_COMMAND_LINKS_NO_ICON   = 0x0020,
    /// <summary>
    /// Indicates that the verification checkbox in the dialog is checked when the
    /// dialog is initially displayed.
    /// This flag is ignored if the pszVerificationText parameter is NULL. 
    /// </summary>
    TDF_VERIFICATION_FLAG_CHECKED   = 0x0100,
    /// <summary>
    /// Indicates that text is displayed reading right to left. 
    /// </summary>
    TDF_RTL_LAYOUT                  = 0x2000,
    /// <summary>
    /// Indicates that no default item will be selected. 
    /// </summary>
    TDF_NO_DEFAULT_RADIO_BUTTON     = 0x4000
};
typedef int TASKDIALOG_FLAGS;

#define TDCBID_COMMANDLINK_FIRST    0xFFA0
#define TDCBID_COMMANDLINK_LAST     0xFFEF


/// <summary>
/// Specify the common menu items displayed in the central menu of task dialog.
/// The order of these common menu items in central menu is listed below.
///     TDCBF_YES_BUTTON
///     TDCBF_NO_BUTTON
///     TDCBF_RETRY_BUTTON
///     TDCBF_CLOSE_BUTTON
///     TDCBF_OK_BUTTON
///     TDCBF_CANCEL_BUTTON
/// 
/// If pButtons member in TASKDIALOGCONFIG/CETASKDIALOGCONFIG structure is specified,
/// the custom menu items will take priority and be added in front of common menu
/// items.
/// </summary>
enum _TASKDIALOG_COMMON_BUTTON_FLAGS
{
    /// <summary>
    /// Add "Okay" to central menu.
    /// 
    /// If there is no custom button assigned to left softkey and TDCBF_YES_BUTTON
    /// and TDCBF_RETRY_BUTTON is not specified, than this menu item will be
    /// associated to left softkey.
    /// 
    /// This common menu item can only be associated to left softkey.
    /// </summary>
    TDCBF_OK_BUTTON         = 0x0001,
    /// <summary>
    /// Add "Yes" to central menu.
    /// 
    /// If there is no custom button assigned to left softkey, than this menu
    /// item will be associated to left softkey.
    /// 
    /// This common menu item can only be associated to left softkey.
    /// </summary>
    TDCBF_YES_BUTTON        = 0x0002,
    /// <summary>
    /// Add "No" to central menu.
    /// 
    /// If there is no custom button assigned to right softkey, than this menu
    /// item will be associated to right softkey.
    /// 
    /// This common menu item can only be associated to right softkey.
    /// </summary>
    TDCBF_NO_BUTTON         = 0x0004,
    /// <summary>
    /// Add "Cancel" to central menu.
    /// 
    /// If there is no custom button assigned to right softkey and TDCBF_NO_BUTTON
    /// and TDCBF_CLOSE_BUTTON is not specified, than this menu item will be
    /// associated to right softkey.
    /// 
    /// This common menu item can only be associated to right softkey.
    /// </summary>
    TDCBF_CANCEL_BUTTON     = 0x0008,
    /// <summary>
    /// Add "Retry" to central menu.
    /// 
    /// If there is no custom button assigned to left softkey and TDCBF_YES_BUTTON
    /// is not specified, than this menu item will be associated to left softkey.
    /// 
    /// This common menu item can only be associated to left softkey.
    /// </summary>
    TDCBF_RETRY_BUTTON      = 0x0010,
    /// <summary>
    /// Add "Close" to central menu.
    /// 
    /// If there is no custom button assigned to right softkey and TDCBF_NO_BUTTON
    /// is not specified, than this menu item will be associated to right softkey.
    /// 
    /// This common menu item can only be associated to right softkey.
    /// </summary>
    TDCBF_CLOSE_BUTTON      = 0x0020
};
typedef int TASKDIALOG_COMMON_BUTTON_FLAGS;


/// <summary>
/// The TASKDIALOG_BUTTON structure contains information used to display a button,
/// menu item, and a soft key in a task dialog.
/// </summary>
typedef struct _TASKDIALOG_BUTTON
{
    /// <summary>
    /// Indicates the value to be returned when this button is selected.
    /// </summary>
    int nButtonID;
    /// <summary>
    /// Pointer that references the string to be used to label the button.
    /// This parameter can be either a null-terminated string or an integer resource
    /// identifier passed to the MAKEINTRESOURCE macro.
    /// </summary>
    PCWSTR pszButtonText;
} TASKDIALOG_BUTTON;


/// <summary>
/// The TASKDIALOGCONFIG structure contains information used to display a task dialog.
/// </summary>
typedef struct _TASKDIALOGCONFIG
{
    /// <summary>
    /// Specify the structure size, in bytes.
    /// </summary>
    UINT cbSize;
    /// <summary>
    /// Handle to the parent window.
    /// </summary>
    HWND hwndParent;
    /// <summary>
    /// Handle to the module that contains the icon resource identified by the 
    /// pszMainIcon, and the string resources identified by the pszMainInstruction,
    /// pszContent, pButtons, pRadioButtons or pszVerificationText members.
    /// </summary>
    HINSTANCE hInstance;
    /// <summary>
    /// Specify the behavior of the task dialog. This parameter can be a value
    /// from TASKDIALOG_FLAGS (TDF_xxx).
    /// </summary>
    TASKDIALOG_FLAGS dwFlags;
    /// <summary>
    /// Specify the right soft keys displayed in the task dialog.
    /// This parameter can be a one of value from TASKDIALOG_COMMON_BUTTON
    /// (TDCBF_XXX).
    /// </summary>
    TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons;
    /// <summary>
    /// Pointer that references the string to be used for task dialog window title.
    /// The content is retrievable by GetWindowText API with the task dialog window
    /// handle.
    /// This member can be either a null-terminiated string or an integrer resource
    /// identifier passed to the MAKEINTRESOURCE macro.
    /// </summary>
    PCWSTR pszWindowTitle;
    union
    {
        /// <summary>
        /// A handle to an Icon that is to be displayed in the task dialog.
        /// This member is ignored unless the TDF_USE_HICON_MAIN flag is specified.
        /// If this member is NULL and the TDF_USE_HICON_MAIN is specified,
        /// no icon will be displayed.
        /// </summary>
        HICON hMainIcon;
        /// <summary>
        /// Pointer that references the icon to be displayed in the task dialog.
        /// This parameter is ignored if the USE_HICON_MAIN flag is specified.
        /// So when USE_HICON_MAIN flag is not specified:
        /// . If this member is NULL, no icon will be displayed.
        /// . If this member is one of predefined icons from ID_xxx_ICON, hInstance
        ///   parameter will be ignore.
        /// . If this member is an integer resource identifier passed to the
        ///   MAKEINTRESOURCE macro, hInstance parameter can't be NULL. Otherwise,
        ///   API will return E_INVALIDARG.
        /// </summary>
        PCWSTR pszMainIcon;
    };
    /// <summary>
    /// Pointer that references the string to be used for the task dialog title.
    /// This member can be either a null-terminated string or an integer resource 
    /// identifier passed to the MAKEINTRESOURCE macro.
    /// If the string is too long, it will be wrapped onto the second line and will
    /// be truncated after that and using an ellipsis.
    /// </summary>
    PCWSTR pszMainInstruction;
    /// <summary>
    /// Pointer that references the string to be used for the dialog's primary
    /// content.
    /// This parameter can be either a null-terminated string or an integer resource
    /// identifier passed to the MAKEINTRESOURCE macro. 
    /// </summary>
    PCWSTR pszContent;
    /// <summary>
    /// The number of entries in the pButtons array that is used to create buttons or
    /// command links in the dialog.
    /// If this member is zero and no common buttons have been specified using the
    /// dwCommonButtons member, then the task dialog will have a single Close button
    /// displayed. However, if TDF_USE_COMMAND_LINKS_NO_ICON is specified in dwFlags
    /// member, API will fail and return E_INVALDARG.
    /// </summary>
    UINT cButtons;
    /// <summary>
    /// Pointer to an array of TASKDIALOG_BUTTON structures containing the definition
    /// of the custom buttons that are to be displayed in the dialog.
    /// This array must contain at least the number of entries that are specified by
    /// the cButtons member. 
    /// 
    /// The member nButtonID can be one of those common button ID.
    /// If the common button ID is specified, pszButtonText member can be NULL and the
    /// system defined label will be applied.
    ///
    /// If the button id falls in the range between TDCBID_COMMANDLINK_FIRST and
    /// TDCBID_COMMANDLINK_LAST and TDF_USE_COMMAND_LINKS_NO_ICON is specified in 
    /// dwFlags member, this button will be shown as command link in task dialog. 
    /// Otherwise, it will be a menu item in menu bar.
    ///
    /// The content of member pszButtonText for a command link can't have anchor
    /// defined in it. Otherwise, task dialog will fail and return E_INVALIDARG.
    /// For example, the content of command link like below is not allowed.
    ///   "Click the link below <A ID="12345"> new location </A>".
    ///
    /// Task dialog will respect the order of this TASKDIALOG_BUTTON array. I.E., the
    /// order of the menu items will base on the order in this array, even it is one 
    /// of common buttons. And then, task dialog will add the common buttons if there
    /// is any.
    ///
    /// Task dialog should have at least one soft key. Either specify one of common
    /// button in dwCommonButtons member, or has one entry that is not command link
    /// here.
    /// </summary>
    const TASKDIALOG_BUTTON *pButtons;
    /// <summary>
    /// The default menu item (left softkey) or command link for the dialog.
    /// This may be any of the values specified in nButtonID members of one of the
    /// TASKDIALOG_BUTTON structures in the pButtons array or one of the common button
    /// ID.
    /// If this member is zero or its value does not correspond to any button ID in
    /// the dialog, then the first command link in the dialog will be the default and
    /// the first menu item in central menu will be associated to left softkey, the 
    /// second menu item in the central menu will be associated to right softkey.
    /// For the button ID such like IDNO, IDCLOSE, or IDCANCEL is invalid left softkey
    /// ID, task dialog will treat it as invalid button ID.
    /// </summary>
    int nDefaultButton;
    /// <summary>
    /// The number of entries in the pRadioButtons array that is used to create radio
    /// buttons in the dialog. 
    /// </summary>
    UINT cRadioButtons;
    /// <summary>
    /// Pointer to an array of TASKDIALOG_BUTTON structures containing the definition
    /// of the radio buttons that are to be displayed in the dialog.
    /// 
    /// This array must contain at least the number of entries that are specified by
    /// the cRadioButtons member.
    /// 
    /// This parameter can be NULL. 
    ///
    /// The radio button id must not conflict with any one of common button id (IDOK,
    /// IDYES, IDNO, IDCANCEL, IDRETRY, IDCLOSE) or specified button id. If this
    /// occurred API will return E_INVALIDARG.
    /// 
    /// </summary>
    const TASKDIALOG_BUTTON *pRadioButtons;
    /// <summary>
    /// The button ID of the radio button that is selected by default.
    /// If this value does not correspond to a button ID, the first button in the
    /// array is selected by default. 
    /// </summary>
    int nDefaultRadioButton;
    /// <summary>
    /// Pointer that references the string to be used to label the verification
    /// checkbox.
    /// This parameter can be either a null-terminated string or an integer resource
    /// identifier passed to the MAKEINTRESOURCE macro.
    /// If this parameter is NULL, the verification checkbox is not displayed in the
    /// task dialog.
    /// If the pfVerificationFlagChecked parameter of TaskDialogIndirect is NULL, the
    /// checkbox is not enabled. 
    /// </summary>
    PCWSTR pszVerificationText;
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    PCWSTR pszExpandedInformation;
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    PCWSTR pszExpandedControlText;
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    PCWSTR pszCollapsedControlText;
    union
    {
        /// <summary>
        /// Not supported. Must be 0.
        /// </summary>
        HICON hFooterIcon;
        /// <summary>
        /// Not supported. Must be 0.
        /// </summary>
        PCWSTR pszFooterIcon;
    };
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    PCWSTR pszFooter;
    /// <summary>
    /// Pointer to an application-defined callback function. For more information see
    /// TaskDialogCallbackProc. 
    /// </summary>
    PFTASKDIALOGCALLBACK pfCallback;
    /// <summary>
    /// A pointer to application-defined reference data. This value is defined by the
    /// caller.
    /// </summary>
    LONG_PTR lpCallbackData;
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    UINT cxWidth;
} TASKDIALOGCONFIG;


/// <summary>
/// The TaskDialogIndirect function creates, displays, and operates a task dialog.
/// The task dialog contains application-defined icons, messages, title, menu items,
/// verification check box, command links, and radio buttons.
/// This function can register a call back function to receive notification messages.
/// </summary>
/// <param name="pTaskConfig">
/// [in] Pointer to a TASKDIALOGCONFIG structure that contains information used to
/// display the task dialog.
/// 
/// TASKDIALOGCONFIG structure pointer and pass it to this function.
/// </param>
/// <param name="pnButton">
/// [out] Address of a variable that receives either:
/// 
///   - one of the button IDs specified in the pButtons member of the pTaskConfig
///     parameter.
///
///   - one of the following values:
///     0        Function call failed. Refer to return value for more information. 
///     IDOK (1)        Ok soft key was pressed.
///     IDCANCEL (2)    Cancel soft key was pressed.
///     IDRETRY (4)     Retry soft key / menu item was selected.
///     IDYES (6)       Yes soft key / menu item was selected.
///     IDNO (7)        No soft key / menu item was selected.
///     IDCLOSE (8)     Close soft key / men item was selected.
/// 
/// If this parameter is NULL, no value is returned.
/// </param>
/// <param name="pnRadioButton">
/// [out] Address of a variable that receives one of the button IDs specified in
/// the pRadioButtons member of the pTaskConfig parameter.
///
/// If this parameter is NULL, no value is returned. 
/// </param>
/// <param name="pfVerificationFlagChecked">
/// [out] Address of a variable that receives one of the following values:
/// 
///     TRUE    The verification checkbox was checked when the dialog was dismissed. 
///     FALSE   The verification checkbox was not checked when the dialog was
///             dismissed. 
/// 
/// If this parameter is NULL, no value is returned. 
/// </param>
/// <returns>
/// Returns one of the following values:
///
///     S_OK            The operation completed successfully.
///     E_OUTOFMEMORY   There is insufficient memory to complete the operation.
///     E_INVALIDARG    One or more arguments are invalid.
///     E_FAIL          The operation failed.
/// </returns>
#ifdef __cplusplus
extern "C"
#endif
HRESULT WINAPI TaskDialogIndirect(
    const TASKDIALOGCONFIG *pTaskConfig,
    __out_opt int *pnButton,
    __out_opt int *pnRadioButton,
    __out_opt BOOL *pfVerificationFlagChecked);


/// <summary>
/// The notifications sent from task dialog.
/// These notifications are received only through the task dialog callback function,
/// which can be registered using the TaskDialogIndirect method. 
/// </summary>
/// <remarks>
/// The following Vista definitions are not supported:
///     TDN_NAVIGATED                       = 1
///     TDN_HYPERLINK_CLICKED               = 3
///     TDN_TIMER                           = 4
///     TDN_HELP                            = 9
///     TDN_EXPANDO_BUTTON_CLICKED          = 10
/// </remarks>
typedef enum _TASKDIALOG_NOTIFICATIONS
{
    /// <summary>
    /// Sent by the task dialog once the dialog has been created and before it is
    /// displayed.
    /// </summary>
    /// <param name="wParam">Not used.</param>
    /// <param name="lParam">Not used.</param>
    /// <returns>Ignored.</returns>
    TDN_CREATED                         = 0,
    /// <summary>
    /// Sent by the task dialog when the user selects a button or command link in 
    /// the task dialog.
    /// </summary>
    /// <param name="wParam">
    /// wParam = (WPARAM) (int) nButtonID
    ///     nButtonID : [in] The button ID corresponding to the button selected.
    /// </param>
    /// <param name="lParam">Not used.</param>
    /// <returns>
    /// To prevent the task dialog from closing, the application must return E_FAIL,
    /// otherwise the task dialog will be closed and the button ID returned via 
    /// the original application call.
    /// </returns>
    TDN_BUTTON_CLICKED                  = 2,
    /// <summary>
    /// Sent by the task dialog when it is destroyed and its window handle is no 
    /// longer valid.
    /// </summary>
    /// <param name="wParam">Not used.</param>
    /// <param name="lParam">Not used.</param>
    /// <returns>Ignored.</returns>
    TDN_DESTROYED                       = 5,
    /// <summary>
    /// Sent by the task dialog when the user selects a button or command link in the
    /// task dialog. 
    /// </summary>
    /// <param name="wParam">
    /// wParam = (WPARAM) (int) nRadioButtonID
    ///     nRadioButtonID : [in] The ID corresponding to the radio button that was
    ///                      clicked.
    /// </param>
    /// <param name="lParam">Not used.</param>
    /// <returns>Ignored.</returns>
    TDN_RADIO_BUTTON_CLICKED            = 6,
    /// <summary>
    /// Sent by the task dialog once the dialog has been created and before it is
    /// displayed. 
    /// </summary>
    /// <param name="wParam">Not used.</param>
    /// <param name="lParam">Not used.</param>
    /// <returns>Ignored.</returns>
    TDN_DIALOG_CONSTRUCTED              = 7,
    /// <summary>
    /// Sent by the task dialog when the user clicks the task dialog verification
    /// check box.
    /// </summary>
    /// <param name="wParam">Not used.</param>
    /// <param name="lParam">Not used.</param>
    /// <returns>Ignored.</returns>
    TDN_VERIFICATION_CLICKED            = 8
} TASKDIALOG_NOTIFICATIONS;


// The following messages are defined in Vista, but not supported in Windows Mobile
// #define TDM_NAVIGATE_PAGE               (WM_USER+101)
// #define TDM_SET_MARQUEE_PROGRESS_BAR    (WM_USER+103)
// #define TDM_SET_PROGRESS_BAR_STATE      (WM_USER+104)
// #define TDM_SET_PROGRESS_BAR_RANGE      (WM_USER+105)
// #define TDM_SET_PROGRESS_BAR_POS        (WM_USER+106)
// #define TDM_SET_PROGRESS_BAR_MARQUEE    (WM_USER+107)
// #define TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE (WM_USER+115)

/// <summary>
/// Simulates the action of a button click in the task dialog.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) (int) nButton
///     nButton : [in] The button ID to be selected.
/// </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// If the function succeeds, the return value is nonzero.
/// </returns>
#define TDM_CLICK_BUTTON                (WM_USER+102)

/// <summary>
/// Used by clients to update a text element on the task dialog.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) (TASKDIALOG_ELEMENTS) eElement
///     eElement : [in] Indicates the element to update. This parameter must be one
///                of the TASKDIALOG_ELEMENTS values.
///         TDE_CONTENT             Content
///         TDE_MAIN_INSTRUCTION    Sub-title
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM) (LPCWSTR) pszNewText
///     pszNewText : [in] The new text to use.
/// </param>
/// <returns>
/// Ignored.
/// </returns>
#define TDM_SET_ELEMENT_TEXT            (WM_USER+108)

/// <summary>
/// Simulates the action of a radio button click in the task dialog.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) (int) nRadioButton
///     nRadioButton = [in] The ID of the radio button to be selected.
/// </param>
/// <param name="lParam">Not used.</param>
/// <returns>
/// Ignored.
/// </returns>
#define TDM_CLICK_RADIO_BUTTON          (WM_USER+110)

/// <summary>
/// Enables or disables a push button in the task dialog.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) (int) nButton
///     nButton : [in] The ID of the push button to be enabled or disabled.
/// </param>
/// <param name="lParam">
/// [in] Specifies button state.
/// Set to 0 to disable the button; set to non-zero to enable the button.
/// </param>
/// <returns>
/// Ignored.
/// </returns>
#define TDM_ENABLE_BUTTON               (WM_USER+111)

/// <summary>
/// Enables or disables a radio button in the task dialog.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) (int) nRadioButton
///     nRadioButton : [in] The ID of the radio button to be enabled or disabled.
/// </param>
/// <param name="lParam">
/// [in] Specifies button state.
/// Set to 0 to disable the button; set to non-zero to enable the button.
/// </param>
/// <returns>
/// Ignored.
/// </returns>
#define TDM_ENABLE_RADIO_BUTTON         (WM_USER+112)

/// <summary>
/// Simulates a click on the verification checkbox of the task dialog, if it exists.
/// </summary>
/// <param name="wParam">
/// [in] TRUE to set the state of the checkbox to be checked; FALSE to set it to be
/// unchecked.
/// </param>
/// <param name="lParam">
/// [in] TRUE to set the keyboard focus to the checkbox; FALSE otherwise.
/// </param>
/// <returns>
/// Ignored.
/// </returns>
#define TDM_CLICK_VERIFICATION          (WM_USER+113)

/// <summary>
/// Use by clients to update a text element on the task dialog. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) (TASKDIALOG_ELEMENTS) eElement
///     eElement : [in] Indicates the element to update. This parameter must be one
///                of the TASKDIALOG_ELEMENTS values.
///         TDE_CONTENT             Content
///         TDE_MAIN_INSTRUCTION    Sub-title
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM) (LPCWSTR) pszNewText
///     pszNewText : [in] Pointer to a Unicode string that indicates the new text to
///                  use.
/// </param>
/// <returns>
/// Ignored.
/// </returns>
#define TDM_UPDATE_ELEMENT_TEXT         (WM_USER+114)

/// <summary>
/// Refreshes the icon of a task dialog. A window receives this message through its
/// WindowProc function.
/// </summary>
/// <param name="wParam">Ignored.</param>
/// <param name="lParam">
/// [in] A pointer to a string (PCWSTR) or handle to an icon (HICON) to display.
/// If lParam is NULL, then no icon is displayed.
/// If the TDF_USE_HICON_MAIN flag is set on the dwFlags member of the
/// TASKDIALOGCONFIG structure used to create the task dialog, then lParam must
/// contain a handle to an icon (HICON) to display.
/// If the TDF_USE_HICON_MAIN flags are not set on the dwFlags member, then lParam
/// must point to a null-terminated, Unicode string (PCWSTR) that contains a valid
/// resource identifier passed through the MAKEINTRESOURCE macro.
/// The resource must be either from the application's resource module (specified in
/// the hInstance member of the TASKDIALOGCONFIG structure), or if hInstance is NULL,
/// from the system's resource module (imageres.dll).
/// To identify a system resource, use a valid system identifier passed through the
/// MAKEINTRESOURCE macro or one of the following predefined icon values:
///     TD_WARNING_ICON         An exclamation point icon.
///     TD_ERROR_ICON           A stop sign icon.
///     TD_INFORMATION_ICON     A icon consisting of a lowercase letter i in a circle.
///     TD_SHIELD_ICON          A shield icon.
///     TD_CONFIRMATION_ICON    A confirmation icon.
/// </param>
/// <returns>
/// Ignored.
/// </returns>
#define TDM_UPDATE_ICON                 (WM_USER+116)


/// <summary>
/// Task dailog text elements
/// </summary>
/// <remarks>
/// The following definitions from Vista are not supported:
///     TDE_EXPANDED_INFORMATION    = 0x0001
///     TDE_FOOTER                  = 0x0002
/// </remarks>
typedef enum _TASKDIALOG_ELEMENTS
{
    TDE_CONTENT             = 0x0000,
    TDE_MAIN_INSTRUCTION    = 0x0003
} TASKDIALOG_ELEMENTS;


/// <summary>
/// A pre-defined stop-sign icon Used with TaskDialogIndirect.
/// </summary>
#define TD_WARNING_ICON         MAKEINTRESOURCEW(-1)
/// <summary>
/// A pre-defined exclamation-point icon Used with TaskDialogIndirect.
/// </summary>
#define TD_ERROR_ICON           MAKEINTRESOURCEW(-2)
/// <summary>
/// A pre-defined icon consisting of a lowercase letter i in a circle used  with
/// TaskDialogIndirect.
/// </summary>
#define TD_INFORMATION_ICON     MAKEINTRESOURCEW(-3)
/// <summary>
/// A pre-defined shield icon used  with TaskDialogIndirect.
/// </summary>
#define TD_SHIELD_ICON          MAKEINTRESOURCEW(-4)
/// <summary>
/// A pre-defined confirmation icon used  with TaskDialogIndirect.
/// </summary>
#define TD_CONFIRMATION_ICON    MAKEINTRESOURCEW(-10)


/// <summary>
/// Specify the CE only behaviors of the task dialog.
/// </summary>
enum _CETASKDIALOG_FLAGS
{
    /// <summary>
    /// Indicates that the dialog will be timed out after the time specified in
    /// nTimeOut member.
    /// The returned value of pnButton that passed into TaskDialogIndirect will be
    /// ZERO if the dialog is closed due to timed out.
    /// </summary>
    CETDF_TIMED                     = 0x00000001,
    /// <summary>
    /// Indicates that the dialog will be brought to foreground.
    /// </summary>
    CETDF_SETFOREGROUND             = 0x00000002,
    /// <summary>
    /// Indicates that the dialog will be canceled when loss activation.
    /// The returned value of pnButton that passed into TaskDialogIndirect will be
    /// ZERO if the dialog is closed due to activation loss.
    /// </summary>
    CETDF_CLOSE_ON_ACTIVATION_LOSS  = 0x00000004,
    /// <summary>
    /// Indicates that the dialog will supresses any default sounds.
    /// </summary>
    CETDF_SUPRESS_DEFAULT_SOUND     = 0x00000008,
    /// <summary>
    /// Indicates that the text box in task dialog will be a password style.
    /// If the member of pszTextBox of CETASKDIALOGCONFIG is NULL, this flag will be
    /// ignored.
    /// </summary>
    CETDF_PASSWORD_TEXTBOX          = 0x00000010,
};
typedef int CETASKDIALOG_FLAGS;


/// <summary>
/// The CETASKDIALOGCONFIG, the extended CETASKDIALOGCONFIG structure contains
/// additional CE only behaviors information that used to display a task dialog.
/// 
/// The top part of CETASKDIALOGCONFIG structure is exactly identical to 
/// TASKDIALOGCONFIG structure. The difference start from dwCeFlags member.
///
/// This structure is for CeTaskDialogIndirect function.
/// </summary>
typedef struct _CETASKDIALOGCONFIG
{
    /// <summary>
    /// Specify the structure size, in bytes.
    /// </summary>
    UINT cbSize;
    /// <summary>
    /// Handle to the parent window.
    /// </summary>
    HWND hwndParent;
    /// <summary>
    /// Handle to the module that contains the icon resource identified by the 
    /// pszMainIcon, and the string resources identified by the pszMainInstruction,
    /// pszContent, pButtons, pRadioButtons or pszVerificationText members.
    /// </summary>
    HINSTANCE hInstance;
    /// <summary>
    /// Specify the behavior of the task dialog. This parameter can be a value
    /// from TASKDIALOG_FLAGS (TDF_xxx).
    /// </summary>
    TASKDIALOG_FLAGS dwFlags;
    /// <summary>
    /// Specify the right soft keys displayed in the task dialog.
    /// This parameter can be a one of value from TASKDIALOG_COMMON_BUTTON
    /// (TDCBF_XXX).
    /// </summary>
    TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons;
    /// <summary>
    /// Pointer that references the string to be used for task dialog window title.
    /// The content is retrievable by GetWindowText API with the task dialog window
    /// handle.
    /// This member can be either a null-terminiated string or an integrer resource
    /// identifier passed to the MAKEINTRESOURCE macro.
    /// </summary>
    PCWSTR pszWindowTitle;
    union
    {
        /// <summary>
        /// A handle to an Icon that is to be displayed in the task dialog.
        /// This member is ignored unless the TDF_USE_HICON_MAIN flag is specified.
        /// If this member is NULL and the TDF_USE_HICON_MAIN is specified,
        /// no icon will be displayed.
        /// </summary>
        HICON hMainIcon;
        /// <summary>
        /// Pointer that references the icon to be displayed in the task dialog.
        /// This parameter is ignored if the USE_HICON_MAIN flag is specified.
        /// So when USE_HICON_MAIN flag is not specified:
        /// . If this member is NULL, no icon will be displayed.
        /// . If this member is one of predefined icons from ID_xxx_ICON, hInstance
        ///   parameter will be ignore.
        /// . If this member is an integer resource identifier passed to the
        ///   MAKEINTRESOURCE macro, hInstance parameter can't be NULL. Otherwise,
        ///   API will return E_INVALIDARG.
        /// </summary>
        PCWSTR pszMainIcon;
    };
    /// <summary>
    /// Pointer that references the string to be used for the task dialog title.
    /// This member can be either a null-terminated string or an integer resource 
    /// identifier passed to the MAKEINTRESOURCE macro.
    /// If the string is too long, it will be wrapped onto the second line and will
    /// be truncated after that and using an ellipsis.
    /// </summary>
    PCWSTR pszMainInstruction;
    /// <summary>
    /// Pointer that references the string to be used for the dialog's primary
    /// content.
    /// This parameter can be either a null-terminated string or an integer resource
    /// identifier passed to the MAKEINTRESOURCE macro. 
    /// </summary>
    PCWSTR pszContent;
    /// <summary>
    /// The number of entries in the pButtons array that is used to create buttons or
    /// command links in the dialog.
    /// If this member is zero and no common buttons have been specified using the
    /// dwCommonButtons member, then the task dialog will have a single Close button
    /// displayed. However, if TDF_USE_COMMAND_LINKS_NO_ICON is specified in dwFlags
    /// member, API will fail and return E_INVALDARG.
    /// </summary>
    UINT cButtons;
    /// <summary>
    /// Pointer to an array of TASKDIALOG_BUTTON structures containing the definition
    /// of the custom buttons that are to be displayed in the dialog.
    /// This array must contain at least the number of entries that are specified by
    /// the cButtons member. 
    /// 
    /// The member nButtonID can be one of those common button ID.
    /// If the common button ID is specified, pszButtonText member can be NULL and the
    /// system defined label will be applied.
    ///
    /// If the button id falls in the range between TDCBID_COMMANDLINK_FIRST and
    /// TDCBID_COMMANDLINK_LAST and TDF_USE_COMMAND_LINKS_NO_ICON is specified in 
    /// dwFlags member, this button will be shown as command link in task dialog. 
    /// Otherwise, it will be a menu item in menu bar.
    ///
    /// The content of member pszButtonText for a command link can't have anchor
    /// defined in it. Otherwise, task dialog will fail and return E_INVALIDARG.
    /// For example, the content of command link like below is not allowed.
    ///   "Click the link below <A ID="12345"> new location </A>".
    ///
    /// Task dialog will respect the order of this TASKDIALOG_BUTTON array. I.E., the
    /// order of the menu items will base on the order in this array, even it is one 
    /// of common buttons. And then, task dialog will add the common buttons if there
    /// is any.
    ///
    /// Task dialog should have at least one soft key. Either specify one of common
    /// button in dwCommonButtons member, or has one entry that is not command link
    /// here.
    /// </summary>
    const TASKDIALOG_BUTTON *pButtons;
    /// <summary>
    /// The default menu item (left softkey) or command link for the dialog.
    /// This may be any of the values specified in nButtonID members of one of the
    /// TASKDIALOG_BUTTON structures in the pButtons array or one of the common button
    /// ID.
    /// If this member is zero or its value does not correspond to any button ID in
    /// the dialog, then the first command link in the dialog will be the default and
    /// the first menu item in central menu will be associated to left softkey, the 
    /// second menu item in the central menu will be associated to right softkey.
    /// For the button ID such like IDNO, IDCLOSE, or IDCANCEL is invalid left softkey
    /// ID, task dialog will treat it as invalid button ID.
    /// </summary>
    int nDefaultButton;
    /// <summary>
    /// The number of entries in the pRadioButtons array that is used to create radio
    /// buttons in the dialog. 
    /// </summary>
    UINT cRadioButtons;
    /// <summary>
    /// Pointer to an array of TASKDIALOG_BUTTON structures containing the definition
    /// of the radio buttons that are to be displayed in the dialog.
    /// 
    /// This array must contain at least the number of entries that are specified by
    /// the cRadioButtons member.
    /// 
    /// This parameter can be NULL. 
    ///
    /// The radio button id must not conflict with any one of common button id (IDOK,
    /// IDYES, IDNO, IDCANCEL, IDRETRY, IDCLOSE) or specified button id. If this
    /// occurred API will return E_INVALIDARG.
    /// 
    /// </summary>
    const TASKDIALOG_BUTTON *pRadioButtons;
    /// <summary>
    /// The button ID of the radio button that is selected by default.
    /// If this value does not correspond to a button ID, the first button in the
    /// array is selected by default. 
    /// </summary>
    int nDefaultRadioButton;
    /// <summary>
    /// Pointer that references the string to be used to label the verification
    /// checkbox.
    /// This parameter can be either a null-terminated string or an integer resource
    /// identifier passed to the MAKEINTRESOURCE macro.
    /// If this parameter is NULL, the verification checkbox is not displayed in the
    /// task dialog.
    /// If the pfVerificationFlagChecked parameter of TaskDialogIndirect is NULL, the
    /// checkbox is not enabled. 
    /// </summary>
    PCWSTR pszVerificationText;
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    PCWSTR pszExpandedInformation;
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    PCWSTR pszExpandedControlText;
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    PCWSTR pszCollapsedControlText;
    union
    {
        /// <summary>
        /// Not supported. Must be 0.
        /// </summary>
        HICON hFooterIcon;
        /// <summary>
        /// Not supported. Must be 0.
        /// </summary>
        PCWSTR pszFooterIcon;
    };
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    PCWSTR pszFooter;
    /// <summary>
    /// Pointer to an application-defined callback function. For more information see
    /// TaskDialogCallbackProc. 
    /// </summary>
    PFTASKDIALOGCALLBACK pfCallback;
    /// <summary>
    /// A pointer to application-defined reference data. This value is defined by the
    /// caller.
    /// </summary>
    LONG_PTR lpCallbackData;
    /// <summary>
    /// Not supported. Must be 0.
    /// </summary>
    UINT cxWidth;

    /// <summary>
    /// Specify the CE only behaviors of the task dialog. This parameter should be a
    /// value from CETASKDIALOG_FLAGS (CETDF_xxx).
    /// </summary>
    CETASKDIALOG_FLAGS dwCeFlags;
    /// <summary>
    /// Timeout in ms if dwCeFlags includes CETDF_TIMED. Set to 0 for default timeout.
    /// </summary>
    UINT nTimeOut;
    /// <summary>
    /// Pointer that references the string to be used to be default content of text
    /// box.
    /// 
    /// This parameter can be either a null-terminated string or an integer resource
    /// identifier passed to the MAKEINTRESOURCE macro.
    /// If this parameter is NULL, the text box is not displayed in task dialog.
    /// If this parameter is a NULL character string, the text box will be displayed
    /// in task dialog but no default content in it.
    /// 
    /// CETDF_PASSWORD_TEXTBOX is specified in dwCeFlags member, this text box will
    /// enable password style. All input content in text box will be displayed as "*".
    /// </summary>
    PCWSTR pszTextBox;
} CETASKDIALOGCONFIG;


/// <summary>
/// The CeTaskDialogIndirect function creates, displays, and operates a task dialog.
/// 
/// The task dialog contains application-defined icons, messages, title, menu items,
/// verification check box, command links, radio buttons, and text box.
///
/// This function can register a call back function to receive notification messages.
/// </summary>
/// <param name="pCeTaskConfig">
/// [in] Pointer to a CETASKDIALOGCONFIG structure that contains information used to
/// display the task dialog.
/// 
/// There is CE only extended behaviors defined in CETASKDIALOG_FLAGS.
/// This extended flag can be specified in dwCeFlags of CETASKDIALOGCONFIG structure
/// that is used in CeTaskDialogIndirect function.
/// </param>
/// <param name="pnButton">
/// [out] Address of a variable that receives either:
/// 
///   - one of the button IDs specified in the pButtons member of the pTaskConfig
///     parameter.
///
///   - one of the following values:
///     0        Function call failed. Refer to return value for more information. 
///     IDOK (1)        Ok soft key was pressed.
///     IDCANCEL (2)    Cancel soft key was pressed.
///     IDRETRY (4)     Retry soft key / menu item was selected.
///     IDYES (6)       Yes soft key / menu item was selected.
///     IDNO (7)        No soft key / menu item was selected.
///     IDCLOSE (8)     Close soft key / men item was selected.
/// 
/// If this parameter is NULL, no value is returned.
/// </param>
/// <param name="pnRadioButton">
/// [out] Address of a variable that receives one of the button IDs specified in
/// the pRadioButtons member of the pTaskConfig parameter.
///
/// If this parameter is NULL, no value is returned. 
/// </param>
/// <param name="pfVerificationFlagChecked">
/// [out] Address of a variable that receives one of the following values:
/// 
///     TRUE    The verification checkbox was checked when the dialog was dismissed. 
///     FALSE   The verification checkbox was not checked when the dialog was
///             dismissed. 
/// 
/// If this parameter is NULL, no value is returned. 
/// </param>
/// <param name="ppszInputText">
/// [out] Address of a Unicode string pointer that receives content of text box.
/// The buffer will be allocated by CeTaskDialogIndirect function. The caller is
/// responsible to call delete[] to delete the allocated buffer.
/// 
/// If there is no input in text box, the return value of this parameter will be
/// NULL.
/// 
/// If this parameter is NULL, no value is returned. 
/// </param>
/// <returns>
/// Returns one of the following values:
///
///     S_OK            The operation completed successfully.
///     E_OUTOFMEMORY   There is insufficient memory to complete the operation.
///     E_INVALIDARG    One or more arguments are invalid.
///     E_FAIL          The operation failed.
/// </returns>
#ifdef __cplusplus
extern "C"
#endif
HRESULT WINAPI CeTaskDialogIndirect(
    const CETASKDIALOGCONFIG *pCeTaskConfig,
    __out_opt int *pnButton,
    __out_opt int *pnRadioButton,
    __out_opt BOOL *pfVerificationFlagChecked,
    __out_opt PWSTR *ppszInputText);


// ==================== End TaskDialog =======================

// ===================== Status Dialog =========================



/// <summary>
/// Specify the behavior of the status dialog.
/// </summary>
typedef enum _STATUSDIALOG_FLAGS
{
    /// <summary>
    /// Indicates that a Progress Bar is to be displayed.
    /// </summary>
    SDF_SHOW_PROGRESS_BAR           = 0x0200,

    /// <summary>
    /// Indicates that an Marquee Progress Bar is to be displayed.
    /// </summary>
    SDF_SHOW_MARQUEE_PROGRESS_BAR   = 0x0400,

    /// <summary>
    /// Indicates that the dialog should use the icon referenced by the handle in the
    /// hMainIcon member as the primary icon in the status dialog.
    /// If this flag is specified, the pszMainIcon member is ignored. 
    /// </summary>
    SDF_USE_HICON_MAIN              = TDF_USE_HICON_MAIN, // 0x0002

    /// <summary>
    /// Indicates that the dialog will be timed out after the time specified in
    /// nTimeOut member.
    /// </summary>
    SDF_TIMED                       = CETDF_TIMED         // 0x0001
};
typedef int STATUSDIALOG_FLAGS;

typedef enum _STATUSDIALOG_DEFAULT_LABEL
{
    SDDL_FIRST = 1,
    SDDL_SEARCHING = SDDL_FIRST,
    SDDL_LOADING,
    SDDL_DOWNLOADING,
    SDDL_CONNECTING,
    
    SDDL_DOWNLOAD_COMPLETE,
    SDDL_COMPLETED,
    SDDL_FINISHED,
    SDDL_CONNECTED,
    SDDL_LAST = SDDL_CONNECTED
};
typedef int STATUSDIALOG_DEFAULT_LABEL;

/// <summary>
/// Status dialog text elements.
/// </summary>
typedef enum _STATUSDIALOG_ELEMENTS
{
    SDE_SECONDARY_LABEL  = TDE_CONTENT,
    SDE_PRIMARY_LABEL    = TDE_MAIN_INSTRUCTION
} STATUSDIALOG_ELEMENTS;

typedef struct _STATUSDIALOGCONFIG {
    /// <summary>
    /// Specifies the structure size, in bytes.
    /// </summary>
    UINT cbSize;

    /// <summary>
    /// Handle to the parent window. This member cannot be NULL.
    /// </summary>
    HWND hwndParent;

    /// <summary>
    /// Handle to the module that contains the icon resource identified by the 
    /// pszMainIcon and the string resources identified by the pszPrimaryLabel or 
    /// pszSecondaryLabel members. 
    /// </summary>
    HINSTANCE hInstance;

    /// <summary>
    /// Specifies the behavior of the status dialog. This parameter can be a 
    /// combination of the STATUSDIALOG_FLAGS (SDF_xxx).
    /// </summary>
    STATUSDIALOG_FLAGS dwFlags; 

    /// <summary>
    /// Timeout in ms if dwFlags includes SDF_TIMED. Set to 0 for no timeout.
    /// </summary>
    UINT nTimeOut;

    /// <summary>
    /// Pointer that references the string to be used for the status dialog primary label.
    /// This parameter can be either a null-terminated string or an integer resource identifier 
    /// passed to the MAKEINTRESOURCE macro. If the hInstance member is NULL then one of the 
    /// STATUSDIALOG_DEFAULT_LABEL (SDDL_xxx) can be used to specify a system defined label.
    /// </summary>
    PCWSTR pszPrimaryLabel; 

    /// <summary>
    /// Pointer that references the string to be used for the status dialog secondary label.
    /// This parameter can be either a null-terminated string or an integer resource identifier 
    /// passed to the MAKEINTRESOURCE macro. If the hInstance member is NULL then one of the 
    /// STATUSDIALOG_DEFAULT_LABEL (SDDL_xxx) can be used to specify a system defined label.
    /// </summary>
    PCWSTR pszSecondaryLabel;

    union
    {
        /// <summary>
        /// A handle to an Icon that is to be displayed in the task dialog. 
        /// This member is ignored unless the SDF_USE_HICON_MAIN flag is specified. 
        /// If this member is NULL and the SDF_USE_HICON_MAIN is specified, no icon 
        /// will be displayed.
        /// </summary>
        HICON hMainIcon;

        /// <summary>
        /// Pointer that references the icon to be displayed in the status dialog. 
        /// This parameter is ignored if the SDF_USE_HICON_MAIN flag is specified. 
        /// Otherwise, if this parameter is NULL or the hInstance parameter is NULL, 
        /// no icon will be displayed. This parameter must be an integer resource 
        /// identifier passed to the MAKEINTRESOURCE macro 
        /// </summary>
        PCWSTR pszMainIcon;
    };
} STATUSDIALOGCONFIG;

/// <summary>
/// The CreateStatusDialog function creates, displays, and operates a status dialog. 
/// The status dialog contains application-defined icons, text, and progress bar.
/// </summary>
/// <param name="pStatusConfig">
/// [in] Pointer to a STATUSDIALOGCONFIG structure that contains information used to display the status dialog.
/// </param>
/// <param name="phwndStatusDialog">
/// Pointer to variable to receive the window handle of the status dialog. This parameter cannot be NULL.
/// </param>
/// <returns>
/// Returns one of the following values.
/// 
/// S_OK The operation completed successfully. 
/// E_OUTOFMEMORY There is insufficient memory to complete the operation. 
/// E_INVALIDARG One or more arguments are invalid. 
/// E_FAIL The operation failed. 
///</returns>
HRESULT CreateStatusDialog(const STATUSDIALOGCONFIG *pStatusConfig, HWND *phwndStatusDialog);

#define SDM_FIRST                  0x1800

/// <summary>
/// Hide the status dialog's progress bar.
/// </summary>
/// <param name="wParam">
/// (WPARAM)(BOOL) fHideProgressBar
/// If TRUE the progress bar should be hidden, FALSE if the progress bar should be displayed.
/// </param>
/// <param name="lParam">
/// Not used.
/// </param>
/// <returns>
/// TRUE if successfuly, FALSE otherwise.
/// </returns>
#define SDM_HIDEPROGRESS_BAR          (SDM_FIRST)

/// <summary>
/// Used by client to update the primary text element on the Status Dialog.
/// </summary>
/// <param name="wParam">
/// (WPARAM)(STATUSDIALOG_ELEMENTS) eElement
/// [in] Indicates the element to update. This parameter must be one of the
/// following predefined values.
///     SDE_PRIMARY_LABEL
///     SDE_SECONDARY_LABEL
/// </param>
/// <param name="lParam">
/// (LPARAM)(STATUSDIALOG_DEFAULT_LABEL) sddl
/// [in] Indicates the default text to use for the primary label.
/// </param>
/// <returns>
/// TRUE if successful, FALSE otherwise.
/// </returns>
#define SDM_SET_DEFAULT_LABEL          (SDM_FIRST + 1)

#define SDM_LAST SDM_SET_DEFAULT_LABEL 

/// <summary>
/// Used by client to update a text element on the Status Dialog.
/// </summary>
/// <param name="wParam">
/// (WPARAM)(STATUSDIALOG_ELEMENTS) eElement
/// [in] Indicates the element to update. This parameter must be one of the following predefined values.
///     SDE_PRIMARY_LABEL
///     SDE_SECONDARY_LABEL
/// </param>
/// <param name="lParam">
/// (LPARAM) (LPCWSTR) pszNewText
/// [in] The new text to use.
/// </param>
/// <returns>
/// The return value is ignored.
/// </returns>
#define SDM_SET_ELEMENT_TEXT          TDM_SET_ELEMENT_TEXT

/// <summary>
/// Refreshes the icon of a status dialog. 
/// </summary>
/// <param name="wParam">Ignored.</param>
/// <param name="lParam">
/// [in] A pointer to a string (PCWSTR) or handle to an icon (HICON) to display.
/// If lParam is NULL, then no icon is displayed.
///
/// If the SDF_USE_HICON_MAIN flag is set on the dwFlags member of the
/// STATUSDIALOGCONFIG structure used to create the status dialog, then lParam must
/// contain a handle to an icon (HICON) to display.
///
/// If the SDF_USE_HICON_MAIN flags are not set on the dwFlags member, then lParam
/// must point to a null-terminated, Unicode string (PCWSTR) that contains a valid
/// resource identifier passed through the MAKEINTRESOURCE macro.
/// The resource must be from the application's resource module (specified in
/// the hInstance member of the STATUSDIALOGCONFIG structure).
/// </param>
/// <returns>
/// Ignored.
/// </returns>
#define SDM_UPDATE_ICON               TDM_UPDATE_ICON

/// <summary>
/// Indicates whether the hosted progress bar should be displayed in marquee mode.
/// </summary>
/// <param name="wParam">
/// (WPARAM)(BOOL)fMarquee
/// [in] Specifies whether the progress bar should be shown in Marquee mode. A value of TRUE turns on Marquee mode.
/// </param>
/// <param name="lParam">
/// Not used.
/// </param>
/// <returns>
/// The return value is ignored.
/// </returns>
#define SDM_SET_MARQUEE_PROGRESS_BAR  (WM_USER+103)


/// <summary>
/// Starts and stops the marquee display of the progress bar, and sets the speed of the marquee.
/// </summary>
/// <param name="wParam">
/// (WPARAM)(BOOL)fMarquee
/// [in] Indicates whether to turn the marquee mode off or on.
/// </param>
/// <param name="lParam">
/// (LPARAM)(UINT)nSpeed
/// [in] The speed of the marquee in milliseconds.
/// <returns>
/// The return value is ignored.
/// </returns>
#define SDM_SET_PROGRESS_BAR_MARQUEE (WM_USER+107)


/// <summary>
/// The SDM_SET_PROGRESS_BAR_POS message is used set the current position for a progress bar.
/// </summary>
/// <param name="wParam">
/// (WPARAM) (int) nNewPos
/// [in] Signed integer that becomes the new position.
/// </param>
/// <param name="lParam">
/// Not used.
/// <returns>
/// Returns the previous position.
/// </returns>
#define SDM_SET_PROGRESS_BAR_POS (WM_USER+106)


/// <summary>
/// The SDM_SET_PROGRESS_BAR_RANGE message is used set the minimum and maximum values for the hosted progress bar.
/// </summary>
/// <param name="wParam">
/// (WPARAM) 0; not used, must be 0
/// </param>
/// <param name="lParam">
/// (LPARAM) MAKELPARAM(nMinRange, nMaxRange)
/// nMinRange
/// [in] Minimum range value. By default, the minimum value is zero.
/// nMaxRange
/// [in] Maximum range value. By default, the maximum value is 100.
/// <returns>
/// Returns the previous range values if successful, or zero otherwise.
/// </returns>
#define SDM_SET_PROGRESS_BAR_RANGE (WM_USER+105)


// ==================== End StatusDialog =======================


// ==================== Picker Dialog ========================

/// <summary>
/// Default menu item ID picks an item in a single selection picker dialog.
/// </summary>
#define MIID_PICK               0xFFF9
/// <summary>
/// Default menu item ID changes the selection state of focus item in a multi-
/// selection picker dialog.
/// 
/// The label of this menu item will reflect to the selection state of focus item in
/// the list.
/// If focus item is not selected, the label of this menu item will be "Select".
/// If focus item is selected, the label of this menu item will be "Unselect".
/// </summary>
#define MIID_CHANGE_SELECTION   0xFFFA
/// <summary>
/// Default menu item ID selects all items in multi-selection picker dialog.
/// </summary>
#define MIID_SELECT_ALL         0xFFFB
/// <summary>
/// Default menu item ID deselects all items in multi-selection picker dialog.
/// </summary>
#define MIID_DESELECT_ALL       0xFFFC
/// <summary>
/// Default menu item ID finish selecting in multi-selection picker dialog.
/// </summary>
#define MIID_DONE               0xFFFD

/// <summary>
/// The PickerDialogCallbackProc function is an application-defined function used with
/// the PickerDialog function.
/// It receives messages from the picker dialog when various events occur.
/// </summary>
/// <param name="hwnd">
/// [in] Handle to the PickerDialog window.
/// Do not continue sending messages to hwnd after the callback procedure returns from
/// having been called with PDN_DESTROYED. 
/// </param>
/// <param name="uNotification">
/// [in] One of the following notifications.
///     PDN_CREATED              Indicates that the picker dialog has been created. 
///     PDN_DESTROYED            Indicates that the picker dialog has been destroyed. 
///     PDN_MENUITEM_CLICKED     Indicates that a menu item has been selected. 
///     PDN_SELECTIONCHANGED     Indicates that the virtual list selection has
///                              changed.
///     PDN_FOCUSCHANGED         Indicates that the position of the focus in the list
///                              has changed.
/// </param>
/// <param name="wParam">
/// [in] Specifies additional notification information.
/// The contents of this parameter depend on the value of the uNotification parameter.
/// </param>
/// <param name="lParam">
/// [in] Specifies additional notification information.
/// The contents of this parameter depend on the value of the uNotification parameter.
/// </param>
/// <param name="lpRefData">
/// [in] Long pointer to application specific data.
/// This is the data pointed to by the lpCallbackData member of structure
/// PICKERDIALOGCREATESTRUCT used to create the picker dialog.
/// </param>
/// <retruns>
/// The return value is specific to the notification being processed.
/// </returns>
typedef HRESULT (CALLBACK *PFNPICKERDIALOGCALLBACK)(__in HWND hwnd, __in UINT uNotification, __in WPARAM wParam, __in LPARAM lParam, __in LONG_PTR lpRefData);

/// <summary>
/// Picker dialog supports layouts
/// </summary>
typedef enum _PICKERDIALOG_LAYOUT
{
    /// <summary>
    /// Single line with no images.
    /// </summary>
    PD_LAYOUT_SINGLELINE            = 0x1,
    /// <summary>
    /// Single line with 1 image.
    /// </summary>
    PD_LAYOUT_SINGLELINE1ICON       = 0x2,
    /// <summary>
    /// Double lines with no images.
    /// </summary>
    PD_LAYOUT_DOUBLELINE            = 0x3,
    /// <summary>
    /// Double lines with 1 image.
    /// </summary>
    PD_LAYOUT_DOUBLELINE1ICON       = 0x4,
    /// <summary>
    /// Basic Grid layout. (One image shown)
    /// 
    /// This layout is not supported if the value of fSearchable member in
    /// PICKERDIALOGCREATESTRUCT is TRUE. PickerDialog function will fail and
    /// return E_INVALIDARG.
    /// </summary>
    PD_LAYOUT_GRID                  = 0x5,
};
typedef int PICKERDIALOG_LAYOUT;

/// <summary>
/// Specify the behavior of the picker dialog.
/// </summary>
typedef enum _PICKERDIALOG_FLAGS
{
    /// <summary>
    /// Indicates that the picker dialog supports multi-selection.
    /// 
    /// If this flag is not specified, this picker dialog will be a single-selection
    /// picker.
    /// </summary>
    PDF_MULTI_SELECTION              = 0x00000001,
    /// <summary>
    /// Indicates that the picker dialog will show partial screen.
    /// 
    /// Picker dialog only supports partial screen for the following layout now. The
    /// API will fail if this flag set with any not supported layout and return
    /// E_INVALIDARG.
    /// </summary>
    PDF_PARTIAL_SCREEN               = 0x00000002,
    /// <summary>
    /// Indicates that the list in picker dialog will not wrap the selection.
    /// 
    /// Picker dialog enable wrapping selection in the list by default. Set this flag
    /// will disable the wrapping behavior.
    /// </summary>
    PDF_DISABLE_WRAPPING             = 0x00000004,
    /// <summary>
    /// Indicates that the dialog will be canceled when loss activation.
    /// 
    /// A notification PDN_MENUITEM_CLICKED with IDCANCEL will be sent to owner and 
    /// the picker dialog box will be closed and no value will be returned.
    /// </summary>
    PDF_CLOSE_ON_ACTIVATION_LOSS     = 0x00000008,
};
typedef DWORD PICKERDIALOG_FLAGS;

/// <summary>
/// The PICKERDIALOG_MENUITEM structure contains information that used to display a
/// menu item in a picker dialog.
/// </summary>
typedef struct _PICKERDIALOG_MENUITEM
{
    /// <summary>
    /// Indicates the value of menu item id.
    /// Picker dialog doesn't allow to override the default menu item. So API will
    /// fail and return E_INVALIDARG if nMemuItemId member is one of default menu
    /// item id.
    /// </summary>
    int nMenuItemId;
    /// <summary>
    /// Pointer that references the string to be used to label the menu item.
    /// This parameter can be either a null-terminated string or an integer resource
    /// identifier passed to the MAKEINTRESOURCE macro.
    /// </summary>
    PCWSTR pszMenuItemLabel;
} PICKERDIALOG_MENUITEM;

/// <summary>
/// Picker Dialog creation structure. 
/// May be passed as the lpCreateParams member of the CREATESTRUCT.
/// </summary>
typedef struct tagPICKERDIALOGCREATESTRUCT
{
    /// <summary>
    /// The size of this structure.
    /// </summary>    
    UINT cbSize;
    /// <summary>
    /// The parent window handle.
    /// </summary>
    HWND hwndParent;
    /// <summary>
    /// Handle to the module that contains the string resources identified by the
    /// pszTitle and the pszMenuItemLabel of PICKERDIALOG_MENUITEM structure.
    /// </summary>
    HINSTANCE hInstance;
    /// <summary>
    /// Pointer to a null-terminated string that contains the title text
    /// for picker dialog.
    /// </summary>
    LPCTSTR pszTitle;
    /// <summary>
    /// The layout that should be used for the Virtual List View.
    /// </summary>    
    PICKERDIALOG_LAYOUT pdLayout;
    /// <summary>
    /// Specify the behavior of the picker dialog. This parameter can be value(s)
    /// from PICKERDIALOG_FLAGS (PDF_xxx).
    /// </summary>    
    PICKERDIALOG_FLAGS dwFlags;
    /// <summary>
    /// Indicates that this picker dialog is a searchable picker.
    /// If the value is TRUE, a accumulator will be enforced.
    /// </summary>
    BOOL fSearchable;
    /// <summary>
    /// The number of entries in the pMenuItems array that is used to create menu
    /// items in the dialog.
    /// </summary>
    UINT cMenuItems;
    /// <summary>
    /// Pointer to an array of PICKERDIALOG_MENUITEM structures containing the
    /// definition of the application-defined menu items that are to be displayed in
    /// the dialog. This array must contain at least the number of entries that are
    /// specified by the cMenuItems member. 
    /// 
    /// The member nMenuItemId can not be picker default menu item ID, otherwise,
    /// PickerDialog API will fail and return E_INVALIDARG. The default menu item ID
    /// are IDOK, IDCANCEL, MIID_CHANGE_SELECTION, MIID_SELECT_ALL, and
    /// MIID_UNSELECT_ALL.
    /// </summary>
    const PICKERDIALOG_MENUITEM* pMenuItems;
    /// <summary>
    /// pDataSource will be used as the data source to the control. 
    /// </summary>
    IVirtualList* pDataSource;
    /// <summary>
    /// The zero-base default focus item index.
    /// </summary>
    UINT uDefaultFocusItemIdx;
    /// <summary>
    /// The number of entries in the rgpDefaultSelectItems array that is used to set
    /// items as selected state in the list of dialog.
    /// </summary>
    UINT cDefaultSelectItems;
    /// <summary>
    /// The array of item index that is used to set as selected state in the list of
    /// dialog.
    ///
    /// PickerDialog API will fail and return E_INVALIDARG if provided item index is
    /// out of range.
    /// </summary>
    const UINT* rguDefaultSelectItemIdx;
    /// <summary>
    /// Pointer to an application-defined callback function. For more information see
    /// PickerDialogCallbackProc. 
    /// </summary>
    PFNPICKERDIALOGCALLBACK pfnCallback;
    /// <summary>
    /// A long pointer to application-defined reference data. This value is defined
    /// by the caller.
    /// </summary>
    LONG_PTR lpCallbackData;
} PICKERDIALOGCREATESTRUCT, *PPICKERDIALOGCREATESTRUCT;

/// <summary>
/// The notifications sent from picker dialog.
/// These notifications are received only through the picker dialog callback function,
/// which can be registered using the PickerDialog method. 
/// </summary>
typedef enum _PICKERDIALOG_NOTIFICATIONS
{
    /// <summary>
    /// Sent by the picker dialog once the dialog has been created and before it is
    /// displayed.
    /// </summary>
    /// <param name="wParam">Not used.</param>
    /// <param name="lParam">Not used.</param>
    /// <returns>Ignored.</returns>
    PDN_CREATED                         = 1,
    /// <summary>
    /// Sent by the picker dialog when it is destroyed and its window handle is no 
    /// longer valid.
    /// </summary>
    /// <param name="wParam">Not used.</param>
    /// <param name="lParam">Not used.</param>
    /// <returns>Ignored.</returns>
    PDN_DESTROYED                       = 2,
    /// <summary>
    /// Sent by the picker dialog when the user selects a menu item in the picker
    /// dialog.
    /// </summary>
    /// <param name="wParam">
    /// wParam = (WPARAM) (int) nMenuItemId
    ///     nMenuItemId : The menu item ID corresponding to the menu item
    ///                   selected.
    /// </param>
    /// <param name="lParam">
    /// lParam = (LPARAM) (TCHAR *) szAccumulator
    ///     szAccumulator : The picker's accumulator contents at the time
    ///                     the menu item is selected.
    /// </param>
    /// <returns>
    /// To prevent the picker dialog from closing, the application must return E_FAIL,
    /// otherwise the picker dialog will be closed and the menu item ID returned via 
    /// the original application call.
    /// </returns>
    /// <remarks>
    /// lParam/szAccumulator is only meaningful if the value of fSearchable member in
    /// PICKERDIALOGCREATESTRUCT is TRUE.
    /// </remarks>
    PDN_MENUITEM_CLICKED                = 3,
    /// <summary>
    /// This notification is sent when the virtual list selection has changed.
    /// </summary>
    /// <param name="wParam">Not used. </param>
    /// <param name="lParam">
    /// lParam = (LPARAM) (NMVLVITEM *) pnmvlvFocus
    ///     pnmvlvFocus : It will contain information on the focus item.
    /// </param>
    /// <returns>Ignored</returns>
    PDN_SELECTION_CHANGED               = 4,
    /// <summary>
    /// This notification is sent when the position of the focus in the list has
    /// changed.
    /// </summary>
    /// <param name="wParam">Not used. </param>
    /// <param name="lParam">
    /// lParam = (LPARAM) (NMVLVFOCUSCHANGE *) pnmvlvFocusChange
    ///     pnmvlvFocusChange : It will contain information on the item that
    ///                         received the focus, and the old item that had the
    ///                         focus.
    /// <param>
    /// <returns>Ignored</returns>
    PDN_FOCUS_CHANGED                   = 5,
} PICKERDIALOG_NOTIFICATIONS;

/// <summary>
/// Use by clients to update a application-defined menu item label in picker dialog. 
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) (UINT) nMenuItemId
///     nMenuItemId : [in] The ID of the menu item ID to be updated. This parameter
///                   must be one of the application-defined menu items ID in picker
///                   dialog.
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM) (LPCWSTR) pszNewLabel
///     pszNewLabel : [in] Pointer to a Unicode string that indicates the new label to
///                   use.
/// </param>
/// <returns>
/// Ignored.
/// </returns>
#define PDM_UPDATE_MENUITEM_LABEL       (WM_USER+200)

/// <summary>
/// Enables or disables an application-defined menu item in picker dialog.
/// </summary>
/// <param name="wParam">
/// wParam = (WPARAM) (UINT) nMenuItemId
///     nMenuItemId : [in] The ID of the menu item to be enabled or disabled. This
///                   parameter must be one of the application-defined menu items ID
///                   in picker dialog.
/// </param>
/// <param name="lParam">
/// lParam = (LPARAM) (BOOL) bEnable
///     bEnable : [in] Specifies menu item state. Set it to FALSE to disable the menu
///               item. Set it to TRUE to enable the menu item.
/// </param>
/// <returns>
/// Ignored.
/// </returns>
#define PDM_ENABLE_MENUITEM             (WM_USER+201)

/// <summary>
/// A helper dialog to pick item(s)
/// </summary>
/// <param name="pcs">
/// Pointer to PICKERDIALOGCREATESTRUCT to bring up picker dialog.
/// </param>
/// <param name="pcPicked">
/// Pointer to a UINT to receive the picked item count.
/// If Picker Dialog has been canceled, the value will be zero.
/// </param>
/// <param name="prgpPickedItems">
/// A pointer to a IVirtualItem* array to receive the picked item(s).
///
/// The owner of picker dialog who recieve this array should call delete[] to free the
/// array when they are done with it.
/// </param>
/// <param name="pnMenuItemId">
/// Pointer to a UINT to receive the menu item id that close dialog. This pointer can
/// be NULL to choose not receiving the menu item id.
/// 
/// If user uses BACK key to cancel the picker dialog, the returned value will be
/// IDCANCEL.
/// </param>
/// <returns>
/// HRESULT value. S_OK indicates succeed, otherwise, it's failed.
/// </returns>
/// <remarks>
/// Picker dialog will enforce default menu items as below.
///
/// Single-selection:
///     Select              MIID_PICK               (SK1)
///     Cancel              IDCANCEL                (SK2)
///
/// Multi-selection: (PDF_MULTI_SELECTION is specified)
///     Select/Unselect     MIID_CHANGE_SELECTION   (SK1)
///     Select All          MIID_SELECT_ALL
///     Unselect All        MIID_UNSELECT_ALL
///     Done                IDOK                    (SK2, after any state change)
///     Cancel              IDCANCEL                (SK2)
///
/// Notes: In multi-selection picker dialog, "Done" menu item will be disabled by
///        default and "Cancel" will be SK2 by default.
///        Once user make any selection change, either select or unselect, the "Done"
///        menu item will be enabled and assigned to SK2.
/// </remarks>
#ifdef __cplusplus
extern "C"
#endif
HRESULT PickerDialog(const PICKERDIALOGCREATESTRUCT* pcs,
                     __out UINT* pcPickedItems,
                     __out IVirtualItem*** prgpPickedItems,
                     __out_opt UINT* pnMenuItemId);

// =================== End PickerDialog ======================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\shimgdata.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Tue Jan 23 14:31:04 2007
 */
/* Compiler settings for ..\shimgdata.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shimgdata_h__
#define __shimgdata_h__

/* Forward Declarations */ 

#ifndef __IShellImageDataFactory_FWD_DEFINED__
#define __IShellImageDataFactory_FWD_DEFINED__
typedef interface IShellImageDataFactory IShellImageDataFactory;
#endif 	/* __IShellImageDataFactory_FWD_DEFINED__ */


#ifndef __IShellImageData_FWD_DEFINED__
#define __IShellImageData_FWD_DEFINED__
typedef interface IShellImageData IShellImageData;
#endif 	/* __IShellImageData_FWD_DEFINED__ */


#ifndef __IShellImageDataAbort_FWD_DEFINED__
#define __IShellImageDataAbort_FWD_DEFINED__
typedef interface IShellImageDataAbort IShellImageDataAbort;
#endif 	/* __IShellImageDataAbort_FWD_DEFINED__ */


#ifndef __ShellImageDataFactory_FWD_DEFINED__
#define __ShellImageDataFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellImageDataFactory ShellImageDataFactory;
#else
typedef struct ShellImageDataFactory ShellImageDataFactory;
#endif /* __cplusplus */

#endif 	/* __ShellImageDataFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_shimgdata_0000 */
/* [local] */ 




#if !defined(_GDIPLUSPIXELFORMATS_H)
typedef DWORD PixelFormat;

#endif
#if !defined(_GDIPLUSENUMS_H)
typedef DWORD InterpolationMode;

#endif
#if !defined(_GDIPLUSHEADERS_H)
typedef BYTE EncoderParameters;

typedef BYTE Image;

#endif
#define  SHIMGKEY_QUALITY    L"Compression"
#define  SHIMGKEY_RAWFORMAT  L"RawDataFormat"

#define  SHIMGDEC_DEFAULT            0x00000000
#define  SHIMGDEC_THUMBNAIL          0x00000001
#define  SHIMGDEC_LOADFULL           0x00000002
#define  E_NOTVALIDFORANIMATEDIMAGE  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x01)
// This helper function is used to determine if a given file is a B&W document image (fax, etc)
BOOL WINAPI SHIsFileADocumentImage(PCIDLIST_ABSOLUTE pidl);


extern RPC_IF_HANDLE __MIDL_itf_shimgdata_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shimgdata_0000_v0_0_s_ifspec;

#ifndef __IShellImageDataFactory_INTERFACE_DEFINED__
#define __IShellImageDataFactory_INTERFACE_DEFINED__

/* interface IShellImageDataFactory */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellImageDataFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9be8ed5c-edab-4d75-90f3-bd5bdbb21c82")
    IShellImageDataFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateIShellImageData( 
            /* [out] */ IShellImageData __RPC_FAR *__RPC_FAR *ppshimg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateImageFromFile( 
            /* [in] */ LPCWSTR pszPath,
            /* [out] */ IShellImageData __RPC_FAR *__RPC_FAR *ppshimg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateImageFromStream( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IShellImageData __RPC_FAR *__RPC_FAR *ppshimg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataFormatFromPath( 
            /* [in] */ LPCWSTR pszPath,
            /* [out] */ GUID __RPC_FAR *pDataFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellImageDataFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellImageDataFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellImageDataFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellImageDataFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateIShellImageData )( 
            IShellImageDataFactory __RPC_FAR * This,
            /* [out] */ IShellImageData __RPC_FAR *__RPC_FAR *ppshimg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateImageFromFile )( 
            IShellImageDataFactory __RPC_FAR * This,
            /* [in] */ LPCWSTR pszPath,
            /* [out] */ IShellImageData __RPC_FAR *__RPC_FAR *ppshimg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateImageFromStream )( 
            IShellImageDataFactory __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [out] */ IShellImageData __RPC_FAR *__RPC_FAR *ppshimg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataFormatFromPath )( 
            IShellImageDataFactory __RPC_FAR * This,
            /* [in] */ LPCWSTR pszPath,
            /* [out] */ GUID __RPC_FAR *pDataFormat);
        
        END_INTERFACE
    } IShellImageDataFactoryVtbl;

    interface IShellImageDataFactory
    {
        CONST_VTBL struct IShellImageDataFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellImageDataFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellImageDataFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellImageDataFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellImageDataFactory_CreateIShellImageData(This,ppshimg)	\
    (This)->lpVtbl -> CreateIShellImageData(This,ppshimg)

#define IShellImageDataFactory_CreateImageFromFile(This,pszPath,ppshimg)	\
    (This)->lpVtbl -> CreateImageFromFile(This,pszPath,ppshimg)

#define IShellImageDataFactory_CreateImageFromStream(This,pStream,ppshimg)	\
    (This)->lpVtbl -> CreateImageFromStream(This,pStream,ppshimg)

#define IShellImageDataFactory_GetDataFormatFromPath(This,pszPath,pDataFormat)	\
    (This)->lpVtbl -> GetDataFormatFromPath(This,pszPath,pDataFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellImageDataFactory_CreateIShellImageData_Proxy( 
    IShellImageDataFactory __RPC_FAR * This,
    /* [out] */ IShellImageData __RPC_FAR *__RPC_FAR *ppshimg);


void __RPC_STUB IShellImageDataFactory_CreateIShellImageData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageDataFactory_CreateImageFromFile_Proxy( 
    IShellImageDataFactory __RPC_FAR * This,
    /* [in] */ LPCWSTR pszPath,
    /* [out] */ IShellImageData __RPC_FAR *__RPC_FAR *ppshimg);


void __RPC_STUB IShellImageDataFactory_CreateImageFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageDataFactory_CreateImageFromStream_Proxy( 
    IShellImageDataFactory __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [out] */ IShellImageData __RPC_FAR *__RPC_FAR *ppshimg);


void __RPC_STUB IShellImageDataFactory_CreateImageFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageDataFactory_GetDataFormatFromPath_Proxy( 
    IShellImageDataFactory __RPC_FAR * This,
    /* [in] */ LPCWSTR pszPath,
    /* [out] */ GUID __RPC_FAR *pDataFormat);


void __RPC_STUB IShellImageDataFactory_GetDataFormatFromPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellImageDataFactory_INTERFACE_DEFINED__ */


#ifndef __IShellImageData_INTERFACE_DEFINED__
#define __IShellImageData_INTERFACE_DEFINED__

/* interface IShellImageData */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellImageData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bfdeec12-8040-4403-a5ea-9e07dafcf530")
    IShellImageData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Decode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cxDesired,
            /* [in] */ ULONG cyDesired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prcDest,
            /* [in] */ LPRECT prcSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextFrame( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextPage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrevPage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTransparent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAnimated( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsVector( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsMultipage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEditable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPrintable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDecoded( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPage( 
            /* [out] */ ULONG __RPC_FAR *pnPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageCount( 
            /* [out] */ ULONG __RPC_FAR *pcPages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectPage( 
            /* [in] */ ULONG iPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ SIZE __RPC_FAR *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRawDataFormat( 
            /* [out] */ GUID __RPC_FAR *pDataFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormat( 
            /* [out] */ PixelFormat __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDelay( 
            /* [out] */ DWORD __RPC_FAR *pdwDelay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ DWORD dwMode,
            /* [out] */ IPropertySetStorage __RPC_FAR *__RPC_FAR *ppPropSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate( 
            /* [in] */ DWORD dwAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale( 
            /* [in] */ ULONG cx,
            /* [in] */ ULONG cy,
            /* [in] */ InterpolationMode hints) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DiscardEdit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEncoderParams( 
            /* [in] */ IPropertyBag __RPC_FAR *pbagEnc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayName( 
            /* [size_is][out][in] */ LPWSTR wszName,
            /* [in] */ UINT cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolution( 
            /* [out] */ ULONG __RPC_FAR *puResolutionX,
            /* [out] */ ULONG __RPC_FAR *puResolutionY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEncoderParams( 
            /* [in] */ GUID __RPC_FAR *pguidFmt,
            /* [out] */ EncoderParameters __RPC_FAR *__RPC_FAR *ppEncParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterAbort( 
            /* [in] */ IShellImageDataAbort __RPC_FAR *pAbort,
            /* [out] */ IShellImageDataAbort __RPC_FAR *__RPC_FAR *ppAbortPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloneFrame( 
            /* [out] */ Image __RPC_FAR *__RPC_FAR *ppImg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceFrame( 
            /* [in] */ Image __RPC_FAR *pImg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellImageDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellImageData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Decode )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cxDesired,
            /* [in] */ ULONG cyDesired);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Draw )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prcDest,
            /* [in] */ LPRECT prcSrc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextFrame )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextPage )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrevPage )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsTransparent )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsAnimated )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsVector )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsMultipage )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEditable )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPrintable )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsDecoded )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentPage )( 
            IShellImageData __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pnPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPageCount )( 
            IShellImageData __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcPages);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectPage )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ ULONG iPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IShellImageData __RPC_FAR * This,
            /* [out] */ SIZE __RPC_FAR *pSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRawDataFormat )( 
            IShellImageData __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pDataFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPixelFormat )( 
            IShellImageData __RPC_FAR * This,
            /* [out] */ PixelFormat __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDelay )( 
            IShellImageData __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwDelay);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperties )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ DWORD dwMode,
            /* [out] */ IPropertySetStorage __RPC_FAR *__RPC_FAR *ppPropSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rotate )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ DWORD dwAngle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Scale )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ ULONG cx,
            /* [in] */ ULONG cy,
            /* [in] */ InterpolationMode hints);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DiscardEdit )( 
            IShellImageData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEncoderParams )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ IPropertyBag __RPC_FAR *pbagEnc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayName )( 
            IShellImageData __RPC_FAR * This,
            /* [size_is][out][in] */ LPWSTR wszName,
            /* [in] */ UINT cch);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResolution )( 
            IShellImageData __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puResolutionX,
            /* [out] */ ULONG __RPC_FAR *puResolutionY);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEncoderParams )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ GUID __RPC_FAR *pguidFmt,
            /* [out] */ EncoderParameters __RPC_FAR *__RPC_FAR *ppEncParams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterAbort )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ IShellImageDataAbort __RPC_FAR *pAbort,
            /* [out] */ IShellImageDataAbort __RPC_FAR *__RPC_FAR *ppAbortPrev);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloneFrame )( 
            IShellImageData __RPC_FAR * This,
            /* [out] */ Image __RPC_FAR *__RPC_FAR *ppImg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReplaceFrame )( 
            IShellImageData __RPC_FAR * This,
            /* [in] */ Image __RPC_FAR *pImg);
        
        END_INTERFACE
    } IShellImageDataVtbl;

    interface IShellImageData
    {
        CONST_VTBL struct IShellImageDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellImageData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellImageData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellImageData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellImageData_Decode(This,dwFlags,cxDesired,cyDesired)	\
    (This)->lpVtbl -> Decode(This,dwFlags,cxDesired,cyDesired)

#define IShellImageData_Draw(This,hdc,prcDest,prcSrc)	\
    (This)->lpVtbl -> Draw(This,hdc,prcDest,prcSrc)

#define IShellImageData_NextFrame(This)	\
    (This)->lpVtbl -> NextFrame(This)

#define IShellImageData_NextPage(This)	\
    (This)->lpVtbl -> NextPage(This)

#define IShellImageData_PrevPage(This)	\
    (This)->lpVtbl -> PrevPage(This)

#define IShellImageData_IsTransparent(This)	\
    (This)->lpVtbl -> IsTransparent(This)

#define IShellImageData_IsAnimated(This)	\
    (This)->lpVtbl -> IsAnimated(This)

#define IShellImageData_IsVector(This)	\
    (This)->lpVtbl -> IsVector(This)

#define IShellImageData_IsMultipage(This)	\
    (This)->lpVtbl -> IsMultipage(This)

#define IShellImageData_IsEditable(This)	\
    (This)->lpVtbl -> IsEditable(This)

#define IShellImageData_IsPrintable(This)	\
    (This)->lpVtbl -> IsPrintable(This)

#define IShellImageData_IsDecoded(This)	\
    (This)->lpVtbl -> IsDecoded(This)

#define IShellImageData_GetCurrentPage(This,pnPage)	\
    (This)->lpVtbl -> GetCurrentPage(This,pnPage)

#define IShellImageData_GetPageCount(This,pcPages)	\
    (This)->lpVtbl -> GetPageCount(This,pcPages)

#define IShellImageData_SelectPage(This,iPage)	\
    (This)->lpVtbl -> SelectPage(This,iPage)

#define IShellImageData_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define IShellImageData_GetRawDataFormat(This,pDataFormat)	\
    (This)->lpVtbl -> GetRawDataFormat(This,pDataFormat)

#define IShellImageData_GetPixelFormat(This,pFormat)	\
    (This)->lpVtbl -> GetPixelFormat(This,pFormat)

#define IShellImageData_GetDelay(This,pdwDelay)	\
    (This)->lpVtbl -> GetDelay(This,pdwDelay)

#define IShellImageData_GetProperties(This,dwMode,ppPropSet)	\
    (This)->lpVtbl -> GetProperties(This,dwMode,ppPropSet)

#define IShellImageData_Rotate(This,dwAngle)	\
    (This)->lpVtbl -> Rotate(This,dwAngle)

#define IShellImageData_Scale(This,cx,cy,hints)	\
    (This)->lpVtbl -> Scale(This,cx,cy,hints)

#define IShellImageData_DiscardEdit(This)	\
    (This)->lpVtbl -> DiscardEdit(This)

#define IShellImageData_SetEncoderParams(This,pbagEnc)	\
    (This)->lpVtbl -> SetEncoderParams(This,pbagEnc)

#define IShellImageData_DisplayName(This,wszName,cch)	\
    (This)->lpVtbl -> DisplayName(This,wszName,cch)

#define IShellImageData_GetResolution(This,puResolutionX,puResolutionY)	\
    (This)->lpVtbl -> GetResolution(This,puResolutionX,puResolutionY)

#define IShellImageData_GetEncoderParams(This,pguidFmt,ppEncParams)	\
    (This)->lpVtbl -> GetEncoderParams(This,pguidFmt,ppEncParams)

#define IShellImageData_RegisterAbort(This,pAbort,ppAbortPrev)	\
    (This)->lpVtbl -> RegisterAbort(This,pAbort,ppAbortPrev)

#define IShellImageData_CloneFrame(This,ppImg)	\
    (This)->lpVtbl -> CloneFrame(This,ppImg)

#define IShellImageData_ReplaceFrame(This,pImg)	\
    (This)->lpVtbl -> ReplaceFrame(This,pImg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellImageData_Decode_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG cxDesired,
    /* [in] */ ULONG cyDesired);


void __RPC_STUB IShellImageData_Decode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_Draw_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ HDC hdc,
    /* [in] */ LPRECT prcDest,
    /* [in] */ LPRECT prcSrc);


void __RPC_STUB IShellImageData_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_NextFrame_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_NextFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_NextPage_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_NextPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_PrevPage_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_PrevPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsTransparent_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_IsTransparent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsAnimated_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_IsAnimated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsVector_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_IsVector_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsMultipage_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_IsMultipage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsEditable_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_IsEditable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsPrintable_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_IsPrintable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsDecoded_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_IsDecoded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetCurrentPage_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pnPage);


void __RPC_STUB IShellImageData_GetCurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetPageCount_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcPages);


void __RPC_STUB IShellImageData_GetPageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_SelectPage_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ ULONG iPage);


void __RPC_STUB IShellImageData_SelectPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetSize_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [out] */ SIZE __RPC_FAR *pSize);


void __RPC_STUB IShellImageData_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetRawDataFormat_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pDataFormat);


void __RPC_STUB IShellImageData_GetRawDataFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetPixelFormat_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [out] */ PixelFormat __RPC_FAR *pFormat);


void __RPC_STUB IShellImageData_GetPixelFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetDelay_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwDelay);


void __RPC_STUB IShellImageData_GetDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetProperties_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ DWORD dwMode,
    /* [out] */ IPropertySetStorage __RPC_FAR *__RPC_FAR *ppPropSet);


void __RPC_STUB IShellImageData_GetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_Rotate_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ DWORD dwAngle);


void __RPC_STUB IShellImageData_Rotate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_Scale_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ ULONG cx,
    /* [in] */ ULONG cy,
    /* [in] */ InterpolationMode hints);


void __RPC_STUB IShellImageData_Scale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_DiscardEdit_Proxy( 
    IShellImageData __RPC_FAR * This);


void __RPC_STUB IShellImageData_DiscardEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_SetEncoderParams_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ IPropertyBag __RPC_FAR *pbagEnc);


void __RPC_STUB IShellImageData_SetEncoderParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_DisplayName_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [size_is][out][in] */ LPWSTR wszName,
    /* [in] */ UINT cch);


void __RPC_STUB IShellImageData_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetResolution_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puResolutionX,
    /* [out] */ ULONG __RPC_FAR *puResolutionY);


void __RPC_STUB IShellImageData_GetResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetEncoderParams_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ GUID __RPC_FAR *pguidFmt,
    /* [out] */ EncoderParameters __RPC_FAR *__RPC_FAR *ppEncParams);


void __RPC_STUB IShellImageData_GetEncoderParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_RegisterAbort_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ IShellImageDataAbort __RPC_FAR *pAbort,
    /* [out] */ IShellImageDataAbort __RPC_FAR *__RPC_FAR *ppAbortPrev);


void __RPC_STUB IShellImageData_RegisterAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_CloneFrame_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [out] */ Image __RPC_FAR *__RPC_FAR *ppImg);


void __RPC_STUB IShellImageData_CloneFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_ReplaceFrame_Proxy( 
    IShellImageData __RPC_FAR * This,
    /* [in] */ Image __RPC_FAR *pImg);


void __RPC_STUB IShellImageData_ReplaceFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellImageData_INTERFACE_DEFINED__ */


#ifndef __IShellImageDataAbort_INTERFACE_DEFINED__
#define __IShellImageDataAbort_INTERFACE_DEFINED__

/* interface IShellImageDataAbort */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellImageDataAbort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53fb8e58-50c0-4003-b4aa-0c8df28e7f3a")
    IShellImageDataAbort : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellImageDataAbortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellImageDataAbort __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellImageDataAbort __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellImageDataAbort __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryAbort )( 
            IShellImageDataAbort __RPC_FAR * This);
        
        END_INTERFACE
    } IShellImageDataAbortVtbl;

    interface IShellImageDataAbort
    {
        CONST_VTBL struct IShellImageDataAbortVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellImageDataAbort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellImageDataAbort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellImageDataAbort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellImageDataAbort_QueryAbort(This)	\
    (This)->lpVtbl -> QueryAbort(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellImageDataAbort_QueryAbort_Proxy( 
    IShellImageDataAbort __RPC_FAR * This);


void __RPC_STUB IShellImageDataAbort_QueryAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellImageDataAbort_INTERFACE_DEFINED__ */



#ifndef __ShellImageData_LIBRARY_DEFINED__
#define __ShellImageData_LIBRARY_DEFINED__

/* library ShellImageData */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_ShellImageData;

EXTERN_C const CLSID CLSID_ShellImageDataFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("66e4e4fb-f385-4dd0-8d74-a2efd1bc6178")
ShellImageDataFactory;
#endif
#endif /* __ShellImageData_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\shlguid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//===========================================================================
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//===========================================================================


#pragma once


DEFINE_GUID(CLSID_NetworkDomain,        0x46e06680, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//46e06680-4bf0-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_NetworkServer,        0xc0542a90, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//c0542a90-4bf0-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_NetworkShare,         0x54a754c0, 0x4bf0, 0x11d1, 0x83,0xee,0x00,0xa0,0xc9,0x0d,0xc8,0x49);//54a754c0-4bf1-11d1-83ee-00a0c90dc849
DEFINE_GUID(CLSID_MyComputer,           0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D);//20D04FE0-3AEA-1069-A2D8-08002B30309D
DEFINE_GUID(CLSID_Internet,             0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D
DEFINE_GUID(CLSID_RecycleBin,           0x645FF040, 0x5081, 0x101B, 0x9F,0x08,0x00,0xAA,0x00,0x2F,0x95,0x4E);//645FF040-5081-101B-9F08-00AA002F954E
DEFINE_GUID(CLSID_ControlPanel,         0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D);//21EC2020-3AEA-1069-A2DD-08002B30309D
DEFINE_GUID(CLSID_Printers,             0x2227A280, 0x3AEA, 0x1069, 0xA2,0xDE,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_MyDocuments,          0x450d8fba, 0xad25, 0x11d0, 0x98,0xa8,0x08,0x00,0x36,0x1b,0x11,0x03);//450D8FBA-AD25-11D0-98A8-0800361B1103
DEFINE_GUID(CLSID_PictureVideoLibrary,  0x00044b4e, 0x11e6, 0x4bef, 0xae,0xc2,0xba,0x15,0x7d,0x80,0xf6,0x60);//00044b4e-11e6-4bef-aec2-ba157d80f660
DEFINE_GUID(CLSID_MusicLibrary,         0x00875566, 0xaddc, 0x4883, 0xa2,0xbf,0x62,0xbb,0xd2,0x30,0xdf,0x07);//00875566-addc-4883-a2bf-62bbd230df07
DEFINE_GUID(CLSID_DocumentLibrary,      0x00f4a6ac, 0xe2e7, 0x4652, 0xb7,0xa7,0xec,0xbd,0x23,0x2f,0x78,0x18);//00f4a6ac-e2e7-4652-b7a7-ecbd232f7818

// string version of above CLSIDs
// useful for doing psfDesktop->ParseDisplayName( L"::" L STR_MYDOCS_CLSID, ...);

#define STR_MYDOCS_CLSID   "{450D8FBA-AD25-11D0-98A8-0800361B1103}"

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(CATID_BrowsableShellExt, 0x00021490L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CATID_BrowseInPlace,     0x00021491L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CATID_DeskBand,          0x00021492L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CATID_InfoBand,          0x00021493L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CATID_CommBand,          0x00021494L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#endif

#define PSGUID_INTERNETSHORTCUT {0x000214A0, 0, 0, 0xC0,0,0,0,0,0,0,0x46}
DEFINE_GUID(FMTID_Intshcut,          0x000214A0L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#define PSGUID_INTERNETSITE {0x000214A1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46}
DEFINE_GUID(FMTID_InternetSite,      0x000214A1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

DEFINE_GUID(CGID_Explorer,           0x000214D0L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CGID_ShellDocView,       0x000214D1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(CGID_ShellServiceObject, 0x000214D2L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(CGID_ExplorerBarDoc,     0x000214D3L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif


DEFINE_GUID(IID_INewShortcutHookA,   0x000214E1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellBrowser,       0x000214E2L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellView,          0x000214E3L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IContextMenu,        0x000214E4L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellIcon,          0x000214E5L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellFolder,        0x000214E6L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellExtInit,       0x000214E8L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellPropSheetExt,  0x000214E9L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IPersistFolder,      0x000214EAL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IExtractIconA,       0x000214EBL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellDetails,       0x000214ECL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellLinkA,         0x000214EEL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_ICopyHookA,          0x000214EFL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IFileViewerA,        0x000214F0L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_ICommDlgBrowser,     0x000214F1L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IEnumIDList,         0x000214F2L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IFileViewerSite,     0x000214F3L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IContextMenu2,       0x000214F4L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellExecuteHookA,  0x000214F5L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IPropSheetPage,      0x000214F6L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_INewShortcutHookW,   0x000214F7L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IFileViewerW,        0x000214F8L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellLinkW,         0x000214F9L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IExtractIconW,       0x000214FAL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IShellExecuteHookW,  0x000214FBL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_ICopyHookW,          0x000214FCL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRemoteComputer,     0x000214FEL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#ifdef UNDER_CE
DEFINE_GUID(IID_IShellListView,      0x000214FFL, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif

#define IID_IShellCopyHookA                  IID_ICopyHookA
#define IID_IShellCopyHookW                  IID_ICopyHookW

#define SID_LinkSite    IID_IShellLinkW     // IServiceProvider::QueryService() access the link object that is defering to you

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IQueryInfo,          0x00021500L, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif

DEFINE_GUID(IID_IBriefcaseStg,          0x8BCE1FA1L, 0x0921, 0x101B, 0xB1, 0xFF, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);
DEFINE_GUID(IID_IShellView2,            0x88E39E80L, 0x3578, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IURLSearchHook,         0xAC60F6A0L, 0x0FD9, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);
DEFINE_GUID(IID_ISearchContext,         0x09F656A2L, 0x41AF, 0x480C, 0x88, 0xF7, 0x16, 0xCC, 0x0D, 0x16, 0x46, 0x15);
DEFINE_GUID(IID_IURLSearchHook2,        0x5ee44da4L, 0x6d32, 0x46e3, 0x86, 0xbc, 0x07, 0x54, 0x0d, 0xed, 0xd0, 0xe0);
DEFINE_GUID(IID_IDefViewID,             0x985F64F0L, 0xD410, 0x4E02, 0xBE, 0x22, 0xDA, 0x07, 0xF2, 0xB5, 0xC5, 0xE1);
#define IDefViewID   IUnknown

#if (_WIN32_IE >= 0x0500)
// CLSID_FolderShortcut {0AFACED1-E828-11D1-9187-B532F1E9575D}
DEFINE_GUID(CLSID_FolderShortcut,       0x0AFACED1L, 0xE828, 0x11D1, 0x91, 0x87, 0xB5, 0x32, 0xF1, 0xE9, 0x57, 0x5D);
#endif

DEFINE_GUID(IID_IDockingWindowSite,     0x2a342fc2, 0x7b26, 0x11d0, 0x8c, 0xa9, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
DEFINE_GUID(IID_IDockingWindowFrame,    0x47d2657a, 0x7b27, 0x11d0, 0x8c, 0xa9, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

DEFINE_GUID(IID_IShellIconOverlay,      0x7D688A70L, 0xC613, 0x11D0, 0x99, 0x9B, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);
DEFINE_GUID(IID_IShellIconOverlayIdentifier,  0x0C6C4200L, 0xC589, 0x11D0, 0x99, 0x9A, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);

// {10339516-2894-11d2-9039-00C04F8EEB3E}
DEFINE_GUID(IID_ICommDlgBrowser2,       0x10339516, 0x2894, 0x11d2, 0x90, 0x39, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e);

// {2047E320-F2A9-11CE-AE65-08002B2E1262}
DEFINE_GUID(IID_IShellFolderViewCB, 0x2047E320L, 0xF2A9, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
#define SID_ShellFolderViewCB IID_IShellFolderViewCB

// {63B51F81-C868-11D0-999C-00C04FD655E1}
DEFINE_GUID(CLSID_CFSIconOverlayManager, 0x63B51F81L, 0xC868, 0x11D0, 0x99, 0x9C, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);


// f10b5e34-dd3b-42a7-aa7d-2f4ec54bb09b
DEFINE_GUID(IID_IShellIconOverlayManager, 0xf10b5e34L, 0xdd3b, 0x42a7, 0xaa, 0x7d, 0x2f, 0x4e, 0xc5, 0x4b, 0xb0, 0x9b);

// {4ea39266-7211-409f-b622-f63dbd16c533}
DEFINE_GUID(IID_IThumbnailCapture,           0x4ea39266, 0x7211, 0x409f, 0xb6, 0x22, 0xf6, 0x3d, 0xbd, 0x16, 0xc5, 0x33);

#if (_WIN32_IE >= 0x0500)

// {48C8118C-B924-11d1-98D5-00C04FB687DA}
DEFINE_GUID(IID_IShellImageStore,            0x48c8118c, 0xb924, 0x11d1, 0x98, 0xd5, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

#if (NTDDI_VERSION < NTDDI_LONGHORN) // removed in Windows Vista
// {1EBDCF80-A200-11d0-A3A4-00C04FD706EC}
DEFINE_GUID(CLSID_ShellThumbnailDiskCache,   0x1ebdcf80, 0xa200, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);
#endif

#endif


// {BCFCE0A0-EC17-11d0-8D10-00A0C90F2719}
DEFINE_GUID(IID_IContextMenu3,          0xbcfce0a0, 0xec17, 0x11d0, 0x8d, 0x10, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);


#endif // _WIN32_IE >= 0x0400

DEFINE_GUID(SID_DefView,                0x6D12FE80, 0x7911, 0x11CF, 0x95, 0x34, 0x00, 0x00, 0xC0, 0x5B, 0xAE, 0x0B);

DEFINE_GUID(CGID_DefView,               0x4af07f10, 0xd231, 0x11d0, 0xb9, 0x42, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

DEFINE_GUID(CLSID_MenuBand,             0x5b4dae26, 0xb807, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// IShellFolderBand stuff
// {7FE80CC8-C247-11d0-B93A-00A0C90312E1}
DEFINE_GUID(IID_IShellFolderBand, 0x7fe80cc8, 0xc247, 0x11d0, 0xb9, 0x3a, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
// 710EB7A0-45ED-11D0-924A-0020AFC7AC4D
DEFINE_GUID(IID_IDefViewFrame, 0x710EB7A0L, 0x45ED, 0x11D0, 0x92, 0x4A, 0x00, 0x20, 0xAF, 0xC7, 0xAC, 0x4D);


// 0057D0E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_LargeIcons, 0x0057D0E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 089000C0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_SmallIcons, 0x089000C0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 0E1FA5E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_List      , 0x0E1FA5E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 137E7700-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_Details   , 0x137E7700L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 5984FFE0-28D4-11CF-AE66-08002B2E1262
DEFINE_GUID(VID_Tile      , 0x65f125e5L, 0x7be1, 0x4810, 0xba, 0x9d, 0xd2, 0x71, 0xc8, 0x43, 0x2c, 0xe3);
// 65F125E5-7BE1-4810-BA9D-D271C8432CE3


// NOTE: This has to be the same as the old CLSID_Thumbnails
// {8BEBB290-52D0-11d0-B7F4-00C04FD706EC}
DEFINE_GUID(VID_Thumbnails,     0x8bebb290, 0x52d0, 0x11d0, 0xb7, 0xf4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// ThumbStrip
// {8EEFA624-D1E9-445B-94B7-74FBCE2EA11A}
DEFINE_GUID(VID_ThumbStrip, 0x8EEFA624, 0xD1E9, 0x445B, 0x94, 0xB7, 0x74, 0xFB, 0xCE, 0x2E, 0xA1, 0x1A);


#define SID_SShellBrowser IID_IShellBrowser
#if (_WIN32_IE >= 0x0400)
#define SID_SShellDesktop CLSID_ShellDesktop
#endif

#if (_WIN32_IE >= 0x0400)
//
//  IShellDiscardable is an IID-only interface. If the object supports this
// interface it can be discarded anytime. IWebBrowser::PutProperty QI's for
// this interface to detect discardable properties.
//
DEFINE_GUID(IID_IDiscardableBrowserProperty, 0x49c3de7c, 0xd329, 0x11d0, 0xab, 0x73, 0x00, 0xc0, 0x4f, 0xc3, 0x3e, 0x80);

// IShellChangeNotify is a sink of LPCITEMIDLIST notification events
//
// D82BE2B1-5764-11D0-A96E-00C04FD705A2
DEFINE_GUID(IID_IShellChangeNotify, 0xD82BE2B1L, 0x5764, 0x11D0, 0xA9, 0x6E, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

#endif // _WIN32_IE >= 0x0400

#ifdef UNICODE
#define IID_IFileViewer         IID_IFileViewerW
#define IID_IShellLink          IID_IShellLinkW
#define IID_IExtractIcon        IID_IExtractIconW
#define IID_IShellCopyHook      IID_IShellCopyHookW
#define IID_IShellExecuteHook   IID_IShellExecuteHookW
#define IID_INewShortcutHook    IID_INewShortcutHookW
#else
#define IID_IFileViewer         IID_IFileViewerA
#define IID_IShellLink          IID_IShellLinkA
#define IID_IExtractIcon        IID_IExtractIconA
#define IID_IShellCopyHook      IID_IShellCopyHookA
#define IID_IShellExecuteHook   IID_IShellExecuteHookA
#define IID_INewShortcutHook    IID_INewShortcutHookA
#endif


#ifndef NO_INTSHCUT_GUIDS
#include <isguids.h>            // internet shortcut GUIDs
#endif

#ifndef NO_SHDOCVW_GUIDS

#ifndef GUID_DEFS_ONLY
#include <exdisp.h>
#include <shldisp.h>
#endif


#if (_WIN32_IE >= 0x0400)
// UrlHistory Guids
DEFINE_GUID(CLSID_CUrlHistory,          0x3C374A40L, 0xBAE4, 0x11CF, 0xBF, 0x7D, 0x00, 0xAA, 0x00, 0x69, 0x46, 0xEE);
#define SID_SUrlHistory         CLSID_CUrlHistory

//UrlSearchHook Guids
DEFINE_GUID(CLSID_CURLSearchHook,       0xCFBFAE00L, 0x17A6, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);


#define SID_SInternetExplorer IID_IWebBrowserApp
#define SID_SWebBrowserApp    IID_IWebBrowserApp

#define SID_SWebBrowserEventsService IID_IWebBrowserEventsService

// AutoComplete Guids
DEFINE_GUID(IID_IObjMgr,                0x00BB2761L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(IID_IACList,                0x77A130B0L, 0x94FD, 0x11D0, 0xA5, 0x44, 0x00, 0xC0, 0x4F, 0xD7, 0xd0, 0x62);
DEFINE_GUID(IID_IACList2,               0x470141a0L, 0x5186, 0x11d2, 0xbb, 0xb6, 0x00, 0x60, 0x97, 0x7b, 0x46, 0x4c);
DEFINE_GUID(IID_ICurrentWorkingDirectory, 0x91956d21L, 0x9276, 0x11d1, 0x92, 0x1a, 0x00, 0x60, 0x97, 0xdf, 0x5b, 0xd4);     // {91956D21-9276-11d1-921A-006097DF5BD4}
DEFINE_GUID(CLSID_AutoComplete,         0x00BB2763L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(CLSID_ACLHistory,           0x00BB2764L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
DEFINE_GUID(CLSID_ACListISF,            0x03C036F1L, 0xA186, 0x11D0, 0x82, 0x4A, 0x00, 0xAA, 0x00, 0x5B, 0x43, 0x83);
DEFINE_GUID(CLSID_ACLMRU,               0x6756a641L, 0xde71, 0x11d0, 0x83, 0x1b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);          // {6756A641-DE71-11d0-831B-00AA005B4383}
DEFINE_GUID(CLSID_ACLMulti,             0x00BB2765L, 0x6A77, 0x11D0, 0xA5, 0x35, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);
#if (_WIN32_IE >= 0x0600)
DEFINE_GUID(CLSID_ACLCustomMRU,      0x6935db93, 0x21e8, 0x4ccc, 0xbe, 0xb9, 0x9f, 0xe3, 0xc7, 0x7a, 0x29, 0x7a);
#endif


#if (_WIN32_IE >= 0x0500)
// IProgressDialog
// {F8383852-FCD3-11d1-A6B9-006097DF5BD4}
DEFINE_GUID(CLSID_ProgressDialog,       0xf8383852, 0xfcd3, 0x11d1, 0xa6, 0xb9, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
// {EBBC7C04-315E-11d2-B62F-006097DF5BD4}
DEFINE_GUID(IID_IProgressDialog,        0xebbc7c04, 0x315e, 0x11d2, 0xb6, 0x2f, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
#endif // _WIN32_IE >= 0x0500

//
// Progress objects exposed via QueryService
//
#define SID_SProgressUI CLSID_ProgressDialog


//
// Top-most browser implementation in the heirarchy. use IServiceProvider::QueryService()
// to get to interfaces (IID_IShellBrowser, IID_IShellBrowserService, etc.)
//
DEFINE_GUID(SID_STopLevelBrowser,       0x4C96BE40L, 0x915C, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

#endif // _WIN32_IE >= 0x0400

#endif // !NO_SHDOCVW_GUIDS


//B091E540-83E3-11CF-A713-0020AFD79762
DEFINE_GUID(CLSID_FileTypes, 0xB091E540, 0x83E3, 0x11CF, 0xA7,0x13,0x00,0x20,0xAF,0xD7,0x97,0x62);


#if (_WIN32_IE >= 0x0400)

// {75048700-EF1F-11D0-9888-006097DEACF9}
DEFINE_GUID( CLSID_ActiveDesktop, 0x75048700L, 0xEF1F, 0x11D0, 0x98, 0x88, 0x00, 0x60, 0x97, 0xDE, 0xAC, 0xF9);

// {F490EB00-1240-11D1-9888-006097DEACF9}
DEFINE_GUID(IID_IActiveDesktop, 0xF490EB00L, 0x1240, 0x11D1, 0x98, 0x88, 0x00, 0x60, 0x97, 0xDE, 0xAC, 0xF9);

// {52502EE0-EC80-11D0-89AB-00C04FC2972D}
DEFINE_GUID(IID_IActiveDesktopP, 0x52502EE0L, 0xEC80, 0x11D0, 0x89, 0xAB, 0x00, 0xC0, 0x4F, 0xC2, 0x97, 0x2D);

// {B22754E2-4574-11d1-9888-006097DEACF9}
DEFINE_GUID(IID_IADesktopP2, 0xb22754e2, 0x4574, 0x11d1, 0x98, 0x88, 0x0, 0x60, 0x97, 0xde, 0xac, 0xf9);

// {74C26041-70D1-11d1-B75A-00A0C90564FE}
DEFINE_GUID(IID_ISynchronizedCallBack, 0x74c26041, 0x70d1, 0x11d1, 0xb7, 0x5a, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xfe);

//  {c46ca590-3c3f-11d2-bee6-0000f805ca57}
DEFINE_GUID(IID_IQueryAssociations,          0xc46ca590, 0x3c3f, 0x11d2, 0xbe, 0xe6, 0x00, 0x00, 0xf8, 0x05, 0xca, 0x57);

// {a07034fd-6caa-4954-ac3f-97a27216f98a}
DEFINE_GUID(CLSID_QueryAssociations, 0xa07034fd, 0x6caa, 0x4954, 0xac, 0x3f, 0x97, 0xa2, 0x72, 0x16, 0xf9, 0x8a);


// {E8025004-1C42-11d2-BE2C-00A0C9A83DA1}
DEFINE_GUID(IID_IColumnProvider,        0xe8025004, 0x1c42, 0x11d2, 0xbe, 0x2c, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1);

// {24F14F02-7B1C-11d1-838f-0000F80461CF}
DEFINE_GUID(CLSID_LinkColumnProvider,    0x24f14f02, 0x7b1c, 0x11d1, 0x83, 0x8f, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// For Internet Shortcut Creation Command
// The shell uses this command to allow trident to save off it's per frame data in the shortcut
// and to allow it to fire the OnPersist() event on every frame
// {93A68750-951A-11d1-946F-000000000000}
DEFINE_GUID(CGID_ShortCut, 0x93a68750, 0x951a, 0x11d1, 0x94, 0x6f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);


// {FB700430-952C-11d1-946F-000000000000}
DEFINE_GUID(IID_INamedPropertyBag, 0xfb700430, 0x952c, 0x11d1, 0x94, 0x6f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {1E796980-9CC5-11D1-A83F-00C04FC99D61}
DEFINE_GUID(CLSID_InternetButtons, 0x1E796980L, 0x9CC5, 0x11D1, 0xA8, 0x3F, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

#if (_WIN32_IE >= 0x0500)
// {178F34B8-A282-11d2-86C5-00C04F8EEA99}
DEFINE_GUID(CLSID_MSOButtons, 0x178f34b8, 0xa282, 0x11d2, 0x86, 0xc5, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);

// {2CE4B5D8-A28F-11d2-86C5-00C04F8EEA99}
DEFINE_GUID(CLSID_ToolbarExtButtons, 0x2ce4b5d8, 0xa28f, 0x11d2, 0x86, 0xc5, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);
#endif // _WIN32_IE >= 0x0500

// {CFCCC7A0-A282-11D1-9082-006008059382}
DEFINE_GUID(CLSID_DarwinAppPublisher, 0xCFCCC7A0L, 0xA282, 0x11D1, 0x90, 0x82, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

// {7057E952-BD1B-11d1-8919-00C04FC2C836}
DEFINE_GUID(CLSID_DocHostUIHandler, 0x7057e952, 0xbd1b, 0x11d1, 0x89, 0x19, 0x0, 0xc0, 0x4f, 0xc2, 0xc8, 0x36);
#endif  // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0500)

// {93F2F68C-1D1B-11d3-A30E-00C04F79ABD1}
DEFINE_GUID(IID_IShellFolder2,  0x93f2f68c, 0x1d1b, 0x11d3, 0xa3, 0xe, 0x0, 0xc0, 0x4f, 0x79, 0xab, 0xd1);

// {28636aa6-953d-11d2-b5d6-00c04fd918d0}
#define PSGUID_SHELLDETAILS     {0x28636aa6, 0x953d, 0x11d2, 0xb5, 0xd6, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0}
DEFINE_GUID(FMTID_ShellDetails,  0x28636aa6, 0x953d, 0x11d2, 0xb5, 0xd6, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);
#define PID_FINDDATA        0
#define PID_NETRESOURCE     1
#define PID_DESCRIPTIONID   2
#define PID_WHICHFOLDER     3
#define PID_NETWORKLOCATION 4
#define PID_COMPUTERNAME    5

// PSGUID_STORAGE comes from ntquery.h
//#define PSGUID_STORAGE    {0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac}
DEFINE_GUID(FMTID_Storage,   0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac);

// Image properties
#define PSGUID_IMAGEPROPERTIES {0x14b81da1, 0x0135, 0x4d31, 0x96, 0xd9, 0x6c, 0xbf, 0xc9, 0x67, 0x1a, 0x99}
DEFINE_GUID(FMTID_ImageProperties, 0x14b81da1, 0x0135, 0x4d31, 0x96, 0xd9, 0x6c, 0xbf, 0xc9, 0x67, 0x1a, 0x99);

// Custom Image Properties (not EXIF tags, which go into the auxiliary image property store)
// {7ECD8B0E-C136-4a9b-9411-4EBD6673CCC3}
#define PSGUID_CUSTOMIMAGEPROPERTIES {0x7ecd8b0e, 0xc136, 0x4a9b, 0x94, 0x11, 0x4e, 0xbd, 0x66, 0x73, 0xcc, 0xc3}
DEFINE_GUID(FMTID_CustomImageProperties, 0x7ecd8b0e, 0xc136, 0x4a9b, 0x94, 0x11, 0x4e, 0xbd, 0x66, 0x73, 0xcc, 0xc3);

// The GUIDs used to identify shell item attributes (columns). See IShellFolder2::GetDetailsEx implementations...

// {9B174B33-40FF-11d2-A27E-00C04FC30871}
#define PSGUID_DISPLACED    {0x9b174b33, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71}
DEFINE_GUID(FMTID_Displaced, 0x9b174b33, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);
#define PID_DISPLACED_FROM  2
#define PID_DISPLACED_DATE  3

// {328D8B21-7729-4bfc-954C-902B329D56B0}
#define PSGUID_BRIEFCASE    {0x328d8b21, 0x7729, 0x4bfc, 0x95, 0x4c, 0x90, 0x2b, 0x32, 0x9d, 0x56, 0xb0}
DEFINE_GUID(FMTID_Briefcase, 0x328d8b21, 0x7729, 0x4bfc, 0x95, 0x4c, 0x90, 0x2b, 0x32, 0x9d, 0x56, 0xb0);
#define PID_SYNC_COPY_IN    2


// {9B174B34-40FF-11d2-A27E-00C04FC30871}
#define PSGUID_MISC    {0x9b174b34, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71}
DEFINE_GUID(FMTID_Misc, 0x9b174b34, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);
#define PID_MISC_STATUS         2
#define PID_MISC_ACCESSCOUNT    3
#define PID_MISC_OWNER          4
#define PID_HTMLINFOTIPFILE     5
#define PID_MISC_PICS           6
// Do not add more pids beyond what shipped in Server 2k3 - just add PROPERTYKEYs to propkey.w

// {F2275480-F782-4291-BD94-F13693513AEC}
#define PSGUID_WEBVIEW  {0xf2275480, 0xf782, 0x4291, 0xbd, 0x94, 0xf1, 0x36, 0x93, 0x51, 0x3a, 0xec}
DEFINE_GUID(FMTID_WebView, 0xf2275480, 0xf782, 0x4291, 0xbd, 0x94, 0xf1, 0x36, 0x93, 0x51, 0x3a, 0xec);
#define PID_DISPLAY_PROPERTIES  0
#define PID_INTROTEXT           1

// {56A3372E-CE9C-11d2-9F0E-006097C686F6}
#define PSGUID_MUSIC    {0x56a3372e, 0xce9c, 0x11d2, 0x9f, 0xe, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6}
DEFINE_GUID(FMTID_MUSIC, 0x56a3372e, 0xce9c, 0x11d2, 0x9f, 0xe, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);
#define PIDSI_ARTIST    2
#define PIDSI_SONGTITLE 3
#define PIDSI_ALBUM     4
#define PIDSI_YEAR      5
#define PIDSI_COMMENT   6
#define PIDSI_TRACK     7
#define PIDSI_GENRE     11
#define PIDSI_LYRICS    12
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead

// {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}
#define PSGUID_DRM    {0xaeac19e4, 0x89ae, 0x4508, 0xb9, 0xb7, 0xbb, 0x86, 0x7a, 0xbe, 0xe2, 0xed}
DEFINE_GUID(FMTID_DRM, 0xaeac19e4, 0x89ae, 0x4508, 0xb9, 0xb7, 0xbb, 0x86, 0x7a, 0xbe, 0xe2, 0xed);
#define PIDDRSI_PROTECTED    2
#define PIDDRSI_DESCRIPTION  3
#define PIDDRSI_PLAYCOUNT    4
#define PIDDRSI_PLAYSTARTS   5
#define PIDDRSI_PLAYEXPIRES  6

// {64440491-4C8B-11D1-8B70-080036B11A03}
#define PSGUID_VIDEO   {0x64440491, 0x4c8b, 0x11d1, 0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3}
//  FMTID_VideoSummaryInformation property identifiers.  See propkey.h for their types.
#define PIDVSI_STREAM_NAME      0x00000002 // "System.Video.StreamName"   (old name "StreamName")
#define PIDVSI_FRAME_WIDTH      0x00000003 // "System.Video.FrameWidth"   (old name "FrameWidth")
#define PIDVSI_FRAME_HEIGHT     0x00000004 // "System.Video.FrameHeight"  (old name "FrameHeight")
#define PIDVSI_TIMELENGTH       0x00000007 //                             (old name "TimeLength")
#define PIDVSI_FRAME_COUNT      0x00000005 // "System.Media.FrameCount"   (old name "FrameCount")
#define PIDVSI_FRAME_RATE       0x00000006 // "System.Video.FrameRate"    (old name "FrameRate")
#define PIDVSI_DATA_RATE        0x00000008 // "System.Video.DataRate"     (old name "DataRate")
#define PIDVSI_SAMPLE_SIZE      0x00000009 // "System.Video.SampleSize"   (old name "SampleSize")
#define PIDVSI_COMPRESSION      0x0000000A // "System.Video.Compression"  (old name "Compression")
#define PIDVSI_STREAM_NUMBER    0x0000000B // "System.Video.StreamNumber" (old name "StreamNumber")

// {64440490-4C8B-11D1-8B70-080036B11A03}
#define PSGUID_AUDIO   {0x64440490, 0x4c8b, 0x11d1, 0x8b, 0x70, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3}
//  FMTID_AudioSummaryInformation property identifiers
#define PIDASI_FORMAT           0x00000002 // VT_BSTR
#define PIDASI_TIMELENGTH       0x00000003 // VT_UI4, milliseconds
#define PIDASI_AVG_DATA_RATE    0x00000004 // VT_UI4,  Hz
#define PIDASI_SAMPLE_RATE      0x00000005 // VT_UI4,  bits
#define PIDASI_SAMPLE_SIZE      0x00000006 // VT_UI4,  bits
#define PIDASI_CHANNEL_COUNT    0x00000007 // VT_UI4
#define PIDASI_STREAM_NUMBER    0x00000008 // VT_UI2
#define PIDASI_STREAM_NAME      0x00000009 // VT_LPWSTR
#define PIDASI_COMPRESSION      0x0000000A // VT_LPWSTR
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead


// {305CA226-D286-468e-B848-2B2E8E697B74}
#define PSGUID_CONTROLPANEL {0x305ca226, 0xd286, 0x468e, 0xb8, 0x48, 0x2b, 0x2e, 0x8e, 0x69, 0x7b, 0x74}
#define PID_CONTROLPANEL_CATEGORY 2
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead

// {9B174B35-40FF-11d2-A27E-00C04FC30871}
#define PSGUID_VOLUME    {0x9b174b35, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71}
DEFINE_GUID(FMTID_Volume, 0x9b174b35, 0x40ff, 0x11d2, 0xa2, 0x7e, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);
#define PID_VOLUME_FREE         2
#define PID_VOLUME_CAPACITY     3
#define PID_VOLUME_FILESYSTEM   4
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead

// {D8C3986F-813B-449c-845D-87B95D674ADE}
#define PSGUID_SHARE    {0xd8c3986f, 0x813b, 0x449c, 0x84, 0x5d, 0x87, 0xb9, 0x5d, 0x67, 0x4a, 0xde}
#define PID_SHARE_CSC_STATUS    2   // server or share status, "online" "offline"
// Do not add more pids to this file. Add new PROPERTYKEYs to propkey.w instead

// {B9B4B3FC-2B51-4a42-B5D8-324146AFCF25}
#define PSGUID_LINK     {0xb9b4b3fc, 0x2b51, 0x4a42, 0xb5, 0xd8, 0x32, 0x41, 0x46, 0xaf, 0xcf, 0x25}
#define PID_LINK_TARGET         2
#define PID_LINK_TARGET_TYPE    3

#define PSGUID_QUERY_D {0x49691c90,0x7e17,0x101a, 0xa9,0x1c,0x08,0x00,0x2b,0x2e,0xcd,0xa9}
DEFINE_GUID(FMTID_Query, 0x49691c90,0x7e17,0x101a, 0xa9,0x1c,0x08,0x00,0x2b,0x2e,0xcd,0xa9);
#define PID_QUERY_RANK  2

// FMTID_SummaryInformation, see OLE docs for PID_ values for these
#define PSGUID_SUMMARYINFORMATION       {0xf29f85e0L, 0x4ff9, 0x1068, 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9}
// FMTID_DocumentSummaryInformation, see OLE docs on the PID_ values for this
#define PSGUID_DOCUMENTSUMMARYINFORMATION {0xd5cdd502L, 0x2e9c, 0x101b, 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae}

// FMTID_MediaFileSummaryInformation, see propidl.h PID_ values for this
#define PSGUID_MEDIAFILESUMMARYINFORMATION {0x64440492L, 0x4c8b, 0x11d1, 0x8b, 0x70, 0x08, 0x00, 0x36, 0xb1, 0x1a, 0x03}

// FMTID_ImageSummaryInformation
#define PSGUID_IMAGESUMMARYINFORMATION {0x6444048fL, 0x4c8b, 0x11d1, 0x8b, 0x70, 0x8, 0x00, 0x36, 0xb1, 0x1a, 0x03}

// {0E700BE1-9DB6-11d1-A1CE-00C04FD75D13}
DEFINE_GUID(IID_IEnumExtraSearch,  0xe700be1, 0x9db6, 0x11d1, 0xa1, 0xce, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {FFB8655F-81B9-4fce-B89C-9A6BA76D13E7}
DEFINE_GUID(CLSID_HWShellExecute, 0xffb8655f, 0x81b9, 0x4fce, 0xb8, 0x9c, 0x9a, 0x6b, 0xa7, 0x6d, 0x13, 0xe7);

// {4657278A-411B-11d2-839A-00C04FD918D0}
DEFINE_GUID(CLSID_DragDropHelper,   0x4657278a, 0x411b, 0x11d2, 0x83, 0x9a, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {3050f3BB-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_CAnchorBrowsePropertyPage, 0x3050f3BB, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f3B3-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_CImageBrowsePropertyPage, 0x3050f3B3, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f3B4-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_CDocBrowsePropertyPage, 0x3050f3B4, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {01E18D10-4D8B-11d2-855D-006008059367}
DEFINE_GUID(IID_IFileSystemBindData, 0x1e18d10, 0x4d8b, 0x11d2, 0x85, 0x5d, 0x0, 0x60, 0x8, 0x5, 0x93, 0x67);

// {49E1B500-4636-11d3-97F7-00C04F45D0B3}
DEFINE_GUID(SID_STopWindow, 0x49e1b500, 0x4636, 0x11d3, 0x97, 0xf7, 0x0, 0xc0, 0x4f, 0x45, 0xd0, 0xb3);

// {889A935D-971E-4B12-B90C-24DFC9E1E5E8}
DEFINE_GUID(SID_SGetViewFromViewDual, 0x889A935D, 0x971E, 0x4B12, 0xB9, 0x0C, 0x24, 0xDF, 0xC9, 0xE1, 0xE5, 0xE8);


// {FEF10FA2-355E-4e06-9381-9B24D7F7CC88}
DEFINE_GUID(CLSID_FolderItem, 0xfef10fa2, 0x355e, 0x4e06, 0x93, 0x81, 0x9b, 0x24, 0xd7, 0xf7, 0xcc, 0x88);

// {53C74826-AB99-4d33-ACA4-3117F51D3788}
DEFINE_GUID(CLSID_FolderItemsMultiLevel, 0x53c74826, 0xab99, 0x4d33, 0xac, 0xa4, 0x31, 0x17, 0xf5, 0x1d, 0x37, 0x88);

// {D969A300-E7FF-11d0-A93B-00A0C90F2719}
DEFINE_GUID(CLSID_NewMenu,0xd969a300, 0xe7ff, 0x11d0, 0xa9, 0x3b, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);


//  BHIDs for IShellItem::BindToHandler()


// use this for IShellFolder::BindToObject() objects; IShellFolder
//  {3981e224-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_SFObject, 0x3981e224, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// use this for IShellFolder::GetUIObject() objects; IContextMenu, IDataObject, IDropTarget, IQueryAssociation, etc.
//  {3981e225-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_SFUIObject, 0x3981e225, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// use this for IShellFolder::CreateViewObject() objects; IShellView, IDropTarget, IContextMenu
//  {3981e226-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_SFViewObject, 0x3981e226, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// use this for storage objects like IStream, IPropertyStore, IStorage
//  {3981e227-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_Storage, 0x3981e227, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// use this to get an IStream for the item
// {1CEBB3AB-7C10-499a-A417-92CA16C4CB83}
DEFINE_GUID(BHID_Stream, 0x1cebb3ab, 0x7c10, 0x499a, 0xa4, 0x17, 0x92, 0xca, 0x16, 0xc4, 0xcb, 0x83);

// use this to deref the item if it is a link to get its target item, use IShellItem
//  {3981e228-f559-11d3-8e3a-00c04f6837d5}
DEFINE_GUID(BHID_LinkTargetItem, 0x3981e228, 0xf559, 0x11d3, 0x8e, 0x3a, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// if the item is a folder use this to get an IEnumShellItems that enumerates the storage contents
// {4621A4E3-F0D6-4773-8A9C-46E77B174840}
DEFINE_GUID(BHID_StorageEnum, 0x4621a4e3, 0xf0d6, 0x4773, 0x8a, 0x9c, 0x46, 0xe7, 0x7b, 0x17, 0x48, 0x40);

// if the item is a folder use this to get an ITransferSource or ITransferDestiation object
// {5D080304-FE2C-48fc-84CE-CF620B0F3C53}
DEFINE_GUID(BHID_Transfer, 0xd5e346a1, 0xf753, 0x4932, 0xb4, 0x3, 0x45, 0x74, 0x80, 0xe, 0x24, 0x98);

// use this to get an IPropertyStore or IPropertyStoreFactory
// to have more control over the property store for the item
// {0384e1a4-1523-439c-a4c8-ab911052f586}
DEFINE_GUID(BHID_PropertyStore, 0x0384e1a4, 0x1523, 0x439c, 0xa4, 0xc8, 0xab, 0x91, 0x10, 0x52, 0xf5, 0x86);

// use this to get IExtractImage / IThumbnailProvider for an item
// {7b2e650a-8e20-4f4a-b09e-6597afc72fb0}
DEFINE_GUID(BHID_ThumbnailHandler, 0x7b2e650a, 0x8e20, 0x4f4a, 0xb0, 0x9e, 0x65, 0x97, 0xaf, 0xc7, 0x2f, 0xb0);

// if the item is a folder use this to get an IEnumShellItems that enumerates all items
// in the folder including folders, non folders and hidden items
// {94f60519-2850-4924-aa5a-d15e84868039}
DEFINE_GUID(BHID_EnumItems, 0x94f60519, 0x2850, 0x4924, 0xaa, 0x5a, 0xd1, 0x5e, 0x84, 0x86, 0x80, 0x39);

// use this to get an IDataObject for an item or an array of items IShellItem/IShellItemArray::BindToHandler()
// {B8C0BD9F-ED24-455c-83E6-D5390C4FE8C4}
DEFINE_GUID(BHID_DataObject, 0xb8c0bd9f, 0xed24, 0x455c, 0x83, 0xe6, 0xd5, 0x39, 0xc, 0x4f, 0xe8, 0xc4);

// use this to get an IQueryAssociations for an item or an array of items IShellItem/IShellItemArray::BindToHandler()
// {bea9ef17-82f1-4f60-9284-4f8db75c3be9}
DEFINE_GUID(BHID_AssociationArray, 0xbea9ef17, 0x82f1, 0x4f60, 0x92, 0x84, 0x4f, 0x8d, 0xb7, 0x5c, 0x3b, 0xe9);

// use this to get an IFilter for an item
// {38d08778-f557-4690-9ebf-ba54706ad8f7}
DEFINE_GUID(BHID_Filter, 0x38d08778, 0xf557, 0x4690, 0x9e, 0xbf, 0xba, 0x54, 0x70, 0x6a, 0xd8, 0xf7);

#endif // _WIN32_IE >= 0x0500

#if _WIN32_IE >= 0x0600


// {faadfc40-b777-4b69-aa81-77035ef0e6e8}
DEFINE_GUID(SID_CtxQueryAssociations, 0xfaadfc40, 0xb777, 0x4b69, 0xaa, 0x81, 0x77, 0x03, 0x5e, 0xf0, 0xe6, 0xe8);

#endif // _WIN32_IE >= 0x0600


// {0x87D605E0L, 0xC511, 0x11CF, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29};
DEFINE_GUID(IID_IDocViewSite,     0x87D605E0, 0xC511, 0x11CF, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);

// {0E5CBF21-D15F-11d0-8301-00AA005B4383}
DEFINE_GUID(CLSID_QuickLinks,           0xe5cbf21, 0xd15f, 0x11d0, 0x83, 0x1, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// The IShellFolder band
// D82BE2B0-5764-11D0-A96E-00C04FD705A2
DEFINE_GUID(CLSID_ISFBand,              0xD82BE2B0L, 0x5764, 0x11D0, 0xA9, 0x6E, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

// { 0x4434FF80L, 0xEF4C, 0x11CE, { 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62 } };
DEFINE_GUID(IID_CDefView,               0x4434FF80, 0xEF4C, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62 );

// {6D5313C0-8C62-11D1-B2CD-006097DF8C11}
DEFINE_GUID(CLSID_ShellFldSetExt,       0x6D5313C0, 0x8C62, 0x11D1, 0xB2,0xCD,0x00,0x60,0x97,0xDF,0x8C,0x11);

DEFINE_GUID(SID_SMenuBandChild,         0xed9cc020, 0x8b9, 0x11d1, 0x98, 0x23, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

DEFINE_GUID(SID_SMenuBandParent,        0x8c278eec, 0x3eab, 0x11d1, 0x8c, 0xb0, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// D1E7AFEB-6A2E-11d0-8C78-00C04FD918B4
DEFINE_GUID(SID_SMenuPopup,             0xD1E7AFEB, 0x6A2E, 0x11d0, 0x8C, 0x78, 0x0, 0xC0, 0x4F, 0xD9, 0x18, 0xB4);

// {165EBAF4-6D51-11d2-83AD-00C04FD918D0}
DEFINE_GUID(SID_SMenuBandBottomSelected, 0x165ebaf4, 0x6d51, 0x11d2, 0x83, 0xad, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

DEFINE_GUID(SID_SMenuBandBottom,        0x743ca664, 0xdeb, 0x11d1, 0x98, 0x25, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {A6C17EB4-2D65-11d2-838F-00C04FD918D0}
DEFINE_GUID(SID_MenuShellFolder,   0xa6c17eb4, 0x2d65, 0x11d2, 0x83, 0x8f, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {39545874-7162-465e-b783-2aa1874fef81}
DEFINE_GUID(SID_SMenuBandContextMenuModifier, 0x39545874, 0x7162, 0x465e, 0xb7, 0x83, 0x2a, 0xa1, 0x87, 0x4f, 0xef, 0x81);

// {164BBD86-1D0D-4de0-9A3B-D9729647C2B8}
DEFINE_GUID(SID_SMenuBandBKContextMenu, 0x164bbd86, 0x1d0d, 0x4de0, 0x9a, 0x3b, 0xd9, 0x72, 0x96, 0x47, 0xc2, 0xb8);

//Command Group ID for MenuDeskBar
// {5C9F0A12-959E-11d0-A3A4-00A0C9082636}
DEFINE_GUID(CGID_MENUDESKBAR,0x5c9f0a12, 0x959e, 0x11d0, 0xa3, 0xa4, 0x0, 0xa0, 0xc9, 0x8, 0x26, 0x36);

DEFINE_GUID(SID_SMenuBandTop,           0x9493a810, 0xec38, 0x11d0, 0xbc, 0x46, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

// {40B96610-B522-11d1-B3B4-00AA006EFDE7}
DEFINE_GUID(CLSID_MenuToolbarBase,      0x40b96610, 0xb522, 0x11d1, 0xb3, 0xb4, 0x0, 0xaa, 0x0, 0x6e, 0xfd, 0xe7);

// {596A9A94-013E-11d1-8D34-00A0C90F2719}
DEFINE_GUID(IID_IBanneredBar,0x596a9a94, 0x13e, 0x11d1, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {E13EF4E4-D2F2-11d0-9816-00C04FD91972}
DEFINE_GUID(CLSID_MenuBandSite,             0xe13ef4e4, 0xd2f2, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {80F30233-B7DF-11d2-A33B-006097DF5BD4}
DEFINE_GUID(SID_SCommDlgBrowser, 0x80f30233, 0xb7df, 0x11d2, 0xa3, 0x3b, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);


//
// These GUIDs may be assigned to the CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR::guidFieldType
// member by Microsoft ICredentialProvider implementations.
//

// {da15bbe8-954sd-4fd3-b0f4-1fb5b90b174b}
DEFINE_GUID(CPFG_LOGON_USERNAME, 0xda15bbe8, 0x954d, 0x4fd3, 0xb0, 0xf4, 0x1f, 0xb5, 0xb9, 0x0b, 0x17, 0x4b);

// {60624cfa-a477-47b1-8a8e-3a4a19981827}
DEFINE_GUID(CPFG_LOGON_PASSWORD, 0x60624cfa, 0xa477, 0x47b1, 0x8a, 0x8e, 0x3a, 0x4a, 0x19, 0x98, 0x18, 0x27);

// {3e1ecf69-568c-4d96-9d59-46444174e2d6}
DEFINE_GUID(CPFG_SMARTCARD_USERNAME, 0x3e1ecf69, 0x568c, 0x4d96, 0x9d, 0x59, 0x46, 0x44, 0x41, 0x74, 0xe2, 0xd6);

// {4fe5263b-9181-46c1-b0a4-9dedd4db7dea}
DEFINE_GUID(CPFG_SMARTCARD_PIN, 0x4fe5263b, 0x9181, 0x46c1, 0xb0, 0xa4, 0x9d, 0xed, 0xd4, 0xdb, 0x7d, 0xea);


//
//  Known Folder IDs
//
#include <knownfolders.h>


// some known folder types

// default value == GUID_NULL
// FOLDERTYPEID_NotSpecified:         {5c4f28b5-f869-4e84-8e60-f11db97c5cc7}
DEFINE_GUID(FOLDERTYPEID_NotSpecified,         0x5c4f28b5, 0xf869, 0x4e84, 0x8e, 0x60, 0xf1, 0x1d, 0xb9, 0x7c, 0x5c, 0xc7);

// FOLDERTYPEID_Invalid:              {57807898-8c4f-4462-bb63-71042380b109}
DEFINE_GUID(FOLDERTYPEID_Invalid,              0x57807898, 0x8c4f, 0x4462, 0xbb, 0x63, 0x71, 0x04, 0x23, 0x80, 0xb1, 0x09);

// typically under FOLDERID_Documents
// FOLDERTYPEID_Documents:            {7d49d726-3c21-4f05-99aa-fdc2c9474656}
DEFINE_GUID(FOLDERTYPEID_Documents,            0x7d49d726, 0x3c21, 0x4f05, 0x99, 0xaa, 0xfd, 0xc2, 0xc9, 0x47, 0x46, 0x56);

// typically under FOLDERID_Pictures, where there's fewer images
// FOLDERTYPEID_Pictures:             {b3690e58-e961-423b-b687-386ebfd83239}
DEFINE_GUID(FOLDERTYPEID_Pictures,             0xb3690e58, 0xe961, 0x423b, 0xb6, 0x87, 0x38, 0x6e, 0xbf, 0xd8, 0x32, 0x39);

// typically under FOLDERID_Music, where there's many songs in a list
// FOLDERTYPEID_MusicDetails:         {af9c03d6-7db9-4a15-9464-13bf9fb69a2a}
DEFINE_GUID(FOLDERTYPEID_MusicDetails,         0xaf9c03d6, 0x7db9, 0x4a15, 0x94, 0x64, 0x13, 0xbf, 0x9f, 0xb6, 0x9a, 0x2a);

// typically under FOLDERID_Music, where we're displaying a set of folders
// FOLDERTYPEID_MusicIcons:           {0b7467fb-84ba-4aae-a09b-15b71097af9e}
DEFINE_GUID(FOLDERTYPEID_MusicIcons,           0x0b7467fb, 0x84ba, 0x4aae, 0xa0, 0x9b, 0x15, 0xb7, 0x10, 0x97, 0xaf, 0x9e);

// FOLDERTYPEID_Games Folder {b689b0d0-76d3-4cbb-87f7-585d0e0ce070}
DEFINE_GUID(FOLDERTYPEID_Games, 0xb689b0d0, 0x76d3, 0x4cbb, 0x87, 0xf7, 0x58, 0x5d, 0x0e, 0x0c, 0xe0, 0x70);

// category view of control panel
// FOLDERTYPEID_ControlPanelCategory: {de4f0660-fa10-4b8f-a494-068b20b22307}
DEFINE_GUID(FOLDERTYPEID_ControlPanelCategory, 0xde4f0660, 0xfa10, 0x4b8f, 0xa4, 0x94, 0x06, 0x8b, 0x20, 0xb2, 0x23, 0x07);

// classic-mode control panel
// FOLDERTYPEID_ControlPanelClassic:  {0c3794f3-b545-43aa-a329-c37430c58d2a}
DEFINE_GUID(FOLDERTYPEID_ControlPanelClassic,  0x0c3794f3, 0xb545, 0x43aa, 0xa3, 0x29, 0xc3, 0x74, 0x30, 0xc5, 0x8d, 0x2a);

// prnfldr
// FOLDERTYPEID_Printers:             {2c7bbec6-c844-4a0a-91fa-cef6f59cfda1}
DEFINE_GUID(FOLDERTYPEID_Printers,             0x2c7bbec6, 0xc844, 0x4a0a, 0x91, 0xfa, 0xce, 0xf6, 0xf5, 0x9c, 0xfd, 0xa1);

// bbckfldr
// FOLDERTYPEID_RecycleBin:           {d6d9e004-cd87-442b-9d57-5e0aeb4f6f72}
DEFINE_GUID(FOLDERTYPEID_RecycleBin,           0xd6d9e004, 0xcd87, 0x442b, 0x9d, 0x57, 0x5e, 0x0a, 0xeb, 0x4f, 0x6f, 0x72);

// software explorer for ARP
// FOLDERTYPEID_SoftwareExplorer:     {d674391b-52d9-4e07-834e-67c98610f39d}
DEFINE_GUID(FOLDERTYPEID_SoftwareExplorer,     0xd674391b, 0x52d9, 0x4e07, 0x83, 0x4e, 0x67, 0xc9, 0x86, 0x10, 0xf3, 0x9d);

// ZIP folders
// FOLDERTYPEID_CompressedFolder:     {80213e82-bcfd-4c4f-8817-bb27601267a9}
DEFINE_GUID(FOLDERTYPEID_CompressedFolder,     0x80213e82, 0xbcfd, 0x4c4f, 0x88, 0x17, 0xbb, 0x27, 0x60, 0x12, 0x67, 0xa9);

// this only needs to be defined here because it's used by the multimedia depot
// contact folders under FOLDERID_Contacts
// FOLDERTYPEID_Contacts:             {de2b70ec-9bf7-4a93-bd3d-243f7881d492}
DEFINE_GUID(FOLDERTYPEID_Contacts,             0xde2b70ec, 0x9bf7, 0x4a93, 0xbd, 0x3d, 0x24, 0x3f, 0x78, 0x81, 0xd4, 0x92);

// default library views that don't have a more specific template
// FOLDERTYPEID_Library:              {4badfc68-c4ac-4716-a0a0-4d5daa6b0f3e}
DEFINE_GUID(FOLDERTYPEID_Library,              0x4badfc68, 0xc4ac, 0x4716, 0xa0, 0xa0, 0x4d, 0x5d, 0xaa, 0x6b, 0x0f, 0x3e);

// NetworkExplorerFolder
// FOLDERTYPEID_NetworkExplorer:      {25CC242B-9A7C-4f51-80E0-7A2928FEBE42}
DEFINE_GUID(FOLDERTYPEID_NetworkExplorer,      0x25cc242b, 0x9a7c, 0x4f51, 0x80, 0xe0, 0x7a, 0x29, 0x28, 0xfe, 0xbe, 0x42);

// User files folder
// FOLDERTYPEID_UserFiles:            {CD0FC69B-71E2-46e5-9690-5BCD9F57AAB3}
DEFINE_GUID(FOLDERTYPEID_UserFiles,            0xcd0fc69b, 0x71e2, 0x46e5, 0x96, 0x90, 0x5b, 0xcd, 0x9f, 0x57, 0xaa, 0xb3);


//
// Sync Manager object IDs.  These are GUIDs used in calls to the GetObject()
// method on ISyncMgrHandler and ISyncMgrSyncItem, defined in SyncMgr.idl.
//

// {6DBC85C3-5D07-4c72-A777-7FEC78072C06}
DEFINE_GUID(SYNCMGR_OBJECTID_Icon, 0x6dbc85c3, 0x5d07, 0x4c72, 0xa7, 0x77, 0x7f, 0xec, 0x78, 0x7, 0x2c, 0x6);

// {4BEF34B9-A786-4075-BA88-0C2B9D89A98F}
DEFINE_GUID(SYNCMGR_OBJECTID_EventStore, 0x4bef34b9, 0xa786, 0x4075, 0xba, 0x88, 0xc, 0x2b, 0x9d, 0x89, 0xa9, 0x8f);

// {D78181F4-2389-47e4-A960-60BCC2ED930B}
DEFINE_GUID(SYNCMGR_OBJECTID_ConflictStore, 0xd78181f4, 0x2389, 0x47e4, 0xa9, 0x60, 0x60, 0xbc, 0xc2, 0xed, 0x93, 0xb);

// {57CBB584-E9B4-47ae-A120-C4DF3335DEE2}
DEFINE_GUID(SYNCMGR_OBJECTID_BrowseContent, 0x57cbb584, 0xe9b4, 0x47ae, 0xa1, 0x20, 0xc4, 0xdf, 0x33, 0x35, 0xde, 0xe2);

// {EDC6F3E3-8441-4109-ADF3-6C1CA0B7DE47}
DEFINE_GUID(SYNCMGR_OBJECTID_ShowSchedule, 0xedc6f3e3, 0x8441, 0x4109, 0xad, 0xf3, 0x6c, 0x1c, 0xa0, 0xb7, 0xde, 0x47);

// {D882D80B-E7AA-49ed-86B7-E6E1F714CDFE}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeActivate, 0xd882d80b, 0xe7aa, 0x49ed, 0x86, 0xb7, 0xe6, 0xe1, 0xf7, 0x14, 0xcd, 0xfe);

// {A0EFC282-60E0-460e-9374-EA88513CFC80}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeDeactivate, 0xa0efc282, 0x60e0, 0x460e, 0x93, 0x74, 0xea, 0x88, 0x51, 0x3c, 0xfc, 0x80);

// {04CBF7F0-5BEB-4de1-BC90-908345C480F6}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeEnable, 0x4cbf7f0, 0x5beb, 0x4de1, 0xbc, 0x90, 0x90, 0x83, 0x45, 0xc4, 0x80, 0xf6);

// {BB5F64AA-F004-4eb5-8E4D-26751966344C}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeDisable, 0xbb5f64aa, 0xf004, 0x4eb5, 0x8e, 0x4d, 0x26, 0x75, 0x19, 0x66, 0x34, 0x4c);

// {F76C3397-AFB3-45d7-A59F-5A49E905437E}
DEFINE_GUID(SYNCMGR_OBJECTID_QueryBeforeDelete, 0xf76c3397, 0xafb3, 0x45d7, 0xa5, 0x9f, 0x5a, 0x49, 0xe9, 0x5, 0x43, 0x7e);

// {2203bdc1-1af1-4082-8c30-28399f41384c}
DEFINE_GUID(SYNCMGR_OBJECTID_EventLinkClick, 0x2203bdc1, 0x1af1, 0x4082, 0x8c, 0x30, 0x28, 0x39, 0x9f, 0x41, 0x38, 0x4c);

// IExplorerPaneVisibility constants
DEFINE_GUID(EP_NavPane,           0xcb316b22, 0x25f7, 0x42b8, 0x8a, 0x09, 0x54, 0x0d, 0x23, 0xa4, 0x3c, 0x2f);
DEFINE_GUID(EP_Commands,          0xd9745868, 0xca5f, 0x4a76, 0x91, 0xcd, 0xf5, 0xa1, 0x29, 0xfb, 0xb0, 0x76);
DEFINE_GUID(EP_Commands_Organize, 0x72e81700, 0xe3ec, 0x4660, 0xbf, 0x24, 0x3c, 0x3b, 0x7b, 0x64, 0x88, 0x06);
DEFINE_GUID(EP_Commands_View,     0x21f7c32d, 0xeeaa, 0x439b, 0xbb, 0x51, 0x37, 0xb9, 0x6f, 0xd6, 0xa9, 0x43);
DEFINE_GUID(EP_DetailsPane,       0x43abf98b, 0x89b8, 0x472d, 0xb9, 0xce, 0xe6, 0x9b, 0x82, 0x29, 0xf0, 0x19);
DEFINE_GUID(EP_PreviewPane,       0x893c63d1, 0x45c8, 0x4d17, 0xbe, 0x19, 0x22, 0x3b, 0xe7, 0x1b, 0xe3, 0x65);
DEFINE_GUID(EP_QueryPane,         0x65bcde4f, 0x4f07, 0x4f27, 0x83, 0xa7, 0x1a, 0xfc, 0xa4, 0xdf, 0x7d, 0xdd);
DEFINE_GUID(EP_AdvQueryPane,      0xb4e9db8b, 0x34ba, 0x4c39, 0xb5, 0xcc, 0x16, 0xa1, 0xbd, 0x2c, 0x41, 0x1c);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\shlobj.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//===========================================================================
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File: shlobj.h
//
//===========================================================================

#ifndef _SHLOBJ_H_
#define _SHLOBJ_H_

#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if defined(_SHELL32_)
#define WINSHELLAPI
#else
#define WINSHELLAPI       DECLSPEC_IMPORT
#endif
#endif // WINSHELLAPI

#ifndef SHSTDAPI
#if defined(_SHELL32_)
#define SHSTDAPI          STDAPI
#define SHSTDAPI_(type)   STDAPI_(type)
#else
#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHSTDAPI

#ifndef SHDOCAPI
#if defined(_SHDOCVW_)
#define SHDOCAPI          STDAPI
#define SHDOCAPI_(type)   STDAPI_(type)
#else
#define SHDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHDOCAPI

// shell32 APIs that are also exported from shdocvw
#ifndef SHSTDDOCAPI
#if defined(_SHDOCVW_) || defined(_SHELL32_)
#define SHSTDDOCAPI          STDAPI
#define SHSTDDOCAPI_(type)   STDAPI_(type)
#else
#define SHSTDDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // SHSTDDOCAPI

#ifndef BROWSEUIAPI
#if defined(_BROWSEUI_)
#define BROWSEUIAPI           STDAPI
#define BROWSEUIAPI_(type)    STDAPI_(type)
#else
#define BROWSEUIAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define BROWSEUIAPI_(type)    EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif // defined(_BROWSEUI_)
#endif // BROWSEUIAPI

// shell32 APIs that are also exported from shfolder
#ifndef SHFOLDERAPI
#if defined(_SHFOLDER_) || defined(_SHELL32_)
#define SHFOLDERAPI           STDAPI
#else
#define SHFOLDERAPI           EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#endif
#endif



#include <ole2.h>
#ifndef _PRSHT_H_
#include <prsht.h>
#endif
#ifndef _INC_COMMCTRL
#include <commctrl.h>   // for LPTBBUTTON
#endif

#ifndef INITGUID
#include <shlguid.h>
#endif /* !INITGUID */


#include <shtypes.h>
#include <shobjidl.h>

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma once
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#include <pshpack1.h>   /* Assume byte packing throughout */

//===========================================================================
//
// Legacy exports that are no longer needed, call the COM API instead
//
//===========================================================================

SHSTDAPI SHGetMalloc(__out IMalloc **ppMalloc); // CoGetMalloc(MEMCTX_TASK,ppMalloc)
SHSTDAPI_(void *) SHAlloc(SIZE_T cb);           // CoTaskMemAlloc(cb)
SHSTDAPI_(void)   SHFree(__in_opt void * pv);   // CoTaskMemFree(pv)



//===========================================================================
//
// IExtractIcon interface
//
//  This interface is used in two different places in the shell.
//
// Case-1: Icons of sub-folders for the scope-pane of the explorer.
//
//  It is used by the explorer to get the "icon location" of
// sub-folders from each shell folders. When the user expands a folder
// in the scope pane of the explorer, the explorer does following:
//  (1) binds to the folder (gets IShellFolder),
//  (2) enumerates its sub-folders by calling its EnumObjects member,
//  (3) calls its GetUIObjectOf member to get IExtractIcon interface
//     for each sub-folders.
//  In this case, the explorer uses only IExtractIcon::GetIconLocation
// member to get the location of the appropriate icon. An icon location
// always consists of a file name (typically DLL or EXE) and either an icon
// resource or an icon index.
//
//
// Case-2: Extracting an icon image from a file
//
//  It is used by the shell when it extracts an icon image
// from a file. When the shell is extracting an icon from a file,
// it does following:
//  (1) creates the icon extraction handler object (by getting its CLSID
//     under the {ProgID}\shell\ExtractIconHanler key and calling
//     CoCreateInstance requesting for IExtractIcon interface).
//  (2) Calls IExtractIcon::GetIconLocation.
//  (3) Then, calls IExtractIcon::ExtractIcon with the location/index pair.
//  (4) If (3) returns S_OK, it uses the returned icon.
//  (5) Otherwise, it recursively calls this logic with new location
//     assuming that the location string contains a fully qualified path name.
//
//  From extension programmer's point of view, there are only two cases
// where they provide implementations of IExtractIcon:
//  Case-1) providing explorer extensions (i.e., IShellFolder).
//  Case-2) providing per-instance icons for some types of files.
//
// Because Case-1 is described above, we'll explain only Case-2 here.
//
// When the shell is about display an icon for a file, it does following:
//  (1) Finds its ProgID and ClassID.
//  (2) If the file has a ClassID, it gets the icon location string from the
//    "DefaultIcon" key under it. The string indicates either per-class
//    icon (e.g., "FOOBAR.DLL,2") or per-instance icon (e.g., "%1,1").
//  (3) If a per-instance icon is specified, the shell creates an icon
//    extraction handler object for it, and extracts the icon from it
//    (which is described above).
//
//  It is important to note that the shell calls IExtractIcon::GetIconLocation
// first, then calls IExtractIcon::Extract. Most application programs
// that support per-instance icons will probably store an icon location
// (DLL/EXE name and index/id) rather than an icon image in each file.
// In those cases, a programmer needs to implement only the GetIconLocation
// member and it Extract member simply returns S_FALSE. They need to
// implement Extract member only if they decided to store the icon images
// within files themselved or some other database (which is very rare).
//
//
//
// [Member functions]
//
//
// IExtractIcon::GetIconLocation
//
//  This function returns an icon location.
//
//  Parameters:
//   uFlags     [in]  -- Specifies if it is opened or not (GIL_OPENICON or 0)
//   szIconFile [out] -- Specifies the string buffer buffer for a location name.
//   cchMax     [in]  -- Specifies the size of szIconFile (almost always MAX_PATH)
//   piIndex    [out] -- Sepcifies the address of UINT for the index.
//   pwFlags    [out] -- Returns GIL_* flags
//  Returns:
//   S_OK, if it returns a valid location; S_FALSE, if the shell use a
//   default icon.
//
//  Notes: The location may or may not be a path to a file. The caller can
//   not assume anything unless the subsequent Extract member call returns
//   S_FALSE.
//
//   if the returned location is not a path to a file, GIL_NOTFILENAME should
//   be set in the returned flags.
//
// IExtractIcon::Extract
//
//  This function extracts an icon image from a specified file.
//
//  Parameters:
//   pszFile [in] -- Specifies the icon location (typically a path to a file).
//   nIconIndex [in] -- Specifies the icon index.
//   phiconLarge [out] -- Specifies the HICON variable for large icon.
//   phiconSmall [out] -- Specifies the HICON variable for small icon.
//   nIconSize [in] -- Specifies the size icon required (size of large icon)
//                     LOWORD is the requested large icon size
//                     HIWORD is the requested small icon size
//  Returns:
//   S_OK, if it extracted the from the file.
//   S_FALSE, if the caller should extract from the file specified in the
//           location.
//
//===========================================================================

// GetIconLocation() input flags

#define GIL_OPENICON      0x0001            // allows containers to specify an "open" look
#define GIL_FORSHELL      0x0002            // icon is to be displayed in a ShellFolder
#define GIL_ASYNC         0x0020            // this is an async extract, return E_PENDING
#define GIL_DEFAULTICON   0x0040            // get the default icon location if the final one takes too long to get
#define GIL_FORSHORTCUT   0x0080            // the icon is for a shortcut to the object
#define GIL_CHECKSHIELD   0x0200            // return GIL_SHIELD or GIL_FORCENOSHIELD, don't block if GIL_ASYNC is set

// GetIconLocation() return flags

#define GIL_SIMULATEDOC   0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE   0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS      0x0004      // icons from this class per class (shared for all files of this type)
#define GIL_NOTFILENAME   0x0008      // location is not a filename, must call ::ExtractIcon
#define GIL_DONTCACHE     0x0010      // this icon should not be cached
#define GIL_SHIELD        0x0200      // icon should be "stamped" with the LUA shield
#define GIL_FORCENOSHIELD 0x0400      // icon must *not* be "stamped" with the LUA shield

#undef  INTERFACE
#define INTERFACE   IExtractIconA

DECLARE_INTERFACE_IID_(IExtractIconA, IUnknown, "000214eb-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                               UINT   uFlags,
          __out_ecount(cchMax) LPSTR  szIconFile,
                               UINT   cchMax,
                         __out int   * piIndex,
                         __out UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                       LPCSTR  pszFile,
                       UINT    nIconIndex,
             __out_opt HICON   *phiconLarge,
             __out_opt HICON   *phiconSmall,
                       UINT    nIconSize) PURE;
};

typedef IExtractIconA * LPEXTRACTICONA;

#undef  INTERFACE
#define INTERFACE   IExtractIconW

DECLARE_INTERFACE_IID_(IExtractIconW, IUnknown, "000214fa-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                               UINT   uFlags,
          __out_ecount(cchMax) LPWSTR pszIconFile,
                               UINT   cchMax,
                         __out int   * piIndex,
                         __out UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                       LPCWSTR pszFile,
                       UINT    nIconIndex,
             __out_opt HICON   *phiconLarge,
             __out_opt HICON   *phiconSmall,
                       UINT    nIconSize) PURE;
};

typedef IExtractIconW * LPEXTRACTICONW;

#ifdef UNICODE
#define IExtractIcon        IExtractIconW
#define IExtractIconVtbl    IExtractIconWVtbl
#define LPEXTRACTICON       LPEXTRACTICONW
#else
#define IExtractIcon        IExtractIconA
#define IExtractIconVtbl    IExtractIconAVtbl
#define LPEXTRACTICON       LPEXTRACTICONA
#endif

//===========================================================================
//
// IShellIconOverlayIdentifier
//
// Used to identify a file as a member of the group of files that have this specific
// icon overlay
//
// Users can create new IconOverlayIdentifiers and place them in the following registry
// location together with the Icon overlay image and their priority.
// HKEY_LOCAL_MACHINE "Software\\Microsoft\\Windows\\CurrentVersion\\ShellIconOverlayIdentifiers"
//
// The shell will enumerate through all IconOverlayIdentifiers at start, and prioritize
// them according to internal rules, in case the internal rules don't apply, we use their
// input priority
//
// IShellIconOverlayIdentifier:IsMemberOf(LPCWSTR pwszPath, DWORD dwAttrib)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//
//  returns:
//      S_OK,    if the file is a member
//      S_FALSE, if the file is not a member
//      E_FAIL,  if the operation failed due to bad WIN32_FIND_DATA
//
// IShellIconOverlayIdentifier::GetOverlayInfo(LPWSTR pwszIconFile, int * pIndex, DWORD * dwFlags) PURE;
//      pszIconFile    the path of the icon file
//      pIndex         Depend on the flags, this could contain the IconIndex
//      dwFlags        defined below
//
// IShellIconOverlayIdentifier::GetPriority(int * pIPriority) PURE;
//      pIPriority     the priority of this Overlay Identifier
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlayIdentifier

DECLARE_INTERFACE_IID_(IShellIconOverlayIdentifier, IUnknown, "0c6c4200-c589-11d0-999a-00c04fd655e1")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlayIdentifier methods ***
    STDMETHOD (IsMemberOf)(THIS_ LPCWSTR pwszPath, DWORD dwAttrib) PURE;
    STDMETHOD (GetOverlayInfo)(THIS_ __out_ecount(cchMax) LPWSTR pwszIconFile, int cchMax, __out int * pIndex, __out DWORD * pdwFlags) PURE;
    STDMETHOD (GetPriority)(THIS_ __out int * pIPriority) PURE;
};

#define ISIOI_ICONFILE            0x00000001          // path is returned through pwszIconFile
#define ISIOI_ICONINDEX           0x00000002          // icon index in pwszIconFile is returned through pIndex

//===========================================================================
//
// IShellIconOverlayManager
//
// Used to return the icon overlay information including OverlayIndex, Image Index or Priority for an IShellFolder object.
//
// IShellIconOverlayManager:GetFileOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//      pIndex          pointer to the Icon Index in the system image list
//      pOverlayIndex   pointer to the OverlayIndex in the system image list
//      pPriority       pointer to the Priority of this overlay
// IShellIconOverlayManager:GetReservedOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags, int iReservedID)
//      iReservedID     reserved icon overlay id
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if lpfd is bad
// IShellIconOverlayManager:RefreshOverlayImages(DWORD dwFlags)
//      This will refresh the overlay cache, depends on the dwFlags passed in
//      It will reload the icons into the imagelist, when passed SIOM_ICONINDEX
// IShellIconOverlayManager::LoadNonloadedOverlayIdentifiers()
//      This method loads any registered overlay identifiers (handlers) that
//      are not currently loaded.
// IShellIconOverlayManager::OverlayIndexFromImageIndex(int iImage, int *piIndex, BOOL fAdd)
//      iImage          existing shell image list index to look for
//      piIndex         returned overlay index
//      fAdd            Add image if not already present?
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlayManager

DECLARE_INTERFACE_IID_(IShellIconOverlayManager, IUnknown, "f10b5e34-dd3b-42a7-aa7d-2f4ec54bb09b")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlayManager methods ***
    STDMETHOD(GetFileOverlayInfo)(THIS_ __in LPCWSTR pwszPath, DWORD dwAttrib, __out int * pIndex, DWORD dwflags) PURE;
    STDMETHOD(GetReservedOverlayInfo)(THIS_ __in_opt LPCWSTR pwszPath, DWORD dwAttrib, __out int * pIndex, DWORD dwflags, int iReservedID) PURE;
    STDMETHOD(RefreshOverlayImages)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(LoadNonloadedOverlayIdentifiers)(THIS) PURE;
    STDMETHOD(OverlayIndexFromImageIndex)(THIS_ int iImage, __out int * piIndex, BOOL fAdd) PURE;
};

#define SIOM_OVERLAYINDEX         1
#define SIOM_ICONINDEX            2
// #define SIOM_PRIORITY          3
#define SIOM_RESERVED_SHARED      0
#define SIOM_RESERVED_LINK        1
#define SIOM_RESERVED_SLOWFILE    2

//===========================================================================
//
// IShellIconOverlay
//
// Used to return the icon overlay index or its icon index for an IShellFolder object,
// this is always implemented with IShellFolder
//
// IShellIconOverlay:GetOverlayIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pidl            object to identify icon overlay for.
//      pdwIndex        the Overlay Index in the system image list
//
// IShellIconOverlay:GetOverlayIconIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pdwIconIndex    the Overlay Icon index in the system image list
// This method is only used for those who are interested in seeing the real bits
// of the Overlay Icon
//
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if pidl is bad
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlay

DECLARE_INTERFACE_IID_(IShellIconOverlay, IUnknown, "7d688a70-c613-11d0-999b-00c04fd655e1")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlay methods ***
    STDMETHOD(GetOverlayIndex)(THIS_ PCUITEMID_CHILD pidl, __inout int * pIndex) PURE;
    STDMETHOD(GetOverlayIconIndex)(THIS_ PCUITEMID_CHILD pidl, __inout int * pIconIndex) PURE;
};

#define OI_DEFAULT 0x00000000
#define OI_ASYNC 0xFFFFEEEE

//-------------------------------------------------------------------------
//
// SHGetIconOverlayIndex
//
// This function takes the path and icon/res id to the icon and convert it into
// an overlay index in the system image list.
// Note: there are totally only 15 slots for system image overlays, some of which
// was reserved by the system, or taken by the overlayidentifiers, so it's possible
// that this function would fail and return -1;
//
// To get the default overlays in the system, such as the share hand, link shortcut
// and slow files, pass NULL as the file name, then the IDO_SHGIOI_* flags as the icon index
//-------------------------------------------------------------------------

#define IDO_SHGIOI_SHARE  0x0FFFFFFF
#define IDO_SHGIOI_LINK   0x0FFFFFFE
#define IDO_SHGIOI_SLOWFILE 0x0FFFFFFFD
SHSTDAPI_(int) SHGetIconOverlayIndexA(LPCSTR pszIconPath, int iIconIndex);
SHSTDAPI_(int) SHGetIconOverlayIndexW(LPCWSTR pszIconPath, int iIconIndex);
#ifdef UNICODE
#define SHGetIconOverlayIndex  SHGetIconOverlayIndexW
#else
#define SHGetIconOverlayIndex  SHGetIconOverlayIndexA
#endif // !UNICODE


#if (_WIN32_IE >= 0x0400)

// IShellLinkDataList::GetFlags()/SetFlags()
typedef enum {
    SLDF_HAS_ID_LIST                            = 0x00000001,   // Shell link saved with ID list
    SLDF_HAS_LINK_INFO                          = 0x00000002,   // Shell link saved with LinkInfo
    SLDF_HAS_NAME                               = 0x00000004,
    SLDF_HAS_RELPATH                            = 0x00000008,
    SLDF_HAS_WORKINGDIR                         = 0x00000010,
    SLDF_HAS_ARGS                               = 0x00000020,
    SLDF_HAS_ICONLOCATION                       = 0x00000040,
    SLDF_UNICODE                                = 0x00000080,   // the strings are unicode
    SLDF_FORCE_NO_LINKINFO                      = 0x00000100,   // disable LINKINFO tracking information (used to track network drives and compute UNC paths if one exists)
    SLDF_HAS_EXP_SZ                             = 0x00000200,   // the link contains expandable env strings
    SLDF_RUN_IN_SEPARATE                        = 0x00000400,   // Run the 16-bit target exe in a separate VDM/WOW
#if (NTDDI_VERSION < NTDDI_LONGHORN)
    SLDF_HAS_LOGO3ID                            = 0x00000800,   // not used anymore
#endif
    SLDF_HAS_DARWINID                           = 0x00001000,   // MSI (Darwin) link that can be installed on demand
    SLDF_RUNAS_USER                             = 0x00002000,   // Run target as a different user
    SLDF_HAS_EXP_ICON_SZ                        = 0x00004000,   // contains expandable env string for icon path
#if (NTDDI_VERSION >= NTDDI_WINXP)
    SLDF_NO_PIDL_ALIAS                          = 0x00008000,   // disable IDList alias mapping when parsing the IDList from the path
    SLDF_FORCE_UNCNAME                          = 0x00010000,   // make GetPath() prefer the UNC name to the local name
    SLDF_RUN_WITH_SHIMLAYER                     = 0x00020000,   // activate target of this link with shim layer active
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
    SLDF_FORCE_NO_LINKTRACK                     = 0x00040000,   // disable ObjectID tracking information
    SLDF_ENABLE_TARGET_METADATA                 = 0x00080000,   // enable caching of target metadata into link
    SLDF_DISABLE_KNOWNFOLDER_RELATIVE_TRACKING  = 0x00200000,   // disable KnownFolder tracking information (EXP_KNOWN_FOLDER)
    SLDF_VALID                                  = 0x003FF7FF,   // bits that are valid for ::SetFlags()
#endif
    SLDF_RESERVED                               = 0x80000000,   // Reserved-- so we can use the low word as an index value in the future
#endif
} SHELL_LINK_DATA_FLAGS;

#if !defined(__cplusplus) && defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#endif

typedef struct tagDATABLOCKHEADER
{
    DWORD   cbSize;             // Size of this extra data block
    DWORD   dwSignature;        // signature of this extra data block
} DATABLOCK_HEADER, *LPDATABLOCK_HEADER, *LPDBLIST;

/*
// #ifndef IEMOBILE
// COORD structure is not defined in WinCE. So commenting it out as this definition
// might not be required by IE on WinCE
typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER;
#endif
    WORD     wFillAttribute;         // fill attribute for console
    WORD     wPopupFillAttribute;    // fill attribute for console popups
    COORD    dwScreenBufferSize;     // screen buffer size for console
    COORD    dwWindowSize;           // window size for console
    COORD    dwWindowOrigin;         // window origin for console
    DWORD    nFont;
    DWORD    nInputBufferSize;
    COORD    dwFontSize;
    UINT     uFontFamily;
    UINT     uFontWeight;
    WCHAR    FaceName[LF_FACESIZE];
    UINT     uCursorSize;
    BOOL     bFullScreen;
    BOOL     bQuickEdit;
    BOOL     bInsertMode;
    BOOL     bAutoPosition;
    UINT     uHistoryBufferSize;
    UINT     uNumberOfHistoryBuffers;
    BOOL     bHistoryNoDup;
    COLORREF ColorTable[ 16 ];
} NT_CONSOLE_PROPS, *LPNT_CONSOLE_PROPS;
#define NT_CONSOLE_PROPS_SIG 0xA0000002
// endif // #ifndef IEMOBILE
*/

// This is a FE Console property
typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER;
#endif
    UINT     uCodePage;
} NT_FE_CONSOLE_PROPS, *LPNT_FE_CONSOLE_PROPS;
#define NT_FE_CONSOLE_PROPS_SIG 0xA0000004

#if (_WIN32_IE >= 0x0500)
typedef struct {
#ifdef __cplusplus
    DATABLOCK_HEADER dbh;
#else
    DATABLOCK_HEADER;
#endif
    CHAR        szDarwinID[MAX_PATH];  // ANSI darwin ID associated with link
    WCHAR       szwDarwinID[MAX_PATH]; // UNICODE darwin ID associated with link
} EXP_DARWIN_LINK, *LPEXP_DARWIN_LINK;
#define EXP_DARWIN_ID_SIG       0xA0000006
#endif

#if !defined(__cplusplus) && defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif

#define EXP_SPECIAL_FOLDER_SIG         0xA0000005   // LPEXP_SPECIAL_FOLDER


typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    DWORD       idSpecialFolder;    // special folder id this link points into
    DWORD       cbOffset;           // ofset into pidl from SLDF_HAS_ID_LIST for child
} EXP_SPECIAL_FOLDER, *LPEXP_SPECIAL_FOLDER;


typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    CHAR        szTarget[ MAX_PATH ];   // ANSI target name w/EXP_SZ in it
    WCHAR       swzTarget[ MAX_PATH ];  // UNICODE target name w/EXP_SZ in it
} EXP_SZ_LINK, *LPEXP_SZ_LINK;
#define EXP_SZ_LINK_SIG                0xA0000001   // LPEXP_SZ_LINK (target)
#define EXP_SZ_ICON_SIG                0xA0000007   // LPEXP_SZ_LINK (icon)

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    BYTE abPropertyStorage[1];
} EXP_PROPERTYSTORAGE;
#define EXP_PROPERTYSTORAGE_SIG     0xA0000009
#endif

#endif // (_WIN32_IE >= 0x0400)

/*
// #ifndef IEMOBILE
// LPSHELLEXECUTEINFO
#ifdef _INC_SHELLAPI    
//===========================================================================
//
// IShellExecuteHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookA

DECLARE_INTERFACE_IID_(IShellExecuteHookA, IUnknown, "000214f5-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookA methods ***
    STDMETHOD(Execute)(THIS_ __inout LPSHELLEXECUTEINFOA pei) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookW

DECLARE_INTERFACE_IID_(IShellExecuteHookW, IUnknown, "000214fb-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookW methods ***
    STDMETHOD(Execute)(THIS_ __inout LPSHELLEXECUTEINFOW pei) PURE;
};

#ifdef UNICODE
#define IShellExecuteHook       IShellExecuteHookW
#define IShellExecuteHookVtbl   IShellExecuteHookWVtbl
#else
#define IShellExecuteHook       IShellExecuteHookA
#define IShellExecuteHookVtbl   IShellExecuteHookAVtbl
#endif
#endif
// #endif // #ifndef IEMOBILE
*/

//===========================================================================
//
// IURLSearchHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IURLSearchHook

DECLARE_INTERFACE_IID_(IURLSearchHook, IUnknown, "ac60f6a0-0fd9-11d0-99cb-00c04fd64497")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IURLSearchHook methods ***
    STDMETHOD(Translate)(THIS_ __out_ecount(cchBufferSize) LPWSTR lpwszSearchURL, DWORD cchBufferSize) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchContext

DECLARE_INTERFACE_IID_(ISearchContext, IUnknown, "09F656A2-41AF-480C-88F7-16CC0D164615")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ISearchContext methods ***
    STDMETHOD(GetSearchUrl)(THIS_ __out BSTR * pbstrSearchUrl) PURE;
    STDMETHOD(GetSearchText)(THIS_ __out BSTR * pbstrSearchText) PURE;
    STDMETHOD(GetSearchStyle)(THIS_ __out DWORD * pdwSearchStyle) PURE;
};

#undef  INTERFACE
#define INTERFACE   IURLSearchHook2

DECLARE_INTERFACE_IID_(IURLSearchHook2, IURLSearchHook, "5ee44da4-6d32-46e3-86bc-07540dedd0e0")
{
    // *** IURLSearchHook2 methods ***
    STDMETHOD(TranslateWithSearchContext)(THIS_ __out_ecount(cchBufferSize) LPWSTR lpwszSearchURL, DWORD cchBufferSize, __in_opt ISearchContext * pSearchContext) PURE;
};

//===========================================================================
//
// INewShortcutHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   INewShortcutHookA

DECLARE_INTERFACE_IID_(INewShortcutHookA, IUnknown, "000214e1-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ __out_ecount(cchReferent) LPSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ __out_ecount(cchFolder) LPSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ __out_ecount(cchName) LPSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ __out_ecount(cchExtension) LPSTR pszExtension, int cchExtension) PURE;
};

#undef  INTERFACE
#define INTERFACE   INewShortcutHookW

DECLARE_INTERFACE_IID_(INewShortcutHookW, IUnknown, "000214f7-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCWSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ __out_ecount(cchReferent) LPWSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCWSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ __out_ecount(cchFolder) LPWSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ __out_ecount(cchName) LPWSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ __out_ecount(cchExtension) LPWSTR pszExtension, int cchExtension) PURE;
};

#ifdef UNICODE
#define INewShortcutHook        INewShortcutHookW
#define INewShortcutHookVtbl    INewShortcutHookWVtbl
#else
#define INewShortcutHook        INewShortcutHookA
#define INewShortcutHookVtbl    INewShortcutHookAVtbl
#endif

//===========================================================================
//
// ICopyHook Interface
//
//  The copy hook is called whenever file system directories are
//  copy/moved/deleted/renamed via the shell.  It is also called by the shell
//  on changes of status of printers.
//
//  Clients register their id under STRREG_SHEX_COPYHOOK for file system hooks
//  and STRREG_SHEx_PRNCOPYHOOK for printer hooks.
//  the CopyCallback is called prior to the action, so the hook has the chance
//  to allow, deny or cancel the operation by returning the falues:
//     IDYES  -  means allow the operation
//     IDNO   -  means disallow the operation on this file, but continue with
//              any other operations (eg. batch copy)
//     IDCANCEL - means disallow the current operation and cancel any pending
//              operations
//
//   arguments to the CopyCallback
//      hwnd - window to use for any UI
//      wFunc - what operation is being done
//      wFlags - and flags (FOF_*) set in the initial call to the file operation
//      pszSrcFile - name of the source file
//      dwSrcAttribs - file attributes of the source file
//      pszDestFile - name of the destiation file (for move and renames)
//      dwDestAttribs - file attributes of the destination file
//
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   ICopyHookA

DECLARE_INTERFACE_IID_(ICopyHookA, IUnknown, "000214EF-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookA *    LPCOPYHOOKA;

#undef  INTERFACE
#define INTERFACE   ICopyHookW

DECLARE_INTERFACE_IID_(ICopyHookW, IUnknown, "000214FC-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCWSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCWSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookW *    LPCOPYHOOKW;

#ifdef UNICODE
#define ICopyHook       ICopyHookW
#define ICopyHookVtbl   ICopyHookWVtbl
#define LPCOPYHOOK      LPCOPYHOOKW
#else
#define ICopyHook       ICopyHookA
#define ICopyHookVtbl   ICopyHookAVtbl
#define LPCOPYHOOK      LPCOPYHOOKA
#endif

// IFileViewer, IFileViewerSite not supported as of win2k
#if (NTDDI_VERSION < NTDDI_WIN2K)

//===========================================================================
//
// IFileViewerSite Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IFileViewerSite

DECLARE_INTERFACE_IID_(IFileViewerSite, IUnknown, "000214f3-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewerSite methods ***
    STDMETHOD(SetPinnedWindow) (THIS_ HWND hwnd) PURE;
    STDMETHOD(GetPinnedWindow) (THIS_ __out HWND *phwnd) PURE;
};

typedef IFileViewerSite * LPFILEVIEWERSITE;

//===========================================================================
//
// IFileViewer Interface
//
// Implemented in a FileViewer component object.  Used to tell a
// FileViewer to PrintTo or to view, the latter happening though
// ShowInitialize and Show.  The filename is always given to the
// viewer through IPersistFile.
//
//===========================================================================

#include <pshpack8.h>

typedef struct
{
    // Stuff passed into viewer (in)
    DWORD cbSize;           // Size of structure for future expansion...
    HWND hwndOwner;         // who is the owner window.
    int iShow;              // The show command

    // Passed in and updated  (in/Out)
    DWORD dwFlags;          // flags
    RECT rect;              // Where to create the window may have defaults
    IUnknown *punkRel;      // Relese this interface when window is visible

    // Stuff that might be returned from viewer (out)
    OLECHAR strNewFile[MAX_PATH];   // New File to view.

} FVSHOWINFO, *LPFVSHOWINFO;

#include <poppack.h>        /* Return to byte packing */

    // Define File View Show Info Flags.
#define FVSIF_RECT      0x00000001      // The rect variable has valid data.
#define FVSIF_PINNED    0x00000002      // We should Initialize pinned

#define FVSIF_NEWFAILED 0x08000000      // The new file passed back failed
                                        // to be viewed.

#define FVSIF_NEWFILE   0x80000000      // A new file to view has been returned
#define FVSIF_CANVIEWIT 0x40000000      // The viewer can view it.

#undef  INTERFACE
#define INTERFACE   IFileViewerA

DECLARE_INTERFACE_IID(IFileViewerA, "000214f0-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ __in LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ __in LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ __in_opt LPSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerA * LPFILEVIEWERA;

#undef  INTERFACE
#define INTERFACE   IFileViewerW

DECLARE_INTERFACE_IID(IFileViewerW, "000214f8-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ __in LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ __in LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ __in_opt LPWSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerW * LPFILEVIEWERW;

#ifdef UNICODE
#define IFileViewer IFileViewerW
#define LPFILEVIEWER LPFILEVIEWERW
#else
#define IFileViewer IFileViewerA
#define LPFILEVIEWER LPFILEVIEWERA
#endif

// IFileViewer, IFileViewerSite not supported as of win2k
#endif // (NTDDI_VERSION < NTDDI_WIN2K)


//--------------------------------------------------------------------------
//
// Command/menuitem IDs
//
//  The explorer dispatches WM_COMMAND messages based on the range of
// command/menuitem IDs. All the IDs of menuitems that the view (right
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer
// won't dispatch them). The view should not deal with any menuitems
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future
// version of the shell).
//
//  FCIDM_SHVIEWFIRST/LAST      for the right pane (IShellView)
//  FCIDM_BROWSERFIRST/LAST     for the explorer frame (IShellBrowser)
//  FCIDM_GLOBAL/LAST           for the explorer's submenu IDs
//
//--------------------------------------------------------------------------

#define FCIDM_SHVIEWFIRST           0x0000
#define FCIDM_SHVIEWLAST            0x7fff
#define FCIDM_BROWSERFIRST          0xa000
#define FCIDM_BROWSERLAST           0xbf00
#define FCIDM_GLOBALFIRST           0x8000
#define FCIDM_GLOBALLAST            0x9fff

//
// Global submenu IDs and separator IDs
//
#define FCIDM_MENU_FILE             (FCIDM_GLOBALFIRST+0x0000)
#define FCIDM_MENU_EDIT             (FCIDM_GLOBALFIRST+0x0040)
#define FCIDM_MENU_VIEW             (FCIDM_GLOBALFIRST+0x0080)
#define FCIDM_MENU_VIEW_SEP_OPTIONS (FCIDM_GLOBALFIRST+0x0081)
#define FCIDM_MENU_TOOLS            (FCIDM_GLOBALFIRST+0x00c0) // for Win9x compat
#define FCIDM_MENU_TOOLS_SEP_GOTO   (FCIDM_GLOBALFIRST+0x00c1) // for Win9x compat
#define FCIDM_MENU_HELP             (FCIDM_GLOBALFIRST+0x0100)
#define FCIDM_MENU_FIND             (FCIDM_GLOBALFIRST+0x0140)
#define FCIDM_MENU_EXPLORE          (FCIDM_GLOBALFIRST+0x0150)
#define FCIDM_MENU_FAVORITES        (FCIDM_GLOBALFIRST+0x0170)

//--------------------------------------------------------------------------
// control IDs known to the view
//--------------------------------------------------------------------------

#define FCIDM_TOOLBAR      (FCIDM_BROWSERFIRST + 0)
#define FCIDM_STATUS       (FCIDM_BROWSERFIRST + 1)

#if (_WIN32_IE >= 0x0400)
//--------------------------------------------------------------------------
//
// The resource id of the offline cursor
// This cursor is avaialble in shdocvw.dll
#define IDC_OFFLINE_HAND        103
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define IDC_PANTOOL_HAND_OPEN   104
#define IDC_PANTOOL_HAND_CLOSED 105
#endif
//
//--------------------------------------------------------------------------
#endif


// SBCMDID_GETPANE - not necessarily in order
#define PANE_NONE        ((DWORD)-1)
#define PANE_ZONE        1
#define PANE_OFFLINE     2
#define PANE_PRINTER     3
#define PANE_SSL         4
#define PANE_NAVIGATION  5
#define PANE_PROGRESS    6
#if (_WIN32_IE >= _WIN32_IE_IE60)
#define PANE_PRIVACY     7
#endif


// SHGetPathFromIDListEx returns a win32 file system path for the item in the name space.
//  and has a few special cases that include returning UNC printer names too!
typedef enum tagGPFIDL_FLAGS
{
    GPFIDL_DEFAULT    = 0x0000,      // normal Win32 file name, servers and drive roots included
    GPFIDL_ALTNAME    = 0x0001,      // short file name
    GPFIDL_UNCPRINTER = 0x0002,      // include UNC printer names too (non file system item)
};
typedef int GPFIDL_FLAGS;
SHSTDAPI_(BOOL) SHGetPathFromIDListEx(__in PCIDLIST_ABSOLUTE pidl, __out_ecount(cchPath) PWSTR pszPath, __in DWORD cchPath, __in GPFIDL_FLAGS uOpts);

//
// SHGetPathFromIDListW is the old version of SHGetPathFromIDListEx that assumes the size of the buffer (MAX_PATH).
// The pidl should point to a file system object.

#ifndef UNDER_CE // implemented only as unicode on Windows CE
SHSTDAPI_(BOOL) SHGetPathFromIDListA(PCIDLIST_ABSOLUTE pidl, __out_ecount(MAX_PATH) LPSTR pszPath);
SHSTDAPI_(BOOL) SHGetPathFromIDListW(PCIDLIST_ABSOLUTE pidl, __out_ecount(MAX_PATH) LPWSTR pszPath);
#ifdef UNICODE
#define SHGetPathFromIDList  SHGetPathFromIDListW
#else
#define SHGetPathFromIDList  SHGetPathFromIDListA
#endif // !UNICODE
#else
SHSTDAPI_(BOOL) SHGetPathFromIDList(LPCITEMIDLIST pidl, __out_ecount(MAX_PATH) LPTSTR pszPath);
#endif

SHSTDAPI_(int) SHCreateDirectory(HWND hwnd, LPCWSTR pszPath);
SHSTDAPI_(int) SHCreateDirectoryExA(HWND hwnd, LPCSTR pszPath, const SECURITY_ATTRIBUTES *psa);
SHSTDAPI_(int) SHCreateDirectoryExW(HWND hwnd, LPCWSTR pszPath, const SECURITY_ATTRIBUTES *psa);
#ifdef UNICODE
#define SHCreateDirectoryEx  SHCreateDirectoryExW
#else
#define SHCreateDirectoryEx  SHCreateDirectoryExA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define OFASI_EDIT          0x0001
#define OFASI_OPENDESKTOP   0x0002
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

SHSTDAPI SHOpenFolderAndSelectItems(PCIDLIST_ABSOLUTE pidlFolder, UINT cidl, __in_ecount_opt(cidl) PCUITEMID_CHILD_ARRAY apidl, DWORD dwFlags);

//  deprecated because of parameter ambiguity
//  call SHCreateItemWithParent() or SHCreateItemFromIDList() instead
SHSTDAPI SHCreateShellItem(__in_opt PCIDLIST_ABSOLUTE pidlParent, __in_opt IShellFolder *psfParent, __in PCUITEMID_CHILD pidl, __out IShellItem **ppsi);

#endif

//
// SHGetSpecialFolderLocation
//
//  Caller should use SHGetMalloc to obtain an allocator that can free the pidl
//
// registry entries for special paths are kept in :
#define REGSTR_PATH_SPECIAL_FOLDERS     REGSTR_PATH_EXPLORER TEXT("\\Shell Folders")


#define CSIDL_DESKTOP                   0x0000        // <desktop>
#define CSIDL_INTERNET                  0x0001        // Internet Explorer (icon on desktop)
#define CSIDL_PROGRAMS                  0x0002        // Start Menu\Programs
#define CSIDL_CONTROLS                  0x0003        // My Computer\Control Panel
#define CSIDL_PRINTERS                  0x0004        // My Computer\Printers
#define CSIDL_PERSONAL                  0x0005        // My Documents
#define CSIDL_FAVORITES                 0x0006        // <user name>\Favorites
#define CSIDL_STARTUP                   0x0007        // Start Menu\Programs\Startup
#define CSIDL_RECENT                    0x0008        // <user name>\Recent
#define CSIDL_SENDTO                    0x0009        // <user name>\SendTo
#define CSIDL_BITBUCKET                 0x000a        // <desktop>\Recycle Bin
#define CSIDL_STARTMENU                 0x000b        // <user name>\Start Menu
#define CSIDL_MYDOCUMENTS               CSIDL_PERSONAL //  Personal was just a silly name for My Documents
#define CSIDL_MYMUSIC                   0x000d        // "My Music" folder
#define CSIDL_MYVIDEO                   0x000e        // "My Videos" folder
#define CSIDL_DESKTOPDIRECTORY          0x0010        // <user name>\Desktop
#define CSIDL_DRIVES                    0x0011        // My Computer
#define CSIDL_NETWORK                   0x0012        // Network Neighborhood (My Network Places)
#define CSIDL_NETHOOD                   0x0013        // <user name>\nethood
#define CSIDL_FONTS                     0x0014        // windows\fonts
#define CSIDL_TEMPLATES                 0x0015
#define CSIDL_COMMON_STARTMENU          0x0016        // All Users\Start Menu
#define CSIDL_COMMON_PROGRAMS           0X0017        // All Users\Start Menu\Programs
#define CSIDL_COMMON_STARTUP            0x0018        // All Users\Startup
#define CSIDL_COMMON_DESKTOPDIRECTORY   0x0019        // All Users\Desktop
#define CSIDL_APPDATA                   0x001a        // <user name>\Application Data
#define CSIDL_PRINTHOOD                 0x001b        // <user name>\PrintHood

#ifndef CSIDL_LOCAL_APPDATA
#define CSIDL_LOCAL_APPDATA             0x001c        // <user name>\Local Settings\Applicaiton Data (non roaming)
#endif // CSIDL_LOCAL_APPDATA

#define CSIDL_ALTSTARTUP                0x001d        // non localized startup
#define CSIDL_COMMON_ALTSTARTUP         0x001e        // non localized common startup
#define CSIDL_COMMON_FAVORITES          0x001f

#ifndef _SHFOLDER_H_
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022
#define CSIDL_COMMON_APPDATA            0x0023        // All Users\Application Data
#define CSIDL_WINDOWS                   0x0024        // GetWindowsDirectory()
#define CSIDL_SYSTEM                    0x0025        // GetSystemDirectory()
#define CSIDL_PROGRAM_FILES             0x0026        // C:\Program Files
#define CSIDL_MYPICTURES                0x0027        // C:\Program Files\My Pictures
#endif // _SHFOLDER_H_

#define CSIDL_PROFILE                   0x0028        // USERPROFILE
#define CSIDL_SYSTEMX86                 0x0029        // x86 system directory on RISC
#define CSIDL_PROGRAM_FILESX86          0x002a        // x86 C:\Program Files on RISC

#ifndef _SHFOLDER_H_
#define CSIDL_PROGRAM_FILES_COMMON      0x002b        // C:\Program Files\Common
#endif // _SHFOLDER_H_

#define CSIDL_PROGRAM_FILES_COMMONX86   0x002c        // x86 Program Files\Common on RISC
#define CSIDL_COMMON_TEMPLATES          0x002d        // All Users\Templates

#ifndef _SHFOLDER_H_
#define CSIDL_COMMON_DOCUMENTS          0x002e        // All Users\Documents
#define CSIDL_COMMON_ADMINTOOLS         0x002f        // All Users\Start Menu\Programs\Administrative Tools
#define CSIDL_ADMINTOOLS                0x0030        // <user name>\Start Menu\Programs\Administrative Tools
#endif // _SHFOLDER_H_

#define CSIDL_CONNECTIONS               0x0031        // Network and Dial-up Connections
#define CSIDL_COMMON_MUSIC              0x0035        // All Users\My Music
#define CSIDL_COMMON_PICTURES           0x0036        // All Users\My Pictures
#define CSIDL_COMMON_VIDEO              0x0037        // All Users\My Video
#define CSIDL_RESOURCES                 0x0038        // Resource Direcotry

#ifndef _SHFOLDER_H_
#define CSIDL_RESOURCES_LOCALIZED       0x0039        // Localized Resource Direcotry
#endif // _SHFOLDER_H_

#define CSIDL_COMMON_OEM_LINKS          0x003a        // Links to All Users OEM specific apps
#define CSIDL_CDBURN_AREA               0x003b        // USERPROFILE\Local Settings\Application Data\Microsoft\CD Burning
// unused                               0x003c
#define CSIDL_COMPUTERSNEARME           0x003d        // Computers Near Me (computered from Workgroup membership)

#ifndef _SHFOLDER_H_
#define CSIDL_FLAG_CREATE               0x8000        // combine with CSIDL_ value to force folder creation in SHGetFolderPath()
#endif // _SHFOLDER_H_

#define CSIDL_FLAG_DONT_VERIFY          0x4000        // combine with CSIDL_ value to return an unverified folder path
#define CSIDL_FLAG_DONT_UNEXPAND        0x2000        // combine with CSIDL_ value to avoid unexpanding environment variables
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define CSIDL_FLAG_NO_ALIAS             0x1000        // combine with CSIDL_ value to insure non-alias versions of the pidl
#define CSIDL_FLAG_PER_USER_INIT        0x0800        // combine with CSIDL_ value to indicate per-user init (eg. upgrade)
#endif  // NTDDI_WINXP
#define CSIDL_FLAG_MASK                 0xFF00        // mask for all possible flag values

SHSTDAPI SHGetSpecialFolderLocation(HWND hwnd, int csidl, __out PIDLIST_ABSOLUTE *ppidl);

SHSTDAPI_(PIDLIST_ABSOLUTE) SHCloneSpecialIDList(HWND hwnd, int csidl, BOOL fCreate);

#ifndef UNDER_CE // CE only implements a Unicode version of this call defined in shellapi.h
SHSTDAPI_(BOOL) SHGetSpecialFolderPathA(HWND hwnd, __out_ecount(MAX_PATH) LPSTR pszPath, int csidl, BOOL fCreate);
SHSTDAPI_(BOOL) SHGetSpecialFolderPathW(HWND hwnd, __out_ecount(MAX_PATH) LPWSTR pszPath, int csidl, BOOL fCreate);
#ifdef UNICODE
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathW
#else
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathA
#endif // !UNICODE
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
SHSTDAPI_(void) SHFlushSFCache(void);

typedef enum {
    SHGFP_TYPE_CURRENT  = 0,   // current value for user, verify it exists
    SHGFP_TYPE_DEFAULT  = 1,   // default value, may not exist
} SHGFP_TYPE;

#ifndef UNDER_CE // #ifndef IEMOBILE
SHFOLDERAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, __out_ecount(MAX_PATH) //LPSTR pszPath);
SHFOLDERAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, __out_ecount(MAX_PATH) //LPWSTR pszPath);
#ifdef UNICODE
#define SHGetFolderPath  SHGetFolderPathW
#else
#define SHGetFolderPath  SHGetFolderPathA
#endif // !UNICODE
#endif

SHSTDAPI SHGetFolderLocation(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, __out PIDLIST_ABSOLUTE *ppidl);
SHSTDAPI SHSetFolderPathA(int csidl, HANDLE hToken, DWORD dwFlags, LPCSTR pszPath);
SHSTDAPI SHSetFolderPathW(int csidl, HANDLE hToken, DWORD dwFlags, LPCWSTR pszPath);
#ifdef UNICODE
#define SHSetFolderPath  SHSetFolderPathW
#else
#define SHSetFolderPath  SHSetFolderPathA
#endif // !UNICODE
#endif  // NTDDI_WIN2K

#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI SHGetFolderPathAndSubDirA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPCSTR pszSubDir, __out_ecount(MAX_PATH) LPSTR pszPath);
SHSTDAPI SHGetFolderPathAndSubDirW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPCWSTR pszSubDir, __out_ecount(MAX_PATH) LPWSTR pszPath);
#ifdef UNICODE
#define SHGetFolderPathAndSubDir  SHGetFolderPathAndSubDirW
#else
#define SHGetFolderPathAndSubDir  SHGetFolderPathAndSubDirA
#endif // !UNICODE
#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN)

//
//  KNOWNFOLDERID based APIs
//

#define KF_FLAG_CREATE              0x00008000  // Make sure that the folder already exists or create it and apply security specified in folder definition
                                                // If folder can not be created then function will return failure and no folder path (IDList) will be returned
                                                // If folder is located on the network the function may take long time to execute

#define KF_FLAG_DONT_VERIFY         0x00004000  // If this flag is specified then the folder path is returned and no verification is performed
                                                // Use this flag is you want to get folder's path (IDList) and do not need to verify folder's existence
                                                //
                                                // If this flag is NOT specified then Known Folder API will try to verify that the folder exists
                                                //     If folder does not exist or can not be accessed then function will return failure and no folder path (IDList) will be returned
                                                //     If folder is located on the network the function may take long time to execute

#define KF_FLAG_DONT_UNEXPAND       0x00002000  // Set folder path as is and do not try to substitute parts of the path with environments variables.
                                                // If flag is not specified then Known Folder will try to replace parts of the path with some
                                                // known environment variables (%USERPROFILE%, %APPDATA% etc.)

#define KF_FLAG_NO_ALIAS            0x00001000  // Get file system based IDList if available. If the flag is not specified the Known Folder API
                                                // will try to return aliased IDList by default. Example for FOLDERID_Documents -
                                                // Aliased - [desktop]\[user]\[Documents] - exact location is determined by shell namespace layout and might change
                                                // Non aliased - [desktop]\[computer]\[disk_c]\[users]\[user]\[Documents] - location is determined by folder location in the file system

#define KF_FLAG_INIT                0x00000800  // Initialize the folder with desktop.ini settings
                                                // If folder can not be initialized then function will return failure and no folder path will be returned
                                                // If folder is located on the network the function may take long time to execute

#define KF_FLAG_DEFAULT_PATH        0x00000400  // Get the default path, will also verify folder existence unless KF_FLAG_DONT_VERIFY is also specified
#define KF_FLAG_NOT_PARENT_RELATIVE 0x00000200  // Get the not-parent-relative default path. Only valid with KF_FLAG_DEFAULT_PATH

#define KF_FLAG_SIMPLE_IDLIST       0x00000100  // Build simple pidl


STDAPI SHGetKnownFolderIDList(REFKNOWNFOLDERID rfid,
                             DWORD dwFlags,
                             HANDLE hToken,
                             __out PIDLIST_ABSOLUTE *ppidl);

STDAPI SHSetKnownFolderPath(REFKNOWNFOLDERID rfid,
                         DWORD dwFlags,
                         HANDLE hToken,
                         __in_opt PCWSTR pszPath);

STDAPI SHGetKnownFolderPath(REFKNOWNFOLDERID rfid,
                         DWORD dwFlags,
                         HANDLE hToken,
                         __out PWSTR *ppszPath); // free *ppszPath with CoTaskMemFree

#endif  // NTDDI_LONGHORN

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#define FCS_READ                    0x00000001
#define FCS_FORCEWRITE              0x00000002
#define FCS_WRITE                   (FCS_READ | FCS_FORCEWRITE)

#define FCS_FLAG_DRAGDROP           2

// Mask which values have been retreived or being set.
#define FCSM_VIEWID                 0x00000001    // deprecated
#define FCSM_WEBVIEWTEMPLATE        0x00000002  // deprecated
#define FCSM_INFOTIP                0x00000004
#define FCSM_CLSID                  0x00000008
#define FCSM_ICONFILE               0x00000010
#define FCSM_LOGO                   0x00000020
#define FCSM_FLAGS                  0x00000040

#include <pshpack8.h>

// Used by SHGetSetFolderCustomSettings
typedef struct
{
    DWORD           dwSize;
    DWORD           dwMask;              // IN/OUT  Which Attributes to Get/Set
    SHELLVIEWID*    pvid;                // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // The folder's WebView template path
    LPWSTR          pszWebViewTemplate;   // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchWebViewTemplate;   // IN - Specifies the size of the buffer pointed to by pszWebViewTemplate
                                         // Ignored if dwReadWrite is FCS_READ
    LPWSTR           pszWebViewTemplateVersion;  // currently IN only
    // Infotip for the folder
    LPWSTR          pszInfoTip;          // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchInfoTip;          // IN - Specifies the size of the buffer pointed to by pszInfoTip
                                         // Ignored if dwReadWrite is FCS_READ
    // CLSID that points to more info in the registry
    CLSID*          pclsid;              // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // Other flags for the folder. Takes FCS_FLAG_* values
    DWORD           dwFlags;             // OUT - if dwReadWrite is FCS_READ, IN - otherwise


    LPWSTR           pszIconFile;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD            cchIconFile;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                         // Ignored if dwReadWrite is FCS_READ

    int              iIconIndex;         // OUT - if dwReadWrite is FCS_READ, IN - otherwise

    LPWSTR           pszLogo;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD            cchLogo;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                         // Ignored if dwReadWrite is FCS_READ
} SHFOLDERCUSTOMSETTINGS, *LPSHFOLDERCUSTOMSETTINGS;

#include <poppack.h>        /* Return to byte packing */

// Gets/Sets the Folder Custom Settings for pszPath based on dwReadWrite. dwReadWrite can be FCS_READ/FCS_WRITE/FCS_FORCEWRITE
SHSTDAPI SHGetSetFolderCustomSettings(__inout LPSHFOLDERCUSTOMSETTINGS pfcs, LPCWSTR pszPath, DWORD dwReadWrite);

#endif  // NTDDI_WIN2K

//-------------------------------------------------------------------------
//
// SHBrowseForFolder API
//
//
//-------------------------------------------------------------------------

typedef int (CALLBACK* BFFCALLBACK)(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

#include <pshpack8.h>

typedef struct _browseinfoA {
    HWND        hwndOwner;
    PCIDLIST_ABSOLUTE pidlRoot;
    LPSTR        pszDisplayName;        // Return display name of item selected.
    LPCSTR       lpszTitle;                     // text to go in the banner over the tree.
    UINT         ulFlags;                       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM       lParam;                        // extra info that's passed back in callbacks
    int          iImage;                        // output var: where to return the Image index.
} BROWSEINFOA, *PBROWSEINFOA, *LPBROWSEINFOA;

typedef struct _browseinfoW {
    HWND        hwndOwner;
    PCIDLIST_ABSOLUTE pidlRoot;
    LPWSTR       pszDisplayName;        // Return display name of item selected.
    LPCWSTR      lpszTitle;                     // text to go in the banner over the tree.
    UINT         ulFlags;                       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM       lParam;                        // extra info that's passed back in callbacks
    int          iImage;                        // output var: where to return the Image index.
} BROWSEINFOW, *PBROWSEINFOW, *LPBROWSEINFOW;

#include <poppack.h>        /* Return to byte packing */

#ifdef UNICODE
#define BROWSEINFO      BROWSEINFOW
#define PBROWSEINFO     PBROWSEINFOW
#define LPBROWSEINFO    LPBROWSEINFOW
#else
#define BROWSEINFO      BROWSEINFOA
#define PBROWSEINFO     PBROWSEINFOA
#define LPBROWSEINFO    LPBROWSEINFOA
#endif

// Browsing for directory.
#define BIF_RETURNONLYFSDIRS   0x0001  // For finding a folder to start document searching
#define BIF_DONTGOBELOWDOMAIN  0x0002  // For starting the Find Computer
#define BIF_STATUSTEXT         0x0004   // Top of the dialog has 2 lines of text for BROWSEINFO.lpszTitle and one line if
                                        // this flag is set.  Passing the message BFFM_SETSTATUSTEXTA to the hwnd can set the
                                        // rest of the text.  This is not used with BIF_USENEWUI and BROWSEINFO.lpszTitle gets
                                        // all three lines of text.
#define BIF_RETURNFSANCESTORS  0x0008
#define BIF_EDITBOX            0x0010   // Add an editbox to the dialog
#define BIF_VALIDATE           0x0020   // insist on valid result (or CANCEL)

#define BIF_NEWDIALOGSTYLE     0x0040   // Use the new dialog layout with the ability to resize
                                        // Caller needs to call OleInitialize() before using this API

#define BIF_USENEWUI           (BIF_NEWDIALOGSTYLE | BIF_EDITBOX)

#define BIF_BROWSEINCLUDEURLS  0x0080   // Allow URLs to be displayed or entered. (Requires BIF_USENEWUI)
#define BIF_UAHINT             0x0100   // Add a UA hint to the dialog, in place of the edit box. May not be combined with BIF_EDITBOX
#define BIF_NONEWFOLDERBUTTON  0x0200   // Do not add the "New Folder" button to the dialog.  Only applicable with BIF_NEWDIALOGSTYLE.
#define BIF_NOTRANSLATETARGETS 0x0400   // don't traverse target as shortcut

#define BIF_BROWSEFORCOMPUTER  0x1000  // Browsing for Computers.
#define BIF_BROWSEFORPRINTER   0x2000  // Browsing for Printers
#define BIF_BROWSEINCLUDEFILES 0x4000  // Browsing for Everything
#define BIF_SHAREABLE          0x8000  // sharable resources displayed (remote shares, requires BIF_USENEWUI)

// message from browser
#define BFFM_INITIALIZED        1
#define BFFM_SELCHANGED         2
#define BFFM_VALIDATEFAILEDA    3   // lParam:szPath ret:1(cont),0(EndDialog)
#define BFFM_VALIDATEFAILEDW    4   // lParam:wzPath ret:1(cont),0(EndDialog)
#define BFFM_IUNKNOWN           5   // provides IUnknown to client. lParam: IUnknown*

// messages to browser
#define BFFM_SETSTATUSTEXTA     (WM_USER + 100)
#define BFFM_ENABLEOK           (WM_USER + 101)
#define BFFM_SETSELECTIONA      (WM_USER + 102)
#define BFFM_SETSELECTIONW      (WM_USER + 103)
#define BFFM_SETSTATUSTEXTW     (WM_USER + 104)
#define BFFM_SETOKTEXT          (WM_USER + 105) // Unicode only
#define BFFM_SETEXPANDED        (WM_USER + 106) // Unicode only


SHSTDAPI_(PIDLIST_ABSOLUTE) SHBrowseForFolderA(LPBROWSEINFOA lpbi);
SHSTDAPI_(PIDLIST_ABSOLUTE) SHBrowseForFolderW(LPBROWSEINFOW lpbi);

#ifdef UNICODE

#ifndef UNDER_CE
#define SHBrowseForFolder   SHBrowseForFolderW
#else
SHSTDAPI_(PIDLIST_ABSOLUTE) SHBrowseForFolder(LPBROWSEINFOW lpbi);
#endif

#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTW
#define BFFM_SETSELECTION   BFFM_SETSELECTIONW

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDW
#else
#define SHBrowseForFolder   SHBrowseForFolderA
#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTA
#define BFFM_SETSELECTION   BFFM_SETSELECTIONA

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDA
#endif

//-------------------------------------------------------------------------
//
// SHLoadInProc
//
//   This function is no longer implemented. It will return E_NOTIMPL.
//
//-------------------------------------------------------------------------

SHSTDAPI SHLoadInProc(REFCLSID rclsid);


//-------------------------------------------------------------------------
//
// Internet Shortcut Object
//
//-------------------------------------------------------------------------
// Cmds for CGID_ShortCut
#if (_WIN32_IE >= _WIN32_IE_IE501)
enum
{
    ISHCUTCMDID_DOWNLOADICON      = 0,
    ISHCUTCMDID_INTSHORTCUTCREATE = 1,
#if (_WIN32_IE >= _WIN32_IE_IE70)
    ISHCUTCMDID_COMMITHISTORY     = 2,
    ISHCUTCMDID_SETUSERAWURL      = 3,
#endif
};
#define CMDID_INTSHORTCUTCREATE ISHCUTCMDID_INTSHORTCUTCREATE
#endif


//
// Helper function which returns a IShellFolder interface to the desktop
// folder. This is equivalent to call CoCreateInstance with CLSID_ShellDesktop.
//
//  CoCreateInstance(CLSID_Desktop, NULL, CLSCTX_INPROC, IID_PPV_ARGS(&pshf));
//
SHSTDAPI SHGetDesktopFolder(__out IShellFolder **ppshf);

// this interface is deprecated, data sources should
// implement IShellFolder2::GetDetailsOf()/GetDetailsEx() instead

#undef  INTERFACE
#define INTERFACE   IShellDetails

DECLARE_INTERFACE_IID_(IShellDetails, IUnknown, "000214EC-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellDetails methods ***
    STDMETHOD(GetDetailsOf)(THIS_ PCUITEMID_CHILD pidl, UINT iColumn, __out SHELLDETAILS *pDetails) PURE;
    STDMETHOD(ColumnClick)(THIS_ UINT iColumn) PURE;
};


//
// IObjMgr::Append(punk)
//   This function adds an object to the end of a list of objects.
//
// IObjMgr::Remove(punk)
//   This function removes an object from a list of objects.
//
// This is implemented by CLSID_ACLMulti so each AutoComplete List
// (CLSID_ACLHistory, CLSID_ACListISF, CLSID_ACLMRU) can be added.
// CLSID_ACLMulti's IEnumString will then be the union of the results
// from the COM Objects added.
//

#undef INTERFACE
#define INTERFACE IObjMgr

DECLARE_INTERFACE_IID_(IObjMgr, IUnknown, "00BB2761-6A77-11D0-A535-00C04FD7D062")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IObjMgr specific methods ***
    STDMETHOD(Append) (THIS_ __in IUnknown *punk) PURE;
    STDMETHOD(Remove) (THIS_ __in IUnknown *punk) PURE;
};

//
// ICurrentWorkingDirectory::GetDirectory(LPWSTR pwzPath, DWORD cchSize)
//   This function gets the Current Working Directory from a COM object that
//   stores such state.
//
// ICurrentWorkingDirectory::SetDirectory(LPCWSTR pwzPath)
//   This function sets the Current Working Directory of a COM object that
//   stores such state.
//
// This function can be used generically.  One COM object that implements it
// is CLSID_ACListISF so that the AutoComplete engine can complete relative
// paths.  SetDirectory() will set the "Current Working Directory" and
// AutoComplete with then complete both absolute and relative paths.
// For Example, if ::SetDirectory(L"C:\Program Files") is called, then
// the user can AutoComplete "..\winnt".  In order to set the current
// working directory for non-file system paths, "ftp://ftp.microsoft.com/" or
// "Control Panel" for example, use IPersistFolder.
//

#undef INTERFACE
#define INTERFACE ICurrentWorkingDirectory

DECLARE_INTERFACE_IID_(ICurrentWorkingDirectory, IUnknown, "91956D21-9276-11d1-921A-006097DF5BD4")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** ICurrentWorkingDirectory specific methods ***
    STDMETHOD(GetDirectory) (THIS_ __out_ecount(cchSize) LPWSTR pwzPath, DWORD cchSize) PURE;
    STDMETHOD(SetDirectory) (THIS_ LPCWSTR pwzPath) PURE;
};


//
// IACList::Expand(LPCWSTR)
//   This function tells an autocomplete list to expand a specific string.
//
// If the user enters a multi-level path, AutoComplete (CLSID_AutoComplete)
// will use this interface to tell the "AutoComplete Lists" where to expand
// the results.
//
// For Example, if the user enters "C:\Program Files\Micros", AutoComplete
// first completely enumerate the "AutoComplete Lists" via IEnumString.  Then it
// will call the "AutoComplete Lists" with IACList::Expand(L"C:\Program Files").
// It will then enumerate the IEnumString interface again to get results in
// that directory.
//

#undef INTERFACE
#define INTERFACE IACList

DECLARE_INTERFACE_IID_(IACList, IUnknown, "77A130B0-94FD-11D0-A544-00C04FD7d062")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IACList specific methods ***
    STDMETHOD(Expand) (THIS_ LPCWSTR pszExpand) PURE;
};

// This interface exists to allow the caller to set filter criteria
// for an AutoComplete List.  AutoComplete Lists generates the list of
// possible AutoComplete completions.  CLSID_ACListISF is one AutoComplete
// List COM object that implements this interface.

#undef INTERFACE
#define INTERFACE IACList2

typedef enum _tagAUTOCOMPLETELISTOPTIONS
{
    ACLO_NONE            = 0,    // don't enumerate anything
    ACLO_CURRENTDIR      = 1,    // enumerate current directory
    ACLO_MYCOMPUTER      = 2,    // enumerate MyComputer
    ACLO_DESKTOP         = 4,    // enumerate Desktop Folder
    ACLO_FAVORITES       = 8,    // enumerate Favorites Folder
    ACLO_FILESYSONLY     = 16,   // enumerate only the file system
#if (_WIN32_IE >= _WIN32_IE_IE60)
    ACLO_FILESYSDIRS     = 32,   // enumerate only the file system dirs, UNC shares, and UNC servers.
#endif
#if (_WIN32_IE >= _WIN32_IE_IE70)
    ACLO_VIRTUALNAMESPACE = 64,  // enumereate on the virual namespace
#endif
} AUTOCOMPLETELISTOPTIONS;

DECLARE_INTERFACE_IID_(IACList2, IACList, "470141a0-5186-11d2-bbb6-0060977b464c")
{
    // *** IACList2 specific methods ***
    STDMETHOD(SetOptions)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(GetOptions)(THIS_ __out DWORD* pdwFlag) PURE;
};


/*-------------------------------------------------------------------------*\
    INTERFACE: IProgressDialog

    DESCRIPTION:
        CLSID_ProgressDialog/IProgressDialog exist to allow a caller to create
    a progress dialog, set it's title, animation, text lines, progress, and
    it will do all the work of updating on a background thread, being modeless,
    handling the user canceling the operation, and estimating the time remaining
    until the operation completes.

    USAGE:
        This is how the dialog is used during operations that require progress
    and the ability to cancel:
    {
        DWORD dwComplete, dwTotal;
        IProgressDialog * ppd;
        CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_IProgressDialog, (void **)&ppd);
        ppd->SetTitle(L"My Slow Operation");                                // Set the title of the dialog.
        ppd->SetAnimation(hInstApp, IDA_OPERATION_ANIMATION);               // Set the animation to play.
        ppd->StartProgressDialog(hwndParent, punk, PROGDLG_AUTOTIME, NULL); // Display and enable automatic estimated time remaining.
        ppd->SetCancelMsg(L"Please wait while the current operation is cleaned up", NULL);   // Will only be displayed if Cancel button is pressed.

        dwComplete = 0;
        dwTotal = CalcTotalUnitsToDo();

        // Reset because CalcTotalUnitsToDo() took a long time and the estimated time
        // is based on the time between ::StartProgressDialog() and the first
        // ::SetProgress() call.
        ppd->Timer(PDTIMER_RESET, NULL);

        for (nIndex = 0; nIndex < nTotal; nIndex++)
        {
            if (TRUE == ppd->HasUserCancelled())
                break;

            ppd->SetLine(2, L"I'm processing item n", FALSE, NULL);
            dwComplete += DoSlowOperation();

            ppd->SetProgress(dwCompleted, dwTotal);
        }

        ppd->StopProgressDialog();
        ppd->Release();
    }
\*-------------------------------------------------------------------------*/

// Flags for IProgressDialog::StartProgressDialog() (dwFlags)
// The flag space includes OPPROGDLG_ and PROGDLG_ values, please guarantee they don't conflict. See shobjidl.idl for OPPROGDLG_*
#define PROGDLG_NORMAL          0x00000000      // default normal progress dlg behavior
#define PROGDLG_MODAL           0x00000001      // the dialog is modal to its hwndParent (default is modeless)
#define PROGDLG_AUTOTIME        0x00000002      // automatically updates the "Line3" text with the "time remaining" (you cant call SetLine3 if you passs this!)
#define PROGDLG_NOTIME          0x00000004      // we dont show the "time remaining" if this is set. We need this if dwTotal < dwCompleted for sparse files
#define PROGDLG_NOMINIMIZE      0x00000008      // Do not have a minimize button in the caption bar.
#define PROGDLG_NOPROGRESSBAR   0x00000010      // Don't display the progress bar
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define PROGDLG_MARQUEEPROGRESS 0x00000020      // Use marquee progress (comctl32 v6 required)
#define PROGDLG_NOCANCEL        0x00000040      // No cancel button (operation cannot be canceled) (use sparingly)
#endif

// Time Actions (dwTimerAction)
#define PDTIMER_RESET       0x00000001       // Reset the timer so the progress will be calculated from now until the first ::SetProgress() is called so
                                             // those this time will correspond to the values passed to ::SetProgress().  Only do this before ::SetProgress() is called.
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define PDTIMER_PAUSE       0x00000002       // Progress has been suspended
#define PDTIMER_RESUME      0x00000003       // Progress has resumed
#endif


#undef  INTERFACE
#define INTERFACE   IProgressDialog

DECLARE_INTERFACE_IID_(IProgressDialog, IUnknown, "EBBC7C04-315E-11d2-B62F-006097DF5BD4")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IProgressDialog specific methods
    STDMETHOD(StartProgressDialog)(THIS_ __in_opt HWND hwndParent, __in_opt IUnknown * punkEnableModless, DWORD dwFlags, __reserved LPCVOID pvResevered) PURE;
    STDMETHOD(StopProgressDialog)(THIS) PURE;
    STDMETHOD(SetTitle)(THIS_ LPCWSTR pwzTitle) PURE;
    STDMETHOD(SetAnimation)(THIS_ HINSTANCE hInstAnimation, UINT idAnimation) PURE;
    STDMETHOD_(BOOL,HasUserCancelled) (THIS) PURE;
    STDMETHOD(SetProgress)(THIS_ DWORD dwCompleted, DWORD dwTotal) PURE;
    STDMETHOD(SetProgress64)(THIS_ ULONGLONG ullCompleted, ULONGLONG ullTotal) PURE;
    STDMETHOD(SetLine)(THIS_ DWORD dwLineNum, LPCWSTR pwzString, BOOL fCompactPath, __reserved LPCVOID pvResevered) PURE;
    STDMETHOD(SetCancelMsg)(THIS_ LPCWSTR pwzCancelMsg, __reserved LPCVOID pvResevered) PURE;
    STDMETHOD(Timer)(THIS_ DWORD dwTimerAction, __reserved LPCVOID pvResevered) PURE;
};


//==========================================================================
// IDockingWindowSite/IDockingWindow/IDockingWindowFrame interfaces
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================


//-------------------------------------------------------------------------
//
// IDockingWindowSite interface
//
//   A site implements this interface so the object can negotiate for
// and inquire about real estate on the site.
//
// [Member functions]
//
// IDockingWindowSite::GetBorderDW(punkObj, prcBorder)
//   Site returns the bounding rectangle of the given source object
//   (punkObj).
//
// IDockingWindowSite::RequestBorderSpaceDW(punkObj, pbw)
//   Object requests that the site makes room for it, as specified in
//   *pbw.
//
// IDockingWindowSite::SetBorderSpaceDW(punkObj, pbw)
//   Object requests that the site set the border spacing to the size
//   specified in *pbw.
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IDockingWindowSite

DECLARE_INTERFACE_IID_(IDockingWindowSite, IOleWindow, "2a342fc2-7b26-11d0-8ca9-00a0c92dbfe8")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowSite methods ***
    STDMETHOD(GetBorderDW) (THIS_ IUnknown* punkObj, LPRECT prcBorder) PURE;
    STDMETHOD(RequestBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
    STDMETHOD(SetBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
};



//-------------------------------------------------------------------------
//
// IDockingWindowFrame interface
//
// [Member functions]
//
// IDockingWindowFrame::AddToolbar(punkSrc, pwszItem, dwReserved)
//
// IDockingWindowFrame::RemoveToolbar(punkSrc, dwRemoveFlags)
//
// IDockingWindowFrame::FindToolbar(pwszItem, riid, ppv)
//
//-------------------------------------------------------------------------


// flags for RemoveToolbar
#define DWFRF_NORMAL            0x0000
#define DWFRF_DELETECONFIGDATA  0x0001


// flags for AddToolbar
#define DWFAF_HIDDEN    0x0001   // add hidden
#define DWFAF_GROUP1    0x0002   // insert at end of group 1
#define DWFAF_GROUP2    0x0004   // insert at end of group 2
#define DWFAF_AUTOHIDE  0x0010   // The toolbar will be subject to AutoHide in Full Screen mode


#undef  INTERFACE
#define INTERFACE   IDockingWindowFrame

DECLARE_INTERFACE_IID_(IDockingWindowFrame, IOleWindow, "47d2657a-7b27-11d0-8ca9-00a0c92dbfe8")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowFrame methods ***
    STDMETHOD(AddToolbar) (THIS_ IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwAddFlags) PURE;
    STDMETHOD(RemoveToolbar) (THIS_ IUnknown* punkSrc, DWORD dwRemoveFlags) PURE;
    STDMETHOD(FindToolbar) (THIS_ LPCWSTR pwszItem, REFIID riid, void **ppv) PURE;
};



#if (_WIN32_IE >= 0x0400)

/* ***************** IThumbnailCapture
 * CaptureThumbnail : takes an IHTMLDocument2 and returns a thumbnail of specified
 *                    size as an hbitmap
 */

#undef  INTERFACE
#define INTERFACE   IThumbnailCapture

DECLARE_INTERFACE_IID_(IThumbnailCapture, IUnknown, "4ea39266-7211-409f-b622-f63dbd16c533")
{
    // *** IThumbnailCapture methods ***
    STDMETHOD (CaptureThumbnail)    ( THIS_ const SIZE * pMaxSize,
                                      IUnknown * pHTMLDoc2,
                                      HBITMAP * phbmThumbnail ) PURE;
};
typedef IThumbnailCapture * LPTHUMBNAILCAPTURE;

#endif


#if (NTDDI_VERSION >= NTDDI_WIN2K && NTDDI_VERSION < NTDDI_LONGHORN)

#include <pshpack8.h>

typedef struct _EnumImageStoreDATAtag
{
    WCHAR     szPath[MAX_PATH];
    FILETIME  ftTimeStamp;
} ENUMSHELLIMAGESTOREDATA, * PENUMSHELLIMAGESTOREDATA;

#include <poppack.h>        /* Return to byte packing */

#undef  INTERFACE
#define INTERFACE   IEnumShellImageStore

DECLARE_INTERFACE_IID_( IEnumShellImageStore, IUnknown, "6DFD582B-92E3-11D1-98A3-00C04FB687DA" )
{
    STDMETHOD ( QueryInterface ) ( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    STDMETHOD ( Reset ) ( THIS ) PURE;
    STDMETHOD ( Next ) ( THIS_ ULONG celt, PENUMSHELLIMAGESTOREDATA * prgElt, ULONG * pceltFetched ) PURE;
    STDMETHOD ( Skip ) ( THIS_ ULONG celt ) PURE;
    STDMETHOD ( Clone ) ( THIS_ IEnumShellImageStore ** ppEnum ) PURE;
};

typedef IEnumShellImageStore * LPENUMSHELLIMAGESTORE;


// flags used to determine the capabilities of the storage for the images
#define SHIMSTCAPFLAG_LOCKABLE    0x0001       // does the store require/support locking
#define SHIMSTCAPFLAG_PURGEABLE   0x0002       // does the store require dead items purging externally ?

#undef  INTERFACE
#define INTERFACE   IShellImageStore

// this interface is used to manipulate the Image cache. It can potentially be used
// in a free threaded manner in conjunction with the Lock parameter to Open and close
DECLARE_INTERFACE_IID_( IShellImageStore, IUnknown, "48C8118C-B924-11D1-98D5-00C04FB687DA" )
{
    STDMETHOD ( QueryInterface )( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    // if the lock parameter is used, then all other calls into
    // open and/or create will block until the lock is released.
    STDMETHOD ( Open ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;
    STDMETHOD ( Create ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;

    // if the lock is passed to either of these two methods, it releases the lock
    // once the operation is complete.
    STDMETHOD ( ReleaseLock ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Close ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Commit ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( IsLocked ) ( THIS ) PURE;

    STDMETHOD ( GetMode ) ( THIS_ DWORD * pdwMode ) PURE;
    STDMETHOD ( GetCapabilities ) ( THIS_ DWORD * pdwCapMask ) PURE;

    STDMETHOD ( AddEntry ) ( THIS_ LPCWSTR pszName, const FILETIME * pftTimeStamp, DWORD dwMode, HBITMAP hImage ) PURE;
    STDMETHOD ( GetEntry ) ( THIS_ LPCWSTR pszName, DWORD dwMode, HBITMAP * phImage ) PURE;
    STDMETHOD ( DeleteEntry ) ( THIS_ LPCWSTR pszName ) PURE;
    STDMETHOD ( IsEntryInStore ) ( THIS_ LPCWSTR pszName, FILETIME * pftTimeStamp ) PURE;

    STDMETHOD ( Enum ) ( THIS_ LPENUMSHELLIMAGESTORE * ppEnum ) PURE;
};

typedef IShellImageStore * LPSHELLIMAGESTORE;

#endif  // (NTDDI_VERSION >= NTDDI_WIN2K && NTDDI_VERSION < NTDDI_LONGHORN)

#if (_WIN32_IE >= 0x0400)

////  IShellFolderBand

// Field mask
#define ISFB_MASK_STATE          0x00000001 // TRUE if dwStateMask and dwState is valid
#define ISFB_MASK_BKCOLOR        0x00000002 // TRUE if crBkgnd field is valid
#define ISFB_MASK_VIEWMODE       0x00000004 // TRUE if wViewMode field is valid
#define ISFB_MASK_SHELLFOLDER    0x00000008
#define ISFB_MASK_IDLIST         0x00000010
#define ISFB_MASK_COLORS         0x00000020 // TRUE if crXXXX fields are valid (except bkgnd)

#define ISFB_STATE_DEFAULT       0x00000000
#define ISFB_STATE_DEBOSSED      0x00000001
#define ISFB_STATE_ALLOWRENAME   0x00000002
#define ISFB_STATE_NOSHOWTEXT    0x00000004 // TRUE if _fNoShowText
#define ISFB_STATE_CHANNELBAR    0x00000010 // TRUE if we want NavigateTarget support
#define ISFB_STATE_QLINKSMODE    0x00000020 // TRUE if we want to turn off drag & drop onto content items
#define ISFB_STATE_FULLOPEN      0x00000040 // TRUE if band should maximize when opened
#define ISFB_STATE_NONAMESORT    0x00000080 // TRUE if band should _not_ sort icons by name
#define ISFB_STATE_BTNMINSIZE    0x00000100 // TRUE if band should report min thickness of button

#define ISFBVIEWMODE_SMALLICONS   0x0001
#define ISFBVIEWMODE_LARGEICONS   0x0002
#if (_WIN32_IE < _WIN32_IE_IE70)
#define ISFBVIEWMODE_LOGOS        0x0003
#endif

#include <pshpack8.h>

typedef struct {
    DWORD       dwMask;       // [in] ISFB_MASK mask of valid fields from crBkgnd on
    DWORD       dwStateMask;  // [in] ISFB_STATE mask of dwState bits being set/queried
    DWORD       dwState;      // [in/out] ISFB_STATE bits
    COLORREF    crBkgnd;      // [in/out]
    COLORREF    crBtnLt;      // [in/out]
    COLORREF    crBtnDk;      // [in/out]
    WORD        wViewMode;    // [in/out]
    WORD        wAlign;       // not used (yet)
    IShellFolder * psf;       // [out]
    PIDLIST_ABSOLUTE pidl;      // [out]
} BANDINFOSFB, *PBANDINFOSFB;

#include <poppack.h>        /* Return to byte packing */

#undef INTERFACE
#define INTERFACE IShellFolderBand

DECLARE_INTERFACE_IID_(IShellFolderBand, IUnknown, "7FE80CC8-C247-11d0-B93A-00A0C90312E1")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderBand Methods ***
    STDMETHOD(InitializeSFB)(THIS_ __in_opt IShellFolder *psf, __in_opt PCIDLIST_ABSOLUTE pidl) PURE;
    STDMETHOD(SetBandInfoSFB)(THIS_ __in PBANDINFOSFB pbi) PURE;
    STDMETHOD(GetBandInfoSFB)(THIS_ __inout PBANDINFOSFB pbi) PURE;
};

// Command Target IDs
enum {
    SFBID_PIDLCHANGED,
};

////  IDeskBarClient

#undef  INTERFACE
#define INTERFACE   IDeskBarClient

DECLARE_INTERFACE_IID_(IDeskBarClient, IOleWindow, "EB0FE175-1A3A-11D0-89B3-00A0C90A90AC")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ __out HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDeskBarClient methods ***
    STDMETHOD(SetDeskBarSite) (THIS_ __in_opt IUnknown* punkSite) PURE;
    STDMETHOD(SetModeDBC) (THIS_ DWORD dwMode) PURE;
    STDMETHOD(UIActivateDBC) (THIS_ DWORD dwState) PURE;
    STDMETHOD(GetSize) (THIS_ DWORD dwWhich, __out LPRECT prc) PURE;
};

#define DBC_GS_IDEAL          0  // get the ideal size
#define DBC_GS_SIZEDOWN       1  // clip the height of a rect to a multiple of the rebar's integral size


#define DBC_HIDE        0 // Band is hidden (being destroyed)
#define DBC_SHOW        1 // Band is visible
#define DBC_SHOWOBSCURE 2 // Band is completely obscured


enum {
    DBCID_EMPTY = 0,        // bandsite is empty
    DBCID_ONDRAG = 1,       // (down)DragMoveEnter/Leave vaIn:I4:eDrag
    DBCID_CLSIDOFBAR = 2,   // clsid of bar inside
    DBCID_RESIZE = 3,       // resize from keyboard
    DBCID_GETBAR = 4,       // returns vaOut:VT_UNKNOWN of hosting dockbar (IDeskBar)
};

#endif // _WIN32_IE > 0x0400


#if (_WIN32_IE >= 0x400)
//
// We need to make sure that WININET.H is included before this interface is
// used because the COMPONENT structure uses INTERNET_MAX_URL_LENGTH
//
#ifdef _WININET_
//
//  Flags and structures used by IActiveDesktop
//

typedef struct _tagWALLPAPEROPT
{
    DWORD   dwSize;     // size of this Structure.
    DWORD   dwStyle;    // WPSTYLE_* mentioned above
}
WALLPAPEROPT;

typedef WALLPAPEROPT  *LPWALLPAPEROPT;
typedef const WALLPAPEROPT *LPCWALLPAPEROPT;

typedef struct _tagCOMPONENTSOPT
{
    DWORD   dwSize;             //Size of this structure
    BOOL    fEnableComponents;  //Enable components?
    BOOL    fActiveDesktop;     // Active desktop enabled ?
}
COMPONENTSOPT;

typedef COMPONENTSOPT   *LPCOMPONENTSOPT;
typedef const COMPONENTSOPT   *LPCCOMPONENTSOPT;

typedef struct _tagCOMPPOS
{
    DWORD   dwSize;             //Size of this structure
    int     iLeft;              //Left of top-left corner in screen co-ordinates.
    int     iTop;               //Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    int     izIndex;            // Indicates the Z-order of the component.
    BOOL    fCanResize;         // Is the component resizeable?
    BOOL    fCanResizeX;        // Resizeable in X-direction?
    BOOL    fCanResizeY;        // Resizeable in Y-direction?
    int     iPreferredLeftPercent;    //Left of top-left corner as percent of screen width
    int     iPreferredTopPercent;     //Top of top-left corner as percent of screen height
}
COMPPOS;

typedef COMPPOS *LPCOMPPOS;
typedef const COMPPOS *LPCCOMPPOS;

typedef struct  _tagCOMPSTATEINFO
{
    DWORD   dwSize;             // Size of this structure.
    int     iLeft;              // Left of the top-left corner in screen co-ordinates.
    int     iTop;               // Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    DWORD   dwItemState;        // State of the component (full-screen mode or split-screen or normal state.
}
COMPSTATEINFO;

typedef COMPSTATEINFO   *LPCOMPSTATEINFO;
typedef const COMPSTATEINFO *LPCCOMPSTATEINFO;



#define COMPONENT_TOP (0x3fffffff)  // izOrder value meaning component is at the top


// iCompType values
#define COMP_TYPE_HTMLDOC       0
#define COMP_TYPE_PICTURE       1
#define COMP_TYPE_WEBSITE       2
#define COMP_TYPE_CONTROL       3
#define COMP_TYPE_CFHTML        4
#define COMP_TYPE_MAX           4

// The following is the COMPONENT structure used in IE4.01, IE4.0 and Memphis. It is kept here for compatibility
// reasons.
typedef struct _tagIE4COMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled?
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MAX_URL_LENGTH]; //Subscrined URL
}
IE4COMPONENT;

typedef IE4COMPONENT *LPIE4COMPONENT;
typedef const IE4COMPONENT *LPCIE4COMPONENT;

//
// The following is the new NT5 component structure. Note that the initial portion of this component exactly
// matches the IE4COMPONENT structure. All new fields are added at the bottom and the dwSize field is used to
// distinguish between IE4COMPONENT and the new COMPONENT structures.
//
typedef struct _tagCOMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled?
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MAX_URL_LENGTH]; //Subscrined URL

    //New fields are added below. Everything above here must exactly match the IE4COMPONENT Structure.
    DWORD           dwCurItemState; // Current state of the Component.
    COMPSTATEINFO   csiOriginal;    // Original state of the component when it was first added.
    COMPSTATEINFO   csiRestored;    // Restored state of the component.
}
COMPONENT;

typedef COMPONENT *LPCOMPONENT;
typedef const COMPONENT *LPCCOMPONENT;


// Defines for dwCurItemState
#define IS_NORMAL               0x00000001
#define IS_FULLSCREEN           0x00000002
#define IS_SPLIT                0x00000004
#define IS_VALIDSIZESTATEBITS   (IS_NORMAL | IS_SPLIT | IS_FULLSCREEN)  // The set of IS_* state bits which define the "size" of the component - these bits are mutually exclusive.
#define IS_VALIDSTATEBITS       (IS_NORMAL | IS_SPLIT | IS_FULLSCREEN | 0x80000000 | 0x40000000)  // All of the currently defined IS_* bits.

////////////////////////////////////////////
// Flags for IActiveDesktop::ApplyChanges()
#define AD_APPLY_SAVE             0x00000001
#define AD_APPLY_HTMLGEN          0x00000002
#define AD_APPLY_REFRESH          0x00000004
#define AD_APPLY_ALL              (AD_APPLY_SAVE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH)
#define AD_APPLY_FORCE            0x00000008
#define AD_APPLY_BUFFERED_REFRESH 0x00000010
#define AD_APPLY_DYNAMICREFRESH   0x00000020

////////////////////////////////////////////
// Flags for IActiveDesktop::GetWallpaper()
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define AD_GETWP_BMP            0x00000000
#define AD_GETWP_IMAGE          0x00000001
#define AD_GETWP_LAST_APPLIED   0x00000002
#endif

////////////////////////////////////////////
// Flags for IActiveDesktop::GetWallpaperOptions()
//           IActiveDesktop::SetWallpaperOptions()
#define WPSTYLE_CENTER      0
#define WPSTYLE_TILE        1
#define WPSTYLE_STRETCH     2
#define WPSTYLE_MAX         3


////////////////////////////////////////////
// Flags for IActiveDesktop::ModifyComponent()

#define COMP_ELEM_TYPE          0x00000001
#define COMP_ELEM_CHECKED       0x00000002
#define COMP_ELEM_DIRTY         0x00000004
#define COMP_ELEM_NOSCROLL      0x00000008
#define COMP_ELEM_POS_LEFT      0x00000010
#define COMP_ELEM_POS_TOP       0x00000020
#define COMP_ELEM_SIZE_WIDTH    0x00000040
#define COMP_ELEM_SIZE_HEIGHT   0x00000080
#define COMP_ELEM_POS_ZINDEX    0x00000100
#define COMP_ELEM_SOURCE        0x00000200
#define COMP_ELEM_FRIENDLYNAME  0x00000400
#define COMP_ELEM_SUBSCRIBEDURL 0x00000800
#define COMP_ELEM_ORIGINAL_CSI  0x00001000
#define COMP_ELEM_RESTORED_CSI  0x00002000
#define COMP_ELEM_CURITEMSTATE  0x00004000

#define COMP_ELEM_ALL   (COMP_ELEM_TYPE | COMP_ELEM_CHECKED | COMP_ELEM_DIRTY |                     \
                         COMP_ELEM_NOSCROLL | COMP_ELEM_POS_LEFT | COMP_ELEM_SIZE_WIDTH  |          \
                         COMP_ELEM_SIZE_HEIGHT | COMP_ELEM_POS_ZINDEX | COMP_ELEM_SOURCE |          \
                         COMP_ELEM_FRIENDLYNAME | COMP_ELEM_POS_TOP | COMP_ELEM_SUBSCRIBEDURL |     \
                         COMP_ELEM_ORIGINAL_CSI | COMP_ELEM_RESTORED_CSI | COMP_ELEM_CURITEMSTATE)


////////////////////////////////////////////
// Flags for IActiveDesktop::AddDesktopItemWithUI()
typedef enum tagDTI_ADTIWUI
{
    DTI_ADDUI_DEFAULT               = 0x00000000,
    DTI_ADDUI_DISPSUBWIZARD         = 0x00000001,
    DTI_ADDUI_POSITIONITEM          = 0x00000002,
};


////////////////////////////////////////////
// Flags for IActiveDesktop::AddUrl()
#define ADDURL_SILENT           0X0001


////////////////////////////////////////////
// Default positions for ADI
#define COMPONENT_DEFAULT_LEFT    (0xFFFF)
#define COMPONENT_DEFAULT_TOP     (0xFFFF)




//
//  Interface for manipulating the Active Desktop.
//

#undef INTERFACE
#define INTERFACE IActiveDesktop

DECLARE_INTERFACE_IID_(IActiveDesktop, IUnknown, "f490eb00-1240-11d1-9888-006097deacf9")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktop methods
    STDMETHOD (ApplyChanges)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (GetWallpaper)(THIS_ __out_ecount(cchWallpaper) LPWSTR pwszWallpaper, UINT cchWallpaper, DWORD dwFlags) PURE;
    STDMETHOD (SetWallpaper)(THIS_ LPCWSTR pwszWallpaper, DWORD dwReserved) PURE;
    STDMETHOD (GetWallpaperOptions)(THIS_ __inout LPWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (SetWallpaperOptions)(THIS_ __in LPCWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (GetPattern)(THIS_ __out_ecount(cchPattern) LPWSTR pwszPattern, UINT cchPattern, DWORD dwReserved) PURE;
    STDMETHOD (SetPattern)(THIS_ LPCWSTR pwszPattern, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemOptions)(THIS_ __inout LPCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (SetDesktopItemOptions)(THIS_ __in LPCCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItem)(THIS_ __in LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItemWithUI)(THIS_ HWND hwnd, __in LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (ModifyDesktopItem)(THIS_ __inout LPCCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (RemoveDesktopItem)(THIS_ __in LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemCount)(THIS_ __out LPINT lpiCount, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItem)(THIS_ int nComponent, __inout LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemByID)(THIS_ ULONG_PTR dwID, __inout LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GenerateDesktopItemHtml)(THIS_ LPCWSTR pwszFileName, __in LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddUrl)(THIS_ HWND hwnd, LPCWSTR pszSource, __in LPCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (GetDesktopItemBySource)(THIS_ LPCWSTR pwszSource, __inout LPCOMPONENT pcomp, DWORD dwReserved) PURE;
};

typedef IActiveDesktop * LPACTIVEDESKTOP;

// Flags for SetSafeMode
#define SSM_CLEAR   0x0000
#define SSM_SET     0x0001
#define SSM_REFRESH 0x0002
#define SSM_UPDATE  0x0004

// Flags for Set/GetScheme
#define SCHEME_DISPLAY          0x0001
#define SCHEME_EDIT             0x0002
#define SCHEME_LOCAL            0x0004
#define SCHEME_GLOBAL           0x0008
#define SCHEME_REFRESH          0x0010
#define SCHEME_UPDATE           0x0020
#define SCHEME_DONOTUSE 0x0040 // used to be SCHEME_ENUMERATE; no longer supported
#define SCHEME_CREATE           0x0080

#undef INTERFACE
#define INTERFACE IActiveDesktopP

DECLARE_INTERFACE_IID_(IActiveDesktopP, IUnknown, "52502EE0-EC80-11D0-89AB-00C04FC2972D")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktopP methods
    STDMETHOD (SetSafeMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (EnsureUpdateHTML)(THIS) PURE;
    STDMETHOD (SetScheme)(THIS_ LPCWSTR pwszSchemeName, DWORD dwFlags) PURE;
    STDMETHOD (GetScheme)(THIS_ __out_ecount(*lpdwcchBuffer) LPWSTR pwszSchemeName, __inout DWORD *lpdwcchBuffer, DWORD dwFlags) PURE;
    //
};

typedef IActiveDesktopP * LPACTIVEDESKTOPP;

//Flags for GetObjectFlags
#define GADOF_DIRTY    0x00000001

#undef INTERFACE
#define INTERFACE IADesktopP2

DECLARE_INTERFACE_IID_(IADesktopP2, IUnknown, "B22754E2-4574-11d1-9888-006097DEACF9")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IADesktopP2 methods
    STDMETHOD (ReReadWallpaper)(THIS) PURE;
    STDMETHOD (GetADObjectFlags)(THIS_ __out DWORD *lpdwFlags, DWORD dwMask) PURE;
    STDMETHOD (UpdateAllDesktopSubscriptions)(THIS) PURE;
    STDMETHOD (MakeDynamicChanges)(THIS_ __in IOleObject *pOleObj) PURE;
};

typedef IADesktopP2 * LPADESKTOPP2;


#endif // _WININET_

#if (_WIN32_IE >= 0x0500)

#define MAX_COLUMN_NAME_LEN 80
#define MAX_COLUMN_DESC_LEN 128

#include <pshpack1.h>

typedef struct {
    SHCOLUMNID  scid;                           // OUT the unique identifier of this column
    VARTYPE     vt;                             // OUT the native type of the data returned
    DWORD       fmt;                            // OUT this listview format (LVCFMT_LEFT, usually)
    UINT        cChars;                         // OUT the default width of the column, in characters
    DWORD       csFlags;                        // OUT SHCOLSTATE flags
    WCHAR wszTitle[MAX_COLUMN_NAME_LEN];        // OUT the title of the column
    WCHAR wszDescription[MAX_COLUMN_DESC_LEN];  // OUT full description of this column
} SHCOLUMNINFO, *LPSHCOLUMNINFO;
typedef const SHCOLUMNINFO* LPCSHCOLUMNINFO;

#include <poppack.h>        /* Return to default */

#include <pshpack8.h>

typedef struct {
    ULONG   dwFlags;              // initialization flags
    ULONG   dwReserved;           // reserved for future use.
    WCHAR   wszFolder[MAX_PATH];  // fully qualified folder path (or empty if multiple folders)
} SHCOLUMNINIT, *LPSHCOLUMNINIT;
typedef const SHCOLUMNINIT* LPCSHCOLUMNINIT;

#define SHCDF_UPDATEITEM        0x00000001      // this flag is a hint that the file has changed since the last call to GetItemData

typedef struct {
    ULONG   dwFlags;             // combination of SHCDF_ flags.
    DWORD   dwFileAttributes;    // file attributes.
    ULONG   dwReserved;          // reserved for future use.
    WCHAR*  pwszExt;             // address of file name extension
    WCHAR   wszFile[MAX_PATH];   // Absolute path of file.
} SHCOLUMNDATA, *LPSHCOLUMNDATA;
typedef const SHCOLUMNDATA* LPCSHCOLUMNDATA;

#include <poppack.h>        /* Return to byte packing */

#undef INTERFACE
#define INTERFACE IColumnProvider

// Note: these objects must be threadsafe!  GetItemData _will_ be called
// simultaneously from multiple threads.
DECLARE_INTERFACE_IID_(IColumnProvider, IUnknown, "E8025004-1C42-11d2-BE2C-00A0C9A83DA1")
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IColumnProvider methods
    STDMETHOD (Initialize)(THIS_ LPCSHCOLUMNINIT psci) PURE;
    STDMETHOD (GetColumnInfo)(THIS_ DWORD dwIndex, __out SHCOLUMNINFO *psci) PURE;
    STDMETHOD (GetItemData)(THIS_ LPCSHCOLUMNID pscid, LPCSHCOLUMNDATA pscd, __out VARIANT *pvarData) PURE;
};

#endif // _WIN32_IE >= 0x0500
#endif // _WIN32_IE

//==========================================================================
// Clipboard format which may be supported by IDataObject from system
// defined shell folders (such as directories, network, ...).
//==========================================================================

#define CFSTR_SHELLIDLIST                   TEXT("Shell IDList Array")                  // CF_IDLIST
#define CFSTR_SHELLIDLISTOFFSET             TEXT("Shell Object Offsets")                // CF_OBJECTPOSITIONS
#define CFSTR_NETRESOURCES                  TEXT("Net Resource")                        // CF_NETRESOURCE
#define CFSTR_FILEDESCRIPTORA               TEXT("FileGroupDescriptor")                 // CF_FILEGROUPDESCRIPTORA
#define CFSTR_FILEDESCRIPTORW               TEXT("FileGroupDescriptorW")                // CF_FILEGROUPDESCRIPTORW
#define CFSTR_FILECONTENTS                  TEXT("FileContents")                        // CF_FILECONTENTS
#define CFSTR_FILENAMEA                     TEXT("FileName")                            // CF_FILENAMEA
#define CFSTR_FILENAMEW                     TEXT("FileNameW")                           // CF_FILENAMEW
#define CFSTR_PRINTERGROUP                  TEXT("PrinterFriendlyName")                 // CF_PRINTERS
#define CFSTR_FILENAMEMAPA                  TEXT("FileNameMap")                         // CF_FILENAMEMAPA
#define CFSTR_FILENAMEMAPW                  TEXT("FileNameMapW")                        // CF_FILENAMEMAPW
#define CFSTR_SHELLURL                      TEXT("UniformResourceLocator")
#define CFSTR_INETURLA                      CFSTR_SHELLURL
#define CFSTR_INETURLW                      TEXT("UniformResourceLocatorW")
#define CFSTR_PREFERREDDROPEFFECT           TEXT("Preferred DropEffect")
#define CFSTR_PERFORMEDDROPEFFECT           TEXT("Performed DropEffect")
#define CFSTR_PASTESUCCEEDED                TEXT("Paste Succeeded")
#define CFSTR_INDRAGLOOP                    TEXT("InShellDragLoop")
#define CFSTR_MOUNTEDVOLUME                 TEXT("MountedVolume")
#define CFSTR_PERSISTEDDATAOBJECT           TEXT("PersistedDataObject")
#define CFSTR_TARGETCLSID                   TEXT("TargetCLSID")                         // HGLOBAL with a CLSID of the drop target
#define CFSTR_LOGICALPERFORMEDDROPEFFECT    TEXT("Logical Performed DropEffect")
#define CFSTR_AUTOPLAY_SHELLIDLISTS         TEXT("Autoplay Enumerated IDList Array")    // (HGLOBAL with LPIDA)
#define CFSTR_UNTRUSTEDDRAGDROP             TEXT("UntrustedDragDrop")                   //  DWORD
#define CFSTR_FILE_ATTRIBUTES_ARRAY         TEXT("File Attributes Array")               // (FILE_ATTRIBUTES_ARRAY format on HGLOBAL)
#define CFSTR_INVOKECOMMAND_DROPPARAM       TEXT("InvokeCommand DropParam")             // (HGLOBAL with LPWSTR)
#define CFSTR_SHELLDROPHANDLER              TEXT("DropHandlerCLSID")                    // (HGLOBAL with CLSID of drop handler)
#define CFSTR_DROPDESCRIPTION               TEXT("DropDescription")                     // (HGLOBAL with DROPDESCRIPTION)

#ifdef UNICODE
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORW
#define CFSTR_FILENAME          CFSTR_FILENAMEW
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPW
#define CFSTR_INETURL           CFSTR_INETURLW
#else
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORA
#define CFSTR_FILENAME          CFSTR_FILENAMEA
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPA
#define CFSTR_INETURL           CFSTR_INETURLA
#endif

#define DVASPECT_SHORTNAME      2 // use for CF_HDROP to get short name version of file paths
#define DVASPECT_COPY           3 // use to indicate format is a "Copy" of the data (FILECONTENTS, FILEDESCRIPTOR, etc)
#define DVASPECT_LINK           4 // use to indicate format is a "Shortcut" to the data (FILECONTENTS, FILEDESCRIPTOR, etc)

#include <pshpack8.h>

/*
// #ifndef IEMOBILE
//
// format of CF_NETRESOURCE
//
typedef struct _NRESARRAY {     // anr
    UINT cItems;
    NETRESOURCE nr[1];
} NRESARRAY, * LPNRESARRAY;
#endif // // #ifndef IEMOBILE
*/

#include <poppack.h>        /* Return to byte packing */

//
// format of CF_IDLIST
//
typedef struct _IDA {
    UINT cidl;          // number of relative IDList
    UINT aoffset[1];    // [0]: folder IDList, [1]-[cidl]: item IDList
} CIDA, * LPIDA;

//
// FILEDESCRIPTOR.dwFlags field indicate which fields are valid in the FILEDESCRIPTOR struct
//
typedef enum {
    FD_CLSID            = 0x00000001,
    FD_SIZEPOINT        = 0x00000002,
    FD_ATTRIBUTES       = 0x00000004,
    FD_CREATETIME       = 0x00000008,
    FD_ACCESSTIME       = 0x00000010,
    FD_WRITESTIME       = 0x00000020,
    FD_FILESIZE         = 0x00000040,
    FD_PROGRESSUI       = 0x00004000,       // Show Progress UI w/Drag and Drop
    FD_LINKUI           = 0x00008000,       // 'link' UI is prefered
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
    FD_UNICODE          = 0x80000000,       // this descriptor is UNICODE
#endif
} FD_FLAGS;

typedef struct _FILEDESCRIPTORA {
    DWORD dwFlags;
    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    CHAR   cFileName[ MAX_PATH ];
} FILEDESCRIPTORA, *LPFILEDESCRIPTORA;

typedef struct _FILEDESCRIPTORW {
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    WCHAR  cFileName[ MAX_PATH ];
} FILEDESCRIPTORW, *LPFILEDESCRIPTORW;

#ifdef UNICODE
#define FILEDESCRIPTOR      FILEDESCRIPTORW
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORW
#else
#define FILEDESCRIPTOR      FILEDESCRIPTORA
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORA
#endif

//
// format of CF_FILEGROUPDESCRIPTOR
//
typedef struct _FILEGROUPDESCRIPTORA { // fgd
     UINT cItems;
     FILEDESCRIPTORA fgd[1];
} FILEGROUPDESCRIPTORA, * LPFILEGROUPDESCRIPTORA;

typedef struct _FILEGROUPDESCRIPTORW { // fgd
     UINT cItems;
     FILEDESCRIPTORW fgd[1];
} FILEGROUPDESCRIPTORW, * LPFILEGROUPDESCRIPTORW;

#ifdef UNICODE
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORW
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORW
#else
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORA
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORA
#endif

//
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
//
typedef struct _DROPFILES {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point (client coords)
   BOOL fNC;                           // is it on NonClient area
                                       // and pt is in screen coords
   BOOL fWide;                         // WIDE character switch
} DROPFILES, *LPDROPFILES;


#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef struct
{
    UINT cItems;                    // number of items in rgdwFileAttributes array
    DWORD dwSumFileAttributes;      // all of the attributes ORed together
    DWORD dwProductFileAttributes;  // all of the attributes ANDed together
    DWORD rgdwFileAttributes[1];    // array
} FILE_ATTRIBUTES_ARRAY;            // clipboard format definition for CFSTR_FILE_ATTRIBUTES_ARRAY
#endif


#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef enum
{
    DROPIMAGE_INVALID             = -1,                // no drop image at all
    DROPIMAGE_NONE                = 0,                 // red "no" circle
    DROPIMAGE_COPY                = DROPEFFECT_COPY,   // plus for copy
    DROPIMAGE_MOVE                = DROPEFFECT_MOVE,   // movement arrow for move
    DROPIMAGE_LINK                = DROPEFFECT_LINK,   // link arrow for link
    DROPIMAGE_LABEL               = 6,                 // tag icon to indicate metadata will be changed
    DROPIMAGE_WARNING             = 7,                 // yellow exclamation, something is amiss with the operation
} DROPIMAGETYPE;

typedef struct
{
    DROPIMAGETYPE type;                 // indicates the stock image to use

// text such as "Move to %1"
    WCHAR szMessage[MAX_PATH];

// text such as "Documents", inserted as specified by szMessage
    WCHAR szInsert[MAX_PATH];

// some UI coloring is applied to the text in szInsert, if used by specifying %1 in szMessage.
// %% and %1 are the subset of FormatMessage markers that are processed here.
} DROPDESCRIPTION;

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN)


//====== File System Notification APIs ===============================
//
typedef struct _SHChangeNotifyEntry
{
    PCIDLIST_ABSOLUTE pidl;
    BOOL   fRecursive;
} SHChangeNotifyEntry;


//
//  File System Notification flags
//

#define SHCNRF_InterruptLevel      0x0001
#define SHCNRF_ShellLevel          0x0002
#define SHCNRF_RecursiveInterrupt  0x1000
#define SHCNRF_NewDelivery         0x8000

#define SHCNE_RENAMEITEM          0x00000001L
#define SHCNE_CREATE              0x00000002L
#define SHCNE_DELETE              0x00000004L
#define SHCNE_MKDIR               0x00000008L
#define SHCNE_RMDIR               0x00000010L
#define SHCNE_MEDIAINSERTED       0x00000020L
#define SHCNE_MEDIAREMOVED        0x00000040L
#define SHCNE_DRIVEREMOVED        0x00000080L
#define SHCNE_DRIVEADD            0x00000100L
#define SHCNE_NETSHARE            0x00000200L
#define SHCNE_NETUNSHARE          0x00000400L
#define SHCNE_ATTRIBUTES          0x00000800L
#define SHCNE_UPDATEDIR           0x00001000L
#define SHCNE_UPDATEITEM          0x00002000L
#define SHCNE_SERVERDISCONNECT    0x00004000L
#define SHCNE_UPDATEIMAGE         0x00008000L
#define SHCNE_DRIVEADDGUI         0x00010000L
#define SHCNE_RENAMEFOLDER        0x00020000L
#define SHCNE_FREESPACE           0x00040000L

#if (_WIN32_IE >= 0x0400)
// SHCNE_EXTENDED_EVENT: the extended event is identified in dwItem1,
// packed in LPITEMIDLIST format (same as SHCNF_DWORD packing).
// Additional information can be passed in the dwItem2 parameter
// of SHChangeNotify (called "pidl2" below), which if present, must also
// be in LPITEMIDLIST format.
//
// Unlike the standard events, the extended events are ORDINALs, so we
// don't run out of bits.  Extended events follow the SHCNEE_* naming
// convention.
//
// The dwItem2 parameter varies according to the extended event.

#define SHCNE_EXTENDED_EVENT      0x04000000L
#endif      // _WIN32_IE >= 0x0400

#define SHCNE_ASSOCCHANGED        0x08000000L

#define SHCNE_DISKEVENTS          0x0002381FL
#define SHCNE_GLOBALEVENTS        0x0C0581E0L // Events that dont match pidls first
#define SHCNE_ALLEVENTS           0x7FFFFFFFL
#define SHCNE_INTERRUPT           0x80000000L // The presence of this flag indicates
                                            // that the event was generated by an
                                            // interrupt.  It is stripped out before
                                            // the clients of SHCNNotify_ see it.

#if (_WIN32_IE >= 0x0400)
// SHCNE_EXTENDED_EVENT extended events.  These events are ordinals.
// This is not a bitfield.

#define SHCNEE_ORDERCHANGED         2L  // pidl2 is the changed folder
#define SHCNEE_MSI_CHANGE           4L  // pidl2 is a SHChangeProductKeyAsIDList
#define SHCNEE_MSI_UNINSTALL        5L  // pidl2 is a SHChangeProductKeyAsIDList
#endif

// Flags
// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean
#define SHCNF_IDLIST      0x0000        // LPITEMIDLIST
#define SHCNF_PATHA       0x0001        // path name
#define SHCNF_PRINTERA    0x0002        // printer friendly name
#define SHCNF_DWORD       0x0003        // DWORD
#define SHCNF_PATHW       0x0005        // path name
#define SHCNF_PRINTERW    0x0006        // printer friendly name
#define SHCNF_TYPE        0x00FF
#define SHCNF_FLUSH       0x1000
#define SHCNF_FLUSHNOWAIT 0x2000

#define SHCNF_NOTIFYRECURSIVE      0x10000 // Notify clients registered for any child


#ifdef UNICODE
   #define SHCNF_PATH      SHCNF_PATHW
   #define SHCNF_PRINTER   SHCNF_PRINTERW
#else
   #define SHCNF_PATH      SHCNF_PATHA
   #define SHCNF_PRINTER   SHCNF_PRINTERA
#endif

//
//  APIs
//
SHSTDAPI_(void) SHChangeNotify(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);

//
// IShellChangeNotify
//
#undef  INTERFACE
#define INTERFACE  IShellChangeNotify

DECLARE_INTERFACE_IID_(IShellChangeNotify, IUnknown, "D82BE2B1-5764-11D0-A96E-00C04FD705A2")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellChangeNotify methods ***
    STDMETHOD(OnChange) (THIS_ LONG lEvent, PCIDLIST_ABSOLUTE pidl1, PCIDLIST_ABSOLUTE pidl2) PURE;
} ;

//
// IQueryInfo
//
//-------------------------------------------------------------------------
//
// IQueryInfo interface
//
// [Methods]
//              ::GetInfoTip()
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE  IQueryInfo

DECLARE_INTERFACE_IID_(IQueryInfo, IUnknown, "00021500-0000-0000-c000-000000000046")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IQueryInfo methods ***
    STDMETHOD(GetInfoTip)(THIS_ DWORD dwFlags, __out WCHAR **ppwszTip) PURE;
    STDMETHOD(GetInfoFlags)(THIS_ __out DWORD *pdwFlags) PURE;
} ;

#define QITIPF_DEFAULT          0x00000000
#define QITIPF_USENAME          0x00000001
#define QITIPF_LINKNOTARGET     0x00000002
#define QITIPF_LINKUSETARGET    0x00000004
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define QITIPF_USESLOWTIP       0x00000008  // Flag says it's OK to take a long time generating tip
#endif
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define QITIPF_SINGLELINE       0x00000010
#endif

#define QIF_CACHED              0x00000001
#define QIF_DONTEXPANDFOLDER    0x00000002


/*
// #ifndef IEMOBILE
//
// SHAddToRecentDocs
//
#define SHARD_PIDL      0x00000001L
#define SHARD_PATHA     0x00000002L
#define SHARD_PATHW     0x00000003L

#ifdef UNICODE
#define SHARD_PATH  SHARD_PATHW
#else
#define SHARD_PATH  SHARD_PATHA
#endif

SHSTDAPI_(void) SHAddToRecentDocs(UINT uFlags, LPCVOID pv);
// # endif // #ifndef IEMOBILE
*/

typedef struct _SHChangeDWORDAsIDList {
    USHORT   cb;
    DWORD    dwItem1;
    DWORD    dwItem2;
    USHORT   cbZero;
} SHChangeDWORDAsIDList, *LPSHChangeDWORDAsIDList;


#if (NTDDI_VERSION >= NTDDI_WIN2K)


typedef struct _SHChangeUpdateImageIDList {
    USHORT cb;
    int iIconIndex;
    int iCurIndex;
    UINT uFlags;
    DWORD dwProcessID;
    WCHAR szName[MAX_PATH];
    USHORT cbZero;
} SHChangeUpdateImageIDList, * LPSHChangeUpdateImageIDList;
SHSTDAPI_(int) SHHandleUpdateImage(PCIDLIST_ABSOLUTE pidlExtra);


typedef struct _SHChangeProductKeyAsIDList {
    USHORT cb;
    WCHAR wszProductKey[39];
    USHORT cbZero;
} SHChangeProductKeyAsIDList, *LPSHChangeProductKeyAsIDList;


SHSTDAPI_(void) SHUpdateImageA(LPCSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex);
SHSTDAPI_(void) SHUpdateImageW(LPCWSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex);
#ifdef UNICODE
#define SHUpdateImage  SHUpdateImageW
#else
#define SHUpdateImage  SHUpdateImageA
#endif // !UNICODE
#endif /* NTDDI_WIN2K */

/*
// #ifndef IEMOBILE
SHSTDAPI_(ULONG) SHChangeNotifyRegister(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, const SHChangeNotifyEntry *pshcne);
SHSTDAPI_(BOOL) SHChangeNotifyDeregister(unsigned long ulID);
// #endif // #ifndef IEMOBILE
*/

typedef enum
{
    SCNRT_ENABLE  = 0,
    SCNRT_DISABLE = 1,
} SCNRT_STATUS;

//  use SHChangeNotifyRegisterThread() to enable Async Register and Deregister.
//  call with SCNRT_ENABLE at the thread proc begining and SCNRT_DISABLE at the end
//  the call with SCNRT_DISABLE can block while it synchronizes with the main ChangeNotify thread
STDAPI_(void) SHChangeNotifyRegisterThread(SCNRT_STATUS status);

SHSTDAPI_(HANDLE) SHChangeNotification_Lock(HANDLE hChange, DWORD dwProcId, __deref_opt_out_ecount(2) PIDLIST_ABSOLUTE **pppidl, __out_opt LONG *plEvent);
SHSTDAPI_(BOOL) SHChangeNotification_Unlock(HANDLE hLock);
#if (_WIN32_IE >= 0x0400)
// The pidls that are given to the view via the ChangeNotifyEvents are simple Pidls,
// SHGetRealIDL() will convert them to true PIDLs.
SHSTDAPI SHGetRealIDL(IShellFolder *psf, PCUITEMID_CHILD pidlSimple, __out PITEMID_CHILD *ppidlReal);
#endif // _WIN32_IE >= 0x0400


SHSTDAPI SHGetInstanceExplorer(__out IUnknown **ppunk);

//
// SHGetDataFromIDListA/W
//
// SHGetDataFromIDList nFormat values TCHAR
#define SHGDFIL_FINDDATA        1
#define SHGDFIL_NETRESOURCE     2
#define SHGDFIL_DESCRIPTIONID   3

#define SHDID_ROOT_REGITEM          1
#define SHDID_FS_FILE               2
#define SHDID_FS_DIRECTORY          3
#define SHDID_FS_OTHER              4
#define SHDID_COMPUTER_DRIVE35      5
#define SHDID_COMPUTER_DRIVE525     6
#define SHDID_COMPUTER_REMOVABLE    7
#define SHDID_COMPUTER_FIXED        8
#define SHDID_COMPUTER_NETDRIVE     9
#define SHDID_COMPUTER_CDROM        10
#define SHDID_COMPUTER_RAMDISK      11
#define SHDID_COMPUTER_OTHER        12
#define SHDID_NET_DOMAIN            13
#define SHDID_NET_SERVER            14
#define SHDID_NET_SHARE             15
#define SHDID_NET_RESTOFNET         16
#define SHDID_NET_OTHER             17
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define SHDID_COMPUTER_IMAGING      18
#define SHDID_COMPUTER_AUDIO        19
#define SHDID_COMPUTER_SHAREDDOCS   20
#endif
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define SHDID_MOBILE_DEVICE         21  // PDA/PalmPC
#endif

#include <pshpack8.h>

typedef struct _SHDESCRIPTIONID {
    DWORD   dwDescriptionId;
    CLSID   clsid;
} SHDESCRIPTIONID, *LPSHDESCRIPTIONID;

#include <poppack.h>        /* Return to byte packing */

// these delegate to IShellFolder2::GetDetailsEx()

SHSTDAPI SHGetDataFromIDListA(IShellFolder *psf, PCUITEMID_CHILD pidl, int nFormat, __out_bcount(cb) void *pv, int cb);
SHSTDAPI SHGetDataFromIDListW(IShellFolder *psf, PCUITEMID_CHILD pidl, int nFormat, __out_bcount(cb) void *pv, int cb);
#ifdef UNICODE
#define SHGetDataFromIDList  SHGetDataFromIDListW
#else
#define SHGetDataFromIDList  SHGetDataFromIDListA
#endif // !UNICODE


//===========================================================================

// PathResolve flags
#define PRF_VERIFYEXISTS            0x0001
#define PRF_TRYPROGRAMEXTENSIONS    (0x0002 | PRF_VERIFYEXISTS)
#define PRF_FIRSTDIRDEF             0x0004
#define PRF_DONTFINDLNK             0x0008      // if PRF_TRYPROGRAMEXTENSIONS is specified
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
#define PRF_REQUIREABSOLUTE         0x0010
#endif

SHSTDAPI_(int) RestartDialog(HWND hwnd, LPCWSTR lpPrompt, DWORD dwReturn);
#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI_(int) RestartDialogEx(HWND hwnd, LPCWSTR lpPrompt, DWORD dwReturn, DWORD dwReasonCode);
#endif

SHSTDAPI SHCoCreateInstance(__in_opt LPCWSTR pszCLSID, __in_opt const CLSID *pclsid, __in_opt IUnknown *pUnkOuter, __in REFIID riid, __deref_out void **ppv);

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
SHSTDAPI SHCreateDataObject(__in PCIDLIST_ABSOLUTE pidlFolder, UINT cidl, __in_ecount_opt(cidl) PCUITEMID_CHILD_ARRAY apidl, __in_opt IDataObject *pdtInner, REFIID riid, __deref_out void **ppv);
#endif
SHSTDAPI CIDLData_CreateFromIDArray(__in PCIDLIST_ABSOLUTE pidlFolder, UINT cidl, __in_ecount_opt(cidl) PCUIDLIST_RELATIVE_ARRAY apidl, __out IDataObject **ppdtobj);
SHSTDAPI SHCreateStdEnumFmtEtc(UINT cfmt, __in_ecount(cfmt) const FORMATETC afmt[], __out IEnumFORMATETC **ppenumFormatEtc);
SHSTDAPI SHDoDragDrop(HWND hwnd, IDataObject *pdata, IDropSource *pdsrc, DWORD dwEffect, __out DWORD *pdwEffect);
// stuff for doing auto scrolling
#define NUM_POINTS      3
typedef struct {        // asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

SHSTDAPI_(BOOL) DAD_SetDragImage(HIMAGELIST him, POINT * pptOffset);
SHSTDAPI_(BOOL) DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart);
SHSTDAPI_(BOOL) DAD_DragEnterEx2(HWND hwndTarget, const POINT ptStart, IDataObject *pdtObject);
SHSTDAPI_(BOOL) DAD_ShowDragImage(BOOL fShow);
SHSTDAPI_(BOOL) DAD_DragMove(POINT pt);
SHSTDAPI_(BOOL) DAD_DragLeave(void);
SHSTDAPI_(BOOL) DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
typedef struct {
    WORD cLength;
    WORD nVersion;

    BOOL fFullPathTitle            : 1;
    BOOL fSaveLocalView            : 1;
    BOOL fNotShell                 : 1;
    BOOL fSimpleDefault            : 1;
    BOOL fDontShowDescBar          : 1;
    BOOL fNewWindowMode            : 1;
    BOOL fShowCompColor            : 1;  // NT: Show compressed volumes in a different colour
    BOOL fDontPrettyNames          : 1;  // NT: Do 8.3 name conversion, or not!
    BOOL fAdminsCreateCommonGroups : 1;  // NT: Administrators create comon groups
    UINT fUnusedFlags : 7;

    UINT fMenuEnumFilter;

} CABINETSTATE, * LPCABINETSTATE;

#define CABINETSTATE_VERSION 2

// APIs for reading and writing the cabinet state.
SHSTDAPI_(BOOL) ReadCabinetState(__out_bcount(cLength) CABINETSTATE *pcs, int cLength);
SHSTDAPI_(BOOL) WriteCabinetState(__in CABINETSTATE *pcs);
#ifndef UNDER_CE // #ifndef IEMOBILE
SHSTDAPI_(BOOL) PathMakeUniqueName(__out_ecount(cchMax) LPWSTR pszUniqueName, UINT cchMax, LPCWSTR pszTemplate, LPCWSTR pszLongPlate, LPCWSTR pszDir);
SHSTDAPI_(void) PathQualify(__inout LPWSTR psz);
SHSTDAPI_(BOOL) PathIsExe(LPCWSTR pszPath);
SHSTDAPI_(BOOL) PathIsSlowA(LPCSTR pszFile, DWORD dwAttr);
SHSTDAPI_(BOOL) PathIsSlowW(LPCWSTR pszFile, DWORD dwAttr);
#ifdef UNICODE
#define PathIsSlow  PathIsSlowW
#else
#define PathIsSlow  PathIsSlowA
#endif // !UNICODE
#endif // UNDER_CE
//
//  Return codes from PathCleanupSpec.  Negative return values are
//  unrecoverable errors
//
#define PCS_FATAL           0x80000000
#define PCS_REPLACEDCHAR    0x00000001
#define PCS_REMOVEDCHAR     0x00000002
#define PCS_TRUNCATED       0x00000004
#define PCS_PATHTOOLONG     0x00000008  // Always combined with FATAL

SHSTDAPI_(int) PathCleanupSpec(LPCWSTR pszDir, __inout LPWSTR pszSpec);
SHSTDAPI_(int) PathResolve(__out_ecount(MAX_PATH) LPWSTR lpszPath, __in_opt __nullterminated LPCWSTR dirs[], UINT fFlags);
SHSTDAPI_(BOOL) GetFileNameFromBrowse(HWND hwnd, __inout_ecount(cchFilePath) LPWSTR pszFilePath, UINT cchFilePath,
                                      LPCWSTR pszWorkingDir, LPCWSTR pszDefExt, LPCWSTR pszFilters, LPCWSTR pszTitle);
SHSTDAPI_(int) DriveType(int iDrive);

SHSTDAPI_(int) RealDriveType(int iDrive, BOOL fOKToHitNet);
SHSTDAPI_(int) IsNetDrive(int iDrive);

// Flags for Shell_MergeMenus
#define MM_ADDSEPARATOR         0x00000001L
#define MM_SUBMENUSHAVEIDS      0x00000002L
#define MM_DONTREMOVESEPS       0x00000004L


/*
// #ifndef IEMOBILE
SHSTDAPI_(UINT) Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);
// #endif // #ifndef IEMOBILE
*/


/*
 * The SHObjectProperties API provides an easy way to invoke the Properties
 *   context menu command on a subset of the shell item namespace.
 *
 *   PARAMETERS
 *
 *     hwnd              The window handle of the window which will own the dialog
 *     shopObjectType    A SHOP_ value as defined below
 *     pszObjectName     Name of the object, see SHOP_ values below
 *     pszPropertyPage   The name of the property sheet page to open to or NULL.
 *
 *   RETURN
 *
 *     TRUE if the Properties command was invoked
 */
SHSTDAPI_(BOOL) SHObjectProperties(__in_opt HWND hwnd, __in DWORD shopObjectType, __in PCWSTR pszObjectName, __in_opt PCWSTR pszPropertyPage);

#define SHOP_PRINTERNAME 0x00000001  // pszObjectName points to a printer friendly name
#define SHOP_FILEPATH    0x00000002  // pszObjectName points to a fully qualified path+file name
#define SHOP_VOLUMEGUID  0x00000004  // pszObjectName points to a Volume GUID


/*
 * The SHFormatDrive API provides access to the Shell
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that the Shell does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *               NOTE that unlike SHCheckDrive, hwnd == NULL does not cause
 *               this dialog to come up as a "top level application" window.
 *               This parameter should always be non-null, this dialog is
 *               only designed to be the child of another window, not a
 *               stand-alone application.
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *               NOTE: The special value SHFMT_ID_DEFAULT means "use the
 *                     default format specified by the DMaint_FormatDrive
 *                     engine". If you want to FORCE a particular format
 *                     ID "up front" you will have to call
 *                     DMaint_GetFormatOptions yourself before calling
 *                     this to obtain the valid list of phys format IDs
 *                     (contents of the PhysFmtIDList array in the
 *                     FMTINFOSTRUCT).
 *     options = There is currently only two option bits defined
 *
 *                SHFMT_OPT_FULL
 *                SHFMT_OPT_SYSONLY
 *
 *               The normal defualt in the Shell format dialog is
 *               "Quick Format", setting this option bit indicates that
 *               the caller wants to start with FULL format selected
 *               (this is useful for folks detecting "unformatted" disks
 *               and wanting to bring up the format dialog).
 *
 *               The SHFMT_OPT_SYSONLY initializes the dialog to
 *               default to just sys the disk.
 *
 *               All other bits are reserved for future expansion and
 *               must be 0.
 *
 *               Please note that this is a bit field and not a value
 *               and treat it accordingly.
 *
 *   RETURN
 *      The return is either one of the SHFMT_* values, or if the
 *      returned DWORD value is not == to one of these values, then
 *      the return is the physical format ID of the last succesful
 *      format. The LOWORD of this value can be passed on subsequent
 *      calls as the fmtID parameter to "format the same type you did
 *      last time".
 *
 */
SHSTDAPI_(DWORD) SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options);

//
// Special value of fmtID which means "use the default format"
//
#define SHFMT_ID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define SHFMT_OPT_FULL     0x0001
#define SHFMT_OPT_SYSONLY  0x0002

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define SHFMT_ERROR     0xFFFFFFFFL     // Error on last format, drive may be formatable
#define SHFMT_CANCEL    0xFFFFFFFEL     // Last format was canceled
#define SHFMT_NOFORMAT  0xFFFFFFFDL     // Drive is not formatable

#ifndef HPSXA_DEFINED
#define HPSXA_DEFINED
DECLARE_HANDLE( HPSXA );
#endif
WINSHELLAPI HPSXA WINAPI SHCreatePropSheetExtArray( HKEY hKey, LPCWSTR pszSubKey, UINT max_iface );
WINSHELLAPI void WINAPI SHDestroyPropSheetExtArray(__in HPSXA hpsxa );
WINSHELLAPI UINT WINAPI SHAddFromPropSheetExtArray(__in HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT WINAPI SHReplaceFromPropSheetExtArray(__in HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );

SHSTDAPI_(PIDLIST_RELATIVE)     ILClone(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(PITEMID_CHILD)        ILCloneFirst(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(PIDLIST_ABSOLUTE)     ILCombine(__in PCIDLIST_ABSOLUTE pidl1, __in PCUIDLIST_RELATIVE pidl2);
#ifdef UNDER_CE // CE shell IDList fix
SHSTDAPI_(void)                 ILFree(__in_opt PCIDLIST_RELATIVE pidl);
#else
SHSTDAPI_(void)                 ILFree(__in_opt PIDLIST_RELATIVE pidl);
#endif
SHSTDAPI_(PUIDLIST_RELATIVE)    ILGetNext(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(UINT)                 ILGetSize(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(PUIDLIST_RELATIVE)    ILFindChild(__in PCIDLIST_ABSOLUTE pidlParent, __in PCIDLIST_ABSOLUTE pidlChild);
SHSTDAPI_(__out PUITEMID_CHILD) ILFindLastID(__in PCUIDLIST_RELATIVE pidl);
SHSTDAPI_(BOOL)                 ILRemoveLastID(__inout PUIDLIST_RELATIVE pidl);
SHSTDAPI_(BOOL)                 ILIsEqual(__in PCIDLIST_ABSOLUTE pidl1, __in PCIDLIST_ABSOLUTE pidl2);
SHSTDAPI_(BOOL)                 ILIsParent(__in PCIDLIST_ABSOLUTE pidl1, __in PCIDLIST_ABSOLUTE pidl2, BOOL fImmediate);
SHSTDAPI                        ILSaveToStream(__in IStream *pstm, __in PCUIDLIST_RELATIVE pidl);
// #ifndef IEMOBILE
// DECLSPEC_DEPRECATED SHSTDAPI    ILLoadFromStream(__in IStream *pstm, __inout PIDLIST_RELATIVE *pidl);
// #endif // #ifndef IEMOBILE
SHSTDAPI                        ILLoadFromStreamEx(__in IStream *pstm, __deref_out PIDLIST_RELATIVE *pidl);

#if (_WIN32_IE >= 0x0400)

SHSTDAPI_(PIDLIST_ABSOLUTE)     ILCreateFromPathA(LPCSTR pszPath);
SHSTDAPI_(PIDLIST_ABSOLUTE)     ILCreateFromPathW(LPCWSTR pszPath);

#ifdef NO_WRAPPERS_FOR_ILCREATEFROMPATH
SHSTDAPI_(PIDLIST_ABSOLUTE)     ILCreateFromPath(LPCTSTR pszPath);
#else
#ifdef UNICODE
#define ILCreateFromPath        ILCreateFromPathW
#else
#define ILCreateFromPath        ILCreateFromPathA
#endif  // !UNICODE
#endif  // NO_WRAPPERS_FOR_ILCREATEFROMPATH

#endif  // (_WIN32_IE >= 0x0400)

SHSTDAPI SHILCreateFromPath(LPCWSTR pszPath, __out PIDLIST_ABSOLUTE *ppidl, __inout_opt DWORD *rgfInOut);


#define VOID_OFFSET(pv, cb)     ((void*)(((BYTE*)(pv))+(cb)))

#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)

} // extern "C"

inline PIDLIST_ABSOLUTE ILCloneFull(__in PCUIDLIST_ABSOLUTE pidl) { return reinterpret_cast<PIDLIST_ABSOLUTE>(ILClone(pidl)); }
inline PITEMID_CHILD    ILCloneChild(__in PCUITEMID_CHILD pidl)   { return ILCloneFirst(pidl); }

inline HRESULT ILLoadFromStreamEx(__in IStream *pstm, __deref_out PIDLIST_ABSOLUTE *ppidl) { return ILLoadFromStreamEx(pstm, reinterpret_cast<PIDLIST_RELATIVE*>(ppidl)); }
inline HRESULT ILLoadFromStreamEx(__in IStream *pstm, __deref_out PITEMID_CHILD *ppidl)    { return ILLoadFromStreamEx(pstm, reinterpret_cast<PIDLIST_RELATIVE*>(ppidl)); }

inline PCUIDLIST_RELATIVE ILSkip(__in PCUIDLIST_RELATIVE pidl, UINT cb) { return reinterpret_cast<PCUIDLIST_RELATIVE>(VOID_OFFSET(pidl, cb)); }
inline PUIDLIST_RELATIVE  ILSkip(__in PUIDLIST_RELATIVE  pidl, UINT cb) { return const_cast<PUIDLIST_RELATIVE>(ILSkip(const_cast<PCUIDLIST_RELATIVE>(pidl), cb)); }

#ifndef UNDER_CE
inline PCUIDLIST_RELATIVE ILNext(__in PCUIDLIST_RELATIVE pidl) { return ILSkip(pidl, pidl->mkid.cb); }
inline PUIDLIST_RELATIVE  ILNext(__in PUIDLIST_RELATIVE  pidl) { return const_cast<PUIDLIST_RELATIVE>(ILNext(const_cast<PCUIDLIST_RELATIVE>(pidl))); }
#else
// ceshell implements this differently
SHSTDAPI_(PCUIDLIST_RELATIVE) ILNext(__in PCUIDLIST_RELATIVE pidl);
#endif

inline BOOL ILIsAligned(__in PCUIDLIST_RELATIVE pidl)       { return (((DWORD_PTR)(pidl) & (sizeof(void*) - 1)) == 0); }

inline BOOL ILIsEmpty(__in_opt PCUIDLIST_RELATIVE pidl)     { return ((pidl == NULL) || (pidl->mkid.cb==0)); }

// ILIsChild does not guarantee that pidl is non-null or non-empty.
inline BOOL ILIsChild(__in_opt PCUIDLIST_RELATIVE pidl)         { return (ILIsEmpty(pidl) || ILIsEmpty(ILNext(pidl))); }

extern "C" {

#else // !defined(STRICT_TYPED_ITEMIDS) || !defined(__cplusplus)

#define ILCloneFull             ILClone
#define ILCloneChild            ILCloneFirst

#define ILSkip(pidl, cb)        ((PUIDLIST_RELATIVE)VOID_OFFSET((pidl), (cb)))
#ifndef UNDER_CE
#define ILNext(pidl)            ILSkip(pidl, (pidl)->mkid.cb)
#else
// ceshell implements this differently
SHSTDAPI_(PUIDLIST_RELATIVE) ILNext(__in PCUIDLIST_RELATIVE pidl);
#endif

#define ILIsAligned(pidl)       (((DWORD_PTR)(pidl) & (sizeof(void*) - 1)) == 0)

#define ILIsEmpty(pidl)         ((pidl) == NULL || (pidl)->mkid.cb==0)

// ILIsChild does not guarantee that pidl is non-null or non-empty.
#define ILIsChild(pidl)         (ILIsEmpty(pidl) || ILIsEmpty(ILNext(pidl)))

#endif // defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)

SHSTDAPI_(PIDLIST_RELATIVE) ILAppendID(PIDLIST_RELATIVE pidl, LPCSHITEMID pmkid, BOOL fAppend);

#if (NTDDI_VERSION >= NTDDI_WIN2K && NTDDI_VERSION < NTDDI_LONGHORN)
#undef  INTERFACE
#define INTERFACE   IDefViewFrame
DECLARE_INTERFACE_IID_(IDefViewFrame, IUnknown, "710EB7A0-45ED-11D0-924A-0020AFC7AC4D")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __out void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewFrame methods ***
    STDMETHOD(GetWindowLV) (THIS_ __out HWND * phwnd) PURE;
    STDMETHOD(ReleaseWindowLV) (THIS) PURE;
    STDMETHOD(GetShellFolder)(THIS_ __out IShellFolder **ppsf) PURE;
};
#endif
//===========================================================================
// Shell restrictions. (Parameter for SHRestricted)
// SHRestricted has been deprecated in favor of SHWindowsPolicy
//--- do not add restrictions here, see winpolicy.cpp c_rgWindowsPolicies

#ifndef UNDER_CE
typedef enum RESTRICTIONS
{
    REST_NONE                       = 0x00000000,
    REST_NORUN                      = 0x00000001,
    REST_NOCLOSE                    = 0x00000002,
    REST_NOSAVESET                  = 0x00000004,
    REST_NOFILEMENU                 = 0x00000008,
    REST_NOSETFOLDERS               = 0x00000010,
    REST_NOSETTASKBAR               = 0x00000020,
    REST_NODESKTOP                  = 0x00000040,
    REST_NOFIND                     = 0x00000080,
    REST_NODRIVES                   = 0x00000100,
    REST_NODRIVEAUTORUN             = 0x00000200,
    REST_NODRIVETYPEAUTORUN         = 0x00000400,
    REST_NONETHOOD                  = 0x00000800,
    REST_STARTBANNER                = 0x00001000,
    REST_RESTRICTRUN                = 0x00002000,
    REST_NOPRINTERTABS              = 0x00004000,
    REST_NOPRINTERDELETE            = 0x00008000,
    REST_NOPRINTERADD               = 0x00010000,
    REST_NOSTARTMENUSUBFOLDERS      = 0x00020000,
    REST_MYDOCSONNET                = 0x00040000,
    REST_NOEXITTODOS                = 0x00080000,
    REST_ENFORCESHELLEXTSECURITY    = 0x00100000,
    REST_LINKRESOLVEIGNORELINKINFO  = 0x00200000,
    REST_NOCOMMONGROUPS             = 0x00400000,
    REST_SEPARATEDESKTOPPROCESS     = 0x00800000,
    REST_NOWEB                      = 0x01000000,
    REST_NOTRAYCONTEXTMENU          = 0x02000000,
    REST_NOVIEWCONTEXTMENU          = 0x04000000,
    REST_NONETCONNECTDISCONNECT     = 0x08000000,
    REST_STARTMENULOGOFF            = 0x10000000,
    REST_NOSETTINGSASSIST           = 0x20000000,
    REST_NOINTERNETICON             = 0x40000001,
    REST_NORECENTDOCSHISTORY        = 0x40000002,
    REST_NORECENTDOCSMENU           = 0x40000003,
    REST_NOACTIVEDESKTOP            = 0x40000004,
    REST_NOACTIVEDESKTOPCHANGES     = 0x40000005,
    REST_NOFAVORITESMENU            = 0x40000006,
    REST_CLEARRECENTDOCSONEXIT      = 0x40000007,
    REST_CLASSICSHELL               = 0x40000008,
    REST_NOCUSTOMIZEWEBVIEW         = 0x40000009,
    REST_NOHTMLWALLPAPER            = 0x40000010,
    REST_NOCHANGINGWALLPAPER        = 0x40000011,
    REST_NODESKCOMP                 = 0x40000012,
    REST_NOADDDESKCOMP              = 0x40000013,
    REST_NODELDESKCOMP              = 0x40000014,
    REST_NOCLOSEDESKCOMP            = 0x40000015,
    REST_NOCLOSE_DRAGDROPBAND       = 0x40000016,   // Disable Close and Drag & Drop on ALL Bands
    REST_NOMOVINGBAND               = 0x40000017,   // Disable Moving ALL Bands
    REST_NOEDITDESKCOMP             = 0x40000018,
    REST_NORESOLVESEARCH            = 0x40000019,
    REST_NORESOLVETRACK             = 0x4000001A,
    REST_FORCECOPYACLWITHFILE       = 0x4000001B,
#if (NTDDI_VERSION < NTDDI_LONGHORN)
    REST_NOLOGO3CHANNELNOTIFY       = 0x4000001C,
#endif
    REST_NOFORGETSOFTWAREUPDATE     = 0x4000001D,
    REST_NOSETACTIVEDESKTOP         = 0x4000001E,   // No Active desktop on Settings Menu
    REST_NOUPDATEWINDOWS            = 0x4000001F,   // No Windows Update on Settings Menu
    REST_NOCHANGESTARMENU           = 0x40000020,   // No Context menu or Drag and Drop on Start menu
    REST_NOFOLDEROPTIONS            = 0x40000021,   // No Folder Options on Settings Menu
    REST_HASFINDCOMPUTERS           = 0x40000022,   // Show Start/Search/Computers
    REST_INTELLIMENUS               = 0x40000023,
    REST_RUNDLGMEMCHECKBOX          = 0x40000024,
    REST_ARP_ShowPostSetup          = 0x40000025,   // ARP: Show Post-Setup page
    REST_NOCSC                      = 0x40000026,   // Disable the ClientSide caching on SM
    REST_NOCONTROLPANEL             = 0x40000027,   // Remove the Control Panel only from SM|Settings
    REST_ENUMWORKGROUP              = 0x40000028,   // Enumerate workgroup in root of nethood
    REST_ARP_NOARP                  = 0x40000029,   // ARP: Don't Allow ARP to come up at all
    REST_ARP_NOREMOVEPAGE           = 0x4000002A,   // ARP: Don't allow Remove page
    REST_ARP_NOADDPAGE              = 0x4000002B,   // ARP: Don't allow Add page
    REST_ARP_NOWINSETUPPAGE         = 0x4000002C,   // ARP: Don't allow opt components page
    REST_GREYMSIADS                 = 0x4000002D,    // SM: Allow the greying of Darwin Ads in SM
    REST_NOCHANGEMAPPEDDRIVELABEL   = 0x4000002E,   // Don't enable the UI which allows users to rename mapped drive labels
    REST_NOCHANGEMAPPEDDRIVECOMMENT = 0x4000002F,   // Don't enable the UI which allows users to change mapped drive comments
    REST_MaxRecentDocs              = 0x40000030,
    REST_NONETWORKCONNECTIONS       = 0x40000031,   // No Start Menu | Settings |Network Connections
    REST_FORCESTARTMENULOGOFF       = 0x40000032,   // Force logoff on the Start Menu
    REST_NOWEBVIEW                  = 0x40000033,   // Disable Web View
    REST_NOCUSTOMIZETHISFOLDER      = 0x40000034,   // Disable Customize This Folder
    REST_NOENCRYPTION               = 0x40000035,   // Don't allow file encryption
//  Do NOT use me                     0x40000036,
    REST_DONTSHOWSUPERHIDDEN        = 0x40000037,   // don't show super hidden files
    REST_NOSHELLSEARCHBUTTON        = 0x40000038,
    REST_NOHARDWARETAB              = 0x40000039,   // No Hardware tab on Drives or in control panel
    REST_NORUNASINSTALLPROMPT       = 0x4000003A,   // Don't bring up "Run As" prompt for install programs
    REST_PROMPTRUNASINSTALLNETPATH  = 0x4000003B,   // Force the  "Run As" prompt for install programs on unc/network shares
    REST_NOMANAGEMYCOMPUTERVERB     = 0x4000003C,   // No Manage verb on My Computer
//  Do NOT use me                     0x4000003D,
    REST_DISALLOWRUN                = 0x4000003E,   // don't allow certain apps to be run
    REST_NOWELCOMESCREEN            = 0x4000003F,   // don't allow the welcome screen to be displayed.
    REST_RESTRICTCPL                = 0x40000040,   // only allow certain cpls to be run
    REST_DISALLOWCPL                = 0x40000041,   // don't allow certain cpls to be run
    REST_NOSMBALLOONTIP             = 0x40000042,   // No Start Menu Balloon Tip
    REST_NOSMHELP                   = 0x40000043,   // No Help on the Start Menu
    REST_NOWINKEYS                  = 0x40000044,   // No Windows-X Hot keys
    REST_NOENCRYPTONMOVE            = 0x40000045,   // Don't automatically try to encrypt files that are moved to encryped directories
    REST_NOLOCALMACHINERUN          = 0x40000046,   // ignore HKLM\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOCURRENTUSERRUN           = 0x40000047,   // ignore HKCU\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOLOCALMACHINERUNONCE      = 0x40000048,   // ignore HKLM\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_NOCURRENTUSERRUNONCE       = 0x40000049,   // ignore HKCU\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_FORCEACTIVEDESKTOPON       = 0x4000004A,   // Force ActiveDesktop to be turned ON all the time.
//  Do NOT use me                     0x4000004B,
    REST_NOVIEWONDRIVE              = 0x4000004C,   // disallows CreateViewObject() on specified drives (CFSFolder only)
#if (NTDDI_VERSION >= NTDDI_WINXP) || defined(IE_BACKCOMPAT_VERSION)
    REST_NONETCRAWL                 = 0x4000004D,   // disables the crawling of the WNet namespace.
    REST_NOSHAREDDOCUMENTS          = 0x4000004E,   // don't auto share the Shared Documents/create link
#endif  // NTDDI_WINXP
    REST_NOSMMYDOCS                 = 0x4000004F,   // Don't show the My Documents item on the Start Menu.
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NOSMMYPICS                 = 0x40000050,   // Don't show the My Pictures item on the Start Menu
    REST_ALLOWBITBUCKDRIVES         = 0x40000051,   // Bit mask indicating which which drives have bit bucket support
    REST_NONLEGACYSHELLMODE         = 0x40000052,   // new consumer shell modes
    REST_NOCONTROLPANELBARRICADE    = 0x40000053,   // The webview barricade in Control Panel
    REST_NOSTARTPAGE                = 0x40000054,   // Whistler Start Page on desktop.
    REST_NOAUTOTRAYNOTIFY           = 0x40000055,   // Whistler auto-tray notify feature
    REST_NOTASKGROUPING             = 0x40000056,   // Whistler taskbar button grouping feature
    REST_NOCDBURNING                = 0x40000057,   // whistler cd burning feature
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_MYCOMPNOPROP               = 0x40000058,   // disables Properties on My Computer's context menu
    REST_MYDOCSNOPROP               = 0x40000059,   // disables Properties on My Documents' context menu
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NOSTARTPANEL               = 0x4000005A,   // Windows start panel (New start menu) for Whistler.
    REST_NODISPLAYAPPEARANCEPAGE    = 0x4000005B,   // disable Themes and Appearance tabs in the Display Control Panel.
    REST_NOTHEMESTAB                = 0x4000005C,   // disable the Themes tab in the Display Control Panel.
    REST_NOVISUALSTYLECHOICE        = 0x4000005D,   // disable the visual style drop down in the Appearance tab of the Display Control Panel.
    REST_NOSIZECHOICE               = 0x4000005E,   // disable the size drop down in the Appearance tab of the Display Control Panel.
    REST_NOCOLORCHOICE              = 0x4000005F,   // disable the color drop down in the Appearance tab of the Display Control Panel.
    REST_SETVISUALSTYLE             = 0x40000060,   // Load the specified file as the visual style.
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_STARTRUNNOHOMEPATH         = 0x40000061,   // dont use the %HOMEPATH% env var for the Start-Run dialog
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NOUSERNAMEINSTARTPANEL     = 0x40000062,   // don't show the username is the startpanel.
    REST_NOMYCOMPUTERICON           = 0x40000063,   // don't show my computer anywhere, hide its contents
    REST_NOSMNETWORKPLACES          = 0x40000064,   // don't show network places in startpanel.
    REST_NOSMPINNEDLIST             = 0x40000065,   // don't show the pinned list in startpanel.
    REST_NOSMMYMUSIC                = 0x40000066,   // don't show MyMusic folder in startpanel
    REST_NOSMEJECTPC                = 0x40000067,   // don't show "Undoc PC" command in startmenu
    REST_NOSMMOREPROGRAMS           = 0x40000068,   // don't show "More Programs" button in StartPanel.
    REST_NOSMMFUPROGRAMS            = 0x40000069,   // don't show the MFU programs list in StartPanel.
    REST_NOTRAYITEMSDISPLAY         = 0x4000006A,   // disables the display of the system tray
    REST_NOTOOLBARSONTASKBAR        = 0x4000006B,   // disables toolbar display on the taskbar
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_NOSMCONFIGUREPROGRAMS      = 0x4000006F,   // No Configure Programs on Settings Menu
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_HIDECLOCK                  = 0x40000070,   // don't show the clock
    REST_NOLOWDISKSPACECHECKS       = 0x40000071,   // disable the low disk space checking
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WIN2KSP4)
    REST_NOENTIRENETWORK            = 0x40000072,   // removes the "Entire Network" link (i.e. from "My Network Places")
#endif  // NTDDI_WIN2KSP4
#if (NTDDI_VERSION >= NTDDI_WINXP)
    REST_NODESKTOPCLEANUP           = 0x40000073,   // disable the desktop cleanup wizard
    REST_BITBUCKNUKEONDELETE        = 0x40000074,   // disables recycling of files
    REST_BITBUCKCONFIRMDELETE       = 0x40000075,   // always show the delete confirmation dialog when deleting files
    REST_BITBUCKNOPROP              = 0x40000076,   // disables Properties on Recycle Bin's context menu
    REST_NODISPBACKGROUND           = 0x40000077,   // disables the Desktop tab in the Display CPL
    REST_NODISPSCREENSAVEPG         = 0x40000078,   // disables the Screen Saver tab in the Display CPL
    REST_NODISPSETTINGSPG           = 0x40000079,   // disables the Settings tab in the Display CPL
    REST_NODISPSCREENSAVEPREVIEW    = 0x4000007A,   // disables the screen saver on the Screen Saver tab in the Display CPL
    REST_NODISPLAYCPL               = 0x4000007B,   // disables the Display CPL
    REST_HIDERUNASVERB              = 0x4000007C,   // hides the "Run As..." context menu item
    REST_NOTHUMBNAILCACHE           = 0x4000007D,   // disables use of the thumbnail cache
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_WINXPSP1) || defined(IE_BACKCOMPAT_VERSION)
    REST_NOSTRCMPLOGICAL            = 0x4000007E,   // dont use StrCmpLogical() instead use default CompareString()
    REST_NOPUBLISHWIZARD            = 0x4000007F,   // disables publishing wizard (WPW)
    REST_NOONLINEPRINTSWIZARD       = 0x40000080,   // disables online prints wizard (OPW)
    REST_NOWEBSERVICES              = 0x40000081,   // disables the web specified services for both OPW and WPW
#endif  // NTDDI_WINXPSP1
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_ALLOWUNHASHEDWEBVIEW       = 0x40000082,   // allow the user to be promted to accept web view templates that don't already have an md5 hash in the registry
#endif  // NTDDI_WIN2KSP3
    REST_ALLOWLEGACYWEBVIEW         = 0x40000083,   // allow legacy webview template to be shown.
#if (NTDDI_VERSION >= NTDDI_WIN2KSP3)
    REST_REVERTWEBVIEWSECURITY      = 0x40000084,   // disable added webview security measures (revert to w2k functionality).
#endif  // NTDDI_WIN2KSP3
#if (NTDDI_VERSION >= NTDDI_WIN2KSP4)
    REST_INHERITCONSOLEHANDLES      = 0x40000086,   // ShellExec() will check for the current process and target process being console processes to inherit handles
#endif  // NTDDI_WIN2KSP4
#if (NTDDI_VERSION >= NTDDI_WINXPSP2 && NTDDI_VERSION < NTDDI_LONGHORN)
    REST_SORTMAXITEMCOUNT           = 0x40000087,   // Do not sort views with more items than this key. Useful for viewing big amount of files in one folder.
#endif
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_NOREMOTERECURSIVEEVENTS    = 0x40000089,   // Dont register network change events recursively to avoid network traffic
#endif  // NTDDI_WINXPSP2
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_NOREMOTECHANGENOTIFY       = 0x40000091,   // Do not notify for remote changy notifies
#if (NTDDI_VERSION < NTDDI_LONGHORN)
    REST_NOSIMPLENETIDLIST          = 0x40000092,   // No simple network IDLists
#endif
    REST_NOENUMENTIRENETWORK        = 0x40000093,   // Don't enumerate entire network if we happen to get to it (in conjunction with REST_NOENTIRENETWORK)
#if (NTDDI_VERSION < NTDDI_LONGHORN)
    REST_NODETAILSTHUMBNAILONNETWORK= 0x40000094,   // Disable Thumbnail for Network files in DUI Details pane
#endif
    REST_NOINTERNETOPENWITH         = 0x40000095,   // dont allow looking on the internet for file associations
#endif  // NTDDI_WINXPSP2
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_DONTRETRYBADNETNAME        = 0x4000009B,   // In Network Places: if provider returns ERROR_BAD_NET_NAME, give up
    REST_ALLOWFILECLSIDJUNCTIONS    = 0x4000009C,   // re-enable legacy support for file.{guid} junctions in FileSystem Folder
    REST_NOUPNPINSTALL              = 0x4000009D,   // disable "install UPnP" task in My Net Places
#endif  // NTDDI_WINXPSP2
    REST_ARP_DONTGROUPPATCHES       = 0x400000AC,   //List individual patches in Add/Remove Programs
    REST_ARP_NOCHOOSEPROGRAMSPAGE   = 0x400000AD,   //Choose programs page

    REST_NODISCONNECT               = 0x41000001,   // No Disconnect option in Start menu
    REST_NOSECURITY                 = 0x41000002,   // No Security option in start menu
    REST_NOFILEASSOCIATE            = 0x41000003,   // Do not allow user to change file association
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
    REST_ALLOWCOMMENTTOGGLE         = 0x41000004,   // Allow the user to toggle the positions of the Comment and the Computer Name
#if (NTDDI_VERSION < NTDDI_LONGHORN)
    REST_USEDESKTOPINICACHE         = 0x41000005,   // Cache desktop.ini entries from network folders
#endif  // NTDDI_LONGHORN
#endif  // NTDDI_WINXPSP2
} RESTRICTIONS;
#else
typedef enum RESTRICTIONS
{
    REST_NONE               = 0x00000000,   // No restrictions
    REST_NORUNDLG           = 0x00000001,   // Disallow Shell Run Dlg
    REST_NOAUTORUN          = 0x00000002,   // No CF Autorun -  !! Must match definition of SECPOLICY_CFAUTORUN in secpol.h !!
    REST_DISALLOWRUN        = 0x00000003,   // Apps specifically disallowed
    REST_RESTRICTRUN        = 0x00000004,   // Apps specifically allowed to run
    REST_NODOWNLOAD         = 0x00000005,   // Don't allow any downloads(inbox, pie, fexplore, etc)
    REST_PASSWDPERIOD       = 0x00000006,   // Password Active Period
    REST_NOPASSWDPERIOD     = 0x00000007,   // Disallow setting of active period
    REST_NOWEAKPASSWORD     = 0x00000008,   // Require Strong password
    REST_NORAPIREGMOD       = 0x00000009,   // Disallow RAPI modifications to "protected" reg keys
    REST_NOEXTERNALEXES     = 0x0000000A,   // Don't allow foreign exes on the device(fexplore, doclist)
} RESTRICTIONS;
#endif // UNDER_CE
SHSTDAPI_(IStream *) OpenRegStream(HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
SHSTDAPI_(BOOL) SHFindFiles(PCIDLIST_ABSOLUTE pidlFolder, PCIDLIST_ABSOLUTE pidlSaveFile);
SHSTDAPI_(void) PathGetShortPath(__inout_ecount(MAX_PATH) LPWSTR pszLongPath);
SHSTDAPI_(BOOL) PathYetAnotherMakeUniqueName(__out_ecount(MAX_PATH) LPWSTR  pszUniqueName, LPCWSTR pszPath, LPCWSTR pszShort, LPCWSTR pszFileSpec);
SHSTDAPI_(BOOL) Win32DeleteFile(LPCWSTR pszPath);
#if (NTDDI_VERSION < NTDDI_LONGHORN)
//
// Path processing function
//
#define PPCF_ADDQUOTES               0x00000001        // return a quoted name if required
#define PPCF_ADDARGUMENTS            0x00000003        // appends arguments (and wraps in quotes if required)
#define PPCF_NODIRECTORIES           0x00000010        // don't match to directories
#define PPCF_FORCEQUALIFY            0x00000040        // qualify even non-relative names
#define PPCF_LONGESTPOSSIBLE         0x00000080        // always find the longest possible name

SHSTDAPI_(LONG) PathProcessCommand(LPCWSTR lpSrc, LPWSTR lpDest, int iMax, DWORD dwFlags);
#endif
SHSTDAPI_(DWORD) SHRestricted(RESTRICTIONS rest);
SHSTDAPI_(BOOL) SignalFileOpen(PCIDLIST_ABSOLUTE pidl);
SHSTDAPI_(PIDLIST_ABSOLUTE) SHSimpleIDListFromPath(LPCWSTR pszPath);

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
SHSTDAPI AssocGetDetailsOfPropKey(__in IShellFolder *psf, __in PCUITEMID_CHILD pidl, __in const PROPERTYKEY *pkey, __out VARIANT *pv, __out_opt BOOL *pfFoundPropKey);
#endif

#if (NTDDI_VERSION < NTDDI_LONGHORN)
SHSTDAPI SHLoadOLE(LPARAM lParam);
#endif

// both ANSI and UNICODE
SHSTDAPI SHStartNetConnectionDialogA(HWND hwnd, __in_opt LPCSTR pszRemoteName, DWORD dwType);
// both ANSI and UNICODE
SHSTDAPI SHStartNetConnectionDialogW(HWND hwnd, __in_opt LPCWSTR pszRemoteName, DWORD dwType);
#ifdef UNICODE
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogW
#else
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogA
#endif // !UNICODE
SHSTDAPI SHDefExtractIconA(LPCSTR pszIconFile, int iIndex, UINT uFlags,
                           __out_opt HICON *phiconLarge, __out_opt HICON *phiconSmall, UINT nIconSize);
SHSTDAPI SHDefExtractIconW(LPCWSTR pszIconFile, int iIndex, UINT uFlags,
                           __out_opt HICON *phiconLarge, __out_opt HICON *phiconSmall, UINT nIconSize);
#ifdef UNICODE
#define SHDefExtractIcon  SHDefExtractIconW
#else
#define SHDefExtractIcon  SHDefExtractIconA
#endif // !UNICODE

// Elevation

// OpenAsInfo flags
enum tagOPEN_AS_INFO_FLAGS {
    OAIF_ALLOW_REGISTRATION = 0x00000001,     // enable the "always use this file" checkbox (NOTE if you don't pass this, it will be disabled)
    OAIF_REGISTER_EXT       = 0x00000002,     // do the registration after the user hits "ok"
    OAIF_EXEC               = 0x00000004,     // execute file after registering
    OAIF_FORCE_REGISTRATION = 0x00000008,     // force the "always use this file" checkbox to be checked (normally, you won't use the OAIF_ALLOW_REGISTRATION when you pass this)
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
    OAIF_HIDE_REGISTRATION  = 0x00000020,     // hide the "always use this file" checkbox
    OAIF_URL_PROTOCOL       = 0x00000040,     // the "extension" passed is actually a protocol, and open with should show apps registered as capable of handling that protocol
#endif
};
typedef int OPEN_AS_INFO_FLAGS;


#include <pshpack8.h>

typedef struct _openasinfo
{
    LPCTSTR pcszFile;               // [in] file name, or protocol name if
                                    //      OAIF_URL_PROTOCOL is set.
    LPCTSTR pcszClass;              // [in] file class description. NULL means
                                    //      use pcszFile's extension. ignored
                                    //      if OAIF_URL_PROTOCOL is set.
    OPEN_AS_INFO_FLAGS oaifInFlags; // [in] input flags from OPEN_AS_INFO_FLAGS enumeration
} OPENASINFO, * POPENASINFO;

#include <poppack.h>        /* Return to byte packing */

SHSTDAPI SHOpenWithDialog(__in HWND hwndParent, __in const OPENASINFO* poainfo);

SHSTDAPI_(BOOL) Shell_GetImageLists(__out_opt HIMAGELIST *phiml, __out_opt HIMAGELIST *phimlSmall);
SHSTDAPI_(int)  Shell_GetCachedImageIndex(LPCWSTR pwszIconPath, int iIconIndex, UINT uIconFlags);
SHSTDAPI_(int)  Shell_GetCachedImageIndexA(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags);
SHSTDAPI_(int)  Shell_GetCachedImageIndexW(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags);
#ifdef UNICODE
#define Shell_GetCachedImageIndex  Shell_GetCachedImageIndexW
#else
#define Shell_GetCachedImageIndex  Shell_GetCachedImageIndexA
#endif // !UNICODE

//
// IDocViewSite
//
#undef  INTERFACE
#define INTERFACE  IDocViewSite
DECLARE_INTERFACE_IID_(IDocViewSite, IUnknown, "87D605E0-C511-11CF-89A9-00A0C9054129")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocViewSite methods ***
    STDMETHOD(OnSetTitle) (THIS_ VARIANTARG *pvTitle) PURE;

} ;
#define VALIDATEUNC_CONNECT     0x0001          // connect a drive letter
#define VALIDATEUNC_NOUI        0x0002          // don't bring up UI
#define VALIDATEUNC_PRINT       0x0004          // validate as print share instead of disk share
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define VALIDATEUNC_PERSIST     0x0008          // the connection should be made persistent
#define VALIDATEUNC_VALID       0x000F          // valid flags
#else
#define VALIDATEUNC_VALID       0x0007          // valid flags
#endif

SHSTDAPI_(BOOL) SHValidateUNC(HWND hwndOwner, __inout LPWSTR pszFile, UINT fConnect);
#define OPENPROPS_NONE          0x0000
#define OPENPROPS_INHIBITPIF    0x8000
#define GETPROPS_NONE           0x0000
#define SETPROPS_NONE           0x0000
#define CLOSEPROPS_NONE         0x0000
#define CLOSEPROPS_DISCARD      0x0001

#define PIFNAMESIZE     30
#define PIFSTARTLOCSIZE 63
#define PIFDEFPATHSIZE  64
#define PIFPARAMSSIZE   64
#define PIFSHPROGSIZE   64
#define PIFSHDATASIZE   64
#define PIFDEFFILESIZE  80
#define PIFMAXFILEPATH  260

typedef struct PROPPRG {                    /* prg */
    WORD    flPrg;                          // see PRG_ flags
    WORD    flPrgInit;                      // see PRGINIT_ flags
    CHAR    achTitle[PIFNAMESIZE];          // name[30]
    CHAR    achCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];// startfile[63] + params[64]
    CHAR    achWorkDir[PIFDEFPATHSIZE];     // defpath[64]
    WORD    wHotKey;                        // PfHotKeyScan thru PfHotKeyVal
    CHAR    achIconFile[PIFDEFFILESIZE];    // name of file containing icon
    WORD    wIconIndex;                     // index of icon within file
    DWORD   dwEnhModeFlags;                 // reserved enh-mode flags
    DWORD   dwRealModeFlags;                // real-mode flags (see RMOPT_*)
    CHAR    achOtherFile[PIFDEFFILESIZE];   // name of "other" file in directory
    CHAR    achPIFFile[PIFMAXFILEPATH];     // name of PIF file
} PROPPRG;
typedef UNALIGNED PROPPRG *PPROPPRG;
typedef UNALIGNED PROPPRG FAR *LPPROPPRG;
typedef const UNALIGNED PROPPRG FAR *LPCPROPPRG;

SHSTDAPI_(HANDLE) PifMgr_OpenProperties(LPCWSTR pszApp, __in_opt LPCWSTR pszPIF, UINT hInf, UINT flOpt);
SHSTDAPI_(int)    PifMgr_GetProperties(__in_opt HANDLE hProps, __in_opt LPCSTR pszGroup, __out_bcount_opt(cbProps) void *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(int)    PifMgr_SetProperties(__in_opt HANDLE hProps, __in_opt LPCSTR pszGroup, __in_bcount(cbProps) const void *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(HANDLE) PifMgr_CloseProperties(__in_opt HANDLE hProps, UINT flOpt);

SHSTDAPI_(void) SHSetInstanceExplorer(IUnknown *punk);
SHSTDAPI_(BOOL) IsUserAnAdmin(void);

#undef  INTERFACE
#define INTERFACE   IInitializeObject

DECLARE_INTERFACE_IID_(IInitializeObject, IUnknown, "4622AD16-FF23-11d0-8D34-00A0C90F2719")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInitializeObject methods
    STDMETHOD(Initialize)(THIS) PURE;
};


enum
{
    BMICON_LARGE = 0,
    BMICON_SMALL
};

#undef  INTERFACE
#define INTERFACE   IBanneredBar

DECLARE_INTERFACE_IID_(IBanneredBar, IUnknown, "596A9A94-013E-11d1-8D34-00A0C90F2719")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBanneredBar methods ***
    STDMETHOD(SetIconSize)(THIS_ DWORD iIcon) PURE;
    STDMETHOD(GetIconSize)(THIS_ DWORD* piIcon) PURE;
    STDMETHOD(SetBitmap)(THIS_ HBITMAP hBitmap) PURE;
    STDMETHOD(GetBitmap)(THIS_ HBITMAP* phBitmap) PURE;

};

SHSTDAPI_(LRESULT) SHShellFolderView_Message(HWND hwndMain, UINT uMsg, LPARAM lParam);

//
// Callback interface for the IShellView object returned from SHCreateShellFolderView.

//
#undef  INTERFACE
#define INTERFACE   IShellFolderViewCB

DECLARE_INTERFACE_IID_(IShellFolderViewCB, IUnknown, "2047E320-F2A9-11CE-AE65-08002B2E1262")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderViewCB methods ***
    STDMETHOD(MessageSFVCB)(THIS_ UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
};


#include <pshpack8.h>

#define QCMINFO_PLACE_BEFORE    0
#define QCMINFO_PLACE_AFTER     1
typedef struct _QCMINFO_IDMAP_PLACEMENT
{
    UINT id;
    UINT fFlags;
} QCMINFO_IDMAP_PLACEMENT;

typedef struct _QCMINFO_IDMAP
{
    UINT                    nMaxIds;
    QCMINFO_IDMAP_PLACEMENT pIdList[1];
} QCMINFO_IDMAP;

typedef struct _QCMINFO
{
    HMENU       hmenu;          // in
    UINT        indexMenu;      // in
    UINT        idCmdFirst;     // in/out
    UINT        idCmdLast;      // in
    QCMINFO_IDMAP const*  pIdMap; // in / unused
} QCMINFO;
typedef QCMINFO * LPQCMINFO;

// TBINFO flags
#define TBIF_APPEND     0
#define TBIF_PREPEND    1
#define TBIF_REPLACE    2
#define TBIF_DEFAULT      0x00000000
#define TBIF_INTERNETBAR  0x00010000
#define TBIF_STANDARDTOOLBAR   0x00020000
#define TBIF_NOTOOLBAR  0x00030000

typedef struct _TBINFO
{
    UINT        cbuttons;       // out
    UINT        uFlags;         // out (one of TBIF_ flags)
} TBINFO;
typedef TBINFO * LPTBINFO;


typedef struct _DETAILSINFO
{
    PCUITEMID_CHILD pidl;
    int fmt;
    int cxChar;
    STRRET str;
    int iImage;
} DETAILSINFO;
typedef DETAILSINFO *PDETAILSINFO;

typedef struct _SFVM_PROPPAGE_DATA
{
    DWORD                dwReserved;
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM               lParam;
} SFVM_PROPPAGE_DATA;

typedef struct _SFVM_HELPTOPIC_DATA
{
    WCHAR wszHelpFile[MAX_PATH];
    WCHAR wszHelpTopic[MAX_PATH];
} SFVM_HELPTOPIC_DATA;

//                                 uMsg    wParam             lParam
#define SFVM_MERGEMENU             1    // -                  LPQCMINFO
#define SFVM_INVOKECOMMAND         2    // idCmd              -
#define SFVM_GETHELPTEXT           3    // idCmd,cchMax       pszText
#define SFVM_GETTOOLTIPTEXT        4    // idCmd,cchMax       pszText
#define SFVM_GETBUTTONINFO         5    // -                  LPTBINFO
#define SFVM_GETBUTTONS            6    // idCmdFirst,cbtnMax LPTBBUTTON
#define SFVM_INITMENUPOPUP         7    // idCmdFirst,nIndex  hmenu
#define SFVM_FSNOTIFY             14    // LPCITEMIDLIST*     lEvent
#define SFVM_WINDOWCREATED        15    // hwnd               -
#define SFVM_GETDETAILSOF         23    // iColumn            DETAILSINFO*
#define SFVM_COLUMNCLICK          24    // iColumn            -
#define SFVM_QUERYFSNOTIFY        25    // -                  SHChangeNotifyEntry *
#define SFVM_DEFITEMCOUNT         26    // -                  UINT*
#define SFVM_DEFVIEWMODE          27    // -                  FOLDERVIEWMODE*
#define SFVM_UNMERGEMENU          28    // -                  hmenu
#define SFVM_UPDATESTATUSBAR      31    // fInitialize        -
#define SFVM_BACKGROUNDENUM       32    // -                  -
#define SFVM_DIDDRAGDROP          36    // dwEffect           IDataObject *
#define SFVM_SETISFV              39    // -                  IShellFolderView*
#define SFVM_THISIDLIST           41    // -                  LPITMIDLIST*
#define SFVM_ADDPROPERTYPAGES     47    // -                  SFVM_PROPPAGE_DATA *
#define SFVM_BACKGROUNDENUMDONE   48    // -                  -
#define SFVM_GETNOTIFY            49    // LPITEMIDLIST*      LONG*
// Note: SFVM_QUERYSTANDARDVIEWS NOT USED: must use SFVM_GETVIEWDATA instead
#define SFVM_GETSORTDEFAULTS      53    // iDirection         iParamSort
#define SFVM_SIZE                 57    // -                  -
#define SFVM_GETZONE              58    // -                  DWORD*
#define SFVM_GETPANE              59    // Pane ID            DWORD*
#define SFVM_GETHELPTOPIC         63    // -                  SFVM_HELPTOPIC_DATA *
#define SFVM_GETANIMATION         68    // HINSTANCE *        WCHAR *

// IShellFolderView
//
// Deprecated: use IFolderView and IFolderView2 instead.
//
// IShellFolderView is supported by the IShellView object returned from SHCreateShellFolderView.
//
// Warnings:
//  - Some methods on this interface do not follow standard COM rules.
//  - Some methods can be used to configure the IShellView or cause it to behave incorrectly.
//  - Few of these methods have parameter or range validation, so callers can cause the IShellView to fault.

typedef struct _ITEMSPACING
{
    int cxSmall;
    int cySmall;
    int cxLarge;
    int cyLarge;
} ITEMSPACING;

// defines for IShellFolderView::SetObjectCount
#define SFVSOC_INVALIDATE_ALL   0x00000001  // Assumed to reset only what is neccessary...
#define SFVSOC_NOSCROLL         LVSICF_NOSCROLL

// defines for IShellFolderView::SelectItems()
#define SFVS_SELECT_NONE        0x0 // unselect all
#define SFVS_SELECT_ALLITEMS    0x1 // select all
#define SFVS_SELECT_INVERT      0x2 // Inver the selection

#undef  INTERFACE
#define INTERFACE   IShellFolderView

DECLARE_INTERFACE_IID_(IShellFolderView, IUnknown, "37A378C0-F82D-11CE-AE65-08002B2E1262")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderView methods ***
    STDMETHOD(Rearrange) (THIS_ LPARAM lParamSort) PURE; // use IFolderView2::SetSortColumns
    STDMETHOD(GetArrangeParam) (THIS_ LPARAM *plParamSort) PURE; // use IFolderView2::GetSortColumns
    STDMETHOD(ArrangeGrid) (THIS) PURE; // select Arrange by Grid
    STDMETHOD(AutoArrange) (THIS) PURE; // select Auto Arrange
    STDMETHOD(GetAutoArrange) (THIS) PURE; // use IFolderView::GetAutoArrange
    STDMETHOD(AddObject) (THIS_ PUITEMID_CHILD pidl, UINT *puItem) PURE; // items added here may disappear (the data source is the final arbiter of which items are available to the view)
    STDMETHOD(GetObject) (THIS_ PITEMID_CHILD *ppidl, UINT uItem) PURE; // use IFolderView::Item
    STDMETHOD(RemoveObject) (THIS_ PUITEMID_CHILD pidl, UINT *puItem) PURE; // items removed here may reappear (the data source is the final arbiter of which items are available to the view)
    STDMETHOD(GetObjectCount) (THIS_ UINT *puCount) PURE; // use IFolderView::ItemCount
    STDMETHOD(SetObjectCount) (THIS_ UINT uCount, UINT dwFlags) PURE; // not implemented on Vista.  Sends LVM_SETITEMCOUNT with WPARAM=uCount and LPARAM=dwFlags to listview on XP.
    STDMETHOD(UpdateObject) (THIS_ PUITEMID_CHILD pidlOld, PUITEMID_CHILD pidlNew, UINT *puItem) PURE; // swaps ITEMID_CHILDs, returning new index.  Changes may be discarded (the data source is the final arbiter of which items are available to the view)
    STDMETHOD(RefreshObject) (THIS_ PUITEMID_CHILD pidl, UINT *puItem) PURE; // tickles the listview to re-draw the item
    STDMETHOD(SetRedraw) (THIS_ BOOL bRedraw) PURE; // sends WM_SETREDRAW to the listview
    STDMETHOD(GetSelectedCount) (THIS_ UINT *puSelected) PURE; // use IFolderView2::GetSelection
    // NOTE: GetSelectedObjects hands out const pointers to internal ITEMID_CHILD structures. The caller is expected to act on them immediately (and not cache them).  LocalFree the array, but not the items it contains.
    STDMETHOD(GetSelectedObjects) (THIS_ PCUITEMID_CHILD **pppidl, UINT *puItems) PURE; // use IFolderView2::GetSelection.
    STDMETHOD(IsDropOnSource) (THIS_ IDropTarget *pDropTarget) PURE; // use IFolderView2::IsMoveInSameFolder
    STDMETHOD(GetDragPoint) (THIS_ POINT *ppt) PURE; // returns point corresponding to drag-and-drop operation
    STDMETHOD(GetDropPoint) (THIS_ POINT *ppt) PURE; // returns point corresponding to drag-and-drop operation
    STDMETHOD(MoveIcons) (THIS_ IDataObject *pDataObject) PURE; // not implemented
    STDMETHOD(SetItemPos) (THIS_ PCUITEMID_CHILD pidl, POINT *ppt) PURE; // use IFolderView::SelectAndPositionItems
    STDMETHOD(IsBkDropTarget) (THIS_ IDropTarget *pDropTarget) PURE; // returns S_OK if drag-and-drop is on the background, S_FALSE otherwise
    STDMETHOD(SetClipboard) (THIS_ BOOL bMove) PURE; // if bMove is TRUE, this attempts to cut (edit.cut, ctrl-x) the current selection.  bMove of FALSE is not supported.
    STDMETHOD(SetPoints) (THIS_ IDataObject *pDataObject) PURE; // copies points of current selection in to data object.  Call is not needed if drag operation was originated by the IShellView.
    STDMETHOD(GetItemSpacing) (THIS_ ITEMSPACING *pSpacing) PURE; // use IFolderView::GetSpacing instead.  GetItemSpacing returns the spacing for small and large view modes only, returning S_OK if the current view mode is is positionable, S_FALSE otherwise.
    STDMETHOD(SetCallback) (THIS_ IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB) PURE; // replace the IShellFolderViewCB that the IShellView uses
    STDMETHOD(Select) ( THIS_  UINT dwFlags ) PURE; // SFVS_ select flags: select all, select none, invert selection
    STDMETHOD(QuerySupport) (THIS_ UINT * pdwSupport ) PURE; // does nothing, returns S_OK.
    STDMETHOD(SetAutomationObject)(THIS_ IDispatch* pdisp) PURE; // replaces the IShellView's internal automation object.
} ;

// SHCreateShellFolderView struct
typedef struct _SFV_CREATE
{
    UINT            cbSize;     // must be sizeof(SFV_CREATE)
    IShellFolder*   pshf;       // IShellFolder the IShellView will use
    IShellView*     psvOuter;   // optional: IShellView to pass to psfvcb
    IShellFolderViewCB* psfvcb; // No callback if NULL
} SFV_CREATE;

SHSTDAPI SHCreateShellFolderView(__in const SFV_CREATE* pcsfv, __deref_out IShellView ** ppsv);
typedef HRESULT (CALLBACK * LPFNDFMCALLBACK)(IShellFolder *psf, HWND hwnd,
                                             IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

SHSTDAPI CDefFolderMenu_Create2(__in PCIDLIST_ABSOLUTE pidlFolder, __in_opt HWND hwnd,
                                __in_opt UINT cidl, __in_ecount_opt(cidl) PCUITEMID_CHILD_ARRAY apidl,
                                __in IShellFolder *psf, __in LPFNDFMCALLBACK pfn,
                                __in UINT nKeys, __in_ecount(nKeys) const HKEY *ahkeys,
                                __deref_out IContextMenu **ppcm);
typedef struct {
    HWND hwnd;
    IContextMenuCB *pcmcb;          // optional: callback object
    PCIDLIST_ABSOLUTE pidlFolder;   // optional: IDList to folder of the items, computed from psf if NULL
    IShellFolder *psf;              // folder of the items
    UINT cidl;                      // # of items in apidl
    PCUITEMID_CHILD_ARRAY apidl;    // items operating on, used to get IDataObject and IAssociationArray
    IUnknown *punkAssociationInfo;  // optional: IQueryAssociations, specifies where to load extensions from, computed from apidl if NULL
    UINT cKeys;                     // # of items in aKeys, may be zero
    const HKEY *aKeys;              // optional: specifies where to load extensions from
} DEFCONTEXTMENU;

// creates object that implements IContextMenu/IContextMenu2/IContextMenu3, typically
// used in the implemetnation of ::GetUIObjectOf()

SHSTDAPI SHCreateDefaultContextMenu(__in const DEFCONTEXTMENU *pdcm, __in REFIID riid, __deref_out void **ppv);

SHSTDAPI_(BOOL) SHOpenPropSheetA(__in_opt LPCSTR pszCaption, __in_ecount_opt(cikeys) HKEY ahkeys[], UINT cikeys,
                                 __in_opt const CLSID * pclsidDefault, __in IDataObject *pdtobj,
                                 __in_opt IShellBrowser *psb, __in_opt LPCSTR pStartPage);
SHSTDAPI_(BOOL) SHOpenPropSheetW(__in_opt LPCWSTR pszCaption, __in_ecount_opt(cikeys) HKEY ahkeys[], UINT cikeys,
                                 __in_opt const CLSID * pclsidDefault, __in IDataObject *pdtobj,
                                 __in_opt IShellBrowser *psb, __in_opt LPCWSTR pStartPage);
#ifdef UNICODE
#define SHOpenPropSheet  SHOpenPropSheetW
#else
#define SHOpenPropSheet  SHOpenPropSheetA
#endif // !UNICODE

// structure for lParam of DFM_INFOKECOMMANDEX
typedef struct
{
    DWORD  cbSize;
    DWORD  fMask;   // CMIC_MASK_ values for the invoke
    LPARAM lParam;  // same as lParam of DFM_INFOKECOMMAND
    UINT idCmdFirst;
    UINT idDefMax;
    LPCMINVOKECOMMANDINFO pici; // the whole thing so you can re-invoke on a child
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
    IUnknown *punkSite;         // site pointer for context menu handler
#endif
} DFMICS, *PDFMICS;

// Note on context menus ranges:
//  Standard Items // DFM_MERGECONTEXTMENU, context menu extensions, DFM_MERGECONTEXTMENU_TOP
//  Separator
//  View Items   // context menu extensions can get here
//  Separator
//  (defcm S_FALSE "default" items, if applicable)
//  Separator
//  Folder Items // context menu extensions can get here
//  Separator
//  Bottom Items // DFM_MERGECONTEXTMENU_BOTTOM

//                                  uMsg       wParam       lParam
#define DFM_MERGECONTEXTMENU         1      // uFlags       LPQCMINFO
#define DFM_INVOKECOMMAND            2      // idCmd        pszArgs
#define DFM_GETHELPTEXT              5      // idCmd,cchMax pszText -Ansi
#define DFM_WM_MEASUREITEM           6      // ---from the message---
#define DFM_WM_DRAWITEM              7      // ---from the message---
#define DFM_WM_INITMENUPOPUP         8      // ---from the message---
#define DFM_VALIDATECMD              9      // idCmd        0
#define DFM_MERGECONTEXTMENU_TOP     10     // uFlags       LPQCMINFO
#define DFM_GETHELPTEXTW             11     // idCmd,cchMax pszText -Unicode
#define DFM_INVOKECOMMANDEX          12     // idCmd        PDFMICS
#define DFM_MAPCOMMANDNAME           13     // idCmd *      pszCommandName
#define DFM_GETDEFSTATICID           14     // idCmd *      0
#define DFM_GETVERBW                 15     // idCmd,cchMax pszText -Unicode
#define DFM_GETVERBA                 16     // idCmd,cchMax pszText -Ansi
#define DFM_MERGECONTEXTMENU_BOTTOM  17     // uFlags       LPQCMINFO

// Commands from DFM_INVOKECOMMAND when strings are passed in
#define DFM_CMD_DELETE          ((UINT)-1)
#define DFM_CMD_MOVE            ((UINT)-2)
#define DFM_CMD_COPY            ((UINT)-3)
#define DFM_CMD_LINK            ((UINT)-4)
#define DFM_CMD_PROPERTIES      ((UINT)-5)
#define DFM_CMD_NEWFOLDER       ((UINT)-6)
#define DFM_CMD_PASTE           ((UINT)-7)
#define DFM_CMD_VIEWLIST        ((UINT)-8)
#define DFM_CMD_VIEWDETAILS     ((UINT)-9)
#define DFM_CMD_PASTELINK       ((UINT)-10)
#define DFM_CMD_PASTESPECIAL    ((UINT)-11)
#define DFM_CMD_MODALPROP       ((UINT)-12)
#define DFM_CMD_RENAME          ((UINT)-13)


typedef HRESULT (CALLBACK * LPFNVIEWCALLBACK)(IShellView *psvOuter,
                                                IShellFolder *psf,
                                                HWND hwndMain,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

// SHCreateShellFolderViewEx struct
typedef struct _CSFV
{
    UINT              cbSize;
    IShellFolder *    pshf;
    IShellView *      psvOuter;
    PCIDLIST_ABSOLUTE pidl;
    LONG              lEvents;
    LPFNVIEWCALLBACK  pfnCallback;       // No callback if NULL
    FOLDERVIEWMODE    fvm;
} CSFV, * LPCSFV;


// Tell the FolderView to rearrange.  The lParam will be passed to
// IShellFolder::CompareIDs
#define SFVM_REARRANGE          0x00000001
#define ShellFolderView_ReArrange(_hwnd, _lparam) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_REARRANGE, _lparam)
// Add an OBJECT into the view
#define SFVM_ADDOBJECT         0x00000003
#define ShellFolderView_AddObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_ADDOBJECT, (LPARAM)(_pidl))
// Remove an OBJECT into the view
#define SFVM_REMOVEOBJECT         0x00000006
#define ShellFolderView_RemoveObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REMOVEOBJECT, (LPARAM)(_pidl))

// updates an object by passing in pointer to two PIDLS, the first
// is the old pidl, the second one is the one with update information.
//
// _ppidl[1] must be a *copy* of a pidl, as control over the lifetime
// of the pidl belongs to the view after successful completion of
// this call.  (Unsuccessful completion (a -1 return) implies failure
// and the caller must free the memory.)  Win95 waits a while before
// freeing the pidl, IE4 frees the pidl immediately.
// IShellFolderView::UpdateObject does not suffer from this problem.
//
#define SFVM_UPDATEOBJECT         0x00000007
#define ShellFolderView_UpdateObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_UPDATEOBJECT, (LPARAM)(_ppidl))


// Returns an array of the selected IDS to the caller.
//     lparam is a pointer to receive the idlists into
//     return value is the count of items in the array.
#define SFVM_GETSELECTEDOBJECTS 0x00000009
#define ShellFolderView_GetSelectedObjects(_hwnd, ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDOBJECTS, (LPARAM)(ppidl))
typedef struct _SFV_SETITEMPOS
{
        PCUITEMID_CHILD pidl;
        POINT pt;
} SFV_SETITEMPOS;
typedef SFV_SETITEMPOS *LPSFV_SETITEMPOS;
typedef const SFV_SETITEMPOS *PCSFV_SETITEMPOS;

// Sets the position of an item in the viewer
//     lparam is a pointer to a SVF_SETITEMPOS
//     return value is unused
#define SFVM_SETITEMPOS         0x0000000e
#define ShellFolderView_SetItemPos(_hwnd, _pidl, _x, _y) \
{       SFV_SETITEMPOS _sip = {_pidl, {_x, _y}}; \
        SHShellFolderView_Message(_hwnd, SFVM_SETITEMPOS, (LPARAM)(LPSFV_SETITEMPOS)&_sip);}
//  Notifies a ShellView when one of its objects get put on the clipboard
//  as a result of a menu command.
//
//
//     lparam is the dwEffect (DROPEFFECT_MOVE, DROPEFFECT_COPY)
//     return value is void.
#define SFVM_SETCLIPBOARD       0x00000010
#define ShellFolderView_SetClipboard(_hwnd, _dwEffect) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETCLIPBOARD, (LPARAM)(DWORD)(_dwEffect))
#define SFVM_SETPOINTS           0x00000017
#define ShellFolderView_SetPoints(_hwnd, _pdtobj) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETPOINTS, (LPARAM)(_pdtobj))
#include <poppack.h>        /* Return to byte packing */
SHSTDAPI_(IContextMenu *) SHFind_InitMenuPopup(HMENU hmenu, HWND hwndOwner, UINT idCmdFirst, UINT idCmdLast);
SHSTDAPI SHCreateShellFolderViewEx(LPCSFV pcsfv, __out IShellView ** ppsv);

// Legacy PROPIDs for Internet Shortcuts (FMTID_Intshcut) to be used with
// IPropertySetStorage/IPropertyStorage.
//
// The known property ids and their variant types are:
//      PID_IS_URL          [VT_LPWSTR]   URL
//      PID_IS_NAME         [VT_LPWSTR]   Name of the internet shortcut
//      PID_IS_WORKINGDIR   [VT_LPWSTR]   Working directory for the shortcut
//      PID_IS_HOTKEY       [VT_UI2]      Hotkey for the shortcut
//      PID_IS_SHOWCMD      [VT_I4]       Show command for shortcut
//      PID_IS_ICONINDEX    [VT_I4]       Index into file that has icon
//      PID_IS_ICONFILE     [VT_LPWSTR]   File that has the icon
//      PID_IS_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_IS_AUTHOR       [VT_LPWSTR]   Author
//      PID_IS_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_IS_COMMENT      [VT_LPWSTR]   User annotated comment

#define PID_IS_URL           2
#define PID_IS_NAME          4
#define PID_IS_WORKINGDIR    5
#define PID_IS_HOTKEY        6
#define PID_IS_SHOWCMD       7
#define PID_IS_ICONINDEX     8
#define PID_IS_ICONFILE      9
#define PID_IS_WHATSNEW      10
#define PID_IS_AUTHOR        11
#define PID_IS_DESCRIPTION   12
#define PID_IS_COMMENT       13

// PROPIDs for Internet Sites (FMTID_InternetSite) to be used with
// IPropertySetStorage/IPropertyStorage
//
// The known property ids and their variant types are:
//      PID_INTSITE_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_INTSITE_AUTHOR       [VT_LPWSTR]   Author
//      PID_INTSITE_LASTVISIT    [VT_FILETIME] Time site was last visited
//      PID_INTSITE_LASTMOD      [VT_FILETIME] Time site was last modified
//      PID_INTSITE_VISITCOUNT   [VT_UI4]      Number of times user has visited
//      PID_INTSITE_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_INTSITE_COMMENT      [VT_LPWSTR]   User annotated comment
//      PID_INTSITE_RECURSE      [VT_UI4]      Levels to recurse (0-3)
//      PID_INTSITE_WATCH        [VT_UI4]      PIDISM_ flags
//      PID_INTSITE_SUBSCRIPTION [VT_UI8]      Subscription cookie
//      PID_INTSITE_URL          [VT_LPWSTR]   URL
//      PID_INTSITE_TITLE        [VT_LPWSTR]   Title
//      PID_INTSITE_CODEPAGE     [VT_UI4]      Codepage of the document
//      PID_INTSITE_TRACKING     [VT_UI4]      Tracking
//      PID_INTSITE_ICONINDEX    [VT_I4]       Retrieve the index to the icon
//      PID_INTSITE_ICONFILE     [VT_LPWSTR]   Retrieve the file containing the icon index.
//      PID_INTSITE_RAWURL       [VT_LPWSTR]   The raw, un-encoded, unicode url.

#define PID_INTSITE_WHATSNEW      2
#define PID_INTSITE_AUTHOR        3
#define PID_INTSITE_LASTVISIT     4
#define PID_INTSITE_LASTMOD       5
#define PID_INTSITE_VISITCOUNT    6
#define PID_INTSITE_DESCRIPTION   7
#define PID_INTSITE_COMMENT       8
#define PID_INTSITE_FLAGS         9
#define PID_INTSITE_CONTENTLEN    10
#define PID_INTSITE_CONTENTCODE   11
#define PID_INTSITE_RECURSE       12
#define PID_INTSITE_WATCH         13
#define PID_INTSITE_SUBSCRIPTION  14
#define PID_INTSITE_URL           15
#define PID_INTSITE_TITLE         16
#define PID_INTSITE_CODEPAGE      18
#define PID_INTSITE_TRACKING      19
#define PID_INTSITE_ICONINDEX     20
#define PID_INTSITE_ICONFILE      21

// Flags for PID_IS_FLAGS
#define PIDISF_RECENTLYCHANGED  0x00000001
#define PIDISF_CACHEDSTICKY     0x00000002
#define PIDISF_CACHEIMAGES      0x00000010
#define PIDISF_FOLLOWALLLINKS   0x00000020


// Values for PID_INTSITE_WATCH
#define PIDISM_GLOBAL           0       // Monitor based on global setting
#define PIDISM_WATCH            1       // User says watch
#define PIDISM_DONTWATCH        2       // User says don't watch


////////////////////////////////////////////////////////////////////
//
// The shell keeps track of some per-user state to handle display
// options that is of major interest to ISVs.
// The key one requested right now is "DoubleClickInWebView".

typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;

    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1; // No longer used, dead bit
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;
    BOOL fNoNetCrawling : 1;

    DWORD dwWin95Unused; // Win95 only - no longer supported pszHiddenFileExts
    UINT  uWin95Unused; // Win95 only - no longer supported cbHiddenFileExts

    // Note: Not a typo!  This is a persisted structure so we cannot use LPARAM
    LONG   lParamSort;
    int    iSortDirection;

    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;

    // new for Whistler.
    BOOL fStartPanelOn: 1;       //Indicates if the Whistler StartPanel mode is ON or OFF.
    BOOL fShowStartPage: 1;      //Indicates if the Whistler StartPage on desktop is ON or OFF.

    // new for Longhorn
    BOOL fAutoCheckSelect: 1;
    BOOL fIconsOnly: 1;
    BOOL fShowTypeOverlay: 1;

    UINT fSpareFlags : 11;

} SHELLSTATEA, *LPSHELLSTATEA;

typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;
    BOOL fNoNetCrawling : 1;

    DWORD dwWin95Unused; // Win95 only - no longer supported pszHiddenFileExts
    UINT  uWin95Unused; // Win95 only - no longer supported cbHiddenFileExts

    // Note: Not a typo!  This is a persisted structure so we cannot use LPARAM
    LONG   lParamSort;
    int    iSortDirection;
    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;

    // new for Whistler.
    BOOL fStartPanelOn: 1;       //Indicates if the Whistler StartPage mode is ON or OFF.
    BOOL fShowStartPage: 1;      //Indicates if the Whistler StartPage on desktop is ON or OFF.

    // new for Longhorn
    BOOL fAutoCheckSelect: 1;
    BOOL fIconsOnly: 1;
    BOOL fShowTypeOverlay: 1;

    // If you need a new flag, steal a bit from from fSpareFlags.
    UINT fSpareFlags : 11;

} SHELLSTATEW, *LPSHELLSTATEW;

#define SHELLSTATEVERSION_IE4   9
#define SHELLSTATEVERSION_WIN2K 10

#ifdef UNICODE
#define SHELLSTATE   SHELLSTATEW
#define LPSHELLSTATE LPSHELLSTATEW
#else
#define SHELLSTATE   SHELLSTATEA
#define LPSHELLSTATE LPSHELLSTATEA
#endif

#define SHELLSTATE_SIZE_WIN95 FIELD_OFFSET(SHELLSTATE,lParamSort)
#define SHELLSTATE_SIZE_NT4   FIELD_OFFSET(SHELLSTATE,version)
#define SHELLSTATE_SIZE_IE4   FIELD_OFFSET(SHELLSTATE,uNotUsed)
#define SHELLSTATE_SIZE_WIN2K sizeof(SHELLSTATE)

SHSTDAPI_(void) SHGetSetSettings(__inout_opt LPSHELLSTATE lpss, DWORD dwMask, BOOL bSet);

//
//  SysFiles are these windows special files:
//      "dll sys vxd 386 drv"
//
//  hidden files are files with the FILE_ATTRIBUTE_HIDDEN attribute
//
//  system files are files with the FILE_ATTRIBUTE_SYSTEM attribute
//
//      fShowAllObjects fShowSysFiles   Result
//      --------------- -------------   ------
//      0               0               hide hidden + SysFiles + system files
//      0               1               hide hidden files.
//      1               0               show all files.
//      1               1               show all files.
//
typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
    BOOL fAutoCheckSelect: 1;
    BOOL fIconsOnly: 1;
    UINT fRestFlags : 1;
#else
    UINT fRestFlags : 3;
#endif
} SHELLFLAGSTATE, *LPSHELLFLAGSTATE;

#define SSF_SHOWALLOBJECTS          0x00000001
#define SSF_SHOWEXTENSIONS          0x00000002
#define SSF_HIDDENFILEEXTS          0x00000004
#define SSF_SERVERADMINUI           0x00000004
#define SSF_SHOWCOMPCOLOR           0x00000008
#define SSF_SORTCOLUMNS             0x00000010
#define SSF_SHOWSYSFILES            0x00000020
#define SSF_DOUBLECLICKINWEBVIEW    0x00000080
#define SSF_SHOWATTRIBCOL           0x00000100
#define SSF_DESKTOPHTML             0x00000200
#define SSF_WIN95CLASSIC            0x00000400
#define SSF_DONTPRETTYPATH          0x00000800
#define SSF_SHOWINFOTIP             0x00002000
#define SSF_MAPNETDRVBUTTON         0x00001000
#define SSF_NOCONFIRMRECYCLE        0x00008000
#define SSF_HIDEICONS               0x00004000
#define SSF_FILTER                  0x00010000
#define SSF_WEBVIEW                 0x00020000
#define SSF_SHOWSUPERHIDDEN         0x00040000
#define SSF_SEPPROCESS              0x00080000
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define SSF_NONETCRAWLING           0x00100000
#define SSF_STARTPANELON            0x00200000
#define SSF_SHOWSTARTPAGE           0x00400000
#endif  // NTDDI_WINXP
#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define SSF_AUTOCHECKSELECT         0x00800000

#define SSF_ICONSONLY               0x01000000
#define SSF_SHOWTYPEOVERLAY         0x02000000

#endif  // NTDDI_LONGHORN

//
// Specify the bits you are interested in in dwMask and they will be
// filled out in the lpss structure.
//
// When these settings change, a WM_SETTINGCHANGE message is sent
// with the string lParam value of "ShellState".
//
SHSTDAPI_(void) SHGetSettings(__out SHELLFLAGSTATE *psfs, DWORD dwMask);

//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
//
SHSTDAPI SHBindToParent(PCIDLIST_ABSOLUTE pidl, REFIID riid, __out void **ppv, __out_opt PCUITEMID_CHILD *ppidlLast);


#if (NTDDI_VERSION >= NTDDI_LONGHORN)

// Same as SHBindToParent, except you also specify which root to use.
SHSTDAPI SHBindToFolderIDListParent(IShellFolder *psfRoot, PCUIDLIST_RELATIVE pidl, REFIID riid, __out void **ppv, __out_opt PCUITEMID_CHILD *ppidlLast);

// same as SHBindToFolderIDListParent but with a IBindCtx *pbc;
SHSTDAPI SHBindToFolderIDListParentEx(IShellFolder *psfRoot, PCUIDLIST_RELATIVE pidl, __in_opt IBindCtx *ppbc, REFIID riid, __out void **ppv, __out_opt PCUITEMID_CHILD *ppidlLast);

#ifndef UNDER_CE // #ifndef IEMOBILE 
// Windows CE: ceshell implements a version of this call with different args
// helper function that gets the desktop object, then calls BindToObject on that
SHSTDAPI SHBindToObject(__in_opt IShellFolder *psf, __in PCUIDLIST_RELATIVE pidl, __in_opt IBindCtx *pbc, __in REFIID riid, __deref_out void **ppv);
#endif // ndef IEMOBILE

#endif // NTDDI_LONGHORN

//
//  given a string it will call psfDesktop->ParseDisplayName() to try and create a pidl
//  if no pbc specified, it uses the preferred options for parsing.
//  this includes mapping file system paths to their appropriate aliased location (RegisterObjectParam(STR_PARSE_TRANSLATE_ALIASES))
//  psfgaoOut is optional for SFGAO attributes
//
#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI SHParseDisplayName(PCWSTR pszName, __in_opt IBindCtx *pbc, __out PIDLIST_ABSOLUTE *ppidl, SFGAOF sfgaoIn, __out_opt SFGAOF *psfgaoOut);
#endif // NTDDI_WINXP

//
// This API will make its best effort to prepare the path for the caller.  This includes:
// 1. Prompting for the ejectable media to be re-inserted. (Floppy, CD-ROM, ZIP drive, etc.)
// 2. Prompting for the media to be formatted. (Floppy, hard drive, etc.)
// 3. Remount mapped drives if the connection was lost. (\\unc\share mapped to N: becomes disconnected)
// 4. If the path doesn't exist, create it.  (SHPPFW_DIRCREATE and SHPPFW_ASKDIRCREATE)
// 5. Display an error if the media is read only. (SHPPFW_NOWRITECHECK not set)
//
// PARAMETERS:
//      hwnd: Parernt window for UI.  NULL means don't display UI. OPTIONAL
//      punkEnableModless: Parent that will be set to modal during UI using IOleInPlaceActiveObject::EnableModeless(). OPTIONAL
//      pszPath: Path to verify is valid for writting.  This can be a UNC or file drive path.  The path
//               should only contain directories.  Pass SHPPFW_IGNOREFILENAME if the last path segment
//               is always filename to ignore.
//      dwFlags: SHPPFW_* Flags to modify behavior

#define SHPPFW_NONE             0x00000000
#define SHPPFW_DEFAULT          SHPPFW_DIRCREATE        // May change
#define SHPPFW_DIRCREATE        0x00000001              // Create the directory if it doesn't exist without asking the user.
#define SHPPFW_ASKDIRCREATE     0x00000002              // Create the directory if it doesn't exist after asking the user.
#define SHPPFW_IGNOREFILENAME   0x00000004              // Ignore the last item in pszPath because it's a file.  Example: pszPath="C:\DirA\DirB", only use "C:\DirA".
#define SHPPFW_NOWRITECHECK     0x00000008              // Caller only needs to read from the drive, so don't check if it's READ ONLY.
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define SHPPFW_MEDIACHECKONLY   0x00000010              // do the retrys on the media (or net path), return errors if the file can't be found
#endif // NTDDI_WINXP

SHSTDAPI SHPathPrepareForWriteA(HWND hwnd, IUnknown *punkEnableModless, LPCSTR pszPath, DWORD dwFlags);
SHSTDAPI SHPathPrepareForWriteW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pszPath, DWORD dwFlags);
#ifdef UNICODE
#define SHPathPrepareForWrite  SHPathPrepareForWriteW
#else
#define SHPathPrepareForWrite  SHPathPrepareForWriteA
#endif // !UNICODE


//--------------------------------------------------------------------------
//
// Interface used for exposing the INI file methods on a shortcut file
//
//
//--------------------------------------------------------------------------
#undef  INTERFACE
#define INTERFACE  INamedPropertyBag
DECLARE_INTERFACE_IID_(INamedPropertyBag, IUnknown, "FB700430-952C-11d1-946F-000000000000")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;
    // *** INamedPropertyBag methods ***
    STDMETHOD(ReadPropertyNPB) (THIS_  /* [in] */ LPCWSTR pszBagname,
                            /* [in] */ LPCWSTR pszPropName,
                            /* [out][in] */ PROPVARIANT *pVar) PURE;

    STDMETHOD(WritePropertyNPB)(THIS_ /* [in] */ LPCWSTR pszBagname,
                           /* [in] */ LPCWSTR pszPropName,
                           /* [in] */ PROPVARIANT  *pVar) PURE;

    STDMETHOD(RemovePropertyNPB)(THIS_ /* [in] */ LPCWSTR pszBagname,
                          /* [in] */ LPCWSTR pszPropName) PURE;
};

#ifdef __urlmon_h__
//    NOTE: urlmon.h must be included before shlobj.h to access this function.
//
//    SoftwareUpdateMessageBox
//
//    Provides a standard message box for the alerting the user that a software
//    update is available or installed. No UI will be displayed if there is no
//    update available or if the available update version is less than or equal
//    to the Advertised update version.
//
//    hWnd                - [in] Handle of owner window
//    szDistUnit          - [in] Unique identifier string for a code distribution unit. For
//                               ActiveX controls and Active Setup installed components, this
//                               is typically a GUID string.
//    dwFlags             - [in] Must be 0.
//    psdi                - [in,out] Pointer to SOFTDISTINFO ( see URLMon.h ). May be NULL.
//                                cbSize should be initialized
//                                by the caller to sizeof(SOFTDISTINFO), dwReserved should be set to 0.
//
//    RETURNS:
//
//    IDNO     - The user chose cancel. If *pbRemind is FALSE, the caller should save the
//               update version from the SOFTDISTINFO and pass it in as the Advertised
//               version in future calls.
//
//    IDYES    - The user has selected Update Now/About Update. The caller should navigate to
//               the SOFTDISTINFO's pszHREF to initiate the install or learn about it.
//               The caller should save the update version from the SOFTDISTINFO and pass
//               it in as the Advertised version in future calls.
//
//    IDIGNORE - There is no pending software update. Note: There is
//               no Ignore button in the standard UI. This occurs if the available
//               version is less than the installed version or is not present or if the
//               Advertised version is greater than or equal to the update version.
//
//    IDABORT  - An error occured. Call GetSoftwareUpdateInfo() for a more specific HRESULT.
//               Note: There is no Abort button in the standard UI.


SHDOCAPI_(DWORD) SoftwareUpdateMessageBox( HWND hWnd,
                                           LPCWSTR pszDistUnit,
                                           DWORD dwFlags,
                                           __out_opt LPSOFTDISTINFO psdi );
#endif // if __urlmon_h__


//  SHPropStgCreate()
//  Wrap of IPropertySetStorage::Open/Create
//
//  This function ensures proper handling of code page retrieval/assignment
//  for the requested property set operation.
//
//  psstg,          //  Address of IPropertySetStorage vtable
//  fmtid,          //  property set ID
//  pclsid,         //  class ID associated with the set. This can be NULL
//  grfFlags,       //  PROPSETFLAG_xxx.  All sets containing ansi bytes should be created with
                    //  PROPSETFLAG_ANSI, otherwise PROPSETFLAG_DEFAULT.
//  grfMode,        //  STGM_ flags.  Must contain STGM_DIRECT|STGM_EXCLUSIVE.
//  dwDisposition,  //  OPEN_EXISTING. OPEN_ALWAYS, CREATE_NEW, or CREATE_ALWAYS
//  IPropertyStorage** ppstg,  // Address to receive requested vtable
//  puCodePage      //  Optional address to receive the code page ID for the set.
//
SHSTDAPI SHPropStgCreate( IPropertySetStorage* psstg, REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, DWORD grfMode, DWORD dwDisposition, __out IPropertyStorage** ppstg, __out_opt UINT* puCodePage );


//  SHPropStgReadMultiple()
//  IPropertyStorage::ReadMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, //Code page value retrieved from SHCreatePropertySet
//  cpspec,    //Count of properties being read
//  rgpspec,   //Array of the properties to be read
//  rgvar      //Array of PROPVARIANTs containing the property values on return
//
SHSTDAPI SHPropStgReadMultiple( IPropertyStorage* pps, UINT uCodePage, ULONG cpspec, __in_ecount(cpspec) PROPSPEC const rgpspec[], __out_ecount_full(cpspec) PROPVARIANT rgvar[] );


//  SHPropStgWriteMultiple()
//  IPropertyStorage::WriteMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, // code page retrieved from SHCreatePropertySet.
//  cpspec,    // The number of properties being set
//  rgpspec,   // Property specifiers
//  rgvar,     // Array of PROPVARIANT values
//  propidNameFirst // Minimum value for property identifiers. This value should be >= PID_FIRST_USABLE
//
SHSTDAPI SHPropStgWriteMultiple( IPropertyStorage* pps, __inout_opt UINT* puCodePage, ULONG cpspec, __in_ecount(cpspec) PROPSPEC const rgpspec[], __inout_ecount(cpspec) PROPVARIANT rgvar[], PROPID propidNameFirst );

#if (NTDDI_VERSION >= NTDDI_WINXP)
SHSTDAPI SHCreateFileExtractIconA(LPCSTR pszFile, DWORD dwFileAttributes, REFIID riid, __out void **ppv);
SHSTDAPI SHCreateFileExtractIconW(LPCWSTR pszFile, DWORD dwFileAttributes, REFIID riid, __out void **ppv);
#ifdef UNICODE
#define SHCreateFileExtractIcon  SHCreateFileExtractIconW
#else
#define SHCreateFileExtractIcon  SHCreateFileExtractIconA
#endif // !UNICODE
#include <pshpack8.h>
#include <poppack.h>        /* Return to byte packing */
SHSTDAPI SHLimitInputEdit(HWND hwndEdit, IShellFolder *psf);
STDAPI SHGetAttributesFromDataObject(IDataObject *pdo, DWORD dwAttributeMask, __out_opt DWORD *pdwAttributes, __out_opt UINT *pcItems);
#endif  // NTDDI_WINXP

#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// The SHMultiFileProperties API displays a property sheet for a
// set of files specified in an IDList Array.
//
// Parameters:
//      pdtobj  - Data object containing list of files.  The data
//                object must provide the "Shell IDList Array"
//                clipboard format.  The parent folder's implementation of
//                IShellFolder::GetDisplayNameOf must return a fully-qualified
//                filesystem path for each item in response to the
//                SHGDN_FORPARSING flag.
//
//      dwFlags - Reserved for future use.  Should be set to 0.
//
// Returns:
//      S_OK
//
SHSTDAPI SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags);

#endif  // NTDDI_WIN2K

// A usefull function in Defview for mapping idlist into index into system
// image list.  Optionally it can also look up the index of the selected
// icon.
SHSTDAPI_(int) SHMapPIDLToSystemImageListIndex(IShellFolder *pshf, PCUITEMID_CHILD pidl, __out_opt int *piIndexSel);

SHSTDAPI SHCLSIDFromString(LPCWSTR psz, __out CLSID *pclsid);
SHSTDAPI SHCreateQueryCancelAutoPlayMoniker(__out IMoniker** ppmoniker);    // deprecated: use CreateClassMoniker(CLSID_YourOwnClsid, ...)
STDAPI_(void) PerUserInit(void);
SHSTDAPI_(BOOL)SHRunControlPanel(LPCWSTR lpcszCmdLine, HWND hwndMsgParent);

SHSTDAPI_(int) PickIconDlg(HWND hwnd, __inout_ecount(cchIconPath) LPWSTR pszIconPath, UINT cchIconPath, __inout_opt int *piIconIndex);

#include <pshpack8.h>

typedef struct tagAAMENUFILENAME
{
  SHORT  cbTotal;
  BYTE   rgbReserved[12];
  WCHAR  szFileName[1];     // variable length string
} AASHELLMENUFILENAME, *LPAASHELLMENUFILENAME;

typedef struct tagAASHELLMENUITEM
{
  void*  lpReserved1;
  int    iReserved;
  UINT   uiReserved;
  LPAASHELLMENUFILENAME lpName; // name of file
  LPWSTR psz;           // text to use if no file
} AASHELLMENUITEM, *LPAASHELLMENUITEM;

#include <poppack.h>        /* Return to byte packing */


#if (_WIN32_IE >= _WIN32_IE_IE70)
typedef enum tagIESHORTCUTFLAGS
{
    IESHORTCUT_NEWBROWSER    = 0x01,
    IESHORTCUT_OPENNEWTAB    = 0x02,
    IESHORTCUT_FORCENAVIGATE = 0x04,
    IESHORTCUT_BACKGROUNDTAB = 0x08,
} IESHORTCUTFLAGS;
#endif // _WIN32_IE_IE70

#if (_WIN32_IE >= _WIN32_IE_XP)

SHDOCAPI_(BOOL) ImportPrivacySettings(LPCWSTR pszFilename, __inout BOOL* pfParsePrivacyPreferences, __inout BOOL* pfParsePerSiteRules);
#ifndef IEnumPrivacyRecords
typedef interface IEnumPrivacyRecords IEnumPrivacyRecords;
#endif
SHDOCAPI DoPrivacyDlg(HWND hwndOwner, __in LPWSTR pszUrl, __in IEnumPrivacyRecords *pPrivacyEnum, BOOL fReportAllSites);

#endif  // _WIN32_IE_XP


#include <poppack.h>

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _SHLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\shldisp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Fri Jan 26 17:24:31 2007
 */
/* Compiler settings for ..\shldisp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shldisp_h__
#define __shldisp_h__

/* Forward Declarations */ 

#ifndef __IFolderViewOC_FWD_DEFINED__
#define __IFolderViewOC_FWD_DEFINED__
typedef interface IFolderViewOC IFolderViewOC;
#endif 	/* __IFolderViewOC_FWD_DEFINED__ */


#ifndef __DShellFolderViewEvents_FWD_DEFINED__
#define __DShellFolderViewEvents_FWD_DEFINED__
typedef interface DShellFolderViewEvents DShellFolderViewEvents;
#endif 	/* __DShellFolderViewEvents_FWD_DEFINED__ */


#ifndef __ShellFolderViewOC_FWD_DEFINED__
#define __ShellFolderViewOC_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderViewOC ShellFolderViewOC;
#else
typedef struct ShellFolderViewOC ShellFolderViewOC;
#endif /* __cplusplus */

#endif 	/* __ShellFolderViewOC_FWD_DEFINED__ */


#ifndef __DFConstraint_FWD_DEFINED__
#define __DFConstraint_FWD_DEFINED__
typedef interface DFConstraint DFConstraint;
#endif 	/* __DFConstraint_FWD_DEFINED__ */


#ifndef __FolderItem_FWD_DEFINED__
#define __FolderItem_FWD_DEFINED__
typedef interface FolderItem FolderItem;
#endif 	/* __FolderItem_FWD_DEFINED__ */


#ifndef __FolderItems_FWD_DEFINED__
#define __FolderItems_FWD_DEFINED__
typedef interface FolderItems FolderItems;
#endif 	/* __FolderItems_FWD_DEFINED__ */


#ifndef __FolderItemVerb_FWD_DEFINED__
#define __FolderItemVerb_FWD_DEFINED__
typedef interface FolderItemVerb FolderItemVerb;
#endif 	/* __FolderItemVerb_FWD_DEFINED__ */


#ifndef __FolderItemVerbs_FWD_DEFINED__
#define __FolderItemVerbs_FWD_DEFINED__
typedef interface FolderItemVerbs FolderItemVerbs;
#endif 	/* __FolderItemVerbs_FWD_DEFINED__ */


#ifndef __Folder_FWD_DEFINED__
#define __Folder_FWD_DEFINED__
typedef interface Folder Folder;
#endif 	/* __Folder_FWD_DEFINED__ */


#ifndef __Folder2_FWD_DEFINED__
#define __Folder2_FWD_DEFINED__
typedef interface Folder2 Folder2;
#endif 	/* __Folder2_FWD_DEFINED__ */


#ifndef __Folder3_FWD_DEFINED__
#define __Folder3_FWD_DEFINED__
typedef interface Folder3 Folder3;
#endif 	/* __Folder3_FWD_DEFINED__ */


#ifndef __FolderItem2_FWD_DEFINED__
#define __FolderItem2_FWD_DEFINED__
typedef interface FolderItem2 FolderItem2;
#endif 	/* __FolderItem2_FWD_DEFINED__ */


#ifndef __ShellFolderItem_FWD_DEFINED__
#define __ShellFolderItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderItem ShellFolderItem;
#else
typedef struct ShellFolderItem ShellFolderItem;
#endif /* __cplusplus */

#endif 	/* __ShellFolderItem_FWD_DEFINED__ */


#ifndef __FolderItems2_FWD_DEFINED__
#define __FolderItems2_FWD_DEFINED__
typedef interface FolderItems2 FolderItems2;
#endif 	/* __FolderItems2_FWD_DEFINED__ */


#ifndef __FolderItems3_FWD_DEFINED__
#define __FolderItems3_FWD_DEFINED__
typedef interface FolderItems3 FolderItems3;
#endif 	/* __FolderItems3_FWD_DEFINED__ */


#ifndef __IShellLinkDual_FWD_DEFINED__
#define __IShellLinkDual_FWD_DEFINED__
typedef interface IShellLinkDual IShellLinkDual;
#endif 	/* __IShellLinkDual_FWD_DEFINED__ */


#ifndef __IShellLinkDual2_FWD_DEFINED__
#define __IShellLinkDual2_FWD_DEFINED__
typedef interface IShellLinkDual2 IShellLinkDual2;
#endif 	/* __IShellLinkDual2_FWD_DEFINED__ */


#ifndef __ShellLinkObject_FWD_DEFINED__
#define __ShellLinkObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLinkObject ShellLinkObject;
#else
typedef struct ShellLinkObject ShellLinkObject;
#endif /* __cplusplus */

#endif 	/* __ShellLinkObject_FWD_DEFINED__ */


#ifndef __IShellFolderViewDual_FWD_DEFINED__
#define __IShellFolderViewDual_FWD_DEFINED__
typedef interface IShellFolderViewDual IShellFolderViewDual;
#endif 	/* __IShellFolderViewDual_FWD_DEFINED__ */


#ifndef __IShellFolderViewDual2_FWD_DEFINED__
#define __IShellFolderViewDual2_FWD_DEFINED__
typedef interface IShellFolderViewDual2 IShellFolderViewDual2;
#endif 	/* __IShellFolderViewDual2_FWD_DEFINED__ */


#ifndef __IShellFolderViewDual3_FWD_DEFINED__
#define __IShellFolderViewDual3_FWD_DEFINED__
typedef interface IShellFolderViewDual3 IShellFolderViewDual3;
#endif 	/* __IShellFolderViewDual3_FWD_DEFINED__ */


#ifndef __ShellFolderView_FWD_DEFINED__
#define __ShellFolderView_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderView ShellFolderView;
#else
typedef struct ShellFolderView ShellFolderView;
#endif /* __cplusplus */

#endif 	/* __ShellFolderView_FWD_DEFINED__ */


#ifndef __IShellDispatch_FWD_DEFINED__
#define __IShellDispatch_FWD_DEFINED__
typedef interface IShellDispatch IShellDispatch;
#endif 	/* __IShellDispatch_FWD_DEFINED__ */


#ifndef __IShellDispatch2_FWD_DEFINED__
#define __IShellDispatch2_FWD_DEFINED__
typedef interface IShellDispatch2 IShellDispatch2;
#endif 	/* __IShellDispatch2_FWD_DEFINED__ */


#ifndef __IShellDispatch3_FWD_DEFINED__
#define __IShellDispatch3_FWD_DEFINED__
typedef interface IShellDispatch3 IShellDispatch3;
#endif 	/* __IShellDispatch3_FWD_DEFINED__ */


#ifndef __IShellDispatch4_FWD_DEFINED__
#define __IShellDispatch4_FWD_DEFINED__
typedef interface IShellDispatch4 IShellDispatch4;
#endif 	/* __IShellDispatch4_FWD_DEFINED__ */


#ifndef __IShellDispatch5_FWD_DEFINED__
#define __IShellDispatch5_FWD_DEFINED__
typedef interface IShellDispatch5 IShellDispatch5;
#endif 	/* __IShellDispatch5_FWD_DEFINED__ */


#ifndef __Shell_FWD_DEFINED__
#define __Shell_FWD_DEFINED__

#ifdef __cplusplus
typedef class Shell Shell;
#else
typedef struct Shell Shell;
#endif /* __cplusplus */

#endif 	/* __Shell_FWD_DEFINED__ */


#ifndef __ShellDispatchInproc_FWD_DEFINED__
#define __ShellDispatchInproc_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellDispatchInproc ShellDispatchInproc;
#else
typedef struct ShellDispatchInproc ShellDispatchInproc;
#endif /* __cplusplus */

#endif 	/* __ShellDispatchInproc_FWD_DEFINED__ */


#ifndef __IFileSearchBand_FWD_DEFINED__
#define __IFileSearchBand_FWD_DEFINED__
typedef interface IFileSearchBand IFileSearchBand;
#endif 	/* __IFileSearchBand_FWD_DEFINED__ */


#ifndef __FileSearchBand_FWD_DEFINED__
#define __FileSearchBand_FWD_DEFINED__

#ifdef __cplusplus
typedef class FileSearchBand FileSearchBand;
#else
typedef struct FileSearchBand FileSearchBand;
#endif /* __cplusplus */

#endif 	/* __FileSearchBand_FWD_DEFINED__ */


#ifndef __IWebWizardHost_FWD_DEFINED__
#define __IWebWizardHost_FWD_DEFINED__
typedef interface IWebWizardHost IWebWizardHost;
#endif 	/* __IWebWizardHost_FWD_DEFINED__ */


#ifndef __INewWDEvents_FWD_DEFINED__
#define __INewWDEvents_FWD_DEFINED__
typedef interface INewWDEvents INewWDEvents;
#endif 	/* __INewWDEvents_FWD_DEFINED__ */


#ifndef __IAutoComplete_FWD_DEFINED__
#define __IAutoComplete_FWD_DEFINED__
typedef interface IAutoComplete IAutoComplete;
#endif 	/* __IAutoComplete_FWD_DEFINED__ */


#ifndef __IAutoComplete2_FWD_DEFINED__
#define __IAutoComplete2_FWD_DEFINED__
typedef interface IAutoComplete2 IAutoComplete2;
#endif 	/* __IAutoComplete2_FWD_DEFINED__ */


#ifndef __IEnumACString_FWD_DEFINED__
#define __IEnumACString_FWD_DEFINED__
typedef interface IEnumACString IEnumACString;
#endif 	/* __IEnumACString_FWD_DEFINED__ */


#ifndef __IAsyncOperation_FWD_DEFINED__
#define __IAsyncOperation_FWD_DEFINED__
typedef interface IAsyncOperation IAsyncOperation;
#endif 	/* __IAsyncOperation_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_shldisp_0000 */
/* [local] */ 


#pragma once


extern RPC_IF_HANDLE __MIDL_itf_shldisp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldisp_0000_v0_0_s_ifspec;


#ifndef __Shell32_LIBRARY_DEFINED__
#define __Shell32_LIBRARY_DEFINED__

/* library Shell32 */
/* [version][lcid][helpstring][uuid] */ 





typedef /* [helpstring] */ 
enum OfflineFolderStatus
    {	OFS_INACTIVE	= -1,
	OFS_ONLINE	= OFS_INACTIVE + 1,
	OFS_OFFLINE	= OFS_ONLINE + 1,
	OFS_SERVERBACK	= OFS_OFFLINE + 1,
	OFS_DIRTYCACHE	= OFS_SERVERBACK + 1
    }	OfflineFolderStatus;

typedef /* [helpstring] */ 
enum ShellFolderViewOptions
    {	SFVVO_SHOWALLOBJECTS	= 0x1,
	SFVVO_SHOWEXTENSIONS	= 0x2,
	SFVVO_SHOWCOMPCOLOR	= 0x8,
	SFVVO_SHOWSYSFILES	= 0x20,
	SFVVO_WIN95CLASSIC	= 0x40,
	SFVVO_DOUBLECLICKINWEBVIEW	= 0x80,
	SFVVO_DESKTOPHTML	= 0x200
    }	ShellFolderViewOptions;

typedef /* [helpstring] */ 
enum ShellSpecialFolderConstants
    {	ssfDESKTOP	= 0,
	ssfPROGRAMS	= 0x2,
	ssfCONTROLS	= 0x3,
	ssfPRINTERS	= 0x4,
	ssfPERSONAL	= 0x5,
	ssfFAVORITES	= 0x6,
	ssfSTARTUP	= 0x7,
	ssfRECENT	= 0x8,
	ssfSENDTO	= 0x9,
	ssfBITBUCKET	= 0xa,
	ssfSTARTMENU	= 0xb,
	ssfDESKTOPDIRECTORY	= 0x10,
	ssfDRIVES	= 0x11,
	ssfNETWORK	= 0x12,
	ssfNETHOOD	= 0x13,
	ssfFONTS	= 0x14,
	ssfTEMPLATES	= 0x15,
	ssfCOMMONSTARTMENU	= 0x16,
	ssfCOMMONPROGRAMS	= 0x17,
	ssfCOMMONSTARTUP	= 0x18,
	ssfCOMMONDESKTOPDIR	= 0x19,
	ssfAPPDATA	= 0x1a,
	ssfPRINTHOOD	= 0x1b,
	ssfLOCALAPPDATA	= 0x1c,
	ssfALTSTARTUP	= 0x1d,
	ssfCOMMONALTSTARTUP	= 0x1e,
	ssfCOMMONFAVORITES	= 0x1f,
	ssfINTERNETCACHE	= 0x20,
	ssfCOOKIES	= 0x21,
	ssfHISTORY	= 0x22,
	ssfCOMMONAPPDATA	= 0x23,
	ssfWINDOWS	= 0x24,
	ssfSYSTEM	= 0x25,
	ssfPROGRAMFILES	= 0x26,
	ssfMYPICTURES	= 0x27,
	ssfPROFILE	= 0x28,
	ssfSYSTEMx86	= 0x29,
	ssfPROGRAMFILESx86	= 0x30
    }	ShellSpecialFolderConstants;


EXTERN_C const IID LIBID_Shell32;

#ifndef __IFolderViewOC_INTERFACE_DEFINED__
#define __IFolderViewOC_INTERFACE_DEFINED__

/* interface IFolderViewOC */
/* [object][dual][oleautomation][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IFolderViewOC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9BA05970-F6A8-11CF-A442-00A0C90A8F39")
    IFolderViewOC : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetFolderView( 
            /* [in] */ IDispatch __RPC_FAR *pdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewOCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFolderViewOC __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFolderViewOC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFolderViewOC __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFolderView )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pdisp);
        
        END_INTERFACE
    } IFolderViewOCVtbl;

    interface IFolderViewOC
    {
        CONST_VTBL struct IFolderViewOCVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderViewOC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFolderViewOC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFolderViewOC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFolderViewOC_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFolderViewOC_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFolderViewOC_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFolderViewOC_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFolderViewOC_SetFolderView(This,pdisp)	\
    (This)->lpVtbl -> SetFolderView(This,pdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IFolderViewOC_SetFolderView_Proxy( 
    IFolderViewOC __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pdisp);


void __RPC_STUB IFolderViewOC_SetFolderView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFolderViewOC_INTERFACE_DEFINED__ */


#ifndef __DShellFolderViewEvents_DISPINTERFACE_DEFINED__
#define __DShellFolderViewEvents_DISPINTERFACE_DEFINED__

/* dispinterface DShellFolderViewEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_DShellFolderViewEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("62112AA2-EBE4-11cf-A5FB-0020AFE7292D")
    DShellFolderViewEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DShellFolderViewEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DShellFolderViewEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DShellFolderViewEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DShellFolderViewEventsVtbl;

    interface DShellFolderViewEvents
    {
        CONST_VTBL struct DShellFolderViewEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DShellFolderViewEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DShellFolderViewEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DShellFolderViewEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DShellFolderViewEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DShellFolderViewEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DShellFolderViewEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DShellFolderViewEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DShellFolderViewEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderViewOC;

#ifdef __cplusplus

class DECLSPEC_UUID("9BA05971-F6A8-11CF-A442-00A0C90A8F39")
ShellFolderViewOC;
#endif

#ifndef __DFConstraint_INTERFACE_DEFINED__
#define __DFConstraint_INTERFACE_DEFINED__

/* interface DFConstraint */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_DFConstraint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a3df050-23bd-11d2-939f-00a0c91eedba")
    DFConstraint : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DFConstraintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DFConstraint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DFConstraint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DFConstraint __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            DFConstraint __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            DFConstraint __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pv);
        
        END_INTERFACE
    } DFConstraintVtbl;

    interface DFConstraint
    {
        CONST_VTBL struct DFConstraintVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DFConstraint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DFConstraint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DFConstraint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DFConstraint_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DFConstraint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DFConstraint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DFConstraint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define DFConstraint_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define DFConstraint_get_Value(This,pv)	\
    (This)->lpVtbl -> get_Value(This,pv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE DFConstraint_get_Name_Proxy( 
    DFConstraint __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB DFConstraint_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE DFConstraint_get_Value_Proxy( 
    DFConstraint __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pv);


void __RPC_STUB DFConstraint_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __DFConstraint_INTERFACE_DEFINED__ */


#ifndef __FolderItem_INTERFACE_DEFINED__
#define __FolderItem_INTERFACE_DEFINED__

/* interface FolderItem */
/* [object][dual][oleautomation][helpstring][uuid] */ 

typedef /* [unique] */ FolderItem __RPC_FAR *LPFOLDERITEM;


EXTERN_C const IID IID_FolderItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAC32C80-CBE4-11CE-8350-444553540000")
    FolderItem : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GetLink( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GetFolder( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsLink( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsFolder( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsFileSystem( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsBrowsable( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ModifyDate( 
            /* [retval][out] */ DATE __RPC_FAR *pdt) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ModifyDate( 
            /* [in] */ DATE dt) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ LONG __RPC_FAR *pul) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Verbs( 
            /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerb( 
            /* [optional][in] */ VARIANT vVerb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItem __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetLink )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetFolder )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsLink )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFolder )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFileSystem )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsBrowsable )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModifyDate )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pdt);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ModifyDate )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ DATE dt);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Size )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pul);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Verbs )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeVerb )( 
            FolderItem __RPC_FAR * This,
            /* [optional][in] */ VARIANT vVerb);
        
        END_INTERFACE
    } FolderItemVtbl;

    interface FolderItem
    {
        CONST_VTBL struct FolderItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItem_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItem_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItem_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define FolderItem_put_Name(This,bs)	\
    (This)->lpVtbl -> put_Name(This,bs)

#define FolderItem_get_Path(This,pbs)	\
    (This)->lpVtbl -> get_Path(This,pbs)

#define FolderItem_get_GetLink(This,ppid)	\
    (This)->lpVtbl -> get_GetLink(This,ppid)

#define FolderItem_get_GetFolder(This,ppid)	\
    (This)->lpVtbl -> get_GetFolder(This,ppid)

#define FolderItem_get_IsLink(This,pb)	\
    (This)->lpVtbl -> get_IsLink(This,pb)

#define FolderItem_get_IsFolder(This,pb)	\
    (This)->lpVtbl -> get_IsFolder(This,pb)

#define FolderItem_get_IsFileSystem(This,pb)	\
    (This)->lpVtbl -> get_IsFileSystem(This,pb)

#define FolderItem_get_IsBrowsable(This,pb)	\
    (This)->lpVtbl -> get_IsBrowsable(This,pb)

#define FolderItem_get_ModifyDate(This,pdt)	\
    (This)->lpVtbl -> get_ModifyDate(This,pdt)

#define FolderItem_put_ModifyDate(This,dt)	\
    (This)->lpVtbl -> put_ModifyDate(This,dt)

#define FolderItem_get_Size(This,pul)	\
    (This)->lpVtbl -> get_Size(This,pul)

#define FolderItem_get_Type(This,pbs)	\
    (This)->lpVtbl -> get_Type(This,pbs)

#define FolderItem_Verbs(This,ppfic)	\
    (This)->lpVtbl -> Verbs(This,ppfic)

#define FolderItem_InvokeVerb(This,vVerb)	\
    (This)->lpVtbl -> InvokeVerb(This,vVerb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Application_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Parent_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Name_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItem_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE FolderItem_put_Name_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB FolderItem_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Path_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItem_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_GetLink_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_GetLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_GetFolder_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_GetFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsLink_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsFolder_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsFileSystem_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsFileSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsBrowsable_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsBrowsable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_ModifyDate_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pdt);


void __RPC_STUB FolderItem_get_ModifyDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE FolderItem_put_ModifyDate_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [in] */ DATE dt);


void __RPC_STUB FolderItem_put_ModifyDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Size_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pul);


void __RPC_STUB FolderItem_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Type_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItem_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem_Verbs_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic);


void __RPC_STUB FolderItem_Verbs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem_InvokeVerb_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [optional][in] */ VARIANT vVerb);


void __RPC_STUB FolderItem_InvokeVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItem_INTERFACE_DEFINED__ */


#ifndef __FolderItems_INTERFACE_DEFINED__
#define __FolderItems_INTERFACE_DEFINED__

/* interface FolderItems */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("744129E0-CBE5-11CE-8350-444553540000")
    FolderItems : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItems __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItems __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItems __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            FolderItems __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } FolderItemsVtbl;

    interface FolderItems
    {
        CONST_VTBL struct FolderItemsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItems_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define FolderItems_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItems_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItems_Item(This,index,ppid)	\
    (This)->lpVtbl -> Item(This,index,ppid)

#define FolderItems__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItems_get_Count_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB FolderItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItems_get_Application_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItems_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItems_get_Parent_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItems_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItems_Item_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [optional][in] */ VARIANT index,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItems_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FolderItems__NewEnum_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB FolderItems__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItems_INTERFACE_DEFINED__ */


#ifndef __FolderItemVerb_INTERFACE_DEFINED__
#define __FolderItemVerb_INTERFACE_DEFINED__

/* interface FolderItemVerb */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItemVerb;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08EC3E00-50B0-11CF-960C-0080C7F4EE85")
    FolderItemVerb : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
