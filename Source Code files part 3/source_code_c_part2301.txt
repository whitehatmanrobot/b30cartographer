  0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:35 2002
 */
/* Compiler settings for oaidl.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "oaidl.h"

#define TYPE_FORMAT_STRING_SIZE   1967                              
#define PROC_FORMAT_STRING_SIZE   3293                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   3            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDispatch_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDispatch_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatch_RemoteInvoke_Proxy( 
    IDispatch * This,
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID riid,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DISPPARAMS *pDispParams,
    /* [out] */ VARIANT *pVarResult,
    /* [out] */ EXCEPINFO *pExcepInfo,
    /* [out] */ UINT *pArgErr,
    /* [in] */ UINT cVarRef,
    /* [size_is][in] */ UINT *rgVarRefIdx,
    /* [size_is][out][in] */ VARIANTARG *rgVarRef)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150],
                  ( unsigned char * )This,
                  dispIdMember,
                  riid,
                  lcid,
                  dwFlags,
                  pDispParams,
                  pVarResult,
                  pExcepInfo,
                  pArgErr,
                  cVarRef,
                  rgVarRefIdx,
                  rgVarRef);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IDispatch_RemoteInvoke_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IDispatch *This;
        DISPID dispIdMember;
        char Pad0[4];
        REFIID riid;
        LCID lcid;
        char Pad1[4];
        DWORD dwFlags;
        char Pad2[4];
        DISPPARAMS *pDispParams;
        VARIANT *pVarResult;
        EXCEPINFO *pExcepInfo;
        UINT *pArgErr;
        UINT cVarRef;
        char Pad3[4];
        UINT *rgVarRefIdx;
        VARIANTARG *rgVarRef;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IDispatch_Invoke_Stub(
                                (IDispatch *) pParamStruct->This,
                                pParamStruct->dispIdMember,
                                pParamStruct->riid,
                                pParamStruct->lcid,
                                pParamStruct->dwFlags,
                                pParamStruct->pDispParams,
                                pParamStruct->pVarResult,
                                pParamStruct->pExcepInfo,
                                pParamStruct->pArgErr,
                                pParamStruct->cVarRef,
                                pParamStruct->rgVarRefIdx,
                                pParamStruct->rgVarRef);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumVARIANT_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumVARIANT_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumVARIANT_RemoteNext_Proxy( 
    IEnumVARIANT * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ VARIANT *rgVar,
    /* [out] */ ULONG *pCeltFetched)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[248],
                  ( unsigned char * )This,
                  celt,
                  rgVar,
                  pCeltFetched);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IEnumVARIANT_RemoteNext_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IEnumVARIANT *This;
        ULONG celt;
        char Pad0[4];
        VARIANT *rgVar;
        ULONG *pCeltFetched;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IEnumVARIANT_Next_Stub(
                                 (IEnumVARIANT *) pParamStruct->This,
                                 pParamStruct->celt,
                                 pParamStruct->rgVar,
                                 pParamStruct->pCeltFetched);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITypeComp_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITypeComp_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeComp_RemoteBind_Proxy( 
    ITypeComp * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [in] */ WORD wFlags,
    /* [out] */ ITypeInfo **ppTInfo,
    /* [out] */ DESCKIND *pDescKind,
    /* [out] */ LPFUNCDESC *ppFuncDesc,
    /* [out] */ LPVARDESC *ppVarDesc,
    /* [out] */ ITypeComp **ppTypeComp,
    /* [out] */ CLEANLOCALSTORAGE *pDummy)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[406],
                  ( unsigned char * )This,
                  szName,
                  lHashVal,
                  wFlags,
                  ppTInfo,
                  pDescKind,
                  ppFuncDesc,
                  ppVarDesc,
                  ppTypeComp,
                  pDummy);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeComp_RemoteBind_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeComp *This;
        LPOLESTR szName;
        ULONG lHashVal;
        char Pad0[4];
        WORD wFlags;
        char Pad1[6];
        ITypeInfo **ppTInfo;
        DESCKIND *pDescKind;
        LPFUNCDESC *ppFuncDesc;
        LPVARDESC *ppVarDesc;
        ITypeComp **ppTypeComp;
        CLEANLOCALSTORAGE *pDummy;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeComp_Bind_Stub(
                              (ITypeComp *) pParamStruct->This,
                              pParamStruct->szName,
                              pParamStruct->lHashVal,
                              pParamStruct->wFlags,
                              pParamStruct->ppTInfo,
                              pParamStruct->pDescKind,
                              pParamStruct->ppFuncDesc,
                              pParamStruct->ppVarDesc,
                              pParamStruct->ppTypeComp,
                              pParamStruct->pDummy);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeComp_RemoteBindType_Proxy( 
    ITypeComp * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [out] */ ITypeInfo **ppTInfo)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[492],
                  ( unsigned char * )This,
                  szName,
                  lHashVal,
                  ppTInfo);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeComp_RemoteBindType_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeComp *This;
        LPOLESTR szName;
        ULONG lHashVal;
        char Pad0[4];
        ITypeInfo **ppTInfo;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeComp_BindType_Stub(
                                  (ITypeComp *) pParamStruct->This,
                                  pParamStruct->szName,
                                  pParamStruct->lHashVal,
                                  pParamStruct->ppTInfo);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITypeInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITypeInfo_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetTypeAttr_Proxy( 
    ITypeInfo * This,
    /* [out] */ LPTYPEATTR *ppTypeAttr,
    /* [out] */ CLEANLOCALSTORAGE *pDummy)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[542],
                  ( unsigned char * )This,
                  ppTypeAttr,
                  pDummy);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeInfo_RemoteGetTypeAttr_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        LPTYPEATTR *ppTypeAttr;
        CLEANLOCALSTORAGE *pDummy;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_GetTypeAttr_Stub(
                                     (ITypeInfo *) pParamStruct->This,
                                     pParamStruct->ppTypeAttr,
                                     pParamStruct->pDummy);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetFuncDesc_Proxy( 
    ITypeInfo * This,
    /* [in] */ UINT index,
    /* [out] */ LPFUNCDESC *ppFuncDesc,
    /* [out] */ CLEANLOCALSTORAGE *pDummy)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[624],
                  ( unsigned char * )This,
                  index,
                  ppFuncDesc,
                  pDummy);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeInfo_RemoteGetFuncDesc_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        UINT index;
        char Pad0[4];
        LPFUNCDESC *ppFuncDesc;
        CLEANLOCALSTORAGE *pDummy;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_GetFuncDesc_Stub(
                                     (ITypeInfo *) pParamStruct->This,
                                     pParamStruct->index,
                                     pParamStruct->ppFuncDesc,
                                     pParamStruct->pDummy);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetVarDesc_Proxy( 
    ITypeInfo * This,
    /* [in] */ UINT index,
    /* [out] */ LPVARDESC *ppVarDesc,
    /* [out] */ CLEANLOCALSTORAGE *pDummy)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[674],
                  ( unsigned char * )This,
                  index,
                  ppVarDesc,
                  pDummy);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeInfo_RemoteGetVarDesc_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        UINT index;
        char Pad0[4];
        LPVARDESC *ppVarDesc;
        CLEANLOCALSTORAGE *pDummy;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_GetVarDesc_Stub(
                                    (ITypeInfo *) pParamStruct->This,
                                    pParamStruct->index,
                                    pParamStruct->ppVarDesc,
                                    pParamStruct->pDummy);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetNames_Proxy( 
    ITypeInfo * This,
    /* [in] */ MEMBERID memid,
    /* [length_is][size_is][out] */ BSTR *rgBstrNames,
    /* [in] */ UINT cMaxNames,
    /* [out] */ UINT *pcNames)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[724],
                  ( unsigned char * )This,
                  memid,
                  rgBstrNames,
                  cMaxNames,
                  pcNames);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeInfo_RemoteGetNames_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        MEMBERID memid;
        char Pad0[4];
        BSTR *rgBstrNames;
        UINT cMaxNames;
        char Pad1[4];
        UINT *pcNames;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_GetNames_Stub(
                                  (ITypeInfo *) pParamStruct->This,
                                  pParamStruct->memid,
                                  pParamStruct->rgBstrNames,
                                  pParamStruct->cMaxNames,
                                  pParamStruct->pcNames);
    
}

void __RPC_API
ITypeInfo_LocalGetIDsOfNames_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_GetIDsOfNames_Stub((ITypeInfo *) pParamStruct->This);
    
}

void __RPC_API
ITypeInfo_LocalInvoke_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_Invoke_Stub((ITypeInfo *) pParamStruct->This);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetDocumentation_Proxy( 
    ITypeInfo * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR *pBstrName,
    /* [out] */ BSTR *pBstrDocString,
    /* [out] */ DWORD *pdwHelpContext,
    /* [out] */ BSTR *pBstrHelpFile)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[932],
                  ( unsigned char * )This,
                  memid,
                  refPtrFlags,
                  pBstrName,
                  pBstrDocString,
                  pdwHelpContext,
                  pBstrHelpFile);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeInfo_RemoteGetDocumentation_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        MEMBERID memid;
        char Pad0[4];
        DWORD refPtrFlags;
        char Pad1[4];
        BSTR *pBstrName;
        BSTR *pBstrDocString;
        DWORD *pdwHelpContext;
        BSTR *pBstrHelpFile;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_GetDocumentation_Stub(
                                          (ITypeInfo *) pParamStruct->This,
                                          pParamStruct->memid,
                                          pParamStruct->refPtrFlags,
                                          pParamStruct->pBstrName,
                                          pParamStruct->pBstrDocString,
                                          pParamStruct->pdwHelpContext,
                                          pParamStruct->pBstrHelpFile);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetDllEntry_Proxy( 
    ITypeInfo * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invKind,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR *pBstrDllName,
    /* [out] */ BSTR *pBstrName,
    /* [out] */ WORD *pwOrdinal)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1000],
                  ( unsigned char * )This,
                  memid,
                  invKind,
                  refPtrFlags,
                  pBstrDllName,
                  pBstrName,
                  pwOrdinal);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeInfo_RemoteGetDllEntry_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        MEMBERID memid;
        char Pad0[4];
        INVOKEKIND invKind;
        char Pad1[4];
        DWORD refPtrFlags;
        char Pad2[4];
        BSTR *pBstrDllName;
        BSTR *pBstrName;
        WORD *pwOrdinal;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_GetDllEntry_Stub(
                                     (ITypeInfo *) pParamStruct->This,
                                     pParamStruct->memid,
                                     pParamStruct->invKind,
                                     pParamStruct->refPtrFlags,
                                     pParamStruct->pBstrDllName,
                                     pParamStruct->pBstrName,
                                     pParamStruct->pwOrdinal);
    
}

void __RPC_API
ITypeInfo_LocalAddressOfMember_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_AddressOfMember_Stub((ITypeInfo *) pParamStruct->This);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteCreateInstance_Proxy( 
    ITypeInfo * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObj)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1144],
                  ( unsigned char * )This,
                  riid,
                  ppvObj);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeInfo_RemoteCreateInstance_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        REFIID riid;
        IUnknown **ppvObj;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_CreateInstance_Stub(
                                        (ITypeInfo *) pParamStruct->This,
                                        pParamStruct->riid,
                                        pParamStruct->ppvObj);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetContainingTypeLib_Proxy( 
    ITypeInfo * This,
    /* [out] */ ITypeLib **ppTLib,
    /* [out] */ UINT *pIndex)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1232],
                  ( unsigned char * )This,
                  ppTLib,
                  pIndex);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeInfo_RemoteGetContainingTypeLib_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        ITypeLib **ppTLib;
        UINT *pIndex;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_GetContainingTypeLib_Stub(
                                              (ITypeInfo *) pParamStruct->This,
                                              pParamStruct->ppTLib,
                                              pParamStruct->pIndex);
    
}

void __RPC_API
ITypeInfo_LocalReleaseTypeAttr_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_ReleaseTypeAttr_Stub((ITypeInfo *) pParamStruct->This);
    
}

void __RPC_API
ITypeInfo_LocalReleaseFuncDesc_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_ReleaseFuncDesc_Stub((ITypeInfo *) pParamStruct->This);
    
}

void __RPC_API
ITypeInfo_LocalReleaseVarDesc_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo *This;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo_ReleaseVarDesc_Stub((ITypeInfo *) pParamStruct->This);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITypeInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITypeInfo2_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo2_RemoteGetDocumentation2_Proxy( 
    ITypeInfo2 * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR *pbstrHelpString,
    /* [out] */ DWORD *pdwHelpStringContext,
    /* [out] */ BSTR *pbstrHelpStringDll)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[1792],
                  ( unsigned char * )This,
                  memid,
                  lcid,
                  refPtrFlags,
                  pbstrHelpString,
                  pdwHelpStringContext,
                  pbstrHelpStringDll);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeInfo2_RemoteGetDocumentation2_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeInfo2 *This;
        MEMBERID memid;
        char Pad0[4];
        LCID lcid;
        char Pad1[4];
        DWORD refPtrFlags;
        char Pad2[4];
        BSTR *pbstrHelpString;
        DWORD *pdwHelpStringContext;
        BSTR *pbstrHelpStringDll;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeInfo2_GetDocumentation2_Stub(
                                            (ITypeInfo2 *) pParamStruct->This,
                                            pParamStruct->memid,
                                            pParamStruct->lcid,
                                            pParamStruct->refPtrFlags,
                                            pParamStruct->pbstrHelpString,
                                            pParamStruct->pdwHelpStringContext,
                                            pParamStruct->pbstrHelpStringDll);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITypeLib_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITypeLib_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteGetTypeInfoCount_Proxy( 
    ITypeLib * This,
    /* [out] */ UINT *pcTInfo)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )This,
                  pcTInfo);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeLib_RemoteGetTypeInfoCount_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeLib *This;
        UINT *pcTInfo;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeLib_GetTypeInfoCount_Stub((ITypeLib *) pParamStruct->This,pParamStruct->pcTInfo);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteGetLibAttr_Proxy( 
    ITypeLib * This,
    /* [out] */ LPTLIBATTR *ppTLibAttr,
    /* [out] */ CLEANLOCALSTORAGE *pDummy)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2212],
                  ( unsigned char * )This,
                  ppTLibAttr,
                  pDummy);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeLib_RemoteGetLibAttr_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeLib *This;
        LPTLIBATTR *ppTLibAttr;
        CLEANLOCALSTORAGE *pDummy;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeLib_GetLibAttr_Stub(
                                   (ITypeLib *) pParamStruct->This,
                                   pParamStruct->ppTLibAttr,
                                   pParamStruct->pDummy);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteGetDocumentation_Proxy( 
    ITypeLib * This,
    /* [in] */ INT index,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR *pBstrName,
    /* [out] */ BSTR *pBstrDocString,
    /* [out] */ DWORD *pdwHelpContext,
    /* [out] */ BSTR *pBstrHelpFile)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2294],
                  ( unsigned char * )This,
                  index,
                  refPtrFlags,
                  pBstrName,
                  pBstrDocString,
                  pdwHelpContext,
                  pBstrHelpFile);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeLib_RemoteGetDocumentation_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeLib *This;
        INT index;
        char Pad0[4];
        DWORD refPtrFlags;
        char Pad1[4];
        BSTR *pBstrName;
        BSTR *pBstrDocString;
        DWORD *pdwHelpContext;
        BSTR *pBstrHelpFile;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeLib_GetDocumentation_Stub(
                                         (ITypeLib *) pParamStruct->This,
                                         pParamStruct->index,
                                         pParamStruct->refPtrFlags,
                                         pParamStruct->pBstrName,
                                         pParamStruct->pBstrDocString,
                                         pParamStruct->pdwHelpContext,
                                         pParamStruct->pBstrHelpFile);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteIsName_Proxy( 
    ITypeLib * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [out] */ BOOL *pfName,
    /* [out] */ BSTR *pBstrLibName)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2362],
                  ( unsigned char * )This,
                  szNameBuf,
                  lHashVal,
                  pfName,
                  pBstrLibName);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeLib_RemoteIsName_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeLib *This;
        LPOLESTR szNameBuf;
        ULONG lHashVal;
        char Pad0[4];
        BOOL *pfName;
        BSTR *pBstrLibName;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeLib_IsName_Stub(
                               (ITypeLib *) pParamStruct->This,
                               pParamStruct->szNameBuf,
                               pParamStruct->lHashVal,
                               pParamStruct->pfName,
                               pParamStruct->pBstrLibName);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteFindName_Proxy( 
    ITypeLib * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [length_is][size_is][out] */ ITypeInfo **ppTInfo,
    /* [length_is][size_is][out] */ MEMBERID *rgMemId,
    /* [out][in] */ USHORT *pcFound,
    /* [out] */ BSTR *pBstrLibName)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2418],
                  ( unsigned char * )This,
                  szNameBuf,
                  lHashVal,
                  ppTInfo,
                  rgMemId,
                  pcFound,
                  pBstrLibName);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeLib_RemoteFindName_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeLib *This;
        LPOLESTR szNameBuf;
        ULONG lHashVal;
        char Pad0[4];
        ITypeInfo **ppTInfo;
        MEMBERID *rgMemId;
        USHORT *pcFound;
        BSTR *pBstrLibName;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeLib_FindName_Stub(
                                 (ITypeLib *) pParamStruct->This,
                                 pParamStruct->szNameBuf,
                                 pParamStruct->lHashVal,
                                 pParamStruct->ppTInfo,
                                 pParamStruct->rgMemId,
                                 pParamStruct->pcFound,
                                 pParamStruct->pBstrLibName);
    
}

void __RPC_API
ITypeLib_LocalReleaseTLibAttr_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeLib *This;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeLib_ReleaseTLibAttr_Stub((ITypeLib *) pParamStruct->This);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITypeLib2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITypeLib2_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib2_RemoteGetLibStatistics_Proxy( 
    ITypeLib2 * This,
    /* [out] */ ULONG *pcUniqueNames,
    /* [out] */ ULONG *pcchUniqueNames)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2562],
                  ( unsigned char * )This,
                  pcUniqueNames,
                  pcchUniqueNames);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeLib2_RemoteGetLibStatistics_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeLib2 *This;
        ULONG *pcUniqueNames;
        ULONG *pcchUniqueNames;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeLib2_GetLibStatistics_Stub(
                                          (ITypeLib2 *) pParamStruct->This,
                                          pParamStruct->pcUniqueNames,
                                          pParamStruct->pcchUniqueNames);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib2_RemoteGetDocumentation2_Proxy( 
    ITypeLib2 * This,
    /* [in] */ INT index,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR *pbstrHelpString,
    /* [out] */ DWORD *pdwHelpStringContext,
    /* [out] */ BSTR *pbstrHelpStringDll)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[2606],
                  ( unsigned char * )This,
                  index,
                  lcid,
                  refPtrFlags,
                  pbstrHelpString,
                  pdwHelpStringContext,
                  pbstrHelpStringDll);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITypeLib2_RemoteGetDocumentation2_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITypeLib2 *This;
        INT index;
        char Pad0[4];
        LCID lcid;
        char Pad1[4];
        DWORD refPtrFlags;
        char Pad2[4];
        BSTR *pbstrHelpString;
        DWORD *pdwHelpStringContext;
        BSTR *pbstrHelpStringDll;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITypeLib2_GetDocumentation2_Stub(
                                           (ITypeLib2 *) pParamStruct->This,
                                           pParamStruct->index,
                                           pParamStruct->lcid,
                                           pParamStruct->refPtrFlags,
                                           pParamStruct->pbstrHelpString,
                                           pParamStruct->pdwHelpStringContext,
                                           pParamStruct->pbstrHelpStringDll);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IErrorInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IErrorInfo_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICreateErrorInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICreateErrorInfo_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISupportErrorInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISupportErrorInfo_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITypeFactory_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITypeFactory_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IErrorLog_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IErrorLog_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IPropertyBag_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IPropertyBag_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyBag_RemoteRead_Proxy( 
    IPropertyBag * This,
    /* [in] */ LPCOLESTR pszPropName,
    /* [out] */ VARIANT *pVar,
    /* [in] */ IErrorLog *pErrorLog,
    /* [in] */ DWORD varType,
    /* [in] */ IUnknown *pUnkObj)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[3186],
                  ( unsigned char * )This,
                  pszPropName,
                  pVar,
                  pErrorLog,
                  varType,
                  pUnkObj);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IPropertyBag_RemoteRead_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IPropertyBag *This;
        LPCOLESTR pszPropName;
        VARIANT *pVar;
        IErrorLog *pErrorLog;
        DWORD varType;
        char Pad0[4];
        IUnknown *pUnkObj;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IPropertyBag_Read_Stub(
                                 (IPropertyBag *) pParamStruct->This,
                                 pParamStruct->pszPropName,
                                 pParamStruct->pVar,
                                 pParamStruct->pErrorLog,
                                 pParamStruct->varType,
                                 pParamStruct->pUnkObj);
    
}


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure RemoteGetTypeInfoCount */


	/* Procedure GetTypeInfoCount */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 16 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pcTInfo */


	/* Parameter pctinfo */

/* 26 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 32 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeInfo */

/* 38 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 40 */	NdrFcLong( 0x0 ),	/* 0 */
/* 44 */	NdrFcShort( 0x4 ),	/* 4 */
/* 46 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 48 */	NdrFcShort( 0x10 ),	/* 16 */
/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
/* 52 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 54 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter iTInfo */

/* 64 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 66 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 68 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lcid */

/* 70 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 72 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 74 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppTInfo */

/* 76 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 78 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 80 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 82 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 84 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 86 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetIDsOfNames */

/* 88 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 90 */	NdrFcLong( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x5 ),	/* 5 */
/* 96 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 98 */	NdrFcShort( 0x54 ),	/* 84 */
/* 100 */	NdrFcShort( 0x8 ),	/* 8 */
/* 102 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 104 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 106 */	NdrFcShort( 0x1 ),	/* 1 */
/* 108 */	NdrFcShort( 0x1 ),	/* 1 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 114 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 116 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 118 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter rgszNames */

/* 120 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 122 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 124 */	NdrFcShort( 0x36 ),	/* Type Offset=54 */

	/* Parameter cNames */

/* 126 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 128 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lcid */

/* 132 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 134 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgDispId */

/* 138 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 140 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 142 */	NdrFcShort( 0x50 ),	/* Type Offset=80 */

	/* Return value */

/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 146 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteInvoke */

/* 150 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0x6 ),	/* 6 */
/* 158 */	NdrFcShort( 0x68 ),	/* ia64 Stack size/offset = 104 */
/* 160 */	NdrFcShort( 0x64 ),	/* 100 */
/* 162 */	NdrFcShort( 0x24 ),	/* 36 */
/* 164 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xc,		/* 12 */
/* 166 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 168 */	NdrFcShort( 0x44 ),	/* 68 */
/* 170 */	NdrFcShort( 0x44 ),	/* 68 */
/* 172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dispIdMember */

/* 176 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 178 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 180 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter riid */

/* 182 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 184 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 186 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter lcid */

/* 188 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 190 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwFlags */

/* 194 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 196 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pDispParams */

/* 200 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 202 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 204 */	NdrFcShort( 0x42a ),	/* Type Offset=1066 */

	/* Parameter pVarResult */

/* 206 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 208 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 210 */	NdrFcShort( 0x448 ),	/* Type Offset=1096 */

	/* Parameter pExcepInfo */

/* 212 */	NdrFcShort( 0xc113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=48 */
/* 214 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 216 */	NdrFcShort( 0x464 ),	/* Type Offset=1124 */

	/* Parameter pArgErr */

/* 218 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 220 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cVarRef */

/* 224 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 226 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgVarRefIdx */

/* 230 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 232 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 234 */	NdrFcShort( 0x484 ),	/* Type Offset=1156 */

	/* Parameter rgVarRef */

/* 236 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 238 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 240 */	NdrFcShort( 0x494 ),	/* Type Offset=1172 */

	/* Return value */

/* 242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 244 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteNext */

/* 248 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 254 */	NdrFcShort( 0x3 ),	/* 3 */
/* 256 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 258 */	NdrFcShort( 0x8 ),	/* 8 */
/* 260 */	NdrFcShort( 0x24 ),	/* 36 */
/* 262 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 264 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 266 */	NdrFcShort( 0x21 ),	/* 33 */
/* 268 */	NdrFcShort( 0x0 ),	/* 0 */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 274 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 276 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 278 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgVar */

/* 280 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 282 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 284 */	NdrFcShort( 0x4ae ),	/* Type Offset=1198 */

	/* Parameter pCeltFetched */

/* 286 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 288 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 290 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 292 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 294 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Skip */

/* 298 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 300 */	NdrFcLong( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x4 ),	/* 4 */
/* 306 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 308 */	NdrFcShort( 0x8 ),	/* 8 */
/* 310 */	NdrFcShort( 0x8 ),	/* 8 */
/* 312 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 314 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 316 */	NdrFcShort( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x0 ),	/* 0 */
/* 320 */	NdrFcShort( 0x0 ),	/* 0 */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 324 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 326 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 330 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 332 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 334 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */

/* 336 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
/* 342 */	NdrFcShort( 0x5 ),	/* 5 */
/* 344 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 348 */	NdrFcShort( 0x8 ),	/* 8 */
/* 350 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 352 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 364 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 368 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x6 ),	/* 6 */
/* 376 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 384 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppEnum */

/* 394 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 396 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 398 */	NdrFcShort( 0x4c4 ),	/* Type Offset=1220 */

	/* Return value */

/* 400 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 402 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 404 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteBind */

/* 406 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 408 */	NdrFcLong( 0x0 ),	/* 0 */
/* 412 */	NdrFcShort( 0x3 ),	/* 3 */
/* 414 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 416 */	NdrFcShort( 0xe ),	/* 14 */
/* 418 */	NdrFcShort( 0x40 ),	/* 64 */
/* 420 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 422 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 424 */	NdrFcShort( 0x89 ),	/* 137 */
/* 426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 430 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter szName */

/* 432 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 434 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 436 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Parameter lHashVal */

/* 438 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 440 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 442 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter wFlags */

/* 444 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 446 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 448 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Parameter ppTInfo */

/* 450 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 452 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 454 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter pDescKind */

/* 456 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 458 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 460 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter ppFuncDesc */

/* 462 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 464 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 466 */	NdrFcShort( 0x4e2 ),	/* Type Offset=1250 */

	/* Parameter ppVarDesc */

/* 468 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 470 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 472 */	NdrFcShort( 0x5c2 ),	/* Type Offset=1474 */

	/* Parameter ppTypeComp */

/* 474 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 476 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 478 */	NdrFcShort( 0x612 ),	/* Type Offset=1554 */

	/* Parameter pDummy */

/* 480 */	NdrFcShort( 0x6112 ),	/* Flags:  must free, out, simple ref, srv alloc size=24 */
/* 482 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 484 */	NdrFcShort( 0x62e ),	/* Type Offset=1582 */

	/* Return value */

/* 486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 488 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteBindType */

/* 492 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 498 */	NdrFcShort( 0x4 ),	/* 4 */
/* 500 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 502 */	NdrFcShort( 0x8 ),	/* 8 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 508 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */
/* 516 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter szName */

/* 518 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 520 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 522 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Parameter lHashVal */

/* 524 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 526 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 528 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppTInfo */

/* 530 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 532 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 534 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 536 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 538 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 540 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetTypeAttr */

/* 542 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 544 */	NdrFcLong( 0x0 ),	/* 0 */
/* 548 */	NdrFcShort( 0x3 ),	/* 3 */
/* 550 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 552 */	NdrFcShort( 0x0 ),	/* 0 */
/* 554 */	NdrFcShort( 0x24 ),	/* 36 */
/* 556 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 558 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 560 */	NdrFcShort( 0x2 ),	/* 2 */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppTypeAttr */

/* 568 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 570 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 572 */	NdrFcShort( 0x638 ),	/* Type Offset=1592 */

	/* Parameter pDummy */

/* 574 */	NdrFcShort( 0x6112 ),	/* Flags:  must free, out, simple ref, srv alloc size=24 */
/* 576 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 578 */	NdrFcShort( 0x67a ),	/* Type Offset=1658 */

	/* Return value */

/* 580 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 582 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeComp */

/* 586 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 588 */	NdrFcLong( 0x0 ),	/* 0 */
/* 592 */	NdrFcShort( 0x4 ),	/* 4 */
/* 594 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 598 */	NdrFcShort( 0x8 ),	/* 8 */
/* 600 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 602 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 604 */	NdrFcShort( 0x0 ),	/* 0 */
/* 606 */	NdrFcShort( 0x0 ),	/* 0 */
/* 608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppTComp */

/* 612 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 614 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 616 */	NdrFcShort( 0x612 ),	/* Type Offset=1554 */

	/* Return value */

/* 618 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 620 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 622 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetFuncDesc */

/* 624 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 626 */	NdrFcLong( 0x0 ),	/* 0 */
/* 630 */	NdrFcShort( 0x5 ),	/* 5 */
/* 632 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 634 */	NdrFcShort( 0x8 ),	/* 8 */
/* 636 */	NdrFcShort( 0x24 ),	/* 36 */
/* 638 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 640 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 642 */	NdrFcShort( 0x46 ),	/* 70 */
/* 644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 650 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 652 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 654 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppFuncDesc */

/* 656 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 658 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 660 */	NdrFcShort( 0x4e2 ),	/* Type Offset=1250 */

	/* Parameter pDummy */

/* 662 */	NdrFcShort( 0x6112 ),	/* Flags:  must free, out, simple ref, srv alloc size=24 */
/* 664 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 666 */	NdrFcShort( 0x68a ),	/* Type Offset=1674 */

	/* Return value */

/* 668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 670 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetVarDesc */

/* 674 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 676 */	NdrFcLong( 0x0 ),	/* 0 */
/* 680 */	NdrFcShort( 0x6 ),	/* 6 */
/* 682 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 684 */	NdrFcShort( 0x8 ),	/* 8 */
/* 686 */	NdrFcShort( 0x24 ),	/* 36 */
/* 688 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 690 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 692 */	NdrFcShort( 0x43 ),	/* 67 */
/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 700 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 702 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 704 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppVarDesc */

/* 706 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 708 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 710 */	NdrFcShort( 0x5c2 ),	/* Type Offset=1474 */

	/* Parameter pDummy */

/* 712 */	NdrFcShort( 0x6112 ),	/* Flags:  must free, out, simple ref, srv alloc size=24 */
/* 714 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 716 */	NdrFcShort( 0x69a ),	/* Type Offset=1690 */

	/* Return value */

/* 718 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 720 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 722 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetNames */

/* 724 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 726 */	NdrFcLong( 0x0 ),	/* 0 */
/* 730 */	NdrFcShort( 0x7 ),	/* 7 */
/* 732 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 734 */	NdrFcShort( 0x10 ),	/* 16 */
/* 736 */	NdrFcShort( 0x24 ),	/* 36 */
/* 738 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 740 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 742 */	NdrFcShort( 0x2 ),	/* 2 */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x0 ),	/* 0 */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter memid */

/* 750 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 752 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 754 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgBstrNames */

/* 756 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 758 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 760 */	NdrFcShort( 0x6a8 ),	/* Type Offset=1704 */

	/* Parameter cMaxNames */

/* 762 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 764 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 766 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcNames */

/* 768 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 770 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 772 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 774 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 776 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRefTypeOfImplType */

/* 780 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 782 */	NdrFcLong( 0x0 ),	/* 0 */
/* 786 */	NdrFcShort( 0x8 ),	/* 8 */
/* 788 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 790 */	NdrFcShort( 0x8 ),	/* 8 */
/* 792 */	NdrFcShort( 0x24 ),	/* 36 */
/* 794 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 796 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 798 */	NdrFcShort( 0x0 ),	/* 0 */
/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 802 */	NdrFcShort( 0x0 ),	/* 0 */
/* 804 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 806 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 808 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRefType */

/* 812 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 814 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 816 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 818 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 820 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 822 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetImplTypeFlags */

/* 824 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 826 */	NdrFcLong( 0x0 ),	/* 0 */
/* 830 */	NdrFcShort( 0x9 ),	/* 9 */
/* 832 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 834 */	NdrFcShort( 0x8 ),	/* 8 */
/* 836 */	NdrFcShort( 0x24 ),	/* 36 */
/* 838 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 840 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 842 */	NdrFcShort( 0x0 ),	/* 0 */
/* 844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 846 */	NdrFcShort( 0x0 ),	/* 0 */
/* 848 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 850 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 852 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 854 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pImplTypeFlags */

/* 856 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 858 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 860 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 862 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 864 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 866 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LocalGetIDsOfNames */

/* 868 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 870 */	NdrFcLong( 0x0 ),	/* 0 */
/* 874 */	NdrFcShort( 0xa ),	/* 10 */
/* 876 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 878 */	NdrFcShort( 0x0 ),	/* 0 */
/* 880 */	NdrFcShort( 0x8 ),	/* 8 */
/* 882 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 884 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 890 */	NdrFcShort( 0x0 ),	/* 0 */
/* 892 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 894 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 896 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 898 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LocalInvoke */

/* 900 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 902 */	NdrFcLong( 0x0 ),	/* 0 */
/* 906 */	NdrFcShort( 0xb ),	/* 11 */
/* 908 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 910 */	NdrFcShort( 0x0 ),	/* 0 */
/* 912 */	NdrFcShort( 0x8 ),	/* 8 */
/* 914 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 916 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 920 */	NdrFcShort( 0x0 ),	/* 0 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */
/* 924 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 926 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 928 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 930 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetDocumentation */

/* 932 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 934 */	NdrFcLong( 0x0 ),	/* 0 */
/* 938 */	NdrFcShort( 0xc ),	/* 12 */
/* 940 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 942 */	NdrFcShort( 0x10 ),	/* 16 */
/* 944 */	NdrFcShort( 0x24 ),	/* 36 */
/* 946 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 948 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 950 */	NdrFcShort( 0x3 ),	/* 3 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */
/* 956 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter memid */

/* 958 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 960 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 962 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter refPtrFlags */

/* 964 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 966 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 968 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pBstrName */

/* 970 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 972 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 974 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Parameter pBstrDocString */

/* 976 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 978 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 980 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Parameter pdwHelpContext */

/* 982 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 984 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 986 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pBstrHelpFile */

/* 988 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 990 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 992 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 994 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 996 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 998 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetDllEntry */

/* 1000 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1002 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0xd ),	/* 13 */
/* 1008 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1010 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1012 */	NdrFcShort( 0x22 ),	/* 34 */
/* 1014 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 1016 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1018 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1020 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1022 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1024 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter memid */

/* 1026 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1028 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1030 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter invKind */

/* 1032 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1034 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1036 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter refPtrFlags */

/* 1038 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1040 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1042 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pBstrDllName */

/* 1044 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1046 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1048 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Parameter pBstrName */

/* 1050 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1052 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1054 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Parameter pwOrdinal */

/* 1056 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1058 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1060 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 1062 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1064 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1066 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRefTypeInfo */

/* 1068 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1070 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1074 */	NdrFcShort( 0xe ),	/* 14 */
/* 1076 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1078 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1080 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1082 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1084 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1086 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1088 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1092 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hRefType */

/* 1094 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1096 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppTInfo */

/* 1100 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1102 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1104 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1108 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LocalAddressOfMember */

/* 1112 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1118 */	NdrFcShort( 0xf ),	/* 15 */
/* 1120 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1126 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1128 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1130 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1140 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateInstance */

/* 1144 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1150 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1152 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1154 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1158 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1160 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1162 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1168 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 1170 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1172 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1174 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter ppvObj */

/* 1176 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1178 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1180 */	NdrFcShort( 0x6c6 ),	/* Type Offset=1734 */

	/* Return value */

/* 1182 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1184 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMops */

/* 1188 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1190 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1194 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1196 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1198 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1200 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1202 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1204 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1206 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1212 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter memid */

/* 1214 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1216 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1218 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pBstrMops */

/* 1220 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1222 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1224 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 1226 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1228 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1230 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetContainingTypeLib */

/* 1232 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1234 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1238 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1240 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1244 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1246 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1248 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1254 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1256 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppTLib */

/* 1258 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1260 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1262 */	NdrFcShort( 0x6d2 ),	/* Type Offset=1746 */

	/* Parameter pIndex */

/* 1264 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1266 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1272 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LocalReleaseTypeAttr */

/* 1276 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1282 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1284 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1288 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1290 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1292 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1298 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1300 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1302 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1304 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1306 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LocalReleaseFuncDesc */

/* 1308 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1310 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1314 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1316 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1318 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1320 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1322 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1324 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1332 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1334 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1336 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LocalReleaseVarDesc */

/* 1340 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1342 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1346 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1348 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1354 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1356 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1364 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1366 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1368 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeKind */

/* 1372 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1374 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1378 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1380 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1384 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1386 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1388 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1396 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pTypeKind */

/* 1398 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1400 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1402 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 1404 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1406 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1408 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeFlags */

/* 1410 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1412 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1416 */	NdrFcShort( 0x17 ),	/* 23 */
/* 1418 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1422 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1424 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1426 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1430 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1434 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pTypeFlags */

/* 1436 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1438 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1440 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1442 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1444 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1446 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFuncIndexOfMemId */

/* 1448 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1450 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1454 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1456 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1458 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1460 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1462 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 1464 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1472 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter memid */

/* 1474 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1476 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1478 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter invKind */

/* 1480 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1482 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1484 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Parameter pFuncIndex */

/* 1486 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1488 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1492 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1494 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1496 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVarIndexOfMemId */

/* 1498 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1500 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1504 */	NdrFcShort( 0x19 ),	/* 25 */
/* 1506 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1510 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1512 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 1514 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1516 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1518 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1522 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter memid */

/* 1524 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1526 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1528 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pVarIndex */

/* 1530 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1532 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1534 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1536 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1538 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1540 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCustData */

/* 1542 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1544 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1548 */	NdrFcShort( 0x1a ),	/* 26 */
/* 1550 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1552 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1554 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1556 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1558 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1560 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1566 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter guid */

/* 1568 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1570 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1572 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter pVarVal */

/* 1574 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 1576 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1578 */	NdrFcShort( 0x448 ),	/* Type Offset=1096 */

	/* Return value */

/* 1580 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1582 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFuncCustData */

/* 1586 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1588 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1592 */	NdrFcShort( 0x1b ),	/* 27 */
/* 1594 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1596 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1598 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1600 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1602 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1604 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1606 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1610 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 1612 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1614 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1616 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guid */

/* 1618 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1620 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1622 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter pVarVal */

/* 1624 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 1626 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1628 */	NdrFcShort( 0x448 ),	/* Type Offset=1096 */

	/* Return value */

/* 1630 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1632 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetParamCustData */

/* 1636 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1638 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1642 */	NdrFcShort( 0x1c ),	/* 28 */
/* 1644 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1646 */	NdrFcShort( 0x54 ),	/* 84 */
/* 1648 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1650 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 1652 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1654 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1656 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1660 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter indexFunc */

/* 1662 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1664 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter indexParam */

/* 1668 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1670 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guid */

/* 1674 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1676 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1678 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter pVarVal */

/* 1680 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 1682 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1684 */	NdrFcShort( 0x448 ),	/* Type Offset=1096 */

	/* Return value */

/* 1686 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1688 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1690 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVarCustData */

/* 1692 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1694 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1698 */	NdrFcShort( 0x1d ),	/* 29 */
/* 1700 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1702 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1704 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1706 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1708 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1710 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1712 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1716 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 1718 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1720 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1722 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guid */

/* 1724 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1726 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1728 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter pVarVal */

/* 1730 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 1732 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1734 */	NdrFcShort( 0x448 ),	/* Type Offset=1096 */

	/* Return value */

/* 1736 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1738 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1740 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetImplTypeCustData */

/* 1742 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1744 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1748 */	NdrFcShort( 0x1e ),	/* 30 */
/* 1750 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1752 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1754 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1756 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1758 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1760 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1762 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1766 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 1768 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1770 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1772 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guid */

/* 1774 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1776 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1778 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter pVarVal */

/* 1780 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 1782 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1784 */	NdrFcShort( 0x448 ),	/* Type Offset=1096 */

	/* Return value */

/* 1786 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1788 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1790 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetDocumentation2 */

/* 1792 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1794 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1798 */	NdrFcShort( 0x1f ),	/* 31 */
/* 1800 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1802 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1804 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1806 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 1808 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1810 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1816 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter memid */

/* 1818 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1820 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1822 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lcid */

/* 1824 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1826 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1828 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter refPtrFlags */

/* 1830 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1832 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1834 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrHelpString */

/* 1836 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1838 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1840 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Parameter pdwHelpStringContext */

/* 1842 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1844 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1846 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrHelpStringDll */

/* 1848 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1850 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1852 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 1854 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1856 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1858 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllCustData */

/* 1860 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1862 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1866 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1868 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1870 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1872 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1874 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 1876 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1878 */	NdrFcShort( 0x21 ),	/* 33 */
/* 1880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1882 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1884 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pCustData */

/* 1886 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 1888 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1890 */	NdrFcShort( 0x714 ),	/* Type Offset=1812 */

	/* Return value */

/* 1892 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1894 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1896 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllFuncCustData */

/* 1898 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1900 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1904 */	NdrFcShort( 0x21 ),	/* 33 */
/* 1906 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1908 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1910 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1912 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1914 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1916 */	NdrFcShort( 0x21 ),	/* 33 */
/* 1918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1920 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1922 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 1924 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1926 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1928 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pCustData */

/* 1930 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 1932 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1934 */	NdrFcShort( 0x714 ),	/* Type Offset=1812 */

	/* Return value */

/* 1936 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1938 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1940 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllParamCustData */

/* 1942 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1944 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1948 */	NdrFcShort( 0x22 ),	/* 34 */
/* 1950 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1952 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1954 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1956 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1958 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1960 */	NdrFcShort( 0x21 ),	/* 33 */
/* 1962 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1966 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter indexFunc */

/* 1968 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1970 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1972 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter indexParam */

/* 1974 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1976 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1978 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pCustData */

/* 1980 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 1982 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1984 */	NdrFcShort( 0x714 ),	/* Type Offset=1812 */

	/* Return value */

/* 1986 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1988 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1990 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllVarCustData */

/* 1992 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1994 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1998 */	NdrFcShort( 0x23 ),	/* 35 */
/* 2000 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2002 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2004 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2006 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 2008 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2010 */	NdrFcShort( 0x21 ),	/* 33 */
/* 2012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2016 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 2018 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2020 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2022 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pCustData */

/* 2024 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 2026 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2028 */	NdrFcShort( 0x714 ),	/* Type Offset=1812 */

	/* Return value */

/* 2030 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2032 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2034 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllImplTypeCustData */

/* 2036 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2038 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2042 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2044 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2046 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2048 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2050 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 2052 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2054 */	NdrFcShort( 0x21 ),	/* 33 */
/* 2056 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2058 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2060 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 2062 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2064 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2066 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pCustData */

/* 2068 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 2070 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2072 */	NdrFcShort( 0x714 ),	/* Type Offset=1812 */

	/* Return value */

/* 2074 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2076 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeInfo */

/* 2080 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2082 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2086 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2088 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2090 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2092 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2094 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 2096 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2100 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2104 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 2106 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2108 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppTInfo */

/* 2112 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2114 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2116 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2118 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2120 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2122 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeInfoType */

/* 2124 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2126 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2130 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2132 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2134 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2136 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2138 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 2140 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2148 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 2150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2152 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pTKind */

/* 2156 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2158 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2160 */	0xe,		/* FC_ENUM32 */
			0x0,		/* 0 */

	/* Return value */

/* 2162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2164 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeInfoOfGuid */

/* 2168 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2174 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2176 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2178 */	NdrFcShort( 0x44 ),	/* 68 */
/* 2180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2182 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 2184 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2192 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter guid */

/* 2194 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2196 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2198 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter ppTinfo */

/* 2200 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2202 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2204 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2206 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2208 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetLibAttr */

/* 2212 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2214 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2218 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2220 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2224 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2226 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 2228 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2236 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppTLibAttr */

/* 2238 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2240 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2242 */	NdrFcShort( 0x724 ),	/* Type Offset=1828 */

	/* Parameter pDummy */

/* 2244 */	NdrFcShort( 0x6112 ),	/* Flags:  must free, out, simple ref, srv alloc size=24 */
/* 2246 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2248 */	NdrFcShort( 0x746 ),	/* Type Offset=1862 */

	/* Return value */

/* 2250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2252 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeComp */

/* 2256 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2264 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2268 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2270 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 2272 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2278 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2280 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppTComp */

/* 2282 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2284 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2286 */	NdrFcShort( 0x612 ),	/* Type Offset=1554 */

	/* Return value */

/* 2288 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2290 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2292 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetDocumentation */

/* 2294 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2296 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2300 */	NdrFcShort( 0x9 ),	/* 9 */
/* 2302 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 2304 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2306 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2308 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 2310 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2312 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2316 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2318 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 2320 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2322 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2324 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter refPtrFlags */

/* 2326 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2328 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pBstrName */

/* 2332 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2334 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2336 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Parameter pBstrDocString */

/* 2338 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2340 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2342 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Parameter pdwHelpContext */

/* 2344 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2346 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2348 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pBstrHelpFile */

/* 2350 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2352 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2354 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 2356 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2358 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2360 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteIsName */

/* 2362 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2364 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2368 */	NdrFcShort( 0xa ),	/* 10 */
/* 2370 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2372 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2374 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2376 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2378 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2380 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2386 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter szNameBuf */

/* 2388 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2390 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2392 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Parameter lHashVal */

/* 2394 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2396 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2398 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pfName */

/* 2400 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2402 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2404 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pBstrLibName */

/* 2406 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2408 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2410 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 2412 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2414 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2416 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteFindName */

/* 2418 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2420 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2424 */	NdrFcShort( 0xb ),	/* 11 */
/* 2426 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 2428 */	NdrFcShort( 0x22 ),	/* 34 */
/* 2430 */	NdrFcShort( 0x22 ),	/* 34 */
/* 2432 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 2434 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2436 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2442 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter szNameBuf */

/* 2444 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2446 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2448 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Parameter lHashVal */

/* 2450 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2452 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2454 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppTInfo */

/* 2456 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 2458 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2460 */	NdrFcShort( 0x754 ),	/* Type Offset=1876 */

	/* Parameter rgMemId */

/* 2462 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 2464 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2466 */	NdrFcShort( 0x76e ),	/* Type Offset=1902 */

	/* Parameter pcFound */

/* 2468 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2470 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2472 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Parameter pBstrLibName */

/* 2474 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2476 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2478 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 2480 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2482 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LocalReleaseTLibAttr */

/* 2486 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2488 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2492 */	NdrFcShort( 0xc ),	/* 12 */
/* 2494 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2496 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2498 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2500 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 2502 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2504 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2506 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2508 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2510 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 2512 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2514 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2516 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCustData */

/* 2518 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2520 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2524 */	NdrFcShort( 0xd ),	/* 13 */
/* 2526 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2528 */	NdrFcShort( 0x44 ),	/* 68 */
/* 2530 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2532 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 2534 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2536 */	NdrFcShort( 0x20 ),	/* 32 */
/* 2538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2540 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2542 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter guid */

/* 2544 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2546 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2548 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter pVarVal */

/* 2550 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 2552 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2554 */	NdrFcShort( 0x448 ),	/* Type Offset=1096 */

	/* Return value */

/* 2556 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2558 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2560 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetLibStatistics */

/* 2562 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2564 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2568 */	NdrFcShort( 0xe ),	/* 14 */
/* 2570 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2574 */	NdrFcShort( 0x40 ),	/* 64 */
/* 2576 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 2578 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2584 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2586 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pcUniqueNames */

/* 2588 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2590 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2592 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchUniqueNames */

/* 2594 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2596 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2598 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2600 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2602 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2604 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetDocumentation2 */

/* 2606 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2608 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2612 */	NdrFcShort( 0xf ),	/* 15 */
/* 2614 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 2616 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2618 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2620 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 2622 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2624 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2626 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2628 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2630 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter index */

/* 2632 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2634 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2636 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lcid */

/* 2638 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2640 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2642 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter refPtrFlags */

/* 2644 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2646 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2648 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrHelpString */

/* 2650 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2652 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2654 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Parameter pdwHelpStringContext */

/* 2656 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2658 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrHelpStringDll */

/* 2662 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2664 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2666 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 2668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2670 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllCustData */

/* 2674 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2676 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2680 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2682 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2688 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 2690 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2692 */	NdrFcShort( 0x21 ),	/* 33 */
/* 2694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2698 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pCustData */

/* 2700 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 2702 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2704 */	NdrFcShort( 0x714 ),	/* Type Offset=1812 */

	/* Return value */

/* 2706 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2708 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2710 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetGUID */

/* 2712 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2714 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2718 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2720 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2722 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2724 */	NdrFcShort( 0x4c ),	/* 76 */
/* 2726 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2728 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2734 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2736 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pGUID */

/* 2738 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 2740 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2742 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 2744 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2746 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2748 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSource */

/* 2750 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2752 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2756 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2758 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2760 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2762 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2764 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 2766 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2768 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2772 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2774 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pBstrSource */

/* 2776 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2778 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2780 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 2782 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2784 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDescription */

/* 2788 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2790 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2794 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2796 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2798 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2800 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2802 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 2804 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2806 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2808 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2810 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2812 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pBstrDescription */

/* 2814 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2816 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2818 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 2820 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2822 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2824 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHelpFile */

/* 2826 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2828 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2832 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2834 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2838 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2840 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 2842 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2844 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2846 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2848 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2850 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pBstrHelpFile */

/* 2852 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2854 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2856 */	NdrFcShort( 0x45a ),	/* Type Offset=1114 */

	/* Return value */

/* 2858 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2860 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHelpContext */

/* 2864 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2866 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2870 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2872 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2874 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2876 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2878 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2880 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2882 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2884 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2888 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pdwHelpContext */

/* 2890 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2892 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2894 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2896 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2898 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2900 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure InterfaceSupportsErrorInfo */


	/* Procedure SetGUID */

/* 2902 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2904 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2908 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2910 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2912 */	NdrFcShort( 0x44 ),	/* 68 */
/* 2914 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2916 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2918 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2920 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2922 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2924 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2926 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */


	/* Parameter rguid */

/* 2928 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2930 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2932 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */


	/* Return value */

/* 2934 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2936 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2938 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetSource */

/* 2940 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2942 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2946 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2948 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2950 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2952 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2954 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 2956 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2958 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2960 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2962 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2964 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter szSource */

/* 2966 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2968 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2970 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Return value */

/* 2972 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2974 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2976 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetDescription */

/* 2978 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2980 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2984 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2986 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2988 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2990 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2992 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 2994 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2998 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3000 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3002 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter szDescription */

/* 3004 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3006 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3008 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Return value */

/* 3010 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3012 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3014 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetHelpFile */

/* 3016 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3018 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3022 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3024 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3028 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3030 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 3032 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3034 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3036 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3038 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3040 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter szHelpFile */

/* 3042 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3044 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3046 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Return value */

/* 3048 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3050 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3052 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetHelpContext */

/* 3054 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3056 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3060 */	NdrFcShort( 0x7 ),	/* 7 */
/* 3062 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3064 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3066 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3068 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3070 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3072 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3074 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3076 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3078 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dwHelpContext */

/* 3080 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3082 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3084 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3088 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateFromTypeInfo */

/* 3092 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3098 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3100 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3102 */	NdrFcShort( 0x44 ),	/* 68 */
/* 3104 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3106 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 3108 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 3110 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3116 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pTypeInfo */

/* 3118 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3120 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3122 */	NdrFcShort( 0xa ),	/* Type Offset=10 */

	/* Parameter riid */

/* 3124 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 3126 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3128 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter ppv */

/* 3130 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3132 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3134 */	NdrFcShort( 0x788 ),	/* Type Offset=1928 */

	/* Return value */

/* 3136 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3138 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddError */

/* 3142 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3144 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3148 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3150 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3156 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 3158 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3162 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3166 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pszPropName */

/* 3168 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3170 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3172 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Parameter pExcepInfo */

/* 3174 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3176 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3178 */	NdrFcShort( 0x464 ),	/* Type Offset=1124 */

	/* Return value */

/* 3180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3182 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteRead */

/* 3186 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3188 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3192 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3194 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 3196 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3198 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3200 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 3202 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 3204 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3210 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pszPropName */

/* 3212 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3214 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3216 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Parameter pVar */

/* 3218 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 3220 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3222 */	NdrFcShort( 0x448 ),	/* Type Offset=1096 */

	/* Parameter pErrorLog */

/* 3224 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3226 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3228 */	NdrFcShort( 0x798 ),	/* Type Offset=1944 */

	/* Parameter varType */

/* 3230 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3232 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pUnkObj */

/* 3236 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3238 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3240 */	NdrFcShort( 0x196 ),	/* Type Offset=406 */

	/* Return value */

/* 3242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3244 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Write */

/* 3248 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3254 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3256 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3262 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 3264 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3268 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3272 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pszPropName */

/* 3274 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3276 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3278 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Parameter pVar */

/* 3280 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3282 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3284 */	NdrFcShort( 0x3fe ),	/* Type Offset=1022 */

	/* Return value */

/* 3286 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3288 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3290 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/*  4 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
/* 10 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 12 */	NdrFcLong( 0x20401 ),	/* 132097 */
/* 16 */	NdrFcShort( 0x0 ),	/* 0 */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 22 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 24 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 26 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 28 */	
			0x11, 0x0,	/* FC_RP */
/* 30 */	NdrFcShort( 0x8 ),	/* Offset= 8 (38) */
/* 32 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 34 */	NdrFcShort( 0x8 ),	/* 8 */
/* 36 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 38 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 40 */	NdrFcShort( 0x10 ),	/* 16 */
/* 42 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 44 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 46 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (32) */
			0x5b,		/* FC_END */
/* 50 */	
			0x11, 0x0,	/* FC_RP */
/* 52 */	NdrFcShort( 0x2 ),	/* Offset= 2 (54) */
/* 54 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 60 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 62 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 64 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 68 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 70 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 72 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 74 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 76 */	
			0x11, 0x0,	/* FC_RP */
/* 78 */	NdrFcShort( 0x2 ),	/* Offset= 2 (80) */
/* 80 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 82 */	NdrFcShort( 0x4 ),	/* 4 */
/* 84 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 86 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 88 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 90 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 92 */	
			0x11, 0x0,	/* FC_RP */
/* 94 */	NdrFcShort( 0x3cc ),	/* Offset= 972 (1066) */
/* 96 */	
			0x12, 0x0,	/* FC_UP */
/* 98 */	NdrFcShort( 0x388 ),	/* Offset= 904 (1002) */
/* 100 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 102 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 104 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 106 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 108 */	NdrFcShort( 0x2 ),	/* Offset= 2 (110) */
/* 110 */	NdrFcShort( 0x10 ),	/* 16 */
/* 112 */	NdrFcShort( 0x2b ),	/* 43 */
/* 114 */	NdrFcLong( 0x3 ),	/* 3 */
/* 118 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 120 */	NdrFcLong( 0x11 ),	/* 17 */
/* 124 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 126 */	NdrFcLong( 0x2 ),	/* 2 */
/* 130 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 132 */	NdrFcLong( 0x4 ),	/* 4 */
/* 136 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 138 */	NdrFcLong( 0x5 ),	/* 5 */
/* 142 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 144 */	NdrFcLong( 0xb ),	/* 11 */
/* 148 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 150 */	NdrFcLong( 0xa ),	/* 10 */
/* 154 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 156 */	NdrFcLong( 0x6 ),	/* 6 */
/* 160 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (374) */
/* 162 */	NdrFcLong( 0x7 ),	/* 7 */
/* 166 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 168 */	NdrFcLong( 0x8 ),	/* 8 */
/* 172 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (380) */
/* 174 */	NdrFcLong( 0xd ),	/* 13 */
/* 178 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (406) */
/* 180 */	NdrFcLong( 0x9 ),	/* 9 */
/* 184 */	NdrFcShort( 0xf0 ),	/* Offset= 240 (424) */
/* 186 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 190 */	NdrFcShort( 0xfc ),	/* Offset= 252 (442) */
/* 192 */	NdrFcLong( 0x24 ),	/* 36 */
/* 196 */	NdrFcShort( 0x2e0 ),	/* Offset= 736 (932) */
/* 198 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 202 */	NdrFcShort( 0x2da ),	/* Offset= 730 (932) */
/* 204 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 208 */	NdrFcShort( 0x2d8 ),	/* Offset= 728 (936) */
/* 210 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 214 */	NdrFcShort( 0x2d6 ),	/* Offset= 726 (940) */
/* 216 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 220 */	NdrFcShort( 0x2d4 ),	/* Offset= 724 (944) */
/* 222 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 226 */	NdrFcShort( 0x2d2 ),	/* Offset= 722 (948) */
/* 228 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 232 */	NdrFcShort( 0x2d0 ),	/* Offset= 720 (952) */
/* 234 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 238 */	NdrFcShort( 0x2be ),	/* Offset= 702 (940) */
/* 240 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 244 */	NdrFcShort( 0x2bc ),	/* Offset= 700 (944) */
/* 246 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 250 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (956) */
/* 252 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 256 */	NdrFcShort( 0x2b8 ),	/* Offset= 696 (952) */
/* 258 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 262 */	NdrFcShort( 0x2ba ),	/* Offset= 698 (960) */
/* 264 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 268 */	NdrFcShort( 0x2b8 ),	/* Offset= 696 (964) */
/* 270 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 274 */	NdrFcShort( 0x2b6 ),	/* Offset= 694 (968) */
/* 276 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 280 */	NdrFcShort( 0x2b4 ),	/* Offset= 692 (972) */
/* 282 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 286 */	NdrFcShort( 0x2b2 ),	/* Offset= 690 (976) */
/* 288 */	NdrFcLong( 0x10 ),	/* 16 */
/* 292 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 294 */	NdrFcLong( 0x12 ),	/* 18 */
/* 298 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 300 */	NdrFcLong( 0x13 ),	/* 19 */
/* 304 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 306 */	NdrFcLong( 0x16 ),	/* 22 */
/* 310 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 312 */	NdrFcLong( 0x17 ),	/* 23 */
/* 316 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 318 */	NdrFcLong( 0xe ),	/* 14 */
/* 322 */	NdrFcShort( 0x296 ),	/* Offset= 662 (984) */
/* 324 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 328 */	NdrFcShort( 0x29a ),	/* Offset= 666 (994) */
/* 330 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 334 */	NdrFcShort( 0x298 ),	/* Offset= 664 (998) */
/* 336 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 340 */	NdrFcShort( 0x258 ),	/* Offset= 600 (940) */
/* 342 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 346 */	NdrFcShort( 0x256 ),	/* Offset= 598 (944) */
/* 348 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 352 */	NdrFcShort( 0x250 ),	/* Offset= 592 (944) */
/* 354 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 358 */	NdrFcShort( 0x24a ),	/* Offset= 586 (944) */
/* 360 */	NdrFcLong( 0x0 ),	/* 0 */
/* 364 */	NdrFcShort( 0x0 ),	/* Offset= 0 (364) */
/* 366 */	NdrFcLong( 0x1 ),	/* 1 */
/* 370 */	NdrFcShort( 0x0 ),	/* Offset= 0 (370) */
/* 372 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (371) */
/* 374 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 376 */	NdrFcShort( 0x8 ),	/* 8 */
/* 378 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 380 */	
			0x12, 0x0,	/* FC_UP */
/* 382 */	NdrFcShort( 0xe ),	/* Offset= 14 (396) */
/* 384 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 386 */	NdrFcShort( 0x2 ),	/* 2 */
/* 388 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 390 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 392 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 394 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 396 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 398 */	NdrFcShort( 0x8 ),	/* 8 */
/* 400 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (384) */
/* 402 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 404 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 406 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 408 */	NdrFcLong( 0x0 ),	/* 0 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 416 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 418 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 420 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 422 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 424 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 426 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 430 */	NdrFcShort( 0x0 ),	/* 0 */
/* 432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 434 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 436 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 438 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 440 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 442 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 444 */	NdrFcShort( 0x2 ),	/* Offset= 2 (446) */
/* 446 */	
			0x12, 0x0,	/* FC_UP */
/* 448 */	NdrFcShort( 0x1d2 ),	/* Offset= 466 (914) */
/* 450 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x89,		/* 137 */
/* 452 */	NdrFcShort( 0x20 ),	/* 32 */
/* 454 */	NdrFcShort( 0xa ),	/* 10 */
/* 456 */	NdrFcLong( 0x8 ),	/* 8 */
/* 460 */	NdrFcShort( 0x50 ),	/* Offset= 80 (540) */
/* 462 */	NdrFcLong( 0xd ),	/* 13 */
/* 466 */	NdrFcShort( 0x70 ),	/* Offset= 112 (578) */
/* 468 */	NdrFcLong( 0x9 ),	/* 9 */
/* 472 */	NdrFcShort( 0x90 ),	/* Offset= 144 (616) */
/* 474 */	NdrFcLong( 0xc ),	/* 12 */
/* 478 */	NdrFcShort( 0xb0 ),	/* Offset= 176 (654) */
/* 480 */	NdrFcLong( 0x24 ),	/* 36 */
/* 484 */	NdrFcShort( 0x102 ),	/* Offset= 258 (742) */
/* 486 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 490 */	NdrFcShort( 0x10c ),	/* Offset= 268 (758) */
/* 492 */	NdrFcLong( 0x10 ),	/* 16 */
/* 496 */	NdrFcShort( 0x126 ),	/* Offset= 294 (790) */
/* 498 */	NdrFcLong( 0x2 ),	/* 2 */
/* 502 */	NdrFcShort( 0x13c ),	/* Offset= 316 (818) */
/* 504 */	NdrFcLong( 0x3 ),	/* 3 */
/* 508 */	NdrFcShort( 0x152 ),	/* Offset= 338 (846) */
/* 510 */	NdrFcLong( 0x14 ),	/* 20 */
/* 514 */	NdrFcShort( 0x168 ),	/* Offset= 360 (874) */
/* 516 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (515) */
/* 518 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 522 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 528 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 532 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 534 */	
			0x12, 0x0,	/* FC_UP */
/* 536 */	NdrFcShort( 0xffffff74 ),	/* Offset= -140 (396) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 542 */	NdrFcShort( 0x10 ),	/* 16 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x6 ),	/* Offset= 6 (552) */
/* 548 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 550 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 552 */	
			0x11, 0x0,	/* FC_RP */
/* 554 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (518) */
/* 556 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 558 */	NdrFcShort( 0x0 ),	/* 0 */
/* 560 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 566 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 570 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 572 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 574 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (406) */
/* 576 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 578 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 580 */	NdrFcShort( 0x10 ),	/* 16 */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	NdrFcShort( 0x6 ),	/* Offset= 6 (590) */
/* 586 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 588 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 590 */	
			0x11, 0x0,	/* FC_RP */
/* 592 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (556) */
/* 594 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 598 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 602 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 604 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 608 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 610 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 612 */	NdrFcShort( 0xffffff44 ),	/* Offset= -188 (424) */
/* 614 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 616 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 618 */	NdrFcShort( 0x10 ),	/* 16 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x6 ),	/* Offset= 6 (628) */
/* 624 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 626 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 628 */	
			0x11, 0x0,	/* FC_RP */
/* 630 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (594) */
/* 632 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
/* 636 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 638 */	NdrFcShort( 0x0 ),	/* 0 */
/* 640 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 642 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 646 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 648 */	
			0x12, 0x0,	/* FC_UP */
/* 650 */	NdrFcShort( 0x160 ),	/* Offset= 352 (1002) */
/* 652 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 654 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 656 */	NdrFcShort( 0x10 ),	/* 16 */
/* 658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 660 */	NdrFcShort( 0x6 ),	/* Offset= 6 (666) */
/* 662 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 664 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 666 */	
			0x11, 0x0,	/* FC_RP */
/* 668 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (632) */
/* 670 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 672 */	NdrFcLong( 0x2f ),	/* 47 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */
/* 678 */	NdrFcShort( 0x0 ),	/* 0 */
/* 680 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 682 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 684 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 686 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 688 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 690 */	NdrFcShort( 0x1 ),	/* 1 */
/* 692 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 694 */	NdrFcShort( 0x4 ),	/* 4 */
/* 696 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 698 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 700 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 702 */	NdrFcShort( 0x18 ),	/* 24 */
/* 704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 706 */	NdrFcShort( 0xa ),	/* Offset= 10 (716) */
/* 708 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 710 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 712 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (670) */
/* 714 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 716 */	
			0x12, 0x0,	/* FC_UP */
/* 718 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (688) */
/* 720 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 722 */	NdrFcShort( 0x0 ),	/* 0 */
/* 724 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 726 */	NdrFcShort( 0x0 ),	/* 0 */
/* 728 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 730 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 734 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 736 */	
			0x12, 0x0,	/* FC_UP */
/* 738 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (700) */
/* 740 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 742 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 744 */	NdrFcShort( 0x10 ),	/* 16 */
/* 746 */	NdrFcShort( 0x0 ),	/* 0 */
/* 748 */	NdrFcShort( 0x6 ),	/* Offset= 6 (754) */
/* 750 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 752 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 754 */	
			0x11, 0x0,	/* FC_RP */
/* 756 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (720) */
/* 758 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 760 */	NdrFcShort( 0x20 ),	/* 32 */
/* 762 */	NdrFcShort( 0x0 ),	/* 0 */
/* 764 */	NdrFcShort( 0xa ),	/* Offset= 10 (774) */
/* 766 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 768 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 770 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd23 ),	/* Offset= -733 (38) */
			0x5b,		/* FC_END */
/* 774 */	
			0x11, 0x0,	/* FC_RP */
/* 776 */	NdrFcShort( 0xffffff24 ),	/* Offset= -220 (556) */
/* 778 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 780 */	NdrFcShort( 0x1 ),	/* 1 */
/* 782 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 786 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 788 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 790 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x10 ),	/* 16 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x6 ),	/* Offset= 6 (802) */
/* 798 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 800 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 802 */	
			0x12, 0x0,	/* FC_UP */
/* 804 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (778) */
/* 806 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 808 */	NdrFcShort( 0x2 ),	/* 2 */
/* 810 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 814 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 816 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 818 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 820 */	NdrFcShort( 0x10 ),	/* 16 */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x6 ),	/* Offset= 6 (830) */
/* 826 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 828 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 830 */	
			0x12, 0x0,	/* FC_UP */
/* 832 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (806) */
/* 834 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 836 */	NdrFcShort( 0x4 ),	/* 4 */
/* 838 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 840 */	NdrFcShort( 0x0 ),	/* 0 */
/* 842 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 844 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 846 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 848 */	NdrFcShort( 0x10 ),	/* 16 */
/* 850 */	NdrFcShort( 0x0 ),	/* 0 */
/* 852 */	NdrFcShort( 0x6 ),	/* Offset= 6 (858) */
/* 854 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 856 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 858 */	
			0x12, 0x0,	/* FC_UP */
/* 860 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (834) */
/* 862 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 864 */	NdrFcShort( 0x8 ),	/* 8 */
/* 866 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 868 */	NdrFcShort( 0x0 ),	/* 0 */
/* 870 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 872 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 874 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 876 */	NdrFcShort( 0x10 ),	/* 16 */
/* 878 */	NdrFcShort( 0x0 ),	/* 0 */
/* 880 */	NdrFcShort( 0x6 ),	/* Offset= 6 (886) */
/* 882 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 884 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 886 */	
			0x12, 0x0,	/* FC_UP */
/* 888 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (862) */
/* 890 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 894 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 896 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 898 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 900 */	NdrFcShort( 0x8 ),	/* 8 */
/* 902 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 904 */	NdrFcShort( 0xffc8 ),	/* -56 */
/* 906 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 908 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 910 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (890) */
/* 912 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 914 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 916 */	NdrFcShort( 0x38 ),	/* 56 */
/* 918 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (898) */
/* 920 */	NdrFcShort( 0x0 ),	/* Offset= 0 (920) */
/* 922 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 924 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 926 */	0x40,		/* FC_STRUCTPAD4 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 928 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe21 ),	/* Offset= -479 (450) */
			0x5b,		/* FC_END */
/* 932 */	
			0x12, 0x0,	/* FC_UP */
/* 934 */	NdrFcShort( 0xffffff16 ),	/* Offset= -234 (700) */
/* 936 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 938 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 940 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 942 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 944 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 946 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 948 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 950 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 952 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 954 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 956 */	
			0x12, 0x0,	/* FC_UP */
/* 958 */	NdrFcShort( 0xfffffdb8 ),	/* Offset= -584 (374) */
/* 960 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 962 */	NdrFcShort( 0xfffffdba ),	/* Offset= -582 (380) */
/* 964 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 966 */	NdrFcShort( 0xfffffdd0 ),	/* Offset= -560 (406) */
/* 968 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 970 */	NdrFcShort( 0xfffffdde ),	/* Offset= -546 (424) */
/* 972 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 974 */	NdrFcShort( 0xfffffdec ),	/* Offset= -532 (442) */
/* 976 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 978 */	NdrFcShort( 0x2 ),	/* Offset= 2 (980) */
/* 980 */	
			0x12, 0x0,	/* FC_UP */
/* 982 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1002) */
/* 984 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 986 */	NdrFcShort( 0x10 ),	/* 16 */
/* 988 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 990 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 992 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 994 */	
			0x12, 0x0,	/* FC_UP */
/* 996 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (984) */
/* 998 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1000 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1002 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 1004 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1006 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1008 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1008) */
/* 1010 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1012 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1014 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1016 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1018 */	NdrFcShort( 0xfffffc6a ),	/* Offset= -918 (100) */
/* 1020 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1022 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1024 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1026 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1028 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1030 */	NdrFcShort( 0xfffffc5a ),	/* Offset= -934 (96) */
/* 1032 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1034 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1036 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1038 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1040 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1042 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1046 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1048 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1050 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1022) */
/* 1052 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1054 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1056 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1058 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1060 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1062 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1064 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1066 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1068 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1080) */
/* 1074 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1076 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1078 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1080 */	
			0x12, 0x0,	/* FC_UP */
/* 1082 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (1032) */
/* 1084 */	
			0x12, 0x0,	/* FC_UP */
/* 1086 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1054) */
/* 1088 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1090 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1096) */
/* 1092 */	
			0x13, 0x0,	/* FC_OP */
/* 1094 */	NdrFcShort( 0xffffffa4 ),	/* Offset= -92 (1002) */
/* 1096 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1100 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1092) */
/* 1106 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1108 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1124) */
/* 1110 */	
			0x13, 0x0,	/* FC_OP */
/* 1112 */	NdrFcShort( 0xfffffd34 ),	/* Offset= -716 (396) */
/* 1114 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1116 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1122 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1110) */
/* 1124 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1126 */	NdrFcShort( 0x30 ),	/* 48 */
/* 1128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1130 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1130) */
/* 1132 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1134 */	0x40,		/* FC_STRUCTPAD4 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1136 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe9 ),	/* Offset= -23 (1114) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1140 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe5 ),	/* Offset= -27 (1114) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1144 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe1 ),	/* Offset= -31 (1114) */
			0x8,		/* FC_LONG */
/* 1148 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1150 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1152 */	
			0x11, 0x0,	/* FC_RP */
/* 1154 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1156) */
/* 1156 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1158 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1160 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1162 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 1164 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1166 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1168 */	
			0x11, 0x0,	/* FC_RP */
/* 1170 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1172) */
/* 1172 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1176 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1178 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 1180 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1182 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1186 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1188 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1190 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (1096) */
/* 1192 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1194 */	
			0x11, 0x0,	/* FC_RP */
/* 1196 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1198) */
/* 1198 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1202 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1204 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1206 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1208 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1210 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1212 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1214 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1216 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (1096) */
/* 1218 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1220 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1222 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1224) */
/* 1224 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1226 */	NdrFcLong( 0x20404 ),	/* 132100 */
/* 1230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1234 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1236 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1238 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1240 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1242 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1244 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1246 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1248 */	0xe,		/* FC_ENUM32 */
			0x5c,		/* FC_PAD */
/* 1250 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1252 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1254) */
/* 1254 */	
			0x13, 0x0,	/* FC_OP */
/* 1256 */	NdrFcShort( 0xb6 ),	/* Offset= 182 (1438) */
/* 1258 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 1260 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1262 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1264 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1266 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1268) */
/* 1268 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1270 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1272 */	NdrFcLong( 0x1a ),	/* 26 */
/* 1276 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1298) */
/* 1278 */	NdrFcLong( 0x1b ),	/* 27 */
/* 1282 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1298) */
/* 1284 */	NdrFcLong( 0x1c ),	/* 28 */
/* 1288 */	NdrFcShort( 0xe ),	/* Offset= 14 (1302) */
/* 1290 */	NdrFcLong( 0x1d ),	/* 29 */
/* 1294 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1296 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1296) */
/* 1298 */	
			0x13, 0x0,	/* FC_OP */
/* 1300 */	NdrFcShort( 0x26 ),	/* Offset= 38 (1338) */
/* 1302 */	
			0x13, 0x0,	/* FC_OP */
/* 1304 */	NdrFcShort( 0x12 ),	/* Offset= 18 (1322) */
/* 1306 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1308 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1310 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1312 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 1314 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1316 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1318 */	NdrFcShort( 0xfffffe54 ),	/* Offset= -428 (890) */
/* 1320 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1322 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1324 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1326 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1306) */
/* 1328 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1328) */
/* 1330 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1332 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1338) */
/* 1334 */	0x6,		/* FC_SHORT */
			0x3e,		/* FC_STRUCTPAD2 */
/* 1336 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1338 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1340 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1344 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1344) */
/* 1346 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1348 */	NdrFcShort( 0xffffffa6 ),	/* Offset= -90 (1258) */
/* 1350 */	0x6,		/* FC_SHORT */
			0x42,		/* FC_STRUCTPAD6 */
/* 1352 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1354 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1356 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1360 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1360) */
/* 1362 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1364 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1366 */	NdrFcShort( 0xfffffef2 ),	/* Offset= -270 (1096) */
/* 1368 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1370 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1372 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1376 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1382) */
/* 1378 */	0x36,		/* FC_POINTER */
			0x6,		/* FC_SHORT */
/* 1380 */	0x42,		/* FC_STRUCTPAD6 */
			0x5b,		/* FC_END */
/* 1382 */	
			0x13, 0x0,	/* FC_OP */
/* 1384 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1354) */
/* 1386 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1388 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1392 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1392) */
/* 1394 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1396 */	NdrFcShort( 0xffffffc6 ),	/* Offset= -58 (1338) */
/* 1398 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1400 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1370) */
/* 1402 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1404 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1406 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1408 */	0x16,		/* Corr desc:  field pointer, FC_SHORT */
			0x0,		/*  */
/* 1410 */	NdrFcShort( 0x2a ),	/* 42 */
/* 1412 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1414 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1416 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1420 */	0x16,		/* Corr desc:  field pointer, FC_SHORT */
			0x0,		/*  */
/* 1422 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1424 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1426 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1430 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1432 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1434 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1386) */
/* 1436 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1438 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1440 */	NdrFcShort( 0x58 ),	/* 88 */
/* 1442 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1444 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1466) */
/* 1446 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1448 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1450 */	0xe,		/* FC_ENUM32 */
			0xe,		/* FC_ENUM32 */
/* 1452 */	0xe,		/* FC_ENUM32 */
			0x6,		/* FC_SHORT */
/* 1454 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1456 */	0x6,		/* FC_SHORT */
			0x40,		/* FC_STRUCTPAD4 */
/* 1458 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1460 */	NdrFcShort( 0xffffffb6 ),	/* Offset= -74 (1386) */
/* 1462 */	0x6,		/* FC_SHORT */
			0x42,		/* FC_STRUCTPAD6 */
/* 1464 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1466 */	
			0x13, 0x0,	/* FC_OP */
/* 1468 */	NdrFcShort( 0xffffffc0 ),	/* Offset= -64 (1404) */
/* 1470 */	
			0x13, 0x0,	/* FC_OP */
/* 1472 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (1416) */
/* 1474 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1476 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1478) */
/* 1478 */	
			0x13, 0x0,	/* FC_OP */
/* 1480 */	NdrFcShort( 0x2e ),	/* Offset= 46 (1526) */
/* 1482 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x8,		/* FC_LONG */
/* 1484 */	0x8,		/* Corr desc: FC_LONG */
			0x0,		/*  */
/* 1486 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1488 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1490 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1492) */
/* 1492 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1494 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1496 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1500 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1502 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1506 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1508 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1512 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1514 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1518 */	NdrFcShort( 0x4 ),	/* Offset= 4 (1522) */
/* 1520 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (1519) */
/* 1522 */	
			0x13, 0x0,	/* FC_OP */
/* 1524 */	NdrFcShort( 0xfffffe54 ),	/* Offset= -428 (1096) */
/* 1526 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1528 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1532 */	NdrFcShort( 0x12 ),	/* Offset= 18 (1550) */
/* 1534 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1536 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1538 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc7 ),	/* Offset= -57 (1482) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1542 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff63 ),	/* Offset= -157 (1386) */
			0x6,		/* FC_SHORT */
/* 1546 */	0x3e,		/* FC_STRUCTPAD2 */
			0xe,		/* FC_ENUM32 */
/* 1548 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1550 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1552 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1554 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1556 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1558) */
/* 1558 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1560 */	NdrFcLong( 0x20403 ),	/* 132099 */
/* 1564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1568 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1570 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1572 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1574 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1576 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1578 */	NdrFcShort( 0x4 ),	/* Offset= 4 (1582) */
/* 1580 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1582 */	0xb4,		/* FC_USER_MARSHAL */
			0x3,		/* 3 */
/* 1584 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1586 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1588 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1590 */	NdrFcShort( 0xfffffff6 ),	/* Offset= -10 (1580) */
/* 1592 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1594 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1596) */
/* 1596 */	
			0x13, 0x0,	/* FC_OP */
/* 1598 */	NdrFcShort( 0xe ),	/* Offset= 14 (1612) */
/* 1600 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1602 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1604 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1606 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1606) */
/* 1608 */	0xb9,		/* FC_UINT3264 */
			0x6,		/* FC_SHORT */
/* 1610 */	0x42,		/* FC_STRUCTPAD6 */
			0x5b,		/* FC_END */
/* 1612 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1614 */	NdrFcShort( 0x60 ),	/* 96 */
/* 1616 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1618 */	NdrFcShort( 0x1e ),	/* Offset= 30 (1648) */
/* 1620 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1622 */	NdrFcShort( 0xfffff9d0 ),	/* Offset= -1584 (38) */
/* 1624 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1626 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1628 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 1630 */	0xe,		/* FC_ENUM32 */
			0x6,		/* FC_SHORT */
/* 1632 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1634 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1636 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1638 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1640 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffed1 ),	/* Offset= -303 (1338) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1644 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (1600) */
			0x5b,		/* FC_END */
/* 1648 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1650 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1652 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1654 */	NdrFcShort( 0x4 ),	/* Offset= 4 (1658) */
/* 1656 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1658 */	0xb4,		/* FC_USER_MARSHAL */
			0x3,		/* 3 */
/* 1660 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1662 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1664 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1666 */	NdrFcShort( 0xfffffff6 ),	/* Offset= -10 (1656) */
/* 1668 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1670 */	NdrFcShort( 0x4 ),	/* Offset= 4 (1674) */
/* 1672 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1674 */	0xb4,		/* FC_USER_MARSHAL */
			0x3,		/* 3 */
/* 1676 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1678 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1680 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1682 */	NdrFcShort( 0xfffffff6 ),	/* Offset= -10 (1672) */
/* 1684 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1686 */	NdrFcShort( 0x4 ),	/* Offset= 4 (1690) */
/* 1688 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1690 */	0xb4,		/* FC_USER_MARSHAL */
			0x3,		/* 3 */
/* 1692 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1694 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1696 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1698 */	NdrFcShort( 0xfffffff6 ),	/* Offset= -10 (1688) */
/* 1700 */	
			0x11, 0x0,	/* FC_RP */
/* 1702 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1704) */
/* 1704 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1706 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1708 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1710 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1712 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1714 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1716 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1718 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1720 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1722 */	NdrFcShort( 0xfffffda0 ),	/* Offset= -608 (1114) */
/* 1724 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1726 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1728 */	NdrFcShort( 0xfffffd9a ),	/* Offset= -614 (1114) */
/* 1730 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1732 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1734 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1736 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1738) */
/* 1738 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1740 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1742 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1744 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1746 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1748 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1750) */
/* 1750 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1752 */	NdrFcLong( 0x20402 ),	/* 132098 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1758 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1760 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1762 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1764 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1766 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1768 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1770 */	NdrFcShort( 0x2a ),	/* Offset= 42 (1812) */
/* 1772 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1774 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1776 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1778 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1778) */
/* 1780 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1782 */	NdrFcShort( 0xfffff930 ),	/* Offset= -1744 (38) */
/* 1784 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1786 */	NdrFcShort( 0xfffffd4e ),	/* Offset= -690 (1096) */
/* 1788 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1790 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1792 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1794 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1798 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1800 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1804 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1806 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1808 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1772) */
/* 1810 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1812 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1814 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1824) */
/* 1820 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1822 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1824 */	
			0x13, 0x0,	/* FC_OP */
/* 1826 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1790) */
/* 1828 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1830 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1832) */
/* 1832 */	
			0x13, 0x0,	/* FC_OP */
/* 1834 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1836) */
/* 1836 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1838 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1840 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1842 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1842) */
/* 1844 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1846 */	NdrFcShort( 0xfffff8f0 ),	/* Offset= -1808 (38) */
/* 1848 */	0x8,		/* FC_LONG */
			0xe,		/* FC_ENUM32 */
/* 1850 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1852 */	0x6,		/* FC_SHORT */
			0x3e,		/* FC_STRUCTPAD2 */
/* 1854 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1856 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1858 */	NdrFcShort( 0x4 ),	/* Offset= 4 (1862) */
/* 1860 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1862 */	0xb4,		/* FC_USER_MARSHAL */
			0x3,		/* 3 */
/* 1864 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1866 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1868 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1870 */	NdrFcShort( 0xfffffff6 ),	/* Offset= -10 (1860) */
/* 1872 */	
			0x11, 0x0,	/* FC_RP */
/* 1874 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1876) */
/* 1876 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1878 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1880 */	0x27,		/* Corr desc:  parameter, FC_USHORT */
			0x54,		/* FC_DEREFERENCE */
/* 1882 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1884 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1886 */	0x27,		/* Corr desc:  parameter, FC_USHORT */
			0x54,		/* FC_DEREFERENCE */
/* 1888 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1890 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1892 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1894 */	NdrFcShort( 0xfffff8a4 ),	/* Offset= -1884 (10) */
/* 1896 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1898 */	
			0x11, 0x0,	/* FC_RP */
/* 1900 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1902) */
/* 1902 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1904 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1906 */	0x27,		/* Corr desc:  parameter, FC_USHORT */
			0x54,		/* FC_DEREFERENCE */
/* 1908 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1910 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1912 */	0x27,		/* Corr desc:  parameter, FC_USHORT */
			0x54,		/* FC_DEREFERENCE */
/* 1914 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1916 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1918 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1920 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1922 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1924 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1926 */	NdrFcShort( 0xfffff8a0 ),	/* Offset= -1888 (38) */
/* 1928 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1930 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1932) */
/* 1932 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1934 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1936 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1938 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1940 */	
			0x11, 0x0,	/* FC_RP */
/* 1942 */	NdrFcShort( 0xfffffcce ),	/* Offset= -818 (1124) */
/* 1944 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1946 */	NdrFcLong( 0x3127ca40 ),	/* 824691264 */
/* 1950 */	NdrFcShort( 0x446e ),	/* 17518 */
/* 1952 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 1954 */	0x81,		/* 129 */
			0x35,		/* 53 */
/* 1956 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 1958 */	0x0,		/* 0 */
			0x4b,		/* 75 */
/* 1960 */	0xb8,		/* 184 */
			0x51,		/* 81 */
/* 1962 */	0x11, 0x0,	/* FC_RP */
/* 1964 */	NdrFcShort( 0xfffffc52 ),	/* Offset= -942 (1022) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            VARIANT_UserSize
            ,VARIANT_UserMarshal
            ,VARIANT_UserUnmarshal
            ,VARIANT_UserFree
            },
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            CLEANLOCALSTORAGE_UserSize
            ,CLEANLOCALSTORAGE_UserMarshal
            ,CLEANLOCALSTORAGE_UserUnmarshal
            ,CLEANLOCALSTORAGE_UserFree
            }

        };



/* Standard interface: __MIDL_itf_oaidl_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: IOleAutomationTypes, ver. 1.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICreateTypeInfo, ver. 0.0,
   GUID={0x00020405,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICreateTypeInfo2, ver. 0.0,
   GUID={0x0002040E,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICreateTypeLib, ver. 0.0,
   GUID={0x00020406,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICreateTypeLib2, ver. 0.0,
   GUID={0x0002040F,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IDispatch_FormatStringOffsetTable[] =
    {
    0,
    38,
    88,
    150
    };

static const MIDL_STUBLESS_PROXY_INFO IDispatch_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDispatch_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDispatch_StubThunkTable[] = 
    {
    0,
    0,
    0,
    IDispatch_RemoteInvoke_Thunk
    };

static const MIDL_SERVER_INFO IDispatch_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDispatch_FormatStringOffsetTable[-3],
    &IDispatch_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IDispatchProxyVtbl = 
{
    &IDispatch_ProxyInfo,
    &IID_IDispatch,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    IDispatch_Invoke_Proxy
};

const CInterfaceStubVtbl _IDispatchStubVtbl =
{
    &IID_IDispatch,
    &IDispatch_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumVARIANT, ver. 0.0,
   GUID={0x00020404,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumVARIANT_FormatStringOffsetTable[] =
    {
    248,
    298,
    336,
    368
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumVARIANT_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumVARIANT_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IEnumVARIANT_StubThunkTable[] = 
    {
    IEnumVARIANT_RemoteNext_Thunk,
    0,
    0,
    0
    };

static const MIDL_SERVER_INFO IEnumVARIANT_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumVARIANT_FormatStringOffsetTable[-3],
    &IEnumVARIANT_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IEnumVARIANTProxyVtbl = 
{
    &IEnumVARIANT_ProxyInfo,
    &IID_IEnumVARIANT,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IEnumVARIANT_Next_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumVARIANT::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumVARIANT::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumVARIANT::Clone */
};

const CInterfaceStubVtbl _IEnumVARIANTStubVtbl =
{
    &IID_IEnumVARIANT,
    &IEnumVARIANT_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITypeComp, ver. 0.0,
   GUID={0x00020403,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short ITypeComp_FormatStringOffsetTable[] =
    {
    406,
    492
    };

static const MIDL_STUBLESS_PROXY_INFO ITypeComp_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITypeComp_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ITypeComp_StubThunkTable[] = 
    {
    ITypeComp_RemoteBind_Thunk,
    ITypeComp_RemoteBindType_Thunk
    };

static const MIDL_SERVER_INFO ITypeComp_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITypeComp_FormatStringOffsetTable[-3],
    &ITypeComp_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ITypeCompProxyVtbl = 
{
    &ITypeComp_ProxyInfo,
    &IID_ITypeComp,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ITypeComp_Bind_Proxy ,
    ITypeComp_BindType_Proxy
};

const CInterfaceStubVtbl _ITypeCompStubVtbl =
{
    &IID_ITypeComp,
    &ITypeComp_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITypeInfo, ver. 0.0,
   GUID={0x00020401,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short ITypeInfo_FormatStringOffsetTable[] =
    {
    542,
    586,
    624,
    674,
    724,
    780,
    824,
    868,
    900,
    932,
    1000,
    1068,
    1112,
    1144,
    1188,
    1232,
    1276,
    1308,
    1340
    };

static const MIDL_STUBLESS_PROXY_INFO ITypeInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITypeInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ITypeInfo_StubThunkTable[] = 
    {
    ITypeInfo_RemoteGetTypeAttr_Thunk,
    0,
    ITypeInfo_RemoteGetFuncDesc_Thunk,
    ITypeInfo_RemoteGetVarDesc_Thunk,
    ITypeInfo_RemoteGetNames_Thunk,
    0,
    0,
    ITypeInfo_LocalGetIDsOfNames_Thunk,
    ITypeInfo_LocalInvoke_Thunk,
    ITypeInfo_RemoteGetDocumentation_Thunk,
    ITypeInfo_RemoteGetDllEntry_Thunk,
    0,
    ITypeInfo_LocalAddressOfMember_Thunk,
    ITypeInfo_RemoteCreateInstance_Thunk,
    0,
    ITypeInfo_RemoteGetContainingTypeLib_Thunk,
    ITypeInfo_LocalReleaseTypeAttr_Thunk,
    ITypeInfo_LocalReleaseFuncDesc_Thunk,
    ITypeInfo_LocalReleaseVarDesc_Thunk
    };

static const MIDL_SERVER_INFO ITypeInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITypeInfo_FormatStringOffsetTable[-3],
    &ITypeInfo_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(22) _ITypeInfoProxyVtbl = 
{
    &ITypeInfo_ProxyInfo,
    &IID_ITypeInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ITypeInfo_GetTypeAttr_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetTypeComp */ ,
    ITypeInfo_GetFuncDesc_Proxy ,
    ITypeInfo_GetVarDesc_Proxy ,
    ITypeInfo_GetNames_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetRefTypeOfImplType */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetImplTypeFlags */ ,
    ITypeInfo_GetIDsOfNames_Proxy ,
    ITypeInfo_Invoke_Proxy ,
    ITypeInfo_GetDocumentation_Proxy ,
    ITypeInfo_GetDllEntry_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetRefTypeInfo */ ,
    ITypeInfo_AddressOfMember_Proxy ,
    ITypeInfo_CreateInstance_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetMops */ ,
    ITypeInfo_GetContainingTypeLib_Proxy ,
    ITypeInfo_ReleaseTypeAttr_Proxy ,
    ITypeInfo_ReleaseFuncDesc_Proxy ,
    ITypeInfo_ReleaseVarDesc_Proxy
};

const CInterfaceStubVtbl _ITypeInfoStubVtbl =
{
    &IID_ITypeInfo,
    &ITypeInfo_ServerInfo,
    22,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITypeInfo2, ver. 0.0,
   GUID={0x00020412,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short ITypeInfo2_FormatStringOffsetTable[] =
    {
    542,
    586,
    624,
    674,
    724,
    780,
    824,
    868,
    900,
    932,
    1000,
    1068,
    1112,
    1144,
    1188,
    1232,
    1276,
    1308,
    1340,
    1372,
    1410,
    1448,
    1498,
    1542,
    1586,
    1636,
    1692,
    1742,
    1792,
    1860,
    1898,
    1942,
    1992,
    2036
    };

static const MIDL_STUBLESS_PROXY_INFO ITypeInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITypeInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ITypeInfo2_StubThunkTable[] = 
    {
    ITypeInfo_RemoteGetTypeAttr_Thunk,
    0,
    ITypeInfo_RemoteGetFuncDesc_Thunk,
    ITypeInfo_RemoteGetVarDesc_Thunk,
    ITypeInfo_RemoteGetNames_Thunk,
    0,
    0,
    ITypeInfo_LocalGetIDsOfNames_Thunk,
    ITypeInfo_LocalInvoke_Thunk,
    ITypeInfo_RemoteGetDocumentation_Thunk,
    ITypeInfo_RemoteGetDllEntry_Thunk,
    0,
    ITypeInfo_LocalAddressOfMember_Thunk,
    ITypeInfo_RemoteCreateInstance_Thunk,
    0,
    ITypeInfo_RemoteGetContainingTypeLib_Thunk,
    ITypeInfo_LocalReleaseTypeAttr_Thunk,
    ITypeInfo_LocalReleaseFuncDesc_Thunk,
    ITypeInfo_LocalReleaseVarDesc_Thunk,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    ITypeInfo2_RemoteGetDocumentation2_Thunk,
    0,
    0,
    0,
    0,
    0
    };

static const MIDL_SERVER_INFO ITypeInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITypeInfo2_FormatStringOffsetTable[-3],
    &ITypeInfo2_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(37) _ITypeInfo2ProxyVtbl = 
{
    &ITypeInfo2_ProxyInfo,
    &IID_ITypeInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ITypeInfo_GetTypeAttr_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetTypeComp */ ,
    ITypeInfo_GetFuncDesc_Proxy ,
    ITypeInfo_GetVarDesc_Proxy ,
    ITypeInfo_GetNames_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetRefTypeOfImplType */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetImplTypeFlags */ ,
    ITypeInfo_GetIDsOfNames_Proxy ,
    ITypeInfo_Invoke_Proxy ,
    ITypeInfo_GetDocumentation_Proxy ,
    ITypeInfo_GetDllEntry_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetRefTypeInfo */ ,
    ITypeInfo_AddressOfMember_Proxy ,
    ITypeInfo_CreateInstance_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo::GetMops */ ,
    ITypeInfo_GetContainingTypeLib_Proxy ,
    ITypeInfo_ReleaseTypeAttr_Proxy ,
    ITypeInfo_ReleaseFuncDesc_Proxy ,
    ITypeInfo_ReleaseVarDesc_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetTypeKind */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetTypeFlags */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetFuncIndexOfMemId */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetVarIndexOfMemId */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetCustData */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetFuncCustData */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetParamCustData */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetVarCustData */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetImplTypeCustData */ ,
    ITypeInfo2_GetDocumentation2_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetAllCustData */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetAllFuncCustData */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetAllParamCustData */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetAllVarCustData */ ,
    (void *) (INT_PTR) -1 /* ITypeInfo2::GetAllImplTypeCustData */
};

const CInterfaceStubVtbl _ITypeInfo2StubVtbl =
{
    &IID_ITypeInfo2,
    &ITypeInfo2_ServerInfo,
    37,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITypeLib, ver. 0.0,
   GUID={0x00020402,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short ITypeLib_FormatStringOffsetTable[] =
    {
    0,
    2080,
    2124,
    2168,
    2212,
    2256,
    2294,
    2362,
    2418,
    2486
    };

static const MIDL_STUBLESS_PROXY_INFO ITypeLib_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITypeLib_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ITypeLib_StubThunkTable[] = 
    {
    ITypeLib_RemoteGetTypeInfoCount_Thunk,
    0,
    0,
    0,
    ITypeLib_RemoteGetLibAttr_Thunk,
    0,
    ITypeLib_RemoteGetDocumentation_Thunk,
    ITypeLib_RemoteIsName_Thunk,
    ITypeLib_RemoteFindName_Thunk,
    ITypeLib_LocalReleaseTLibAttr_Thunk
    };

static const MIDL_SERVER_INFO ITypeLib_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITypeLib_FormatStringOffsetTable[-3],
    &ITypeLib_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _ITypeLibProxyVtbl = 
{
    &ITypeLib_ProxyInfo,
    &IID_ITypeLib,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ITypeLib_GetTypeInfoCount_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeLib::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* ITypeLib::GetTypeInfoType */ ,
    (void *) (INT_PTR) -1 /* ITypeLib::GetTypeInfoOfGuid */ ,
    ITypeLib_GetLibAttr_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeLib::GetTypeComp */ ,
    ITypeLib_GetDocumentation_Proxy ,
    ITypeLib_IsName_Proxy ,
    ITypeLib_FindName_Proxy ,
    ITypeLib_ReleaseTLibAttr_Proxy
};

const CInterfaceStubVtbl _ITypeLibStubVtbl =
{
    &IID_ITypeLib,
    &ITypeLib_ServerInfo,
    13,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITypeLib2, ver. 0.0,
   GUID={0x00020411,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short ITypeLib2_FormatStringOffsetTable[] =
    {
    0,
    2080,
    2124,
    2168,
    2212,
    2256,
    2294,
    2362,
    2418,
    2486,
    2518,
    2562,
    2606,
    2674
    };

static const MIDL_STUBLESS_PROXY_INFO ITypeLib2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITypeLib2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ITypeLib2_StubThunkTable[] = 
    {
    ITypeLib_RemoteGetTypeInfoCount_Thunk,
    0,
    0,
    0,
    ITypeLib_RemoteGetLibAttr_Thunk,
    0,
    ITypeLib_RemoteGetDocumentation_Thunk,
    ITypeLib_RemoteIsName_Thunk,
    ITypeLib_RemoteFindName_Thunk,
    ITypeLib_LocalReleaseTLibAttr_Thunk,
    0,
    ITypeLib2_RemoteGetLibStatistics_Thunk,
    ITypeLib2_RemoteGetDocumentation2_Thunk,
    0
    };

static const MIDL_SERVER_INFO ITypeLib2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITypeLib2_FormatStringOffsetTable[-3],
    &ITypeLib2_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(17) _ITypeLib2ProxyVtbl = 
{
    &ITypeLib2_ProxyInfo,
    &IID_ITypeLib2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ITypeLib_GetTypeInfoCount_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeLib::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* ITypeLib::GetTypeInfoType */ ,
    (void *) (INT_PTR) -1 /* ITypeLib::GetTypeInfoOfGuid */ ,
    ITypeLib_GetLibAttr_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeLib::GetTypeComp */ ,
    ITypeLib_GetDocumentation_Proxy ,
    ITypeLib_IsName_Proxy ,
    ITypeLib_FindName_Proxy ,
    ITypeLib_ReleaseTLibAttr_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeLib2::GetCustData */ ,
    ITypeLib2_GetLibStatistics_Proxy ,
    ITypeLib2_GetDocumentation2_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeLib2::GetAllCustData */
};

const CInterfaceStubVtbl _ITypeLib2StubVtbl =
{
    &IID_ITypeLib2,
    &ITypeLib2_ServerInfo,
    17,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITypeChangeEvents, ver. 0.0,
   GUID={0x00020410,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IErrorInfo, ver. 0.0,
   GUID={0x1CF2B120,0x547D,0x101B,{0x8E,0x65,0x08,0x00,0x2B,0x2B,0xD1,0x19}} */

#pragma code_seg(".orpc")
static const unsigned short IErrorInfo_FormatStringOffsetTable[] =
    {
    2712,
    2750,
    2788,
    2826,
    2864
    };

static const MIDL_STUBLESS_PROXY_INFO IErrorInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IErrorInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IErrorInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IErrorInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IErrorInfoProxyVtbl = 
{
    &IErrorInfo_ProxyInfo,
    &IID_IErrorInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IErrorInfo::GetGUID */ ,
    (void *) (INT_PTR) -1 /* IErrorInfo::GetSource */ ,
    (void *) (INT_PTR) -1 /* IErrorInfo::GetDescription */ ,
    (void *) (INT_PTR) -1 /* IErrorInfo::GetHelpFile */ ,
    (void *) (INT_PTR) -1 /* IErrorInfo::GetHelpContext */
};

const CInterfaceStubVtbl _IErrorInfoStubVtbl =
{
    &IID_IErrorInfo,
    &IErrorInfo_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICreateErrorInfo, ver. 0.0,
   GUID={0x22F03340,0x547D,0x101B,{0x8E,0x65,0x08,0x00,0x2B,0x2B,0xD1,0x19}} */

#pragma code_seg(".orpc")
static const unsigned short ICreateErrorInfo_FormatStringOffsetTable[] =
    {
    2902,
    2940,
    2978,
    3016,
    3054
    };

static const MIDL_STUBLESS_PROXY_INFO ICreateErrorInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICreateErrorInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICreateErrorInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICreateErrorInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICreateErrorInfoProxyVtbl = 
{
    &ICreateErrorInfo_ProxyInfo,
    &IID_ICreateErrorInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICreateErrorInfo::SetGUID */ ,
    (void *) (INT_PTR) -1 /* ICreateErrorInfo::SetSource */ ,
    (void *) (INT_PTR) -1 /* ICreateErrorInfo::SetDescription */ ,
    (void *) (INT_PTR) -1 /* ICreateErrorInfo::SetHelpFile */ ,
    (void *) (INT_PTR) -1 /* ICreateErrorInfo::SetHelpContext */
};

const CInterfaceStubVtbl _ICreateErrorInfoStubVtbl =
{
    &IID_ICreateErrorInfo,
    &ICreateErrorInfo_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISupportErrorInfo, ver. 0.0,
   GUID={0xDF0B3D60,0x548F,0x101B,{0x8E,0x65,0x08,0x00,0x2B,0x2B,0xD1,0x19}} */

#pragma code_seg(".orpc")
static const unsigned short ISupportErrorInfo_FormatStringOffsetTable[] =
    {
    2902
    };

static const MIDL_STUBLESS_PROXY_INFO ISupportErrorInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISupportErrorInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISupportErrorInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISupportErrorInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _ISupportErrorInfoProxyVtbl = 
{
    &ISupportErrorInfo_ProxyInfo,
    &IID_ISupportErrorInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISupportErrorInfo::InterfaceSupportsErrorInfo */
};

const CInterfaceStubVtbl _ISupportErrorInfoStubVtbl =
{
    &IID_ISupportErrorInfo,
    &ISupportErrorInfo_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITypeFactory, ver. 0.0,
   GUID={0x0000002E,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short ITypeFactory_FormatStringOffsetTable[] =
    {
    3092
    };

static const MIDL_STUBLESS_PROXY_INFO ITypeFactory_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITypeFactory_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ITypeFactory_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITypeFactory_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _ITypeFactoryProxyVtbl = 
{
    &ITypeFactory_ProxyInfo,
    &IID_ITypeFactory,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ITypeFactory::CreateFromTypeInfo */
};

const CInterfaceStubVtbl _ITypeFactoryStubVtbl =
{
    &IID_ITypeFactory,
    &ITypeFactory_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITypeMarshal, ver. 0.0,
   GUID={0x0000002D,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IRecordInfo, ver. 0.0,
   GUID={0x0000002F,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IErrorLog, ver. 0.0,
   GUID={0x3127CA40,0x446E,0x11CE,{0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51}} */

#pragma code_seg(".orpc")
static const unsigned short IErrorLog_FormatStringOffsetTable[] =
    {
    3142
    };

static const MIDL_STUBLESS_PROXY_INFO IErrorLog_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IErrorLog_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IErrorLog_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IErrorLog_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IErrorLogProxyVtbl = 
{
    &IErrorLog_ProxyInfo,
    &IID_IErrorLog,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IErrorLog::AddError */
};

const CInterfaceStubVtbl _IErrorLogStubVtbl =
{
    &IID_IErrorLog,
    &IErrorLog_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IPropertyBag, ver. 0.0,
   GUID={0x55272A00,0x42CB,0x11CE,{0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51}} */

#pragma code_seg(".orpc")
static const unsigned short IPropertyBag_FormatStringOffsetTable[] =
    {
    3186,
    3248
    };

static const MIDL_STUBLESS_PROXY_INFO IPropertyBag_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IPropertyBag_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IPropertyBag_StubThunkTable[] = 
    {
    IPropertyBag_RemoteRead_Thunk,
    0
    };

static const MIDL_SERVER_INFO IPropertyBag_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IPropertyBag_FormatStringOffsetTable[-3],
    &IPropertyBag_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IPropertyBagProxyVtbl = 
{
    &IPropertyBag_ProxyInfo,
    &IID_IPropertyBag,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IPropertyBag_Read_Proxy ,
    (void *) (INT_PTR) -1 /* IPropertyBag::Write */
};

const CInterfaceStubVtbl _IPropertyBagStubVtbl =
{
    &IID_IPropertyBag,
    &IPropertyBag_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oaidl_0103, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _oaidl_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IDispatchProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IPropertyBagProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITypeInfoProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITypeLibProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITypeCompProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumVARIANTProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITypeLib2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITypeInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IErrorInfoProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITypeFactoryProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICreateErrorInfoProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IErrorLogProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISupportErrorInfoProxyVtbl,
    0
};

const CInterfaceStubVtbl * _oaidl_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IDispatchStubVtbl,
    ( CInterfaceStubVtbl *) &_IPropertyBagStubVtbl,
    ( CInterfaceStubVtbl *) &_ITypeInfoStubVtbl,
    ( CInterfaceStubVtbl *) &_ITypeLibStubVtbl,
    ( CInterfaceStubVtbl *) &_ITypeCompStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumVARIANTStubVtbl,
    ( CInterfaceStubVtbl *) &_ITypeLib2StubVtbl,
    ( CInterfaceStubVtbl *) &_ITypeInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IErrorInfoStubVtbl,
    ( CInterfaceStubVtbl *) &_ITypeFactoryStubVtbl,
    ( CInterfaceStubVtbl *) &_ICreateErrorInfoStubVtbl,
    ( CInterfaceStubVtbl *) &_IErrorLogStubVtbl,
    ( CInterfaceStubVtbl *) &_ISupportErrorInfoStubVtbl,
    0
};

PCInterfaceName const _oaidl_InterfaceNamesList[] = 
{
    "IDispatch",
    "IPropertyBag",
    "ITypeInfo",
    "ITypeLib",
    "ITypeComp",
    "IEnumVARIANT",
    "ITypeLib2",
    "ITypeInfo2",
    "IErrorInfo",
    "ITypeFactory",
    "ICreateErrorInfo",
    "IErrorLog",
    "ISupportErrorInfo",
    0
};


#define _oaidl_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _oaidl, pIID, n)

int __stdcall _oaidl_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _oaidl, 13, 8 )
    IID_BS_LOOKUP_NEXT_TEST( _oaidl, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _oaidl, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _oaidl, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _oaidl, 13, *pIndex )
    
}

const ExtendedProxyFileInfo oaidl_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _oaidl_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _oaidl_StubVtblList,
    (const PCInterfaceName * ) & _oaidl_InterfaceNamesList,
    0, // no delegation
    & _oaidl_IID_Lookup, 
    13,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\idl\obj\propidl_d.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( propidl )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( propidl ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\idl\obj\storext_d.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( storext )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( storext ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\idl\obj\propidl_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:28 2002
 */
/* Compiler settings for propidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "propidl.h"

#define TYPE_FORMAT_STRING_SIZE   2611                              
#define PROC_FORMAT_STRING_SIZE   883                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IPropertyStorage_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IPropertyStorage_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IPropertySetStorage_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IPropertySetStorage_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumSTATPROPSTG_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPSTG_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
    /* [out] */ ULONG *pceltFetched)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[684],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IEnumSTATPROPSTG_RemoteNext_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IEnumSTATPROPSTG *This;
        ULONG celt;
        STATPROPSTG *rgelt;
        ULONG *pceltFetched;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IEnumSTATPROPSTG_Next_Stub(
                                     (IEnumSTATPROPSTG *) pParamStruct->This,
                                     pParamStruct->celt,
                                     pParamStruct->rgelt,
                                     pParamStruct->pceltFetched);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumSTATPROPSETSTG_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPSETSTG_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
    /* [out] */ ULONG *pceltFetched)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[834],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IEnumSTATPROPSETSTG_RemoteNext_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IEnumSTATPROPSETSTG *This;
        ULONG celt;
        STATPROPSETSTG *rgelt;
        ULONG *pceltFetched;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IEnumSTATPROPSETSTG_Next_Stub(
                                        (IEnumSTATPROPSETSTG *) pParamStruct->This,
                                        pParamStruct->celt,
                                        pParamStruct->rgelt,
                                        pParamStruct->pceltFetched);
    
}


extern const EXPR_EVAL ExprEvalRoutines[];
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure ReadMultiple */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x44 ),	/* 68 */
/* 20 */	NdrFcShort( 0x2 ),	/* 2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpspec */

/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpspec */

/* 30 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x30 ),	/* Type Offset=48 */

	/* Parameter rgpropvar */

/* 36 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 40 */	NdrFcShort( 0x918 ),	/* Type Offset=2328 */

	/* Return value */

/* 42 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 46 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteMultiple */

/* 48 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 50 */	NdrFcLong( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x4 ),	/* 4 */
/* 56 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 58 */	NdrFcShort( 0x10 ),	/* 16 */
/* 60 */	NdrFcShort( 0x8 ),	/* 8 */
/* 62 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 64 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x46 ),	/* 70 */
/* 70 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpspec */

/* 72 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 74 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 76 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpspec */

/* 78 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 80 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 82 */	NdrFcShort( 0x30 ),	/* Type Offset=48 */

	/* Parameter rgpropvar */

/* 84 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 86 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 88 */	NdrFcShort( 0x918 ),	/* Type Offset=2328 */

	/* Parameter propidNameFirst */

/* 90 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 92 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 96 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 98 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DeleteMultiple */

/* 102 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 108 */	NdrFcShort( 0x5 ),	/* 5 */
/* 110 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 112 */	NdrFcShort( 0x8 ),	/* 8 */
/* 114 */	NdrFcShort( 0x8 ),	/* 8 */
/* 116 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 118 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x2 ),	/* 2 */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpspec */

/* 126 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 128 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpspec */

/* 132 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 134 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 136 */	NdrFcShort( 0x30 ),	/* Type Offset=48 */

	/* Return value */

/* 138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 140 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReadPropertyNames */

/* 144 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0x6 ),	/* 6 */
/* 152 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 158 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 160 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 162 */	NdrFcShort( 0x1 ),	/* 1 */
/* 164 */	NdrFcShort( 0x1 ),	/* 1 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpropid */

/* 168 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 170 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpropid */

/* 174 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 176 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 178 */	NdrFcShort( 0x92e ),	/* Type Offset=2350 */

	/* Parameter rglpwstrName */

/* 180 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 182 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 184 */	NdrFcShort( 0x93a ),	/* Type Offset=2362 */

	/* Return value */

/* 186 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 188 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 190 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WritePropertyNames */

/* 192 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 194 */	NdrFcLong( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x7 ),	/* 7 */
/* 200 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 202 */	NdrFcShort( 0x8 ),	/* 8 */
/* 204 */	NdrFcShort( 0x8 ),	/* 8 */
/* 206 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 208 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 212 */	NdrFcShort( 0x2 ),	/* 2 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpropid */

/* 216 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 218 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpropid */

/* 222 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 224 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 226 */	NdrFcShort( 0x92e ),	/* Type Offset=2350 */

	/* Parameter rglpwstrName */

/* 228 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 230 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 232 */	NdrFcShort( 0x95a ),	/* Type Offset=2394 */

	/* Return value */

/* 234 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 236 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 238 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DeletePropertyNames */

/* 240 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 242 */	NdrFcLong( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0x8 ),	/* 8 */
/* 248 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 254 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 256 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x1 ),	/* 1 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpropid */

/* 264 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 266 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpropid */

/* 270 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 272 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 274 */	NdrFcShort( 0x92e ),	/* Type Offset=2350 */

	/* Return value */

/* 276 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 278 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Commit */

/* 282 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 284 */	NdrFcLong( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x9 ),	/* 9 */
/* 290 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 296 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 298 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter grfCommitFlags */

/* 306 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 308 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 312 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 314 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 316 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Revert */

/* 318 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 320 */	NdrFcLong( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0xa ),	/* 10 */
/* 326 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0x8 ),	/* 8 */
/* 332 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 334 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 342 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 344 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 346 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Enum */

/* 348 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 350 */	NdrFcLong( 0x0 ),	/* 0 */
/* 354 */	NdrFcShort( 0xb ),	/* 11 */
/* 356 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x8 ),	/* 8 */
/* 362 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 364 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 366 */	NdrFcShort( 0x0 ),	/* 0 */
/* 368 */	NdrFcShort( 0x0 ),	/* 0 */
/* 370 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppenum */

/* 372 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 374 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 376 */	NdrFcShort( 0x97a ),	/* Type Offset=2426 */

	/* Return value */

/* 378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 380 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 382 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetTimes */

/* 384 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 386 */	NdrFcLong( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0xc ),	/* 12 */
/* 392 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 394 */	NdrFcShort( 0x84 ),	/* 132 */
/* 396 */	NdrFcShort( 0x8 ),	/* 8 */
/* 398 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 400 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 402 */	NdrFcShort( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 406 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pctime */

/* 408 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 410 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 412 */	NdrFcShort( 0x2a2 ),	/* Type Offset=674 */

	/* Parameter patime */

/* 414 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 416 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 418 */	NdrFcShort( 0x2a2 ),	/* Type Offset=674 */

	/* Parameter pmtime */

/* 420 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 424 */	NdrFcShort( 0x2a2 ),	/* Type Offset=674 */

	/* Return value */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 428 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetClass */

/* 432 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0xd ),	/* 13 */
/* 440 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 442 */	NdrFcShort( 0x44 ),	/* 68 */
/* 444 */	NdrFcShort( 0x8 ),	/* 8 */
/* 446 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 448 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 450 */	NdrFcShort( 0x0 ),	/* 0 */
/* 452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 454 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter clsid */

/* 456 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 458 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 460 */	NdrFcShort( 0x2b4 ),	/* Type Offset=692 */

	/* Return value */

/* 462 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 464 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 466 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Stat */

/* 468 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 470 */	NdrFcLong( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0xe ),	/* 14 */
/* 476 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */
/* 480 */	NdrFcShort( 0xdc ),	/* 220 */
/* 482 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 484 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 486 */	NdrFcShort( 0x0 ),	/* 0 */
/* 488 */	NdrFcShort( 0x0 ),	/* 0 */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pstatpsstg */

/* 492 */	NdrFcShort( 0x112 ),	/* Flags:  must free, out, simple ref, */
/* 494 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 496 */	NdrFcShort( 0x99c ),	/* Type Offset=2460 */

	/* Return value */

/* 498 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 500 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 502 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Create */

/* 504 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 506 */	NdrFcLong( 0x0 ),	/* 0 */
/* 510 */	NdrFcShort( 0x3 ),	/* 3 */
/* 512 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 514 */	NdrFcShort( 0x98 ),	/* 152 */
/* 516 */	NdrFcShort( 0x8 ),	/* 8 */
/* 518 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 520 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 522 */	NdrFcShort( 0x0 ),	/* 0 */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter rfmtid */

/* 528 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 530 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 532 */	NdrFcShort( 0x2b4 ),	/* Type Offset=692 */

	/* Parameter pclsid */

/* 534 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 536 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 538 */	NdrFcShort( 0x9b8 ),	/* Type Offset=2488 */

	/* Parameter grfFlags */

/* 540 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 542 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 544 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter grfMode */

/* 546 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 548 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 550 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppprstg */

/* 552 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 554 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 556 */	NdrFcShort( 0x9bc ),	/* Type Offset=2492 */

	/* Return value */

/* 558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 560 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Open */

/* 564 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 566 */	NdrFcLong( 0x0 ),	/* 0 */
/* 570 */	NdrFcShort( 0x4 ),	/* 4 */
/* 572 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 574 */	NdrFcShort( 0x4c ),	/* 76 */
/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 578 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 580 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	NdrFcShort( 0x0 ),	/* 0 */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter rfmtid */

/* 588 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 590 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 592 */	NdrFcShort( 0x2b4 ),	/* Type Offset=692 */

	/* Parameter grfMode */

/* 594 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 596 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 598 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppprstg */

/* 600 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 602 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 604 */	NdrFcShort( 0x9bc ),	/* Type Offset=2492 */

	/* Return value */

/* 606 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 608 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 610 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Delete */

/* 612 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 614 */	NdrFcLong( 0x0 ),	/* 0 */
/* 618 */	NdrFcShort( 0x5 ),	/* 5 */
/* 620 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 622 */	NdrFcShort( 0x44 ),	/* 68 */
/* 624 */	NdrFcShort( 0x8 ),	/* 8 */
/* 626 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 628 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 630 */	NdrFcShort( 0x0 ),	/* 0 */
/* 632 */	NdrFcShort( 0x0 ),	/* 0 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter rfmtid */

/* 636 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 638 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 640 */	NdrFcShort( 0x2b4 ),	/* Type Offset=692 */

	/* Return value */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 644 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */


	/* Procedure Enum */

/* 648 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0x6 ),	/* 6 */
/* 656 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 662 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 664 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 670 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppenum */


	/* Parameter ppenum */

/* 672 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 674 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 676 */	NdrFcShort( 0x9d2 ),	/* Type Offset=2514 */

	/* Return value */


	/* Return value */

/* 678 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 680 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 682 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteNext */

/* 684 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 686 */	NdrFcLong( 0x0 ),	/* 0 */
/* 690 */	NdrFcShort( 0x3 ),	/* 3 */
/* 692 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 694 */	NdrFcShort( 0x8 ),	/* 8 */
/* 696 */	NdrFcShort( 0x24 ),	/* 36 */
/* 698 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 700 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 702 */	NdrFcShort( 0x1 ),	/* 1 */
/* 704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 706 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 708 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 710 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 714 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 716 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 718 */	NdrFcShort( 0x9fe ),	/* Type Offset=2558 */

	/* Parameter pceltFetched */

/* 720 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 722 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 728 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Skip */


	/* Procedure Skip */

/* 732 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 738 */	NdrFcShort( 0x4 ),	/* 4 */
/* 740 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 742 */	NdrFcShort( 0x8 ),	/* 8 */
/* 744 */	NdrFcShort( 0x8 ),	/* 8 */
/* 746 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 748 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 750 */	NdrFcShort( 0x0 ),	/* 0 */
/* 752 */	NdrFcShort( 0x0 ),	/* 0 */
/* 754 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */


	/* Parameter celt */

/* 756 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 758 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 760 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 762 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 764 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 766 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */


	/* Procedure Reset */

/* 768 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 770 */	NdrFcLong( 0x0 ),	/* 0 */
/* 774 */	NdrFcShort( 0x5 ),	/* 5 */
/* 776 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 778 */	NdrFcShort( 0x0 ),	/* 0 */
/* 780 */	NdrFcShort( 0x8 ),	/* 8 */
/* 782 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 784 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 786 */	NdrFcShort( 0x0 ),	/* 0 */
/* 788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 790 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */


	/* Return value */

/* 792 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 794 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 798 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 800 */	NdrFcLong( 0x0 ),	/* 0 */
/* 804 */	NdrFcShort( 0x6 ),	/* 6 */
/* 806 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 808 */	NdrFcShort( 0x0 ),	/* 0 */
/* 810 */	NdrFcShort( 0x8 ),	/* 8 */
/* 812 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 814 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 818 */	NdrFcShort( 0x0 ),	/* 0 */
/* 820 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppenum */

/* 822 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 824 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 826 */	NdrFcShort( 0x97a ),	/* Type Offset=2426 */

	/* Return value */

/* 828 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 830 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 832 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteNext */

/* 834 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 836 */	NdrFcLong( 0x0 ),	/* 0 */
/* 840 */	NdrFcShort( 0x3 ),	/* 3 */
/* 842 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 844 */	NdrFcShort( 0x8 ),	/* 8 */
/* 846 */	NdrFcShort( 0x24 ),	/* 36 */
/* 848 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 850 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 852 */	NdrFcShort( 0x1 ),	/* 1 */
/* 854 */	NdrFcShort( 0x0 ),	/* 0 */
/* 856 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 858 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 860 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 864 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 866 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 868 */	NdrFcShort( 0xa1c ),	/* Type Offset=2588 */

	/* Parameter pceltFetched */

/* 870 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 872 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 874 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 876 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 878 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 880 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/*  4 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/*  6 */	NdrFcShort( 0xfffc ),	/* -4 */
/*  8 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 10 */	NdrFcShort( 0x2 ),	/* Offset= 2 (12) */
/* 12 */	NdrFcShort( 0x4 ),	/* 4 */
/* 14 */	NdrFcShort( 0x2 ),	/* 2 */
/* 16 */	NdrFcLong( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 22 */	NdrFcLong( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x4 ),	/* Offset= 4 (30) */
/* 28 */	NdrFcShort( 0x0 ),	/* Offset= 0 (28) */
/* 30 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 32 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 34 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 36 */	NdrFcShort( 0x8 ),	/* 8 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x0 ),	/* Offset= 0 (40) */
/* 42 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 44 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd5 ),	/* Offset= -43 (2) */
			0x5b,		/* FC_END */
/* 48 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 54 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 56 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 58 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 62 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 64 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 66 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (34) */
/* 68 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 70 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 72 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 74 */	NdrFcShort( 0x0 ),	/* 0 */
/* 76 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 78 */	NdrFcShort( 0x2 ),	/* Offset= 2 (80) */
/* 80 */	NdrFcShort( 0x8 ),	/* 8 */
/* 82 */	NdrFcShort( 0x61 ),	/* 97 */
/* 84 */	NdrFcLong( 0x0 ),	/* 0 */
/* 88 */	NdrFcShort( 0x0 ),	/* Offset= 0 (88) */
/* 90 */	NdrFcLong( 0x1 ),	/* 1 */
/* 94 */	NdrFcShort( 0x0 ),	/* Offset= 0 (94) */
/* 96 */	NdrFcLong( 0x10 ),	/* 16 */
/* 100 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 102 */	NdrFcLong( 0x11 ),	/* 17 */
/* 106 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 108 */	NdrFcLong( 0x2 ),	/* 2 */
/* 112 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 114 */	NdrFcLong( 0x12 ),	/* 18 */
/* 118 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 120 */	NdrFcLong( 0x3 ),	/* 3 */
/* 124 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 126 */	NdrFcLong( 0x13 ),	/* 19 */
/* 130 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 132 */	NdrFcLong( 0x16 ),	/* 22 */
/* 136 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 138 */	NdrFcLong( 0x17 ),	/* 23 */
/* 142 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 144 */	NdrFcLong( 0xe ),	/* 14 */
/* 148 */	NdrFcShort( 0x208 ),	/* Offset= 520 (668) */
/* 150 */	NdrFcLong( 0x14 ),	/* 20 */
/* 154 */	NdrFcShort( 0x202 ),	/* Offset= 514 (668) */
/* 156 */	NdrFcLong( 0x15 ),	/* 21 */
/* 160 */	NdrFcShort( 0x1fc ),	/* Offset= 508 (668) */
/* 162 */	NdrFcLong( 0x4 ),	/* 4 */
/* 166 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 168 */	NdrFcLong( 0x5 ),	/* 5 */
/* 172 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 174 */	NdrFcLong( 0xb ),	/* 11 */
/* 178 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 180 */	NdrFcLong( 0xffff ),	/* 65535 */
/* 184 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 186 */	NdrFcLong( 0xa ),	/* 10 */
/* 190 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 192 */	NdrFcLong( 0x6 ),	/* 6 */
/* 196 */	NdrFcShort( 0x1d8 ),	/* Offset= 472 (668) */
/* 198 */	NdrFcLong( 0x7 ),	/* 7 */
/* 202 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 204 */	NdrFcLong( 0x40 ),	/* 64 */
/* 208 */	NdrFcShort( 0x1d2 ),	/* Offset= 466 (674) */
/* 210 */	NdrFcLong( 0x48 ),	/* 72 */
/* 214 */	NdrFcShort( 0x1d4 ),	/* Offset= 468 (682) */
/* 216 */	NdrFcLong( 0x47 ),	/* 71 */
/* 220 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (704) */
/* 222 */	NdrFcLong( 0x8 ),	/* 8 */
/* 226 */	NdrFcShort( 0x21e ),	/* Offset= 542 (768) */
/* 228 */	NdrFcLong( 0xfff ),	/* 4095 */
/* 232 */	NdrFcShort( 0x22e ),	/* Offset= 558 (790) */
/* 234 */	NdrFcLong( 0x41 ),	/* 65 */
/* 238 */	NdrFcShort( 0x228 ),	/* Offset= 552 (790) */
/* 240 */	NdrFcLong( 0x46 ),	/* 70 */
/* 244 */	NdrFcShort( 0x222 ),	/* Offset= 546 (790) */
/* 246 */	NdrFcLong( 0x1e ),	/* 30 */
/* 250 */	NdrFcShort( 0x230 ),	/* Offset= 560 (810) */
/* 252 */	NdrFcLong( 0x1f ),	/* 31 */
/* 256 */	NdrFcShort( 0x22e ),	/* Offset= 558 (814) */
/* 258 */	NdrFcLong( 0xd ),	/* 13 */
/* 262 */	NdrFcShort( 0x22c ),	/* Offset= 556 (818) */
/* 264 */	NdrFcLong( 0x9 ),	/* 9 */
/* 268 */	NdrFcShort( 0x238 ),	/* Offset= 568 (836) */
/* 270 */	NdrFcLong( 0x42 ),	/* 66 */
/* 274 */	NdrFcShort( 0x244 ),	/* Offset= 580 (854) */
/* 276 */	NdrFcLong( 0x44 ),	/* 68 */
/* 280 */	NdrFcShort( 0x23e ),	/* Offset= 574 (854) */
/* 282 */	NdrFcLong( 0x43 ),	/* 67 */
/* 286 */	NdrFcShort( 0x24a ),	/* Offset= 586 (872) */
/* 288 */	NdrFcLong( 0x45 ),	/* 69 */
/* 292 */	NdrFcShort( 0x244 ),	/* Offset= 580 (872) */
/* 294 */	NdrFcLong( 0x49 ),	/* 73 */
/* 298 */	NdrFcShort( 0x250 ),	/* Offset= 592 (890) */
/* 300 */	NdrFcLong( 0x2010 ),	/* 8208 */
/* 304 */	NdrFcShort( 0x5d0 ),	/* Offset= 1488 (1792) */
/* 306 */	NdrFcLong( 0x2011 ),	/* 8209 */
/* 310 */	NdrFcShort( 0x5ca ),	/* Offset= 1482 (1792) */
/* 312 */	NdrFcLong( 0x2002 ),	/* 8194 */
/* 316 */	NdrFcShort( 0x5c4 ),	/* Offset= 1476 (1792) */
/* 318 */	NdrFcLong( 0x2012 ),	/* 8210 */
/* 322 */	NdrFcShort( 0x5be ),	/* Offset= 1470 (1792) */
/* 324 */	NdrFcLong( 0x2003 ),	/* 8195 */
/* 328 */	NdrFcShort( 0x5b8 ),	/* Offset= 1464 (1792) */
/* 330 */	NdrFcLong( 0x2013 ),	/* 8211 */
/* 334 */	NdrFcShort( 0x5b2 ),	/* Offset= 1458 (1792) */
/* 336 */	NdrFcLong( 0x2016 ),	/* 8214 */
/* 340 */	NdrFcShort( 0x5ac ),	/* Offset= 1452 (1792) */
/* 342 */	NdrFcLong( 0x2017 ),	/* 8215 */
/* 346 */	NdrFcShort( 0x5a6 ),	/* Offset= 1446 (1792) */
/* 348 */	NdrFcLong( 0x2004 ),	/* 8196 */
/* 352 */	NdrFcShort( 0x5a0 ),	/* Offset= 1440 (1792) */
/* 354 */	NdrFcLong( 0x2005 ),	/* 8197 */
/* 358 */	NdrFcShort( 0x59a ),	/* Offset= 1434 (1792) */
/* 360 */	NdrFcLong( 0x2006 ),	/* 8198 */
/* 364 */	NdrFcShort( 0x594 ),	/* Offset= 1428 (1792) */
/* 366 */	NdrFcLong( 0x2007 ),	/* 8199 */
/* 370 */	NdrFcShort( 0x58e ),	/* Offset= 1422 (1792) */
/* 372 */	NdrFcLong( 0x2008 ),	/* 8200 */
/* 376 */	NdrFcShort( 0x588 ),	/* Offset= 1416 (1792) */
/* 378 */	NdrFcLong( 0x200b ),	/* 8203 */
/* 382 */	NdrFcShort( 0x582 ),	/* Offset= 1410 (1792) */
/* 384 */	NdrFcLong( 0x200e ),	/* 8206 */
/* 388 */	NdrFcShort( 0x57c ),	/* Offset= 1404 (1792) */
/* 390 */	NdrFcLong( 0x2009 ),	/* 8201 */
/* 394 */	NdrFcShort( 0x576 ),	/* Offset= 1398 (1792) */
/* 396 */	NdrFcLong( 0x200d ),	/* 8205 */
/* 400 */	NdrFcShort( 0x570 ),	/* Offset= 1392 (1792) */
/* 402 */	NdrFcLong( 0x200a ),	/* 8202 */
/* 406 */	NdrFcShort( 0x56a ),	/* Offset= 1386 (1792) */
/* 408 */	NdrFcLong( 0x200c ),	/* 8204 */
/* 412 */	NdrFcShort( 0x564 ),	/* Offset= 1380 (1792) */
/* 414 */	NdrFcLong( 0x1010 ),	/* 4112 */
/* 418 */	NdrFcShort( 0x574 ),	/* Offset= 1396 (1814) */
/* 420 */	NdrFcLong( 0x1011 ),	/* 4113 */
/* 424 */	NdrFcShort( 0x56e ),	/* Offset= 1390 (1814) */
/* 426 */	NdrFcLong( 0x1002 ),	/* 4098 */
/* 430 */	NdrFcShort( 0x4dc ),	/* Offset= 1244 (1674) */
/* 432 */	NdrFcLong( 0x1012 ),	/* 4114 */
/* 436 */	NdrFcShort( 0x4d6 ),	/* Offset= 1238 (1674) */
/* 438 */	NdrFcLong( 0x1003 ),	/* 4099 */
/* 442 */	NdrFcShort( 0x4f0 ),	/* Offset= 1264 (1706) */
/* 444 */	NdrFcLong( 0x1013 ),	/* 4115 */
/* 448 */	NdrFcShort( 0x4ea ),	/* Offset= 1258 (1706) */
/* 450 */	NdrFcLong( 0x1014 ),	/* 4116 */
/* 454 */	NdrFcShort( 0x574 ),	/* Offset= 1396 (1850) */
/* 456 */	NdrFcLong( 0x1015 ),	/* 4117 */
/* 460 */	NdrFcShort( 0x56e ),	/* Offset= 1390 (1850) */
/* 462 */	NdrFcLong( 0x1004 ),	/* 4100 */
/* 466 */	NdrFcShort( 0x588 ),	/* Offset= 1416 (1882) */
/* 468 */	NdrFcLong( 0x1005 ),	/* 4101 */
/* 472 */	NdrFcShort( 0x5a2 ),	/* Offset= 1442 (1914) */
/* 474 */	NdrFcLong( 0x100b ),	/* 4107 */
/* 478 */	NdrFcShort( 0x4ac ),	/* Offset= 1196 (1674) */
/* 480 */	NdrFcLong( 0x100a ),	/* 4106 */
/* 484 */	NdrFcShort( 0x4c6 ),	/* Offset= 1222 (1706) */
/* 486 */	NdrFcLong( 0x1006 ),	/* 4102 */
/* 490 */	NdrFcShort( 0x550 ),	/* Offset= 1360 (1850) */
/* 492 */	NdrFcLong( 0x1007 ),	/* 4103 */
/* 496 */	NdrFcShort( 0x58a ),	/* Offset= 1418 (1914) */
/* 498 */	NdrFcLong( 0x1040 ),	/* 4160 */
/* 502 */	NdrFcShort( 0x5a8 ),	/* Offset= 1448 (1950) */
/* 504 */	NdrFcLong( 0x1048 ),	/* 4168 */
/* 508 */	NdrFcShort( 0x5c6 ),	/* Offset= 1478 (1986) */
/* 510 */	NdrFcLong( 0x1047 ),	/* 4167 */
/* 514 */	NdrFcShort( 0x5f6 ),	/* Offset= 1526 (2040) */
/* 516 */	NdrFcLong( 0x1008 ),	/* 4104 */
/* 520 */	NdrFcShort( 0x61a ),	/* Offset= 1562 (2082) */
/* 522 */	NdrFcLong( 0x1fff ),	/* 8191 */
/* 526 */	NdrFcShort( 0x64a ),	/* Offset= 1610 (2136) */
/* 528 */	NdrFcLong( 0x101e ),	/* 4126 */
/* 532 */	NdrFcShort( 0x678 ),	/* Offset= 1656 (2188) */
/* 534 */	NdrFcLong( 0x101f ),	/* 4127 */
/* 538 */	NdrFcShort( 0x6a6 ),	/* Offset= 1702 (2240) */
/* 540 */	NdrFcLong( 0x100c ),	/* 4108 */
/* 544 */	NdrFcShort( 0x6ca ),	/* Offset= 1738 (2282) */
/* 546 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 550 */	NdrFcShort( 0x3cc ),	/* Offset= 972 (1522) */
/* 552 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 556 */	NdrFcShort( 0x3c6 ),	/* Offset= 966 (1522) */
/* 558 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 562 */	NdrFcShort( 0x37e ),	/* Offset= 894 (1456) */
/* 564 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 568 */	NdrFcShort( 0x378 ),	/* Offset= 888 (1456) */
/* 570 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 574 */	NdrFcShort( 0x376 ),	/* Offset= 886 (1460) */
/* 576 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 580 */	NdrFcShort( 0x370 ),	/* Offset= 880 (1460) */
/* 582 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 586 */	NdrFcShort( 0x36a ),	/* Offset= 874 (1460) */
/* 588 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 592 */	NdrFcShort( 0x364 ),	/* Offset= 868 (1460) */
/* 594 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 598 */	NdrFcShort( 0x362 ),	/* Offset= 866 (1464) */
/* 600 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 604 */	NdrFcShort( 0x360 ),	/* Offset= 864 (1468) */
/* 606 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 610 */	NdrFcShort( 0x34e ),	/* Offset= 846 (1456) */
/* 612 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 616 */	NdrFcShort( 0x386 ),	/* Offset= 902 (1518) */
/* 618 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 622 */	NdrFcShort( 0x346 ),	/* Offset= 838 (1460) */
/* 624 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 628 */	NdrFcShort( 0x34c ),	/* Offset= 844 (1472) */
/* 630 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 634 */	NdrFcShort( 0x342 ),	/* Offset= 834 (1468) */
/* 636 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 640 */	NdrFcShort( 0x67a ),	/* Offset= 1658 (2298) */
/* 642 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 646 */	NdrFcShort( 0x342 ),	/* Offset= 834 (1480) */
/* 648 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 652 */	NdrFcShort( 0x340 ),	/* Offset= 832 (1484) */
/* 654 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 658 */	NdrFcShort( 0x66c ),	/* Offset= 1644 (2302) */
/* 660 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 664 */	NdrFcShort( 0x66a ),	/* Offset= 1642 (2306) */
/* 666 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (665) */
/* 668 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 670 */	NdrFcShort( 0x8 ),	/* 8 */
/* 672 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 674 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 676 */	NdrFcShort( 0x8 ),	/* 8 */
/* 678 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 680 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 682 */	
			0x13, 0x0,	/* FC_OP */
/* 684 */	NdrFcShort( 0x8 ),	/* Offset= 8 (692) */
/* 686 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 688 */	NdrFcShort( 0x8 ),	/* 8 */
/* 690 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 692 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 694 */	NdrFcShort( 0x10 ),	/* 16 */
/* 696 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 698 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 700 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (686) */
			0x5b,		/* FC_END */
/* 704 */	
			0x13, 0x0,	/* FC_OP */
/* 706 */	NdrFcShort( 0xe ),	/* Offset= 14 (720) */
/* 708 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 710 */	NdrFcShort( 0x1 ),	/* 1 */
/* 712 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 714 */	NdrFcShort( 0x1 ),	/* 1 */
/* 716 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 718 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 720 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 722 */	NdrFcShort( 0xc ),	/* 12 */
/* 724 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 726 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 728 */	NdrFcShort( 0x8 ),	/* 8 */
/* 730 */	NdrFcShort( 0x8 ),	/* 8 */
/* 732 */	0x13, 0x0,	/* FC_OP */
/* 734 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (708) */
/* 736 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 738 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 740 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 742 */	
			0x13, 0x0,	/* FC_OP */
/* 744 */	NdrFcShort( 0xe ),	/* Offset= 14 (758) */
/* 746 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 748 */	NdrFcShort( 0x2 ),	/* 2 */
/* 750 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 752 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 754 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 756 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 758 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 760 */	NdrFcShort( 0x8 ),	/* 8 */
/* 762 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (746) */
/* 764 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 766 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 768 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 772 */	NdrFcShort( 0x4 ),	/* 4 */
/* 774 */	NdrFcShort( 0x0 ),	/* 0 */
/* 776 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (742) */
/* 778 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 780 */	NdrFcShort( 0x1 ),	/* 1 */
/* 782 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 786 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 788 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 790 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x8 ),	/* 8 */
/* 794 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 796 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 798 */	NdrFcShort( 0x4 ),	/* 4 */
/* 800 */	NdrFcShort( 0x4 ),	/* 4 */
/* 802 */	0x13, 0x0,	/* FC_OP */
/* 804 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (778) */
/* 806 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 808 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 810 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 812 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 814 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 816 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 818 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 820 */	NdrFcLong( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 830 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 832 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 834 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 836 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 838 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 842 */	NdrFcShort( 0x0 ),	/* 0 */
/* 844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 846 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 848 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 850 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 852 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 854 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 856 */	NdrFcLong( 0xc ),	/* 12 */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */
/* 864 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 866 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 868 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 870 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 872 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 874 */	NdrFcLong( 0xb ),	/* 11 */
/* 878 */	NdrFcShort( 0x0 ),	/* 0 */
/* 880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 882 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 884 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 886 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 888 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 890 */	
			0x13, 0x0,	/* FC_OP */
/* 892 */	NdrFcShort( 0x2 ),	/* Offset= 2 (894) */
/* 894 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 896 */	NdrFcShort( 0x14 ),	/* 20 */
/* 898 */	NdrFcShort( 0x0 ),	/* 0 */
/* 900 */	NdrFcShort( 0xc ),	/* Offset= 12 (912) */
/* 902 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 904 */	NdrFcShort( 0xffffff2c ),	/* Offset= -212 (692) */
/* 906 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 908 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (854) */
/* 910 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 912 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 914 */	NdrFcShort( 0x2 ),	/* Offset= 2 (916) */
/* 916 */	
			0x13, 0x0,	/* FC_OP */
/* 918 */	NdrFcShort( 0x358 ),	/* Offset= 856 (1774) */
/* 920 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 922 */	NdrFcShort( 0x18 ),	/* 24 */
/* 924 */	NdrFcShort( 0xa ),	/* 10 */
/* 926 */	NdrFcLong( 0x8 ),	/* 8 */
/* 930 */	NdrFcShort( 0x5a ),	/* Offset= 90 (1020) */
/* 932 */	NdrFcLong( 0xd ),	/* 13 */
/* 936 */	NdrFcShort( 0x7e ),	/* Offset= 126 (1062) */
/* 938 */	NdrFcLong( 0x9 ),	/* 9 */
/* 942 */	NdrFcShort( 0x9e ),	/* Offset= 158 (1100) */
/* 944 */	NdrFcLong( 0xc ),	/* 12 */
/* 948 */	NdrFcShort( 0x276 ),	/* Offset= 630 (1578) */
/* 950 */	NdrFcLong( 0x24 ),	/* 36 */
/* 954 */	NdrFcShort( 0x2a0 ),	/* Offset= 672 (1626) */
/* 956 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 960 */	NdrFcShort( 0x2aa ),	/* Offset= 682 (1642) */
/* 962 */	NdrFcLong( 0x10 ),	/* 16 */
/* 966 */	NdrFcShort( 0xffffff50 ),	/* Offset= -176 (790) */
/* 968 */	NdrFcLong( 0x2 ),	/* 2 */
/* 972 */	NdrFcShort( 0x2be ),	/* Offset= 702 (1674) */
/* 974 */	NdrFcLong( 0x3 ),	/* 3 */
/* 978 */	NdrFcShort( 0x2d8 ),	/* Offset= 728 (1706) */
/* 980 */	NdrFcLong( 0x14 ),	/* 20 */
/* 984 */	NdrFcShort( 0x2f2 ),	/* Offset= 754 (1738) */
/* 986 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (985) */
/* 988 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 990 */	NdrFcShort( 0x4 ),	/* 4 */
/* 992 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 996 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 998 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1000 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1002 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1008 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1012 */	0x13, 0x0,	/* FC_OP */
/* 1014 */	NdrFcShort( 0xffffff00 ),	/* Offset= -256 (758) */
/* 1016 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1018 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1020 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1022 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1024 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1026 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1028 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1030 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1032 */	0x11, 0x0,	/* FC_RP */
/* 1034 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (988) */
/* 1036 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1038 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1040 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1042 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1044 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1046 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1048 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1050 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1054 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1056 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1058 */	NdrFcShort( 0xffffff10 ),	/* Offset= -240 (818) */
/* 1060 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1062 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1064 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1066 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1068 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1074) */
/* 1070 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1072 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1074 */	
			0x11, 0x0,	/* FC_RP */
/* 1076 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1040) */
/* 1078 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1080 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1082 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1084 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1086 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1088 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1092 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1094 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1096 */	NdrFcShort( 0xfffffefc ),	/* Offset= -260 (836) */
/* 1098 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1100 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1104 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1106 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1112) */
/* 1108 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1110 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1112 */	
			0x11, 0x0,	/* FC_RP */
/* 1114 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1078) */
/* 1116 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 1118 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1120 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 1122 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1124 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1126) */
/* 1126 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1128 */	NdrFcShort( 0x2b ),	/* 43 */
/* 1130 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1134 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1136 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1140 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 1142 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1146 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1148 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1152 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1154 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1158 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1160 */	NdrFcLong( 0xb ),	/* 11 */
/* 1164 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1166 */	NdrFcLong( 0xa ),	/* 10 */
/* 1170 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1172 */	NdrFcLong( 0x6 ),	/* 6 */
/* 1176 */	NdrFcShort( 0xfffffe04 ),	/* Offset= -508 (668) */
/* 1178 */	NdrFcLong( 0x7 ),	/* 7 */
/* 1182 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1184 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1188 */	NdrFcShort( 0xfffffe42 ),	/* Offset= -446 (742) */
/* 1190 */	NdrFcLong( 0xd ),	/* 13 */
/* 1194 */	NdrFcShort( 0xfffffe88 ),	/* Offset= -376 (818) */
/* 1196 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1200 */	NdrFcShort( 0xfffffe94 ),	/* Offset= -364 (836) */
/* 1202 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 1206 */	NdrFcShort( 0xb8 ),	/* Offset= 184 (1390) */
/* 1208 */	NdrFcLong( 0x24 ),	/* 36 */
/* 1212 */	NdrFcShort( 0xba ),	/* Offset= 186 (1398) */
/* 1214 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 1218 */	NdrFcShort( 0xb4 ),	/* Offset= 180 (1398) */
/* 1220 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 1224 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (1452) */
/* 1226 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 1230 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (1456) */
/* 1232 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 1236 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (1460) */
/* 1238 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 1242 */	NdrFcShort( 0xde ),	/* Offset= 222 (1464) */
/* 1244 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 1248 */	NdrFcShort( 0xdc ),	/* Offset= 220 (1468) */
/* 1250 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 1254 */	NdrFcShort( 0xca ),	/* Offset= 202 (1456) */
/* 1256 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 1260 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (1460) */
/* 1262 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 1266 */	NdrFcShort( 0xce ),	/* Offset= 206 (1472) */
/* 1268 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 1272 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (1468) */
/* 1274 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 1278 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (1476) */
/* 1280 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 1284 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (1480) */
/* 1286 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 1290 */	NdrFcShort( 0xc2 ),	/* Offset= 194 (1484) */
/* 1292 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 1296 */	NdrFcShort( 0xc0 ),	/* Offset= 192 (1488) */
/* 1298 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 1302 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (1500) */
/* 1304 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1308 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1310 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1314 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1316 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1320 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1322 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1326 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1328 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1332 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1334 */	NdrFcLong( 0xe ),	/* 14 */
/* 1338 */	NdrFcShort( 0xaa ),	/* Offset= 170 (1508) */
/* 1340 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 1344 */	NdrFcShort( 0xae ),	/* Offset= 174 (1518) */
/* 1346 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 1350 */	NdrFcShort( 0xac ),	/* Offset= 172 (1522) */
/* 1352 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 1356 */	NdrFcShort( 0x64 ),	/* Offset= 100 (1456) */
/* 1358 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 1362 */	NdrFcShort( 0x62 ),	/* Offset= 98 (1460) */
/* 1364 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 1368 */	NdrFcShort( 0x5c ),	/* Offset= 92 (1460) */
/* 1370 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 1374 */	NdrFcShort( 0x56 ),	/* Offset= 86 (1460) */
/* 1376 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1380 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1380) */
/* 1382 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1386 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1386) */
/* 1388 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (1387) */
/* 1390 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1392 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1394) */
/* 1394 */	
			0x13, 0x0,	/* FC_OP */
/* 1396 */	NdrFcShort( 0x17a ),	/* Offset= 378 (1774) */
/* 1398 */	
			0x13, 0x0,	/* FC_OP */
/* 1400 */	NdrFcShort( 0x20 ),	/* Offset= 32 (1432) */
/* 1402 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1404 */	NdrFcLong( 0x2f ),	/* 47 */
/* 1408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1410 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1412 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1414 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1416 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1418 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1420 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1422 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1424 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1426 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1428 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1430 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1432 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1434 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1438 */	NdrFcShort( 0xa ),	/* Offset= 10 (1448) */
/* 1440 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1442 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1444 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1402) */
/* 1446 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1448 */	
			0x13, 0x0,	/* FC_OP */
/* 1450 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1420) */
/* 1452 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1454 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 1456 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1458 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1460 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1462 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1464 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1466 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 1468 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1470 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 1472 */	
			0x13, 0x0,	/* FC_OP */
/* 1474 */	NdrFcShort( 0xfffffcda ),	/* Offset= -806 (668) */
/* 1476 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1478 */	NdrFcShort( 0xfffffd20 ),	/* Offset= -736 (742) */
/* 1480 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1482 */	NdrFcShort( 0xfffffd68 ),	/* Offset= -664 (818) */
/* 1484 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1486 */	NdrFcShort( 0xfffffd76 ),	/* Offset= -650 (836) */
/* 1488 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1490 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1492) */
/* 1492 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1494 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1496) */
/* 1496 */	
			0x13, 0x0,	/* FC_OP */
/* 1498 */	NdrFcShort( 0x114 ),	/* Offset= 276 (1774) */
/* 1500 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1502 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1504) */
/* 1504 */	
			0x13, 0x0,	/* FC_OP */
/* 1506 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1526) */
/* 1508 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 1510 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1512 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 1514 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 1516 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1518 */	
			0x13, 0x0,	/* FC_OP */
/* 1520 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1508) */
/* 1522 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1524 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1526 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 1528 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1532 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1532) */
/* 1534 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1536 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1538 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1540 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1542 */	NdrFcShort( 0xfffffe56 ),	/* Offset= -426 (1116) */
/* 1544 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1546 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1548 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1550 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1552 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1554 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1556 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1558 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1560 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1564 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1568 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1570 */	0x13, 0x0,	/* FC_OP */
/* 1572 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1526) */
/* 1574 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1576 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1578 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1580 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1584 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1590) */
/* 1586 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1588 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1590 */	
			0x11, 0x0,	/* FC_RP */
/* 1592 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1546) */
/* 1594 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1596 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1598 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1602 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1604 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1606 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1608 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1612 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1614 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1616 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1618 */	0x13, 0x0,	/* FC_OP */
/* 1620 */	NdrFcShort( 0xffffff44 ),	/* Offset= -188 (1432) */
/* 1622 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1624 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1626 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1628 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1630 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1632 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1638) */
/* 1634 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1636 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1638 */	
			0x11, 0x0,	/* FC_RP */
/* 1640 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1594) */
/* 1642 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1644 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1648 */	NdrFcShort( 0xa ),	/* Offset= 10 (1658) */
/* 1650 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1652 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1654 */	NdrFcShort( 0xfffffc3e ),	/* Offset= -962 (692) */
/* 1656 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1658 */	
			0x11, 0x0,	/* FC_RP */
/* 1660 */	NdrFcShort( 0xfffffd94 ),	/* Offset= -620 (1040) */
/* 1662 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1664 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1666 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1670 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1672 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1674 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1676 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1678 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1680 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1682 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1684 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1686 */	0x13, 0x0,	/* FC_OP */
/* 1688 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1662) */
/* 1690 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1692 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1694 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1696 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1698 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1702 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1704 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1706 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1708 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1710 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1712 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1714 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1716 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1718 */	0x13, 0x0,	/* FC_OP */
/* 1720 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1694) */
/* 1722 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1724 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1726 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1728 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1730 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1734 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1736 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1738 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1740 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1742 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1744 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1746 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1748 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1750 */	0x13, 0x0,	/* FC_OP */
/* 1752 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1726) */
/* 1754 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1756 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1758 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1760 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1762 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1764 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1766 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1768 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1770 */	NdrFcShort( 0xfffffbb8 ),	/* Offset= -1096 (674) */
/* 1772 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1774 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1776 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1778 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1758) */
/* 1780 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1780) */
/* 1782 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1784 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1786 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1788 */	NdrFcShort( 0xfffffc9c ),	/* Offset= -868 (920) */
/* 1790 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1792 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1794 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1796 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1798 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1800 */	NdrFcShort( 0xfffffc88 ),	/* Offset= -888 (912) */
/* 1802 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1804 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1806 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1808 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1810 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1812 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1814 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1816 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1818 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1820 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1822 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1824 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1826 */	0x13, 0x0,	/* FC_OP */
/* 1828 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1802) */
/* 1830 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1832 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1834 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1836 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1838 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1840 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1842 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1844 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1846 */	NdrFcShort( 0xfffffb66 ),	/* Offset= -1178 (668) */
/* 1848 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1850 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1852 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1854 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1856 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1858 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1860 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1862 */	0x13, 0x0,	/* FC_OP */
/* 1864 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1834) */
/* 1866 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1868 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1870 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1872 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1874 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1876 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1878 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1880 */	0xa,		/* FC_FLOAT */
			0x5b,		/* FC_END */
/* 1882 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1884 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1886 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1888 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1890 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1892 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1894 */	0x13, 0x0,	/* FC_OP */
/* 1896 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1870) */
/* 1898 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1900 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1902 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1904 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1906 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1908 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1910 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1912 */	0xc,		/* FC_DOUBLE */
			0x5b,		/* FC_END */
/* 1914 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1916 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1918 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1920 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1922 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1924 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1926 */	0x13, 0x0,	/* FC_OP */
/* 1928 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1902) */
/* 1930 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1932 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1934 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1936 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1938 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1940 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1942 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1944 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1946 */	NdrFcShort( 0xfffffb08 ),	/* Offset= -1272 (674) */
/* 1948 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1950 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1952 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1954 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1956 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1958 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1960 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1962 */	0x13, 0x0,	/* FC_OP */
/* 1964 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1934) */
/* 1966 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1968 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1970 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1972 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1974 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1978 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1980 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1982 */	NdrFcShort( 0xfffffaf6 ),	/* Offset= -1290 (692) */
/* 1984 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1986 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1988 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1990 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1992 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1994 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1996 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1998 */	0x13, 0x0,	/* FC_OP */
/* 2000 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1970) */
/* 2002 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2004 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2006 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2008 */	NdrFcShort( 0xc ),	/* 12 */
/* 2010 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2014 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2016 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2018 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2020 */	NdrFcShort( 0xc ),	/* 12 */
/* 2022 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2024 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2026 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2028 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2030 */	0x13, 0x0,	/* FC_OP */
/* 2032 */	NdrFcShort( 0xfffffad4 ),	/* Offset= -1324 (708) */
/* 2034 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2036 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffadb ),	/* Offset= -1317 (720) */
			0x5b,		/* FC_END */
/* 2040 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2042 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2044 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2046 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2048 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2050 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2052 */	0x13, 0x0,	/* FC_OP */
/* 2054 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (2006) */
/* 2056 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2058 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2060 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2062 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2064 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2066 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2068 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2070 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2074 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2076 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2078 */	NdrFcShort( 0xfffffae2 ),	/* Offset= -1310 (768) */
/* 2080 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2082 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2084 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2086 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2088 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2090 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2092 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2094 */	0x13, 0x0,	/* FC_OP */
/* 2096 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2060) */
/* 2098 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2100 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2102 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2104 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2106 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2110 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2112 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2114 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2120 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2122 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2124 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2126 */	0x13, 0x0,	/* FC_OP */
/* 2128 */	NdrFcShort( 0xfffffaba ),	/* Offset= -1350 (778) */
/* 2130 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2132 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffac1 ),	/* Offset= -1343 (790) */
			0x5b,		/* FC_END */
/* 2136 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2138 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2140 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2142 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2144 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2146 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2148 */	0x13, 0x0,	/* FC_OP */
/* 2150 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (2102) */
/* 2152 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2154 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2156 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2158 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2160 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2164 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2166 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2168 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2170 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2174 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2180 */	0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2182 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 2184 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2186 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2188 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2192 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2194 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2196 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2198 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2200 */	0x13, 0x0,	/* FC_OP */
/* 2202 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (2156) */
/* 2204 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2206 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2208 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2210 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2212 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2216 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2218 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2220 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2222 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2226 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2232 */	0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2234 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2236 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2238 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2240 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2242 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2244 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2246 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2248 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2250 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2252 */	0x13, 0x0,	/* FC_OP */
/* 2254 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (2208) */
/* 2256 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2258 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2260 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2264 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2268 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2270 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2274 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2276 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2278 */	NdrFcShort( 0x20 ),	/* Offset= 32 (2310) */
/* 2280 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2282 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2288 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2294) */
/* 2290 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 2292 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2294 */	
			0x13, 0x0,	/* FC_OP */
/* 2296 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2260) */
/* 2298 */	
			0x13, 0x0,	/* FC_OP */
/* 2300 */	NdrFcShort( 0xfffffa04 ),	/* Offset= -1532 (768) */
/* 2302 */	
			0x13, 0x0,	/* FC_OP */
/* 2304 */	NdrFcShort( 0xfffffe00 ),	/* Offset= -512 (1792) */
/* 2306 */	
			0x13, 0x0,	/* FC_OP */
/* 2308 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2310) */
/* 2310 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2312 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2316 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2316) */
/* 2318 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 2320 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 2322 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2324 */	NdrFcShort( 0xfffff732 ),	/* Offset= -2254 (70) */
/* 2326 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2328 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2332 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2334 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2336 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2338 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2342 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2344 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2346 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2310) */
/* 2348 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2350 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2352 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2354 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2356 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2358 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2360 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2362 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2364 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2366 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2368 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2370 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2372 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2374 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2376 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2380 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2386 */	0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2388 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2390 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2392 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2394 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2396 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2398 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2400 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2402 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2404 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2406 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2408 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2410 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2412 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2418 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2420 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2422 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2424 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2426 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2428 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2430) */
/* 2430 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2432 */	NdrFcLong( 0x139 ),	/* 313 */
/* 2436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2440 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2442 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2444 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2446 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2448 */	
			0x11, 0x0,	/* FC_RP */
/* 2450 */	NdrFcShort( 0xfffff910 ),	/* Offset= -1776 (674) */
/* 2452 */	
			0x11, 0x0,	/* FC_RP */
/* 2454 */	NdrFcShort( 0xfffff91e ),	/* Offset= -1762 (692) */
/* 2456 */	
			0x11, 0x0,	/* FC_RP */
/* 2458 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2460) */
/* 2460 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 2462 */	NdrFcShort( 0x40 ),	/* 64 */
/* 2464 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2466 */	NdrFcShort( 0xfffff912 ),	/* Offset= -1774 (692) */
/* 2468 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2470 */	NdrFcShort( 0xfffff90e ),	/* Offset= -1778 (692) */
/* 2472 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2474 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff8f7 ),	/* Offset= -1801 (674) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2478 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff8f3 ),	/* Offset= -1805 (674) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2482 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff8ef ),	/* Offset= -1809 (674) */
			0x8,		/* FC_LONG */
/* 2486 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2488 */	
			0x12, 0x0,	/* FC_UP */
/* 2490 */	NdrFcShort( 0xfffff8fa ),	/* Offset= -1798 (692) */
/* 2492 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2494 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2496) */
/* 2496 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2498 */	NdrFcLong( 0x138 ),	/* 312 */
/* 2502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2504 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2506 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2508 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2510 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2512 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2514 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2516 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2518) */
/* 2518 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2520 */	NdrFcLong( 0x13b ),	/* 315 */
/* 2524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2528 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2530 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2532 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2534 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2536 */	
			0x11, 0x0,	/* FC_RP */
/* 2538 */	NdrFcShort( 0x14 ),	/* Offset= 20 (2558) */
/* 2540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2542 */	NdrFcShort( 0xc ),	/* 12 */
/* 2544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2546 */	NdrFcShort( 0x8 ),	/* Offset= 8 (2554) */
/* 2548 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 2550 */	0x6,		/* FC_SHORT */
			0x3e,		/* FC_STRUCTPAD2 */
/* 2552 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2554 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2556 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2558 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2560 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2562 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2564 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2566 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2568 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 2570 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2572 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2574 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2576 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2540) */
/* 2578 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2580 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2582 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2584 */	
			0x11, 0x0,	/* FC_RP */
/* 2586 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2588) */
/* 2588 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 2590 */	NdrFcShort( 0x40 ),	/* 64 */
/* 2592 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2594 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2596 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2598 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 2600 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2602 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2604 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2606 */	NdrFcShort( 0xffffff6e ),	/* Offset= -146 (2460) */
/* 2608 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            }

        };


static void __RPC_USER IPropertyStorage_PROPVARIANTExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    PROPVARIANT *pS	=	( PROPVARIANT * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( ( unsigned short  )pS->vt );
}

static void __RPC_USER IPropertyStorage_CLIPDATAExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    CLIPDATA *pS	=	( CLIPDATA * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->cbSize - 4 );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    IPropertyStorage_PROPVARIANTExprEval_0000
    ,IPropertyStorage_CLIPDATAExprEval_0001
    };



/* Standard interface: __MIDL_itf_propidl_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IPropertyStorage, ver. 0.0,
   GUID={0x00000138,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IPropertyStorage_FormatStringOffsetTable[] =
    {
    0,
    48,
    102,
    144,
    192,
    240,
    282,
    318,
    348,
    384,
    432,
    468
    };

static const MIDL_STUBLESS_PROXY_INFO IPropertyStorage_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IPropertyStorage_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IPropertyStorage_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IPropertyStorage_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(15) _IPropertyStorageProxyVtbl = 
{
    &IPropertyStorage_ProxyInfo,
    &IID_IPropertyStorage,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::ReadMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::WriteMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::DeleteMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::ReadPropertyNames */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::WritePropertyNames */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::DeletePropertyNames */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::Commit */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::Revert */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::Enum */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::SetTimes */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::SetClass */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::Stat */
};

const CInterfaceStubVtbl _IPropertyStorageStubVtbl =
{
    &IID_IPropertyStorage,
    &IPropertyStorage_ServerInfo,
    15,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IPropertySetStorage, ver. 0.0,
   GUID={0x0000013A,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IPropertySetStorage_FormatStringOffsetTable[] =
    {
    504,
    564,
    612,
    648
    };

static const MIDL_STUBLESS_PROXY_INFO IPropertySetStorage_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IPropertySetStorage_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IPropertySetStorage_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IPropertySetStorage_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IPropertySetStorageProxyVtbl = 
{
    &IPropertySetStorage_ProxyInfo,
    &IID_IPropertySetStorage,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IPropertySetStorage::Create */ ,
    (void *) (INT_PTR) -1 /* IPropertySetStorage::Open */ ,
    (void *) (INT_PTR) -1 /* IPropertySetStorage::Delete */ ,
    (void *) (INT_PTR) -1 /* IPropertySetStorage::Enum */
};

const CInterfaceStubVtbl _IPropertySetStorageStubVtbl =
{
    &IID_IPropertySetStorage,
    &IPropertySetStorage_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumSTATPROPSTG, ver. 0.0,
   GUID={0x00000139,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumSTATPROPSTG_FormatStringOffsetTable[] =
    {
    684,
    732,
    768,
    798
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPSTG_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPSTG_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IEnumSTATPROPSTG_StubThunkTable[] = 
    {
    IEnumSTATPROPSTG_RemoteNext_Thunk,
    0,
    0,
    0
    };

static const MIDL_SERVER_INFO IEnumSTATPROPSTG_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPSTG_FormatStringOffsetTable[-3],
    &IEnumSTATPROPSTG_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IEnumSTATPROPSTGProxyVtbl = 
{
    &IEnumSTATPROPSTG_ProxyInfo,
    &IID_IEnumSTATPROPSTG,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IEnumSTATPROPSTG_Next_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSTG::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSTG::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSTG::Clone */
};

const CInterfaceStubVtbl _IEnumSTATPROPSTGStubVtbl =
{
    &IID_IEnumSTATPROPSTG,
    &IEnumSTATPROPSTG_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumSTATPROPSETSTG, ver. 0.0,
   GUID={0x0000013B,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumSTATPROPSETSTG_FormatStringOffsetTable[] =
    {
    834,
    732,
    768,
    648
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPSETSTG_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPSETSTG_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IEnumSTATPROPSETSTG_StubThunkTable[] = 
    {
    IEnumSTATPROPSETSTG_RemoteNext_Thunk,
    0,
    0,
    0
    };

static const MIDL_SERVER_INFO IEnumSTATPROPSETSTG_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPSETSTG_FormatStringOffsetTable[-3],
    &IEnumSTATPROPSETSTG_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IEnumSTATPROPSETSTGProxyVtbl = 
{
    &IEnumSTATPROPSETSTG_ProxyInfo,
    &IID_IEnumSTATPROPSETSTG,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IEnumSTATPROPSETSTG_Next_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSETSTG::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSETSTG::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSETSTG::Clone */
};

const CInterfaceStubVtbl _IEnumSTATPROPSETSTGStubVtbl =
{
    &IID_IEnumSTATPROPSETSTG,
    &IEnumSTATPROPSETSTG_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_propidl_0109, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _propidl_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IPropertyStorageProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumSTATPROPSTGProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IPropertySetStorageProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumSTATPROPSETSTGProxyVtbl,
    0
};

const CInterfaceStubVtbl * _propidl_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IPropertyStorageStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumSTATPROPSTGStubVtbl,
    ( CInterfaceStubVtbl *) &_IPropertySetStorageStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumSTATPROPSETSTGStubVtbl,
    0
};

PCInterfaceName const _propidl_InterfaceNamesList[] = 
{
    "IPropertyStorage",
    "IEnumSTATPROPSTG",
    "IPropertySetStorage",
    "IEnumSTATPROPSETSTG",
    0
};


#define _propidl_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _propidl, pIID, n)

int __stdcall _propidl_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _propidl, 4, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _propidl, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _propidl, 4, *pIndex )
    
}

const ExtendedProxyFileInfo propidl_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _propidl_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _propidl_StubVtblList,
    (const PCInterfaceName * ) & _propidl_InterfaceNamesList,
    0, // no delegation
    & _propidl_IID_Lookup, 
    4,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:28 2002
 */
/* Compiler settings for propidl.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "propidl.h"

#define TYPE_FORMAT_STRING_SIZE   2641                              
#define PROC_FORMAT_STRING_SIZE   925                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IPropertyStorage_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IPropertyStorage_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IPropertySetStorage_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IPropertySetStorage_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumSTATPROPSTG_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPSTG_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
    /* [out] */ ULONG *pceltFetched)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[716],
                  ( unsigned char * )This,
                  celt,
                  rgelt,
                  pceltFetched);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IEnumSTATPROPSTG_RemoteNext_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IEnumSTATPROPSTG *This;
        ULONG celt;
        char Pad0[4];
        STATPROPSTG *rgelt;
        ULONG *pceltFetched;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IEnumSTATPROPSTG_Next_Stub(
                                     (IEnumSTATPROPSTG *) pParamStruct->This,
                                     pParamStruct->celt,
                                     pParamStruct->rgelt,
                                     pParamStruct->pceltFetched);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumSTATPROPSETSTG_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPSETSTG_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
    /* [out] */ ULONG *pceltFetched)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[874],
                  ( unsigned char * )This,
                  celt,
                  rgelt,
                  pceltFetched);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IEnumSTATPROPSETSTG_RemoteNext_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IEnumSTATPROPSETSTG *This;
        ULONG celt;
        char Pad0[4];
        STATPROPSETSTG *rgelt;
        ULONG *pceltFetched;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IEnumSTATPROPSETSTG_Next_Stub(
                                        (IEnumSTATPROPSETSTG *) pParamStruct->This,
                                        pParamStruct->celt,
                                        pParamStruct->rgelt,
                                        pParamStruct->pceltFetched);
    
}


extern const EXPR_EVAL ExprEvalRoutines[];
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure ReadMultiple */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x44 ),	/* 68 */
/* 20 */	NdrFcShort( 0x2 ),	/* 2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpspec */

/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpspec */

/* 32 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	NdrFcShort( 0x32 ),	/* Type Offset=50 */

	/* Parameter rgpropvar */

/* 38 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	NdrFcShort( 0x94a ),	/* Type Offset=2378 */

	/* Return value */

/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 46 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteMultiple */

/* 50 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x4 ),	/* 4 */
/* 58 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 60 */	NdrFcShort( 0x10 ),	/* 16 */
/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
/* 64 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 66 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
/* 70 */	NdrFcShort( 0x46 ),	/* 70 */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpspec */

/* 76 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 78 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 80 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpspec */

/* 82 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 84 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 86 */	NdrFcShort( 0x32 ),	/* Type Offset=50 */

	/* Parameter rgpropvar */

/* 88 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 90 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 92 */	NdrFcShort( 0x94a ),	/* Type Offset=2378 */

	/* Parameter propidNameFirst */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 96 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 98 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 100 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 102 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DeleteMultiple */

/* 106 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0x5 ),	/* 5 */
/* 114 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 120 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 122 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 126 */	NdrFcShort( 0x2 ),	/* 2 */
/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 130 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpspec */

/* 132 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 134 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpspec */

/* 138 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 140 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 142 */	NdrFcShort( 0x32 ),	/* Type Offset=50 */

	/* Return value */

/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 146 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReadPropertyNames */

/* 150 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0x6 ),	/* 6 */
/* 158 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 160 */	NdrFcShort( 0x8 ),	/* 8 */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 166 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 168 */	NdrFcShort( 0x1 ),	/* 1 */
/* 170 */	NdrFcShort( 0x1 ),	/* 1 */
/* 172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpropid */

/* 176 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 178 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 180 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpropid */

/* 182 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 184 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 186 */	NdrFcShort( 0x960 ),	/* Type Offset=2400 */

	/* Parameter rglpwstrName */

/* 188 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 190 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 192 */	NdrFcShort( 0x96c ),	/* Type Offset=2412 */

	/* Return value */

/* 194 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 196 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WritePropertyNames */

/* 200 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 202 */	NdrFcLong( 0x0 ),	/* 0 */
/* 206 */	NdrFcShort( 0x7 ),	/* 7 */
/* 208 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
/* 212 */	NdrFcShort( 0x8 ),	/* 8 */
/* 214 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 216 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x2 ),	/* 2 */
/* 222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 224 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpropid */

/* 226 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 228 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 230 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpropid */

/* 232 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 234 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 236 */	NdrFcShort( 0x960 ),	/* Type Offset=2400 */

	/* Parameter rglpwstrName */

/* 238 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 240 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 242 */	NdrFcShort( 0x982 ),	/* Type Offset=2434 */

	/* Return value */

/* 244 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 246 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 248 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DeletePropertyNames */

/* 250 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 252 */	NdrFcLong( 0x0 ),	/* 0 */
/* 256 */	NdrFcShort( 0x8 ),	/* 8 */
/* 258 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 262 */	NdrFcShort( 0x8 ),	/* 8 */
/* 264 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 266 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 268 */	NdrFcShort( 0x0 ),	/* 0 */
/* 270 */	NdrFcShort( 0x1 ),	/* 1 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cpropid */

/* 276 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 278 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpropid */

/* 282 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 284 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 286 */	NdrFcShort( 0x960 ),	/* Type Offset=2400 */

	/* Return value */

/* 288 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 290 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 292 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Commit */

/* 294 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 296 */	NdrFcLong( 0x0 ),	/* 0 */
/* 300 */	NdrFcShort( 0x9 ),	/* 9 */
/* 302 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 304 */	NdrFcShort( 0x8 ),	/* 8 */
/* 306 */	NdrFcShort( 0x8 ),	/* 8 */
/* 308 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 310 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 316 */	NdrFcShort( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter grfCommitFlags */

/* 320 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 322 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 324 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 326 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 328 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Revert */

/* 332 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 334 */	NdrFcLong( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0xa ),	/* 10 */
/* 340 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x8 ),	/* 8 */
/* 346 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 348 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 352 */	NdrFcShort( 0x0 ),	/* 0 */
/* 354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 356 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 358 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 360 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 362 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Enum */

/* 364 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 366 */	NdrFcLong( 0x0 ),	/* 0 */
/* 370 */	NdrFcShort( 0xb ),	/* 11 */
/* 372 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x8 ),	/* 8 */
/* 378 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 380 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppenum */

/* 390 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 392 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 394 */	NdrFcShort( 0x998 ),	/* Type Offset=2456 */

	/* Return value */

/* 396 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 398 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetTimes */

/* 402 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 404 */	NdrFcLong( 0x0 ),	/* 0 */
/* 408 */	NdrFcShort( 0xc ),	/* 12 */
/* 410 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 412 */	NdrFcShort( 0x84 ),	/* 132 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 418 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	NdrFcShort( 0x0 ),	/* 0 */
/* 426 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pctime */

/* 428 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 430 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 432 */	NdrFcShort( 0x2a4 ),	/* Type Offset=676 */

	/* Parameter patime */

/* 434 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 436 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 438 */	NdrFcShort( 0x2a4 ),	/* Type Offset=676 */

	/* Parameter pmtime */

/* 440 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 442 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 444 */	NdrFcShort( 0x2a4 ),	/* Type Offset=676 */

	/* Return value */

/* 446 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 448 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 450 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetClass */

/* 452 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 454 */	NdrFcLong( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0xd ),	/* 13 */
/* 460 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 462 */	NdrFcShort( 0x44 ),	/* 68 */
/* 464 */	NdrFcShort( 0x8 ),	/* 8 */
/* 466 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 468 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter clsid */

/* 478 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 480 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 482 */	NdrFcShort( 0x2b6 ),	/* Type Offset=694 */

	/* Return value */

/* 484 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 486 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 488 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Stat */

/* 490 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 492 */	NdrFcLong( 0x0 ),	/* 0 */
/* 496 */	NdrFcShort( 0xe ),	/* 14 */
/* 498 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 502 */	NdrFcShort( 0xdc ),	/* 220 */
/* 504 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 506 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 508 */	NdrFcShort( 0x0 ),	/* 0 */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pstatpsstg */

/* 516 */	NdrFcShort( 0x112 ),	/* Flags:  must free, out, simple ref, */
/* 518 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 520 */	NdrFcShort( 0x9ba ),	/* Type Offset=2490 */

	/* Return value */

/* 522 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 524 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Create */

/* 528 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 530 */	NdrFcLong( 0x0 ),	/* 0 */
/* 534 */	NdrFcShort( 0x3 ),	/* 3 */
/* 536 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 538 */	NdrFcShort( 0x98 ),	/* 152 */
/* 540 */	NdrFcShort( 0x8 ),	/* 8 */
/* 542 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 544 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 548 */	NdrFcShort( 0x0 ),	/* 0 */
/* 550 */	NdrFcShort( 0x0 ),	/* 0 */
/* 552 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter rfmtid */

/* 554 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 556 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 558 */	NdrFcShort( 0x2b6 ),	/* Type Offset=694 */

	/* Parameter pclsid */

/* 560 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 562 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 564 */	NdrFcShort( 0x9d6 ),	/* Type Offset=2518 */

	/* Parameter grfFlags */

/* 566 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 568 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 570 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter grfMode */

/* 572 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 574 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 576 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppprstg */

/* 578 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 580 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 582 */	NdrFcShort( 0x9da ),	/* Type Offset=2522 */

	/* Return value */

/* 584 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 586 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 588 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Open */

/* 590 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 592 */	NdrFcLong( 0x0 ),	/* 0 */
/* 596 */	NdrFcShort( 0x4 ),	/* 4 */
/* 598 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 600 */	NdrFcShort( 0x4c ),	/* 76 */
/* 602 */	NdrFcShort( 0x8 ),	/* 8 */
/* 604 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 606 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 612 */	NdrFcShort( 0x0 ),	/* 0 */
/* 614 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter rfmtid */

/* 616 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 618 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 620 */	NdrFcShort( 0x2b6 ),	/* Type Offset=694 */

	/* Parameter grfMode */

/* 622 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 624 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 626 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppprstg */

/* 628 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 630 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 632 */	NdrFcShort( 0x9da ),	/* Type Offset=2522 */

	/* Return value */

/* 634 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 636 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 638 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Delete */

/* 640 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 642 */	NdrFcLong( 0x0 ),	/* 0 */
/* 646 */	NdrFcShort( 0x5 ),	/* 5 */
/* 648 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 650 */	NdrFcShort( 0x44 ),	/* 68 */
/* 652 */	NdrFcShort( 0x8 ),	/* 8 */
/* 654 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 656 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 662 */	NdrFcShort( 0x0 ),	/* 0 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter rfmtid */

/* 666 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 668 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 670 */	NdrFcShort( 0x2b6 ),	/* Type Offset=694 */

	/* Return value */

/* 672 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 674 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 676 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */


	/* Procedure Enum */

/* 678 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 680 */	NdrFcLong( 0x0 ),	/* 0 */
/* 684 */	NdrFcShort( 0x6 ),	/* 6 */
/* 686 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 692 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 694 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppenum */


	/* Parameter ppenum */

/* 704 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 706 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 708 */	NdrFcShort( 0x9f0 ),	/* Type Offset=2544 */

	/* Return value */


	/* Return value */

/* 710 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 712 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteNext */

/* 716 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 718 */	NdrFcLong( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x3 ),	/* 3 */
/* 724 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 726 */	NdrFcShort( 0x8 ),	/* 8 */
/* 728 */	NdrFcShort( 0x24 ),	/* 36 */
/* 730 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 732 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 734 */	NdrFcShort( 0x1 ),	/* 1 */
/* 736 */	NdrFcShort( 0x0 ),	/* 0 */
/* 738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 742 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 744 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 746 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 748 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 750 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 752 */	NdrFcShort( 0xa1c ),	/* Type Offset=2588 */

	/* Parameter pceltFetched */

/* 754 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 756 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 758 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 760 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 762 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Skip */


	/* Procedure Skip */

/* 766 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 768 */	NdrFcLong( 0x0 ),	/* 0 */
/* 772 */	NdrFcShort( 0x4 ),	/* 4 */
/* 774 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 776 */	NdrFcShort( 0x8 ),	/* 8 */
/* 778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 780 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 782 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 786 */	NdrFcShort( 0x0 ),	/* 0 */
/* 788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 790 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */


	/* Parameter celt */

/* 792 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 794 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 798 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 800 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 802 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */


	/* Procedure Reset */

/* 804 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 806 */	NdrFcLong( 0x0 ),	/* 0 */
/* 810 */	NdrFcShort( 0x5 ),	/* 5 */
/* 812 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 816 */	NdrFcShort( 0x8 ),	/* 8 */
/* 818 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 820 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */


	/* Return value */

/* 830 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 832 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 834 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 836 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 838 */	NdrFcLong( 0x0 ),	/* 0 */
/* 842 */	NdrFcShort( 0x6 ),	/* 6 */
/* 844 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 846 */	NdrFcShort( 0x0 ),	/* 0 */
/* 848 */	NdrFcShort( 0x8 ),	/* 8 */
/* 850 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 852 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 854 */	NdrFcShort( 0x0 ),	/* 0 */
/* 856 */	NdrFcShort( 0x0 ),	/* 0 */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppenum */

/* 862 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 864 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 866 */	NdrFcShort( 0x998 ),	/* Type Offset=2456 */

	/* Return value */

/* 868 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 870 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 872 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteNext */

/* 874 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 876 */	NdrFcLong( 0x0 ),	/* 0 */
/* 880 */	NdrFcShort( 0x3 ),	/* 3 */
/* 882 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 884 */	NdrFcShort( 0x8 ),	/* 8 */
/* 886 */	NdrFcShort( 0x24 ),	/* 36 */
/* 888 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 890 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 892 */	NdrFcShort( 0x1 ),	/* 1 */
/* 894 */	NdrFcShort( 0x0 ),	/* 0 */
/* 896 */	NdrFcShort( 0x0 ),	/* 0 */
/* 898 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 900 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 902 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 904 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 906 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 908 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 910 */	NdrFcShort( 0xa3a ),	/* Type Offset=2618 */

	/* Parameter pceltFetched */

/* 912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 914 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 920 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/*  4 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/*  6 */	NdrFcShort( 0xfff8 ),	/* -8 */
/*  8 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 10 */	NdrFcShort( 0x2 ),	/* Offset= 2 (12) */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	NdrFcShort( 0x2 ),	/* 2 */
/* 16 */	NdrFcLong( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 22 */	NdrFcLong( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x4 ),	/* Offset= 4 (30) */
/* 28 */	NdrFcShort( 0x0 ),	/* Offset= 0 (28) */
/* 30 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 32 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 34 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 36 */	NdrFcShort( 0x10 ),	/* 16 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x0 ),	/* Offset= 0 (40) */
/* 42 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 44 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 46 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (2) */
/* 48 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 50 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 56 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 58 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 60 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 64 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 66 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 68 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (34) */
/* 70 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 72 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 74 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 76 */	NdrFcShort( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 80 */	NdrFcShort( 0x2 ),	/* Offset= 2 (82) */
/* 82 */	NdrFcShort( 0x10 ),	/* 16 */
/* 84 */	NdrFcShort( 0x61 ),	/* 97 */
/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
/* 90 */	NdrFcShort( 0x0 ),	/* Offset= 0 (90) */
/* 92 */	NdrFcLong( 0x1 ),	/* 1 */
/* 96 */	NdrFcShort( 0x0 ),	/* Offset= 0 (96) */
/* 98 */	NdrFcLong( 0x10 ),	/* 16 */
/* 102 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 104 */	NdrFcLong( 0x11 ),	/* 17 */
/* 108 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 110 */	NdrFcLong( 0x2 ),	/* 2 */
/* 114 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 116 */	NdrFcLong( 0x12 ),	/* 18 */
/* 120 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 122 */	NdrFcLong( 0x3 ),	/* 3 */
/* 126 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 128 */	NdrFcLong( 0x13 ),	/* 19 */
/* 132 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 134 */	NdrFcLong( 0x16 ),	/* 22 */
/* 138 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 140 */	NdrFcLong( 0x17 ),	/* 23 */
/* 144 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 146 */	NdrFcLong( 0xe ),	/* 14 */
/* 150 */	NdrFcShort( 0x208 ),	/* Offset= 520 (670) */
/* 152 */	NdrFcLong( 0x14 ),	/* 20 */
/* 156 */	NdrFcShort( 0x202 ),	/* Offset= 514 (670) */
/* 158 */	NdrFcLong( 0x15 ),	/* 21 */
/* 162 */	NdrFcShort( 0x1fc ),	/* Offset= 508 (670) */
/* 164 */	NdrFcLong( 0x4 ),	/* 4 */
/* 168 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 170 */	NdrFcLong( 0x5 ),	/* 5 */
/* 174 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 176 */	NdrFcLong( 0xb ),	/* 11 */
/* 180 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 182 */	NdrFcLong( 0xffff ),	/* 65535 */
/* 186 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 188 */	NdrFcLong( 0xa ),	/* 10 */
/* 192 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 194 */	NdrFcLong( 0x6 ),	/* 6 */
/* 198 */	NdrFcShort( 0x1d8 ),	/* Offset= 472 (670) */
/* 200 */	NdrFcLong( 0x7 ),	/* 7 */
/* 204 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 206 */	NdrFcLong( 0x40 ),	/* 64 */
/* 210 */	NdrFcShort( 0x1d2 ),	/* Offset= 466 (676) */
/* 212 */	NdrFcLong( 0x48 ),	/* 72 */
/* 216 */	NdrFcShort( 0x1d4 ),	/* Offset= 468 (684) */
/* 218 */	NdrFcLong( 0x47 ),	/* 71 */
/* 222 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (706) */
/* 224 */	NdrFcLong( 0x8 ),	/* 8 */
/* 228 */	NdrFcShort( 0x218 ),	/* Offset= 536 (764) */
/* 230 */	NdrFcLong( 0xfff ),	/* 4095 */
/* 234 */	NdrFcShort( 0x228 ),	/* Offset= 552 (786) */
/* 236 */	NdrFcLong( 0x41 ),	/* 65 */
/* 240 */	NdrFcShort( 0x232 ),	/* Offset= 562 (802) */
/* 242 */	NdrFcLong( 0x46 ),	/* 70 */
/* 246 */	NdrFcShort( 0x22c ),	/* Offset= 556 (802) */
/* 248 */	NdrFcLong( 0x1e ),	/* 30 */
/* 252 */	NdrFcShort( 0x236 ),	/* Offset= 566 (818) */
/* 254 */	NdrFcLong( 0x1f ),	/* 31 */
/* 258 */	NdrFcShort( 0x234 ),	/* Offset= 564 (822) */
/* 260 */	NdrFcLong( 0xd ),	/* 13 */
/* 264 */	NdrFcShort( 0x232 ),	/* Offset= 562 (826) */
/* 266 */	NdrFcLong( 0x9 ),	/* 9 */
/* 270 */	NdrFcShort( 0x23e ),	/* Offset= 574 (844) */
/* 272 */	NdrFcLong( 0x42 ),	/* 66 */
/* 276 */	NdrFcShort( 0x24a ),	/* Offset= 586 (862) */
/* 278 */	NdrFcLong( 0x44 ),	/* 68 */
/* 282 */	NdrFcShort( 0x244 ),	/* Offset= 580 (862) */
/* 284 */	NdrFcLong( 0x43 ),	/* 67 */
/* 288 */	NdrFcShort( 0x250 ),	/* Offset= 592 (880) */
/* 290 */	NdrFcLong( 0x45 ),	/* 69 */
/* 294 */	NdrFcShort( 0x24a ),	/* Offset= 586 (880) */
/* 296 */	NdrFcLong( 0x49 ),	/* 73 */
/* 300 */	NdrFcShort( 0x256 ),	/* Offset= 598 (898) */
/* 302 */	NdrFcLong( 0x2010 ),	/* 8208 */
/* 306 */	NdrFcShort( 0x5b8 ),	/* Offset= 1464 (1770) */
/* 308 */	NdrFcLong( 0x2011 ),	/* 8209 */
/* 312 */	NdrFcShort( 0x5b2 ),	/* Offset= 1458 (1770) */
/* 314 */	NdrFcLong( 0x2002 ),	/* 8194 */
/* 318 */	NdrFcShort( 0x5ac ),	/* Offset= 1452 (1770) */
/* 320 */	NdrFcLong( 0x2012 ),	/* 8210 */
/* 324 */	NdrFcShort( 0x5a6 ),	/* Offset= 1446 (1770) */
/* 326 */	NdrFcLong( 0x2003 ),	/* 8195 */
/* 330 */	NdrFcShort( 0x5a0 ),	/* Offset= 1440 (1770) */
/* 332 */	NdrFcLong( 0x2013 ),	/* 8211 */
/* 336 */	NdrFcShort( 0x59a ),	/* Offset= 1434 (1770) */
/* 338 */	NdrFcLong( 0x2016 ),	/* 8214 */
/* 342 */	NdrFcShort( 0x594 ),	/* Offset= 1428 (1770) */
/* 344 */	NdrFcLong( 0x2017 ),	/* 8215 */
/* 348 */	NdrFcShort( 0x58e ),	/* Offset= 1422 (1770) */
/* 350 */	NdrFcLong( 0x2004 ),	/* 8196 */
/* 354 */	NdrFcShort( 0x588 ),	/* Offset= 1416 (1770) */
/* 356 */	NdrFcLong( 0x2005 ),	/* 8197 */
/* 360 */	NdrFcShort( 0x582 ),	/* Offset= 1410 (1770) */
/* 362 */	NdrFcLong( 0x2006 ),	/* 8198 */
/* 366 */	NdrFcShort( 0x57c ),	/* Offset= 1404 (1770) */
/* 368 */	NdrFcLong( 0x2007 ),	/* 8199 */
/* 372 */	NdrFcShort( 0x576 ),	/* Offset= 1398 (1770) */
/* 374 */	NdrFcLong( 0x2008 ),	/* 8200 */
/* 378 */	NdrFcShort( 0x570 ),	/* Offset= 1392 (1770) */
/* 380 */	NdrFcLong( 0x200b ),	/* 8203 */
/* 384 */	NdrFcShort( 0x56a ),	/* Offset= 1386 (1770) */
/* 386 */	NdrFcLong( 0x200e ),	/* 8206 */
/* 390 */	NdrFcShort( 0x564 ),	/* Offset= 1380 (1770) */
/* 392 */	NdrFcLong( 0x2009 ),	/* 8201 */
/* 396 */	NdrFcShort( 0x55e ),	/* Offset= 1374 (1770) */
/* 398 */	NdrFcLong( 0x200d ),	/* 8205 */
/* 402 */	NdrFcShort( 0x558 ),	/* Offset= 1368 (1770) */
/* 404 */	NdrFcLong( 0x200a ),	/* 8202 */
/* 408 */	NdrFcShort( 0x552 ),	/* Offset= 1362 (1770) */
/* 410 */	NdrFcLong( 0x200c ),	/* 8204 */
/* 414 */	NdrFcShort( 0x54c ),	/* Offset= 1356 (1770) */
/* 416 */	NdrFcLong( 0x1010 ),	/* 4112 */
/* 420 */	NdrFcShort( 0x55c ),	/* Offset= 1372 (1792) */
/* 422 */	NdrFcLong( 0x1011 ),	/* 4113 */
/* 426 */	NdrFcShort( 0x566 ),	/* Offset= 1382 (1808) */
/* 428 */	NdrFcLong( 0x1002 ),	/* 4098 */
/* 432 */	NdrFcShort( 0x570 ),	/* Offset= 1392 (1824) */
/* 434 */	NdrFcLong( 0x1012 ),	/* 4114 */
/* 438 */	NdrFcShort( 0x57a ),	/* Offset= 1402 (1840) */
/* 440 */	NdrFcLong( 0x1003 ),	/* 4099 */
/* 444 */	NdrFcShort( 0x584 ),	/* Offset= 1412 (1856) */
/* 446 */	NdrFcLong( 0x1013 ),	/* 4115 */
/* 450 */	NdrFcShort( 0x58e ),	/* Offset= 1422 (1872) */
/* 452 */	NdrFcLong( 0x1014 ),	/* 4116 */
/* 456 */	NdrFcShort( 0x5a8 ),	/* Offset= 1448 (1904) */
/* 458 */	NdrFcLong( 0x1015 ),	/* 4117 */
/* 462 */	NdrFcShort( 0x5b2 ),	/* Offset= 1458 (1920) */
/* 464 */	NdrFcLong( 0x1004 ),	/* 4100 */
/* 468 */	NdrFcShort( 0x5c8 ),	/* Offset= 1480 (1948) */
/* 470 */	NdrFcLong( 0x1005 ),	/* 4101 */
/* 474 */	NdrFcShort( 0x5de ),	/* Offset= 1502 (1976) */
/* 476 */	NdrFcLong( 0x100b ),	/* 4107 */
/* 480 */	NdrFcShort( 0x5e8 ),	/* Offset= 1512 (1992) */
/* 482 */	NdrFcLong( 0x100a ),	/* 4106 */
/* 486 */	NdrFcShort( 0x5f2 ),	/* Offset= 1522 (2008) */
/* 488 */	NdrFcLong( 0x1006 ),	/* 4102 */
/* 492 */	NdrFcShort( 0x5fc ),	/* Offset= 1532 (2024) */
/* 494 */	NdrFcLong( 0x1007 ),	/* 4103 */
/* 498 */	NdrFcShort( 0x606 ),	/* Offset= 1542 (2040) */
/* 500 */	NdrFcLong( 0x1040 ),	/* 4160 */
/* 504 */	NdrFcShort( 0x620 ),	/* Offset= 1568 (2072) */
/* 506 */	NdrFcLong( 0x1048 ),	/* 4168 */
/* 510 */	NdrFcShort( 0x63a ),	/* Offset= 1594 (2104) */
/* 512 */	NdrFcLong( 0x1047 ),	/* 4167 */
/* 516 */	NdrFcShort( 0x65a ),	/* Offset= 1626 (2142) */
/* 518 */	NdrFcLong( 0x1008 ),	/* 4104 */
/* 522 */	NdrFcShort( 0x67a ),	/* Offset= 1658 (2180) */
/* 524 */	NdrFcLong( 0x1fff ),	/* 8191 */
/* 528 */	NdrFcShort( 0x69a ),	/* Offset= 1690 (2218) */
/* 530 */	NdrFcLong( 0x101e ),	/* 4126 */
/* 534 */	NdrFcShort( 0x6ba ),	/* Offset= 1722 (2256) */
/* 536 */	NdrFcLong( 0x101f ),	/* 4127 */
/* 540 */	NdrFcShort( 0x6da ),	/* Offset= 1754 (2294) */
/* 542 */	NdrFcLong( 0x100c ),	/* 4108 */
/* 546 */	NdrFcShort( 0x6fa ),	/* Offset= 1786 (2332) */
/* 548 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 552 */	NdrFcShort( 0x3c4 ),	/* Offset= 964 (1516) */
/* 554 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 558 */	NdrFcShort( 0x3be ),	/* Offset= 958 (1516) */
/* 560 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 564 */	NdrFcShort( 0x376 ),	/* Offset= 886 (1450) */
/* 566 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 570 */	NdrFcShort( 0x370 ),	/* Offset= 880 (1450) */
/* 572 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 576 */	NdrFcShort( 0x36e ),	/* Offset= 878 (1454) */
/* 578 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 582 */	NdrFcShort( 0x368 ),	/* Offset= 872 (1454) */
/* 584 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 588 */	NdrFcShort( 0x362 ),	/* Offset= 866 (1454) */
/* 590 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 594 */	NdrFcShort( 0x35c ),	/* Offset= 860 (1454) */
/* 596 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 600 */	NdrFcShort( 0x35a ),	/* Offset= 858 (1458) */
/* 602 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 606 */	NdrFcShort( 0x358 ),	/* Offset= 856 (1462) */
/* 608 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 612 */	NdrFcShort( 0x346 ),	/* Offset= 838 (1450) */
/* 614 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 618 */	NdrFcShort( 0x37e ),	/* Offset= 894 (1512) */
/* 620 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 624 */	NdrFcShort( 0x33e ),	/* Offset= 830 (1454) */
/* 626 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 630 */	NdrFcShort( 0x344 ),	/* Offset= 836 (1466) */
/* 632 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 636 */	NdrFcShort( 0x33a ),	/* Offset= 826 (1462) */
/* 638 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 642 */	NdrFcShort( 0x6aa ),	/* Offset= 1706 (2348) */
/* 644 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 648 */	NdrFcShort( 0x33a ),	/* Offset= 826 (1474) */
/* 650 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 654 */	NdrFcShort( 0x338 ),	/* Offset= 824 (1478) */
/* 656 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 660 */	NdrFcShort( 0x69c ),	/* Offset= 1692 (2352) */
/* 662 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 666 */	NdrFcShort( 0x69a ),	/* Offset= 1690 (2356) */
/* 668 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (667) */
/* 670 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 672 */	NdrFcShort( 0x8 ),	/* 8 */
/* 674 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 676 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 678 */	NdrFcShort( 0x8 ),	/* 8 */
/* 680 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 682 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 684 */	
			0x13, 0x0,	/* FC_OP */
/* 686 */	NdrFcShort( 0x8 ),	/* Offset= 8 (694) */
/* 688 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 692 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 694 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 696 */	NdrFcShort( 0x10 ),	/* 16 */
/* 698 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 700 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 702 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (688) */
			0x5b,		/* FC_END */
/* 706 */	
			0x13, 0x0,	/* FC_OP */
/* 708 */	NdrFcShort( 0xe ),	/* Offset= 14 (722) */
/* 710 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 712 */	NdrFcShort( 0x1 ),	/* 1 */
/* 714 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 716 */	NdrFcShort( 0x1 ),	/* 1 */
/* 718 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 720 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 722 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 724 */	NdrFcShort( 0x10 ),	/* 16 */
/* 726 */	NdrFcShort( 0x0 ),	/* 0 */
/* 728 */	NdrFcShort( 0x6 ),	/* Offset= 6 (734) */
/* 730 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 732 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 734 */	
			0x13, 0x0,	/* FC_OP */
/* 736 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (710) */
/* 738 */	
			0x13, 0x0,	/* FC_OP */
/* 740 */	NdrFcShort( 0xe ),	/* Offset= 14 (754) */
/* 742 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 744 */	NdrFcShort( 0x2 ),	/* 2 */
/* 746 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 748 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 750 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 752 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 754 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 756 */	NdrFcShort( 0x8 ),	/* 8 */
/* 758 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (742) */
/* 760 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 762 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 764 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 768 */	NdrFcShort( 0x8 ),	/* 8 */
/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 772 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (738) */
/* 774 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 776 */	NdrFcShort( 0x1 ),	/* 1 */
/* 778 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 780 */	NdrFcShort( 0x0 ),	/* 0 */
/* 782 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 784 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 786 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 788 */	NdrFcShort( 0x10 ),	/* 16 */
/* 790 */	NdrFcShort( 0x0 ),	/* 0 */
/* 792 */	NdrFcShort( 0x6 ),	/* Offset= 6 (798) */
/* 794 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 796 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 798 */	
			0x13, 0x0,	/* FC_OP */
/* 800 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (774) */
/* 802 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 804 */	NdrFcShort( 0x10 ),	/* 16 */
/* 806 */	NdrFcShort( 0x0 ),	/* 0 */
/* 808 */	NdrFcShort( 0x6 ),	/* Offset= 6 (814) */
/* 810 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 812 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 814 */	
			0x13, 0x0,	/* FC_OP */
/* 816 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (774) */
/* 818 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 820 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 822 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 824 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 826 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 828 */	NdrFcLong( 0x0 ),	/* 0 */
/* 832 */	NdrFcShort( 0x0 ),	/* 0 */
/* 834 */	NdrFcShort( 0x0 ),	/* 0 */
/* 836 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 838 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 840 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 842 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 844 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 846 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 850 */	NdrFcShort( 0x0 ),	/* 0 */
/* 852 */	NdrFcShort( 0x0 ),	/* 0 */
/* 854 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 856 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 858 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 860 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 862 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 864 */	NdrFcLong( 0xc ),	/* 12 */
/* 868 */	NdrFcShort( 0x0 ),	/* 0 */
/* 870 */	NdrFcShort( 0x0 ),	/* 0 */
/* 872 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 874 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 876 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 878 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 880 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 882 */	NdrFcLong( 0xb ),	/* 11 */
/* 886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 890 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 892 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 894 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 896 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 898 */	
			0x13, 0x0,	/* FC_OP */
/* 900 */	NdrFcShort( 0x2 ),	/* Offset= 2 (902) */
/* 902 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 904 */	NdrFcShort( 0x18 ),	/* 24 */
/* 906 */	NdrFcShort( 0x0 ),	/* 0 */
/* 908 */	NdrFcShort( 0xc ),	/* Offset= 12 (920) */
/* 910 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 912 */	NdrFcShort( 0xffffff26 ),	/* Offset= -218 (694) */
/* 914 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 916 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (862) */
/* 918 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 920 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 922 */	NdrFcShort( 0x2 ),	/* Offset= 2 (924) */
/* 924 */	
			0x13, 0x0,	/* FC_OP */
/* 926 */	NdrFcShort( 0x33a ),	/* Offset= 826 (1752) */
/* 928 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x89,		/* 137 */
/* 930 */	NdrFcShort( 0x20 ),	/* 32 */
/* 932 */	NdrFcShort( 0xa ),	/* 10 */
/* 934 */	NdrFcLong( 0x8 ),	/* 8 */
/* 938 */	NdrFcShort( 0x50 ),	/* Offset= 80 (1018) */
/* 940 */	NdrFcLong( 0xd ),	/* 13 */
/* 944 */	NdrFcShort( 0x70 ),	/* Offset= 112 (1056) */
/* 946 */	NdrFcLong( 0x9 ),	/* 9 */
/* 950 */	NdrFcShort( 0x90 ),	/* Offset= 144 (1094) */
/* 952 */	NdrFcLong( 0xc ),	/* 12 */
/* 956 */	NdrFcShort( 0x25e ),	/* Offset= 606 (1562) */
/* 958 */	NdrFcLong( 0x24 ),	/* 36 */
/* 962 */	NdrFcShort( 0x27e ),	/* Offset= 638 (1600) */
/* 964 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 968 */	NdrFcShort( 0x288 ),	/* Offset= 648 (1616) */
/* 970 */	NdrFcLong( 0x10 ),	/* 16 */
/* 974 */	NdrFcShort( 0x296 ),	/* Offset= 662 (1636) */
/* 976 */	NdrFcLong( 0x2 ),	/* 2 */
/* 980 */	NdrFcShort( 0x2ac ),	/* Offset= 684 (1664) */
/* 982 */	NdrFcLong( 0x3 ),	/* 3 */
/* 986 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (1692) */
/* 988 */	NdrFcLong( 0x14 ),	/* 20 */
/* 992 */	NdrFcShort( 0x2d8 ),	/* Offset= 728 (1720) */
/* 994 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (993) */
/* 996 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 998 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1000 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1006 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1010 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1012 */	
			0x13, 0x0,	/* FC_OP */
/* 1014 */	NdrFcShort( 0xfffffefc ),	/* Offset= -260 (754) */
/* 1016 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1018 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1020 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1022 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1024 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1030) */
/* 1026 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1028 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1030 */	
			0x11, 0x0,	/* FC_RP */
/* 1032 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (996) */
/* 1034 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1036 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1038 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1040 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1042 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1044 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1048 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1050 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1052 */	NdrFcShort( 0xffffff1e ),	/* Offset= -226 (826) */
/* 1054 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1056 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1058 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1068) */
/* 1064 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1066 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1068 */	
			0x11, 0x0,	/* FC_RP */
/* 1070 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1034) */
/* 1072 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1074 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1076 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1078 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1080 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1082 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1086 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1088 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1090 */	NdrFcShort( 0xffffff0a ),	/* Offset= -246 (844) */
/* 1092 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1094 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1096 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1100 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1106) */
/* 1102 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1104 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1106 */	
			0x11, 0x0,	/* FC_RP */
/* 1108 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1072) */
/* 1110 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 1112 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1114 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 1116 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1118 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1120) */
/* 1120 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1122 */	NdrFcShort( 0x2b ),	/* 43 */
/* 1124 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1128 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1130 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1134 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 1136 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1140 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1142 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1146 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1148 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1152 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1154 */	NdrFcLong( 0xb ),	/* 11 */
/* 1158 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1160 */	NdrFcLong( 0xa ),	/* 10 */
/* 1164 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1166 */	NdrFcLong( 0x6 ),	/* 6 */
/* 1170 */	NdrFcShort( 0xfffffe0c ),	/* Offset= -500 (670) */
/* 1172 */	NdrFcLong( 0x7 ),	/* 7 */
/* 1176 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1178 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1182 */	NdrFcShort( 0xfffffe44 ),	/* Offset= -444 (738) */
/* 1184 */	NdrFcLong( 0xd ),	/* 13 */
/* 1188 */	NdrFcShort( 0xfffffe96 ),	/* Offset= -362 (826) */
/* 1190 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1194 */	NdrFcShort( 0xfffffea2 ),	/* Offset= -350 (844) */
/* 1196 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 1200 */	NdrFcShort( 0xb8 ),	/* Offset= 184 (1384) */
/* 1202 */	NdrFcLong( 0x24 ),	/* 36 */
/* 1206 */	NdrFcShort( 0xba ),	/* Offset= 186 (1392) */
/* 1208 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 1212 */	NdrFcShort( 0xb4 ),	/* Offset= 180 (1392) */
/* 1214 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 1218 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (1446) */
/* 1220 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 1224 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (1450) */
/* 1226 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 1230 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (1454) */
/* 1232 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 1236 */	NdrFcShort( 0xde ),	/* Offset= 222 (1458) */
/* 1238 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 1242 */	NdrFcShort( 0xdc ),	/* Offset= 220 (1462) */
/* 1244 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 1248 */	NdrFcShort( 0xca ),	/* Offset= 202 (1450) */
/* 1250 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 1254 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (1454) */
/* 1256 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 1260 */	NdrFcShort( 0xce ),	/* Offset= 206 (1466) */
/* 1262 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 1266 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (1462) */
/* 1268 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 1272 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (1470) */
/* 1274 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 1278 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (1474) */
/* 1280 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 1284 */	NdrFcShort( 0xc2 ),	/* Offset= 194 (1478) */
/* 1286 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 1290 */	NdrFcShort( 0xc0 ),	/* Offset= 192 (1482) */
/* 1292 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 1296 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (1494) */
/* 1298 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1302 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1304 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1308 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1310 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1314 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1316 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1320 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1322 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1326 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1328 */	NdrFcLong( 0xe ),	/* 14 */
/* 1332 */	NdrFcShort( 0xaa ),	/* Offset= 170 (1502) */
/* 1334 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 1338 */	NdrFcShort( 0xae ),	/* Offset= 174 (1512) */
/* 1340 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 1344 */	NdrFcShort( 0xac ),	/* Offset= 172 (1516) */
/* 1346 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 1350 */	NdrFcShort( 0x64 ),	/* Offset= 100 (1450) */
/* 1352 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 1356 */	NdrFcShort( 0x62 ),	/* Offset= 98 (1454) */
/* 1358 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 1362 */	NdrFcShort( 0x5c ),	/* Offset= 92 (1454) */
/* 1364 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 1368 */	NdrFcShort( 0x56 ),	/* Offset= 86 (1454) */
/* 1370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1374 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1374) */
/* 1376 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1380 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1380) */
/* 1382 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (1381) */
/* 1384 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1386 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1388) */
/* 1388 */	
			0x13, 0x0,	/* FC_OP */
/* 1390 */	NdrFcShort( 0x16a ),	/* Offset= 362 (1752) */
/* 1392 */	
			0x13, 0x0,	/* FC_OP */
/* 1394 */	NdrFcShort( 0x20 ),	/* Offset= 32 (1426) */
/* 1396 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1398 */	NdrFcLong( 0x2f ),	/* 47 */
/* 1402 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1406 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1408 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1410 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1412 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1414 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1416 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1418 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1420 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1422 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1424 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1426 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1428 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1430 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1432 */	NdrFcShort( 0xa ),	/* Offset= 10 (1442) */
/* 1434 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1436 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1438 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1396) */
/* 1440 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1442 */	
			0x13, 0x0,	/* FC_OP */
/* 1444 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1414) */
/* 1446 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1448 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 1450 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1452 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1454 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1456 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1458 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1460 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 1462 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1464 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 1466 */	
			0x13, 0x0,	/* FC_OP */
/* 1468 */	NdrFcShort( 0xfffffce2 ),	/* Offset= -798 (670) */
/* 1470 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1472 */	NdrFcShort( 0xfffffd22 ),	/* Offset= -734 (738) */
/* 1474 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1476 */	NdrFcShort( 0xfffffd76 ),	/* Offset= -650 (826) */
/* 1478 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1480 */	NdrFcShort( 0xfffffd84 ),	/* Offset= -636 (844) */
/* 1482 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1484 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1486) */
/* 1486 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1488 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1490) */
/* 1490 */	
			0x13, 0x0,	/* FC_OP */
/* 1492 */	NdrFcShort( 0x104 ),	/* Offset= 260 (1752) */
/* 1494 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1496 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1498) */
/* 1498 */	
			0x13, 0x0,	/* FC_OP */
/* 1500 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1520) */
/* 1502 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 1504 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1506 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 1508 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 1510 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1512 */	
			0x13, 0x0,	/* FC_OP */
/* 1514 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1502) */
/* 1516 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1518 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1520 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 1522 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1526 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1526) */
/* 1528 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1530 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1532 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1536 */	NdrFcShort( 0xfffffe56 ),	/* Offset= -426 (1110) */
/* 1538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1540 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1542 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1544 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1548 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1550 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1554 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1556 */	
			0x13, 0x0,	/* FC_OP */
/* 1558 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (1520) */
/* 1560 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1562 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1564 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1568 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1574) */
/* 1570 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1572 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1574 */	
			0x11, 0x0,	/* FC_RP */
/* 1576 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1540) */
/* 1578 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1582 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1584 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1586 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1588 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1592 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1594 */	
			0x13, 0x0,	/* FC_OP */
/* 1596 */	NdrFcShort( 0xffffff56 ),	/* Offset= -170 (1426) */
/* 1598 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1600 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1602 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1604 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1606 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1612) */
/* 1608 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1610 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1612 */	
			0x11, 0x0,	/* FC_RP */
/* 1614 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1578) */
/* 1616 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1618 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1622 */	NdrFcShort( 0xa ),	/* Offset= 10 (1632) */
/* 1624 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1626 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1628 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffc59 ),	/* Offset= -935 (694) */
			0x5b,		/* FC_END */
/* 1632 */	
			0x11, 0x0,	/* FC_RP */
/* 1634 */	NdrFcShort( 0xfffffda8 ),	/* Offset= -600 (1034) */
/* 1636 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1638 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1642 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1648) */
/* 1644 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1646 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1648 */	
			0x13, 0x0,	/* FC_OP */
/* 1650 */	NdrFcShort( 0xfffffc94 ),	/* Offset= -876 (774) */
/* 1652 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1654 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1656 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1660 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1662 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1664 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1666 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1670 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1676) */
/* 1672 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1674 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1676 */	
			0x13, 0x0,	/* FC_OP */
/* 1678 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1652) */
/* 1680 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1682 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1684 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1688 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1690 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1692 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1694 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1698 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1704) */
/* 1700 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1702 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1704 */	
			0x13, 0x0,	/* FC_OP */
/* 1706 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1680) */
/* 1708 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1710 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1712 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1716 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1718 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1720 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1722 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1724 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1726 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1732) */
/* 1728 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1730 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1732 */	
			0x13, 0x0,	/* FC_OP */
/* 1734 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1708) */
/* 1736 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1738 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1740 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1742 */	NdrFcShort( 0xffc8 ),	/* -56 */
/* 1744 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1746 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1748 */	NdrFcShort( 0xfffffbd0 ),	/* Offset= -1072 (676) */
/* 1750 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1752 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1754 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1756 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1736) */
/* 1758 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1758) */
/* 1760 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1762 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1764 */	0x40,		/* FC_STRUCTPAD4 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1766 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffcb9 ),	/* Offset= -839 (928) */
			0x5b,		/* FC_END */
/* 1770 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1772 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1774 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1776 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1778 */	NdrFcShort( 0xfffffca6 ),	/* Offset= -858 (920) */
/* 1780 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1782 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1784 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1786 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1788 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1790 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1792 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1794 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1798 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1804) */
/* 1800 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1802 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1804 */	
			0x13, 0x0,	/* FC_OP */
/* 1806 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1780) */
/* 1808 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1810 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1814 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1820) */
/* 1816 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1818 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1820 */	
			0x13, 0x0,	/* FC_OP */
/* 1822 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1780) */
/* 1824 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1826 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1830 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1836) */
/* 1832 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1834 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1836 */	
			0x13, 0x0,	/* FC_OP */
/* 1838 */	NdrFcShort( 0xffffff46 ),	/* Offset= -186 (1652) */
/* 1840 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1842 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1846 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1852) */
/* 1848 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1850 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1852 */	
			0x13, 0x0,	/* FC_OP */
/* 1854 */	NdrFcShort( 0xffffff36 ),	/* Offset= -202 (1652) */
/* 1856 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1858 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1862 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1868) */
/* 1864 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1866 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1868 */	
			0x13, 0x0,	/* FC_OP */
/* 1870 */	NdrFcShort( 0xffffff42 ),	/* Offset= -190 (1680) */
/* 1872 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1874 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1876 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1878 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1884) */
/* 1880 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1882 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1884 */	
			0x13, 0x0,	/* FC_OP */
/* 1886 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (1680) */
/* 1888 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1890 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1892 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1894 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1896 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1898 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1900 */	NdrFcShort( 0xfffffb32 ),	/* Offset= -1230 (670) */
/* 1902 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1904 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1906 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1908 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1910 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1916) */
/* 1912 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1914 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1916 */	
			0x13, 0x0,	/* FC_OP */
/* 1918 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1888) */
/* 1920 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1922 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1924 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1926 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1932) */
/* 1928 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1930 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1932 */	
			0x13, 0x0,	/* FC_OP */
/* 1934 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1888) */
/* 1936 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1938 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1940 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1942 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1944 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1946 */	0xa,		/* FC_FLOAT */
			0x5b,		/* FC_END */
/* 1948 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1950 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1954 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1960) */
/* 1956 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1958 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1960 */	
			0x13, 0x0,	/* FC_OP */
/* 1962 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1936) */
/* 1964 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1966 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1968 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1970 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1972 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1974 */	0xc,		/* FC_DOUBLE */
			0x5b,		/* FC_END */
/* 1976 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1978 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1980 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1982 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1988) */
/* 1984 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1986 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1988 */	
			0x13, 0x0,	/* FC_OP */
/* 1990 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1964) */
/* 1992 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1994 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1998 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2004) */
/* 2000 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2002 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2004 */	
			0x13, 0x0,	/* FC_OP */
/* 2006 */	NdrFcShort( 0xfffffe9e ),	/* Offset= -354 (1652) */
/* 2008 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2010 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2014 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2020) */
/* 2016 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2018 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2020 */	
			0x13, 0x0,	/* FC_OP */
/* 2022 */	NdrFcShort( 0xfffffeaa ),	/* Offset= -342 (1680) */
/* 2024 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2026 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2028 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2030 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2036) */
/* 2032 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2034 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2036 */	
			0x13, 0x0,	/* FC_OP */
/* 2038 */	NdrFcShort( 0xffffff6a ),	/* Offset= -150 (1888) */
/* 2040 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2042 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2046 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2052) */
/* 2048 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2050 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2052 */	
			0x13, 0x0,	/* FC_OP */
/* 2054 */	NdrFcShort( 0xffffffa6 ),	/* Offset= -90 (1964) */
/* 2056 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2058 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2060 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2062 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2064 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2066 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2068 */	NdrFcShort( 0xfffffa90 ),	/* Offset= -1392 (676) */
/* 2070 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2072 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2074 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2076 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2078 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2084) */
/* 2080 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2082 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2084 */	
			0x13, 0x0,	/* FC_OP */
/* 2086 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (2056) */
/* 2088 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2090 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2092 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2094 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2096 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2098 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2100 */	NdrFcShort( 0xfffffa82 ),	/* Offset= -1406 (694) */
/* 2102 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2104 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2106 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2110 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2116) */
/* 2112 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2114 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2116 */	
			0x13, 0x0,	/* FC_OP */
/* 2118 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (2088) */
/* 2120 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2124 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2128 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2130 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2134 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2136 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2138 */	NdrFcShort( 0xfffffa78 ),	/* Offset= -1416 (722) */
/* 2140 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2142 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2144 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2148 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2154) */
/* 2150 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2152 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2154 */	
			0x13, 0x0,	/* FC_OP */
/* 2156 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2120) */
/* 2158 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2162 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2166 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2168 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2172 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2174 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2176 */	NdrFcShort( 0xfffffa7c ),	/* Offset= -1412 (764) */
/* 2178 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2180 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2182 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2186 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2192) */
/* 2188 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2190 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2192 */	
			0x13, 0x0,	/* FC_OP */
/* 2194 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2158) */
/* 2196 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2200 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2204 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2206 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2210 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2212 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2214 */	NdrFcShort( 0xfffffa6c ),	/* Offset= -1428 (786) */
/* 2216 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2218 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2220 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2224 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2230) */
/* 2226 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2228 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2230 */	
			0x13, 0x0,	/* FC_OP */
/* 2232 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2196) */
/* 2234 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2238 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2242 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2244 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2248 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2250 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2252 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 2254 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2256 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2258 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2268) */
/* 2264 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2266 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2268 */	
			0x13, 0x0,	/* FC_OP */
/* 2270 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2234) */
/* 2272 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2276 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2278 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2280 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2282 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2286 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2288 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2290 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2292 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2294 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2296 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2298 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2300 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2306) */
/* 2302 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2304 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2306 */	
			0x13, 0x0,	/* FC_OP */
/* 2308 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2272) */
/* 2310 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2314 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2316 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2318 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2320 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2324 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2326 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2328 */	NdrFcShort( 0x20 ),	/* Offset= 32 (2360) */
/* 2330 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2332 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2334 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2338 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2344) */
/* 2340 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2342 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2344 */	
			0x13, 0x0,	/* FC_OP */
/* 2346 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2310) */
/* 2348 */	
			0x13, 0x0,	/* FC_OP */
/* 2350 */	NdrFcShort( 0xfffff9ce ),	/* Offset= -1586 (764) */
/* 2352 */	
			0x13, 0x0,	/* FC_OP */
/* 2354 */	NdrFcShort( 0xfffffdb8 ),	/* Offset= -584 (1770) */
/* 2356 */	
			0x13, 0x0,	/* FC_OP */
/* 2358 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2360) */
/* 2360 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2362 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2364 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2366 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2366) */
/* 2368 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 2370 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 2372 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2374 */	NdrFcShort( 0xfffff702 ),	/* Offset= -2302 (72) */
/* 2376 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2378 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2382 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2384 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2386 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2388 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2392 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2394 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2396 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2360) */
/* 2398 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2400 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2402 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2404 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2406 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2408 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2410 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2412 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2416 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2418 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2420 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2422 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2426 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2428 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2430 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2432 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2434 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2438 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2440 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2442 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2444 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2448 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2450 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2452 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2454 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2456 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2458 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2460) */
/* 2460 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2462 */	NdrFcLong( 0x139 ),	/* 313 */
/* 2466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2470 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2472 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2474 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2476 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2478 */	
			0x11, 0x0,	/* FC_RP */
/* 2480 */	NdrFcShort( 0xfffff8f4 ),	/* Offset= -1804 (676) */
/* 2482 */	
			0x11, 0x0,	/* FC_RP */
/* 2484 */	NdrFcShort( 0xfffff902 ),	/* Offset= -1790 (694) */
/* 2486 */	
			0x11, 0x0,	/* FC_RP */
/* 2488 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2490) */
/* 2490 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 2492 */	NdrFcShort( 0x40 ),	/* 64 */
/* 2494 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2496 */	NdrFcShort( 0xfffff8f6 ),	/* Offset= -1802 (694) */
/* 2498 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2500 */	NdrFcShort( 0xfffff8f2 ),	/* Offset= -1806 (694) */
/* 2502 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2504 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff8db ),	/* Offset= -1829 (676) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2508 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff8d7 ),	/* Offset= -1833 (676) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2512 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff8d3 ),	/* Offset= -1837 (676) */
			0x8,		/* FC_LONG */
/* 2516 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2518 */	
			0x12, 0x0,	/* FC_UP */
/* 2520 */	NdrFcShort( 0xfffff8de ),	/* Offset= -1826 (694) */
/* 2522 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2524 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2526) */
/* 2526 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2528 */	NdrFcLong( 0x138 ),	/* 312 */
/* 2532 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2536 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2538 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2540 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2542 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2544 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2546 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2548) */
/* 2548 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2550 */	NdrFcLong( 0x13b ),	/* 315 */
/* 2554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2556 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2558 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2560 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2562 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2564 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2566 */	
			0x11, 0x0,	/* FC_RP */
/* 2568 */	NdrFcShort( 0x14 ),	/* Offset= 20 (2588) */
/* 2570 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2572 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2576 */	NdrFcShort( 0x8 ),	/* Offset= 8 (2584) */
/* 2578 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 2580 */	0x6,		/* FC_SHORT */
			0x3e,		/* FC_STRUCTPAD2 */
/* 2582 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2584 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2586 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2588 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2592 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2594 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2596 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2598 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 2600 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2602 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2604 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2606 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2570) */
/* 2608 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2610 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2612 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2614 */	
			0x11, 0x0,	/* FC_RP */
/* 2616 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2618) */
/* 2618 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 2620 */	NdrFcShort( 0x40 ),	/* 64 */
/* 2622 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2624 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2626 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2628 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 2630 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2632 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2634 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2636 */	NdrFcShort( 0xffffff6e ),	/* Offset= -146 (2490) */
/* 2638 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            }

        };


static void __RPC_USER IPropertyStorage_PROPVARIANTExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    PROPVARIANT *pS	=	( PROPVARIANT * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( unsigned short  )pS->vt );
}

static void __RPC_USER IPropertyStorage_CLIPDATAExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    CLIPDATA *pS	=	( CLIPDATA * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->cbSize - 4 );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    IPropertyStorage_PROPVARIANTExprEval_0000
    ,IPropertyStorage_CLIPDATAExprEval_0001
    };



/* Standard interface: __MIDL_itf_propidl_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IPropertyStorage, ver. 0.0,
   GUID={0x00000138,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IPropertyStorage_FormatStringOffsetTable[] =
    {
    0,
    50,
    106,
    150,
    200,
    250,
    294,
    332,
    364,
    402,
    452,
    490
    };

static const MIDL_STUBLESS_PROXY_INFO IPropertyStorage_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IPropertyStorage_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IPropertyStorage_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IPropertyStorage_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(15) _IPropertyStorageProxyVtbl = 
{
    &IPropertyStorage_ProxyInfo,
    &IID_IPropertyStorage,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::ReadMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::WriteMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::DeleteMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::ReadPropertyNames */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::WritePropertyNames */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::DeletePropertyNames */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::Commit */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::Revert */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::Enum */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::SetTimes */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::SetClass */ ,
    (void *) (INT_PTR) -1 /* IPropertyStorage::Stat */
};

const CInterfaceStubVtbl _IPropertyStorageStubVtbl =
{
    &IID_IPropertyStorage,
    &IPropertyStorage_ServerInfo,
    15,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IPropertySetStorage, ver. 0.0,
   GUID={0x0000013A,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IPropertySetStorage_FormatStringOffsetTable[] =
    {
    528,
    590,
    640,
    678
    };

static const MIDL_STUBLESS_PROXY_INFO IPropertySetStorage_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IPropertySetStorage_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IPropertySetStorage_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IPropertySetStorage_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IPropertySetStorageProxyVtbl = 
{
    &IPropertySetStorage_ProxyInfo,
    &IID_IPropertySetStorage,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IPropertySetStorage::Create */ ,
    (void *) (INT_PTR) -1 /* IPropertySetStorage::Open */ ,
    (void *) (INT_PTR) -1 /* IPropertySetStorage::Delete */ ,
    (void *) (INT_PTR) -1 /* IPropertySetStorage::Enum */
};

const CInterfaceStubVtbl _IPropertySetStorageStubVtbl =
{
    &IID_IPropertySetStorage,
    &IPropertySetStorage_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumSTATPROPSTG, ver. 0.0,
   GUID={0x00000139,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumSTATPROPSTG_FormatStringOffsetTable[] =
    {
    716,
    766,
    804,
    836
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPSTG_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPSTG_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IEnumSTATPROPSTG_StubThunkTable[] = 
    {
    IEnumSTATPROPSTG_RemoteNext_Thunk,
    0,
    0,
    0
    };

static const MIDL_SERVER_INFO IEnumSTATPROPSTG_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPSTG_FormatStringOffsetTable[-3],
    &IEnumSTATPROPSTG_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IEnumSTATPROPSTGProxyVtbl = 
{
    &IEnumSTATPROPSTG_ProxyInfo,
    &IID_IEnumSTATPROPSTG,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IEnumSTATPROPSTG_Next_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSTG::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSTG::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSTG::Clone */
};

const CInterfaceStubVtbl _IEnumSTATPROPSTGStubVtbl =
{
    &IID_IEnumSTATPROPSTG,
    &IEnumSTATPROPSTG_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumSTATPROPSETSTG, ver. 0.0,
   GUID={0x0000013B,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumSTATPROPSETSTG_FormatStringOffsetTable[] =
    {
    874,
    766,
    804,
    678
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPSETSTG_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPSETSTG_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IEnumSTATPROPSETSTG_StubThunkTable[] = 
    {
    IEnumSTATPROPSETSTG_RemoteNext_Thunk,
    0,
    0,
    0
    };

static const MIDL_SERVER_INFO IEnumSTATPROPSETSTG_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPSETSTG_FormatStringOffsetTable[-3],
    &IEnumSTATPROPSETSTG_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IEnumSTATPROPSETSTGProxyVtbl = 
{
    &IEnumSTATPROPSETSTG_ProxyInfo,
    &IID_IEnumSTATPROPSETSTG,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IEnumSTATPROPSETSTG_Next_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSETSTG::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSETSTG::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPSETSTG::Clone */
};

const CInterfaceStubVtbl _IEnumSTATPROPSETSTGStubVtbl =
{
    &IID_IEnumSTATPROPSETSTG,
    &IEnumSTATPROPSETSTG_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_propidl_0109, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _propidl_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IPropertyStorageProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumSTATPROPSTGProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IPropertySetStorageProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumSTATPROPSETSTGProxyVtbl,
    0
};

const CInterfaceStubVtbl * _propidl_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IPropertyStorageStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumSTATPROPSTGStubVtbl,
    ( CInterfaceStubVtbl *) &_IPropertySetStorageStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumSTATPROPSETSTGStubVtbl,
    0
};

PCInterfaceName const _propidl_InterfaceNamesList[] = 
{
    "IPropertyStorage",
    "IEnumSTATPROPSTG",
    "IPropertySetStorage",
    "IEnumSTATPROPSETSTG",
    0
};


#define _propidl_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _propidl, pIID, n)

int __stdcall _propidl_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _propidl, 4, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _propidl, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _propidl, 4, *pIndex )
    
}

const ExtendedProxyFileInfo propidl_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _propidl_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _propidl_StubVtblList,
    (const PCInterfaceName * ) & _propidl_InterfaceNamesList,
    0, // no delegation
    & _propidl_IID_Lookup, 
    4,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\idl\obj\pbagex_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:31 2002
 */
/* Compiler settings for pbagex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "pbagex.h"

#define TYPE_FORMAT_STRING_SIZE   2449                              
#define PROC_FORMAT_STRING_SIZE   415                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IPropertyBagEx_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IPropertyBagEx_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumSTATPROPBAG_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPBAG_ProxyInfo;


extern const EXPR_EVAL ExprEvalRoutines[];
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure ReadMultiple */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 16 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x44 ),	/* 68 */
/* 20 */	NdrFcShort( 0x45 ),	/* 69 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cprops */

/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgwszPropNames */

/* 30 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter rgvar */

/* 36 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 40 */	NdrFcShort( 0x8f4 ),	/* Type Offset=2292 */

	/* Parameter pErrorLog */

/* 42 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 46 */	NdrFcShort( 0x90a ),	/* Type Offset=2314 */

	/* Return value */

/* 48 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 50 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 52 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteMultiple */

/* 54 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 56 */	NdrFcLong( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x4 ),	/* 4 */
/* 62 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 64 */	NdrFcShort( 0x8 ),	/* 8 */
/* 66 */	NdrFcShort( 0x8 ),	/* 8 */
/* 68 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 70 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x45 ),	/* 69 */
/* 76 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cprops */

/* 78 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 80 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgwszPropNames */

/* 84 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 86 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 88 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter rgvar */

/* 90 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 92 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 94 */	NdrFcShort( 0x8f4 ),	/* Type Offset=2292 */

	/* Return value */

/* 96 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 98 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DeleteMultiple */

/* 102 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 108 */	NdrFcShort( 0x5 ),	/* 5 */
/* 110 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 112 */	NdrFcShort( 0x10 ),	/* 16 */
/* 114 */	NdrFcShort( 0x8 ),	/* 8 */
/* 116 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 118 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x1 ),	/* 1 */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cprops */

/* 126 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 128 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgwszPropNames */

/* 132 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 134 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 136 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwReserved */

/* 138 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 140 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 146 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Open */

/* 150 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0x6 ),	/* 6 */
/* 158 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 160 */	NdrFcShort( 0x7c ),	/* 124 */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 166 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 168 */	NdrFcShort( 0x1 ),	/* 1 */
/* 170 */	NdrFcShort( 0x0 ),	/* 0 */
/* 172 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 174 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 176 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 178 */	NdrFcShort( 0x30e ),	/* Type Offset=782 */

	/* Parameter wszPropName */

/* 180 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 182 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 184 */	NdrFcShort( 0x91e ),	/* Type Offset=2334 */

	/* Parameter guidPropertyType */

/* 186 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 188 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 190 */	NdrFcShort( 0x290 ),	/* Type Offset=656 */

	/* Parameter dwFlags */

/* 192 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 194 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter riid */

/* 198 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 200 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 202 */	NdrFcShort( 0x290 ),	/* Type Offset=656 */

	/* Parameter ppUnk */

/* 204 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 206 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 208 */	NdrFcShort( 0x924 ),	/* Type Offset=2340 */

	/* Return value */

/* 210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 212 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Enum */

/* 216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 222 */	NdrFcShort( 0x7 ),	/* 7 */
/* 224 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 226 */	NdrFcShort( 0x8 ),	/* 8 */
/* 228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 230 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 232 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszPropNameMask */

/* 240 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 242 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 244 */	NdrFcShort( 0x91e ),	/* Type Offset=2334 */

	/* Parameter dwFlags */

/* 246 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 248 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppenum */

/* 252 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 254 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 256 */	NdrFcShort( 0x930 ),	/* Type Offset=2352 */

	/* Return value */

/* 258 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 260 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 262 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 264 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 266 */	NdrFcLong( 0x0 ),	/* 0 */
/* 270 */	NdrFcShort( 0x3 ),	/* 3 */
/* 272 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 276 */	NdrFcShort( 0x24 ),	/* 36 */
/* 278 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 280 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 282 */	NdrFcShort( 0x1 ),	/* 1 */
/* 284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 288 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 290 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 292 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 294 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 296 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 298 */	NdrFcShort( 0x964 ),	/* Type Offset=2404 */

	/* Parameter pceltFetched */

/* 300 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Skip */

/* 312 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x4 ),	/* 4 */
/* 320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 328 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 336 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 338 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 342 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 344 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 346 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */

/* 348 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 350 */	NdrFcLong( 0x0 ),	/* 0 */
/* 354 */	NdrFcShort( 0x5 ),	/* 5 */
/* 356 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x8 ),	/* 8 */
/* 362 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 364 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 366 */	NdrFcShort( 0x0 ),	/* 0 */
/* 368 */	NdrFcShort( 0x0 ),	/* 0 */
/* 370 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 374 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 378 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 380 */	NdrFcLong( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0x6 ),	/* 6 */
/* 386 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 392 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 394 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 396 */	NdrFcShort( 0x0 ),	/* 0 */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppenum */

/* 402 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 406 */	NdrFcShort( 0x930 ),	/* Type Offset=2352 */

	/* Return value */

/* 408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x4 ),	/* 4 */
/*  6 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/*  8 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 10 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 12 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 14 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 16 */	NdrFcShort( 0x4 ),	/* 4 */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x1 ),	/* 1 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 28 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 30 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 32 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 34 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 36 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 42 */	NdrFcShort( 0x2 ),	/* Offset= 2 (44) */
/* 44 */	NdrFcShort( 0x8 ),	/* 8 */
/* 46 */	NdrFcShort( 0x61 ),	/* 97 */
/* 48 */	NdrFcLong( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x0 ),	/* Offset= 0 (52) */
/* 54 */	NdrFcLong( 0x1 ),	/* 1 */
/* 58 */	NdrFcShort( 0x0 ),	/* Offset= 0 (58) */
/* 60 */	NdrFcLong( 0x10 ),	/* 16 */
/* 64 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 66 */	NdrFcLong( 0x11 ),	/* 17 */
/* 70 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 72 */	NdrFcLong( 0x2 ),	/* 2 */
/* 76 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 78 */	NdrFcLong( 0x12 ),	/* 18 */
/* 82 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 84 */	NdrFcLong( 0x3 ),	/* 3 */
/* 88 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 90 */	NdrFcLong( 0x13 ),	/* 19 */
/* 94 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 96 */	NdrFcLong( 0x16 ),	/* 22 */
/* 100 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 102 */	NdrFcLong( 0x17 ),	/* 23 */
/* 106 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 108 */	NdrFcLong( 0xe ),	/* 14 */
/* 112 */	NdrFcShort( 0x208 ),	/* Offset= 520 (632) */
/* 114 */	NdrFcLong( 0x14 ),	/* 20 */
/* 118 */	NdrFcShort( 0x202 ),	/* Offset= 514 (632) */
/* 120 */	NdrFcLong( 0x15 ),	/* 21 */
/* 124 */	NdrFcShort( 0x1fc ),	/* Offset= 508 (632) */
/* 126 */	NdrFcLong( 0x4 ),	/* 4 */
/* 130 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 132 */	NdrFcLong( 0x5 ),	/* 5 */
/* 136 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 138 */	NdrFcLong( 0xb ),	/* 11 */
/* 142 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 144 */	NdrFcLong( 0xffff ),	/* 65535 */
/* 148 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 150 */	NdrFcLong( 0xa ),	/* 10 */
/* 154 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 156 */	NdrFcLong( 0x6 ),	/* 6 */
/* 160 */	NdrFcShort( 0x1d8 ),	/* Offset= 472 (632) */
/* 162 */	NdrFcLong( 0x7 ),	/* 7 */
/* 166 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 168 */	NdrFcLong( 0x40 ),	/* 64 */
/* 172 */	NdrFcShort( 0x1d2 ),	/* Offset= 466 (638) */
/* 174 */	NdrFcLong( 0x48 ),	/* 72 */
/* 178 */	NdrFcShort( 0x1d4 ),	/* Offset= 468 (646) */
/* 180 */	NdrFcLong( 0x47 ),	/* 71 */
/* 184 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (668) */
/* 186 */	NdrFcLong( 0x8 ),	/* 8 */
/* 190 */	NdrFcShort( 0x21e ),	/* Offset= 542 (732) */
/* 192 */	NdrFcLong( 0xfff ),	/* 4095 */
/* 196 */	NdrFcShort( 0x22e ),	/* Offset= 558 (754) */
/* 198 */	NdrFcLong( 0x41 ),	/* 65 */
/* 202 */	NdrFcShort( 0x228 ),	/* Offset= 552 (754) */
/* 204 */	NdrFcLong( 0x46 ),	/* 70 */
/* 208 */	NdrFcShort( 0x222 ),	/* Offset= 546 (754) */
/* 210 */	NdrFcLong( 0x1e ),	/* 30 */
/* 214 */	NdrFcShort( 0x230 ),	/* Offset= 560 (774) */
/* 216 */	NdrFcLong( 0x1f ),	/* 31 */
/* 220 */	NdrFcShort( 0x22e ),	/* Offset= 558 (778) */
/* 222 */	NdrFcLong( 0xd ),	/* 13 */
/* 226 */	NdrFcShort( 0x22c ),	/* Offset= 556 (782) */
/* 228 */	NdrFcLong( 0x9 ),	/* 9 */
/* 232 */	NdrFcShort( 0x238 ),	/* Offset= 568 (800) */
/* 234 */	NdrFcLong( 0x42 ),	/* 66 */
/* 238 */	NdrFcShort( 0x244 ),	/* Offset= 580 (818) */
/* 240 */	NdrFcLong( 0x44 ),	/* 68 */
/* 244 */	NdrFcShort( 0x23e ),	/* Offset= 574 (818) */
/* 246 */	NdrFcLong( 0x43 ),	/* 67 */
/* 250 */	NdrFcShort( 0x24a ),	/* Offset= 586 (836) */
/* 252 */	NdrFcLong( 0x45 ),	/* 69 */
/* 256 */	NdrFcShort( 0x244 ),	/* Offset= 580 (836) */
/* 258 */	NdrFcLong( 0x49 ),	/* 73 */
/* 262 */	NdrFcShort( 0x250 ),	/* Offset= 592 (854) */
/* 264 */	NdrFcLong( 0x2010 ),	/* 8208 */
/* 268 */	NdrFcShort( 0x5d0 ),	/* Offset= 1488 (1756) */
/* 270 */	NdrFcLong( 0x2011 ),	/* 8209 */
/* 274 */	NdrFcShort( 0x5ca ),	/* Offset= 1482 (1756) */
/* 276 */	NdrFcLong( 0x2002 ),	/* 8194 */
/* 280 */	NdrFcShort( 0x5c4 ),	/* Offset= 1476 (1756) */
/* 282 */	NdrFcLong( 0x2012 ),	/* 8210 */
/* 286 */	NdrFcShort( 0x5be ),	/* Offset= 1470 (1756) */
/* 288 */	NdrFcLong( 0x2003 ),	/* 8195 */
/* 292 */	NdrFcShort( 0x5b8 ),	/* Offset= 1464 (1756) */
/* 294 */	NdrFcLong( 0x2013 ),	/* 8211 */
/* 298 */	NdrFcShort( 0x5b2 ),	/* Offset= 1458 (1756) */
/* 300 */	NdrFcLong( 0x2016 ),	/* 8214 */
/* 304 */	NdrFcShort( 0x5ac ),	/* Offset= 1452 (1756) */
/* 306 */	NdrFcLong( 0x2017 ),	/* 8215 */
/* 310 */	NdrFcShort( 0x5a6 ),	/* Offset= 1446 (1756) */
/* 312 */	NdrFcLong( 0x2004 ),	/* 8196 */
/* 316 */	NdrFcShort( 0x5a0 ),	/* Offset= 1440 (1756) */
/* 318 */	NdrFcLong( 0x2005 ),	/* 8197 */
/* 322 */	NdrFcShort( 0x59a ),	/* Offset= 1434 (1756) */
/* 324 */	NdrFcLong( 0x2006 ),	/* 8198 */
/* 328 */	NdrFcShort( 0x594 ),	/* Offset= 1428 (1756) */
/* 330 */	NdrFcLong( 0x2007 ),	/* 8199 */
/* 334 */	NdrFcShort( 0x58e ),	/* Offset= 1422 (1756) */
/* 336 */	NdrFcLong( 0x2008 ),	/* 8200 */
/* 340 */	NdrFcShort( 0x588 ),	/* Offset= 1416 (1756) */
/* 342 */	NdrFcLong( 0x200b ),	/* 8203 */
/* 346 */	NdrFcShort( 0x582 ),	/* Offset= 1410 (1756) */
/* 348 */	NdrFcLong( 0x200e ),	/* 8206 */
/* 352 */	NdrFcShort( 0x57c ),	/* Offset= 1404 (1756) */
/* 354 */	NdrFcLong( 0x2009 ),	/* 8201 */
/* 358 */	NdrFcShort( 0x576 ),	/* Offset= 1398 (1756) */
/* 360 */	NdrFcLong( 0x200d ),	/* 8205 */
/* 364 */	NdrFcShort( 0x570 ),	/* Offset= 1392 (1756) */
/* 366 */	NdrFcLong( 0x200a ),	/* 8202 */
/* 370 */	NdrFcShort( 0x56a ),	/* Offset= 1386 (1756) */
/* 372 */	NdrFcLong( 0x200c ),	/* 8204 */
/* 376 */	NdrFcShort( 0x564 ),	/* Offset= 1380 (1756) */
/* 378 */	NdrFcLong( 0x1010 ),	/* 4112 */
/* 382 */	NdrFcShort( 0x574 ),	/* Offset= 1396 (1778) */
/* 384 */	NdrFcLong( 0x1011 ),	/* 4113 */
/* 388 */	NdrFcShort( 0x56e ),	/* Offset= 1390 (1778) */
/* 390 */	NdrFcLong( 0x1002 ),	/* 4098 */
/* 394 */	NdrFcShort( 0x4dc ),	/* Offset= 1244 (1638) */
/* 396 */	NdrFcLong( 0x1012 ),	/* 4114 */
/* 400 */	NdrFcShort( 0x4d6 ),	/* Offset= 1238 (1638) */
/* 402 */	NdrFcLong( 0x1003 ),	/* 4099 */
/* 406 */	NdrFcShort( 0x4f0 ),	/* Offset= 1264 (1670) */
/* 408 */	NdrFcLong( 0x1013 ),	/* 4115 */
/* 412 */	NdrFcShort( 0x4ea ),	/* Offset= 1258 (1670) */
/* 414 */	NdrFcLong( 0x1014 ),	/* 4116 */
/* 418 */	NdrFcShort( 0x574 ),	/* Offset= 1396 (1814) */
/* 420 */	NdrFcLong( 0x1015 ),	/* 4117 */
/* 424 */	NdrFcShort( 0x56e ),	/* Offset= 1390 (1814) */
/* 426 */	NdrFcLong( 0x1004 ),	/* 4100 */
/* 430 */	NdrFcShort( 0x588 ),	/* Offset= 1416 (1846) */
/* 432 */	NdrFcLong( 0x1005 ),	/* 4101 */
/* 436 */	NdrFcShort( 0x5a2 ),	/* Offset= 1442 (1878) */
/* 438 */	NdrFcLong( 0x100b ),	/* 4107 */
/* 442 */	NdrFcShort( 0x4ac ),	/* Offset= 1196 (1638) */
/* 444 */	NdrFcLong( 0x100a ),	/* 4106 */
/* 448 */	NdrFcShort( 0x4c6 ),	/* Offset= 1222 (1670) */
/* 450 */	NdrFcLong( 0x1006 ),	/* 4102 */
/* 454 */	NdrFcShort( 0x550 ),	/* Offset= 1360 (1814) */
/* 456 */	NdrFcLong( 0x1007 ),	/* 4103 */
/* 460 */	NdrFcShort( 0x58a ),	/* Offset= 1418 (1878) */
/* 462 */	NdrFcLong( 0x1040 ),	/* 4160 */
/* 466 */	NdrFcShort( 0x5a8 ),	/* Offset= 1448 (1914) */
/* 468 */	NdrFcLong( 0x1048 ),	/* 4168 */
/* 472 */	NdrFcShort( 0x5c6 ),	/* Offset= 1478 (1950) */
/* 474 */	NdrFcLong( 0x1047 ),	/* 4167 */
/* 478 */	NdrFcShort( 0x5f6 ),	/* Offset= 1526 (2004) */
/* 480 */	NdrFcLong( 0x1008 ),	/* 4104 */
/* 484 */	NdrFcShort( 0x61a ),	/* Offset= 1562 (2046) */
/* 486 */	NdrFcLong( 0x1fff ),	/* 8191 */
/* 490 */	NdrFcShort( 0x64a ),	/* Offset= 1610 (2100) */
/* 492 */	NdrFcLong( 0x101e ),	/* 4126 */
/* 496 */	NdrFcShort( 0x678 ),	/* Offset= 1656 (2152) */
/* 498 */	NdrFcLong( 0x101f ),	/* 4127 */
/* 502 */	NdrFcShort( 0x6a6 ),	/* Offset= 1702 (2204) */
/* 504 */	NdrFcLong( 0x100c ),	/* 4108 */
/* 508 */	NdrFcShort( 0x6ca ),	/* Offset= 1738 (2246) */
/* 510 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 514 */	NdrFcShort( 0x3cc ),	/* Offset= 972 (1486) */
/* 516 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 520 */	NdrFcShort( 0x3c6 ),	/* Offset= 966 (1486) */
/* 522 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 526 */	NdrFcShort( 0x37e ),	/* Offset= 894 (1420) */
/* 528 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 532 */	NdrFcShort( 0x378 ),	/* Offset= 888 (1420) */
/* 534 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 538 */	NdrFcShort( 0x376 ),	/* Offset= 886 (1424) */
/* 540 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 544 */	NdrFcShort( 0x370 ),	/* Offset= 880 (1424) */
/* 546 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 550 */	NdrFcShort( 0x36a ),	/* Offset= 874 (1424) */
/* 552 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 556 */	NdrFcShort( 0x364 ),	/* Offset= 868 (1424) */
/* 558 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 562 */	NdrFcShort( 0x362 ),	/* Offset= 866 (1428) */
/* 564 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 568 */	NdrFcShort( 0x360 ),	/* Offset= 864 (1432) */
/* 570 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 574 */	NdrFcShort( 0x34e ),	/* Offset= 846 (1420) */
/* 576 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 580 */	NdrFcShort( 0x386 ),	/* Offset= 902 (1482) */
/* 582 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 586 */	NdrFcShort( 0x346 ),	/* Offset= 838 (1424) */
/* 588 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 592 */	NdrFcShort( 0x34c ),	/* Offset= 844 (1436) */
/* 594 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 598 */	NdrFcShort( 0x342 ),	/* Offset= 834 (1432) */
/* 600 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 604 */	NdrFcShort( 0x67a ),	/* Offset= 1658 (2262) */
/* 606 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 610 */	NdrFcShort( 0x342 ),	/* Offset= 834 (1444) */
/* 612 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 616 */	NdrFcShort( 0x340 ),	/* Offset= 832 (1448) */
/* 618 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 622 */	NdrFcShort( 0x66c ),	/* Offset= 1644 (2266) */
/* 624 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 628 */	NdrFcShort( 0x66a ),	/* Offset= 1642 (2270) */
/* 630 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (629) */
/* 632 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 634 */	NdrFcShort( 0x8 ),	/* 8 */
/* 636 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 638 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 640 */	NdrFcShort( 0x8 ),	/* 8 */
/* 642 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 644 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 646 */	
			0x13, 0x0,	/* FC_OP */
/* 648 */	NdrFcShort( 0x8 ),	/* Offset= 8 (656) */
/* 650 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 652 */	NdrFcShort( 0x8 ),	/* 8 */
/* 654 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 656 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 658 */	NdrFcShort( 0x10 ),	/* 16 */
/* 660 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 662 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 664 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (650) */
			0x5b,		/* FC_END */
/* 668 */	
			0x13, 0x0,	/* FC_OP */
/* 670 */	NdrFcShort( 0xe ),	/* Offset= 14 (684) */
/* 672 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 674 */	NdrFcShort( 0x1 ),	/* 1 */
/* 676 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 678 */	NdrFcShort( 0x1 ),	/* 1 */
/* 680 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 682 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 684 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 686 */	NdrFcShort( 0xc ),	/* 12 */
/* 688 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 690 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 692 */	NdrFcShort( 0x8 ),	/* 8 */
/* 694 */	NdrFcShort( 0x8 ),	/* 8 */
/* 696 */	0x13, 0x0,	/* FC_OP */
/* 698 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (672) */
/* 700 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 702 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 704 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 706 */	
			0x13, 0x0,	/* FC_OP */
/* 708 */	NdrFcShort( 0xe ),	/* Offset= 14 (722) */
/* 710 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 712 */	NdrFcShort( 0x2 ),	/* 2 */
/* 714 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 716 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 718 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 720 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 722 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 724 */	NdrFcShort( 0x8 ),	/* 8 */
/* 726 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (710) */
/* 728 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 730 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 732 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 734 */	NdrFcShort( 0x0 ),	/* 0 */
/* 736 */	NdrFcShort( 0x4 ),	/* 4 */
/* 738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 740 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (706) */
/* 742 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 744 */	NdrFcShort( 0x1 ),	/* 1 */
/* 746 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 752 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 754 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 756 */	NdrFcShort( 0x8 ),	/* 8 */
/* 758 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 760 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 762 */	NdrFcShort( 0x4 ),	/* 4 */
/* 764 */	NdrFcShort( 0x4 ),	/* 4 */
/* 766 */	0x13, 0x0,	/* FC_OP */
/* 768 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (742) */
/* 770 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 772 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 774 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 776 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 778 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 780 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 782 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 784 */	NdrFcLong( 0x0 ),	/* 0 */
/* 788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 790 */	NdrFcShort( 0x0 ),	/* 0 */
/* 792 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 794 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 796 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 798 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 800 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 802 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 806 */	NdrFcShort( 0x0 ),	/* 0 */
/* 808 */	NdrFcShort( 0x0 ),	/* 0 */
/* 810 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 812 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 814 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 816 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 818 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 820 */	NdrFcLong( 0xc ),	/* 12 */
/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 830 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 832 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 834 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 836 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 838 */	NdrFcLong( 0xb ),	/* 11 */
/* 842 */	NdrFcShort( 0x0 ),	/* 0 */
/* 844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 846 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 848 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 850 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 852 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 854 */	
			0x13, 0x0,	/* FC_OP */
/* 856 */	NdrFcShort( 0x2 ),	/* Offset= 2 (858) */
/* 858 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 860 */	NdrFcShort( 0x14 ),	/* 20 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */
/* 864 */	NdrFcShort( 0xc ),	/* Offset= 12 (876) */
/* 866 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 868 */	NdrFcShort( 0xffffff2c ),	/* Offset= -212 (656) */
/* 870 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 872 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (818) */
/* 874 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 876 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 878 */	NdrFcShort( 0x2 ),	/* Offset= 2 (880) */
/* 880 */	
			0x13, 0x0,	/* FC_OP */
/* 882 */	NdrFcShort( 0x358 ),	/* Offset= 856 (1738) */
/* 884 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 886 */	NdrFcShort( 0x18 ),	/* 24 */
/* 888 */	NdrFcShort( 0xa ),	/* 10 */
/* 890 */	NdrFcLong( 0x8 ),	/* 8 */
/* 894 */	NdrFcShort( 0x5a ),	/* Offset= 90 (984) */
/* 896 */	NdrFcLong( 0xd ),	/* 13 */
/* 900 */	NdrFcShort( 0x7e ),	/* Offset= 126 (1026) */
/* 902 */	NdrFcLong( 0x9 ),	/* 9 */
/* 906 */	NdrFcShort( 0x9e ),	/* Offset= 158 (1064) */
/* 908 */	NdrFcLong( 0xc ),	/* 12 */
/* 912 */	NdrFcShort( 0x276 ),	/* Offset= 630 (1542) */
/* 914 */	NdrFcLong( 0x24 ),	/* 36 */
/* 918 */	NdrFcShort( 0x2a0 ),	/* Offset= 672 (1590) */
/* 920 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 924 */	NdrFcShort( 0x2aa ),	/* Offset= 682 (1606) */
/* 926 */	NdrFcLong( 0x10 ),	/* 16 */
/* 930 */	NdrFcShort( 0xffffff50 ),	/* Offset= -176 (754) */
/* 932 */	NdrFcLong( 0x2 ),	/* 2 */
/* 936 */	NdrFcShort( 0x2be ),	/* Offset= 702 (1638) */
/* 938 */	NdrFcLong( 0x3 ),	/* 3 */
/* 942 */	NdrFcShort( 0x2d8 ),	/* Offset= 728 (1670) */
/* 944 */	NdrFcLong( 0x14 ),	/* 20 */
/* 948 */	NdrFcShort( 0x2f2 ),	/* Offset= 754 (1702) */
/* 950 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (949) */
/* 952 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 954 */	NdrFcShort( 0x4 ),	/* 4 */
/* 956 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 958 */	NdrFcShort( 0x0 ),	/* 0 */
/* 960 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 962 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 964 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 966 */	NdrFcShort( 0x4 ),	/* 4 */
/* 968 */	NdrFcShort( 0x0 ),	/* 0 */
/* 970 */	NdrFcShort( 0x1 ),	/* 1 */
/* 972 */	NdrFcShort( 0x0 ),	/* 0 */
/* 974 */	NdrFcShort( 0x0 ),	/* 0 */
/* 976 */	0x13, 0x0,	/* FC_OP */
/* 978 */	NdrFcShort( 0xffffff00 ),	/* Offset= -256 (722) */
/* 980 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 982 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 984 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 986 */	NdrFcShort( 0x8 ),	/* 8 */
/* 988 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 990 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 992 */	NdrFcShort( 0x4 ),	/* 4 */
/* 994 */	NdrFcShort( 0x4 ),	/* 4 */
/* 996 */	0x11, 0x0,	/* FC_RP */
/* 998 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (952) */
/* 1000 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1002 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1004 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1006 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1008 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1012 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1014 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1018 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1020 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1022 */	NdrFcShort( 0xffffff10 ),	/* Offset= -240 (782) */
/* 1024 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1026 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1028 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1030 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1032 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1038) */
/* 1034 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1036 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1038 */	
			0x11, 0x0,	/* FC_RP */
/* 1040 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1004) */
/* 1042 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1046 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1048 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1050 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1052 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1056 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1058 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1060 */	NdrFcShort( 0xfffffefc ),	/* Offset= -260 (800) */
/* 1062 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1064 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1066 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1068 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1070 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1076) */
/* 1072 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1074 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1076 */	
			0x11, 0x0,	/* FC_RP */
/* 1078 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1042) */
/* 1080 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 1082 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1084 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 1086 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1088 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1090) */
/* 1090 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1092 */	NdrFcShort( 0x2b ),	/* 43 */
/* 1094 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1098 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1100 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1104 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 1106 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1110 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1112 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1116 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1118 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1122 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1124 */	NdrFcLong( 0xb ),	/* 11 */
/* 1128 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1130 */	NdrFcLong( 0xa ),	/* 10 */
/* 1134 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1136 */	NdrFcLong( 0x6 ),	/* 6 */
/* 1140 */	NdrFcShort( 0xfffffe04 ),	/* Offset= -508 (632) */
/* 1142 */	NdrFcLong( 0x7 ),	/* 7 */
/* 1146 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1148 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1152 */	NdrFcShort( 0xfffffe42 ),	/* Offset= -446 (706) */
/* 1154 */	NdrFcLong( 0xd ),	/* 13 */
/* 1158 */	NdrFcShort( 0xfffffe88 ),	/* Offset= -376 (782) */
/* 1160 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1164 */	NdrFcShort( 0xfffffe94 ),	/* Offset= -364 (800) */
/* 1166 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 1170 */	NdrFcShort( 0xb8 ),	/* Offset= 184 (1354) */
/* 1172 */	NdrFcLong( 0x24 ),	/* 36 */
/* 1176 */	NdrFcShort( 0xba ),	/* Offset= 186 (1362) */
/* 1178 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 1182 */	NdrFcShort( 0xb4 ),	/* Offset= 180 (1362) */
/* 1184 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 1188 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (1416) */
/* 1190 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 1194 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (1420) */
/* 1196 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 1200 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (1424) */
/* 1202 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 1206 */	NdrFcShort( 0xde ),	/* Offset= 222 (1428) */
/* 1208 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 1212 */	NdrFcShort( 0xdc ),	/* Offset= 220 (1432) */
/* 1214 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 1218 */	NdrFcShort( 0xca ),	/* Offset= 202 (1420) */
/* 1220 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 1224 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (1424) */
/* 1226 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 1230 */	NdrFcShort( 0xce ),	/* Offset= 206 (1436) */
/* 1232 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 1236 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (1432) */
/* 1238 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 1242 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (1440) */
/* 1244 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 1248 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (1444) */
/* 1250 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 1254 */	NdrFcShort( 0xc2 ),	/* Offset= 194 (1448) */
/* 1256 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 1260 */	NdrFcShort( 0xc0 ),	/* Offset= 192 (1452) */
/* 1262 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 1266 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (1464) */
/* 1268 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1272 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1274 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1278 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1280 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1284 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1286 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1290 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1292 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1296 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1298 */	NdrFcLong( 0xe ),	/* 14 */
/* 1302 */	NdrFcShort( 0xaa ),	/* Offset= 170 (1472) */
/* 1304 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 1308 */	NdrFcShort( 0xae ),	/* Offset= 174 (1482) */
/* 1310 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 1314 */	NdrFcShort( 0xac ),	/* Offset= 172 (1486) */
/* 1316 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 1320 */	NdrFcShort( 0x64 ),	/* Offset= 100 (1420) */
/* 1322 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 1326 */	NdrFcShort( 0x62 ),	/* Offset= 98 (1424) */
/* 1328 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 1332 */	NdrFcShort( 0x5c ),	/* Offset= 92 (1424) */
/* 1334 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 1338 */	NdrFcShort( 0x56 ),	/* Offset= 86 (1424) */
/* 1340 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1344 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1344) */
/* 1346 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1350 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1350) */
/* 1352 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (1351) */
/* 1354 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1356 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1358) */
/* 1358 */	
			0x13, 0x0,	/* FC_OP */
/* 1360 */	NdrFcShort( 0x17a ),	/* Offset= 378 (1738) */
/* 1362 */	
			0x13, 0x0,	/* FC_OP */
/* 1364 */	NdrFcShort( 0x20 ),	/* Offset= 32 (1396) */
/* 1366 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1368 */	NdrFcLong( 0x2f ),	/* 47 */
/* 1372 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1376 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1378 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1380 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1382 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1384 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1386 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1388 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1390 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1392 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1394 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1396 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1398 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1400 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1402 */	NdrFcShort( 0xa ),	/* Offset= 10 (1412) */
/* 1404 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1406 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1408 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1366) */
/* 1410 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1412 */	
			0x13, 0x0,	/* FC_OP */
/* 1414 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1384) */
/* 1416 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1418 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 1420 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1422 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1424 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1426 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1428 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1430 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 1432 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1434 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 1436 */	
			0x13, 0x0,	/* FC_OP */
/* 1438 */	NdrFcShort( 0xfffffcda ),	/* Offset= -806 (632) */
/* 1440 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1442 */	NdrFcShort( 0xfffffd20 ),	/* Offset= -736 (706) */
/* 1444 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1446 */	NdrFcShort( 0xfffffd68 ),	/* Offset= -664 (782) */
/* 1448 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1450 */	NdrFcShort( 0xfffffd76 ),	/* Offset= -650 (800) */
/* 1452 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1454 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1456) */
/* 1456 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1458 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1460) */
/* 1460 */	
			0x13, 0x0,	/* FC_OP */
/* 1462 */	NdrFcShort( 0x114 ),	/* Offset= 276 (1738) */
/* 1464 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1466 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1468) */
/* 1468 */	
			0x13, 0x0,	/* FC_OP */
/* 1470 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1490) */
/* 1472 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 1474 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1476 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 1478 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 1480 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1482 */	
			0x13, 0x0,	/* FC_OP */
/* 1484 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1472) */
/* 1486 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1488 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1490 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 1492 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1494 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1496 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1496) */
/* 1498 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1500 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1502 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1504 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1506 */	NdrFcShort( 0xfffffe56 ),	/* Offset= -426 (1080) */
/* 1508 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1510 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1512 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1514 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1516 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1518 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1520 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1522 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1524 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1528 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1532 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1534 */	0x13, 0x0,	/* FC_OP */
/* 1536 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1490) */
/* 1538 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1540 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1542 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1544 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1548 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1554) */
/* 1550 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1552 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1554 */	
			0x11, 0x0,	/* FC_RP */
/* 1556 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1510) */
/* 1558 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1560 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1562 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1566 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1568 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1570 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1572 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1576 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1578 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1582 */	0x13, 0x0,	/* FC_OP */
/* 1584 */	NdrFcShort( 0xffffff44 ),	/* Offset= -188 (1396) */
/* 1586 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1588 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1590 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1592 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1596 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1602) */
/* 1598 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1600 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1602 */	
			0x11, 0x0,	/* FC_RP */
/* 1604 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1558) */
/* 1606 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1608 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1612 */	NdrFcShort( 0xa ),	/* Offset= 10 (1622) */
/* 1614 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1616 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1618 */	NdrFcShort( 0xfffffc3e ),	/* Offset= -962 (656) */
/* 1620 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1622 */	
			0x11, 0x0,	/* FC_RP */
/* 1624 */	NdrFcShort( 0xfffffd94 ),	/* Offset= -620 (1004) */
/* 1626 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1628 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1630 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1632 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1634 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1636 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1638 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1640 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1642 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1644 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1646 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1648 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1650 */	0x13, 0x0,	/* FC_OP */
/* 1652 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1626) */
/* 1654 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1656 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1658 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1660 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1662 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1666 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1668 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1670 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1672 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1674 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1676 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1678 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1680 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1682 */	0x13, 0x0,	/* FC_OP */
/* 1684 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1658) */
/* 1686 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1688 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1690 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1692 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1694 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1698 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1700 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1702 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1704 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1706 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1708 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1710 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1712 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1714 */	0x13, 0x0,	/* FC_OP */
/* 1716 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1690) */
/* 1718 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1720 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1722 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1724 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1726 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1728 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1730 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1732 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1734 */	NdrFcShort( 0xfffffbb8 ),	/* Offset= -1096 (638) */
/* 1736 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1738 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1740 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1742 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1722) */
/* 1744 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1744) */
/* 1746 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1748 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1750 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1752 */	NdrFcShort( 0xfffffc9c ),	/* Offset= -868 (884) */
/* 1754 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1756 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1758 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1760 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1762 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1764 */	NdrFcShort( 0xfffffc88 ),	/* Offset= -888 (876) */
/* 1766 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1768 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1770 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1772 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1774 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1776 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1778 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1780 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1782 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1784 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1786 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1788 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1790 */	0x13, 0x0,	/* FC_OP */
/* 1792 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1766) */
/* 1794 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1796 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1798 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1800 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1802 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1806 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1808 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1810 */	NdrFcShort( 0xfffffb66 ),	/* Offset= -1178 (632) */
/* 1812 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1814 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1816 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1818 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1820 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1822 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1824 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1826 */	0x13, 0x0,	/* FC_OP */
/* 1828 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1798) */
/* 1830 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1832 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1834 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1836 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1838 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1840 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1842 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1844 */	0xa,		/* FC_FLOAT */
			0x5b,		/* FC_END */
/* 1846 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1848 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1850 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1852 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1854 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1856 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1858 */	0x13, 0x0,	/* FC_OP */
/* 1860 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1834) */
/* 1862 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1864 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1866 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1868 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1870 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1872 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1874 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1876 */	0xc,		/* FC_DOUBLE */
			0x5b,		/* FC_END */
/* 1878 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1880 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1882 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1884 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1886 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1888 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1890 */	0x13, 0x0,	/* FC_OP */
/* 1892 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1866) */
/* 1894 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1896 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1898 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1900 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1902 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1904 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1906 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1908 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1910 */	NdrFcShort( 0xfffffb08 ),	/* Offset= -1272 (638) */
/* 1912 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1914 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1916 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1918 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1920 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1922 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1924 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1926 */	0x13, 0x0,	/* FC_OP */
/* 1928 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1898) */
/* 1930 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1932 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1934 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1936 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1938 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1940 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1942 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1944 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1946 */	NdrFcShort( 0xfffffaf6 ),	/* Offset= -1290 (656) */
/* 1948 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1950 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1952 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1954 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1956 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1958 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1960 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1962 */	0x13, 0x0,	/* FC_OP */
/* 1964 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1934) */
/* 1966 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1968 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1970 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1972 */	NdrFcShort( 0xc ),	/* 12 */
/* 1974 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1978 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1980 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1982 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1984 */	NdrFcShort( 0xc ),	/* 12 */
/* 1986 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1988 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1990 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1992 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1994 */	0x13, 0x0,	/* FC_OP */
/* 1996 */	NdrFcShort( 0xfffffad4 ),	/* Offset= -1324 (672) */
/* 1998 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2000 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffadb ),	/* Offset= -1317 (684) */
			0x5b,		/* FC_END */
/* 2004 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2006 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2008 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2010 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2012 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2014 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2016 */	0x13, 0x0,	/* FC_OP */
/* 2018 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1970) */
/* 2020 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2022 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2024 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2028 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2030 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2032 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2034 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2038 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2040 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2042 */	NdrFcShort( 0xfffffae2 ),	/* Offset= -1310 (732) */
/* 2044 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2046 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2048 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2050 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2052 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2054 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2056 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2058 */	0x13, 0x0,	/* FC_OP */
/* 2060 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2024) */
/* 2062 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2064 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2066 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2068 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2070 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2072 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2074 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2076 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2078 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2080 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2082 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2084 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2086 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2088 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2090 */	0x13, 0x0,	/* FC_OP */
/* 2092 */	NdrFcShort( 0xfffffaba ),	/* Offset= -1350 (742) */
/* 2094 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2096 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffac1 ),	/* Offset= -1343 (754) */
			0x5b,		/* FC_END */
/* 2100 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2104 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2106 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2108 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2110 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2112 */	0x13, 0x0,	/* FC_OP */
/* 2114 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (2066) */
/* 2116 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2118 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2120 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2122 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2124 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2128 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2130 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2132 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2134 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2138 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2144 */	0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2146 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 2148 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2150 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2152 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2156 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2158 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2160 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2162 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2164 */	0x13, 0x0,	/* FC_OP */
/* 2166 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (2120) */
/* 2168 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2170 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2172 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2174 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2176 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2180 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2182 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2184 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2186 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2190 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2194 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2196 */	0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2198 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2200 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2202 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2204 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2206 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2208 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2210 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2212 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2214 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2216 */	0x13, 0x0,	/* FC_OP */
/* 2218 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (2172) */
/* 2220 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2222 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2224 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2228 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2232 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2234 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2238 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2240 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2242 */	NdrFcShort( 0x20 ),	/* Offset= 32 (2274) */
/* 2244 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2246 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2248 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2252 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2258) */
/* 2254 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 2256 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2258 */	
			0x13, 0x0,	/* FC_OP */
/* 2260 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2224) */
/* 2262 */	
			0x13, 0x0,	/* FC_OP */
/* 2264 */	NdrFcShort( 0xfffffa04 ),	/* Offset= -1532 (732) */
/* 2266 */	
			0x13, 0x0,	/* FC_OP */
/* 2268 */	NdrFcShort( 0xfffffe00 ),	/* Offset= -512 (1756) */
/* 2270 */	
			0x13, 0x0,	/* FC_OP */
/* 2272 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2274) */
/* 2274 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2276 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2278 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2280 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2280) */
/* 2282 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 2284 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 2286 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2288 */	NdrFcShort( 0xfffff732 ),	/* Offset= -2254 (34) */
/* 2290 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2292 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2296 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2298 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2300 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2302 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2306 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2308 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2310 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2274) */
/* 2312 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2314 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2316 */	NdrFcLong( 0x3127ca40 ),	/* 824691264 */
/* 2320 */	NdrFcShort( 0x446e ),	/* 17518 */
/* 2322 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 2324 */	0x81,		/* 129 */
			0x35,		/* 53 */
/* 2326 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 2328 */	0x0,		/* 0 */
			0x4b,		/* 75 */
/* 2330 */	0xb8,		/* 184 */
			0x51,		/* 81 */
/* 2332 */	0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 2334 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2336 */	
			0x11, 0x0,	/* FC_RP */
/* 2338 */	NdrFcShort( 0xfffff96e ),	/* Offset= -1682 (656) */
/* 2340 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2342 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2344) */
/* 2344 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 2346 */	0x28,		/* Corr desc:  parameter, FC_LONG */
			0x0,		/*  */
/* 2348 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2350 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 2352 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2354 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2356) */
/* 2356 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2358 */	NdrFcLong( 0x20021801 ),	/* 537008129 */
/* 2362 */	NdrFcShort( 0x5de6 ),	/* 24038 */
/* 2364 */	NdrFcShort( 0x11d1 ),	/* 4561 */
/* 2366 */	0x8e,		/* 142 */
			0x38,		/* 56 */
/* 2368 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 2370 */	0x4f,		/* 79 */
			0xb9,		/* 185 */
/* 2372 */	0x38,		/* 56 */
			0x6d,		/* 109 */
/* 2374 */	
			0x11, 0x0,	/* FC_RP */
/* 2376 */	NdrFcShort( 0x1c ),	/* Offset= 28 (2404) */
/* 2378 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2380 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2382 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2384 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2390 */	0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2392 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2394 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2396 */	0x6,		/* FC_SHORT */
			0x3e,		/* FC_STRUCTPAD2 */
/* 2398 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2400 */	NdrFcShort( 0xfffff930 ),	/* Offset= -1744 (656) */
/* 2402 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2404 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 2406 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2408 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2410 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2412 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2414 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 2416 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2418 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2420 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2422 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x4a,		/* FC_VARIABLE_OFFSET */
/* 2424 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2428 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2430 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2434 */	0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2436 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2438 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2440 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc1 ),	/* Offset= -63 (2378) */
			0x5b,		/* FC_END */
/* 2444 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2446 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            }

        };


static void __RPC_USER IPropertyBagEx_PROPVARIANTExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    PROPVARIANT *pS	=	( PROPVARIANT * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( ( unsigned short  )pS->vt );
}

static void __RPC_USER IPropertyBagEx_CLIPDATAExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    CLIPDATA *pS	=	( CLIPDATA * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->cbSize - 4 );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    IPropertyBagEx_PROPVARIANTExprEval_0000
    ,IPropertyBagEx_CLIPDATAExprEval_0001
    };



/* Standard interface: __MIDL_itf_pbagex_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IPropertyBagEx, ver. 0.0,
   GUID={0x20011801,0x5DE6,0x11D1,{0x8E,0x38,0x00,0xC0,0x4F,0xB9,0x38,0x6D}} */

#pragma code_seg(".orpc")
static const unsigned short IPropertyBagEx_FormatStringOffsetTable[] =
    {
    0,
    54,
    102,
    150,
    216
    };

static const MIDL_STUBLESS_PROXY_INFO IPropertyBagEx_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IPropertyBagEx_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IPropertyBagEx_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IPropertyBagEx_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IPropertyBagExProxyVtbl = 
{
    &IPropertyBagEx_ProxyInfo,
    &IID_IPropertyBagEx,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::ReadMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::WriteMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::DeleteMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::Open */ ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::Enum */
};

const CInterfaceStubVtbl _IPropertyBagExStubVtbl =
{
    &IID_IPropertyBagEx,
    &IPropertyBagEx_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumSTATPROPBAG, ver. 0.0,
   GUID={0x20021801,0x5DE6,0x11D1,{0x8E,0x38,0x00,0xC0,0x4F,0xB9,0x38,0x6D}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumSTATPROPBAG_FormatStringOffsetTable[] =
    {
    264,
    312,
    348,
    378
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPBAG_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPBAG_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumSTATPROPBAG_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPBAG_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IEnumSTATPROPBAGProxyVtbl = 
{
    &IEnumSTATPROPBAG_ProxyInfo,
    &IID_IEnumSTATPROPBAG,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPBAG::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPBAG::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPBAG::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPBAG::Clone */
};

const CInterfaceStubVtbl _IEnumSTATPROPBAGStubVtbl =
{
    &IID_IEnumSTATPROPBAG,
    &IEnumSTATPROPBAG_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_pbagex_0112, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _pbagex_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IPropertyBagExProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumSTATPROPBAGProxyVtbl,
    0
};

const CInterfaceStubVtbl * _pbagex_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IPropertyBagExStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumSTATPROPBAGStubVtbl,
    0
};

PCInterfaceName const _pbagex_InterfaceNamesList[] = 
{
    "IPropertyBagEx",
    "IEnumSTATPROPBAG",
    0
};


#define _pbagex_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _pbagex, pIID, n)

int __stdcall _pbagex_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _pbagex, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _pbagex, 2, *pIndex )
    
}

const ExtendedProxyFileInfo pbagex_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _pbagex_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _pbagex_StubVtblList,
    (const PCInterfaceName * ) & _pbagex_InterfaceNamesList,
    0, // no delegation
    & _pbagex_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:31 2002
 */
/* Compiler settings for pbagex.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "pbagex.h"

#define TYPE_FORMAT_STRING_SIZE   2465                              
#define PROC_FORMAT_STRING_SIZE   433                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IPropertyBagEx_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IPropertyBagEx_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumSTATPROPBAG_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPBAG_ProxyInfo;


extern const EXPR_EVAL ExprEvalRoutines[];
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure ReadMultiple */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 16 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x44 ),	/* 68 */
/* 20 */	NdrFcShort( 0x45 ),	/* 69 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cprops */

/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgwszPropNames */

/* 32 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter rgvar */

/* 38 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	NdrFcShort( 0x91a ),	/* Type Offset=2330 */

	/* Parameter pErrorLog */

/* 44 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 46 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 48 */	NdrFcShort( 0x930 ),	/* Type Offset=2352 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteMultiple */

/* 56 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x4 ),	/* 4 */
/* 64 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 66 */	NdrFcShort( 0x8 ),	/* 8 */
/* 68 */	NdrFcShort( 0x8 ),	/* 8 */
/* 70 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 72 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 74 */	NdrFcShort( 0x0 ),	/* 0 */
/* 76 */	NdrFcShort( 0x45 ),	/* 69 */
/* 78 */	NdrFcShort( 0x0 ),	/* 0 */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cprops */

/* 82 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 84 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 86 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgwszPropNames */

/* 88 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 90 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 92 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter rgvar */

/* 94 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 96 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 98 */	NdrFcShort( 0x91a ),	/* Type Offset=2330 */

	/* Return value */

/* 100 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 102 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DeleteMultiple */

/* 106 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0x5 ),	/* 5 */
/* 114 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 116 */	NdrFcShort( 0x10 ),	/* 16 */
/* 118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 120 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 122 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 126 */	NdrFcShort( 0x1 ),	/* 1 */
/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 130 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cprops */

/* 132 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 134 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgwszPropNames */

/* 138 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 140 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 142 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter dwReserved */

/* 144 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 146 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 150 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 152 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Open */

/* 156 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 158 */	NdrFcLong( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0x6 ),	/* 6 */
/* 164 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 166 */	NdrFcShort( 0x7c ),	/* 124 */
/* 168 */	NdrFcShort( 0x8 ),	/* 8 */
/* 170 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 172 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 174 */	NdrFcShort( 0x1 ),	/* 1 */
/* 176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 182 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 184 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 186 */	NdrFcShort( 0x30a ),	/* Type Offset=778 */

	/* Parameter wszPropName */

/* 188 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 190 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 192 */	NdrFcShort( 0x944 ),	/* Type Offset=2372 */

	/* Parameter guidPropertyType */

/* 194 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 196 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 198 */	NdrFcShort( 0x286 ),	/* Type Offset=646 */

	/* Parameter dwFlags */

/* 200 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 202 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 204 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter riid */

/* 206 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 208 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 210 */	NdrFcShort( 0x286 ),	/* Type Offset=646 */

	/* Parameter ppUnk */

/* 212 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 214 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 216 */	NdrFcShort( 0x94a ),	/* Type Offset=2378 */

	/* Return value */

/* 218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 220 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Enum */

/* 224 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x7 ),	/* 7 */
/* 232 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 234 */	NdrFcShort( 0x8 ),	/* 8 */
/* 236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 238 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 240 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszPropNameMask */

/* 250 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 252 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 254 */	NdrFcShort( 0x944 ),	/* Type Offset=2372 */

	/* Parameter dwFlags */

/* 256 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 258 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 260 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppenum */

/* 262 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 264 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 266 */	NdrFcShort( 0x956 ),	/* Type Offset=2390 */

	/* Return value */

/* 268 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 270 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 272 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 274 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 276 */	NdrFcLong( 0x0 ),	/* 0 */
/* 280 */	NdrFcShort( 0x3 ),	/* 3 */
/* 282 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 286 */	NdrFcShort( 0x24 ),	/* 36 */
/* 288 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 290 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 292 */	NdrFcShort( 0x1 ),	/* 1 */
/* 294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 298 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 300 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 302 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 306 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 308 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 310 */	NdrFcShort( 0x986 ),	/* Type Offset=2438 */

	/* Parameter pceltFetched */

/* 312 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 314 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 316 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 320 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Skip */

/* 324 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0x4 ),	/* 4 */
/* 332 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 334 */	NdrFcShort( 0x8 ),	/* 8 */
/* 336 */	NdrFcShort( 0x8 ),	/* 8 */
/* 338 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 340 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 348 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter celt */

/* 350 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 352 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 354 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 356 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 358 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 360 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */

/* 362 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 364 */	NdrFcLong( 0x0 ),	/* 0 */
/* 368 */	NdrFcShort( 0x5 ),	/* 5 */
/* 370 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 372 */	NdrFcShort( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x8 ),	/* 8 */
/* 376 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 378 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 388 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 390 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 392 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 394 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 396 */	NdrFcLong( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x6 ),	/* 6 */
/* 402 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 406 */	NdrFcShort( 0x8 ),	/* 8 */
/* 408 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 410 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 418 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppenum */

/* 420 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 422 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 424 */	NdrFcShort( 0x956 ),	/* Type Offset=2390 */

	/* Return value */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 428 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x0 ),	/* 0 */
/*  6 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/*  8 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 10 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 12 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 16 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 18 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 20 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 22 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 24 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 26 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 32 */	NdrFcShort( 0x2 ),	/* Offset= 2 (34) */
/* 34 */	NdrFcShort( 0x10 ),	/* 16 */
/* 36 */	NdrFcShort( 0x61 ),	/* 97 */
/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x0 ),	/* Offset= 0 (42) */
/* 44 */	NdrFcLong( 0x1 ),	/* 1 */
/* 48 */	NdrFcShort( 0x0 ),	/* Offset= 0 (48) */
/* 50 */	NdrFcLong( 0x10 ),	/* 16 */
/* 54 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 56 */	NdrFcLong( 0x11 ),	/* 17 */
/* 60 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 62 */	NdrFcLong( 0x2 ),	/* 2 */
/* 66 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 68 */	NdrFcLong( 0x12 ),	/* 18 */
/* 72 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 74 */	NdrFcLong( 0x3 ),	/* 3 */
/* 78 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 80 */	NdrFcLong( 0x13 ),	/* 19 */
/* 84 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 86 */	NdrFcLong( 0x16 ),	/* 22 */
/* 90 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 92 */	NdrFcLong( 0x17 ),	/* 23 */
/* 96 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 98 */	NdrFcLong( 0xe ),	/* 14 */
/* 102 */	NdrFcShort( 0x208 ),	/* Offset= 520 (622) */
/* 104 */	NdrFcLong( 0x14 ),	/* 20 */
/* 108 */	NdrFcShort( 0x202 ),	/* Offset= 514 (622) */
/* 110 */	NdrFcLong( 0x15 ),	/* 21 */
/* 114 */	NdrFcShort( 0x1fc ),	/* Offset= 508 (622) */
/* 116 */	NdrFcLong( 0x4 ),	/* 4 */
/* 120 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 122 */	NdrFcLong( 0x5 ),	/* 5 */
/* 126 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 128 */	NdrFcLong( 0xb ),	/* 11 */
/* 132 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 134 */	NdrFcLong( 0xffff ),	/* 65535 */
/* 138 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 140 */	NdrFcLong( 0xa ),	/* 10 */
/* 144 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 146 */	NdrFcLong( 0x6 ),	/* 6 */
/* 150 */	NdrFcShort( 0x1d8 ),	/* Offset= 472 (622) */
/* 152 */	NdrFcLong( 0x7 ),	/* 7 */
/* 156 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 158 */	NdrFcLong( 0x40 ),	/* 64 */
/* 162 */	NdrFcShort( 0x1d2 ),	/* Offset= 466 (628) */
/* 164 */	NdrFcLong( 0x48 ),	/* 72 */
/* 168 */	NdrFcShort( 0x1d4 ),	/* Offset= 468 (636) */
/* 170 */	NdrFcLong( 0x47 ),	/* 71 */
/* 174 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (658) */
/* 176 */	NdrFcLong( 0x8 ),	/* 8 */
/* 180 */	NdrFcShort( 0x218 ),	/* Offset= 536 (716) */
/* 182 */	NdrFcLong( 0xfff ),	/* 4095 */
/* 186 */	NdrFcShort( 0x228 ),	/* Offset= 552 (738) */
/* 188 */	NdrFcLong( 0x41 ),	/* 65 */
/* 192 */	NdrFcShort( 0x232 ),	/* Offset= 562 (754) */
/* 194 */	NdrFcLong( 0x46 ),	/* 70 */
/* 198 */	NdrFcShort( 0x22c ),	/* Offset= 556 (754) */
/* 200 */	NdrFcLong( 0x1e ),	/* 30 */
/* 204 */	NdrFcShort( 0x236 ),	/* Offset= 566 (770) */
/* 206 */	NdrFcLong( 0x1f ),	/* 31 */
/* 210 */	NdrFcShort( 0x234 ),	/* Offset= 564 (774) */
/* 212 */	NdrFcLong( 0xd ),	/* 13 */
/* 216 */	NdrFcShort( 0x232 ),	/* Offset= 562 (778) */
/* 218 */	NdrFcLong( 0x9 ),	/* 9 */
/* 222 */	NdrFcShort( 0x23e ),	/* Offset= 574 (796) */
/* 224 */	NdrFcLong( 0x42 ),	/* 66 */
/* 228 */	NdrFcShort( 0x24a ),	/* Offset= 586 (814) */
/* 230 */	NdrFcLong( 0x44 ),	/* 68 */
/* 234 */	NdrFcShort( 0x244 ),	/* Offset= 580 (814) */
/* 236 */	NdrFcLong( 0x43 ),	/* 67 */
/* 240 */	NdrFcShort( 0x250 ),	/* Offset= 592 (832) */
/* 242 */	NdrFcLong( 0x45 ),	/* 69 */
/* 246 */	NdrFcShort( 0x24a ),	/* Offset= 586 (832) */
/* 248 */	NdrFcLong( 0x49 ),	/* 73 */
/* 252 */	NdrFcShort( 0x256 ),	/* Offset= 598 (850) */
/* 254 */	NdrFcLong( 0x2010 ),	/* 8208 */
/* 258 */	NdrFcShort( 0x5b8 ),	/* Offset= 1464 (1722) */
/* 260 */	NdrFcLong( 0x2011 ),	/* 8209 */
/* 264 */	NdrFcShort( 0x5b2 ),	/* Offset= 1458 (1722) */
/* 266 */	NdrFcLong( 0x2002 ),	/* 8194 */
/* 270 */	NdrFcShort( 0x5ac ),	/* Offset= 1452 (1722) */
/* 272 */	NdrFcLong( 0x2012 ),	/* 8210 */
/* 276 */	NdrFcShort( 0x5a6 ),	/* Offset= 1446 (1722) */
/* 278 */	NdrFcLong( 0x2003 ),	/* 8195 */
/* 282 */	NdrFcShort( 0x5a0 ),	/* Offset= 1440 (1722) */
/* 284 */	NdrFcLong( 0x2013 ),	/* 8211 */
/* 288 */	NdrFcShort( 0x59a ),	/* Offset= 1434 (1722) */
/* 290 */	NdrFcLong( 0x2016 ),	/* 8214 */
/* 294 */	NdrFcShort( 0x594 ),	/* Offset= 1428 (1722) */
/* 296 */	NdrFcLong( 0x2017 ),	/* 8215 */
/* 300 */	NdrFcShort( 0x58e ),	/* Offset= 1422 (1722) */
/* 302 */	NdrFcLong( 0x2004 ),	/* 8196 */
/* 306 */	NdrFcShort( 0x588 ),	/* Offset= 1416 (1722) */
/* 308 */	NdrFcLong( 0x2005 ),	/* 8197 */
/* 312 */	NdrFcShort( 0x582 ),	/* Offset= 1410 (1722) */
/* 314 */	NdrFcLong( 0x2006 ),	/* 8198 */
/* 318 */	NdrFcShort( 0x57c ),	/* Offset= 1404 (1722) */
/* 320 */	NdrFcLong( 0x2007 ),	/* 8199 */
/* 324 */	NdrFcShort( 0x576 ),	/* Offset= 1398 (1722) */
/* 326 */	NdrFcLong( 0x2008 ),	/* 8200 */
/* 330 */	NdrFcShort( 0x570 ),	/* Offset= 1392 (1722) */
/* 332 */	NdrFcLong( 0x200b ),	/* 8203 */
/* 336 */	NdrFcShort( 0x56a ),	/* Offset= 1386 (1722) */
/* 338 */	NdrFcLong( 0x200e ),	/* 8206 */
/* 342 */	NdrFcShort( 0x564 ),	/* Offset= 1380 (1722) */
/* 344 */	NdrFcLong( 0x2009 ),	/* 8201 */
/* 348 */	NdrFcShort( 0x55e ),	/* Offset= 1374 (1722) */
/* 350 */	NdrFcLong( 0x200d ),	/* 8205 */
/* 354 */	NdrFcShort( 0x558 ),	/* Offset= 1368 (1722) */
/* 356 */	NdrFcLong( 0x200a ),	/* 8202 */
/* 360 */	NdrFcShort( 0x552 ),	/* Offset= 1362 (1722) */
/* 362 */	NdrFcLong( 0x200c ),	/* 8204 */
/* 366 */	NdrFcShort( 0x54c ),	/* Offset= 1356 (1722) */
/* 368 */	NdrFcLong( 0x1010 ),	/* 4112 */
/* 372 */	NdrFcShort( 0x55c ),	/* Offset= 1372 (1744) */
/* 374 */	NdrFcLong( 0x1011 ),	/* 4113 */
/* 378 */	NdrFcShort( 0x566 ),	/* Offset= 1382 (1760) */
/* 380 */	NdrFcLong( 0x1002 ),	/* 4098 */
/* 384 */	NdrFcShort( 0x570 ),	/* Offset= 1392 (1776) */
/* 386 */	NdrFcLong( 0x1012 ),	/* 4114 */
/* 390 */	NdrFcShort( 0x57a ),	/* Offset= 1402 (1792) */
/* 392 */	NdrFcLong( 0x1003 ),	/* 4099 */
/* 396 */	NdrFcShort( 0x584 ),	/* Offset= 1412 (1808) */
/* 398 */	NdrFcLong( 0x1013 ),	/* 4115 */
/* 402 */	NdrFcShort( 0x58e ),	/* Offset= 1422 (1824) */
/* 404 */	NdrFcLong( 0x1014 ),	/* 4116 */
/* 408 */	NdrFcShort( 0x5a8 ),	/* Offset= 1448 (1856) */
/* 410 */	NdrFcLong( 0x1015 ),	/* 4117 */
/* 414 */	NdrFcShort( 0x5b2 ),	/* Offset= 1458 (1872) */
/* 416 */	NdrFcLong( 0x1004 ),	/* 4100 */
/* 420 */	NdrFcShort( 0x5c8 ),	/* Offset= 1480 (1900) */
/* 422 */	NdrFcLong( 0x1005 ),	/* 4101 */
/* 426 */	NdrFcShort( 0x5de ),	/* Offset= 1502 (1928) */
/* 428 */	NdrFcLong( 0x100b ),	/* 4107 */
/* 432 */	NdrFcShort( 0x5e8 ),	/* Offset= 1512 (1944) */
/* 434 */	NdrFcLong( 0x100a ),	/* 4106 */
/* 438 */	NdrFcShort( 0x5f2 ),	/* Offset= 1522 (1960) */
/* 440 */	NdrFcLong( 0x1006 ),	/* 4102 */
/* 444 */	NdrFcShort( 0x5fc ),	/* Offset= 1532 (1976) */
/* 446 */	NdrFcLong( 0x1007 ),	/* 4103 */
/* 450 */	NdrFcShort( 0x606 ),	/* Offset= 1542 (1992) */
/* 452 */	NdrFcLong( 0x1040 ),	/* 4160 */
/* 456 */	NdrFcShort( 0x620 ),	/* Offset= 1568 (2024) */
/* 458 */	NdrFcLong( 0x1048 ),	/* 4168 */
/* 462 */	NdrFcShort( 0x63a ),	/* Offset= 1594 (2056) */
/* 464 */	NdrFcLong( 0x1047 ),	/* 4167 */
/* 468 */	NdrFcShort( 0x65a ),	/* Offset= 1626 (2094) */
/* 470 */	NdrFcLong( 0x1008 ),	/* 4104 */
/* 474 */	NdrFcShort( 0x67a ),	/* Offset= 1658 (2132) */
/* 476 */	NdrFcLong( 0x1fff ),	/* 8191 */
/* 480 */	NdrFcShort( 0x69a ),	/* Offset= 1690 (2170) */
/* 482 */	NdrFcLong( 0x101e ),	/* 4126 */
/* 486 */	NdrFcShort( 0x6ba ),	/* Offset= 1722 (2208) */
/* 488 */	NdrFcLong( 0x101f ),	/* 4127 */
/* 492 */	NdrFcShort( 0x6da ),	/* Offset= 1754 (2246) */
/* 494 */	NdrFcLong( 0x100c ),	/* 4108 */
/* 498 */	NdrFcShort( 0x6fa ),	/* Offset= 1786 (2284) */
/* 500 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 504 */	NdrFcShort( 0x3c4 ),	/* Offset= 964 (1468) */
/* 506 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 510 */	NdrFcShort( 0x3be ),	/* Offset= 958 (1468) */
/* 512 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 516 */	NdrFcShort( 0x376 ),	/* Offset= 886 (1402) */
/* 518 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 522 */	NdrFcShort( 0x370 ),	/* Offset= 880 (1402) */
/* 524 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 528 */	NdrFcShort( 0x36e ),	/* Offset= 878 (1406) */
/* 530 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 534 */	NdrFcShort( 0x368 ),	/* Offset= 872 (1406) */
/* 536 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 540 */	NdrFcShort( 0x362 ),	/* Offset= 866 (1406) */
/* 542 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 546 */	NdrFcShort( 0x35c ),	/* Offset= 860 (1406) */
/* 548 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 552 */	NdrFcShort( 0x35a ),	/* Offset= 858 (1410) */
/* 554 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 558 */	NdrFcShort( 0x358 ),	/* Offset= 856 (1414) */
/* 560 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 564 */	NdrFcShort( 0x346 ),	/* Offset= 838 (1402) */
/* 566 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 570 */	NdrFcShort( 0x37e ),	/* Offset= 894 (1464) */
/* 572 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 576 */	NdrFcShort( 0x33e ),	/* Offset= 830 (1406) */
/* 578 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 582 */	NdrFcShort( 0x344 ),	/* Offset= 836 (1418) */
/* 584 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 588 */	NdrFcShort( 0x33a ),	/* Offset= 826 (1414) */
/* 590 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 594 */	NdrFcShort( 0x6aa ),	/* Offset= 1706 (2300) */
/* 596 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 600 */	NdrFcShort( 0x33a ),	/* Offset= 826 (1426) */
/* 602 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 606 */	NdrFcShort( 0x338 ),	/* Offset= 824 (1430) */
/* 608 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 612 */	NdrFcShort( 0x69c ),	/* Offset= 1692 (2304) */
/* 614 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 618 */	NdrFcShort( 0x69a ),	/* Offset= 1690 (2308) */
/* 620 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (619) */
/* 622 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 624 */	NdrFcShort( 0x8 ),	/* 8 */
/* 626 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 628 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 632 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 634 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 636 */	
			0x13, 0x0,	/* FC_OP */
/* 638 */	NdrFcShort( 0x8 ),	/* Offset= 8 (646) */
/* 640 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 642 */	NdrFcShort( 0x8 ),	/* 8 */
/* 644 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 646 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 648 */	NdrFcShort( 0x10 ),	/* 16 */
/* 650 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 652 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 654 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (640) */
			0x5b,		/* FC_END */
/* 658 */	
			0x13, 0x0,	/* FC_OP */
/* 660 */	NdrFcShort( 0xe ),	/* Offset= 14 (674) */
/* 662 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 664 */	NdrFcShort( 0x1 ),	/* 1 */
/* 666 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 668 */	NdrFcShort( 0x1 ),	/* 1 */
/* 670 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 672 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 674 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 676 */	NdrFcShort( 0x10 ),	/* 16 */
/* 678 */	NdrFcShort( 0x0 ),	/* 0 */
/* 680 */	NdrFcShort( 0x6 ),	/* Offset= 6 (686) */
/* 682 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 684 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 686 */	
			0x13, 0x0,	/* FC_OP */
/* 688 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (662) */
/* 690 */	
			0x13, 0x0,	/* FC_OP */
/* 692 */	NdrFcShort( 0xe ),	/* Offset= 14 (706) */
/* 694 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 696 */	NdrFcShort( 0x2 ),	/* 2 */
/* 698 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 700 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 702 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 704 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 706 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 708 */	NdrFcShort( 0x8 ),	/* 8 */
/* 710 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (694) */
/* 712 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 714 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 716 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 718 */	NdrFcShort( 0x0 ),	/* 0 */
/* 720 */	NdrFcShort( 0x8 ),	/* 8 */
/* 722 */	NdrFcShort( 0x0 ),	/* 0 */
/* 724 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (690) */
/* 726 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 728 */	NdrFcShort( 0x1 ),	/* 1 */
/* 730 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 734 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 736 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 738 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 740 */	NdrFcShort( 0x10 ),	/* 16 */
/* 742 */	NdrFcShort( 0x0 ),	/* 0 */
/* 744 */	NdrFcShort( 0x6 ),	/* Offset= 6 (750) */
/* 746 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 748 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 750 */	
			0x13, 0x0,	/* FC_OP */
/* 752 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (726) */
/* 754 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 756 */	NdrFcShort( 0x10 ),	/* 16 */
/* 758 */	NdrFcShort( 0x0 ),	/* 0 */
/* 760 */	NdrFcShort( 0x6 ),	/* Offset= 6 (766) */
/* 762 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 764 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 766 */	
			0x13, 0x0,	/* FC_OP */
/* 768 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (726) */
/* 770 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 772 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 774 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 776 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 778 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 780 */	NdrFcLong( 0x0 ),	/* 0 */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 786 */	NdrFcShort( 0x0 ),	/* 0 */
/* 788 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 790 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 792 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 794 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 796 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 798 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 802 */	NdrFcShort( 0x0 ),	/* 0 */
/* 804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 806 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 808 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 810 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 812 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 814 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 816 */	NdrFcLong( 0xc ),	/* 12 */
/* 820 */	NdrFcShort( 0x0 ),	/* 0 */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 826 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 828 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 830 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 832 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 834 */	NdrFcLong( 0xb ),	/* 11 */
/* 838 */	NdrFcShort( 0x0 ),	/* 0 */
/* 840 */	NdrFcShort( 0x0 ),	/* 0 */
/* 842 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 844 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 846 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 848 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 850 */	
			0x13, 0x0,	/* FC_OP */
/* 852 */	NdrFcShort( 0x2 ),	/* Offset= 2 (854) */
/* 854 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 856 */	NdrFcShort( 0x18 ),	/* 24 */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0xc ),	/* Offset= 12 (872) */
/* 862 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 864 */	NdrFcShort( 0xffffff26 ),	/* Offset= -218 (646) */
/* 866 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 868 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (814) */
/* 870 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 872 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 874 */	NdrFcShort( 0x2 ),	/* Offset= 2 (876) */
/* 876 */	
			0x13, 0x0,	/* FC_OP */
/* 878 */	NdrFcShort( 0x33a ),	/* Offset= 826 (1704) */
/* 880 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x89,		/* 137 */
/* 882 */	NdrFcShort( 0x20 ),	/* 32 */
/* 884 */	NdrFcShort( 0xa ),	/* 10 */
/* 886 */	NdrFcLong( 0x8 ),	/* 8 */
/* 890 */	NdrFcShort( 0x50 ),	/* Offset= 80 (970) */
/* 892 */	NdrFcLong( 0xd ),	/* 13 */
/* 896 */	NdrFcShort( 0x70 ),	/* Offset= 112 (1008) */
/* 898 */	NdrFcLong( 0x9 ),	/* 9 */
/* 902 */	NdrFcShort( 0x90 ),	/* Offset= 144 (1046) */
/* 904 */	NdrFcLong( 0xc ),	/* 12 */
/* 908 */	NdrFcShort( 0x25e ),	/* Offset= 606 (1514) */
/* 910 */	NdrFcLong( 0x24 ),	/* 36 */
/* 914 */	NdrFcShort( 0x27e ),	/* Offset= 638 (1552) */
/* 916 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 920 */	NdrFcShort( 0x288 ),	/* Offset= 648 (1568) */
/* 922 */	NdrFcLong( 0x10 ),	/* 16 */
/* 926 */	NdrFcShort( 0x296 ),	/* Offset= 662 (1588) */
/* 928 */	NdrFcLong( 0x2 ),	/* 2 */
/* 932 */	NdrFcShort( 0x2ac ),	/* Offset= 684 (1616) */
/* 934 */	NdrFcLong( 0x3 ),	/* 3 */
/* 938 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (1644) */
/* 940 */	NdrFcLong( 0x14 ),	/* 20 */
/* 944 */	NdrFcShort( 0x2d8 ),	/* Offset= 728 (1672) */
/* 946 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (945) */
/* 948 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 950 */	NdrFcShort( 0x0 ),	/* 0 */
/* 952 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */
/* 956 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 958 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 962 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 964 */	
			0x13, 0x0,	/* FC_OP */
/* 966 */	NdrFcShort( 0xfffffefc ),	/* Offset= -260 (706) */
/* 968 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 970 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 972 */	NdrFcShort( 0x10 ),	/* 16 */
/* 974 */	NdrFcShort( 0x0 ),	/* 0 */
/* 976 */	NdrFcShort( 0x6 ),	/* Offset= 6 (982) */
/* 978 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 980 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 982 */	
			0x11, 0x0,	/* FC_RP */
/* 984 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (948) */
/* 986 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 988 */	NdrFcShort( 0x0 ),	/* 0 */
/* 990 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 992 */	NdrFcShort( 0x0 ),	/* 0 */
/* 994 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 996 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1000 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1002 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1004 */	NdrFcShort( 0xffffff1e ),	/* Offset= -226 (778) */
/* 1006 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1008 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1010 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1014 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1020) */
/* 1016 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1018 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1020 */	
			0x11, 0x0,	/* FC_RP */
/* 1022 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (986) */
/* 1024 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1028 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1030 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1032 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1034 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1038 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1040 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1042 */	NdrFcShort( 0xffffff0a ),	/* Offset= -246 (796) */
/* 1044 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1046 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1048 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1050 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1052 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1058) */
/* 1054 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1056 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1058 */	
			0x11, 0x0,	/* FC_RP */
/* 1060 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1024) */
/* 1062 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 1064 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1066 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 1068 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1070 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1072) */
/* 1072 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1074 */	NdrFcShort( 0x2b ),	/* 43 */
/* 1076 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1080 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1082 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1086 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 1088 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1092 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1094 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1098 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1100 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1104 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1106 */	NdrFcLong( 0xb ),	/* 11 */
/* 1110 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1112 */	NdrFcLong( 0xa ),	/* 10 */
/* 1116 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1118 */	NdrFcLong( 0x6 ),	/* 6 */
/* 1122 */	NdrFcShort( 0xfffffe0c ),	/* Offset= -500 (622) */
/* 1124 */	NdrFcLong( 0x7 ),	/* 7 */
/* 1128 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1130 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1134 */	NdrFcShort( 0xfffffe44 ),	/* Offset= -444 (690) */
/* 1136 */	NdrFcLong( 0xd ),	/* 13 */
/* 1140 */	NdrFcShort( 0xfffffe96 ),	/* Offset= -362 (778) */
/* 1142 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1146 */	NdrFcShort( 0xfffffea2 ),	/* Offset= -350 (796) */
/* 1148 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 1152 */	NdrFcShort( 0xb8 ),	/* Offset= 184 (1336) */
/* 1154 */	NdrFcLong( 0x24 ),	/* 36 */
/* 1158 */	NdrFcShort( 0xba ),	/* Offset= 186 (1344) */
/* 1160 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 1164 */	NdrFcShort( 0xb4 ),	/* Offset= 180 (1344) */
/* 1166 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 1170 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (1398) */
/* 1172 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 1176 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (1402) */
/* 1178 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 1182 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (1406) */
/* 1184 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 1188 */	NdrFcShort( 0xde ),	/* Offset= 222 (1410) */
/* 1190 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 1194 */	NdrFcShort( 0xdc ),	/* Offset= 220 (1414) */
/* 1196 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 1200 */	NdrFcShort( 0xca ),	/* Offset= 202 (1402) */
/* 1202 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 1206 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (1406) */
/* 1208 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 1212 */	NdrFcShort( 0xce ),	/* Offset= 206 (1418) */
/* 1214 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 1218 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (1414) */
/* 1220 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 1224 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (1422) */
/* 1226 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 1230 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (1426) */
/* 1232 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 1236 */	NdrFcShort( 0xc2 ),	/* Offset= 194 (1430) */
/* 1238 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 1242 */	NdrFcShort( 0xc0 ),	/* Offset= 192 (1434) */
/* 1244 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 1248 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (1446) */
/* 1250 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1254 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1256 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1260 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1262 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1266 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1268 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1272 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1274 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1278 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1280 */	NdrFcLong( 0xe ),	/* 14 */
/* 1284 */	NdrFcShort( 0xaa ),	/* Offset= 170 (1454) */
/* 1286 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 1290 */	NdrFcShort( 0xae ),	/* Offset= 174 (1464) */
/* 1292 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 1296 */	NdrFcShort( 0xac ),	/* Offset= 172 (1468) */
/* 1298 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 1302 */	NdrFcShort( 0x64 ),	/* Offset= 100 (1402) */
/* 1304 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 1308 */	NdrFcShort( 0x62 ),	/* Offset= 98 (1406) */
/* 1310 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 1314 */	NdrFcShort( 0x5c ),	/* Offset= 92 (1406) */
/* 1316 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 1320 */	NdrFcShort( 0x56 ),	/* Offset= 86 (1406) */
/* 1322 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1326 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1326) */
/* 1328 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1332 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1332) */
/* 1334 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (1333) */
/* 1336 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1338 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1340) */
/* 1340 */	
			0x13, 0x0,	/* FC_OP */
/* 1342 */	NdrFcShort( 0x16a ),	/* Offset= 362 (1704) */
/* 1344 */	
			0x13, 0x0,	/* FC_OP */
/* 1346 */	NdrFcShort( 0x20 ),	/* Offset= 32 (1378) */
/* 1348 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1350 */	NdrFcLong( 0x2f ),	/* 47 */
/* 1354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1358 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1360 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1362 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1364 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1366 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1368 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1370 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1372 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1374 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1376 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1378 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1380 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1384 */	NdrFcShort( 0xa ),	/* Offset= 10 (1394) */
/* 1386 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1390 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1348) */
/* 1392 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1394 */	
			0x13, 0x0,	/* FC_OP */
/* 1396 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1366) */
/* 1398 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1400 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 1402 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1404 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1406 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1408 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1410 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1412 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 1414 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1416 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 1418 */	
			0x13, 0x0,	/* FC_OP */
/* 1420 */	NdrFcShort( 0xfffffce2 ),	/* Offset= -798 (622) */
/* 1422 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1424 */	NdrFcShort( 0xfffffd22 ),	/* Offset= -734 (690) */
/* 1426 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1428 */	NdrFcShort( 0xfffffd76 ),	/* Offset= -650 (778) */
/* 1430 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1432 */	NdrFcShort( 0xfffffd84 ),	/* Offset= -636 (796) */
/* 1434 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1436 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1438) */
/* 1438 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1440 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1442) */
/* 1442 */	
			0x13, 0x0,	/* FC_OP */
/* 1444 */	NdrFcShort( 0x104 ),	/* Offset= 260 (1704) */
/* 1446 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1448 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1450) */
/* 1450 */	
			0x13, 0x0,	/* FC_OP */
/* 1452 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1472) */
/* 1454 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 1456 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1458 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 1460 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 1462 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1464 */	
			0x13, 0x0,	/* FC_OP */
/* 1466 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1454) */
/* 1468 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1470 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1472 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 1474 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1478 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1478) */
/* 1480 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1482 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1484 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1486 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1488 */	NdrFcShort( 0xfffffe56 ),	/* Offset= -426 (1062) */
/* 1490 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1492 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1494 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1496 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1498 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1500 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1502 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1506 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1508 */	
			0x13, 0x0,	/* FC_OP */
/* 1510 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (1472) */
/* 1512 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1514 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1516 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1518 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1520 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1526) */
/* 1522 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1524 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1526 */	
			0x11, 0x0,	/* FC_RP */
/* 1528 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1492) */
/* 1530 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1532 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1534 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1540 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1544 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1546 */	
			0x13, 0x0,	/* FC_OP */
/* 1548 */	NdrFcShort( 0xffffff56 ),	/* Offset= -170 (1378) */
/* 1550 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1552 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1554 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1556 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1558 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1564) */
/* 1560 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1562 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1564 */	
			0x11, 0x0,	/* FC_RP */
/* 1566 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1530) */
/* 1568 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1570 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1574 */	NdrFcShort( 0xa ),	/* Offset= 10 (1584) */
/* 1576 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1578 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1580 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffc59 ),	/* Offset= -935 (646) */
			0x5b,		/* FC_END */
/* 1584 */	
			0x11, 0x0,	/* FC_RP */
/* 1586 */	NdrFcShort( 0xfffffda8 ),	/* Offset= -600 (986) */
/* 1588 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1590 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1592 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1594 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1600) */
/* 1596 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1598 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1600 */	
			0x13, 0x0,	/* FC_OP */
/* 1602 */	NdrFcShort( 0xfffffc94 ),	/* Offset= -876 (726) */
/* 1604 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1606 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1608 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1612 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1614 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1616 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1618 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1622 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1628) */
/* 1624 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1626 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1628 */	
			0x13, 0x0,	/* FC_OP */
/* 1630 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1604) */
/* 1632 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1634 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1636 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1638 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1640 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1642 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1644 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1646 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1650 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1656) */
/* 1652 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1654 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1656 */	
			0x13, 0x0,	/* FC_OP */
/* 1658 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1632) */
/* 1660 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1662 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1664 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1668 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1670 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1672 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1674 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1676 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1678 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1684) */
/* 1680 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1682 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1684 */	
			0x13, 0x0,	/* FC_OP */
/* 1686 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1660) */
/* 1688 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1692 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1694 */	NdrFcShort( 0xffc8 ),	/* -56 */
/* 1696 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1698 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1700 */	NdrFcShort( 0xfffffbd0 ),	/* Offset= -1072 (628) */
/* 1702 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1704 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1706 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1708 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1688) */
/* 1710 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1710) */
/* 1712 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1714 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1716 */	0x40,		/* FC_STRUCTPAD4 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1718 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffcb9 ),	/* Offset= -839 (880) */
			0x5b,		/* FC_END */
/* 1722 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1724 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1726 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1730 */	NdrFcShort( 0xfffffca6 ),	/* Offset= -858 (872) */
/* 1732 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1734 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1736 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1740 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1742 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1744 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1746 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1750 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1756) */
/* 1752 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1754 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1756 */	
			0x13, 0x0,	/* FC_OP */
/* 1758 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1732) */
/* 1760 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1762 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1766 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1772) */
/* 1768 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1770 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1772 */	
			0x13, 0x0,	/* FC_OP */
/* 1774 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1732) */
/* 1776 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1778 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1780 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1782 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1788) */
/* 1784 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1786 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1788 */	
			0x13, 0x0,	/* FC_OP */
/* 1790 */	NdrFcShort( 0xffffff46 ),	/* Offset= -186 (1604) */
/* 1792 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1794 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1798 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1804) */
/* 1800 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1802 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1804 */	
			0x13, 0x0,	/* FC_OP */
/* 1806 */	NdrFcShort( 0xffffff36 ),	/* Offset= -202 (1604) */
/* 1808 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1810 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1814 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1820) */
/* 1816 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1818 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1820 */	
			0x13, 0x0,	/* FC_OP */
/* 1822 */	NdrFcShort( 0xffffff42 ),	/* Offset= -190 (1632) */
/* 1824 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1826 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1830 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1836) */
/* 1832 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1834 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1836 */	
			0x13, 0x0,	/* FC_OP */
/* 1838 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (1632) */
/* 1840 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1842 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1844 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1846 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1848 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1850 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1852 */	NdrFcShort( 0xfffffb32 ),	/* Offset= -1230 (622) */
/* 1854 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1856 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1858 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1862 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1868) */
/* 1864 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1866 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1868 */	
			0x13, 0x0,	/* FC_OP */
/* 1870 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1840) */
/* 1872 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1874 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1876 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1878 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1884) */
/* 1880 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1882 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1884 */	
			0x13, 0x0,	/* FC_OP */
/* 1886 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1840) */
/* 1888 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1890 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1892 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1894 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1896 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1898 */	0xa,		/* FC_FLOAT */
			0x5b,		/* FC_END */
/* 1900 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1902 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1904 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1906 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1912) */
/* 1908 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1910 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1912 */	
			0x13, 0x0,	/* FC_OP */
/* 1914 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1888) */
/* 1916 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1918 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1920 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1922 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1924 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1926 */	0xc,		/* FC_DOUBLE */
			0x5b,		/* FC_END */
/* 1928 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1930 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1934 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1940) */
/* 1936 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1938 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1940 */	
			0x13, 0x0,	/* FC_OP */
/* 1942 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1916) */
/* 1944 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1946 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1948 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1950 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1956) */
/* 1952 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1954 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1956 */	
			0x13, 0x0,	/* FC_OP */
/* 1958 */	NdrFcShort( 0xfffffe9e ),	/* Offset= -354 (1604) */
/* 1960 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1962 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1966 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1972) */
/* 1968 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1970 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1972 */	
			0x13, 0x0,	/* FC_OP */
/* 1974 */	NdrFcShort( 0xfffffeaa ),	/* Offset= -342 (1632) */
/* 1976 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1978 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1980 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1982 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1988) */
/* 1984 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1986 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1988 */	
			0x13, 0x0,	/* FC_OP */
/* 1990 */	NdrFcShort( 0xffffff6a ),	/* Offset= -150 (1840) */
/* 1992 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1994 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1998 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2004) */
/* 2000 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2002 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2004 */	
			0x13, 0x0,	/* FC_OP */
/* 2006 */	NdrFcShort( 0xffffffa6 ),	/* Offset= -90 (1916) */
/* 2008 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2010 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2012 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2016 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2018 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2020 */	NdrFcShort( 0xfffffa90 ),	/* Offset= -1392 (628) */
/* 2022 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2024 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2026 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2028 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2030 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2036) */
/* 2032 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2034 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2036 */	
			0x13, 0x0,	/* FC_OP */
/* 2038 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (2008) */
/* 2040 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2042 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2044 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2046 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2048 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2050 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2052 */	NdrFcShort( 0xfffffa82 ),	/* Offset= -1406 (646) */
/* 2054 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2056 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2058 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2062 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2068) */
/* 2064 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2066 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2068 */	
			0x13, 0x0,	/* FC_OP */
/* 2070 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (2040) */
/* 2072 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2074 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2076 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2078 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2080 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2082 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2086 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2088 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2090 */	NdrFcShort( 0xfffffa78 ),	/* Offset= -1416 (674) */
/* 2092 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2094 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2096 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2100 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2106) */
/* 2102 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2104 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2106 */	
			0x13, 0x0,	/* FC_OP */
/* 2108 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2072) */
/* 2110 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2114 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2118 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2120 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2124 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2126 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2128 */	NdrFcShort( 0xfffffa7c ),	/* Offset= -1412 (716) */
/* 2130 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2132 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2134 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2138 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2144) */
/* 2140 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2142 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2144 */	
			0x13, 0x0,	/* FC_OP */
/* 2146 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2110) */
/* 2148 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2152 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2156 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2158 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2162 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2164 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2166 */	NdrFcShort( 0xfffffa6c ),	/* Offset= -1428 (738) */
/* 2168 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2170 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2172 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2176 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2182) */
/* 2178 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2180 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2182 */	
			0x13, 0x0,	/* FC_OP */
/* 2184 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2148) */
/* 2186 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2190 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2194 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2196 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2200 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2202 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2204 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 2206 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2208 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2210 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2214 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2220) */
/* 2216 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2218 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2220 */	
			0x13, 0x0,	/* FC_OP */
/* 2222 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2186) */
/* 2224 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2228 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2232 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2234 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2238 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2240 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2242 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2244 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2246 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2248 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2252 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2258) */
/* 2254 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2256 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2258 */	
			0x13, 0x0,	/* FC_OP */
/* 2260 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2224) */
/* 2262 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2264 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2266 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2268 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2270 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2272 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2276 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2278 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2280 */	NdrFcShort( 0x20 ),	/* Offset= 32 (2312) */
/* 2282 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2284 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2286 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2288 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2290 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2296) */
/* 2292 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2294 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2296 */	
			0x13, 0x0,	/* FC_OP */
/* 2298 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2262) */
/* 2300 */	
			0x13, 0x0,	/* FC_OP */
/* 2302 */	NdrFcShort( 0xfffff9ce ),	/* Offset= -1586 (716) */
/* 2304 */	
			0x13, 0x0,	/* FC_OP */
/* 2306 */	NdrFcShort( 0xfffffdb8 ),	/* Offset= -584 (1722) */
/* 2308 */	
			0x13, 0x0,	/* FC_OP */
/* 2310 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2312) */
/* 2312 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2314 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2316 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2318 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2318) */
/* 2320 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 2322 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 2324 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2326 */	NdrFcShort( 0xfffff702 ),	/* Offset= -2302 (24) */
/* 2328 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2330 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2334 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2336 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2338 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2340 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2344 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2346 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2348 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2312) */
/* 2350 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2352 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2354 */	NdrFcLong( 0x3127ca40 ),	/* 824691264 */
/* 2358 */	NdrFcShort( 0x446e ),	/* 17518 */
/* 2360 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 2362 */	0x81,		/* 129 */
			0x35,		/* 53 */
/* 2364 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 2366 */	0x0,		/* 0 */
			0x4b,		/* 75 */
/* 2368 */	0xb8,		/* 184 */
			0x51,		/* 81 */
/* 2370 */	0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 2372 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2374 */	
			0x11, 0x0,	/* FC_RP */
/* 2376 */	NdrFcShort( 0xfffff93e ),	/* Offset= -1730 (646) */
/* 2378 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2380 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2382) */
/* 2382 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 2384 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 2386 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2388 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 2390 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2392 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2394) */
/* 2394 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2396 */	NdrFcLong( 0x20021801 ),	/* 537008129 */
/* 2400 */	NdrFcShort( 0x5de6 ),	/* 24038 */
/* 2402 */	NdrFcShort( 0x11d1 ),	/* 4561 */
/* 2404 */	0x8e,		/* 142 */
			0x38,		/* 56 */
/* 2406 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 2408 */	0x4f,		/* 79 */
			0xb9,		/* 185 */
/* 2410 */	0x38,		/* 56 */
			0x6d,		/* 109 */
/* 2412 */	
			0x11, 0x0,	/* FC_RP */
/* 2414 */	NdrFcShort( 0x18 ),	/* Offset= 24 (2438) */
/* 2416 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2418 */	NdrFcShort( 0x20 ),	/* 32 */
/* 2420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2422 */	NdrFcShort( 0xc ),	/* Offset= 12 (2434) */
/* 2424 */	0x36,		/* FC_POINTER */
			0x6,		/* FC_SHORT */
/* 2426 */	0x3e,		/* FC_STRUCTPAD2 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2428 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff909 ),	/* Offset= -1783 (646) */
			0x40,		/* FC_STRUCTPAD4 */
/* 2432 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2434 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 2436 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2438 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2442 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2444 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2446 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2448 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 2450 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2452 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2454 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2456 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (2416) */
/* 2458 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2460 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2462 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            }

        };


static void __RPC_USER IPropertyBagEx_PROPVARIANTExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    PROPVARIANT *pS	=	( PROPVARIANT * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( unsigned short  )pS->vt );
}

static void __RPC_USER IPropertyBagEx_CLIPDATAExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    CLIPDATA *pS	=	( CLIPDATA * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->cbSize - 4 );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    IPropertyBagEx_PROPVARIANTExprEval_0000
    ,IPropertyBagEx_CLIPDATAExprEval_0001
    };



/* Standard interface: __MIDL_itf_pbagex_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IPropertyBagEx, ver. 0.0,
   GUID={0x20011801,0x5DE6,0x11D1,{0x8E,0x38,0x00,0xC0,0x4F,0xB9,0x38,0x6D}} */

#pragma code_seg(".orpc")
static const unsigned short IPropertyBagEx_FormatStringOffsetTable[] =
    {
    0,
    56,
    106,
    156,
    224
    };

static const MIDL_STUBLESS_PROXY_INFO IPropertyBagEx_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IPropertyBagEx_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IPropertyBagEx_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IPropertyBagEx_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IPropertyBagExProxyVtbl = 
{
    &IPropertyBagEx_ProxyInfo,
    &IID_IPropertyBagEx,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::ReadMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::WriteMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::DeleteMultiple */ ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::Open */ ,
    (void *) (INT_PTR) -1 /* IPropertyBagEx::Enum */
};

const CInterfaceStubVtbl _IPropertyBagExStubVtbl =
{
    &IID_IPropertyBagEx,
    &IPropertyBagEx_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumSTATPROPBAG, ver. 0.0,
   GUID={0x20021801,0x5DE6,0x11D1,{0x8E,0x38,0x00,0xC0,0x4F,0xB9,0x38,0x6D}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumSTATPROPBAG_FormatStringOffsetTable[] =
    {
    274,
    324,
    362,
    394
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumSTATPROPBAG_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPBAG_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumSTATPROPBAG_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumSTATPROPBAG_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IEnumSTATPROPBAGProxyVtbl = 
{
    &IEnumSTATPROPBAG_ProxyInfo,
    &IID_IEnumSTATPROPBAG,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPBAG::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPBAG::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPBAG::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumSTATPROPBAG::Clone */
};

const CInterfaceStubVtbl _IEnumSTATPROPBAGStubVtbl =
{
    &IID_IEnumSTATPROPBAG,
    &IEnumSTATPROPBAG_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_pbagex_0112, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _pbagex_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IPropertyBagExProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumSTATPROPBAGProxyVtbl,
    0
};

const CInterfaceStubVtbl * _pbagex_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IPropertyBagExStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumSTATPROPBAGStubVtbl,
    0
};

PCInterfaceName const _pbagex_InterfaceNamesList[] = 
{
    "IPropertyBagEx",
    "IEnumSTATPROPBAG",
    0
};


#define _pbagex_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _pbagex, pIID, n)

int __stdcall _pbagex_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _pbagex, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _pbagex, 2, *pIndex )
    
}

const ExtendedProxyFileInfo pbagex_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _pbagex_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _pbagex_StubVtblList,
    (const PCInterfaceName * ) & _pbagex_InterfaceNamesList,
    0, // no delegation
    & _pbagex_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\cguid.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       cguid_i.c
//
//  Contents:   Defines guids for interfaces not supported by MIDL.
//              This file is named so the this file will be include into UUID.LIB
//              As these interfaces are converted to IDL, the corresponding DEFINE_OLEGUID
//              macro calls for  the interfaces should be removed.
//
//  History:    8-06-93   terryru   Created
//
//----------------------------------------------------------------------------




#define INITGUID

#include <guiddef.h>

//
// BUGBUG what about class id's


DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);


/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,                 0x00000004, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,                    0x00000005, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,                0x00000006, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,                   0x00000007, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,               0x00000008, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,                  0x00000009, 0, 0);


/* moniker related interfaces */

DEFINE_OLEGUID(IID_IInternalMoniker,            0x00000011, 0, 0);

DEFINE_OLEGUID(IID_IDfReserved1,                0x00000013, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,                0x00000014, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,                0x00000015, 0, 0);


/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,                0x00000017, 0, 0);

DEFINE_OLEGUID(IID_IStub,                       0x00000026, 0, 0);
DEFINE_OLEGUID(IID_IProxy,                      0x00000027, 0, 0);

/* NOTE: LSB 0x2E through 0xff are reserved for future use */


//--------------------------------------------------------------------------
//
//  master definition of all public GUIDs specific to OLE2
//
//--------------------------------------------------------------------------


DEFINE_OLEGUID(IID_IEnumGeneric,                0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,                 0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,               0x00000108, 0, 0);





DEFINE_OLEGUID(IID_IOleManager,                 0x0000011f, 0, 0);
DEFINE_OLEGUID(IID_IOlePresObj,                 0x00000120, 0, 0);


DEFINE_OLEGUID(IID_IDebug,                      0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,                0x00000124, 0, 0);


// clsids for proxy/stub objects
DEFINE_OLEGUID(CLSID_PSGenObject,               0x0000030c, 0, 0);
DEFINE_OLEGUID(CLSID_PSClientSite,              0x0000030d, 0, 0);
DEFINE_OLEGUID(CLSID_PSClassObject,             0x0000030e, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceActive,           0x0000030f, 0, 0);
DEFINE_OLEGUID(CLSID_PSInPlaceFrame,            0x00000310, 0, 0);
DEFINE_OLEGUID(CLSID_PSDragDrop,                0x00000311, 0, 0);
DEFINE_OLEGUID(CLSID_PSBindCtx,                 0x00000312, 0, 0);
DEFINE_OLEGUID(CLSID_PSEnumerators,             0x00000313, 0, 0);

DEFINE_OLEGUID(CLSID_StaticMetafile,            0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_StaticDib,                 0x00000316, 0, 0);


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_Picture_Metafile,          0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_EnhMetafile,       0x00000319, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_Dib,               0x00000316, 0, 0);
DEFINE_OLEGUID(CLSID_DCOMAccessControl,         0x0000031D, 0, 0);
DEFINE_OLEGUID(CLSID_StdGlobalInterfaceTable,   0x00000323, 0, 0);


// Class ids for various implementations of ISynchronize
DEFINE_OLEGUID(CLSID_ManualResetEvent,             0x0000032c, 0, 0);
DEFINE_OLEGUID(CLSID_StdEvent,                     0x0000032b, 0, 0);
DEFINE_OLEGUID(CLSID_SynchronizeContainer,         0x0000032d, 0, 0);


// OBJREF Moniker                                  0x00000327
// Class id for string binding wrapper object
DEFINE_OLEGUID(CLSID_ComBinding,                0x00000328, 0, 0);
// Class id for obtaining an implementation of IAsyncManager
DEFINE_OLEGUID(CLSID_StdAsyncActManager,           0x00000329L, 0, 0);

/* clsid for free threaded marshaler */
DEFINE_OLEGUID(CLSID_InProcFreeMarshaler,       0x00000033a, 0, 0);
DEFINE_OLEGUID(CLSID_RemoteUnknownPSFactory,       0x00000340, 0, 0);


//
//  Define Richedit GUIDs
//
DEFINE_OLEGUID(IID_IRichEditOle,                0x00020D00, 0, 0);
DEFINE_OLEGUID(IID_IRichEditOleCallback,        0x00020D03, 0, 0);

//
//  Define Class Repository CLSIDs
//

DEFINE_OLEGUID(CLSID_AllClasses,                0x00000330, 0, 0);
DEFINE_OLEGUID(CLSID_LocalMachineClasses,       0x00000331, 0, 0);
DEFINE_OLEGUID(CLSID_CurrentUserClasses,        0x00000332, 0, 0);


//
// define ole controls clsids
//
//

DEFINE_GUID(IID_IPropertyFrame,
        0xB196B28A,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);

//  Class IDs for property sheet implementations
//

DEFINE_GUID(CLSID_CFontPropPage,
        0x0be35200,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);
DEFINE_GUID(CLSID_CColorPropPage,
        0x0be35201,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);
DEFINE_GUID(CLSID_CPicturePropPage,
        0x0be35202,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);

//
// class IDs for msprop32's property pages.
//

#include <msstkppg.h>

//
//  Class IDs for persistent property set formats
//

DEFINE_GUID(CLSID_PersistPropset,
        0xfb8f0821,0x0164,0x101b,0x84,0xed,0x08,0x00,0x2b,0x2e,0xc7,0x13);
DEFINE_GUID(CLSID_ConvertVBX,
        0xfb8f0822,0x0164,0x101b,0x84,0xed,0x08,0x00,0x2b,0x2e,0xc7,0x13);

//
//  Class ID for standard implementations of IFont and IPicture

DEFINE_GUID(CLSID_StdFont,
        0x0be35203,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);
DEFINE_GUID(CLSID_StdPicture,
        0x0be35204,0x8f91,0x11ce,0x9d,0xe3,0x00,0xaa,0x00,0x4b,0xb8,0x51);


//
//  GUIDs for standard types
//

DEFINE_GUID(GUID_HIMETRIC,
        0x66504300,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_COLOR,
        0x66504301,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XPOSPIXEL,
        0x66504302,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YPOSPIXEL,
        0x66504303,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XSIZEPIXEL,
        0x66504304,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YSIZEPIXEL,
        0x66504305,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XPOS,
        0x66504306,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YPOS,
        0x66504307,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_XSIZE,
        0x66504308,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_YSIZE,
        0x66504309,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_TRISTATE,
        0x6650430A,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_OPTIONVALUEEXCLUSIVE,
        0x6650430B,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_CHECKVALUEEXCLUSIVE,
        0x6650430C,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTNAME,
        0x6650430D,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTSIZE,
        0x6650430E,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTBOLD,
        0x6650430F,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTITALIC,
        0x66504310,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTUNDERSCORE,
        0x66504311,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_FONTSTRIKETHROUGH,
        0x66504312,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);
DEFINE_GUID(GUID_HANDLE,
        0x66504313,0xBE0F,0x101A,0x8B,0xBB,0x00,0xAA,0x00,0x30,0x0C,0xAB);

//
//  GUIDs for OLE Automation
//
DEFINE_OLEGUID(IID_StdOle,  0x00020430L, 0, 0);

// Ole Control Data Binding guids

DEFINE_GUID(IID_ICursor,
    0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorMove,
    0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorScroll,
    0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorUpdateARow,
    0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_INotifyDBEvents,
    0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_ICursorFind,
    0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_IEntryID,
    0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(_GUID_NAMEONLY,
    0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(_DBBMKGUID,
    0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(_DBCIDGUID,
    0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

// OLE Data binding

DEFINE_GUID(IID_IBoundObject,
    0x9BFBBC00, 0xEFF1, 0x101A, 0x84, 0xED, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07);

DEFINE_GUID(IID_IBoundObjectSite,
    0x9BFBBC01, 0xEFF1, 0x101A, 0x84, 0xED, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07);

// Global Comcat clsid (with Class Store)
DEFINE_OLEGUID(CLSID_GblComponentCategoriesMgr, 0x0002E006, 0, 0);


//
// A GUID for the thumbnail generator
//
DEFINE_GUID(CLSID_ThumbnailFCNHandler,
    0xcefc65d8, 0x66d8, 0x11d1, 0x8d, 0x8c, 0x00, 0x00, 0xf8, 0x04, 0xb0, 0x57);

DEFINE_GUID(CLSID_ThumbnailUpdater,
    0xa3c63918, 0x889d, 0x11d1, 0x83, 0xe9, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0xd4);

#include <devguid.h>

#define _WINIOCTL_
#include <winioctl.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\idl\obj\unknwn_d.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( unknwn )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( unknwn ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\ctxtcall.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:38 2002
 */
/* Compiler settings for ctxtcall.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IContextCallback,0x000001da,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:38 2002
 */
/* Compiler settings for ctxtcall.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IContextCallback,0x000001da,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\oaidl.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:35 2002
 */
/* Compiler settings for oaidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICreateTypeInfo,0x00020405,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICreateTypeInfo2,0x0002040E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICreateTypeLib,0x00020406,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICreateTypeLib2,0x0002040F,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDispatch,0x00020400,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumVARIANT,0x00020404,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeComp,0x00020403,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeInfo,0x00020401,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeInfo2,0x00020412,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeLib,0x00020402,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeLib2,0x00020411,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeChangeEvents,0x00020410,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IErrorInfo,0x1CF2B120,0x547D,0x101B,0x8E,0x65,0x08,0x00,0x2B,0x2B,0xD1,0x19);


MIDL_DEFINE_GUID(IID, IID_ICreateErrorInfo,0x22F03340,0x547D,0x101B,0x8E,0x65,0x08,0x00,0x2B,0x2B,0xD1,0x19);


MIDL_DEFINE_GUID(IID, IID_ISupportErrorInfo,0xDF0B3D60,0x548F,0x101B,0x8E,0x65,0x08,0x00,0x2B,0x2B,0xD1,0x19);


MIDL_DEFINE_GUID(IID, IID_ITypeFactory,0x0000002E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeMarshal,0x0000002D,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRecordInfo,0x0000002F,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IErrorLog,0x3127CA40,0x446E,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);


MIDL_DEFINE_GUID(IID, IID_IPropertyBag,0x55272A00,0x42CB,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:35 2002
 */
/* Compiler settings for oaidl.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICreateTypeInfo,0x00020405,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICreateTypeInfo2,0x0002040E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICreateTypeLib,0x00020406,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICreateTypeLib2,0x0002040F,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDispatch,0x00020400,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumVARIANT,0x00020404,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeComp,0x00020403,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeInfo,0x00020401,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeInfo2,0x00020412,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeLib,0x00020402,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeLib2,0x00020411,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeChangeEvents,0x00020410,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IErrorInfo,0x1CF2B120,0x547D,0x101B,0x8E,0x65,0x08,0x00,0x2B,0x2B,0xD1,0x19);


MIDL_DEFINE_GUID(IID, IID_ICreateErrorInfo,0x22F03340,0x547D,0x101B,0x8E,0x65,0x08,0x00,0x2B,0x2B,0xD1,0x19);


MIDL_DEFINE_GUID(IID, IID_ISupportErrorInfo,0xDF0B3D60,0x548F,0x101B,0x8E,0x65,0x08,0x00,0x2B,0x2B,0xD1,0x19);


MIDL_DEFINE_GUID(IID, IID_ITypeFactory,0x0000002E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ITypeMarshal,0x0000002D,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRecordInfo,0x0000002F,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IErrorLog,0x3127CA40,0x446E,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);


MIDL_DEFINE_GUID(IID, IID_IPropertyBag,0x55272A00,0x42CB,0x11CE,0x81,0x35,0x00,0xAA,0x00,0x4B,0xB8,0x51);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\idl\obj\storext_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:37 2002
 */
/* Compiler settings for storext.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "storext.h"

#define TYPE_FORMAT_STRING_SIZE   79                                
#define PROC_FORMAT_STRING_SIZE   205                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IOverlappedCompletion_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IOverlappedCompletion_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IOverlappedStream_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IOverlappedStream_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IOverlappedStream_RemoteReadOverlapped_Proxy( 
    IOverlappedStream * This,
    /* [size_is][in] */ byte *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG *pcbRead,
    /* [in] */ STGOVERLAPPED *lpOverlapped)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[48],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IOverlappedStream_RemoteReadOverlapped_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IOverlappedStream *This;
        byte *pv;
        ULONG cb;
        ULONG *pcbRead;
        STGOVERLAPPED *lpOverlapped;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IOverlappedStream_ReadOverlapped_Stub(
                                                (IOverlappedStream *) pParamStruct->This,
                                                pParamStruct->pv,
                                                pParamStruct->cb,
                                                pParamStruct->pcbRead,
                                                pParamStruct->lpOverlapped);
    
}

/* [call_as] */ HRESULT __stdcall IOverlappedStream_RemoteWriteOverlapped_Proxy( 
    IOverlappedStream * This,
    /* [size_is][in] */ byte *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG *pcbWritten,
    /* [in] */ STGOVERLAPPED *lpOverlapped)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[102],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IOverlappedStream_RemoteWriteOverlapped_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IOverlappedStream *This;
        byte *pv;
        ULONG cb;
        ULONG *pcbWritten;
        STGOVERLAPPED *lpOverlapped;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IOverlappedStream_WriteOverlapped_Stub(
                                                 (IOverlappedStream *) pParamStruct->This,
                                                 pParamStruct->pv,
                                                 pParamStruct->cb,
                                                 pParamStruct->pcbWritten,
                                                 pParamStruct->lpOverlapped);
    
}


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure OnComplete */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hr */

/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbTransferred */

/* 30 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lpOverlapped */

/* 36 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 40 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */

	/* Return value */

/* 42 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 46 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteReadOverlapped */

/* 48 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 50 */	NdrFcLong( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0xe ),	/* 14 */
/* 56 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 58 */	NdrFcShort( 0x8 ),	/* 8 */
/* 60 */	NdrFcShort( 0x24 ),	/* 36 */
/* 62 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 64 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x1 ),	/* 1 */
/* 70 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pv */

/* 72 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 74 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 76 */	NdrFcShort( 0x3e ),	/* Type Offset=62 */

	/* Parameter cb */

/* 78 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 80 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbRead */

/* 84 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 86 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 88 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lpOverlapped */

/* 90 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 92 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 94 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */

	/* Return value */

/* 96 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 98 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteWriteOverlapped */

/* 102 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 108 */	NdrFcShort( 0xf ),	/* 15 */
/* 110 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 112 */	NdrFcShort( 0x8 ),	/* 8 */
/* 114 */	NdrFcShort( 0x24 ),	/* 36 */
/* 116 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 118 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x1 ),	/* 1 */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pv */

/* 126 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 128 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 130 */	NdrFcShort( 0x3e ),	/* Type Offset=62 */

	/* Parameter cb */

/* 132 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 134 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbWritten */

/* 138 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 140 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lpOverlapped */

/* 144 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 146 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 148 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */

	/* Return value */

/* 150 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 152 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOverlappedResult */

/* 156 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 158 */	NdrFcLong( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0x10 ),	/* 16 */
/* 164 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 166 */	NdrFcShort( 0x8 ),	/* 8 */
/* 168 */	NdrFcShort( 0x24 ),	/* 36 */
/* 170 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 172 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 178 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lpOverlapped */

/* 180 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 182 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 184 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */

	/* Parameter plcbTransfer */

/* 186 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 188 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 190 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fWait */

/* 192 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 194 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 198 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 200 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 202 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x20 ),	/* Offset= 32 (36) */
/*  6 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/*  8 */	0xb4,		/* FC_USER_MARSHAL */
			0x3,		/* 3 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x4 ),	/* 4 */
/* 14 */	NdrFcShort( 0x4 ),	/* 4 */
/* 16 */	NdrFcShort( 0xfffffff6 ),	/* Offset= -10 (6) */
/* 18 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 20 */	NdrFcLong( 0x521a28f0 ),	/* 1377446128 */
/* 24 */	NdrFcShort( 0xe40b ),	/* -7157 */
/* 26 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 28 */	0xb2,		/* 178 */
			0xc9,		/* 201 */
/* 30 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 32 */	0x0,		/* 0 */
			0x68,		/* 104 */
/* 34 */	0x9,		/* 9 */
			0x37,		/* 55 */
/* 36 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 38 */	NdrFcShort( 0x1c ),	/* 28 */
/* 40 */	NdrFcShort( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x10 ),	/* Offset= 16 (58) */
/* 44 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 46 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 48 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 50 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (8) */
/* 52 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 54 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (18) */
/* 56 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 58 */	
			0x11, 0x0,	/* FC_RP */
/* 60 */	NdrFcShort( 0x2 ),	/* Offset= 2 (62) */
/* 62 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 64 */	NdrFcShort( 0x1 ),	/* 1 */
/* 66 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 70 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 72 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 74 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 76 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            HEVENT_UserSize
            ,HEVENT_UserMarshal
            ,HEVENT_UserUnmarshal
            ,HEVENT_UserFree
            }

        };



/* Standard interface: __MIDL_itf_storext_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IOverlappedCompletion, ver. 0.0,
   GUID={0x521a28f0,0xe40b,0x11ce,{0xb2,0xc9,0x00,0xaa,0x00,0x68,0x09,0x37}} */

#pragma code_seg(".orpc")
static const unsigned short IOverlappedCompletion_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IOverlappedCompletion_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IOverlappedCompletion_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IOverlappedCompletion_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IOverlappedCompletion_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IOverlappedCompletionProxyVtbl = 
{
    &IOverlappedCompletion_ProxyInfo,
    &IID_IOverlappedCompletion,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IOverlappedCompletion::OnComplete */
};

const CInterfaceStubVtbl _IOverlappedCompletionStubVtbl =
{
    &IID_IOverlappedCompletion,
    &IOverlappedCompletion_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISequentialStream, ver. 0.0,
   GUID={0x0c733a30,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IStream, ver. 0.0,
   GUID={0x0000000c,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IOverlappedStream, ver. 0.0,
   GUID={0x49384070,0xe40a,0x11ce,{0xb2,0xc9,0x00,0xaa,0x00,0x68,0x09,0x37}} */

#pragma code_seg(".orpc")
static const unsigned short IOverlappedStream_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    48,
    102,
    156
    };

static const MIDL_STUBLESS_PROXY_INFO IOverlappedStream_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IOverlappedStream_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IOverlappedStream_StubThunkTable[] = 
    {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    IOverlappedStream_RemoteReadOverlapped_Thunk,
    IOverlappedStream_RemoteWriteOverlapped_Thunk,
    0
    };

static const MIDL_SERVER_INFO IOverlappedStream_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IOverlappedStream_FormatStringOffsetTable[-3],
    &IOverlappedStream_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(17) _IOverlappedStreamProxyVtbl = 
{
    &IOverlappedStream_ProxyInfo,
    &IID_IOverlappedStream,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* ISequentialStream_Read_Proxy */ ,
    0 /* ISequentialStream_Write_Proxy */ ,
    0 /* IStream_Seek_Proxy */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::SetSize */ ,
    0 /* IStream_CopyTo_Proxy */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::Commit */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::Revert */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::LockRegion */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::UnlockRegion */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::Stat */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::Clone */ ,
    IOverlappedStream_ReadOverlapped_Proxy ,
    IOverlappedStream_WriteOverlapped_Proxy ,
    (void *) (INT_PTR) -1 /* IOverlappedStream::GetOverlappedResult */
};


static const PRPC_STUB_FUNCTION IOverlappedStream_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IOverlappedStreamStubVtbl =
{
    &IID_IOverlappedStream,
    &IOverlappedStream_ServerInfo,
    17,
    &IOverlappedStream_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _storext_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IOverlappedStreamProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IOverlappedCompletionProxyVtbl,
    0
};

const CInterfaceStubVtbl * _storext_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IOverlappedStreamStubVtbl,
    ( CInterfaceStubVtbl *) &_IOverlappedCompletionStubVtbl,
    0
};

PCInterfaceName const _storext_InterfaceNamesList[] = 
{
    "IOverlappedStream",
    "IOverlappedCompletion",
    0
};

const IID *  _storext_BaseIIDList[] = 
{
    &IID_IStream,
    0,
    0
};


#define _storext_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _storext, pIID, n)

int __stdcall _storext_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _storext, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _storext, 2, *pIndex )
    
}

const ExtendedProxyFileInfo storext_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _storext_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _storext_StubVtblList,
    (const PCInterfaceName * ) & _storext_InterfaceNamesList,
    (const IID ** ) & _storext_BaseIIDList,
    & _storext_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:37 2002
 */
/* Compiler settings for storext.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "storext.h"

#define TYPE_FORMAT_STRING_SIZE   81                                
#define PROC_FORMAT_STRING_SIZE   213                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IOverlappedCompletion_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IOverlappedCompletion_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IOverlappedStream_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IOverlappedStream_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IOverlappedStream_RemoteReadOverlapped_Proxy( 
    IOverlappedStream * This,
    /* [size_is][in] */ byte *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG *pcbRead,
    /* [in] */ STGOVERLAPPED *lpOverlapped)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[50],
                  ( unsigned char * )This,
                  pv,
                  cb,
                  pcbRead,
                  lpOverlapped);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IOverlappedStream_RemoteReadOverlapped_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IOverlappedStream *This;
        byte *pv;
        ULONG cb;
        char Pad0[4];
        ULONG *pcbRead;
        STGOVERLAPPED *lpOverlapped;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IOverlappedStream_ReadOverlapped_Stub(
                                                (IOverlappedStream *) pParamStruct->This,
                                                pParamStruct->pv,
                                                pParamStruct->cb,
                                                pParamStruct->pcbRead,
                                                pParamStruct->lpOverlapped);
    
}

/* [call_as] */ HRESULT __stdcall IOverlappedStream_RemoteWriteOverlapped_Proxy( 
    IOverlappedStream * This,
    /* [size_is][in] */ byte *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG *pcbWritten,
    /* [in] */ STGOVERLAPPED *lpOverlapped)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[106],
                  ( unsigned char * )This,
                  pv,
                  cb,
                  pcbWritten,
                  lpOverlapped);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IOverlappedStream_RemoteWriteOverlapped_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IOverlappedStream *This;
        byte *pv;
        ULONG cb;
        char Pad0[4];
        ULONG *pcbWritten;
        STGOVERLAPPED *lpOverlapped;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IOverlappedStream_WriteOverlapped_Stub(
                                                 (IOverlappedStream *) pParamStruct->This,
                                                 pParamStruct->pv,
                                                 pParamStruct->cb,
                                                 pParamStruct->pcbWritten,
                                                 pParamStruct->lpOverlapped);
    
}


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure OnComplete */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hr */

/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbTransferred */

/* 32 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lpOverlapped */

/* 38 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */

	/* Return value */

/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 46 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteReadOverlapped */

/* 50 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0xe ),	/* 14 */
/* 58 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 60 */	NdrFcShort( 0x8 ),	/* 8 */
/* 62 */	NdrFcShort( 0x24 ),	/* 36 */
/* 64 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 66 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
/* 70 */	NdrFcShort( 0x1 ),	/* 1 */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pv */

/* 76 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 78 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 80 */	NdrFcShort( 0x40 ),	/* Type Offset=64 */

	/* Parameter cb */

/* 82 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 84 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 86 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbRead */

/* 88 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 90 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lpOverlapped */

/* 94 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 96 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 98 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */

	/* Return value */

/* 100 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 102 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteWriteOverlapped */

/* 106 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0xf ),	/* 15 */
/* 114 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 118 */	NdrFcShort( 0x24 ),	/* 36 */
/* 120 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 122 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 126 */	NdrFcShort( 0x1 ),	/* 1 */
/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 130 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pv */

/* 132 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 134 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 136 */	NdrFcShort( 0x40 ),	/* Type Offset=64 */

	/* Parameter cb */

/* 138 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 140 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcbWritten */

/* 144 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 146 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lpOverlapped */

/* 150 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 152 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 154 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */

	/* Return value */

/* 156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 158 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOverlappedResult */

/* 162 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 164 */	NdrFcLong( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x10 ),	/* 16 */
/* 170 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 174 */	NdrFcShort( 0x24 ),	/* 36 */
/* 176 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 178 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 180 */	NdrFcShort( 0x0 ),	/* 0 */
/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lpOverlapped */

/* 188 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 190 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 192 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */

	/* Parameter plcbTransfer */

/* 194 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 196 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fWait */

/* 200 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 202 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 204 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 206 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 208 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x20 ),	/* Offset= 32 (36) */
/*  6 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/*  8 */	0xb4,		/* FC_USER_MARSHAL */
			0x3,		/* 3 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	NdrFcShort( 0x4 ),	/* 4 */
/* 16 */	NdrFcShort( 0xfffffff6 ),	/* Offset= -10 (6) */
/* 18 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 20 */	NdrFcLong( 0x521a28f0 ),	/* 1377446128 */
/* 24 */	NdrFcShort( 0xe40b ),	/* -7157 */
/* 26 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 28 */	0xb2,		/* 178 */
			0xc9,		/* 201 */
/* 30 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 32 */	0x0,		/* 0 */
			0x68,		/* 104 */
/* 34 */	0x9,		/* 9 */
			0x37,		/* 55 */
/* 36 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 38 */	NdrFcShort( 0x28 ),	/* 40 */
/* 40 */	NdrFcShort( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x12 ),	/* Offset= 18 (60) */
/* 44 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 46 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 48 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 50 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (8) */
/* 52 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 54 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (18) */
/* 56 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 58 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 60 */	
			0x11, 0x0,	/* FC_RP */
/* 62 */	NdrFcShort( 0x2 ),	/* Offset= 2 (64) */
/* 64 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 66 */	NdrFcShort( 0x1 ),	/* 1 */
/* 68 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 70 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 72 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 74 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 76 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 78 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            HEVENT_UserSize
            ,HEVENT_UserMarshal
            ,HEVENT_UserUnmarshal
            ,HEVENT_UserFree
            }

        };



/* Standard interface: __MIDL_itf_storext_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IOverlappedCompletion, ver. 0.0,
   GUID={0x521a28f0,0xe40b,0x11ce,{0xb2,0xc9,0x00,0xaa,0x00,0x68,0x09,0x37}} */

#pragma code_seg(".orpc")
static const unsigned short IOverlappedCompletion_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IOverlappedCompletion_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IOverlappedCompletion_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IOverlappedCompletion_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IOverlappedCompletion_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IOverlappedCompletionProxyVtbl = 
{
    &IOverlappedCompletion_ProxyInfo,
    &IID_IOverlappedCompletion,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IOverlappedCompletion::OnComplete */
};

const CInterfaceStubVtbl _IOverlappedCompletionStubVtbl =
{
    &IID_IOverlappedCompletion,
    &IOverlappedCompletion_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISequentialStream, ver. 0.0,
   GUID={0x0c733a30,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IStream, ver. 0.0,
   GUID={0x0000000c,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IOverlappedStream, ver. 0.0,
   GUID={0x49384070,0xe40a,0x11ce,{0xb2,0xc9,0x00,0xaa,0x00,0x68,0x09,0x37}} */

#pragma code_seg(".orpc")
static const unsigned short IOverlappedStream_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    50,
    106,
    162
    };

static const MIDL_STUBLESS_PROXY_INFO IOverlappedStream_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IOverlappedStream_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IOverlappedStream_StubThunkTable[] = 
    {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    IOverlappedStream_RemoteReadOverlapped_Thunk,
    IOverlappedStream_RemoteWriteOverlapped_Thunk,
    0
    };

static const MIDL_SERVER_INFO IOverlappedStream_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IOverlappedStream_FormatStringOffsetTable[-3],
    &IOverlappedStream_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(17) _IOverlappedStreamProxyVtbl = 
{
    &IOverlappedStream_ProxyInfo,
    &IID_IOverlappedStream,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* ISequentialStream_Read_Proxy */ ,
    0 /* ISequentialStream_Write_Proxy */ ,
    0 /* IStream_Seek_Proxy */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::SetSize */ ,
    0 /* IStream_CopyTo_Proxy */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::Commit */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::Revert */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::LockRegion */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::UnlockRegion */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::Stat */ ,
    0 /* (void *) (INT_PTR) -1 /* IStream::Clone */ ,
    IOverlappedStream_ReadOverlapped_Proxy ,
    IOverlappedStream_WriteOverlapped_Proxy ,
    (void *) (INT_PTR) -1 /* IOverlappedStream::GetOverlappedResult */
};


static const PRPC_STUB_FUNCTION IOverlappedStream_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IOverlappedStreamStubVtbl =
{
    &IID_IOverlappedStream,
    &IOverlappedStream_ServerInfo,
    17,
    &IOverlappedStream_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _storext_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IOverlappedStreamProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IOverlappedCompletionProxyVtbl,
    0
};

const CInterfaceStubVtbl * _storext_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IOverlappedStreamStubVtbl,
    ( CInterfaceStubVtbl *) &_IOverlappedCompletionStubVtbl,
    0
};

PCInterfaceName const _storext_InterfaceNamesList[] = 
{
    "IOverlappedStream",
    "IOverlappedCompletion",
    0
};

const IID *  _storext_BaseIIDList[] = 
{
    &IID_IStream,
    0,
    0
};


#define _storext_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _storext, pIID, n)

int __stdcall _storext_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _storext, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _storext, 2, *pIndex )
    
}

const ExtendedProxyFileInfo storext_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _storext_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _storext_StubVtblList,
    (const PCInterfaceName * ) & _storext_InterfaceNamesList,
    (const IID ** ) & _storext_BaseIIDList,
    & _storext_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\objidl.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:27 2002
 */
/* Compiler settings for objidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMarshal,0x00000003,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMarshal2,0x000001cf,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMalloc,0x00000002,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMallocSpy,0x0000001d,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IStdMarshalInfo,0x00000018,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IExternalConnection,0x00000019,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMultiQI,0x00000020,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_AsyncIMultiQI,0x000e0020,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IInternalUnknown,0x00000021,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumUnknown,0x00000100,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IBindCtx,0x0000000e,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumMoniker,0x00000102,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRunnableObject,0x00000126,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRunningObjectTable,0x00000010,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPersist,0x0000010c,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPersistStream,0x00000109,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMoniker,0x0000000f,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IROTData,0xf29f6bc0,0x5021,0x11ce,0xaa,0x15,0x00,0x00,0x69,0x01,0x29,0x3f);


MIDL_DEFINE_GUID(IID, IID_IEnumString,0x00000101,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISequentialStream,0x0c733a30,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IStream,0x0000000c,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATSTG,0x0000000d,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IStorage,0x0000000b,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPersistFile,0x0000010b,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPersistStorage,0x0000010a,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ILockBytes,0x0000000a,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumFORMATETC,0x00000103,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATDATA,0x00000105,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRootStorage,0x00000012,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IAdviseSink,0x0000010f,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_AsyncIAdviseSink,0x00000150,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IAdviseSink2,0x00000125,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_AsyncIAdviseSink2,0x00000151,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDataObject,0x0000010e,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDataAdviseHolder,0x00000110,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMessageFilter,0x00000016,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRpcChannelBuffer,0xD5F56B60,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRpcChannelBuffer2,0x594f31d0,0x7f19,0x11d0,0xb1,0x94,0x00,0xa0,0xc9,0x0d,0xc8,0xbf);


MIDL_DEFINE_GUID(IID, IID_IAsyncRpcChannelBuffer,0xa5029fb6,0x3c34,0x11d1,0x9c,0x99,0x00,0xc0,0x4f,0xb9,0x98,0xaa);


MIDL_DEFINE_GUID(IID, IID_IRpcChannelBuffer3,0x25B15600,0x0115,0x11d0,0xBF,0x0D,0x00,0xAA,0x00,0xB8,0xDF,0xD2);


MIDL_DEFINE_GUID(IID, IID_IRpcProxyBuffer,0xD5F56A34,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRpcStubBuffer,0xD5F56AFC,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IPSFactoryBuffer,0xD5F569D0,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IChannelHook,0x1008c4a0,0x7613,0x11cf,0x9a,0xf1,0x00,0x20,0xaf,0x6e,0x72,0xf4);


MIDL_DEFINE_GUID(IID, IID_IClientSecurity,0x0000013D,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IServerSecurity,0x0000013E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IClassActivator,0x00000140,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRpcOptions,0x00000144,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IFillLockBytes,0x99caf010,0x415e,0x11cf,0x88,0x14,0x00,0xaa,0x00,0xb5,0x69,0xf5);


MIDL_DEFINE_GUID(IID, IID_IProgressNotify,0xa9d758a0,0x4617,0x11cf,0x95,0xfc,0x00,0xaa,0x00,0x68,0x0d,0xb4);


MIDL_DEFINE_GUID(IID, IID_ILayoutStorage,0x0e6d4d90,0x6738,0x11cf,0x96,0x08,0x00,0xaa,0x00,0x68,0x0d,0xb4);


MIDL_DEFINE_GUID(IID, IID_IBlockingLock,0x30f3d47a,0x6447,0x11d1,0x8e,0x3c,0x00,0xc0,0x4f,0xb9,0x38,0x6d);


MIDL_DEFINE_GUID(IID, IID_ITimeAndNoticeControl,0xbc0bf6ae,0x8878,0x11d1,0x83,0xe9,0x00,0xc0,0x4f,0xc2,0xc6,0xd4);


MIDL_DEFINE_GUID(IID, IID_IOplockStorage,0x8d19c834,0x8879,0x11d1,0x83,0xe9,0x00,0xc0,0x4f,0xc2,0xc6,0xd4);


MIDL_DEFINE_GUID(IID, IID_ISurrogate,0x00000022,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IGlobalInterfaceTable,0x00000146,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDirectWriterLock,0x0e6d4d92,0x6738,0x11cf,0x96,0x08,0x00,0xaa,0x00,0x68,0x0d,0xb4);


MIDL_DEFINE_GUID(IID, IID_ISynchronize,0x00000030,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISynchronizeHandle,0x00000031,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISynchronizeEvent,0x00000032,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISynchronizeContainer,0x00000033,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISynchronizeMutex,0x00000025,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICancelMethodCalls,0x00000029,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IAsyncManager,0x0000002A,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICallFactory,0x1c733a30,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRpcHelper,0x00000149,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IReleaseMarshalBuffers,0xeb0cb9e8,0x7996,0x11d2,0x87,0x2e,0x00,0x00,0xf8,0x08,0x08,0x59);


MIDL_DEFINE_GUID(IID, IID_IWaitMultiple,0x0000002B,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IUrlMon,0x00000026,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IForegroundTransfer,0x00000145,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPipeByte,0xDB2F3ACA,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_AsyncIPipeByte,0xDB2F3ACB,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_IPipeLong,0xDB2F3ACC,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_AsyncIPipeLong,0xDB2F3ACD,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_IPipeDouble,0xDB2F3ACE,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_AsyncIPipeDouble,0xDB2F3ACF,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_IThumbnailExtractor,0x969dc708,0x5c76,0x11d1,0x8d,0x86,0x00,0x00,0xf8,0x04,0xb0,0x57);


MIDL_DEFINE_GUID(IID, IID_IDummyHICONIncluder,0x947990de,0xcc28,0x11d2,0xa0,0xf7,0x00,0x80,0x5f,0x85,0x8f,0xb1);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:27 2002
 */
/* Compiler settings for objidl.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMarshal,0x00000003,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMarshal2,0x000001cf,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMalloc,0x00000002,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMallocSpy,0x0000001d,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IStdMarshalInfo,0x00000018,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IExternalConnection,0x00000019,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMultiQI,0x00000020,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_AsyncIMultiQI,0x000e0020,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IInternalUnknown,0x00000021,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumUnknown,0x00000100,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IBindCtx,0x0000000e,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumMoniker,0x00000102,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRunnableObject,0x00000126,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRunningObjectTable,0x00000010,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPersist,0x0000010c,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPersistStream,0x00000109,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMoniker,0x0000000f,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IROTData,0xf29f6bc0,0x5021,0x11ce,0xaa,0x15,0x00,0x00,0x69,0x01,0x29,0x3f);


MIDL_DEFINE_GUID(IID, IID_IEnumString,0x00000101,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISequentialStream,0x0c733a30,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IStream,0x0000000c,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATSTG,0x0000000d,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IStorage,0x0000000b,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPersistFile,0x0000010b,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPersistStorage,0x0000010a,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ILockBytes,0x0000000a,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumFORMATETC,0x00000103,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATDATA,0x00000105,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRootStorage,0x00000012,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IAdviseSink,0x0000010f,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_AsyncIAdviseSink,0x00000150,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IAdviseSink2,0x00000125,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_AsyncIAdviseSink2,0x00000151,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDataObject,0x0000010e,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDataAdviseHolder,0x00000110,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IMessageFilter,0x00000016,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRpcChannelBuffer,0xD5F56B60,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRpcChannelBuffer2,0x594f31d0,0x7f19,0x11d0,0xb1,0x94,0x00,0xa0,0xc9,0x0d,0xc8,0xbf);


MIDL_DEFINE_GUID(IID, IID_IAsyncRpcChannelBuffer,0xa5029fb6,0x3c34,0x11d1,0x9c,0x99,0x00,0xc0,0x4f,0xb9,0x98,0xaa);


MIDL_DEFINE_GUID(IID, IID_IRpcChannelBuffer3,0x25B15600,0x0115,0x11d0,0xBF,0x0D,0x00,0xAA,0x00,0xB8,0xDF,0xD2);


MIDL_DEFINE_GUID(IID, IID_IRpcProxyBuffer,0xD5F56A34,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRpcStubBuffer,0xD5F56AFC,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IPSFactoryBuffer,0xD5F569D0,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IChannelHook,0x1008c4a0,0x7613,0x11cf,0x9a,0xf1,0x00,0x20,0xaf,0x6e,0x72,0xf4);


MIDL_DEFINE_GUID(IID, IID_IClientSecurity,0x0000013D,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IServerSecurity,0x0000013E,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IClassActivator,0x00000140,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IRpcOptions,0x00000144,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IFillLockBytes,0x99caf010,0x415e,0x11cf,0x88,0x14,0x00,0xaa,0x00,0xb5,0x69,0xf5);


MIDL_DEFINE_GUID(IID, IID_IProgressNotify,0xa9d758a0,0x4617,0x11cf,0x95,0xfc,0x00,0xaa,0x00,0x68,0x0d,0xb4);


MIDL_DEFINE_GUID(IID, IID_ILayoutStorage,0x0e6d4d90,0x6738,0x11cf,0x96,0x08,0x00,0xaa,0x00,0x68,0x0d,0xb4);


MIDL_DEFINE_GUID(IID, IID_IBlockingLock,0x30f3d47a,0x6447,0x11d1,0x8e,0x3c,0x00,0xc0,0x4f,0xb9,0x38,0x6d);


MIDL_DEFINE_GUID(IID, IID_ITimeAndNoticeControl,0xbc0bf6ae,0x8878,0x11d1,0x83,0xe9,0x00,0xc0,0x4f,0xc2,0xc6,0xd4);


MIDL_DEFINE_GUID(IID, IID_IOplockStorage,0x8d19c834,0x8879,0x11d1,0x83,0xe9,0x00,0xc0,0x4f,0xc2,0xc6,0xd4);


MIDL_DEFINE_GUID(IID, IID_ISurrogate,0x00000022,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IGlobalInterfaceTable,0x00000146,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDirectWriterLock,0x0e6d4d92,0x6738,0x11cf,0x96,0x08,0x00,0xaa,0x00,0x68,0x0d,0xb4);


MIDL_DEFINE_GUID(IID, IID_ISynchronize,0x00000030,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISynchronizeHandle,0x00000031,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISynchronizeEvent,0x00000032,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISynchronizeContainer,0x00000033,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ISynchronizeMutex,0x00000025,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICancelMethodCalls,0x00000029,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IAsyncManager,0x0000002A,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_ICallFactory,0x1c733a30,0x2a1c,0x11ce,0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d);


MIDL_DEFINE_GUID(IID, IID_IRpcHelper,0x00000149,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IReleaseMarshalBuffers,0xeb0cb9e8,0x7996,0x11d2,0x87,0x2e,0x00,0x00,0xf8,0x08,0x08,0x59);


MIDL_DEFINE_GUID(IID, IID_IWaitMultiple,0x0000002B,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IUrlMon,0x00000026,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IForegroundTransfer,0x00000145,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPipeByte,0xDB2F3ACA,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_AsyncIPipeByte,0xDB2F3ACB,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_IPipeLong,0xDB2F3ACC,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_AsyncIPipeLong,0xDB2F3ACD,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_IPipeDouble,0xDB2F3ACE,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_AsyncIPipeDouble,0xDB2F3ACF,0x2F86,0x11d1,0x8E,0x04,0x00,0xC0,0x4F,0xB9,0x98,0x9A);


MIDL_DEFINE_GUID(IID, IID_IThumbnailExtractor,0x969dc708,0x5c76,0x11d1,0x8d,0x86,0x00,0x00,0xf8,0x04,0xb0,0x57);


MIDL_DEFINE_GUID(IID, IID_IDummyHICONIncluder,0x947990de,0xcc28,0x11d2,0xa0,0xf7,0x00,0x80,0x5f,0x85,0x8f,0xb1);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\idl\obj\unknwn_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:25 2002
 */
/* Compiler settings for unknwn.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "unknwn.h"

#define TYPE_FORMAT_STRING_SIZE   37                                
#define PROC_FORMAT_STRING_SIZE   79                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IClassFactory_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IClassFactory_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_RemoteCreateInstance_Proxy( 
    IClassFactory * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObject)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IClassFactory_RemoteCreateInstance_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IClassFactory *This;
        REFIID riid;
        IUnknown **ppvObject;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IClassFactory_CreateInstance_Stub(
                                            (IClassFactory *) pParamStruct->This,
                                            pParamStruct->riid,
                                            pParamStruct->ppvObject);
    
}

/* [call_as] */ HRESULT __stdcall IClassFactory_RemoteLockServer_Proxy( 
    IClassFactory * This,
    /* [in] */ BOOL fLock)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[42],
                  ( unsigned char * )&This);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IClassFactory_RemoteLockServer_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(4)
    struct _PARAM_STRUCT
        {
        IClassFactory *This;
        BOOL fLock;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IClassFactory_LockServer_Stub((IClassFactory *) pParamStruct->This,pParamStruct->fLock);
    
}



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure RemoteCreateInstance */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 10 */	NdrFcShort( 0x44 ),	/* 68 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 24 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	NdrFcShort( 0xc ),	/* Type Offset=12 */

	/* Parameter ppvObject */

/* 30 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */

	/* Return value */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteLockServer */

/* 42 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 58 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter fLock */

/* 66 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 68 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 72 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 76 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x8 ),	/* Offset= 8 (12) */
/*  6 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/*  8 */	NdrFcShort( 0x8 ),	/* 8 */
/* 10 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 12 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 14 */	NdrFcShort( 0x10 ),	/* 16 */
/* 16 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 18 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 20 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (6) */
			0x5b,		/* FC_END */
/* 24 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 26 */	NdrFcShort( 0x2 ),	/* Offset= 2 (28) */
/* 28 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 30 */	0x28,		/* Corr desc:  parameter, FC_LONG */
			0x0,		/*  */
/* 32 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 34 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_unknwn_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Standard interface: __MIDL_itf_unknwn_0005, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: AsyncIUnknown, ver. 0.0,
   GUID={0x000e0000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IClassFactory, ver. 0.0,
   GUID={0x00000001,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IClassFactory_FormatStringOffsetTable[] =
    {
    0,
    42
    };

static const MIDL_STUBLESS_PROXY_INFO IClassFactory_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IClassFactory_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IClassFactory_StubThunkTable[] = 
    {
    IClassFactory_RemoteCreateInstance_Thunk,
    IClassFactory_RemoteLockServer_Thunk
    };

static const MIDL_SERVER_INFO IClassFactory_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IClassFactory_FormatStringOffsetTable[-3],
    &IClassFactory_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IClassFactoryProxyVtbl = 
{
    &IClassFactory_ProxyInfo,
    &IID_IClassFactory,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IClassFactory_CreateInstance_Proxy ,
    IClassFactory_LockServer_Proxy
};

const CInterfaceStubVtbl _IClassFactoryStubVtbl =
{
    &IID_IClassFactory,
    &IClassFactory_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _unknwn_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IClassFactoryProxyVtbl,
    0
};

const CInterfaceStubVtbl * _unknwn_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IClassFactoryStubVtbl,
    0
};

PCInterfaceName const _unknwn_InterfaceNamesList[] = 
{
    "IClassFactory",
    0
};


#define _unknwn_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _unknwn, pIID, n)

int __stdcall _unknwn_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_unknwn_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo unknwn_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _unknwn_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _unknwn_StubVtblList,
    (const PCInterfaceName * ) & _unknwn_InterfaceNamesList,
    0, // no delegation
    & _unknwn_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:25 2002
 */
/* Compiler settings for unknwn.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "unknwn.h"

#define TYPE_FORMAT_STRING_SIZE   37                                
#define PROC_FORMAT_STRING_SIZE   83                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IClassFactory_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IClassFactory_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_RemoteCreateInstance_Proxy( 
    IClassFactory * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppvObject)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )This,
                  riid,
                  ppvObject);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IClassFactory_RemoteCreateInstance_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IClassFactory *This;
        REFIID riid;
        IUnknown **ppvObject;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IClassFactory_CreateInstance_Stub(
                                            (IClassFactory *) pParamStruct->This,
                                            pParamStruct->riid,
                                            pParamStruct->ppvObject);
    
}

/* [call_as] */ HRESULT __stdcall IClassFactory_RemoteLockServer_Proxy( 
    IClassFactory * This,
    /* [in] */ BOOL fLock)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[44],
                  ( unsigned char * )This,
                  fLock);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IClassFactory_RemoteLockServer_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IClassFactory *This;
        BOOL fLock;
        char Pad0[4];
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IClassFactory_LockServer_Stub((IClassFactory *) pParamStruct->This,pParamStruct->fLock);
    
}



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure RemoteCreateInstance */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 10 */	NdrFcShort( 0x44 ),	/* 68 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 26 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	NdrFcShort( 0xc ),	/* Type Offset=12 */

	/* Parameter ppvObject */

/* 32 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */

	/* Return value */

/* 38 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteLockServer */

/* 44 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 46 */	NdrFcLong( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x4 ),	/* 4 */
/* 52 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	NdrFcShort( 0x8 ),	/* 8 */
/* 58 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 60 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter fLock */

/* 70 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 72 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 74 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 76 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 78 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 80 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x8 ),	/* Offset= 8 (12) */
/*  6 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/*  8 */	NdrFcShort( 0x8 ),	/* 8 */
/* 10 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 12 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 14 */	NdrFcShort( 0x10 ),	/* 16 */
/* 16 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 18 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 20 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (6) */
			0x5b,		/* FC_END */
/* 24 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 26 */	NdrFcShort( 0x2 ),	/* Offset= 2 (28) */
/* 28 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 30 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 32 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_unknwn_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Standard interface: __MIDL_itf_unknwn_0005, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: AsyncIUnknown, ver. 0.0,
   GUID={0x000e0000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IClassFactory, ver. 0.0,
   GUID={0x00000001,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IClassFactory_FormatStringOffsetTable[] =
    {
    0,
    44
    };

static const MIDL_STUBLESS_PROXY_INFO IClassFactory_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IClassFactory_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IClassFactory_StubThunkTable[] = 
    {
    IClassFactory_RemoteCreateInstance_Thunk,
    IClassFactory_RemoteLockServer_Thunk
    };

static const MIDL_SERVER_INFO IClassFactory_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IClassFactory_FormatStringOffsetTable[-3],
    &IClassFactory_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IClassFactoryProxyVtbl = 
{
    &IClassFactory_ProxyInfo,
    &IID_IClassFactory,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IClassFactory_CreateInstance_Proxy ,
    IClassFactory_LockServer_Proxy
};

const CInterfaceStubVtbl _IClassFactoryStubVtbl =
{
    &IID_IClassFactory,
    &IClassFactory_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _unknwn_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IClassFactoryProxyVtbl,
    0
};

const CInterfaceStubVtbl * _unknwn_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IClassFactoryStubVtbl,
    0
};

PCInterfaceName const _unknwn_InterfaceNamesList[] = 
{
    "IClassFactory",
    0
};


#define _unknwn_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _unknwn, pIID, n)

int __stdcall _unknwn_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_unknwn_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo unknwn_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _unknwn_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _unknwn_StubVtblList,
    (const PCInterfaceName * ) & _unknwn_InterfaceNamesList,
    0, // no delegation
    & _unknwn_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\windows\inc\dxfile.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxfile.h
 *
 *  Content:    DirectX File public header file
 *
 ***************************************************************************/

#ifndef __DXFILE_H__
#define __DXFILE_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD DXFILEFORMAT;

#define DXFILEFORMAT_BINARY     0
#define DXFILEFORMAT_TEXT       1
#define DXFILEFORMAT_COMPRESSED 2

typedef DWORD DXFILELOADOPTIONS;

#define DXFILELOAD_FROMFILE  0x00L
#define DXFILELOAD_FROMRESOURCE 0x01L
#define DXFILELOAD_FROMMEMORY 0x02L
#define DXFILELOAD_FROMSTREAM 0x04L
#define DXFILELOAD_FROMURL 0x08L

typedef struct _DXFILELOADRESOURCE {
    HMODULE hModule;
    LPCTSTR lpName;
    LPCTSTR lpType;
}DXFILELOADRESOURCE, *LPDXFILELOADRESOURCE;

typedef struct _DXFILELOADMEMORY {
    LPVOID lpMemory;
    DWORD dSize;
}DXFILELOADMEMORY, *LPDXFILELOADMEMORY;

/*
 * DirectX File object types.
 */

#ifndef WIN_TYPES
#define WIN_TYPES(itype, ptype) typedef interface itype *LP##ptype, **LPLP##ptype
#endif

WIN_TYPES(IDirectXFile,                 DIRECTXFILE);
WIN_TYPES(IDirectXFileEnumObject,       DIRECTXFILEENUMOBJECT);
WIN_TYPES(IDirectXFileSaveObject,       DIRECTXFILESAVEOBJECT);
WIN_TYPES(IDirectXFileObject,           DIRECTXFILEOBJECT);
WIN_TYPES(IDirectXFileData,             DIRECTXFILEDATA);
WIN_TYPES(IDirectXFileDataReference,    DIRECTXFILEDATAREFERENCE);
WIN_TYPES(IDirectXFileBinary,           DIRECTXFILEBINARY);

/*
 * API for creating IDirectXFile interface.
 */

STDAPI DirectXFileCreate(LPDIRECTXFILE *lplpDirectXFile);

/*
 * The methods for IUnknown
 */

#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)       (THIS) kind; \
    STDMETHOD_(ULONG, Release)      (THIS) kind

/*
 * The methods for IDirectXFileObject
 */

#define IDIRECTXFILEOBJECT_METHODS(kind) \
    STDMETHOD(GetName) (THIS_ LPSTR, LPDWORD) kind; \
    STDMETHOD(GetId) (THIS_ LPGUID) kind

/*
 * DirectX File interfaces.
 */

#undef INTERFACE
#define INTERFACE IDirectXFile

DECLARE_INTERFACE_(IDirectXFile, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    STDMETHOD(CreateEnumObject) (THIS_ LPVOID, DXFILELOADOPTIONS,
                                 LPDIRECTXFILEENUMOBJECT *) PURE;
    STDMETHOD(CreateSaveObject) (THIS_ LPCSTR, DXFILEFORMAT,
                                 LPDIRECTXFILESAVEOBJECT *) PURE;
    STDMETHOD(RegisterTemplates) (THIS_ LPVOID, DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileEnumObject

DECLARE_INTERFACE_(IDirectXFileEnumObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    STDMETHOD(GetNextDataObject)    (THIS_ LPDIRECTXFILEDATA *) PURE;
    STDMETHOD(GetDataObjectById)    (THIS_ REFGUID, LPDIRECTXFILEDATA *) PURE;
    STDMETHOD(GetDataObjectByName)  (THIS_ LPCSTR, LPDIRECTXFILEDATA *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileSaveObject

DECLARE_INTERFACE_(IDirectXFileSaveObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    STDMETHOD(SaveTemplates) (THIS_ DWORD, const GUID **) PURE;
    STDMETHOD(CreateDataObject) (THIS_ REFGUID, LPCSTR, const GUID *,
                                 DWORD, LPVOID, LPDIRECTXFILEDATA *) PURE;
    STDMETHOD(SaveData) (THIS_ LPDIRECTXFILEDATA) PURE;
};


#undef INTERFACE
#define INTERFACE IDirectXFileObject

DECLARE_INTERFACE_(IDirectXFileObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirectXFileData

DECLARE_INTERFACE_(IDirectXFileData, IDirectXFileObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);

    STDMETHOD(GetData)          (THIS_ LPCSTR, DWORD *, void **) PURE;
    STDMETHOD(GetType)          (THIS_ const GUID **) PURE;
    STDMETHOD(GetNextObject)    (THIS_ LPDIRECTXFILEOBJECT *) PURE;
    STDMETHOD(AddDataObject)    (THIS_ LPDIRECTXFILEDATA) PURE;
    STDMETHOD(AddDataReference) (THIS_ LPCSTR, const GUID *) PURE;
    STDMETHOD(AddBinaryObject)  (THIS_ LPCSTR, const GUID *, LPCSTR, LPVOID, DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileDataReference

DECLARE_INTERFACE_(IDirectXFileDataReference, IDirectXFileObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);

    STDMETHOD(Resolve) (THIS_ LPDIRECTXFILEDATA *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirectXFileBinary

DECLARE_INTERFACE_(IDirectXFileBinary, IDirectXFileObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECTXFILEOBJECT_METHODS(PURE);

    STDMETHOD(GetSize)      (THIS_ DWORD *) PURE;
    STDMETHOD(GetMimeType)  (THIS_ LPCSTR *) PURE;
    STDMETHOD(Read)         (THIS_ LPVOID, DWORD, LPDWORD) PURE;
};

/*
 * DirectXFile Object Class Id (for CoCreateInstance())
 */

DEFINE_GUID(CLSID_CDirectXFile, 0x4516ec43, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);

/*
 * DirectX File Interface GUIDs.
 */

DEFINE_GUID(IID_IDirectXFile,               0x3d82ab40, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileEnumObject,     0x3d82ab41, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileSaveObject,     0x3d82ab42, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileObject,         0x3d82ab43, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileData,           0x3d82ab44, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileDataReference,  0x3d82ab45, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);
DEFINE_GUID(IID_IDirectXFileBinary,         0x3d82ab46, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/*
 * DirectX File Header template's GUID.
 */

DEFINE_GUID(TID_DXFILEHeader,   0x3d82ab43, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);


/*
 * DirectX File errors.
 */

#define _FACDD  0x876
#define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )

#define DXFILE_OK   0

#define DXFILEERR_BADOBJECT                 MAKE_DDHRESULT(850)
#define DXFILEERR_BADVALUE                  MAKE_DDHRESULT(851)
#define DXFILEERR_BADTYPE                   MAKE_DDHRESULT(852)
#define DXFILEERR_BADSTREAMHANDLE           MAKE_DDHRESULT(853)
#define DXFILEERR_BADALLOC                  MAKE_DDHRESULT(854)
#define DXFILEERR_NOTFOUND                  MAKE_DDHRESULT(855)
#define DXFILEERR_NOTDONEYET                MAKE_DDHRESULT(856)
#define DXFILEERR_FILENOTFOUND              MAKE_DDHRESULT(857)
#define DXFILEERR_RESOURCENOTFOUND          MAKE_DDHRESULT(858)
#define DXFILEERR_URLNOTFOUND               MAKE_DDHRESULT(859)
#define DXFILEERR_BADRESOURCE               MAKE_DDHRESULT(860)
#define DXFILEERR_BADFILETYPE               MAKE_DDHRESULT(861)
#define DXFILEERR_BADFILEVERSION            MAKE_DDHRESULT(862)
#define DXFILEERR_BADFILEFLOATSIZE          MAKE_DDHRESULT(863)
#define DXFILEERR_BADFILECOMPRESSIONTYPE    MAKE_DDHRESULT(864)
#define DXFILEERR_BADFILE                   MAKE_DDHRESULT(865)
#define DXFILEERR_PARSEERROR                MAKE_DDHRESULT(866)
#define DXFILEERR_NOTEMPLATE                MAKE_DDHRESULT(867)
#define DXFILEERR_BADARRAYSIZE              MAKE_DDHRESULT(868)
#define DXFILEERR_BADDATAREFERENCE          MAKE_DDHRESULT(869)
#define DXFILEERR_INTERNALERROR             MAKE_DDHRESULT(870)
#define DXFILEERR_NOMOREOBJECTS             MAKE_DDHRESULT(871)
#define DXFILEERR_BADINTRINSICS             MAKE_DDHRESULT(872)
#define DXFILEERR_NOMORESTREAMHANDLES       MAKE_DDHRESULT(873)
#define DXFILEERR_NOMOREDATA                MAKE_DDHRESULT(874)
#define DXFILEERR_BADCACHEFILE              MAKE_DDHRESULT(875)
#define DXFILEERR_NOINTERNET                MAKE_DDHRESULT(876)


#ifdef __cplusplus
};
#endif

#endif /* _DXFILE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\oleidl.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:33 2002
 */
/* Compiler settings for oleidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IOleAdviseHolder,0x00000111,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleCache,0x0000011e,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleCache2,0x00000128,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleCacheControl,0x00000129,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IParseDisplayName,0x0000011a,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleContainer,0x0000011b,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleClientSite,0x00000118,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleObject,0x00000112,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleWindow,0x00000114,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleLink,0x0000011d,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleItemContainer,0x0000011c,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceUIWindow,0x00000115,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceActiveObject,0x00000117,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceFrame,0x00000116,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceObject,0x00000113,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceSite,0x00000119,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IContinue,0x0000012a,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IViewObject,0x0000010d,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IViewObject2,0x00000127,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDropSource,0x00000121,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDropTarget,0x00000122,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumOLEVERB,0x00000104,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:33 2002
 */
/* Compiler settings for oleidl.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IOleAdviseHolder,0x00000111,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleCache,0x0000011e,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleCache2,0x00000128,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleCacheControl,0x00000129,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IParseDisplayName,0x0000011a,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleContainer,0x0000011b,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleClientSite,0x00000118,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleObject,0x00000112,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleWindow,0x00000114,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleLink,0x0000011d,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleItemContainer,0x0000011c,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceUIWindow,0x00000115,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceActiveObject,0x00000117,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceFrame,0x00000116,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceObject,0x00000113,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IOleInPlaceSite,0x00000119,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IContinue,0x0000012a,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IViewObject,0x0000010d,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IViewObject2,0x00000127,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDropSource,0x00000121,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IDropTarget,0x00000122,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumOLEVERB,0x00000104,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\wtypes.c ===
"/* dummy file for build*/"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\unknwn.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:25 2002
 */
/* Compiler settings for unknwn.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IUnknown,0x00000000,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_AsyncIUnknown,0x000e0000,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IClassFactory,0x00000001,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:25 2002
 */
/* Compiler settings for unknwn.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IUnknown,0x00000000,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_AsyncIUnknown,0x000e0000,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IClassFactory,0x00000001,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\pbagex.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:31 2002
 */
/* Compiler settings for pbagex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IPropertyBagEx,0x20011801,0x5DE6,0x11D1,0x8E,0x38,0x00,0xC0,0x4F,0xB9,0x38,0x6D);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATPROPBAG,0x20021801,0x5DE6,0x11D1,0x8E,0x38,0x00,0xC0,0x4F,0xB9,0x38,0x6D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:31 2002
 */
/* Compiler settings for pbagex.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IPropertyBagEx,0x20011801,0x5DE6,0x11D1,0x8E,0x38,0x00,0xC0,0x4F,0xB9,0x38,0x6D);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATPROPBAG,0x20021801,0x5DE6,0x11D1,0x8E,0x38,0x00,0xC0,0x4F,0xB9,0x38,0x6D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\propidl.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:28 2002
 */
/* Compiler settings for propidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IPropertyStorage,0x00000138,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPropertySetStorage,0x0000013A,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATPROPSTG,0x00000139,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATPROPSETSTG,0x0000013B,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:28 2002
 */
/* Compiler settings for propidl.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IPropertyStorage,0x00000138,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IPropertySetStorage,0x0000013A,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATPROPSTG,0x00000139,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);


MIDL_DEFINE_GUID(IID, IID_IEnumSTATPROPSETSTG,0x0000013B,0x0000,0x0000,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\types\uuid\storext.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:37 2002
 */
/* Compiler settings for storext.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IOverlappedCompletion,0x521a28f0,0xe40b,0x11ce,0xb2,0xc9,0x00,0xaa,0x00,0x68,0x09,0x37);


MIDL_DEFINE_GUID(IID, IID_IOverlappedStream,0x49384070,0xe40a,0x11ce,0xb2,0xc9,0x00,0xaa,0x00,0x68,0x09,0x37);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:07:37 2002
 */
/* Compiler settings for storext.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IOverlappedCompletion,0x521a28f0,0xe40b,0x11ce,0xb2,0xc9,0x00,0xaa,0x00,0x68,0x09,0x37);


MIDL_DEFINE_GUID(IID, IID_IOverlappedStream,0x49384070,0xe40a,0x11ce,0xb2,0xc9,0x00,0xaa,0x00,0x68,0x09,0x37);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\uuid\makefile.inc ===
$(XDK_LIB_PATH)\uuid.lib: $(SDK_LIB_PATH)\uuid.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\windows\inc\dxtdbg.h ===
/*******************************************************************************
* DXTDbg.h *
*----------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTDbg_h
#define DXTDbg_h

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#define DXTDBG_FUNC_TRACE   1
#define DXTDBG_INFO         2

class CDXTDbgFlags
{
  public:
    DWORD m_F;
    CDXTDbgFlags()
    {
        m_F = 0;
        HKEY hkResult;
        DWORD dwDisposition;
        if( RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("DXTDbgFlags"), 0, NULL, 0,
                            KEY_ALL_ACCESS, NULL, &hkResult, &dwDisposition )
                            == ERROR_SUCCESS )
        {
            if( dwDisposition == REG_CREATED_NEW_KEY )
            {
                RegSetValueEx( hkResult, _T("Flags"), NULL, REG_DWORD, (PBYTE)&m_F, sizeof( m_F ) );
            }
            else
            {
                DWORD BuffSize = sizeof( m_F );
                RegQueryValueEx( hkResult, _T("Flags"), NULL, NULL, (PBYTE)&m_F, &BuffSize );
            }
            RegCloseKey( hkResult );
        }
    }
};

class CDXTDbgScope
{
  public:
    static CDXTDbgFlags m_DebugFlags; 
    PCHAR  m_pFuncName;
    CDXTDbgScope( PCHAR pFuncName )
    {
        m_pFuncName = pFuncName;
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "\nEntering Function: %s\n", m_pFuncName );
        }
    }
    ~CDXTDbgScope()
    {
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "Leaving Function: %s\n", m_pFuncName );
        }
    }
};

//=== User macros ==============================================================
#ifdef _DEBUG
#define DXTDBG_FUNC( name ) CDXTDbgScope DXTDbgScope( name ); 
#define DXTDBG_MSG0( reportType, format ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF0( reportType, format );
#define DXTDBG_MSG1( reportType, format, arg1 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF4( reportType, format, arg1, arg2, arg3, arg4 )
#else
#define DXTDBG_FUNC( name )
#define DXTDBG_MSG0( reportType, format )
#define DXTDBG_MSG1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 )
#endif

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\windows\inc\rmxfguid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rmxfguid.h
 *
 *  Content:    Defines GUIDs of D3DRM's templates.
 *
 ***************************************************************************/

#ifndef __RMXFGUID_H_
#define __RMXFGUID_H_

/* {2B957100-9E9A-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInfo,
0x2b957100, 0x9e9a, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB44-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMesh,
0x3d82ab44, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5E-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMVector,
0x3d82ab5e, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB5F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMeshFace,
0x3d82ab5f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB4D-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMMaterial,
0x3d82ab4d, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {35FF44E1-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialArray,
0x35ff44e1, 0x6c7c, 0x11cf, 0x8F, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB46-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMFrame,
0x3d82ab46, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {F6F23F41-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameTransformMatrix,
0xf6f23f41, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F42-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshMaterialList,
0xf6f23f42, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F40-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshTextureCoords,
0xf6f23f40, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F43-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshNormals,
0xf6f23f43, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F44-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMCoords2d,
0xf6f23f44, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F6F23F45-7686-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMatrix4x4,
0xf6f23f45, 0x7686, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4F-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimation,
0x3d82ab4f, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB50-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMAnimationSet,
0x3d82ab50, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {10DD46A8-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationKey,
0x10dd46a8, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {10DD46A9-775B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFloatKeys,
0x10dd46a9, 0x775b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411840-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialAmbientColor,
0x01411840, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411841-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialDiffuseColor,
0x01411841, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {01411842-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialSpecularColor,
0x01411842, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E80-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialEmissiveColor,
0xd3e16e80, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {01411843-7786-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialPower,
0x01411843, 0x7786, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {35FF44E0-6C7C-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGBA,
0x35ff44e0, 0x6c7c, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xA3);

/* {D3E16E81-7835-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMColorRGB,
0xd3e16e81, 0x7835, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E0-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMGuid,
0xa42790e0, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E1-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureFilename,
0xa42790e1, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {A42790E2-7810-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTextureReference,
0xa42790e2, 0x7810, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B820-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMIndexedColor,
0x1630b820, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {1630B821-7842-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMeshVertexColors,
0x1630b821, 0x7842, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {4885AE60-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMMaterialWrap,
0x4885ae60, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {537DA6A0-CA37-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMBoolean,
0x537da6a0, 0xca37, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {ED1EC5C0-C0A8-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMMeshFaceWraps,
0xed1ec5c0, 0xc0a8, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {4885AE63-78E8-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMBoolean2d,
0x4885ae63, 0x78e8, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {F406B180-7B3B-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMTimedFloatKeys,
0xf406b180, 0x7b3b, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C0-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMAnimationOptions,
0xe2bf56c0, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C1-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFramePosition,
0xe2bf56c1, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C2-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameVelocity,
0xe2bf56c2, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {E2BF56C3-840F-11cf-8F52-0040333594A3} */
DEFINE_GUID(TID_D3DRMFrameRotation,
0xe2bf56c3, 0x840f, 0x11cf, 0x8f, 0x52, 0x0, 0x40, 0x33, 0x35, 0x94, 0xa3);

/* {3D82AB4A-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMLight,
0x3d82ab4a, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3D82AB51-62DA-11cf-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMCamera,
0x3d82ab51, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {E5745280-B24F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMAppData,
0xe5745280, 0xb24f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22740-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightUmbra,
0xaed22740, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22742-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightRange,
0xaed22742, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {AED22741-B31F-11cf-9DD5-00AA00A71A2F} */
DEFINE_GUID(TID_D3DRMLightPenumbra,
0xaed22741, 0xb31f, 0x11cf, 0x9d, 0xd5, 0x0, 0xaa, 0x0, 0xa7, 0x1a, 0x2f);

/* {A8A98BA0-C5E5-11cf-B941-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMLightAttenuation,
0xa8a98ba0, 0xc5e5, 0x11cf, 0xb9, 0x41, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);

/* {3A23EEA0-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMInlineData,
0x3a23eea0, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {3A23EEA1-94B1-11d0-AB39-0020AF71E433} */
DEFINE_GUID(TID_D3DRMUrl,
0x3a23eea1, 0x94b1, 0x11d0, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33);

/* {8A63C360-997D-11d0-941C-0080C80CFA7B} */
DEFINE_GUID(TID_D3DRMProgressiveMesh,
0x8A63C360, 0x997D, 0x11d0, 0x94, 0x1C, 0x0, 0x80, 0xC8, 0x0C, 0xFA, 0x7B);

/* {98116AA0-BDBA-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMExternalVisual,
0x98116AA0, 0xBDBA, 0x11d1, 0x82, 0xC0, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x71);

/* {7F0F21E0-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMStringProperty,
0x7f0f21e0, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

/* {7F0F21E1-BFE1-11d1-82C0-00A0C9697271} */
DEFINE_GUID(TID_D3DRMPropertyBag,
0x7f0f21e1, 0xbfe1, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

// {7F5D5EA0-D53A-11d1-82C0-00A0C9697271}
DEFINE_GUID(TID_D3DRMRightHanded,
0x7f5d5ea0, 0xd53a, 0x11d1, 0x82, 0xc0, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x71);

#endif /* __RMXFGUID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\xdk\makefile.inc ===
TARGETSRCS= \
             $(XDK_INC_PATH)\BaseTsd.h       \
             $(XDK_INC_PATH)\CGuid.h         \
             $(XDK_INC_PATH)\GuidDef.h       \
             $(XDK_INC_PATH)\PopPack.h       \
             $(XDK_INC_PATH)\PshPack1.h      \
             $(XDK_INC_PATH)\PshPack2.h      \
             $(XDK_INC_PATH)\PshPack4.h      \
             $(XDK_INC_PATH)\PshPack8.h      \
             $(XDK_INC_PATH)\XObjBase.h


xdkinc: $(TARGETSRCS)

clean: cleansrc

cleansrc:
    -del /q /f $(TARGETSRCS) 2>nul

{$(SDK_INC_PATH)}.h{$(XDK_INC_PATH)}.h:
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\windows\inc\makefile.inc ===
#
# The contents of this file was moved from windows\makefile0
#

COPYRIGHT_STRING = Copyright (c) 1990-2001  Microsoft Corporation

!IFNDEF NO_STRICT
STRICT=1
!ENDIF

TARGETSRCS0= \
             $(SDK_INC_PATH)\dxfile.h        \
             $(SDK_INC_PATH)\rmxfguid.h      \
             $(SDK_INC_PATH)\rmxftmpl.h      \
             $(SDK_INC_PATH)\winbase.h       \
             $(SDK_INC_PATH)\windef.h        \
             $(SDK_INC_PATH)\windows.h       \
             $(SDK_INC_PATH)\wingdi.h        \
             $(SDK_INC_PATH)\winioctl.h      \
             $(SDK_INC_PATH)\winnls.h        \
             $(SDK_INC_PATH)\winnt.h         \
             $(SDK_INC_PATH)\winsockx.h      \
             $(SDK_INC_PATH)\winuser.h       \
             $(SDK_INC_PATH)\winver.h        \
             $(SDK_INC_PATH)\xbox.h          \
             $(SDK_INC_PATH)\xkbd.h          \
             $(SDK_INC_PATH)\xmv.h           \
             $(SDK_INC_PATH)\xtl.h

TARGETSRCS1= \
             $(PRIVATE_INC_PATH)\winbasep.h  \
             $(PRIVATE_INC_PATH)\windowsp.h  \
             $(PRIVATE_INC_PATH)\wingdip.h   \
             $(PRIVATE_INC_PATH)\winnlsp.h   \
             $(PRIVATE_INC_PATH)\winuserp.h  \
             $(PRIVATE_INC_PATH)\xbdm.h      \
             $(PRIVATE_INC_PATH)\xbdmp.h     \
             $(PRIVATE_INC_PATH)\xboxdbg.h   \
             $(PRIVATE_INC_PATH)\xboxp.h     \
             $(PRIVATE_INC_PATH)\winsockp.h  \
             $(PRIVATE_INC_PATH)\wsockntp.h

TARGETSRCS2= \
             $(XDK_INC_PATH)\dxfile.h        \
             $(XDK_INC_PATH)\rmxfguid.h      \
             $(XDK_INC_PATH)\rmxftmpl.h      \
             $(XDK_INC_PATH)\winbase.h       \
             $(XDK_INC_PATH)\windef.h        \
             $(XDK_INC_PATH)\winnt.h         \
             $(XDK_INC_PATH)\winsockx.h      \
             $(XDK_INC_PATH)\xbox.h          \
             $(XDK_INC_PATH)\xbdm.h          \
             $(XDK_INC_PATH)\xboxdbg.h       \
             $(XDK_INC_PATH)\xkbd.h          \
             $(XDK_INC_PATH)\xmv.h           \
             $(XDK_INC_PATH)\xtl.h

INTERMEDIATES0= \
             winbase.x                       \
             winbasep.x                      \
             windows.x                       \
             windowsp.x                      \
             wingdi.x                        \
             wingdip.x                       \
             winnls.x                        \
             winsockx.x                      \
             winuser.x                       \
             winuserp.x                      \
             xbdm.x                          \
             xbdmp.x                         \
             xboxdbg.x

WINNT_DEPENDS = $(SDK_INC_PATH)\ntdef.h \
                $(SDK_INC_PATH)\ntstatus.h \
                $(SDK_INC_PATH)\ntkeapi.h \
                $(SDK_INC_PATH)\nti386.h \
                $(SDK_INC_PATH)\ntxcapi.h \
                $(SDK_INC_PATH)\ntseapi.h \
                $(SDK_INC_PATH)\ntpsapi.h \
                $(SDK_INC_PATH)\ntexapi.h \
                $(SDK_INC_PATH)\ntmmapi.h \
                $(SDK_INC_PATH)\ntioapi.h \
                $(SDK_INC_PATH)\ntobapi.h \
                $(SDK_INC_PATH)\ntpoapi.h \
                $(SDK_INC_PATH)\ntimage.h \
                $(SDK_INC_PATH)\ntrtl.h  \
                $(SDK_INC_PATH)\nturtl.h  \
                $(SDK_INC_PATH)\ntldr.h  \
                $(SDK_INC_PATH)\ntdbg.h \
                $(SDK_INC_PATH)\ntregapi.h \
                $(SDK_INC_PATH)\ntconfig.h \

WINIOCTL_DEPENDS = $(SDK_INC_PATH)\devioctl.h \
                   $(SDK_INC_PATH)\ntddstor.h \
                   $(SDK_INC_PATH)\ntdddisk.h \
                   $(SDK_INC_PATH)\ntioapi.h


TARGET_MOVED0 = \
                $(SDK_INC_PATH)\accctrl.h       \
                $(SDK_INC_PATH)\dde.rh          \
                $(SDK_INC_PATH)\ddeml.h         \
                $(SDK_INC_PATH)\ddraw.h         \
                $(SDK_INC_PATH)\ddrawex.h       \
                $(SDK_INC_PATH)\digitalv.h      \
                $(SDK_INC_PATH)\dxtdbg.h        \
                $(SDK_INC_PATH)\ime.h           \
                $(SDK_INC_PATH)\imm.h           \
                $(SDK_INC_PATH)\indicml.h       \
                $(SDK_INC_PATH)\lzexpand.h      \
                $(SDK_INC_PATH)\nspapi.h        \
                $(SDK_INC_PATH)\pbt.h           \
                $(SDK_INC_PATH)\userenv.h       \
                $(SDK_INC_PATH)\wincon.h        \
                $(SDK_INC_PATH)\wincrypt.h      \
                $(SDK_INC_PATH)\winnls32.h      \
                $(SDK_INC_PATH)\winnt.rh        \
                $(SDK_INC_PATH)\winreg.h        \
                $(SDK_INC_PATH)\winspool.h      \
                $(SDK_INC_PATH)\winsvc.h

TARGET_MOVED1 = \
                $(OAK_INC_PATH)\dderror.h       \
                $(OAK_INC_PATH)\immdev.h        \
                $(OAK_INC_PATH)\winsecp.h       \
                $(PRIVATE_INC_PATH)\conapi.h    \
                $(PRIVATE_INC_PATH)\ddmc.h      \
                $(PRIVATE_INC_PATH)\ddmcp.h     \
                $(PRIVATE_INC_PATH)\ddemlp.h    \
                $(PRIVATE_INC_PATH)\ddrawp.h    \
                $(PRIVATE_INC_PATH)\dvpp.h      \
                $(PRIVATE_INC_PATH)\imep.h      \
                $(PRIVATE_INC_PATH)\immp.h      \
                $(PRIVATE_INC_PATH)\indicmlp.h  \
                $(PRIVATE_INC_PATH)\userenvp.h  \
                $(PRIVATE_INC_PATH)\profmapp.h  \
                $(PRIVATE_INC_PATH)\wbasek.h    \
                $(PRIVATE_INC_PATH)\winconp.h   \
                $(PRIVATE_INC_PATH)\winregp.h   \
                $(PRIVATE_INC_PATH)\winsprlp.h  \
                $(PRIVATE_INC_PATH)\xtlp.h

TARGET_MOVED2 = \
                accctrl.x                       \
                accctrlp.x                      \
                wincon.x                        \
                winconp.x                       \
                winnls32.x                      \
                winnls3p.x                      \
                winreg.x                        \
                winregp.x                       \
                ddeml.x                         \
                ime.x                           \
                imep.x                          \
                imm.x                           \
                immdev.x                        \
                immp.x                          \
                userenv.x                       \
                userenvp.x                      \
                profmap.x                       \
                profmapp.x                      \
                qos.w                           \
                qospol.w                        \
                qossp.w                         \
                wbasenoxbox.x                   \
                winnetp.x                       \
                winnetwk.x                      \
                winspool.x                      \
                xtl.x                           \
                xtlp.x

TARGETSRCS= $(TARGETSRCS0) $(TARGETSRCS1) $(TARGETSRCS2)

wininc: $(TARGETSRCS)

clean: cleansrc cleanmoved

# split up the deletes so we don't get nmake "line too long" errors
cleansrc:
    -del /q /f $(TARGETSRCS0) 2>nul
    -del /q /f $(TARGETSRCS1) 2>nul
    -del /q /f $(TARGETSRCS2) 2>nul
    -del /q /f $(INTERMEDIATES0) 2>nul
    -del /q /f $(INTERMEDIATES1) 2>nul

# delete the files that were used to be generated

cleanmoved:
    -del /q /f $(TARGET_MOVED0) 2>nul
    -del /q /f $(TARGET_MOVED1) 2>nul
    -del /q /f $(TARGET_MOVED2) 2>nul

#
# mmddk.h, mmddkp.h
#

$(SDK_INC_PATH)\mmddk.h: mmddk.h
    hsplit -lt2 Internal -e -o $@ nul mmddk.h

$(PRIVATE_INC_PATH)\mmddkp.h: mmddk.h
    copy mmddk.h $@


#
# mmsystem.h, mmsystem.x, mmsysp.h, mmsysp.x
#

mmsystem.x: mmsystem.w
    hsplit -e -s -o mmsystem.y nul -lt2 inc -bt2 begin_inc end_inc -ltb hinc -btb begin_hinc end_hinc mmsystem.w
    hsplit -e -n -o mmsystem.x mmsysp.x mmsystem.y
    del mmsystem.y

$(SDK_INC_PATH)\mmsystem.h: mmsystem.x
    wcshdr < mmsystem.x > $@

$(XDK_INC_PATH)\mmsystem.h : $(SDK_INC_PATH)\mmsystem.h
    copy $** $@

$(PRIVATE_INC_PATH)\mmsysp.h:  mmsysp.x
    wcshdr <  mmsysp.x > $@

#
# winsockx.h, winsockx.w
#

$(SDK_INC_PATH)\winsockx.h $(PRIVATE_INC_PATH)\winsockp.h : winsockx.w
    hsplit -ts noxbox -ts ntp -ta xboxp -o nul $(PRIVATE_INC_PATH)\winsockp.h winsockx.w
    hsplit -ts noxbox -ts xboxp -ta ntp -o $(SDK_INC_PATH)\winsockx.h $(PRIVATE_INC_PATH)\wsockntp.h winsockx.w

$(XDK_INC_PATH)\winsockx.h : $(SDK_INC_PATH)\winsockx.h
    copy $** $@

#
# winbase.h, winbasep.h, winbase.x, winbasep.x
#

winbase.x winbasep.x $(PRIVATE_INC_PATH)\wbasek.h : winbase.w
    hsplit -ts noxbox -ta xboxonly -o winbase.x winbasep.x winbase.w

$(SDK_INC_PATH)\winbase.h : winbase.x
    wcshdr < winbase.x > $@

$(XDK_INC_PATH)\winbase.h : $(SDK_INC_PATH)\winbase.h
    copy $** $@

$(PRIVATE_INC_PATH)\winbasep.h : winbasep.x
    wcshdr < winbasep.x > $@

#
# windef.h
#

$(SDK_INC_PATH)\windef.h: windef.w
    hsplit -e -o $@ nul windef.w

$(XDK_INC_PATH)\windef.h : $(SDK_INC_PATH)\windef.h
    copy $** $@

#
# windows.h, windowsp.h, windows.x, windowsp.x
#

windows.x windowsp.x: windows.w
    hsplit -e -o windows.x windowsp.x windows.w

$(SDK_INC_PATH)\windows.h : windows.x
    wcshdr < windows.x > $@

$(PRIVATE_INC_PATH)\windowsp.h : windowsp.x
    wcshdr < windowsp.x > $@

#
# xtl.h
#

$(SDK_INC_PATH)\xtl.h : xtl.w $(PRIVATE_INC_PATH)\xboxverp.h makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    xtl.h

Abstract:

    Master include file for Xbox applications.

--*/

#ifndef _XTL_
#define _XTL_

#ifndef WINVER
#define WINVER 0x0500
#endif

#ifndef _INC_XTL
#define _INC_XTL

<<
    hextract -o $@ -lt xtl $(PRIVATE_INC_PATH)\xboxverp.h
    hextract -o $@ -bt begin_xtl end_xtl xtl.w

$(XDK_INC_PATH)\xtl.h : $(SDK_INC_PATH)\xtl.h
    copy $** $@

#
# wingdi.h, wingdip.h, wingdip.x, wingdi.x
#

wingdi.x wingdip.x: wingdi.w
    hsplit -e -o wingdi.x wingdip.x wingdi.w

$(PRIVATE_INC_PATH)\wingdip.h: wingdip.x
    wcshdr < wingdip.x > $@

$(SDK_INC_PATH)\wingdi.h: wingdi.x
    wcshdr < wingdi.x > $@

#
# winnls.h, winnlsp.h, winnls.x
#

winnls.x $(PRIVATE_INC_PATH)\winnlsp.h: winnls.w
    hsplit -e -o winnls.x $(PRIVATE_INC_PATH)\winnlsp.h winnls.w

$(SDK_INC_PATH)\winnls.h: winnls.x
    wcshdr < winnls.x > $@

#
# winuser.h, winuserp.h, winuserp.x
#

winuser.x winuserp.x : winuser.w
    hsplit -e -o winuser.x winuserp.x -i winuser.w

$(SDK_INC_PATH)\winuser.h: winuser.x
    wcshdr < winuser.x > $@

$(PRIVATE_INC_PATH)\winuserp.h: winuserp.x
    wcshdr < winuserp.x > $@

#
# winver.h
#

$(SDK_INC_PATH)\winver.h : winver.x
    wcshdr < winver.x > $@


#
# dxfile.h
#

$(SDK_INC_PATH)\dxfile.h: dxfile.h
        copy dxfile.h $@

$(XDK_INC_PATH)\dxfile.h : $(SDK_INC_PATH)\dxfile.h
    copy $** $@

#
# xmv.h
#

$(SDK_INC_PATH)\xmv.h: xmv.h
        copy xmv.h $@

$(XDK_INC_PATH)\xmv.h : $(SDK_INC_PATH)\xmv.h
    copy $** $@

#
# rmxfguid.h
#

$(SDK_INC_PATH)\rmxfguid.h: rmxfguid.h
        copy rmxfguid.h $@

$(XDK_INC_PATH)\rmxfguid.h : $(SDK_INC_PATH)\rmxfguid.h
    copy $** $@

#
# rmxftmpl.h
#

$(SDK_INC_PATH)\rmxftmpl.h: rmxftmpl.h
        copy rmxftmpl.h $@

$(XDK_INC_PATH)\rmxftmpl.h : $(SDK_INC_PATH)\rmxftmpl.h
    copy $** $@


#
# xbox.h, xboxp.h
#

$(SDK_INC_PATH)\xbox.h $(PRIVATE_INC_PATH)\xboxp.h : xbox.x
    hsplit -o $(SDK_INC_PATH)\xbox.h $(PRIVATE_INC_PATH)\xboxp.h xbox.x

$(XDK_INC_PATH)\xbox.h : $(SDK_INC_PATH)\xbox.h
    copy $** $@


#
# xbdm.h, xboxdbg.h
#

xbdm.x xbdmp.x : xbdm.w
    hsplit -ta xbdm -ts xboxdbg -ts priv -o xbdm.x xbdmp.x -i xbdm.w

$(PRIVATE_INC_PATH)\xbdm.h : xbdm.x
    copy $** $@

$(PRIVATE_INC_PATH)\xbdmp.h : xbdmp.x
    copy $** $@

$(XDK_INC_PATH)\XbDm.h : $(PRIVATE_INC_PATH)\xbdm.h
    Copy "$?" "$@"

xboxdbg.x : xbdm.w
    hsplit -ts xbdm -ta xboxdbg -o xboxdbg.x xboxdbgp.x xbdm.w

$(PRIVATE_INC_PATH)\xboxdbg.h : xboxdbg.x
    wcshdr < xboxdbg.x > $@

$(XDK_INC_PATH)\XboxDbg.h : $(PRIVATE_INC_PATH)\XboxDbg.h
    Copy "$?" "$@"

#
# xkbd.h
#

$(SDK_INC_PATH)\xkbd.h : xkbd.x
    copy $** $@   

$(XDK_INC_PATH)\xkbd.h : xkbd.x
    copy $** $@   


########################################################################
# winnt.h
#

$(SDK_INC_PATH)\winnt.h: $(WINNT_DEPENDS) makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    winnt.h

Abstract:

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

Revision History:

--*/

#ifndef _WINNT_
#define _WINNT_

#ifdef __cplusplus
extern "C" {
#endif

<<
    hextract -f2 -o $@ -lt winnt -bt begin_winnt end_winnt $(WINNT_DEPENDS)
    type << >> $@

#ifdef __cplusplus
}
#endif

#endif /* _WINNT_ */

<<

$(XDK_INC_PATH)\winnt.h : $(SDK_INC_PATH)\winnt.h
    copy $** $@


########################################################################
# winioctl.h
#

$(SDK_INC_PATH)\winioctl.h: $(WINIOCTL_DEPENDS) makefile.inc
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    winioctl.h

Abstract:

    This module defines the 32-Bit Windows Device I/O control codes.

Revision History:

--*/


//
// Interface GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <winioctl.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <winioctl.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

<<
    hextract -f -o $@ -lt wioctlguids -bt begin_wioctlguids end_wioctlguids $(WINIOCTL_DEPENDS)
    type << >> $@
#endif // DEFINE_GUID

#ifndef _WINIOCTL_
#define _WINIOCTL_

<<
    hextract -f -o $@ -lt winioctl -bt begin_winioctl end_winioctl $(WINIOCTL_DEPENDS)
    type << >> $@

#endif // _WINIOCTL_

<<
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\windows\inc\mmddk.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1998, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MMDDK
#define _INC_MMDDK

#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOMIXERDEV        - Mixer support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef MMNOTIMER
  #define MMNOTIMERDEV
#endif
#ifdef MMNOWAVE
  #define MMNOWAVEDEV
#endif
#ifdef MMNOMIDI
  #define MMNOMIDIDEV
#endif
#ifdef MMNOAUX
  #define MMNOAUXDEV
#endif
#ifdef MMNOJOY
  #define MMNOJOYDEV
#endif
#ifdef MMNOMMIO
  #define MMNOMMIODEV
#endif
#ifdef MMNOMCI
  #define MMNOMCIDEV
#endif

#ifdef  NOMIDIDEV       /* ;Internal */
#define MMNOMIDIDEV     /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOWAVEDEV       /* ;Internal */
#define MMNOWAVEDEV     /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOAUXDEV        /* ;Internal */
#define MMNOAUXDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOTIMERDEV      /* ;Internal */
#define MMNOTIMERDEV        /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOJOYDEV        /* ;Internal */
#define MMNOJOYDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOMCIDEV        /* ;Internal */
#define MMNOMCIDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOTASKDEV       /* ;Internal */
#define MMNOTASKDEV     /* ;Internal */
#endif              /* ;Internal */

/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#ifndef NODRIVERS
#define DRV_LOAD               0x0001
#define DRV_ENABLE             0x0002
#define DRV_OPEN               0x0003
#define DRV_CLOSE              0x0004
#define DRV_DISABLE            0x0005
#define DRV_FREE               0x0006
#define DRV_CONFIGURE          0x0007
#define DRV_QUERYCONFIGURE     0x0008
#define DRV_INSTALL            0x0009
#define DRV_REMOVE             0x000A

#define DRV_RESERVED           0x0800
#define DRV_USER               0x4000

#define DRIVERS_SECTION  TEXT("DRIVERS32")     // Section name for installed drivers
#define MCI_SECTION      TEXT("MCI32")         // Section name for installed MCI drivers

#endif /* !NODRIVERS */

#define DCB_NOSWITCH   0x0008           // don't switch stacks for callback
#define DCB_TYPEMASK   0x0007           // callback type mask
#define DCB_NULL       0x0000           // unknown callback type

// flags for wFlags parameter of DriverCallback()
#define DCB_WINDOW     0x0001           // dwCallback is a HWND
#define DCB_TASK       0x0002           // dwCallback is a HTASK
#define DCB_FUNCTION   0x0003           // dwCallback is a FARPROC
#define DCB_EVENT      0x0005           // dwCallback is an EVENT

BOOL APIENTRY DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags,
    HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
//typedef DWORD (SOUNDDEVMSGPROC)(WORD, WORD, DWORD, DWORD, DWORD);
//typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

#define DRVM_INIT               100
#define DRVM_EXIT               101
#define DRVM_DISABLE            102
#define DRVM_ENABLE             103


// message base for driver specific messages.
//
#define DRVM_MAPPER             0x2000
#define DRVM_USER               0x4000
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#define DRVM_MAPPER_RECONFIGURE (DRVM_MAPPER+1)
#define	DRVM_MAPPER_QUERYDEST	                  (DRVM_MAPPER+20) /* ;Internal */
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#define DRVM_MAPPER_PREFERRED_SET                 (DRVM_MAPPER+22) /* ;Internal */

#define DRV_QUERYDRVENTRY            (DRV_RESERVED + 1)         /* ;Internal */
#define DRV_QUERYDEVNODE             (DRV_RESERVED + 2)         /* ;Internal */
#define DRV_QUERYNAME                (DRV_RESERVED + 3)         /* ;Internal */
#define DRV_QUERYDRIVERIDS           (DRV_RESERVED + 4)         /* ;Internal */
#define DRV_QUERYMAPPABLE            (DRV_RESERVED + 5)         /* ;Internal */
#define DRV_QUERYMAPID               (DRV_RESERVED + 6)         /* ;Internal */
#define DRV_QUERYNUMPORTS            (DRV_RESERVED + 8)         /* ;Internal */
#define DRV_QUERYMODULE              (DRV_RESERVED + 9)
#define DRV_QUERYFILENAME            (DRV_RESERVED + 10)        /* ;Internal */
#define DRV_PNPINSTALL               (DRV_RESERVED + 11)
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)        /* ;Internal */
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)        /* ;Internal */

//
// DRVM_MAPPER_PREFERRED_GET flags
//
#define DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY   0x00000001



//
// messages that have IOCTL format
//    dw1 = NULL or handle
//    dw2 = NULL or ptr to DRVM_IOCTL_DATA
//    return is MMRESULT
//
#define DRVM_IOCTL                0x100
#define DRVM_ADD_THRU             (DRVM_IOCTL+1)
#define DRVM_REMOVE_THRU          (DRVM_IOCTL+2)
#define DRVM_IOCTL_LAST           (DRVM_IOCTL+5)

typedef struct {
    DWORD  dwSize; // size of this structure (inclusive)
    DWORD  dwCmd;  // IOCTL command code, 0x80000000 and above reserved for system
    } DRVM_IOCTL_DATA, FAR * LPDRVM_IOCTL_DATA;

// command code ranges for dwCmd field of DRVM_IOCTL message
// codes from 0 to 0x7FFFFFFF are user defined
// codes from 0x80000000 to 0xFFFFFFFF are reserved for future
// definition by microsoft
//
#define DRVM_IOCTL_CMD_USER   0x00000000L
#define DRVM_IOCTL_CMD_SYSTEM 0x80000000L

// device ID for 386 AUTODMA VxD
#define VADMAD_Device_ID    0X0444

/* PnP version of media device caps */
typedef struct {
    DWORD	cbSize;
    LPVOID	pCaps;
} MDEVICECAPSEX;

#ifndef MMNOWAVEDEV
/****************************************************************************

                       Waveform device driver support

****************************************************************************/

// maximum number of wave device drivers loaded
#ifndef NOWIN31
#define MAXWAVEDRIVERS 10
#else
#define MAXWAVEDRIVERS 4
#endif

#define WODM_INIT      DRVM_INIT
#define WIDM_INIT      DRVM_INIT

// waveform input and output device open information structure
typedef struct waveopendesc_tag {
    HWAVE          hWave;             // handle
    LPWAVEFORMAT   lpFormat;          // format of wave data
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    UINT           uMappedDeviceID;   // device to map to if WAVE_MAPPED set
    DWORD_PTR      dnDevNode;         /* if device is PnP */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

// messages sent to wodMessage() entry-point function
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20
#define WODM_PREFERRED        21
// #if (WINVER >= 0x030B)
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
// #endif /* WINVER >= 0x030B */
#define WODM_BUSY             21

// messages sent to widMessage() entry-point function
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60
#define WIDM_PREFERRED   61
// #if (WINVER >= 0x030B)
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
// #endif /* WINVER >= 0x30B */

#endif // ifndef MMNOWAVEDEV


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

// maximum number of MIDI device drivers loaded
#ifndef NOWIN31
#define MAXMIDIDRIVERS 10
#else
#define MAXMIDIDRIVERS 4
#endif

#define MODM_USER      DRVM_USER
#define MIDM_USER      DRVM_USER
#define MODM_MAPPER    DRVM_MAPPER
#define MIDM_MAPPER    DRVM_MAPPER

#define MODM_INIT      DRVM_INIT
#define MIDM_INIT      DRVM_INIT

#ifndef MMNOMIDI   // This protects the definition of HMIDI in WINMM.H
                   // Win 3.1 works the same way
typedef struct midiopenstrmid_tag {
    DWORD          dwStreamID;
    UINT           uDeviceID;
} MIDIOPENSTRMID;
// MIDI input and output device open information structure
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             // handle
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    DWORD_PTR      dnDevNode;         // DevNode
    DWORD          cIds;              // If stream open, # stream ids
    MIDIOPENSTRMID rgIds[1];          // Array of device ID's (actually [cIds])
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;
#endif // MMNOMIDI


/* Flags for MODM_OPEN */
#define MIDI_IO_PACKED      0x00000000L     /* Compatibility mode */
#define MIDI_IO_COOKED      0x00000002L

// messages sent to modMessage() entry-point function
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12
#define MODM_CACHEDRUMPATCHES   13

#if (WINVER >= 0x400)
#define MODM_STRMDATA               14
#define MODM_GETPOS                 17
#define MODM_PAUSE                  18
#define MODM_RESTART                19
#define MODM_STOP                   20
#define MODM_PROPERTIES             21
#define MODM_PREFERRED              22
#define MODM_RECONFIGURE            (MODM_USER+0x0768)
#endif


// messages sent to midMessage() entry-point function
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif // ifndef MMNOMIDIDEV


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

// maximum number of auxiliary device drivers loaded
#ifndef NOWIN31
#define MAXAUXDRIVERS 10
#else
#define MAXAUXDRIVERS 4
#endif

#define AUXM_INIT      DRVM_INIT

// messages sent to auxMessage() entry-point function
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif // ifndef MMNOAUXDEV

// #if (WINVER >= 0x030B)
#ifndef MMNOMIXERDEV

#ifndef MAXMIXERDRIVERS

//
//  maximum number of mixer drivers that can be loaded by MSMIXMGR.DLL
//
#define MAXMIXERDRIVERS     10


//
//  mixer device open information structure
//
//
typedef struct tMIXEROPENDESC
{
    HMIXER          hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD_PTR       dwCallback;     // callback
    DWORD_PTR       dwInstance;     // app's private instance information
    DWORD_PTR       dnDevNode;      // if device is PnP

} MIXEROPENDESC, *PMIXEROPENDESC, FAR *LPMIXEROPENDESC;



//
//
//
//
#define MXDM_INIT                   100
#define MXDM_USER                   DRV_USER

#define MXDM_BASE                   (1)
#define MXDM_GETNUMDEVS             (MXDM_BASE + 0)
#define MXDM_GETDEVCAPS             (MXDM_BASE + 1)
#define MXDM_OPEN                   (MXDM_BASE + 2)
#define MXDM_CLOSE                  (MXDM_BASE + 3)
#define MXDM_GETLINEINFO            (MXDM_BASE + 4)
#define MXDM_GETLINECONTROLS        (MXDM_BASE + 5)
#define MXDM_GETCONTROLDETAILS      (MXDM_BASE + 6)
#define MXDM_SETCONTROLDETAILS      (MXDM_BASE + 7)

#endif // MAXMIXERDRIVERS

#endif // MMNOMIXERDEV
// #endif /* ifdef WINVER >= 0x030B */

#if !defined(MMNOTIMERDEV)
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    WORD                wDelay;         // delay required
    WORD                wResolution;    // resolution required
    LPTIMECALLBACK      lpFunction;     // ptr to callback function
    DWORD               dwUser;         // user DWORD
    WORD                wFlags;         // defines how to program event
    WORD                wReserved1;     // structure packing
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

// messages sent to tddMessage() function
#define TDD_KILLTIMEREVENT  (DRV_RESERVED+0)  // indices into a table of
#define TDD_SETTIMEREVENT   (DRV_RESERVED+4)  // functions; thus offset by
#define TDD_GETSYSTEMTIME   (DRV_RESERVED+8)  // four each time...
#define TDD_GETDEVCAPS      (DRV_RESERVED+12) // room for future expansion
#define TDD_BEGINMINPERIOD  (DRV_RESERVED+16) // room for future expansion
#define TDD_ENDMINPERIOD    (DRV_RESERVED+20) // room for future expansion

#endif // ifndef MMNOTIMERDEV


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* RegisterWindowMessage with this to get msg id of config changes */
#define JOY_CONFIGCHANGED_MSGSTRING     "MSJSTICK_VJOYD_MSGSTR"

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_LASTENTRY                12

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

// joystick calibration info structure
typedef struct joycalibrate_tag {
    WORD    wXbase;
    WORD    wXdelta;
    WORD    wYbase;
    WORD    wYdelta;
    WORD    wZbase;
    WORD    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

// prototype for joystick message function
typedef DWORD (JOYDEVMSGPROC)(DWORD, UINT, LONG, LONG);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

// messages sent to joystick driver's DriverProc() function
#define JDD_GETNUMDEVS          (DRV_RESERVED + 0x0001)
#define JDD_GETDEVCAPS          (DRV_RESERVED + 0x0002)
#define JDD_GETPOS              (DRV_RESERVED + 0x0101)
#define JDD_SETCALIBRATION      (DRV_RESERVED + 0x0102)
#define JDD_CONFIGCHANGED       (DRV_RESERVED + 0x0103)
#define JDD_GETPOSEX            (DRV_RESERVED + 0x0104)

#endif // ifndef MMNOJOYDEV

#ifndef MAKELRESULT
#define MAKELRESULT(low, high)   ((LRESULT)MAKELONG(low, high))
#endif//MAKELRESULT


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/


// internal MCI messages
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

// string return values only used with MAKEMCIRESOURCE
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

// resource string return values
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

#define MCI_TABLE_NOT_PRESENT   ((UINT)-1)
// parameters for internal version of MCI_OPEN message sent from
// mciOpenDevice() to the driver
typedef struct {
    MCIDEVICEID wDeviceID;             // device ID
    LPCWSTR     lpstrParams;           // parameter string for entry in SYSTEM.INI
    UINT        wCustomCommandTable;   // custom command table ((-1) if none)
                                       // filled in by the driver
    UINT        wType;                 // driver type
                                       // filled in by the driver
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

// maximum length of an MCI device type
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

// flags for mciSendCommandInternal() which direct mciSendString() how to
// interpret the return value
#define MCI_RESOURCE_RETURNED       0x00010000  // resource ID
#define MCI_COLONIZED3_RETURN       0x00020000  // colonized ID, 3 bytes data
#define MCI_COLONIZED4_RETURN       0x00040000  // colonized ID, 4 bytes data
#define MCI_INTEGER_RETURNED        0x00080000  // integer conversion needed
#define MCI_RESOURCE_DRIVER         0x00100000  // driver owns returned resource

// invalid command table ID
#define MCI_NO_COMMAND_TABLE    ((UINT)(-1))

// command table information type tags
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9
#define MCI_HWND               10
#define MCI_HPAL               11
#define MCI_HDC                12

// function prototypes for MCI driver functions
DWORD_PTR APIENTRY mciGetDriverData(MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData);
UINT      APIENTRY mciDriverYield (MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciDriverNotify (HANDLE hwndCallback, MCIDEVICEID wDeviceID,
    UINT uStatus);
UINT  APIENTRY mciLoadCommandResource(HANDLE hInstance,
    LPCWSTR lpResName, UINT wType);
BOOL  APIENTRY mciFreeCommandResource(UINT wTable);

#endif // ifndef MMNOMCIDEV


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

// error return values
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

// task support function prototypes
#ifdef  BUILDDLL                                            /* ;Internal */
typedef VOID (FAR PASCAL TASKCALLBACK) (DWORD dwInst);      /* ;Internal */
#else                                                       /* ;Internal */
typedef VOID (TASKCALLBACK) (DWORD dwInst);
#endif  // ifdef BUILDDLL                                   /* ;Internal */

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE FAR * lph, DWORD_PTR dwInst);
VOID    APIENTRY mmTaskBlock(DWORD h);
BOOL    APIENTRY mmTaskSignal(DWORD h);
VOID    APIENTRY mmTaskYield(VOID);
DWORD   APIENTRY mmGetCurrentTask(VOID);

#endif // endif MMNOTASKDEV

#define MMDDKINC

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "poppack.h"        /* Revert to default packing */

#endif /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\windows\inc\xmv.h ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       decoder.h
 *  Content:    The main definitions for the XMV decoder.
 *
 ****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _XMVDecoder XMVDecoder;

/*
 * Just use an enum for the result, only 4 possibilities anyway.
 */

typedef enum _XMVRESULT
{
    XMV_NOFRAME,
    XMV_NEWFRAME,
    XMV_ENDOFFILE,
    XMV_FAIL
}
XMVRESULT;

/*
 * Describes the general attributes of the XMV file.
 */

typedef struct _XMVVideoDescriptior
{
    // The geometry of the video.  The surface that each frame is rendered
    // onto must be exactly this size.  If width and height are zero then 
    // there is no video stream in this file.
    //
    DWORD Width;
    DWORD Height;

    // The frame rate of the file.
    DWORD FramesPerSecond;

    // The number of audio streams encoded in this file.
    DWORD AudioStreamCount;
}
XMVVideoDescriptor;

/*
 * The audio descriptor of the XMV files.
 */

typedef struct _XMVAudioDescriptor
{
    // The WAVE_FORMAT tag that describes how the audio data in the stream is
    // encoded.  This can be either WAVE_FORMAT_PCM or WAVE_FORMAT_ADPCM.
    //
    DWORD WaveFormat;

    // The number of channels in the audio stream.  Can be 1, 2, 4 or 6.
    DWORD ChannelCount;

    // The number of samples per second (Hz) in the audio stream.
    DWORD SamplesPerSecond;

    // The number of bits in each sample.  
    DWORD BitsPerSample;
}
XMVAudioDescriptor;

/*
 * Create the decoder, load the headers from the movie file and create
 * all of the video decoding buffers.
 */

HRESULT XMVCreateDecoder(char *szFileName, XMVDecoder **ppDecoder);

/*
 * Destroy decoder, freeing all memory and closing the input file.
 */

void XMVCloseDecoder(XMVDecoder *pDecoder);

/*
 * Get the general information about the file.
 */

void XMVGetVideoDescriptor(XMVDecoder *pDecoder, XMVVideoDescriptor *pVideoDescriptor);

/*
 * Get information about a specific audio stream.
 */

void XMVGetAudioDescriptor(XMVDecoder *pDecoder, DWORD AudioStream, XMVAudioDescriptor *pAudioDescriptor);

/*
 * Tell the decoder to play one of the audio tracks in the XMV file.  The 
 * caller can optionally get the IDirectSoundStream interface to manually
 * adjust the sound parameters.
 *
 * This API can be called multiple times for different streams to allow
 * them to be played at the same time.
 *
 * The Flags and pMixBins parameters are used when creating the stream.  
 * These can be safely set to zero and NULL, respectively.
 *
 * ppStream may be NULL if the caller does not want direct access to the
 * stream.
 */

HRESULT XMVEnableAudioStream(XMVDecoder *pDecoder, DWORD AudioStream, DWORD Flags, DSMIXBINS *pMixBins, IDirectSoundStream **ppStream);

/*
 * Get the next frame to display.
 *
 * This method has four possible return values:
 *
 *   XMV_NOFRAME - There is no new data and the passed-in surface
 *       is unchanged.
 *
 *   XMV_NEWFRAME - The surface contains a new frame that needs to be
 *       displayed.
 *
 *   XMV_ENDOFILE - The movie is over, throw your trash away and go home.
 *
 *   XMV_FAIL - Some major catastrophy happened that prevents the video from
 *       being decoded any further.  This only happens with major data 
 *       corruption or some kind of read error.
 *
 * The Width and Height of the surface must match that of the video.
 *
 * This method must be called occasionally even if there is no video in the
 * input file, simply pass NULL for the surface.
 */

XMVRESULT XMVGetNextFrame(XMVDecoder *pDecoder, D3DSurface *pSurface);

/*
 * Get the current frame.  This will not decode the next frame.
 *
 * This method cannot fail.  If it is called before the first call to 
 * GetNextFrame then the surface will be black.  If it's called after the end
 * of the file then it will return the very last frame.
 *
 * The passed-in surface does not have to have the same format as the one
 * passed into GetNextFrame.
 */

void XMVGetCurrentFrame(XMVDecoder *pDecoder, D3DSurface *pSurface);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\windows\inc\rmxftmpl.h ===
/* D3DRM XFile templates in binary form */
/* Copyright Microsoft Corporation 2000 - 2001. All Rights Reserved */

#ifndef _RMXFTMPL_H_
#define _RMXFTMPL_H_

unsigned char D3DRM_XTEMPLATES[] = {
	0x78, 0x6f, 0x66, 0x20, 0x30, 0x33, 0x30, 0x32, 0x62, 
	0x69, 0x6e, 0x20, 0x30, 0x30, 0x36, 0x34, 0x1f, 0, 0x1, 
	0, 0x6, 0, 0, 0, 0x48, 0x65, 0x61, 0x64, 0x65, 
	0x72, 0xa, 0, 0x5, 0, 0x43, 0xab, 0x82, 0x3d, 0xda, 
	0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
	0x33, 0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x6d, 
	0x61, 0x6a, 0x6f, 0x72, 0x14, 0, 0x28, 0, 0x1, 0, 
	0x5, 0, 0, 0, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x14, 
	0, 0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x66, 
	0x6c, 0x61, 0x67, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
	0x6f, 0x72, 0xa, 0, 0x5, 0, 0x5e, 0xab, 0x82, 0x3d, 
	0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 
	0xe4, 0x33, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 0, 
	0x78, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
	0, 0x79, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
	0, 0, 0x7a, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x73, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x44, 0x3f, 0xf2, 
	0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
	0, 0x75, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
	0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x34, 0x78, 0x34, 0xa, 0, 0x5, 0, 0x45, 0x3f, 
	0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
	0x33, 0x35, 0x94, 0xa3, 0x34, 0, 0x2a, 0, 0x1, 0, 
	0x6, 0, 0, 0, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 
	0xe, 0, 0x3, 0, 0x10, 0, 0, 0, 0xf, 0, 
	0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 
	0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
	0x41, 0xa, 0, 0x5, 0, 0xe0, 0x44, 0xff, 0x35, 0x7c, 
	0x6c, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 
	0xa3, 0x2a, 0, 0x1, 0, 0x3, 0, 0, 0, 0x72, 
	0x65, 0x64, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 
	0, 0, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x14, 0, 0x2a, 
	0, 0x1, 0, 0x4, 0, 0, 0, 0x62, 0x6c, 0x75, 
	0x65, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 0, 
	0, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 
	0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0xa, 0, 0x5, 0, 
	0x81, 0x6e, 0xe1, 0xd3, 0x35, 0x78, 0xcf, 0x11, 0x8f, 0x52, 
	0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 
	0x3, 0, 0, 0, 0x72, 0x65, 0x64, 0x14, 0, 0x2a, 
	0, 0x1, 0, 0x5, 0, 0, 0, 0x67, 0x72, 0x65, 
	0x65, 0x6e, 0x14, 0, 0x2a, 0, 0x1, 0, 0x4, 0, 
	0, 0, 0x62, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x49, 0x6e, 
	0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0xa, 0, 0x5, 0, 0x20, 0xb8, 0x30, 0x16, 0x42, 0x78, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x69, 0x6e, 
	0x64, 0x65, 0x78, 0x14, 0, 0x1, 0, 0x9, 0, 0, 
	0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 
	0x1, 0, 0xa, 0, 0, 0, 0x69, 0x6e, 0x64, 0x65, 
	0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 
	0x6f, 0x6c, 0x65, 0x61, 0x6e, 0xa, 0, 0x5, 0, 0xa0, 
	0xa6, 0x7d, 0x53, 0x37, 0xca, 0xd0, 0x11, 0x94, 0x1c, 0, 
	0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 0, 0x9, 
	0, 0, 0, 0x74, 0x72, 0x75, 0x65, 0x66, 0x61, 0x6c, 
	0x73, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0x9, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 
	0x6e, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x63, 0xae, 0x85, 
	0x48, 0xe8, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x1, 0, 0x7, 0, 0, 0, 0x42, 
	0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 
	0, 0, 0x75, 0x14, 0, 0x1, 0, 0x7, 0, 0, 
	0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 
	0x1, 0, 0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 
	0, 0x1, 0, 0xc, 0, 0, 0, 0x4d, 0x61, 0x74, 
	0x65, 0x72, 0x69, 0x61, 0x6c, 0x57, 0x72, 0x61, 0x70, 0xa, 
	0, 0x5, 0, 0x60, 0xae, 0x85, 0x48, 0xe8, 0x78, 0xcf, 
	0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
	0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 
	0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 0x75, 0x14, 
	0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 
	0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 
	0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0xf, 
	0, 0, 0, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 
	0x46, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0xa, 0, 
	0x5, 0, 0xe1, 0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 
	0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x31, 0, 
	0x1, 0, 0x8, 0, 0, 0, 0x66, 0x69, 0x6c, 0x65, 
	0x6e, 0x61, 0x6d, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x8, 0, 0, 0, 0x4d, 0x61, 0x74, 0x65, 
	0x72, 0x69, 0x61, 0x6c, 0xa, 0, 0x5, 0, 0x4d, 0xab, 
	0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 
	0xaf, 0x71, 0xe4, 0x33, 0x1, 0, 0x9, 0, 0, 0, 
	0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 0x1, 
	0, 0x9, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x43, 
	0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x2a, 0, 0x1, 0, 
	0x5, 0, 0, 0, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x14, 
	0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6c, 
	0x6f, 0x72, 0x52, 0x47, 0x42, 0x1, 0, 0xd, 0, 0, 
	0, 0x73, 0x70, 0x65, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x43, 
	0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x1, 0, 0x8, 0, 
	0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
	0x1, 0, 0xd, 0, 0, 0, 0x65, 0x6d, 0x69, 0x73, 
	0x73, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 
	0, 0xe, 0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 
	0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x8, 0, 0, 
	0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 0xa, 
	0, 0x5, 0, 0x5f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
	0, 0x1, 0, 0x12, 0, 0, 0, 0x6e, 0x46, 0x61, 
	0x63, 0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 
	0x64, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 
	0, 0x1, 0, 0x11, 0, 0, 0, 0x66, 0x61, 0x63, 
	0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 
	0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 0, 0x12, 0, 
	0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x56, 0x65, 0x72, 
	0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 
	0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xd, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 
	0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x73, 0xa, 0, 0x5, 
	0, 0xc0, 0xc5, 0x1e, 0xed, 0xa8, 0xc0, 0xd0, 0x11, 0x94, 
	0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 
	0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
	0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 
	0x14, 0, 0x34, 0, 0x1, 0, 0x9, 0, 0, 0, 
	0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x32, 0x64, 0x1, 
	0, 0xe, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x57, 
	0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0xe, 
	0, 0x1, 0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 
	0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 
	0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x11, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
	0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 
	0x72, 0x64, 0x73, 0xa, 0, 0x5, 0, 0x40, 0x3f, 0xf2, 
	0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xe, 0, 0, 
	0, 0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 
	0x6f, 0x6f, 0x72, 0x64, 0x73, 0x14, 0, 0x34, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x73, 0x32, 0x64, 0x1, 0, 0xd, 0, 0, 0, 0x74, 
	0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 0x72, 
	0x64, 0x73, 0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 
	0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 
	0x6f, 0x72, 0x64, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x4d, 0x65, 
	0x73, 0x68, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 
	0x4c, 0x69, 0x73, 0x74, 0xa, 0, 0x5, 0, 0x42, 0x3f, 
	0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
	0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 0, 
	0, 0, 0x6e, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 
	0x6c, 0x73, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 0, 
	0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x49, 0x6e, 0x64, 
	0x65, 0x78, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 0, 
	0x1, 0, 0xb, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xe, 0, 0x1, 
	0, 0xc, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xf, 0, 0x14, 
	0, 0xe, 0, 0x1, 0, 0x8, 0, 0, 0, 0x4d, 
	0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x4d, 
	0x65, 0x73, 0x68, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xa, 0, 0x5, 0, 0x43, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0x8, 0, 0, 0, 0x6e, 0x4e, 
	0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
	0x6f, 0x72, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x6f, 
	0x72, 0x6d, 0x61, 0x6c, 0x73, 0xe, 0, 0x1, 0, 0x8, 
	0, 0, 0, 0x6e, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 
	0x73, 0xf, 0, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 
	0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x4e, 0x6f, 
	0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 0x1, 
	0, 0x8, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 
	0x61, 0x63, 0x65, 0x1, 0, 0xb, 0, 0, 0, 0x66, 
	0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xe, 0, 0x1, 0, 0xc, 0, 0, 0, 0x6e, 0x46, 
	0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
	0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0x10, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x56, 0x65, 
	0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 
	0xa, 0, 0x5, 0, 0x21, 0xb8, 0x30, 0x16, 0x42, 0x78, 
	0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
	0x29, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 0x56, 
	0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0xc, 0, 0, 
	0, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 
	0x6c, 0x6f, 0x72, 0x1, 0, 0xc, 0, 0, 0, 0x76, 
	0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
	0x73, 0xe, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 
	0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 
	0x72, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x4, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
	0xa, 0, 0x5, 0, 0x44, 0xab, 0x82, 0x3d, 0xda, 0x62, 
	0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
	0x29, 0, 0x1, 0, 0x9, 0, 0, 0, 0x6e, 0x56, 
	0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 
	0, 0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 
	0x74, 0x6f, 0x72, 0x1, 0, 0x8, 0, 0, 0, 0x76, 
	0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 
	0, 0x9, 0, 0, 0, 0x6e, 0x56, 0x65, 0x72, 0x74, 
	0x69, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0x29, 0, 
	0x1, 0, 0x6, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 
	0x65, 0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0x8, 0, 
	0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 
	0x1, 0, 0x5, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
	0x73, 0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x6e, 
	0x46, 0x61, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xe, 
	0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0x14, 0, 0, 0, 0x46, 
	0x72, 0x61, 0x6d, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 
	0x6f, 0x72, 0x6d, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78, 0xa, 
	0, 0x5, 0, 0x41, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 0xcf, 
	0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
	0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x34, 0x78, 0x34, 0x1, 0, 0xb, 0, 0, 0, 
	0x66, 0x72, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x74, 0x72, 0x69, 
	0x78, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x46, 0x72, 0x61, 0x6d, 0x65, 0xa, 0, 
	0x5, 0, 0x46, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 
	0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 0, 
	0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 0, 
	0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 0x46, 0x6c, 
	0x6f, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73, 0xa, 0, 0x5, 
	0, 0xa9, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 0x8f, 
	0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 
	0, 0x7, 0, 0, 0, 0x6e, 0x56, 0x61, 0x6c, 0x75, 
	0x65, 0x73, 0x14, 0, 0x34, 0, 0x2a, 0, 0x1, 0, 
	0x6, 0, 0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 
	0xe, 0, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x56, 
	0x61, 0x6c, 0x75, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 
	0x69, 0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 
	0x65, 0x79, 0x73, 0xa, 0, 0x5, 0, 0x80, 0xb1, 0x6, 
	0xf4, 0x3b, 0x7b, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
	0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x4, 0, 0, 
	0, 0x74, 0x69, 0x6d, 0x65, 0x14, 0, 0x1, 0, 0x9, 
	0, 0, 0, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
	0x79, 0x73, 0x1, 0, 0x6, 0, 0, 0, 0x74, 0x66, 
	0x6b, 0x65, 0x79, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0xc, 0, 0, 0, 0x41, 0x6e, 0x69, 0x6d, 
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0xa, 0, 
	0x5, 0, 0xa8, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 
	0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 
	0x1, 0, 0x7, 0, 0, 0, 0x6b, 0x65, 0x79, 0x54, 
	0x79, 0x70, 0x65, 0x14, 0, 0x29, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x6e, 0x4b, 0x65, 0x79, 0x73, 0x14, 0, 
	0x34, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 0x69, 
	0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
	0x79, 0x73, 0x1, 0, 0x4, 0, 0, 0, 0x6b, 0x65, 
	0x79, 0x73, 0xe, 0, 0x1, 0, 0x5, 0, 0, 0, 
	0x6e, 0x4b, 0x65, 0x79, 0x73, 0xf, 0, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x70, 
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa, 0, 0x5, 0, 0xc0, 
	0x56, 0xbf, 0xe2, 0xf, 0x84, 0xcf, 0x11, 0x8f, 0x52, 0, 
	0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 
	0, 0, 0, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x6c, 0x6f, 
	0x73, 0x65, 0x64, 0x14, 0, 0x29, 0, 0x1, 0, 0xf, 
	0, 0, 0, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
	0x6e, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x14, 0, 
	0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 
	0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xa, 
	0, 0x5, 0, 0x4f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 
	0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 
	0x74, 0xa, 0, 0x5, 0, 0x50, 0xab, 0x82, 0x3d, 0xda, 
	0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
	0x33, 0xe, 0, 0x1, 0, 0x9, 0, 0, 0, 0x41, 
	0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xf, 0, 
	0xb, 0, 0x1f, 0, 0x1, 0, 0xa, 0, 0, 0, 
	0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 
	0xa, 0, 0x5, 0, 0xa0, 0xee, 0x23, 0x3a, 0xb1, 0x94, 
	0xd0, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
	0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x42, 0x49, 
	0x4e, 0x41, 0x52, 0x59, 0xf, 0, 0xb, 0, 0x1f, 0, 
	0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 0x6c, 0xa, 
	0, 0x5, 0, 0xa1, 0xee, 0x23, 0x3a, 0xb1, 0x94, 0xd0, 
	0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
	0, 0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 
	0x6c, 0x73, 0x14, 0, 0x34, 0, 0x31, 0, 0x1, 0, 
	0x4, 0, 0, 0, 0x75, 0x72, 0x6c, 0x73, 0xe, 0, 
	0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 0x6c, 
	0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
	0, 0xf, 0, 0, 0, 0x50, 0x72, 0x6f, 0x67, 0x72, 
	0x65, 0x73, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x65, 0x73, 0x68, 
	0xa, 0, 0x5, 0, 0x60, 0xc3, 0x63, 0x8a, 0x7d, 0x99, 
	0xd0, 0x11, 0x94, 0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 
	0xe, 0, 0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 
	0x6c, 0x13, 0, 0x1, 0, 0xa, 0, 0, 0, 0x49, 
	0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 0xf, 
	0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x4, 0, 0, 
	0, 0x47, 0x75, 0x69, 0x64, 0xa, 0, 0x5, 0, 0xe0, 
	0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 
	0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x31, 0x14, 0, 
	0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x64, 0x61, 
	0x74, 0x61, 0x32, 0x14, 0, 0x28, 0, 0x1, 0, 0x5, 
	0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x33, 0x14, 0, 
	0x34, 0, 0x2d, 0, 0x1, 0, 0x5, 0, 0, 0, 
	0x64, 0x61, 0x74, 0x61, 0x34, 0xe, 0, 0x3, 0, 0x8, 
	0, 0, 0, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 
	0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 0x72, 
	0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 
	0x79, 0xa, 0, 0x5, 0, 0xe0, 0x21, 0xf, 0x7f, 0xe1, 
	0xbf, 0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 
	0x71, 0x31, 0, 0x1, 0, 0x3, 0, 0, 0, 0x6b, 
	0x65, 0x79, 0x14, 0, 0x31, 0, 0x1, 0, 0x5, 0, 
	0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 
	0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x50, 
	0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x42, 0x61, 0x67, 
	0xa, 0, 0x5, 0, 0xe1, 0x21, 0xf, 0x7f, 0xe1, 0xbf, 
	0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 
	0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 
	0x72, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 
	0x74, 0x79, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xe, 0, 0, 0, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 
	0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0xa, 0, 
	0x5, 0, 0xa0, 0x6a, 0x11, 0x98, 0xba, 0xbd, 0xd1, 0x11, 
	0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 0x1, 0, 
	0x4, 0, 0, 0, 0x47, 0x75, 0x69, 0x64, 0x1, 0, 
	0x12, 0, 0, 0, 0x67, 0x75, 0x69, 0x64, 0x45, 0x78, 
	0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 
	0x61, 0x6c, 0x14, 0, 0xe, 0, 0x12, 0, 0x12, 0, 
	0x12, 0, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
	0xb, 0, 0, 0, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
	0x61, 0x6e, 0x64, 0x65, 0x64, 0xa, 0, 0x5, 0, 0xa0, 
	0x5e, 0x5d, 0x7f, 0x3a, 0xd5, 0xd1, 0x11, 0x82, 0xc0, 0, 
	0xa0, 0xc9, 0x69, 0x72, 0x71, 0x29, 0, 0x1, 0, 0xc, 
	0, 0, 0, 0x62, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
	0x61, 0x6e, 0x64, 0x65, 0x64, 0x14, 0, 0xb, 0
};

#define D3DRM_XTEMPLATE_BYTES 3278

#endif /* _RMXFTMPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\asdf.h ===
/****************************** Module Header ******************************\
* Copyright (c) 1991-1998 Microsoft Corporation
*
* Module Name: ASDF.H
*
* This header contains all structures and constants needed for manipulating
* ASDF format data files.
*
* History:
* 10-02-91 DarrinM      Created.
* 08-17-92 DarrinM      Recreated in a RIFF compatible fashion.
\***************************************************************************/

#include <mmsystem.h>

// RIFF chunk header.

typedef struct _RTAG {
    FOURCC ckID;
    DWORD ckSize;
} RTAG, *PRTAG;


// Valid TAG types.

// 'ANI ' - simple ANImation file

#define FOURCC_ACON  mmioFOURCC('A', 'C', 'O', 'N')


// 'anih' - ANImation Header
// Contains an ANIHEADER structure.

#define FOURCC_anih mmioFOURCC('a', 'n', 'i', 'h')


// 'rate' - RATE table (array of jiffies)
// Contains an array of JIFs.  Each JIF specifies how long the corresponding
// animation frame is to be displayed before advancing to the next frame.
// If the AF_SEQUENCE flag is set then the count of JIFs == anih.cSteps,
// otherwise the count == anih.cFrames.

#define FOURCC_rate mmioFOURCC('r', 'a', 't', 'e')


// 'seq ' - SEQuence table (array of frame index values)
// Countains an array of DWORD frame indices.  anih.cSteps specifies how
// many.

#define FOURCC_seq  mmioFOURCC('s', 'e', 'q', ' ')


// 'fram' - list type for the icon list that follows

#define FOURCC_fram mmioFOURCC('f', 'r', 'a', 'm')

// 'icon' - Windows ICON format image (replaces MPTR)

#define FOURCC_icon mmioFOURCC('i', 'c', 'o', 'n')


// Standard tags (but for some reason not defined in MMSYSTEM.H)

#define FOURCC_INFO mmioFOURCC('I', 'N', 'F', 'O')      // INFO list
#define FOURCC_IART mmioFOURCC('I', 'A', 'R', 'T')      // Artist
#define FOURCC_INAM mmioFOURCC('I', 'N', 'A', 'M')      // Name/Title

#if 0 //in winuser.w
typedef DWORD JIF;  // in winuser.w

typedef struct _ANIHEADER {     // anih
    DWORD cbSizeof;
    DWORD cFrames;
    DWORD cSteps;
    DWORD cx, cy;
    DWORD cBitCount, cPlanes;
    JIF   jifRate;
    DWORD fl;
} ANIHEADER, *PANIHEADER;

// If the AF_ICON flag is specified the fields cx, cy, cBitCount, and
// cPlanes are all unused.  Each frame will be of type ICON and will
// contain its own dimensional information.

#define AF_ICON     0x0001L     // Windows format icon/cursor animation

#define AF_SEQUENCE 0x0002L     // Animation is sequenced
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\cklibver.h ===
// cklibver
// Check XBE library versions

#ifdef __cplusplus
extern "C" {
#endif

typedef void (*PLIB_ERROR_FUNCTION)(PXBEIMAGE_LIBRARY_VERSION, int);

int CheckLibraryApprovalStatus(PXBEIMAGE_LIBRARY_VERSION plibvXapi,
    PXBEIMAGE_LIBRARY_VERSION rglibv, int clibv, PLIB_ERROR_FUNCTION pfnErr);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\align.h ===
/*++

Copyright (c) 1988-1992  Microsoft Corporation

Module Name:

    Align.h

Abstract:

    BUGBUG

Author:

    John Rogers (JohnRo) 15-May-1991

Environment:

    This code assumes that sizeof(DWORD) >= sizeof(LPVOID).

Revision History:

    15-May-1991 JohnRo
        Created align.h for NT/LAN from OS/2 1.2 HPFS pbmacros.h.
    19-Jun-1991 JohnRo
        Make sure pointer-to-wider-then-byte doesn't get messed up.
    10-Jul-1991 JohnRo
        Added ALIGN_BYTE and ALIGN_CHAR for completeness.
    21-Aug-1991 CliffV
        Fix ROUND_DOWN_* to include ~
    03-Dec-1991 JohnRo
        Worst-case on MIPS is 8-byte alignment.
        Added COUNT_IS_ALIGNED() and POINTER_IS_ALIGNED() macros.
    26-Jun-1992 JohnRo
        RAID 9933: ALIGN_WORST should be 8 for x86 builds.

--*/

#ifndef _ALIGN_
#define _ALIGN_


// BOOL
// COUNT_IS_ALIGNED(
//     IN DWORD Count,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define COUNT_IS_ALIGNED(Count,Pow2) \
        ( ( ( (Count) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )

// BOOL
// POINTER_IS_ALIGNED(
//     IN LPVOID Ptr,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define POINTER_IS_ALIGNED(Ptr,Pow2) \
        ( ( ( ((ULONG_PTR)(Ptr)) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )


#define ROUND_DOWN_COUNT(Count,Pow2) \
        ( (Count) & (~(((LONG)(Pow2))-1)) )

#define ROUND_DOWN_POINTER(Ptr,Pow2) \
        ( (LPVOID) ROUND_DOWN_COUNT( ((ULONG_PTR)(Ptr)), (Pow2) ) )


// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~(((LONG)(Pow2))-1)) )

// LPVOID
// ROUND_UP_POINTER(
//     IN LPVOID Ptr,
//     IN DWORD Pow2
//     );

// If Ptr is not already aligned, then round it up until it is.
#define ROUND_UP_POINTER(Ptr,Pow2) \
        ( (LPVOID) ( (((ULONG_PTR)(Ptr))+(Pow2)-1) & (~(((LONG)(Pow2))-1)) ) )


// Usage: myPtr = ROUND_UP_POINTER( unalignedPtr, ALIGN_LPVOID )

#define ALIGN_BYTE              sizeof(UCHAR)
#define ALIGN_CHAR              sizeof(CHAR)
#define ALIGN_DESC_CHAR         sizeof(DESC_CHAR)
#define ALIGN_DWORD             sizeof(DWORD)
#define ALIGN_LONG              sizeof(LONG)
#define ALIGN_LPBYTE            sizeof(LPBYTE)
#define ALIGN_LPDWORD           sizeof(LPDWORD)
#define ALIGN_LPSTR             sizeof(LPSTR)
#define ALIGN_LPTSTR            sizeof(LPTSTR)
#define ALIGN_LPVOID            sizeof(LPVOID)
#define ALIGN_LPWORD            sizeof(LPWORD)
#define ALIGN_TCHAR             sizeof(TCHAR)
#define ALIGN_WCHAR             sizeof(WCHAR)
#define ALIGN_WORD              sizeof(WORD)

//
// For now, use a hardcoded constant. however, this should be visited again
// and maybe changed to sizeof(QUAD).
//

#define ALIGN_QUAD              8

#if defined(_X86_)

#define ALIGN_WORST             8

#elif defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)

//
// Worst-case alignment on MIPS is 8 bytes (for double).  Specify this here,
// in case our allocator is used for structures containing this.  (That is,
// even though NT/LAN doesn't need this for our data structures, let's be
// permissive.) The alignment requirements apply to Alpha.
//

#define ALIGN_WORST             8

#elif defined(_IA64_)

//
// IA64 note for QUAD: The NT QUAD type definition is NOT the EM 16byte quad type.
//                     Because of some NT constraints, QUAD type size cannot be changed.
//

#define ALIGN_WORST             16

#else  // none of the above

#error "Unknown alignment requirements for align.h"

#endif  // none of the above

#endif  // _ALIGN_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\certmgrd.h ===
//-----------------------------------------------------------------------------
//
// certmgrd.h - Definitions for CERTMGR.DLL as an extension of the 
//					Security Configuation Editor
//
// Copyright 1997-1998, Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef AFX_CERTMGRD_H__E5D13265_9435_11d1_A6EA_0000F803A951__INCLUDED_
#define AFX_CERTMGRD_H__E5D13265_9435_11d1_A6EA_0000F803A951__INCLUDED_

// Certificate Manager GUID for when it's an extension
// {9c7910d2-4c01-11d1-856b-00c04fb94f17}
DEFINE_GUID (CLSID_CertificateManagerExt, 0x9c7910d2, 0x4c01, 0x11d1, 0x85, 0x6b, 0x00, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);

// Certificate Manager GUID for when it's an extension of the Security Configuration Editor
// {34AB8E82-C27E-11d1-A6C0-00C04FB94F17}
DEFINE_GUID (CLSID_CertificateManagerPKPOLExt, 0x34ab8e82, 0xc27e, 0x11d1, 0xa6, 0xc0, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);

//
// Certificate Manager node IDs for extending the Security Configuration Editor
//


// Node ID for "Computer Settings/Security Settings/Public Key Policies"
// {c4a92b41-91ee-11d1-85fd-00c04fb94f17}
DEFINE_GUID (NODEID_CertMgr_SCE_COMP_PKPOL, 0xc4a92b41, 0x91ee, 0x11d1, 0x85, 0xfd, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);

// Node ID for "Computer Settings/Security Settings/Public Key Policies/Enrollment"
// {c4a92b43-91ee-11d1-85fd-00c04fb94f17}
DEFINE_GUID	(NODEID_CertMgr_SCE_COMP_PKPOL_ENROLL, 0xc4a92b43, 0x91ee, 0x11d1, 0x85, 0xfd, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);

// Node ID for "User Settings/Security Settings/Public Key Policies"
// {c4a92b40-91ee-11d1-85fd-00c04fb94f17}
DEFINE_GUID (NODEID_CertMgr_SCE_USER_PKPOL, 0xc4a92b40, 0x91ee, 0x11d1, 0x85, 0xfd, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);

// Node ID for "User Settings/Security Settings/Public Key Policies/Enrollment"
// {c4a92b42-91ee-11d1-85fd-00c04fb94f17}
DEFINE_GUID (NODEID_CertMgr_SCE_USER_PKPOL_ENROLL, 0xc4a92b42, 0x91ee, 0x11d1, 0x85, 0xfd, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);


// Registry path to store values for the Public Key Policies of the GPO.
#define CERT_PUBLIC_KEY_POLICY_REGPATH L"Software\\Policies\\Microsoft\\PublicKeyPolicy"
#define CERT_PUBLIC_KEY_POLICY_FLAGS_VALUE_NAME L"Flags"

// Set the following flag to enable the Public Key Policy for the GPO.
#define CERT_ENABLE_PUBLIC_KEY_POLICY_FLAG    0x1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\cabinet.h ===
/***    cabinet.h - Definitions for Cabinet File structure
 *
 *  Author:
 *      Benjamin W. Slivka
 *
 *  History:
 *      15-Aug-1993 bens    Initial version
 *      05-Sep-1993 bens    Added Overview section
 *      29-Nov-1993 chuckst Added disk names to folder first & next
 *                          Used "CF" consistently
 *                          Eliminated redundant cch fields
 *      09-Feb-1994 chuckst merged in some related global constants
 *      09-Mar-1994 bens    Add RESERVE defintions (for encryption)
 *      17-Mar-1994 bens    Improve comments about split CFDATA structures
 *      25-Mar-1994 bens    Add cabinet set ID
 *      13-May-1994 bens    Define bad value for iCabinet
 *
 *  Overview:
 *      This file contains definitions for the Diamond Cabinet File format.
 *      A Cabinet File exists to store one or more files.  Usually these
 *      files have been compressed, but that is not required.  It is also
 *      possible for a cabinet file to contain only a portion of a larger
 *      file.
 *
 *      In designing this format, the following goals where achieved:
 *      1) Minimize overhead in the CF format
 *         ==> Where ever possible BYTEs or USHORTs were used, rather
 *             than using LONGs, even though the latter would be easier
 *             to manipulate on certain RISC platforms.
 *      2) Support little-endian and big-endian byte ordering.
 *         ==> For simplicity on x86 systems, multi-byte numbers are
 *             stored in a little-endian form, but the code to read and
 *             write these numbers operates correctly on either type of
 *             computer.
 *
 *      A cabinet file contains the following structures in the following
 *      order:
 *          Name            Description
 *          -----------     -------------------
 *          CFHEADER        Cabinet description
 *            [CFRESERVE]   Optional RESERVED control information in CFHEADER
 *          CFFOLDER(s)     Folder descriptions
 *            [reserved]    Optional RESERVED data per folder
 *          CFFILE(s)       File descriptions
 *          CFDATA(s)       Data blocks
 *            [reserved]    Optional RESERVED data per data block
 *
 *  Data Integrity Strategy:
 *      The Cabinet File has built-in data integrity checks, since it is
 *      possible for customers to have damaged diskettes, or for accidental
 *      or malicious damage to occur.  Rather than doing an individual
 *      checksum for the entire cabinet file (which would have a dramatic
 *      impact on the speed of installation from floppy disk, since the
 *      entire file would need to be read), we have per-component
 *      checksums, and compute and check them as we read the various
 *      components of the file.
 *
 *      1)  Checksum CFHEADER
 *      2)  Store cabinet file length in CFHEADER (to detect file truncation)
 *      3)  Checksum entire set of CFFOLDER structures
 *      4)  Checksum entire set of CFFILE structures
 *      5)  Checksum each (compressed) data block independantly
 *
 *      This approach allows us to avoid reading unnecessary parts of the
 *      file cabinet (though reading all of CFFOLDER and CFFILE structures
 *      would otherwise not be required in all cases), while still providing
 *      adequate integrity checking.
 */

#ifndef INCLUDED_CABINET
#define INCLUDED_CABINET 1

//** Pack structures tightly in cabinet files!
#pragma pack(1)


/***    verCF - Cabinet File format version
 *
 *      The low-order byte is interpreted as a decimal number for the minor
 *      (1/100ths) portion of the version number.
 *      The high-order byte is interpreted as a decimal number for the major
 *      portion of the version number.
 *
 *      Examples:
 *          0x0000  0.00
 *          0x010A  1.10
 *          0x0410  4.16
 *
 *      History:
 *          1.01    Original
 *          1.02    Added flags field, changed signature
 *          1.03    Added setId,iCabinet so FDI can ensure correct cabinet
 *                      on continuation.
 */
#define verCF           0x0103      // CF version 1.03


/***    Various cabinet file limits
 *
 */
#define cMAX_FOLDERS_PER_CABINET    (ifoldMASK-1)
#define cMAX_FILES_PER_CABINET      65535


/***    cbRESERVE_XXX_MAX - Maximum size of RESERVE sections
 *
 *  NOTE: cbRESERVE_HEADER_MAX is a fair bit less than 64K because in
 *        the 16-bit version of this code, we want to have a USHORT
 *        variable that holds the size of the CFHEADER structure +
 *        the size of the CFRESERVE structure + the size of the per-header
 *        reserved data.
 */
//BUGBUG 16-Mar-1994 bens Define better bound for cbRESERVE_HEADER_MAX
#define cbRESERVE_HEADER_MAX        60000   // Fits in a USHORT
#define cbRESERVE_FOLDER_MAX          255   // Fits in a BYTE
#define cbRESERVE_DATA_MAX            255   // Fits in a BYTE


/***    ifoldXXXX - Special values for CFFILE.iFolder
 *
 */
#define ifoldMASK                    0xFFFC  // Low two bits zero
#define ifoldCONTINUED_FROM_PREV     0xFFFD
#define ifoldCONTINUED_TO_NEXT       0xFFFE
#define ifoldCONTINUED_PREV_AND_NEXT 0xFFFF

#define IS_CONTD_FORWARD(ifold) ((ifold & 0xfffe) == ifoldCONTINUED_TO_NEXT)
#define IS_CONTD_BACK(ifold) ((ifold & 0xfffd) == ifoldCONTINUED_FROM_PREV)


#ifndef MAKESIG
/***    MAKESIG - Construct a 4 byte signature
 *
 *  Entry:
 *      ch1,ch2,ch3,ch4 - four characters
 *
 *  Exit:
 *      returns unsigned long
 */
#define MAKESIG(ch1,ch2,ch3,ch4)          \
          (  ((unsigned long)ch1)      +  \
            (((unsigned long)ch2)<< 8) +  \
            (((unsigned long)ch3)<<16) +  \
            (((unsigned long)ch4)<<24) )
#endif // !MAKESIG


#define sigCFHEADER MAKESIG('M','S','C','F')  // CFHEADER signature


/***    cfhdrXXX - bit flags for cfheader.flags field
 *
 */
#define cfhdrPREV_CABINET       0x0001  // Set if previous cab/disk present
#define cfhdrNEXT_CABINET       0x0002  // Set if next cab/disk present
#define cfhdrRESERVE_PRESENT    0x0004  // Set if RESERVE_CONTROL is present

typedef unsigned long  CHECKSUM; /* checksum */
typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */

/***    CFHEADER - Cabinet File Header
 *
 */
typedef struct {
//**    LONGs are first, to ensure alignment
    long        sig;            // Cabinet File identification string
    CHECKSUM    csumHeader;     // Structure checksum (excluding csumHeader!)
    long        cbCabinet;      // Total length of file (consistency check)
    CHECKSUM    csumFolders;    // Checksum of CFFOLDER list
    COFF        coffFiles;      // Location in cabinet file of CFFILE list
    CHECKSUM    csumFiles;      // Checksum of CFFILE list

//**    SHORTs are next, to ensure alignment
    USHORT      version;        // Cabinet File version (verCF)
    USHORT      cFolders;       // Count of folders (CFIFOLDERs) in cabinet
    USHORT      cFiles;         // Count of files (CFIFILEs) in cabinet
    USHORT      flags;          // Flags to indicate optional data presence
    USHORT      setID;          // Cabinet set ID (identifies set of cabinets)
    USHORT      iCabinet;       // Cabinet number in set (0 based)
#define iCABINET_BAD    0xFFFF  // Illegal number for iCabinet

//**    If flags has the cfhdrRESERVE_PRESENT bit set, then a CFRESERVE
//      structure appears here, followed possibly by some CFHEADER reserved
//      space. The CFRESERVE structure has fields to define how much reserved
//      space is present in the CFHEADER, CFFOLDER, and CFDATA structures.
//      If CFRESERVE.cbCFHeader is non-zero, then abReserve[] immediately
//      follows the CFRESERVE structure.  Note that all of these sizes are
//      multiples of 4 bytes, to ensure structure alignment!
//
//  CFRESERVE   cfres;          // Reserve information
//  BYTE        abReserve[];    // Reserved data space
//

//**    The following fields presence depends upon the settings in the flags
//      field above.  If cfhdrPREV_CABINET is set, then there are two ASCIIZ
//      strings to describe the previous disk and cabinet.
//
//      NOTE: This "previous" cabinet is not necessarily the immediately
//            preceding cabinet!  While it usually will be, if a file is
//            continued into the current cabinet, then the "previous"
//            cabinet identifies the cabinet where the folder that contains
//            this file *starts*!  For example, if EXCEL.EXE starts in
//            cabinet excel.1 and is continued through excel.2 to excel.3,
//            then cabinet excel.3 will point back to *cabinet.1*, since
//            that is where you have to start in order to extract EXCEL.EXE.
//
//  char    szCabinetPrev[];    // Prev Cabinet filespec
//  char    szDiskPrev[];       // Prev descriptive disk name
//
//      Similarly, If cfhdrNEXT_CABINET is set, then there are two ASCIIZ
//      strings to describe the next disk and cabinet:
//
//  char    szCabinetNext[];    // Next Cabinet filespec
//  char    szDiskNext[];       // Next descriptive disk name
//
} CFHEADER; /* cfheader */


/***    CFRESERVE - Cabinet File Reserved data information
 *
 *  This structure is present in the middle of the CFHEADER structure if
 *  CFHEADER.flags has the cfhdrRESERVE_PRESENT bit set.  This structure
 *  defines the sizes of all the reserved data sections in the CFHEADER,
 *  CFFOLDER, and CFDATA structures.
 *
 *  These reserved sizes can be zero (although it would be silly to have
 *  all of them be zero), but otherwise must be a multiple of 4, to ensure
 *  structure alignment for RISC machines.
 */
typedef struct {
    USHORT  cbCFHeader;         // Size of abReserve in CFHEADER structure
    BYTE    cbCFFolder;         // Size of abReserve in CFFOLDER structure
    BYTE    cbCFData;           // Size of abReserve in CFDATA   structure
} CFRESERVE; /* cfreserve */

#define cbCF_HEADER_BAD     0xFFFF      // Bad value for CFRESERVE.cbCFHeader


/***    CFFOLDER - Cabinet Folder
 *
 *  This structure describes a partial or complete "compression unit".
 *  A folder is by definition a stream of compressed data.  To retrieve
 *  an uncompressed data from a folder, you *must* start decompressing
 *  the data at the start of the folder, regardless of how far into the
 *  folder the data you want actually starts.
 *
 *  Folders may start in one cabinet, and continue on to one or more
 *  succeeding cabinets.  In general, if a folder has been continued over
 *  a cabinet boundary, Diamond/FCI will terminate that folder as soon as
 *  the current file has been completely compressed.  Generally this means
 *  that a folder would span at most two cabinets, but if the file is really
 *  large, it could span more than two cabinets.
 *
 *  Note: CFFOLDERs actually refer to folder *fragments*, not necessarily
 *        complete folders.  You know that a CFFOLDER is the beginning of a
 *        folder (as opposed to a continuation in a subsequent cabinet file)
 *        if a file starts in it (i.e., the CFFILE.uoffFolderStart field is
 *        0).
 */
typedef struct {
    COFF    coffCabStart;       // Offset in cabinet file of first CFDATA
                                // block for this folder.

    USHORT  cCFData;            // Count of CFDATAs for this folder that
                                //  are actually in this cabinet.  Note that
                                //  a folder can continue into another cabinet
                                //  and have many more CFDATA blocks in that
                                //  cabinet, *and* a folder may have started
                                //  in a previous cabinet.  This count is
                                //  only of CFDATAs for this folder that are
                                //  (at least partially) in this cabinet.

    short   typeCompress;       // Indicates compression type for all CFDATA
                                //   blocks for this folder.  The valid values
                                //   are defined in the types.h built into
                                //   fci.h/fdi.h.

//**    If CFHEADER.flags has the cfhdrRESERVE_PRESENT bit set, and
//      CFRESERVE.cbCFFolder is non-zero, then abReserve[] appears here.
//
//  BYTE    abReserve[];        // Reserved data space
//
} CFFOLDER; /* cffolder */



/***    CFFILE - Cabinet File structure describing a single file in the cabinet
 *
 *  NOTE: iFolder is used to indicatate continuation cases, so we have to
 *        calculate the real iFolder by examining the cabinet files:
 *
 *        ifoldCONTINUED_FROM_PREV
 *            This file ends in this cabinet, but is continued from a
 *            previous cabinet.  Therefore, the portion of the file contained
 *            in *this* cabinet *must* start in the first folder.
 *
 *            NOTE: szCabinetPrev is the name of the cabinet where this file
 *                  *starts*, which is not necessarily the immediately
 *                  preceeding cabinet!  Since it only makes sense to
 *                  decompress a file from its start, the starting cabinet
 *                  is what is important!
 *
 *        ifoldCONTINUED_TO_NEXT
 *            This file starts in this cabinet, but is continued to the next
 *            cabinet.  Therfore, this file must start in the *last* folder
 *            in this cabinet.
 *
 *        ifoldCONTINUED_PREV_AND_NEXT
 *            This file is the *middle* portion of a file that started in a
 *            previous cabinet and is continued in the next cabinet.  Since
 *            this cabinet only contain this piece of a single file, there
 *            is only a single folder fragment in this cabinet.
 */
typedef struct {
    long    cbFile;             // Uncompressed size of file

    UOFF    uoffFolderStart;    // Offset in folder IN UNCOMPRESSED BYTES
                                //  of the start of this file

    USHORT  iFolder;            // Index of folder containing this file;
                                //  0 is first folder in this cabinet.
                                //  See ifoldCONTINUED_XXXX values above
                                //  for treatment of continuation files.

    USHORT  date;               // Date stamp in FAT file system format

    USHORT  time;               // Time stamp in FAT file system format

    USHORT  attribs;            // Attribute in FAT file system format

//  char    szName[];           // File name (may include path characters)
} CFFILE; /* cffile */


/***    CFDATA - Cabinet File structure describing a data block
 *
 */
typedef struct {
    CHECKSUM    csum;           // Checksum (excluding this field itself!)
                                //  of this structure and the data that
                                //  follows.  If this CFDATA structure is
                                //  continued to the next cabinet, then
                                //  the value of this field is ignored
                                //  (and set to zero).

    USHORT      cbData;         // Size of ab[] data that resides in the
                                //  current cabinet.  A CFDATA may be split
                                //  across a cabinet boundary, so this
                                //  value indicates only the amount of data
                                //  store in this cabinet.

    USHORT      cbUncomp;       // Uncompressed size of ab[] data; if this
                                //  CFDATA block is continued to the next
                                //  cabinet, then this value is zero!
                                //  If this CFDATA block the remainder of
                                //  of a CFDATA block that started in the
                                //  previous cabinet, then this value is
                                //  the total size of the uncompressed data
                                //  represented by the two CFDATA blocks!

//**    If CFHEADER.flags has the cfhdrRESERVE_PRESENT bit set, and
//      CFRESERVE.cbCFData is non-zero, then abReserve[] appears here.
//
//  BYTE        abReserve[];    // Reserved data space
//

//**    The actual data follows here, cbData bytes in length.
//
//  BYTE        ab[];           // Data
//
} CFDATA; /* cfdata */



//** Attribute Bit to use for Run after extract
#define  RUNATTRIB  0x40


//** Revert to default structure packing!
#pragma pack()

#endif // !INCLUDED_CABINET
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\atom.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    atom.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the atom manager, exported by ntdll.dll and
    ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 27-Nov-1995

Revision History:

--*/

typedef struct _RTL_ATOM_TABLE_ENTRY {
    struct _RTL_ATOM_TABLE_ENTRY *HashLink;
    USHORT HandleIndex;
    RTL_ATOM Atom;
    USHORT ReferenceCount;
    UCHAR Flags;
    UCHAR NameLength;
    WCHAR Name[ 1 ];
} RTL_ATOM_TABLE_ENTRY, *PRTL_ATOM_TABLE_ENTRY;

typedef struct _RTL_ATOM_TABLE {
    ULONG Signature;
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        FAST_MUTEX FastMutex;
    };
    union {
        RTL_HANDLE_TABLE RtlHandleTable;
        PHANDLE_TABLE ExHandleTable;
    };
    ULONG NumberOfBuckets;
    PRTL_ATOM_TABLE_ENTRY Buckets[ 1 ];
} RTL_ATOM_TABLE, *PRTL_ATOM_TABLE;

#define RTL_ATOM_TABLE_SIGNATURE (ULONG)'motA'

typedef struct _RTL_ATOM_HANDLE_TABLE_ENTRY {
    USHORT Flags;
    USHORT LockCount;
    PRTL_ATOM_TABLE_ENTRY Atom;
} RTL_ATOM_HANDLE_TABLE_ENTRY, *PRTL_ATOM_HANDLE_TABLE_ENTRY;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\Copy of crypt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

--*/

#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsubauth

#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;

#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
// end_ntsubauth

#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

// begin_ntsubauth
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
// end_ntsubauth



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

// begin_ntsubauth
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
// end_ntsubauth



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

// begin_ntsubauth
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
// end_ntsubauth


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

// begin_ntsubauth
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
// end_ntsubauth


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
// begin_ntsubauth
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;
// end_ntsubauth


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033
#define RtlGetUserSessionKeyClientBinding SystemFunction034
#define RtlCheckSignatureInFile         SystemFunction035


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

ULONG
RtlCheckSignatureInFile(
    IN PWSTR File
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\cpolstor.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  IPSEC Policy Storage Component
//  Contract Category: Directory Schema 
//	Copyright (C) 1997 Cisco Systems, Inc. All rights reserved.
//
//  File:       cpolstor.h
//
//  Contents:   C interface for access to Polstore DLL
//
//  Notes:      
/////////////////////////////////////////////////////////////////////////////
#ifndef __C_POLICY_STORAGE_H__
#define __C_POLICY_STORAGE_H__

#include "polguids.h"

// This is a structure that has the policy's name and guid in it
struct C_IPSEC_POLICY_INFO
{
    TCHAR szPolicyName[MAX_PATH];
    TCHAR szPolicyDescription[MAX_PATH];
    GUID  guidPolicyId;

    C_IPSEC_POLICY_INFO * pNextPolicyInfo;
};

STDAPI HrGetLocalIpSecPolicyList(C_IPSEC_POLICY_INFO ** ppPolicyInfoList, C_IPSEC_POLICY_INFO ** ppActivePolicyInfo);

STDAPI HrFreeLocalIpSecPolicyList(C_IPSEC_POLICY_INFO* pPolicyInfoList);

STDAPI HrSetAssignedLocalPolicy(GUID* pActivePolicyGuid);

//HrIsLocalPolicyAssigned() return values:
//	S_OK = Yes, local policy is assigned.
//  S_FALSE = No, local policy not assigned.
STDAPI HrIsLocalPolicyAssigned();

//HrIsDomainPolicyAssigned() return values:
//	S_OK = Yes, domain policy is assigned.
//  S_FALSE = No, domain policy not assigned.
STDAPI HrIsDomainPolicyAssigned();

STDAPI HrGetAssignedDomainPolicyName(LPTSTR strPolicyName, DWORD *pdwBufferSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\Copy (2) of crypt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

--*/

#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsubauth

#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;

#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
// end_ntsubauth

#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

// begin_ntsubauth
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
// end_ntsubauth



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

// begin_ntsubauth
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
// end_ntsubauth



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

// begin_ntsubauth
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
// end_ntsubauth


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

// begin_ntsubauth
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
// end_ntsubauth


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
// begin_ntsubauth
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;
// end_ntsubauth


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033
#define RtlGetUserSessionKeyClientBinding SystemFunction034
#define RtlCheckSignatureInFile         SystemFunction035


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

ULONG
RtlCheckSignatureInFile(
    IN PWSTR File
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\cryptkeys.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cryptkeys.h

Abstract:

    Keys we use for munging data

--*/

#ifndef __CRYPTKEYS_H__
#define __CRYPTKEYS_H__

#include <xcrypt.h>

#define SYMMETRIC_KEY_LEN 16

#define HARD_DRIVE_KEY_LEN SYMMETRIC_KEY_LEN
#define ONLINE_KEY_LEN SYMMETRIC_KEY_LEN
#define XBOX_SERIAL_NUMBER_LEN 12
#define RECOVERY_KEY_LEN 8
#define ETHERNET_MAC_ADDR_LEN 6
#define ONLINE_KEY_PKENC_SIZE 128

//
// Following keys can change from version to version
//
#define FACTORY_RAND_KEY "\x71\x82\xEF\xDB\x72\x55\xD0\xA9\x9B\xC6\x3E\xD6\x47\xE5\x45\x47"
#define FACTORY_RAND_KEY_LEN SYMMETRIC_KEY_LEN

#define DEVKIT_ONLINE_RAND_KEY "\x7B\x59\x2E\x4F\x81\x78\xB4\xC7\x57\x88\x53\x1B\x2E\x74\x76\x87"
//#define DEVKIT_ONLINE_RAND_KEY "\xB2\x74\xD2\x92\xFE\x16\xA0\x17\x58\x70\xDB\x61\x7B\x02\xD0\xAD"
#define DEVKIT_ONLINE_RAND_KEY_LEN SYMMETRIC_KEY_LEN

//
// Following keys must be forever fixed
//
#define RECOVERY_RAND_KEY "\xBC\x20\x05\x1A\xB5\x97\xF9\x60\x48\x37\x5A\x83\x78\x7F\xE5\x94"
#define RECOVERY_RAND_KEY_LEN SYMMETRIC_KEY_LEN

//
// TODO: Any use of this key is temporary. We should not release anything that uses this key
//
#define TEMP_RAND_KEY "\x7b\x35\xa8\xb7\x27\xed\x43\x7a\xa0\xba\xfb\x8f\xa4\x38\x61\x80"
#define TEMP_RAND_KEY_LEN SYMMETRIC_KEY_LEN
#define ZERO_KEY "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

//
// This is the struct passed between GeneratePerBoxData and WritePerBoxData
//
typedef struct _XBOX_ENCRYPTED_PER_BOX_DATA {
    char XboxSerialNumber[XBOX_SERIAL_NUMBER_LEN];
    BYTE MACAddress[ETHERNET_MAC_ADDR_LEN];
    DWORD GameRegion;
    DWORD AVRegion;
    BYTE HardDriveKey[HARD_DRIVE_KEY_LEN];
    BYTE OnlineKey[ONLINE_KEY_LEN];
} XBOX_ENCRYPTED_PER_BOX_DATA, *PXBOX_ENCRYPTED_PER_BOX_DATA;

//
// This is the struct encrypted with the online public key.
// From the perspective of the genealogy database, we only
// claim that the online key is stored here. But in reality we
// store the following struct just for information redundency.
//
typedef struct _XBOX_ENCRYPTED_ONLINE_DATA {
    BYTE OnlineKey[ONLINE_KEY_LEN];
    char XboxSerialNumber[XBOX_SERIAL_NUMBER_LEN];
    BYTE HardDriveKey[HARD_DRIVE_KEY_LEN];
    BYTE MACAddress[ETHERNET_MAC_ADDR_LEN];
    DWORD GameRegion;
    DWORD AVRegion;
} XBOX_ENCRYPTED_ONLINE_DATA, *PXBOX_ENCRYPTED_ONLINE_DATA;

//
// This is the encrypted portion of the EEPROM before encryption
//
typedef struct _XBOX_ENCRYPTED_EEPROM_DATA {
    BYTE EncHeader[28] ;
    BYTE HardDriveKey[HARD_DRIVE_KEY_LEN];
    DWORD GameRegion;
} XBOX_ENCRYPTED_EEPROM_DATA, *PXBOX_ENCRYPTED_EEPROM_DATA;

#ifdef _XBOX

__forceinline void ComputeRecoveryKey (
    IN LPBYTE pbHardDriveKey,
    OUT char* pcRecoveryKey )
{
    BYTE Digest[XC_SERVICE_DIGEST_SIZE];
    WORD* pwDigestWORD = (WORD*)(&Digest[0]);
    int i = 4;
    char* recoveryKeyMap = "AXYUDLR";
    
    XcHMAC( (LPBYTE)RECOVERY_RAND_KEY, RECOVERY_RAND_KEY_LEN,
            pbHardDriveKey, HARD_DRIVE_KEY_LEN,
            NULL, 0,
            Digest );

    RtlZeroMemory( pcRecoveryKey, RECOVERY_KEY_LEN );
    while ( --i >= 0 )
    {
        pcRecoveryKey[i] = recoveryKeyMap[ (*pwDigestWORD++) % 7 ];
    }
}

#else // _XBOX

#include <sha.h>

void shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    );

__forceinline void ComputeRecoveryKey (
    IN LPBYTE pbHardDriveKey,
    OUT char* pcRecoveryKey )
{
    BYTE Digest[A_SHA_DIGEST_LEN];
    WORD* pwDigestWORD = (WORD*)(&Digest[0]);
    int i = 4;
    char* recoveryKeyMap = "AXYUDLR";
    
    shaHmac( (LPBYTE)RECOVERY_RAND_KEY, RECOVERY_RAND_KEY_LEN,
             pbHardDriveKey, HARD_DRIVE_KEY_LEN,
             NULL, 0,
             Digest );

    RtlZeroMemory( pcRecoveryKey, RECOVERY_KEY_LEN );
    while ( --i >= 0 )
    {
        pcRecoveryKey[i] = recoveryKeyMap[ (*pwDigestWORD++) % 7 ];
    }
}

#endif // _XBOX

//
// Following key must be forever fixed
//
#define HDMORPH_RAND_KEY "\x60\x59\xE8\x2E\xDF\xBF\x7F\xD3\x23\x35\x74\x2A\x64\x8B\xB1\x2C"
#define HDMORPH_RAND_KEY_LEN SYMMETRIC_KEY_LEN

//
// Should be only used for online key
//
__forceinline void MorphKeyByHardDriveKeyEx( BYTE * pbHDKey, BYTE* key, DWORD dwKeyLen )
{
    BYTE Digest[XC_SERVICE_DIGEST_SIZE];
    BYTE RC4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    XcHMAC( (LPBYTE)HDMORPH_RAND_KEY, HDMORPH_RAND_KEY_LEN,
            pbHDKey, SYMMETRIC_KEY_LEN,
            NULL, 0,
            Digest );

    XcRC4Key( RC4KeyStruct, XC_SERVICE_DIGEST_SIZE, Digest );
    XcRC4Crypt( RC4KeyStruct, dwKeyLen, key );    
}

#ifdef _XBOX
__forceinline void MorphKeyByHardDriveKey( BYTE* key, DWORD dwKeyLen )
{
    MorphKeyByHardDriveKeyEx((LPBYTE)(*XboxHDKey), key, dwKeyLen);
}
#endif

#define KEY_MORPH_RAND_KEY1 "\x2B\xB8\xD9\xEF\xD2\x04\x6D\x9D\x1F\x39\xB1\x5B\x46\x58\x01\xD7"
#define KEY_MORPH_RAND_KEY2 "\x1E\x05\xD7\x3A\xA4\x20\x6A\x7B\xA0\x5B\xCD\xDF\xAD\x26\xD3\xDE"
#define KEY_MORPH_IV        "\x7b\x35\xa8\xb7\x27\xed\x43\x7a"

//
// Should be used to morph all other keys
//
__forceinline void MorphKeyWithKey( BYTE* morphKey, DWORD dwMorphKeyLen, BYTE* key, DWORD dwKeyLen, DWORD dwOp )
{
    BYTE DESKey[XC_SERVICE_DES3_KEYSIZE];
    BYTE DES3Table[XC_SERVICE_DES3_TABLESIZE];
    BYTE Feedback[XC_SERVICE_DES_BLOCKLEN];
    
    memcpy(Feedback, KEY_MORPH_IV, sizeof(Feedback));

    XcHMAC( (LPBYTE)KEY_MORPH_RAND_KEY1, SYMMETRIC_KEY_LEN,
            morphKey, dwMorphKeyLen,
            NULL, 0,
            DESKey );

    XcHMAC( (LPBYTE)KEY_MORPH_RAND_KEY2, SYMMETRIC_KEY_LEN,
            morphKey, dwMorphKeyLen,
            NULL, 0,
            DESKey + XC_SERVICE_DES3_KEYSIZE - XC_SERVICE_DIGEST_SIZE );

    XcDESKeyParity( DESKey, XC_SERVICE_DES3_KEYSIZE );

    XcKeyTable( XC_SERVICE_DES3_CIPHER, DES3Table, DESKey );

    XcBlockCryptCBC( XC_SERVICE_DES3_CIPHER, dwKeyLen, key, key, DES3Table, dwOp, Feedback );
}

//
// Following two routines are used to encrypt/decrypt keys that are stored on HD
//
__forceinline void EncryptKeyWithHardDriveKeyEx( BYTE * pbHDKey, BYTE* key, DWORD dwKeyLen )
{
    MorphKeyWithKey( pbHDKey, SYMMETRIC_KEY_LEN, key, dwKeyLen, XC_SERVICE_ENCRYPT );
}

__forceinline void DecryptKeyWithHardDriveKeyEx( BYTE * pbHDKey, BYTE* key, DWORD dwKeyLen )
{
    MorphKeyWithKey( pbHDKey, SYMMETRIC_KEY_LEN, key, dwKeyLen, XC_SERVICE_DECRYPT );
}


#ifdef _XBOX
__forceinline void EncryptKeyWithHardDriveKey( BYTE* key, DWORD dwKeyLen )
{
    EncryptKeyWithHardDriveKeyEx((LPBYTE)(*XboxHDKey), key, dwKeyLen);
}

__forceinline void DecryptKeyWithHardDriveKey( BYTE* key, DWORD dwKeyLen )
{
    DecryptKeyWithHardDriveKeyEx((LPBYTE)(*XboxHDKey), key, dwKeyLen);
}
#endif

#define MU_ENCRYPT_RAND_KEY "\xA7\x14\x21\x3D\x94\x46\x1E\x05\x97\x6D\xE8\x35\x21\x2A\xE5\x7C"

//
// Following two routines are used to encrypt/decrypt keys that are stored on MU
//
__forceinline void EncryptKeyWithMUKey( BYTE* key, DWORD dwKeyLen )
{
    MorphKeyWithKey( (LPBYTE)MU_ENCRYPT_RAND_KEY, SYMMETRIC_KEY_LEN, key, dwKeyLen, XC_SERVICE_ENCRYPT );
}

__forceinline void DecryptKeyWithMUKey( BYTE* key, DWORD dwKeyLen )
{
    MorphKeyWithKey( (LPBYTE)MU_ENCRYPT_RAND_KEY, SYMMETRIC_KEY_LEN, key, dwKeyLen, XC_SERVICE_DECRYPT );
}

#endif //__CRYPTKEYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dls2.h ===
/*
 
 	dls2.h
 	
 	Description:
 
 	Interface defines and structures for the DLS2 extensions of DLS.
 
 
     Written by Microsoft 1998.  Released for public use.
 
*/
 
#ifndef _INC_DLS2
#define _INC_DLS2
#ifdef XBOX
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif
#endif // XBOX

/*
     FOURCC's used in the DLS2 file, in addition to DLS1 chunks
*/
 
#define FOURCC_RGN2  mmioFOURCC('r','g','n','2')
#define FOURCC_LAR2  mmioFOURCC('l','a','r','2')
#define FOURCC_ART2  mmioFOURCC('a','r','t','2')
#define FOURCC_CDL   mmioFOURCC('c','d','l',' ')
#define FOURCC_DLID	 mmioFOURCC('d','l','i','d')
 
/*
     Articulation connection graph definitions. These are in addition to
     the definitions in the DLS1 header.
*/
 
/* Generic Sources (in addition to DLS1 sources. */
#define CONN_SRC_POLYPRESSURE		0x0007	/* Polyphonic Pressure */
#define CONN_SRC_CHANNELPRESSURE		0x0008	/* Channel Pressure */
#define CONN_SRC_VIBRATO			0x0009	/* Vibrato LFO */
#define CONN_SRC_MONOPRESSURE       	0x000a  /* MIDI Mono pressure */
 
 
/* Midi Controllers */
#define CONN_SRC_CC91			0x00db	/* Reverb Send */
#define CONN_SRC_CC93			0x00dd	/* Chorus Send */
 
 
/* Generic Destinations */
#define CONN_DST_GAIN			0x0001	/* Same as CONN_DST_ ATTENUATION, but more appropriate terminology. */
#define CONN_DST_KEYNUMBER 0x0005  /* Key Number Generator */
 
/* Audio Channel Output Destinations */
#define CONN_DST_LEFT			0x0010	/* Left Channel Send */
#define CONN_DST_RIGHT			0x0011	/* Right Channel Send */
#define CONN_DST_CENTER			0x0012	/* Center Channel Send */
#define CONN_DST_LEFTREAR			0x0013	/* Left Rear Channel Send */
#define CONN_DST_RIGHTREAR			0x0014	/* Right Rear Channel Send */
#define CONN_DST_LFE_CHANNEL		0x0015	/* LFE Channel Send */
#define CONN_DST_CHORUS			0x0080	/* Chorus Send */
#define CONN_DST_REVERB			0x0081	/* Reverb Send */
 
/* Vibrato LFO Destinations */
#define CONN_DST_VIB_FREQUENCY		0x0114	/* Vibrato Frequency */
#define CONN_DST_VIB_STARTDELAY		0x0115	/* Vibrato Start Delay */
 
/* EG1 Destinations */
#define CONN_DST_EG1_DELAYTIME		0x020B	/* EG1 Delay Time */
#define CONN_DST_EG1_HOLDTIME		0x020C	/* EG1 Hold Time */
#define CONN_DST_EG1_SHUTDOWNTIME		0x020D	/* EG1 Shutdown Time */
 
 
/*	EG2 Destinations */
#define CONN_DST_EG2_DELAYTIME		0x030F	/* EG2 Delay Time */
#define CONN_DST_EG2_HOLDTIME		0x0310	/* EG2 Hold Time */
 
 
/* Filter Destinations */
#define CONN_DST_FILTER_CUTOFF		0x0500	/* Filter Cutoff Frequency */
#define CONN_DST_FILTER_Q			0x0501	/* Filter Resonance */
 
 
/* Transforms */
#define CONN_TRN_CONVEX			0x0002	/* Convex Transform */
#define CONN_TRN_SWITCH			0x0003	/* Switch Transform */
 
 
/*	Conditional chunk operators */
 #define DLS_CDL_AND			0x0001	/* X = X & Y */
 #define DLS_CDL_OR			0x0002	/* X = X | Y */
 #define DLS_CDL_XOR			0x0003	/* X = X ^ Y */
 #define DLS_CDL_ADD			0x0004	/* X = X + Y */
 #define DLS_CDL_SUBTRACT		0x0005	/* X = X - Y */
 #define DLS_CDL_MULTIPLY		0x0006	/* X = X * Y */
 #define DLS_CDL_DIVIDE		0x0007	/* X = X / Y */
 #define DLS_CDL_LOGICAL_AND	0x0008	/* X = X && Y */
 #define DLS_CDL_LOGICAL_OR		0x0009	/* X = X || Y */
 #define DLS_CDL_LT			0x000A	/* X = (X < Y) */
 #define DLS_CDL_LE			0x000B	/* X = (X <= Y) */
 #define DLS_CDL_GT			0x000C	/* X = (X > Y) */
 #define DLS_CDL_GE			0x000D	/* X = (X >= Y) */
 #define DLS_CDL_EQ			0x000E	/* X = (X == Y) */
 #define DLS_CDL_NOT			0x000F	/* X = !X */
 #define DLS_CDL_CONST		0x0010	/* 32-bit constant */
 #define DLS_CDL_QUERY		0x0011	/* 32-bit value returned from query */
 #define DLS_CDL_QUERYSUPPORTED	0x0012	/* Test to see if query is supported by synth */
 
/*
  Loop and release
*/

#define WLOOP_TYPE_RELEASE 1

/*
  WaveLink chunk <wlnk-ck>
*/

#define F_WAVELINK_MULTICHANNEL 0x0002


/*
  DLSID queries for <cdl-ck>
*/

DEFINE_GUID(DLSID_GMInHardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_GSInHardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_XGInHardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS1, 0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS2, 0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(DLSID_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_ManufacturersID, 0xb03e1181, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_ProductID, 0xb03e1182, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

#endif	/* _INC_DLS2 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\debugfmt.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    DebugFmt.h

Abstract:

    This header file declares equates for debug print format strings.

Author:

    John Rogers (JohnRo) 11-Mar-1991

Environment:

    ifdef'ed for NT, any ANSI C environment, or none of the above (which
    implies nondebug).  The interface is portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    11-Mar-1991 JohnRo
        Created NetDebug.h.
    15-Apr-1992 JohnRo
        Extracted format equates into DebugFmt.h.

--*/


#ifndef _DEBUGFMT_
#define _DEBUGFMT_


//
// printf-style format strings for some possibly nonportable stuff...
// These are passed to NetpDbgPrint(); use with other routines at your
// own risk.
//
// Note also that FORMAT_LPVOID is preferable to FORMAT_POINTER, as
// different kinds of pointers can be different sizes.  FORMAT_POINTER
// will be deleted eventually.
//

//#define FORMAT_API_STATUS       "%lu"
#define FORMAT_CHAR             "%c"
//#define FORMAT_LPDEBUG_STRING   "%s"
#define FORMAT_DWORD            "%lu"
#define FORMAT_HEX_DWORD        "0x%08lX"
#define FORMAT_HEX_WORD         "0x%04X"
#define FORMAT_HEX_ULONG        "0x%08lX"
#define FORMAT_LONG             "%ld"
#define FORMAT_LPSTR            "%s"
#define FORMAT_LPVOID           "0x%08lX"
#define FORMAT_LPWSTR           "%ws"
//#define FORMAT_POINTER          "0x%08lX"
#define FORMAT_RPC_STATUS       "0x%08lX"
#define FORMAT_ULONG            "%lu"
#define FORMAT_WCHAR            "%wc"
#define FORMAT_WORD_ONLY        "%u"
#define FORMAT_POINTER          "%p"

#ifndef UNICODE
#define FORMAT_TCHAR            FORMAT_CHAR
#define FORMAT_LPTSTR           FORMAT_LPSTR
#else // UNICODE
#define FORMAT_TCHAR            FORMAT_WCHAR
#define FORMAT_LPTSTR           FORMAT_LPWSTR
#endif // UNICODE

#define FORMAT_NTSTATUS         "0x%08lX"



#endif // ndef _DEBUGFMT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\d3d8perfp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8perf.h
 *  Content:    Xbox Direct3D debug library API
 *
 ****************************************************************************/

#ifdef DEFINE_PERF

    DEFINE_PERF(VERTICES)

    DEFINE_PERF(SETTRANSFORM_WORLD)
    DEFINE_PERF(SETTRANSFORM_VIEW)
    DEFINE_PERF(SETTRANSFORM_PROJECTION)
    DEFINE_PERF(SETTRANSFORM_TEXTURE)

    DEFINE_PERF(PUSHBUFFER_SEGMENTS)
    DEFINE_PERF(PUSHBUFFER_WAITS)
    DEFINE_PERF(OBJECTLOCK_WAITS)
    DEFINE_PERF(PRESENT_WAITS)
    DEFINE_PERF(D3DDEVICE_BLOCKUNTILIDLE_WAITS)
    DEFINE_PERF(D3DDEVICE_BLOCKUNTILVERTICALBLANK_WAITS)
    DEFINE_PERF(D3DDEVICE_BLOCKONFENCE_WAITS)
    DEFINE_PERF(CPUSPINDURINGWAIT_TIME)
    DEFINE_PERF(UNSWIZZLING_TEXTURE_LOCKS)
    DEFINE_PERF(PUSHBUFFER_JUMPTOBEGINNING)
    DEFINE_PERF(RUNPUSHBUFFER_BYTES)

    DEFINE_PERF(REDUNDANT_SETRENDERSTATE)
    DEFINE_PERF(REDUNDANT_SETTEXTURESTATE)
    DEFINE_PERF(REDUNDANT_SETVERTEXSHADER)
    DEFINE_PERF(REDUNDANT_SETTRANSFORM)
    DEFINE_PERF(REDUNDANT_SETTEXTURE)
    DEFINE_PERF(REDUNDANT_SETPALETTE)
    DEFINE_PERF(REDUNDANT_SETSTREAMSOURCE)

    DEFINE_PERF(SETSTATE_POINTPARAMS)
    DEFINE_PERF(SETSTATE_COMBINERS)
    DEFINE_PERF(SETSTATE_TEXTURESTATE)
    DEFINE_PERF(SETSTATE_SPECFOGCOMBINER)
    DEFINE_PERF(SETSTATE_TEXTRANSFORM)
    DEFINE_PERF(SETSTATE_LIGHTS)
    DEFINE_PERF(SETSTATE_TRANSFORM)

#endif

#ifdef DEFINE_API

    /* Direct3D APIs */

    DEFINE_API(DIRECT3D_CHECKDEPTHSTENCILMATCH)
    DEFINE_API(DIRECT3D_CHECKDEVICEFORMAT)
    DEFINE_API(DIRECT3D_CHECKDEVICEMULTISAMPLETYPE)
    DEFINE_API(DIRECT3D_CHECKDEVICETYPE)
    DEFINE_API(DIRECT3D_CREATEDEVICE)
    DEFINE_API(DIRECT3D_ENUMADAPTERMODES)
    DEFINE_API(DIRECT3D_GETADAPTERDISPLAYMODE)
    DEFINE_API(DIRECT3D_GETADAPTERIDENTIFIER)
    DEFINE_API(DIRECT3D_GETADAPTERMODECOUNT)
    DEFINE_API(DIRECT3D_GETDEVICECAPS)
    DEFINE_API(DIRECT3D_SETPUSHBUFFERSIZE)

    /* D3DDevice APIs */

    DEFINE_API(D3DDEVICE_APPLYSTATEBLOCK)
    DEFINE_API(D3DDEVICE_BEGIN)
    DEFINE_API(D3DDEVICE_BEGINPUSH)
    DEFINE_API(D3DDEVICE_BEGINPUSHBUFFER)
    DEFINE_API(D3DDEVICE_BEGINSTATEBLOCK)
    DEFINE_API(D3DDEVICE_BEGINVISIBILITYTEST)
    DEFINE_API(D3DDEVICE_BLOCKONFENCE)
    DEFINE_API(D3DDEVICE_BLOCKUNTILIDLE)
    DEFINE_API(D3DDEVICE_BLOCKUNTILVERTICALBLANK)
    DEFINE_API(D3DDEVICE_CAPTURESTATEBLOCK)
    DEFINE_API(D3DDEVICE_CLEAR)
    DEFINE_API(D3DDEVICE_COPYRECTS)
    DEFINE_API(D3DDEVICE_CREATECUBETEXTURE)
    DEFINE_API(D3DDEVICE_CREATEDEPTHSTENCILSURFACE)
    DEFINE_API(D3DDEVICE_CREATEFIXUP)
    DEFINE_API(D3DDEVICE_CREATEIMAGESURFACE)
    DEFINE_API(D3DDEVICE_CREATEINDEXBUFFER)
    DEFINE_API(D3DDEVICE_CREATEPALETTE)
    DEFINE_API(D3DDEVICE_CREATEPIXELSHADER)
    DEFINE_API(D3DDEVICE_CREATEPUSHBUFFER)
    DEFINE_API(D3DDEVICE_CREATERENDERTARGET)
    DEFINE_API(D3DDEVICE_CREATESTATEBLOCK)
    DEFINE_API(D3DDEVICE_CREATETEXTURE)
    DEFINE_API(D3DDEVICE_CREATEVERTEXBUFFER)
    DEFINE_API(D3DDEVICE_CREATEVERTEXSHADER)
    DEFINE_API(D3DDEVICE_CREATEVOLUMETEXTURE)
    DEFINE_API(D3DDEVICE_DELETEPATCH)
    DEFINE_API(D3DDEVICE_DELETEPIXELSHADER)
    DEFINE_API(D3DDEVICE_DELETESTATEBLOCK)
    DEFINE_API(D3DDEVICE_DELETEVERTEXSHADER)
    DEFINE_API(D3DDEVICE_DRAWINDEXEDVERTICES)
    DEFINE_API(D3DDEVICE_DRAWINDEXEDVERTICESUP)
    DEFINE_API(D3DDEVICE_DRAWRECTPATCH)
    DEFINE_API(D3DDEVICE_DRAWTRIPATCH)
    DEFINE_API(D3DDEVICE_DRAWVERTICES)
    DEFINE_API(D3DDEVICE_DRAWVERTICESUP)
    DEFINE_API(D3DDEVICE_ENABLECC)
    DEFINE_API(D3DDEVICE_ENABLEOVERLAY)
    DEFINE_API(D3DDEVICE_END)
    DEFINE_API(D3DDEVICE_ENDPUSH)
    DEFINE_API(D3DDEVICE_ENDPUSHBUFFER)
    DEFINE_API(D3DDEVICE_ENDSTATEBLOCK)
    DEFINE_API(D3DDEVICE_ENDVISIBILITYTEST)
    DEFINE_API(D3DDEVICE_FLUSHVERTEXCACHE)
    DEFINE_API(D3DDEVICE_GETBACKBUFFER)
    DEFINE_API(D3DDEVICE_GETBACKBUFFERSCALE)
    DEFINE_API(D3DDEVICE_GETBACKMATERIAL)
    DEFINE_API(D3DDEVICE_GETCCSTATUS)
    DEFINE_API(D3DDEVICE_GETCREATIONPARAMETERS)
    DEFINE_API(D3DDEVICE_GETDEPTHSTENCILSURFACE)
    DEFINE_API(D3DDEVICE_GETDEVICECAPS)
    DEFINE_API(D3DDEVICE_GETDIRECT3D)
    DEFINE_API(D3DDEVICE_GETDISPLAYFIELDSTATUS)
    DEFINE_API(D3DDEVICE_GETDISPLAYMODE)
    DEFINE_API(D3DDEVICE_GETGAMMARAMP)
    DEFINE_API(D3DDEVICE_GETINDICES)
    DEFINE_API(D3DDEVICE_GETLIGHT)
    DEFINE_API(D3DDEVICE_GETLIGHTENABLE)
    DEFINE_API(D3DDEVICE_GETMATERIAL)
    DEFINE_API(D3DDEVICE_GETMODELVIEW)
    DEFINE_API(D3DDEVICE_GETOVERLAYUPDATESTATUS)
    DEFINE_API(D3DDEVICE_GETPALETTE)
    DEFINE_API(D3DDEVICE_GETPIXELSHADER)
    DEFINE_API(D3DDEVICE_GETPIXELSHADERCONSTANT)
    DEFINE_API(D3DDEVICE_GETPIXELSHADERFUNCTION)
    DEFINE_API(D3DDEVICE_GETPROJECTIONVIEWPORTMATRIX)
    DEFINE_API(D3DDEVICE_GETPUSHBUFFEROFFSET)
    DEFINE_API(D3DDEVICE_GETRASTERSTATUS)
    DEFINE_API(D3DDEVICE_GETRENDERSTATE)
    DEFINE_API(D3DDEVICE_GETRENDERTARGET)
    DEFINE_API(D3DDEVICE_GETSCISSORS)
    DEFINE_API(D3DDEVICE_GETSCREENSPACEOFFSET)
    DEFINE_API(D3DDEVICE_GETSHADERCONSTANTMODE)
    DEFINE_API(D3DDEVICE_GETSTREAMSOURCE)
    DEFINE_API(D3DDEVICE_GETTEXTURE)
    DEFINE_API(D3DDEVICE_GETTEXTURESTAGESTATE)
    DEFINE_API(D3DDEVICE_GETTILE)
    DEFINE_API(D3DDEVICE_GETTILECOMPRESSIONTAGS)
    DEFINE_API(D3DDEVICE_GETTRANSFORM)
    DEFINE_API(D3DDEVICE_GETVERTEXBLENDMODELVIEW)
    DEFINE_API(D3DDEVICE_GETVERTEXSHADER)
    DEFINE_API(D3DDEVICE_GETVERTEXSHADERCONSTANT)
    DEFINE_API(D3DDEVICE_GETVERTEXSHADERDECLARATION)
    DEFINE_API(D3DDEVICE_GETVERTEXSHADERFUNCTION)
    DEFINE_API(D3DDEVICE_GETVERTEXSHADERINPUT)
    DEFINE_API(D3DDEVICE_GETVERTEXSHADERSIZE)
    DEFINE_API(D3DDEVICE_GETVERTEXSHADERTYPE)
    DEFINE_API(D3DDEVICE_GETVIEWPORT)
    DEFINE_API(D3DDEVICE_GETVISIBILITYTESTRESULT)
    DEFINE_API(D3DDEVICE_INSERTCALLBACK)
    DEFINE_API(D3DDEVICE_INSERTFENCE)
    DEFINE_API(D3DDEVICE_ISBUSY)
    DEFINE_API(D3DDEVICE_ISFENCEPENDING)
    DEFINE_API(D3DDEVICE_KICKPUSHBUFFER)
    DEFINE_API(D3DDEVICE_LIGHTENABLE)
    DEFINE_API(D3DDEVICE_LOADVERTEXSHADER)
    DEFINE_API(D3DDEVICE_LOADVERTEXSHADERPROGRAM)
    DEFINE_API(D3DDEVICE_MULTIPLYTRANSFORM)
    DEFINE_API(D3DDEVICE_NOP)
    DEFINE_API(D3DDEVICE_PERSISTDISPLAY)
    DEFINE_API(D3DDEVICE_PRESENT)
    DEFINE_API(D3DDEVICE_PRIMEVERTEXCACHE)
    DEFINE_API(D3DDEVICE_READVERTEXSHADERCONSTANT)
    DEFINE_API(D3DDEVICE_RESET)
    DEFINE_API(D3DDEVICE_RESUME)
    DEFINE_API(D3DDEVICE_RUNPUSHBUFFER)
    DEFINE_API(D3DDEVICE_RUNVERTEXSTATESHADER)
    DEFINE_API(D3DDEVICE_SELECTVERTEXSHADER)
    DEFINE_API(D3DDEVICE_SENDCC)
    DEFINE_API(D3DDEVICE_SETBACKBUFFERSCALE)
    DEFINE_API(D3DDEVICE_SETBACKMATERIAL)
    DEFINE_API(D3DDEVICE_SETGAMMARAMP)
    DEFINE_API(D3DDEVICE_SETINDICES)
    DEFINE_API(D3DDEVICE_SETLIGHT)
    DEFINE_API(D3DDEVICE_SETMATERIAL)
    DEFINE_API(D3DDEVICE_SETMODELVIEW)
    DEFINE_API(D3DDEVICE_SETPALETTE)
    DEFINE_API(D3DDEVICE_SETPIXELSHADER)
    DEFINE_API(D3DDEVICE_SETPIXELSHADERCONSTANT)
    DEFINE_API(D3DDEVICE_SETPIXELSHADERPROGRAM)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_BACKFILLMODE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_CULLMODE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_DONOTCULLUNCOMPRESSED)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_DXT1NOISEENABLE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_EDGEANTIALIAS)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_FILLMODE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_FOGCOLOR)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_FRONTFACE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_LINEWIDTH)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_LOGICOP)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_MULTISAMPLEANTIALIAS)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_MULTISAMPLEMASK)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_MULTISAMPLEMODE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_MULTISAMPLERENDERTARGETMODE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_NORMALIZENORMALS)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_OCCLUSIONCULLENABLE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_PARAMETERCHECK)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_PSTEXTUREMODES)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_ROPZCMPALWAYSREAD)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_ROPZREAD)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_SHADOWFUNC)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_SIMPLE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_STENCILCULLENABLE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_STENCILENABLE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_STENCILFAIL)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_TEXTUREFACTOR)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_TWOSIDEDLIGHTING)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_VERTEXBLEND)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_YUVENABLE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_ZBIAS)
    DEFINE_API(D3DDEVICE_SETRENDERSTATE_ZENABLE)
    DEFINE_API(D3DDEVICE_SETRENDERSTATENOTINLINE)
    DEFINE_API(D3DDEVICE_SETRENDERTARGET)
    DEFINE_API(D3DDEVICE_SETSCISSORS)
    DEFINE_API(D3DDEVICE_SETSCREENSPACEOFFSET)
    DEFINE_API(D3DDEVICE_SETSHADERCONSTANTMODE)
    DEFINE_API(D3DDEVICE_SETSTREAMSOURCE)
    DEFINE_API(D3DDEVICE_SETSWAPCALLBACK)
    DEFINE_API(D3DDEVICE_SETTEXTURE)
    DEFINE_API(D3DDEVICE_SETTEXTURESTAGESTATENOTINLINE)
    DEFINE_API(D3DDEVICE_SETTEXTURESTATE_BORDERCOLOR)
    DEFINE_API(D3DDEVICE_SETTEXTURESTATE_BUMPENV)
    DEFINE_API(D3DDEVICE_SETTEXTURESTATE_COLORKEYCOLOR)
    DEFINE_API(D3DDEVICE_SETTEXTURESTATE_PARAMETERCHECK)
    DEFINE_API(D3DDEVICE_SETTEXTURESTATE_TEXCOORDINDEX)
    DEFINE_API(D3DDEVICE_SETTILE)
    DEFINE_API(D3DDEVICE_SETTRANSFORM)
    DEFINE_API(D3DDEVICE_SETVERTEXBLENDMODELVIEW)
    DEFINE_API(D3DDEVICE_SETVERTEXDATA2F)
    DEFINE_API(D3DDEVICE_SETVERTEXDATA2S)
    DEFINE_API(D3DDEVICE_SETVERTEXDATA4F)
    DEFINE_API(D3DDEVICE_SETVERTEXDATA4S)
    DEFINE_API(D3DDEVICE_SETVERTEXDATA4UB)
    DEFINE_API(D3DDEVICE_SETVERTEXDATACOLOR)
    DEFINE_API(D3DDEVICE_SETVERTEXSHADER)
    DEFINE_API(D3DDEVICE_SETVERTEXSHADERCONSTANT)
    DEFINE_API(D3DDEVICE_SETVERTEXSHADERINPUT)
    DEFINE_API(D3DDEVICE_SETVERTICALBLANKCALLBACK)
    DEFINE_API(D3DDEVICE_SETVIEWPORT)
    DEFINE_API(D3DDEVICE_SUSPEND)
    DEFINE_API(D3DDEVICE_SWITCHTEXTURE)
    DEFINE_API(D3DDEVICE_UPDATEOVERLAY)

    /* D3DResource APIs */

    DEFINE_API(D3DRESOURCE_ADDREF)
    DEFINE_API(D3DRESOURCE_BLOCKUNTILNOTBUSY)
    DEFINE_API(D3DRESOURCE_FREEPRIVATEDATA)
    DEFINE_API(D3DRESOURCE_GETDEVICE)
    DEFINE_API(D3DRESOURCE_GETPRIVATEDATA)
    DEFINE_API(D3DRESOURCE_GETTYPE)
    DEFINE_API(D3DRESOURCE_ISBUSY)
    DEFINE_API(D3DRESOURCE_REGISTER)
    DEFINE_API(D3DRESOURCE_RELEASE)
    DEFINE_API(D3DRESOURCE_SETPRIVATEDATA)

    /* D3DBaseTexture APIs */

    DEFINE_API(D3DBASETEXTURE_GETLEVELCOUNT)

    /* D3DTexture APIs */

    DEFINE_API(D3DTEXTURE_GETLEVELDESC)
    DEFINE_API(D3DTEXTURE_GETSURFACELEVEL)
    DEFINE_API(D3DTEXTURE_LOCKRECT)

    /* D3DCubeTexture APIs */

    DEFINE_API(D3DCUBETEXTURE_GETCUBEMAPSURFACE)
    DEFINE_API(D3DCUBETEXTURE_GETLEVELDESC)
    DEFINE_API(D3DCUBETEXTURE_LOCKRECT)

    /* D3DVolumeTexture APIs */

    DEFINE_API(D3DVOLUMETEXURE_GETLEVELDESC)
    DEFINE_API(D3DVOLUMETEXURE_GETVOLUMELEVEL)
    DEFINE_API(D3DVOLUMETEXURE_LOCKBOX)

    /* D3DVertexBuffer APIs */

    DEFINE_API(D3DVERTEXBUFFER_GETDESC)
    DEFINE_API(D3DVERTEXBUFFER_LOCK)

    /* D3DIndexBuffer APIs */

    DEFINE_API(D3DINDEXBUFFER_GETDESC)

    /* D3DVolume APIs */

    DEFINE_API(D3DVOLUME_GETCONTAINER)
    DEFINE_API(D3DVOLUME_GETDESC)
    DEFINE_API(D3DVOLUME_LOCKBOX)

    /* D3DSurface APIs */

    DEFINE_API(D3DSURFACE_GETCONTAINER)
    DEFINE_API(D3DSURFACE_GETDESC)
    DEFINE_API(D3DSURFACE_LOCKRECT)

    /* D3DPalette APIs */

    DEFINE_API(D3DPALETTE_GETSIZE)
    DEFINE_API(D3DPALETTE_LOCK)

    /* D3DPushBuffer APIs */

    DEFINE_API(D3DPUSHBUFFER_BEGINFIXUP)
    DEFINE_API(D3DPUSHBUFFER_ENDFIXUP)
    DEFINE_API(D3DPUSHBUFFER_ENDVISIBILITYTEST)
    DEFINE_API(D3DPUSHBUFFER_JUMP)
    DEFINE_API(D3DPUSHBUFFER_RUNPUSHBUFFER)
    DEFINE_API(D3DPUSHBUFFER_SETMODELVIEW)
    DEFINE_API(D3DPUSHBUFFER_SETPALETTE)
    DEFINE_API(D3DPUSHBUFFER_SETRENDERTARGET)
    DEFINE_API(D3DPUSHBUFFER_SETTEXTURE)
    DEFINE_API(D3DPUSHBUFFER_SETVERTEXBLENDMODELVIEW)
    DEFINE_API(D3DPUSHBUFFER_SETVERTEXSHADERCONSTANT)
    DEFINE_API(D3DPUSHBUFFER_SETVERTEXSHADERINPUT)
    DEFINE_API(D3DPUSHBUFFER_VERIFY)

    /* D3DFixup APIs */

    DEFINE_API(D3DFIXUP_GETSIZE)
    DEFINE_API(D3DFIXUP_GETSPACE)
    DEFINE_API(D3DFIXUP_RESET)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dmdls.h ===
/************************************************************************
*                                                                       *
*   dmdls.h -- DLS download definitions for DirectMusic API's           *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation                       *
*                                                                       *
************************************************************************/

#ifndef _DMDLS_
#define _DMDLS_

#include "dls1.h"

typedef long PCENT;     /* Pitch cents */
typedef long GCENT;     /* Gain cents */
typedef long TCENT;     /* Time cents */
typedef long PERCENT;   /* Per.. cent! */

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

#if defined(XBOX) && defined(MAKEFOURCC) && !defined(MAKE_FOURCC)
#define MAKE_FOURCC
#endif // XBOX, etc.

#ifndef MAKE_FOURCC
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))


typedef DWORD           FOURCC;         /* a four character code */
#endif

typedef struct _DMUS_DOWNLOADINFO
{
    DWORD dwDLType;                     /* Instrument or Wave */
    DWORD dwDLId;                       /* Unique identifier to tag this download. */
    DWORD dwNumOffsetTableEntries;      /* Number of index in the offset address table. */
    DWORD cbSize;                       /* Total size of this memory chunk. */
} DMUS_DOWNLOADINFO;

#define DMUS_DOWNLOADINFO_INSTRUMENT        1
#define DMUS_DOWNLOADINFO_WAVE              2
#define DMUS_DOWNLOADINFO_INSTRUMENT2       3   /* New version for better DLS2 support. */

/* Support for oneshot and streaming wave data 
 */
#define DMUS_DOWNLOADINFO_WAVEARTICULATION  4   /* Wave articulation data */
#define DMUS_DOWNLOADINFO_STREAMINGWAVE     5   /* One chunk of a streaming */
#define DMUS_DOWNLOADINFO_ONESHOTWAVE       6

#define DMUS_DEFAULT_SIZE_OFFSETTABLE   1

/* Flags for DMUS_INSTRUMENT's ulFlags member */
 
#define DMUS_INSTRUMENT_GM_INSTRUMENT   (1 << 0)

typedef struct _DMUS_OFFSETTABLE
{
    ULONG ulOffsetTable[DMUS_DEFAULT_SIZE_OFFSETTABLE];
} DMUS_OFFSETTABLE;

typedef struct _DMUS_INSTRUMENT
{
    ULONG           ulPatch;
    ULONG           ulFirstRegionIdx;             
    ULONG           ulGlobalArtIdx;         /* If zero the instrument does not have an articulation */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the instrument */
    ULONG           ulCopyrightIdx;         /* If zero no Copyright information associated with the instrument */
    ULONG           ulFlags;                        
} DMUS_INSTRUMENT;

typedef struct _DMUS_REGION
{
    RGNRANGE        RangeKey;
    RGNRANGE        RangeVelocity;
    USHORT          fusOptions;
    USHORT          usKeyGroup;
    ULONG           ulRegionArtIdx;         /* If zero the region does not have an articulation */
    ULONG           ulNextRegionIdx;        /* If zero no more regions */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the region */
    WAVELINK        WaveLink;
    WSMPL           WSMP;                   /*  If WSMP.cSampleLoops > 1 then a WLOOP is included */
    WLOOP           WLOOP[1];
} DMUS_REGION;

typedef struct _DMUS_LFOPARAMS
{
    PCENT       pcFrequency;
    TCENT       tcDelay;
    GCENT       gcVolumeScale;
    PCENT       pcPitchScale;
    GCENT       gcMWToVolume;
    PCENT       pcMWToPitch;
} DMUS_LFOPARAMS;

typedef struct _DMUS_VEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
} DMUS_VEGPARAMS;

typedef struct _DMUS_PEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
    PCENT       pcRange;
} DMUS_PEGPARAMS;

typedef struct _DMUS_MSCPARAMS
{
    PERCENT     ptDefaultPan;
} DMUS_MSCPARAMS;

typedef struct _DMUS_ARTICPARAMS
{
    DMUS_LFOPARAMS   LFO;
    DMUS_VEGPARAMS   VolEG;
    DMUS_PEGPARAMS   PitchEG;
    DMUS_MSCPARAMS   Misc;
} DMUS_ARTICPARAMS;

typedef struct _DMUS_ARTICULATION           /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT format. */
{
    ULONG           ulArt1Idx;              /* DLS Level 1 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
} DMUS_ARTICULATION;

typedef struct _DMUS_ARTICULATION2          /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT2 format. */
{
    ULONG           ulArtIdx;               /* DLS Level 1/2 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
    ULONG           ulNextArtIdx;           /* Additional articulation chunks */
} DMUS_ARTICULATION2;

#define DMUS_MIN_DATA_SIZE 4       
/*  The actual number is determined by cbSize of struct _DMUS_EXTENSIONCHUNK */

typedef struct _DMUS_EXTENSIONCHUNK
{
    ULONG           cbSize;                      /*  Size of extension chunk  */
    ULONG           ulNextExtCkIdx;              /*  If zero no more 3rd party entenstion chunks */
    FOURCC          ExtCkID;                                      
    BYTE            byExtCk[DMUS_MIN_DATA_SIZE]; /*  The actual number that follows is determined by cbSize */
} DMUS_EXTENSIONCHUNK;

/*  The actual number is determined by cbSize of struct _DMUS_COPYRIGHT */

typedef struct _DMUS_COPYRIGHT
{
    ULONG           cbSize;                             /*  Size of copyright information */
    BYTE            byCopyright[DMUS_MIN_DATA_SIZE];    /*  The actual number that follows is determined by cbSize */
} DMUS_COPYRIGHT;

typedef struct _DMUS_WAVEDATA
{
    ULONG           cbSize;
    BYTE            byData[DMUS_MIN_DATA_SIZE]; 
} DMUS_WAVEDATA;

typedef struct _DMUS_WAVE
{
    ULONG           ulFirstExtCkIdx;    /* If zero no 3rd party entenstion chunks associated with the wave */
    ULONG           ulCopyrightIdx;     /* If zero no Copyright information associated with the wave */
    ULONG           ulWaveDataIdx;      /* Location of actual wave data. */
    WAVEFORMATEX    WaveformatEx;       
} DMUS_WAVE;

typedef struct _DMUS_NOTERANGE *LPDMUS_NOTERANGE;
typedef struct _DMUS_NOTERANGE
{
    DWORD           dwLowNote;  /* Sets the low note for the range of MIDI note events to which the instrument responds.*/
    DWORD           dwHighNote; /* Sets the high note for the range of MIDI note events to which the instrument responds.*/
} DMUS_NOTERANGE;

typedef struct _DMUS_WAVEARTDL
{
    ULONG               ulDownloadIdIdx;    /* Download ID's of each buffer */
    ULONG               ulBus;              /* Playback bus */
    ULONG               ulBuffers;          /* Buffers */
    ULONG               ulMasterDLId;       /* Download ID of master voice of slave group */
    USHORT              usOptions;          /* Same as DLS2 region options */
}   DMUS_WAVEARTDL,
    *LPDMUS_WAVEARTDL;

typedef struct _DMUS_WAVEDL
{
    ULONG               cbWaveData;         /* Bytes of wave data */
}   DMUS_WAVEDL,
    *LPDMUS_WAVEDL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dmksctrl.h ===
/************************************************************************
*                                                                       *
*   dmksctrl.h -- Definition of IKsControl                              *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
*                                                                       *
*   This header file contains the definition of IKsControl, which       *
*   duplicates definitions from ks.h and ksproxy.h. Your code should    *
*   include ks.h and ksproxy.h directly if you have them (they are      *
*   provided in the Windows 98 DDK and will be in the Windows NT 5      *
*   SDK).                                                               *
*                                                                       *
************************************************************************/

#ifndef _DMKSCTRL_
#define _DMKSCTRL_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)   /* Disable warnings on anonymous unions */

#include <pshpack8.h>

#include <objbase.h>

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif /* !defined(DEFINE_GUIDEX) */

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif /* !defined(STATICGUIDOF) */
#endif /* !defined(_NTRTL_) */

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif /* STATIC_IID_IKsControl */

/* 
 * Warning: This will prevent the rest of ks.h from being pulled in if ks.h is 
 * included after dmksctrl.h. Make sure you do not include both headers in
 * the same source file.
 */
#ifndef _KS_
#define _KS_

#if (defined(_MSC_EXTENSIONS) || defined(__cplusplus)) && !defined(CINTERFACE)
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#else
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        } Data;
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#endif

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY            0x10000000
#endif  /* _KS_ */

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_


#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
     /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*IKsControl*/
    STDMETHOD(KsProperty)(
        THIS_
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
};

#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsControl_ */

#include <poppack.h>

DEFINE_GUID(IID_IKsControl, 0x28F54685, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);

/* These formats are in ksmedia.h
 */
#ifndef _KSMEDIA_

DEFINE_GUID(KSDATAFORMAT_SUBTYPE_MIDI, 0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00);
DEFINE_GUID(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC, 0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif /* _DMKSCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\cryptdll.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        cryptdll.h
//
// Contents:    How to use the crypt support dll
//
//
// History:     04 Jun 92   RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __CRYPTDLL_H__
#define __CRYPTDLL_H__

typedef PVOID   PCRYPT_STATE_BUFFER;

typedef NTSTATUS (NTAPI * PCRYPT_INITIALIZE_FN)(
    PUCHAR,
    ULONG,
    ULONG,
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_ENCRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DECRYPT_FN)(
    PCRYPT_STATE_BUFFER StateBuffer,
    PUCHAR InputBuffer,
    ULONG InputBufferSize,
    PUCHAR OutputBuffer,
    PULONG OutputBufferSize
    );

typedef NTSTATUS (NTAPI * PCRYPT_DISCARD_FN)(
    PCRYPT_STATE_BUFFER *
    );

typedef NTSTATUS (NTAPI * PCRYPT_HASH_STRING_FN)(
    PUNICODE_STRING String,
    PUCHAR Buffer
    );
typedef NTSTATUS (NTAPI * PCRYPT_RANDOM_KEY_FN)(
    OPTIONAL PUCHAR Seed,
    OPTIONAL ULONG SeedLength,
    PUCHAR Key
    );

typedef NTSTATUS (NTAPI * PCRYPT_CONTROL_FN)(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    );

//
// functions for CryptControl
#define CRYPT_CONTROL_SET_INIT_VECT     0x1


typedef struct _CRYPTO_SYSTEM {
    ULONG EncryptionType;
    ULONG BlockSize;
    ULONG ExportableEncryptionType;
    ULONG KeySize;
    ULONG HeaderSize;
    ULONG PreferredCheckSum;
    ULONG Attributes;
    PWSTR Name;
    PCRYPT_INITIALIZE_FN Initialize;
    PCRYPT_ENCRYPT_FN Encrypt;
    PCRYPT_DECRYPT_FN Decrypt;
    PCRYPT_DISCARD_FN Discard;
    PCRYPT_HASH_STRING_FN HashString;
    PCRYPT_RANDOM_KEY_FN RandomKey;
    PCRYPT_CONTROL_FN Control;
} CRYPTO_SYSTEM, *PCRYPTO_SYSTEM;

#define CSYSTEM_USE_PRINCIPAL_NAME      0x01
#define CSYSTEM_EXPORT_STRENGTH         0x02
#define CSYSTEM_INTEGRITY_PROTECTED     0x04

NTSTATUS NTAPI
CDRegisterCSystem(PCRYPTO_SYSTEM);

NTSTATUS NTAPI
CDBuildVect(
    PULONG EncryptionTypesAvailable,
    PULONG EncryptionTypes
    );

NTSTATUS NTAPI
CDBuildIntegrityVect(
    PULONG      pcCSystems,
    PULONG      pdwEtypes
    );


NTSTATUS NTAPI
CDLocateCSystem(
    ULONG EncryptionType,
    PCRYPTO_SYSTEM * CryptoSystem
    );


NTSTATUS NTAPI
CDFindCommonCSystem(
    ULONG EncryptionTypeCount,
    PULONG EncryptionTypes,
    PULONG CommonEncryptionType
    );

NTSTATUS NTAPI
CDFindCommonCSystemWithKey(
    IN ULONG EncryptionEntries,
    IN PULONG EncryptionTypes,
    IN ULONG KeyTypeCount,
    IN PULONG KeyTypes,
    OUT PULONG CommonEtype
    );



////////////////////////////////////////////////////////////////////

typedef PVOID PCHECKSUM_BUFFER;

typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZE_FN)(ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_INITIALIZEEX_FN)(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
typedef NTSTATUS (NTAPI * PCHECKSUM_SUM_FN)(PCHECKSUM_BUFFER, ULONG, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINALIZE_FN)(PCHECKSUM_BUFFER, PUCHAR);
typedef NTSTATUS (NTAPI * PCHECKSUM_FINISH_FN)(PCHECKSUM_BUFFER *);

typedef struct _CHECKSUM_FUNCTION {
    ULONG CheckSumType;
    ULONG CheckSumSize;
    ULONG Attributes;
    PCHECKSUM_INITIALIZE_FN Initialize;
    PCHECKSUM_SUM_FN Sum;
    PCHECKSUM_FINALIZE_FN Finalize;
    PCHECKSUM_FINISH_FN Finish;
    PCHECKSUM_INITIALIZEEX_FN InitializeEx;
} CHECKSUM_FUNCTION, *PCHECKSUM_FUNCTION;

#define CKSUM_COLLISION     0x00000001
#define CKSUM_KEYED         0x00000002


#define CHECKSUM_SHA1       131

NTSTATUS NTAPI
CDRegisterCheckSum( PCHECKSUM_FUNCTION);


NTSTATUS NTAPI
CDLocateCheckSum( ULONG, PCHECKSUM_FUNCTION *);



//////////////////////////////////////////////////////////////



typedef BOOLEAN (NTAPI * PRANDOM_NUMBER_GENERATOR_FN)(PUCHAR, ULONG);


typedef struct _RANDOM_NUMBER_GENERATOR {
    ULONG GeneratorId;
    ULONG Attributes;
    ULONG Seed;
    PRANDOM_NUMBER_GENERATOR_FN GenerateBitstream;
} RANDOM_NUMBER_GENERATOR, *PRANDOM_NUMBER_GENERATOR;

#define RNG_PSEUDO_RANDOM   0x00000001  // Pseudo-random function
#define RNG_NOISE_CIRCUIT   0x00000002  // Noise circuit (ZNR diode, eg)
#define RNG_NATURAL_PHENOM  0x00000004  // Natural sampler (geiger counter)

BOOLEAN NTAPI
CDGenerateRandomBits(PUCHAR pBuffer,
                     ULONG  cbBuffer);

BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng);

BOOLEAN NTAPI
CDLocateRng(ULONG                       Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng);

#define CD_BUILTIN_RNG  1


///////////////////////////////////////////////////////////
//
// Error codes
//
///////////////////////////////////////////////////////////

//
// BUGBUG: these need to be moved to a real place.
//

#define SEC_E_ETYPE_NOT_SUPP            0x80080341
#define SEC_E_CHECKSUM_NOT_SUPP         0x80080342
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

--*/

#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif
/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsubauth

#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;

#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
// end_ntsubauth

#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;
/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;
/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

// begin_ntsubauth
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
// end_ntsubauth



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

// begin_ntsubauth
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
// end_ntsubauth



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;
typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

// begin_ntsubauth
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
// end_ntsubauth


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

// begin_ntsubauth
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
// end_ntsubauth


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;
/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
// begin_ntsubauth
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;
// end_ntsubauth
////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033
#define RtlGetUserSessionKeyClientBinding SystemFunction034
#define RtlCheckSignatureInFile         SystemFunction035
////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

ULONG
RtlCheckSignatureInFile(
    IN PWSTR File
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dmusbuff.h ===
/***************************************************************************
*                                                                          *
*   DMusBuff.h -- This module defines the buffer format for DirectMusic    *
*                 Shared file between user mode and kernel mode components *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusBuff_
#define _DMusBuff_

/* Format of DirectMusic events in a buffer
 *
 * A buffer contains 1 or more events, each with the following header.
 * Immediately following the header is the event data. The header+data
 * size is rounded to the nearest quadword (8 bytes).
 */
 
#include <pshpack4.h>                       /* Do not pad at end - that's where the data is */ 
typedef struct _DMUS_EVENTHEADER *LPDMUS_EVENTHEADER;
typedef struct _DMUS_EVENTHEADER
{
    DWORD           cbEvent;                /* Unrounded bytes in event */
    DWORD           dwChannelGroup;         /* Channel group of event */
    REFERENCE_TIME  rtDelta;                /* Delta from start time of entire buffer */
    DWORD           dwFlags;                /* Flags DMUS_EVENT_xxx */
} DMUS_EVENTHEADER;
#include <poppack.h>

#define DMUS_EVENT_STRUCTURED   0x00000001  /* Unstructured data (SysEx, etc.) */

/* The number of bytes to allocate for an event with 'cb' data bytes.
 */ 
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define DMUS_EVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cb)


#endif /* _DMusBuff_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dgstfile.h ===
// ---------------------------------------------------------------------------------------
// dgstfile.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __DGSTFILE_H__
#define __DGSTFILE_H__

// ---------------------------------------------------------------------------------------
// Includes
// ---------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------

//
// Define the current digest file version
//
#define DGSTFILE_VERSION_HI			((WORD)1)
#define DGSTFILE_VERSION_LO			((WORD)0)

//
// Define the various structures that constitute the digest info
//

//
// In-memory digest info
//
typedef struct 
{
	DWORD		dwSectionStart;
	DWORD		dwSectionSize;
	BYTE		rgbSignature[XCALCSIG_SIGNATURE_SIZE];

} DGST_SECTION_DATA, *PDGST_SECTION_DATA;

typedef struct
{
	CHAR				szFileName[MAX_PATH];
	DWORD				dwFileSize;
	BYTE				bFlags;
	BYTE				bReservedSize;
	WORD				wSections;
	DGST_SECTION_DATA	rgSectionData[1]; // wSections records

	// bReservedSize bytes here ...
	
} DGST_FILE_DATA, *PDGST_FILE_DATA;

typedef struct
{
	DWORD				dwFileSize;
	BYTE				bFlags;
	BYTE				bReservedSize;
	WORD				wSections;
	DGST_SECTION_DATA	rgSectionData[1]; // wSections records

	// bReservedSize bytes here ...
	
} DGSTFILE_FILE_DATA, *PDGSTFILE_FILE_DATA;
	
typedef struct
{
	DWORD				dwHeaderReserved;
	DWORD				dwPerFileReserved;
	
	DWORD				dwEntriesAlloc;
	DWORD				dwEntriesCur;
	PDGST_FILE_DATA		rgdfd;

} DGST_CONTEXT, *PDGST_CONTEXT;

typedef struct
{
	XONLINEOFFERING_ID	OfferingId;
	DWORD				dwTitleId;
	WORD				wTitleVersionHi;
	WORD				wTitleVersionLo;

} DGSTFILE_IDENTIFIER, *PDGSTFILE_IDENTIFIER;

typedef struct
{
	BYTE				rgbSignature[XCALCSIG_SIGNATURE_SIZE];
	BYTE				bDigestVersionHi;
	BYTE				bDigestVersionLo;
	WORD				wReservedSize;
	WORD				wFlags;
	WORD				wRating;
	DWORD				cDigestEntries;
	DGSTFILE_IDENTIFIER	dfi;

} DGSTFILE_HEADER, *PDGSTFILE_HEADER;	

//
// Header flags
//
#define DGSTFILE_HEADER_FLAG_SHARED		((WORD)0x8000)

typedef struct
{
	PDGSTFILE_HEADER	pHeader;
	DWORD				*rgdwOffsetVector;
	DWORD				dwCurrent;
	DWORD				cbDigestData;
	PBYTE				pbDigestData;

} DGSTFILE_ENUM_CONTEXT, *PDGSTFILE_ENUM_CONTEXT;

#ifndef XBOX

//
// API to initialize the digest builder
//
HRESULT CreateDigest(
			DWORD			dwMaxEntries,
			DWORD			dwHeaderReservedSize,
			DWORD			dwPerFileReservedSize,
			PDGST_CONTEXT	*ppContext
			);

//
// API to Insert a file record into the digest
//
HRESULT InsertFileIntoDigest(
			PDGST_CONTEXT		pContext,
			PDGST_FILE_DATA		pdfd
			);

//
// API to serialze an in-memory digest to a file
//
HRESULT SerializeDigestToFile(
			PDGST_CONTEXT		pContext,
			CHAR				*szDigestFile,
			PDGSTFILE_HEADER	pHeader,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey,
			PBYTE				pbHeaderReservedData
			);

//
// API to free a digest context
//
VOID FreeDigest(
			PDGST_CONTEXT	pContext
			);

//
// API to create a digest file from a file list
//
HRESULT CreateDigestFromFileList(
			cab_file_list_header	*pFileList,
			PDGSTFILE_HEADER		pdfh,
			PSTR					szDigestPath,
			PBYTE					pbSymmetricKey,
			DWORD					cbSymmetricKey
			);

//
// API to dump a digest file
//
HRESULT DumpDigest(
			CHAR	*szDigestFile,
			BOOL	fVerify,
			PBYTE	pbSymmetricKey,
			DWORD	cbSymmetricKey
			);

#else

//
// API to begin a digest file enumeration
//
HRESULT EnumerateDigestInitializeContext(
			PBYTE					pbDigestData,
			DWORD					cbDigestData,
			PDGSTFILE_ENUM_CONTEXT	pContext
			);

//
// API to get entries in a digest file (returns a reference to the
// data instead of a copy)
//
HRESULT EnumerateDigestNext(
			PDGSTFILE_ENUM_CONTEXT	pContext,
			PSTR					*ppszFileName,
			PDGSTFILE_FILE_DATA		*ppData
			);			

//
// API to find a specific entry in a digest file (returns a reference to the
// data instead of a copy)
//
HRESULT EnumerateDigestFind(
			PDGSTFILE_ENUM_CONTEXT	pContext,
			PSTR					pszFileName,
			PDGSTFILE_FILE_DATA		*ppData
			);

#endif			

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dls1.h ===
/*==========================================================================;
//
//  dls1.h
//
//
//  Description:
//
//  Interface defines and structures for the Instrument Collection Form
//  RIFF DLS.
//
//
//  Written by Sonic Foundry 1996.  Released for public use.
//
//=========================================================================*/

#ifndef _INC_DLS1
#define _INC_DLS1
#ifdef XBOX
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif
#endif // XBOX

/*//////////////////////////////////////////////////////////////////////////
//
//
// Layout of an instrument collection:
//
//
// RIFF [] 'DLS ' [dlid,colh,INSTLIST,WAVEPOOL,INFOLIST]
//
// INSTLIST
// LIST [] 'lins'
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//
// RGNLIST
// LIST [] 'lrgn' 
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//
// ARTLIST
// LIST [] 'lart'
//         'art1' level 1 Articulation connection graph
//         'art2' level 2 Articulation connection graph
//         '3rd1' Possible 3rd party articulation structure 1
//         '3rd2' Possible 3rd party articulation structure 2 .... and so on
//
// WAVEPOOL 
// ptbl [] [pool table]
// LIST [] 'wvpl'
//               [path],
//               [path],
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//
// INFOLIST
// LIST [] 'INFO' 
//               'icmt' 'One of those crazy comments.'
//               'icop' 'Copyright (C) 1996 Sonic Foundry'
//
/////////////////////////////////////////////////////////////////////////*/


/*/////////////////////////////////////////////////////////////////////////
// FOURCC's used in the DLS file
/////////////////////////////////////////////////////////////////////////*/

#define FOURCC_DLS   mmioFOURCC('D','L','S',' ')
#define FOURCC_DLID  mmioFOURCC('d','l','i','d')
#define FOURCC_COLH  mmioFOURCC('c','o','l','h')
#define FOURCC_WVPL  mmioFOURCC('w','v','p','l')
#define FOURCC_PTBL  mmioFOURCC('p','t','b','l')
#define FOURCC_PATH  mmioFOURCC('p','a','t','h')
#define FOURCC_wave  mmioFOURCC('w','a','v','e')
#define FOURCC_LINS  mmioFOURCC('l','i','n','s')
#define FOURCC_INS   mmioFOURCC('i','n','s',' ')
#define FOURCC_INSH  mmioFOURCC('i','n','s','h')
#define FOURCC_LRGN  mmioFOURCC('l','r','g','n')
#define FOURCC_RGN   mmioFOURCC('r','g','n',' ')
#define FOURCC_RGNH  mmioFOURCC('r','g','n','h')
#define FOURCC_LART  mmioFOURCC('l','a','r','t')
#define FOURCC_ART1  mmioFOURCC('a','r','t','1')
#define FOURCC_WLNK  mmioFOURCC('w','l','n','k')
#define FOURCC_WSMP  mmioFOURCC('w','s','m','p')
#define FOURCC_VERS  mmioFOURCC('v','e','r','s')

/*/////////////////////////////////////////////////////////////////////////
// Articulation connection graph definitions 
/////////////////////////////////////////////////////////////////////////*/

/* Generic Sources */
#define CONN_SRC_NONE              0x0000
#define CONN_SRC_LFO               0x0001
#define CONN_SRC_KEYONVELOCITY     0x0002
#define CONN_SRC_KEYNUMBER         0x0003
#define CONN_SRC_EG1               0x0004
#define CONN_SRC_EG2               0x0005
#define CONN_SRC_PITCHWHEEL        0x0006

/* Midi Controllers 0-127 */
#define CONN_SRC_CC1               0x0081
#define CONN_SRC_CC7               0x0087
#define CONN_SRC_CC10              0x008a
#define CONN_SRC_CC11              0x008b

/* Generic Destinations */
#define CONN_DST_NONE              0x0000
#define CONN_DST_ATTENUATION       0x0001
#define CONN_DST_PITCH             0x0003
#define CONN_DST_PAN               0x0004

/* LFO Destinations */
#define CONN_DST_LFO_FREQUENCY     0x0104
#define CONN_DST_LFO_STARTDELAY    0x0105

/* EG1 Destinations */
#define CONN_DST_EG1_ATTACKTIME    0x0206
#define CONN_DST_EG1_DECAYTIME     0x0207
#define CONN_DST_EG1_RELEASETIME   0x0209
#define CONN_DST_EG1_SUSTAINLEVEL  0x020a

/* EG2 Destinations */
#define CONN_DST_EG2_ATTACKTIME    0x030a
#define CONN_DST_EG2_DECAYTIME     0x030b
#define CONN_DST_EG2_RELEASETIME   0x030d
#define CONN_DST_EG2_SUSTAINLEVEL  0x030e

#define CONN_TRN_NONE              0x0000
#define CONN_TRN_CONCAVE           0x0001

typedef struct _DLSID {
  ULONG    ulData1;
  USHORT   usData2;
  USHORT   usData3;
  BYTE     abData4[8];
} DLSID, FAR *LPDLSID;

typedef struct _DLSVERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DLSVERSION, FAR *LPDLSVERSION;
                   

typedef struct _CONNECTION {
  USHORT   usSource;
  USHORT   usControl;
  USHORT   usDestination;
  USHORT   usTransform;
  LONG     lScale;
  }CONNECTION, FAR *LPCONNECTION;


/* Level 1 Articulation Data */

typedef struct _CONNECTIONLIST {
  ULONG    cbSize;            /* size of the connection list structure */
  ULONG    cConnections;      /* count of connections in the list */
  } CONNECTIONLIST, FAR *LPCONNECTIONLIST;



/*/////////////////////////////////////////////////////////////////////////
// Generic type defines for regions and instruments
/////////////////////////////////////////////////////////////////////////*/

typedef struct _RGNRANGE {
  USHORT usLow;
  USHORT usHigh;
}RGNRANGE, FAR * LPRGNRANGE;

#define F_INSTRUMENT_DRUMS      0x80000000

typedef struct _MIDILOCALE {
  ULONG ulBank;
  ULONG ulInstrument;
}MIDILOCALE, FAR *LPMIDILOCALE;

/*/////////////////////////////////////////////////////////////////////////
// Header structures found in an DLS file for collection, instruments, and
// regions.
/////////////////////////////////////////////////////////////////////////*/

#define F_RGN_OPTION_SELFNONEXCLUSIVE  0x0001

typedef struct _RGNHEADER {
  RGNRANGE RangeKey;            /* Key range  */
  RGNRANGE RangeVelocity;       /* Velocity Range  */
  USHORT   fusOptions;          /* Synthesis options for this range */
  USHORT   usKeyGroup;          /* Key grouping for non simultaneous play */
                                /* 0 = no group, 1 up is group */
                                /* for Level 1 only groups 1-15 are allowed */
}RGNHEADER, FAR *LPRGNHEADER;

typedef struct _INSTHEADER {
  ULONG      cRegions;          /* Count of regions in this instrument */
  MIDILOCALE Locale;            /* Intended MIDI locale of this instrument */
}INSTHEADER, FAR *LPINSTHEADER;

typedef struct _DLSHEADER {
  ULONG      cInstruments;      /* Count of instruments in the collection */
}DLSHEADER, FAR *LPDLSHEADER;

/*////////////////////////////////////////////////////////////////////////////
// definitions for the Wave link structure
////////////////////////////////////////////////////////////////////////////*/

/* ****  For level 1 only WAVELINK_CHANNEL_MONO is valid  **** */
/* ulChannel allows for up to 32 channels of audio with each bit position */
/* specifiying a channel of playback */

#define WAVELINK_CHANNEL_LEFT    0x0001l
#define WAVELINK_CHANNEL_RIGHT   0x0002l

#define F_WAVELINK_PHASE_MASTER  0x0001

typedef struct _WAVELINK { /* any paths or links are stored right after struct */
  USHORT   fusOptions;     /* options flags for this wave */
  USHORT   usPhaseGroup;   /* Phase grouping for locking channels */
  ULONG    ulChannel;      /* channel placement */
  ULONG    ulTableIndex;   /* index into the wave pool table, 0 based */
}WAVELINK, FAR *LPWAVELINK;

#define POOL_CUE_NULL  0xffffffffl

typedef struct _POOLCUE { 
  ULONG    ulOffset;       /* Offset to the entry in the list */
}POOLCUE, FAR *LPPOOLCUE;

typedef struct _POOLTABLE {
  ULONG    cbSize;            /* size of the pool table structure */
  ULONG    cCues;             /* count of cues in the list */
  } POOLTABLE, FAR *LPPOOLTABLE;

/*////////////////////////////////////////////////////////////////////////////
// Structures for the "wsmp" chunk
////////////////////////////////////////////////////////////////////////////*/

#define F_WSMP_NO_TRUNCATION     0x0001l
#define F_WSMP_NO_COMPRESSION    0x0002l


typedef struct _rwsmp {
  ULONG   cbSize;
  USHORT  usUnityNote;         /* MIDI Unity Playback Note */
  SHORT   sFineTune;           /* Fine Tune in log tuning */
  LONG    lAttenuation;        /* Overall Attenuation to be applied to data */
  ULONG   fulOptions;          /* Flag options  */
  ULONG   cSampleLoops;        /* Count of Sample loops, 0 loops is one shot */
  } WSMPL, FAR *LPWSMPL;


/* This loop type is a normal forward playing loop which is continually */
/* played until the envelope reaches an off threshold in the release */
/* portion of the volume envelope */

#define WLOOP_TYPE_FORWARD   0

typedef struct _rloop {
  ULONG cbSize;
  ULONG ulType;              /* Loop Type */
  ULONG ulStart;             /* Start of loop in samples */
  ULONG ulLength;            /* Length of loop in samples */
} WLOOP, FAR *LPWLOOP;

#endif /*_INC_DLS1 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dinputp.h ===
#if DIRECTINPUT_VERSION <= 0x0300
/*
 *  Old GUIDs from DX3 that were never used but which we can't recycle
 *  because we shipped them.
 */
DEFINE_GUID(GUID_RAxis,   0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_UAxis,   0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_VAxis,   0xA36D02E5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
#endif
#define DIEFT_PREDEFMIN             0x00000001
#define DIEFT_PREDEFMAX             0x00000005
//#define DIEFT_PREDEFMAX             0x00000006
#define DIEFT_TYPEMASK              0x000000FF

#define DIEFT_FORCEFEEDBACK         0x00000100
#define DIEFT_VALIDFLAGS            0x0000FE00
#define DIEFT_ENUMVALID             0x040000FF
/*
 *  Name for the latest structures, in places where we specifically care.
 */
#if (DIRECTINPUT_VERSION >= 900)
typedef       DIEFFECT      DIEFFECT_DX9;
typedef       DIEFFECT   *LPDIEFFECT_DX9;
#else
typedef       DIEFFECT      DIEFFECT_DX6;
typedef       DIEFFECT   *LPDIEFFECT_DX6;
#endif

BOOL static __inline
IsValidSizeDIEFFECT(DWORD cb)
{
    return cb == sizeof(DIEFFECT_DX6)
        || cb == sizeof(DIEFFECT_DX5);
}


#define DIEFFECT_MAXAXES            32
#define DIEFF_OBJECTMASK            0x00000003
#define DIEFF_ANGULAR               0x00000060
#define DIEFF_COORDMASK             0x00000070
#define DIEFF_REGIONANGULAR         0x00006000
#define DIEFF_REGIONCOORDMASK       0x00007000

#define DIEFF_VALID                 0x00000073
#define DIEP_GETVALID_DX5           0x000001FF
#define DIEP_SETVALID_DX5           0xE00001FF
#define DIEP_GETVALID               0x000003FF
#define DIEP_SETVALID               0xE00003FF
#define DIEP_USESOBJECTS            0x00000028
#define DIEP_USESCOORDS             0x00000040
#define DIES_VALID                  0x80000001
#define DIES_DRIVER                 0x00000001
#define DIDEVTYPE_MAX           5
#define DI8DEVCLASS_MAX             5
#define DI8DEVTYPE_MIN              0x11
#define DI8DEVTYPE_GAMEMIN          0x14
#define DI8DEVTYPE_GAMEMAX          0x19
#define DI8DEVTYPE_MAX              0x1D
/* 
 *  If any change is made to the order or number of devices in the range 
 *  DI8DEVTYPE_GAMEMIN to DI8DEVTYPE_MAX CJoy_InitFromHwc must be updated.
 */
#define DI8DEVTYPEJOYSTICK_MIN_BUTTONS      5
#define DI8DEVTYPEGAMEPAD_MIN_BUTTONS       6
#define DI8DEVTYPEDRIVING_MIN_BUTTONS       4
#define DI8DEVTYPEFLIGHT_MIN_BUTTONS        4
#define DI8DEVTYPE1STPERSON_MIN_BUTTONS     4

#define DIDEVTYPE_TYPEMASK      0x000000FF
#define DIDEVTYPE_SUBTYPEMASK   0x0000FF00
#define DIDEVTYPE_ENUMMASK      0xFFFFFF00
#define DIDEVTYPE_ENUMVALID     0x00010000
#define DIDEVTYPE_RANDOM        0x80000000
#define MAKE_DIDEVICE_TYPE(maj, min)    MAKEWORD(maj, min) //
#define GET_DIDEVICE_TYPEANDSUBTYPE(dwDevType)    LOWORD(dwDevType) //
/*
 *  Name for the 5.0 structure, in places where we specifically care.
 */
typedef       DIDEVCAPS     DIDEVCAPS_DX5;
typedef       DIDEVCAPS  *LPDIDEVCAPS_DX5;

BOOL static __inline
IsValidSizeDIDEVCAPS(DWORD cb)
{
    return cb == sizeof(DIDEVCAPS_DX5) ||
           cb == sizeof(DIDEVCAPS_DX3);
}
#define DIDF_VALID              0x00000003  //
#define DIA_VALID               0x0000000F
#define DIAH_MAPMASK            0x0000003F
#define DIAH_VALID              0x8000003F
#define DIDBAM_VALID            0x00000007
#define DIDSAM_VALID            0x00000003
#define DICD_VALID              0x00000001
#define DIDIFTT_VALID           0x0000000F
#define DIDIFT_IMAGE2D_BMP      0x80000000
#define DIDIFTF_VALID           0x80010000
#define DIDIFT_VALID            ( DIDIFTT_VALID | DIDIFTF_VALID )
#define DIDAL_VALID         0x0000000F  //
#define HAVE_DIDEVICEOBJECTINSTANCE_DX5
typedef       DIDEVICEOBJECTINSTANCEA    DIDEVICEOBJECTINSTANCE_DX5A;
typedef       DIDEVICEOBJECTINSTANCEW    DIDEVICEOBJECTINSTANCE_DX5W;
typedef       DIDEVICEOBJECTINSTANCE     DIDEVICEOBJECTINSTANCE_DX5;
typedef       DIDEVICEOBJECTINSTANCEA *LPDIDEVICEOBJECTINSTANCE_DX5A;
typedef       DIDEVICEOBJECTINSTANCEW *LPDIDEVICEOBJECTINSTANCE_DX5W;
typedef       DIDEVICEOBJECTINSTANCE  *LPDIDEVICEOBJECTINSTANCE_DX5;
typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCE_DX5A;
typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCE_DX5W;
typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE_DX5;

BOOL static __inline
IsValidSizeDIDEVICEOBJECTINSTANCEW(DWORD cb)
{
    return cb == sizeof(DIDEVICEOBJECTINSTANCE_DX5W) ||
           cb == sizeof(DIDEVICEOBJECTINSTANCE_DX3W);
}

BOOL static __inline
IsValidSizeDIDEVICEOBJECTINSTANCEA(DWORD cb)
{
    return cb == sizeof(DIDEVICEOBJECTINSTANCE_DX5A) ||
           cb == sizeof(DIDEVICEOBJECTINSTANCE_DX3A);
}

#define DIDOI_NOTINPUT          0x80000000
#define DIDOI_ASPECTUNKNOWN     0x00000000
#define DIDOI_RANDOM            0x80000000
#define DIGDD_RESIDUAL      0x00000002  //
#define DIGDD_VALID         0x00000003  //
#define DISCL_EXCLMASK      0x00000003  //
#define DISCL_GROUNDMASK    0x0000000C  //
#define DISCL_VALID         0x0000001F  //
/*
 *  Name for the 5.0 structure, in places where we specifically care.
 */
typedef       DIDEVICEINSTANCEA    DIDEVICEINSTANCE_DX5A;
/*
 *  Name for the 5.0 structure, in places where we specifically care.
 */
typedef       DIDEVICEINSTANCEW    DIDEVICEINSTANCE_DX5W;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef DIDEVICEINSTANCE_DX5W DIDEVICEINSTANCE_DX5;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef DIDEVICEINSTANCE_DX5A DIDEVICEINSTANCE_DX5;
#endif // UNICODE
typedef       DIDEVICEINSTANCE     DIDEVICEINSTANCE_DX5;
typedef       DIDEVICEINSTANCEA *LPDIDEVICEINSTANCE_DX5A;
typedef       DIDEVICEINSTANCEW *LPDIDEVICEINSTANCE_DX5W;
#ifdef UNICODE
typedef LPDIDEVICEINSTANCE_DX5W LPDIDEVICEINSTANCE_DX5;
#else
typedef LPDIDEVICEINSTANCE_DX5A LPDIDEVICEINSTANCE_DX5;
#endif // UNICODE
typedef       DIDEVICEINSTANCE  *LPDIDEVICEINSTANCE_DX5;
typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCE_DX5A;
typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCE_DX5W;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCE_DX5W LPCDIDEVICEINSTANCE_DX5;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPCDIDEVICEINSTANCE_DX5A LPCDIDEVICEINSTANCE_DX5;
#endif // UNICODE
typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE_DX5;

BOOL static __inline
IsValidSizeDIDEVICEINSTANCEW(DWORD cb)
{
    return cb == sizeof(DIDEVICEINSTANCE_DX5W) ||
           cb == sizeof(DIDEVICEINSTANCE_DX3W);
}

BOOL static __inline
IsValidSizeDIDEVICEINSTANCEA(DWORD cb)
{
    return cb == sizeof(DIDEVICEINSTANCE_DX5A) ||
           cb == sizeof(DIDEVICEINSTANCE_DX3A);
}

#define INITINSTANCEGUID(guidInstance, bDeviceId)\
{\
	(guidInstance).Data1 = (DWORD)bDeviceId;\
	(guidInstance).Data2 = 0;\
	(guidInstance).Data3 = 0;\
	*((PLONGLONG)&(guidInstance).Data4) = 0;\
}

#define IS_VALID_GUID_INSTANCE(guidInstance)\
	(((256 > (guidInstance).Data1)&&\
    (0 == (guidInstance).Data2)&&\
	(0 == (guidInstance).Data3)&&\
	(0 == *((PLONGLONG)&(guidInstance).Data4))) ? TRUE : FALSE)

#define DEVICEIDFROMGUID(guidInstance) ((BYTE)((guidInstance).Data1))

#define DIRCP_MODAL         0x00000001  //
#define DIRCP_VALID         0x00000000  //
#define DISFFC_NULL             0x00000000
#define DISFFC_VALID            0x0000003F
#define DISFFC_FORCERESET       0x80000000
#define DIGFFS_RANDOM           0x40000000
#define DISDD_VALID             0x00000001
#define DIECEFL_VALID       0x00000000
#define DIFEF_ENUMVALID             0x00000011
#define DIFEF_WRITEVALID            0x00000001
#if DIRECTINPUT_VERSION >= 0x0700           //
#define DIMOUSESTATE_INT DIMOUSESTATE2      //
#define LPDIMOUSESTATE_INT LPDIMOUSESTATE2  //
#else                                       //
#define DIMOUSESTATE_INT DIMOUSESTATE       //
#define LPDIMOUSESTATE_INT LPDIMOUSESTATE   //
#endif                                      //
#define DIKBD_CKEYS         256     /* Size of buffers */       //
                                                                //
#define DIK_PRTSC           DIK_SNAPSHOT        /* Print Screen */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dmplugin.h ===
/************************************************************************
*                                                                       *
*   dmplugin.h -- This module contains the API for plugins for the      *
*                 DirectMusic performance layer                         *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation                       *
*                                                                       *
************************************************************************/

#ifndef _DMPLUGIN_
#define _DMPLUGIN_

#ifdef XBOX
#include <xtl.h>
#include <xobjbase.h>
#else
#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <mmsystem.h>
#endif // XBOX

#include <dmusicip.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicTrack;
//interface IDirectMusicTool;
//interface IDirectMusicTool8;
interface IDirectMusicTrack8;
interface IDirectMusicPerformance;
interface IDirectMusicSegment;
interface IDirectMusicSegmentState;
interface IDirectMusicGraph;
#ifndef __cplusplus 
typedef interface IDirectMusicTrack IDirectMusicTrack;
//typedef interface IDirectMusicTool IDirectMusicTool;
//typedef interface IDirectMusicTool8 IDirectMusicTool8;
typedef interface IDirectMusicTrack8 IDirectMusicTrack8;
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicGraph IDirectMusicGraph;
#endif

typedef struct _DMUS_PMSG DMUS_PMSG;
typedef long              MUSIC_TIME;

/* Registry location for tools */
#define DMUS_REGSTR_PATH_TOOLS  "Software\\Microsoft\\DirectMusic\\Tools"

 
/* The following flags are sent in the IDirectMusicTrack::Play() method */
/* inside the dwFlags parameter */
typedef enum enumDMUS_TRACKF_FLAGS
{
    DMUS_TRACKF_SEEK            = 1,      /* set on a seek */
    DMUS_TRACKF_LOOP            = 2,      /* set on a loop (repeat) */
    DMUS_TRACKF_START           = 4,      /* set on first call to Play */
    DMUS_TRACKF_FLUSH           = 8,      /* set when this call is in response to a flush on the perfomance */
    DMUS_TRACKF_DIRTY           = 0x10,   /* set when the track should consider any cached values from a previous call to GetParam to be invalidated */
    /* The following flags are DX8 only. */
    DMUS_TRACKF_NOTIFY_OFF      = 0x20,   /* tells track not to send notifications. */
    DMUS_TRACKF_PLAY_OFF        = 0x40,   /* tells track not to play anything (but can still send notifications.) */
    DMUS_TRACKF_LOOPEND         = 0x80,   /* set when the end of range is also a loop end. */
    DMUS_TRACKF_STOP            = 0x100,  /* set when the end of range is also end of playing this segment. */
    DMUS_TRACKF_RECOMPOSE       = 0x200,  /* set to indicate the track should compose. */
    DMUS_TRACKF_CLOCK           = 0x400,  /* set when time parameters are in reference (clock) time. Only valid for PlayEx(). */
} DMUS_TRACKF_FLAGS;

/* The following flags are sent in the IDirectMusicTrack8::GetParamEx() and SetParamEx() methods */
/* inside the dwFlags parameter */
#define DMUS_TRACK_PARAMF_CLOCK  0x01       /* set when the time is measured is in reference (clock) time */

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTrack */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTrack
DECLARE_INTERFACE_(IDirectMusicTrack, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicTrack */
    STDMETHOD(Init)                   (THIS_ IDirectMusicSegment* pSegment) PURE;
    STDMETHOD(InitPlay)               (THIS_ IDirectMusicSegmentState* pSegmentState, 
                                             IDirectMusicPerformance* pPerformance, 
                                             void** ppStateData, 
                                             DWORD dwVirtualTrackID,
                                             DWORD dwFlags) PURE;
    STDMETHOD(EndPlay)                (THIS_ void* pStateData) PURE;
    STDMETHOD(Play)                   (THIS_ void* pStateData, 
                                             MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             MUSIC_TIME mtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE;
    STDMETHOD(GetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             MUSIC_TIME* pmtNext, 
                                             void* pParam) PURE; 
    STDMETHOD(SetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             void* pParam) PURE;
    STDMETHOD(IsParamSupported)       (THIS_ REFGUID rguidType) PURE;
    STDMETHOD(AddNotificationType)    (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType) (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(Clone)                  (THIS_ MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             IDirectMusicTrack** ppTrack) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTrack8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTrack8
DECLARE_INTERFACE_(IDirectMusicTrack8, IDirectMusicTrack)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicTrack */
    STDMETHOD(Init)                   (THIS_ IDirectMusicSegment* pSegment) PURE;
    STDMETHOD(InitPlay)               (THIS_ IDirectMusicSegmentState* pSegmentState, 
                                             IDirectMusicPerformance* pPerformance, 
                                             void** ppStateData, 
                                             DWORD dwVirtualTrackID,
                                             DWORD dwFlags) PURE;
    STDMETHOD(EndPlay)                (THIS_ void* pStateData) PURE;
    STDMETHOD(Play)                   (THIS_ void* pStateData, 
                                             MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             MUSIC_TIME mtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE;
    STDMETHOD(GetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             MUSIC_TIME* pmtNext, 
                                             void* pParam) PURE; 
    STDMETHOD(SetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             void* pParam) PURE;
    STDMETHOD(IsParamSupported)       (THIS_ REFGUID rguidType) PURE;
    STDMETHOD(AddNotificationType)    (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType) (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(Clone)                  (THIS_ MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             IDirectMusicTrack** ppTrack) PURE;
    /* IDirectMusicTrack8 */
    STDMETHOD(PlayEx)                 (THIS_ void* pStateData, 
                                             REFERENCE_TIME rtStart, 
                                             REFERENCE_TIME rtEnd, 
                                             REFERENCE_TIME rtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE; 
    STDMETHOD(GetParamEx)             (THIS_ REFGUID rguidType,         /* Command type. */
                                             REFERENCE_TIME rtTime,     /* Time, in ref time if dwFlags == DMUS_TRACK_PARAMF_CLOCK. Otherwise, music time. */
                                             REFERENCE_TIME* prtNext,   /* Time of next parameter, relative to rtTime, in music or clock time units. */
                                             void* pParam,              /* Pointer to the parameter data. */
                                             void * pStateData,         /* State data for track instance. */
                                             DWORD dwFlags) PURE;       /* Control flags. */
    STDMETHOD(SetParamEx)             (THIS_ REFGUID rguidType, 
                                             REFERENCE_TIME rtTime, 
                                             void* pParam,              /* Pointer to the parameter data. */
                                             void * pStateData,         /* State data for track instance. */
                                             DWORD dwFlags) PURE;       /* Control flags. */
    STDMETHOD(Compose)                (THIS_ IUnknown* pContext,        /* Context for composition (song or segment) */
                                             DWORD dwTrackGroup,
                                             IDirectMusicTrack** ppResultTrack) PURE;
    STDMETHOD(Join)                   (THIS_ IDirectMusicTrack* pNewTrack,
                                             MUSIC_TIME mtJoin,
                                             IUnknown* pContext,        /* Context for joining (song or segment) */
                                             DWORD dwTrackGroup,
                                             IDirectMusicTrack** ppResultTrack) PURE;
};

/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* New CLSID's for DX8 */
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

/* IID's */
DEFINE_GUID(IID_IDirectMusicTrack, 0xf96029a1, 0x4282, 0x11d2, 0x87, 0x17, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
//DEFINE_GUID(IID_IDirectMusicTool,0xd2ac28ba, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Interface IDs for DX8 */
/* changed interfaces (GUID only) */
DEFINE_GUID(IID_IDirectMusicTool8, 0xe674303, 0x3b05, 0x11d3, 0x9b, 0xd1, 0xf9, 0xe7, 0xf0, 0xa0, 0x15, 0x36);
DEFINE_GUID(IID_IDirectMusicTrack8, 0xe674304, 0x3b05, 0x11d3, 0x9b, 0xd1, 0xf9, 0xe7, 0xf0, 0xa0, 0x15, 0x36);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMPLUGIN_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dmerror.h ===
/************************************************************************
*                                                                       *
*   dmerror.h -- Error code returned by DirectMusic API's               *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifdef DXAPI
#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif
    
#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_PARTIALLOAD
 *
 * The object could only load partially. This can happen if some components are
 * not registered properly, such as embedded tracks and tools. This can also happen
 * if some content is missing. For example, if a segment uses a DLS collection that
 * is not in the loader's current search directory.
 */
#define DMUS_S_PARTIALLOAD              MAKE_DMHRESULTSUCCESS(0x091)

/* DMUS_S_PARTIALDOWNLOAD
 *
 * Return value from IDirectMusicBand::Download() which indicates that
 * some of the instruments safely downloaded, but others failed. This usually
 * occurs when some instruments are on PChannels not supported by the performance
 * or port.
 */
#define DMUS_S_PARTIALDOWNLOAD          MAKE_DMHRESULTSUCCESS(0x092)

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */
#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

/* DMUS_S_STRING_TRUNCATED
 *
 * Returned string has been truncated to fit the buffer size.
 */
#define DMUS_S_STRING_TRUNCATED         MAKE_DMHRESULTSUCCESS(0x210)

/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that no note has been calculated because the music value has the note 
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is below 0, 
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is above 127, 
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)

/* DMUS_S_NOBUFFERCONTROL
 *
 * Although the audio output from the port will be routed to the
 * same device as the given DirectSound buffer, buffer controls
 * such as pan and volume will not affect the output.
 *
 */
#define DMUS_S_NOBUFFERCONTROL          MAKE_DMHRESULTSUCCESS(0x215)

/* DMUS_S_GARBAGE_COLLECTED
 *
 * The requested operation was not performed because during CollectGarbage
 * the loader determined that the object had been released.
 */
#define DMUS_S_GARBAGE_COLLECTED        MAKE_DMHRESULTSUCCESS(0x216)

/* DMUS_E_DRIVER_FAILED
 *
 * An unexpected error was returned from a device driver, indicating
 * possible failure of the driver or hardware.
 */
#define DMUS_E_DRIVER_FAILED            MAKE_DMHRESULTERROR(0x0101)

/* DMUS_E_PORTS_OPEN
 *
 * The requested operation cannot be performed while there are 
 * instantiated ports in any process in the system.
 */
#define DMUS_E_PORTS_OPEN               MAKE_DMHRESULTERROR(0x0102)

/* DMUS_E_DEVICE_IN_USE
 *
 * The requested device is already in use (possibly by a non-DirectMusic
 * client) and cannot be opened again.
 */
#define DMUS_E_DEVICE_IN_USE            MAKE_DMHRESULTERROR(0x0103)

/* DMUS_E_INSUFFICIENTBUFFER
 *
 * Buffer is not large enough for requested operation.
 */
#define DMUS_E_INSUFFICIENTBUFFER       MAKE_DMHRESULTERROR(0x0104)

/* DMUS_E_BUFFERNOTSET
 *
 * No buffer was prepared for the download data.
 */
#define DMUS_E_BUFFERNOTSET             MAKE_DMHRESULTERROR(0x0105)

/* DMUS_E_BUFFERNOTAVAILABLE
 *
 * Download failed due to inability to access or create download buffer.
 */
#define DMUS_E_BUFFERNOTAVAILABLE       MAKE_DMHRESULTERROR(0x0106)

/* DMUS_E_NOTADLSCOL
 *
 * Error parsing DLS collection. File is corrupt.
 */
#define DMUS_E_NOTADLSCOL               MAKE_DMHRESULTERROR(0x0108)

/* DMUS_E_INVALIDOFFSET
 *
 * Wave chunks in DLS collection file are at incorrect offsets.
 */
#define DMUS_E_INVALIDOFFSET            MAKE_DMHRESULTERROR(0x0109)

/* DMUS_E_ALREADY_LOADED
 *
 * Second attempt to load a DLS collection that is currently open. 
 */
#define DMUS_E_ALREADY_LOADED           MAKE_DMHRESULTERROR(0x0111)

/* DMUS_E_INVALIDPOS
 *
 * Error reading wave data from DLS collection. Indicates bad file.
 */
#define DMUS_E_INVALIDPOS               MAKE_DMHRESULTERROR(0x0113)

/* DMUS_E_INVALIDPATCH
 *
 * There is no instrument in the collection that matches patch number.
 */
#define DMUS_E_INVALIDPATCH             MAKE_DMHRESULTERROR(0x0114)

/* DMUS_E_CANNOTSEEK
 *
 * The IStream* doesn't support Seek().
 */
#define DMUS_E_CANNOTSEEK               MAKE_DMHRESULTERROR(0x0115)

/* DMUS_E_CANNOTWRITE
 *
 * The IStream* doesn't support Write().
 */
#define DMUS_E_CANNOTWRITE              MAKE_DMHRESULTERROR(0x0116)

/* DMUS_E_CHUNKNOTFOUND
 *
 * The RIFF parser doesn't contain a required chunk while parsing file.
 */
#define DMUS_E_CHUNKNOTFOUND            MAKE_DMHRESULTERROR(0x0117)

/* DMUS_E_INVALID_DOWNLOADID
 *
 * Invalid download id was used in the process of creating a download buffer.
 */
#define DMUS_E_INVALID_DOWNLOADID       MAKE_DMHRESULTERROR(0x0119)

/* DMUS_E_NOT_DOWNLOADED_TO_PORT
 *
 * Tried to unload an object that was not downloaded or previously unloaded.
 */
#define DMUS_E_NOT_DOWNLOADED_TO_PORT   MAKE_DMHRESULTERROR(0x0120)

/* DMUS_E_ALREADY_DOWNLOADED
 *
 * Buffer was already downloaded to synth.
 */
#define DMUS_E_ALREADY_DOWNLOADED       MAKE_DMHRESULTERROR(0x0121)

/* DMUS_E_UNKNOWN_PROPERTY
 *
 * The specified property item was not recognized by the target object.
 */
#define DMUS_E_UNKNOWN_PROPERTY         MAKE_DMHRESULTERROR(0x0122)

/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */ 
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)

/* DMUS_E_NOTMONO
 *
 * Wave chunk has more than one interleaved channel. DLS format requires MONO.
 */
#define DMUS_E_NOTMONO                  MAKE_DMHRESULTERROR(0x0125)

/* DMUS_E_BADARTICULATION
 *
 * Invalid articulation chunk in DLS collection.
 */
#define DMUS_E_BADARTICULATION          MAKE_DMHRESULTERROR(0x0126)

/* DMUS_E_BADINSTRUMENT
 *
 * Invalid instrument chunk in DLS collection.
 */
#define DMUS_E_BADINSTRUMENT            MAKE_DMHRESULTERROR(0x0127)

/* DMUS_E_BADWAVELINK
 *
 * Wavelink chunk in DLS collection points to invalid wave.
 */
#define DMUS_E_BADWAVELINK              MAKE_DMHRESULTERROR(0x0128)

/* DMUS_E_NOARTICULATION
 *
 * Articulation missing from instrument in DLS collection.
 */
#define DMUS_E_NOARTICULATION           MAKE_DMHRESULTERROR(0x0129)

/* DMUS_E_NOTPCM
 *
 * Downoaded DLS wave is not in PCM format. 
*/
#define DMUS_E_NOTPCM                   MAKE_DMHRESULTERROR(0x012A)

/* DMUS_E_BADWAVE
 *
 * Bad wave chunk in DLS collection
 */
#define DMUS_E_BADWAVE                  MAKE_DMHRESULTERROR(0x012B)

/* DMUS_E_BADOFFSETTABLE
 *
 * Offset Table for download buffer has errors. 
 */
#define DMUS_E_BADOFFSETTABLE           MAKE_DMHRESULTERROR(0x012C)

/* DMUS_E_UNKNOWNDOWNLOAD
 *
 * Attempted to download unknown data type.
 */
#define DMUS_E_UNKNOWNDOWNLOAD          MAKE_DMHRESULTERROR(0x012D)

/* DMUS_E_NOSYNTHSINK
 *
 * The operation could not be completed because no sink was connected to
 * the synthesizer.
 */
#define DMUS_E_NOSYNTHSINK              MAKE_DMHRESULTERROR(0x012E)

/* DMUS_E_ALREADYOPEN
 *
 * An attempt was made to open the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYOPEN              MAKE_DMHRESULTERROR(0x012F)

/* DMUS_E_ALREADYCLOSE
 *
 * An attempt was made to close the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYCLOSED            MAKE_DMHRESULTERROR(0x0130)

/* DMUS_E_SYNTHNOTCONFIGURED
 *
 * The operation could not be completed because the software synth has not 
 * yet been fully configured.
 * ASSERT?
 */
#define DMUS_E_SYNTHNOTCONFIGURED       MAKE_DMHRESULTERROR(0x0131)

/* DMUS_E_SYNTHACTIVE
 *
 * The operation cannot be carried out while the synthesizer is active.
 */
#define DMUS_E_SYNTHACTIVE              MAKE_DMHRESULTERROR(0x0132)

/* DMUS_E_CANNOTREAD
 *
 * An error occurred while attempting to read from the IStream* object.
 */
#define DMUS_E_CANNOTREAD               MAKE_DMHRESULTERROR(0x0133)

/* DMUS_E_DMUSIC_RELEASED
 *
 * The operation cannot be performed because the final instance of the
 * DirectMusic object was released. Ports cannot be used after final 
 * release of the DirectMusic object.
 */
#define DMUS_E_DMUSIC_RELEASED          MAKE_DMHRESULTERROR(0x0134)

/* DMUS_E_BUFFER_EMPTY
 *
 * There was no data in the referenced buffer.
 */
#define DMUS_E_BUFFER_EMPTY             MAKE_DMHRESULTERROR(0x0135)

/* DMUS_E_BUFFER_FULL
 *
 * There is insufficient space to insert the given event into the buffer.
 */
#define DMUS_E_BUFFER_FULL              MAKE_DMHRESULTERROR(0x0136)

/* DMUS_E_PORT_NOT_CAPTURE
 *
 * The given operation could not be carried out because the port is a
 * capture port.
 */
#define DMUS_E_PORT_NOT_CAPTURE         MAKE_DMHRESULTERROR(0x0137)

/* DMUS_E_PORT_NOT_RENDER
 *
 * The given operation could not be carried out because the port is a
 * render port.
 */
#define DMUS_E_PORT_NOT_RENDER          MAKE_DMHRESULTERROR(0x0138)

/* DMUS_E_DSOUND_NOT_SET
 *
 * The port could not be created because no DirectSound has been specified.
 * Specify a DirectSound interface via the IDirectMusic::SetDirectSound
 * method; pass NULL to have DirectMusic manage usage of DirectSound.
 */
#define DMUS_E_DSOUND_NOT_SET           MAKE_DMHRESULTERROR(0x0139)

/* DMUS_E_ALREADY_ACTIVATED
 *
 * The operation cannot be carried out while the port is active.
 */
#define DMUS_E_ALREADY_ACTIVATED        MAKE_DMHRESULTERROR(0x013A)

/* DMUS_E_INVALIDBUFFER
 *
 * Invalid DirectSound buffer was handed to port. 
 */
#define DMUS_E_INVALIDBUFFER            MAKE_DMHRESULTERROR(0x013B)

/* DMUS_E_WAVEFORMATNOTSUPPORTED
 *
 * Invalid buffer format was handed to the synth sink.
 */
#define DMUS_E_WAVEFORMATNOTSUPPORTED   MAKE_DMHRESULTERROR(0x013C)

/* DMUS_E_SYNTHINACTIVE
 *
 * The operation cannot be carried out while the synthesizer is inactive.
 */
#define DMUS_E_SYNTHINACTIVE            MAKE_DMHRESULTERROR(0x013D)

/* DMUS_E_DSOUND_ALREADY_SET
 *
 * IDirectMusic::SetDirectSound has already been called. It may not be
 * changed while in use.
 */
#define DMUS_E_DSOUND_ALREADY_SET       MAKE_DMHRESULTERROR(0x013E)

/* DMUS_E_INVALID_EVENT
 *
 * The given event is invalid (either it is not a valid MIDI message
 * or it makes use of running status). The event cannot be packed
 * into the buffer.
 */
#define DMUS_E_INVALID_EVENT            MAKE_DMHRESULTERROR(0x013F)

/* DMUS_E_UNSUPPORTED_STREAM
 *
 * The IStream* object does not contain data supported by the loading object.
 */
#define DMUS_E_UNSUPPORTED_STREAM       MAKE_DMHRESULTERROR(0x0150)

/* DMUS_E_ALREADY_INITED
 *
 * The object has already been initialized.
 */
#define DMUS_E_ALREADY_INITED           MAKE_DMHRESULTERROR(0x0151)

/* DMUS_E_INVALID_BAND
 *
 * The file does not contain a valid band.
 */
#define DMUS_E_INVALID_BAND             MAKE_DMHRESULTERROR(0x0152)

/* DMUS_E_TRACK_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a track header as the first chunk,
 * and therefore can not be read by the segment object.
 */
#define DMUS_E_TRACK_HDR_NOT_FIRST_CK   MAKE_DMHRESULTERROR(0x0155)

/* DMUS_E_TOOL_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a tool header as the first chunk,
 * and therefore can not be read by the graph object.
 */
#define DMUS_E_TOOL_HDR_NOT_FIRST_CK    MAKE_DMHRESULTERROR(0x0156)

/* DMUS_E_INVALID_TRACK_HDR
 *
 * The IStream* object's data contains an invalid track header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the segment object.
 */
#define DMUS_E_INVALID_TRACK_HDR        MAKE_DMHRESULTERROR(0x0157)

/* DMUS_E_INVALID_TOOL_HDR
 *
 * The IStream* object's data contains an invalid tool header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the graph object.
 */
#define DMUS_E_INVALID_TOOL_HDR         MAKE_DMHRESULTERROR(0x0158)

/* DMUS_E_ALL_TOOLS_FAILED
 *
 * The graph object was unable to load all tools from the IStream* object data.
 * This may be due to errors in the stream, or the tools being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TOOLS_FAILED         MAKE_DMHRESULTERROR(0x0159)

/* DMUS_E_ALL_TRACKS_FAILED
 *
 * The segment object was unable to load all tracks from the IStream* object data.
 * This may be due to errors in the stream, or the tracks being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TRACKS_FAILED        MAKE_DMHRESULTERROR(0x0160)

/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)

/* DMUS_E_TYPE_DISABLED
 *
 * The requested parameter type is currently disabled. Parameter types may
 * be enabled and disabled by certain calls to SetParam().
 */
#define DMUS_E_TYPE_DISABLED            MAKE_DMHRESULTERROR(0x0163)

/* DMUS_E_TYPE_UNSUPPORTED
 *
 * The requested parameter type is not supported on the object.
 */
#define DMUS_E_TYPE_UNSUPPORTED         MAKE_DMHRESULTERROR(0x0164)

/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)

/* DMUS_E_TRACK_NOT_FOUND
 *
 * The requested track is not contained by the segment.
 */
#define DMUS_E_TRACK_NOT_FOUND			MAKE_DMHRESULTERROR(0x0166)

/* DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT
 *
 * The track does not support clock time playback or getparam.
 */
#define DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT   MAKE_DMHRESULTERROR(0x0167)
 
/* DMUS_E_NO_MASTER_CLOCK
 *
 * There is no master clock in the performance. Be sure to call
 * IDirectMusicPerformance::Init().
 */
#define DMUS_E_NO_MASTER_CLOCK          MAKE_DMHRESULTERROR(0x0170)

/* DMUS_E_LOADER_NOCLASSID
 *
 * The class id field is required and missing in the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOCLASSID         MAKE_DMHRESULTERROR(0x0180)

/* DMUS_E_LOADER_BADPATH
 *
 * The requested file path is invalid.
 */
#define DMUS_E_LOADER_BADPATH           MAKE_DMHRESULTERROR(0x0181)

/* DMUS_E_LOADER_FAILEDOPEN
 *
 * File open failed - either file doesn't exist or is locked.
 */
#define DMUS_E_LOADER_FAILEDOPEN        MAKE_DMHRESULTERROR(0x0182)

/* DMUS_E_LOADER_FORMATNOTSUPPORTED
 *
 * Search data type is not supported.
 */
#define DMUS_E_LOADER_FORMATNOTSUPPORTED    MAKE_DMHRESULTERROR(0x0183)

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)

/* DMUS_E_LOADER_NOFILENAME
 *
 * The file name is missing from the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOFILENAME	    MAKE_DMHRESULTERROR(0x0186)

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200)

/* DMUS_E_ALREADY_EXISTS
 *
 * The tool is already contained in the graph. Create a new instance.
 */
#define DMUS_E_ALREADY_EXISTS           MAKE_DMHRESULTERROR(0x0201)

/* DMUS_E_OUT_OF_RANGE
 *
 * Value is out of range, for instance the requested length is longer than
 * the segment.
 */
#define DMUS_E_OUT_OF_RANGE             MAKE_DMHRESULTERROR(0x0202)

/* DMUS_E_SEGMENT_INIT_FAILED
 *
 * Segment initialization failed, most likely due to a critical memory situation.
 */
#define DMUS_E_SEGMENT_INIT_FAILED      MAKE_DMHRESULTERROR(0x0203)

/* DMUS_E_ALREADY_SENT
 *
 * The DMUS_PMSG has already been sent to the performance object via
 * IDirectMusicPerformance::SendPMsg().
 */
#define DMUS_E_ALREADY_SENT             MAKE_DMHRESULTERROR(0x0204)

/* DMUS_E_CANNOT_FREE
 *
 * The DMUS_PMSG was either not allocated by the performance via
 * IDirectMusicPerformance::AllocPMsg(), or it was already freed via
 * IDirectMusicPerformance::FreePMsg().
 */
#define DMUS_E_CANNOT_FREE              MAKE_DMHRESULTERROR(0x0205)

/* DMUS_E_CANNOT_OPEN_PORT
 *
 * The default system port could not be opened.
 */
#define DMUS_E_CANNOT_OPEN_PORT         MAKE_DMHRESULTERROR(0x0206)

/* DMUS_E_CANNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CANNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)
/* misspelling in previous versions of DirectX preserved for backward compatibility */
#define DMUS_E_CONNOT_CONVERT           DMUS_E_CANNOT_CONVERT

/* DMUS_E_DESCEND_CHUNK_FAIL
 * 
 * DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
 * was reached before the desired chunk was found.
 */
#define DMUS_E_DESCEND_CHUNK_FAIL       MAKE_DMHRESULTERROR(0x0210)

/* DMUS_E_NOT_LOADED
 *
 * An attempt to use this object failed because it first needs to
 * be loaded.
 */
#define DMUS_E_NOT_LOADED               MAKE_DMHRESULTERROR(0x0211)

/* DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE
 *
 * The activeX scripting engine for the script's language is not compatible with
 * DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE  MAKE_DMHRESULTERROR(0x0213)

/* DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE
 *
 * A varient was used that had a type that is not supported by DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE    MAKE_DMHRESULTERROR(0x0214)

/* DMUS_E_SCRIPT_ERROR_IN_SCRIPT
 *
 * An error was encountered while parsing or executing the script.
 * The pErrorInfo parameter (if supplied) was filled with information about the error.
 */
#define DMUS_E_SCRIPT_ERROR_IN_SCRIPT        MAKE_DMHRESULTERROR(0x0215)

/* DMUS_E_SCRIPT_CANTLOAD_OLEAUT32
 *
 * Loading of oleaut32.dll failed.  VBScript and other activeX scripting languages
 * require use of oleaut32.dll.  On platforms where oleaut32.dll is not present, only
 * the DirectMusicScript language, which doesn't require oleaut32.dll can be used.
 */
#define DMUS_E_SCRIPT_CANTLOAD_OLEAUT32      MAKE_DMHRESULTERROR(0x0216)

/* DMUS_E_SCRIPT_LOADSCRIPT_ERROR
 *
 * An error occured while parsing a script loaded using LoadScript.  The script that
 * was loaded contains an error.
 */
#define DMUS_E_SCRIPT_LOADSCRIPT_ERROR       MAKE_DMHRESULTERROR(0x0217)

/* DMUS_E_SCRIPT_INVALID_FILE
 *
 * The script file is invalid.
 */
#define DMUS_E_SCRIPT_INVALID_FILE           MAKE_DMHRESULTERROR(0x0218)

/* DMUS_E_INVALID_SCRIPTTRACK
 *
 * The file contains an invalid script track.
 */
#define DMUS_E_INVALID_SCRIPTTRACK           MAKE_DMHRESULTERROR(0x0219)

/* DMUS_E_SCRIPT_VARIABLE_NOT_FOUND
 *
 * The script does not contain a variable with the specified name.
 */
#define DMUS_E_SCRIPT_VARIABLE_NOT_FOUND     MAKE_DMHRESULTERROR(0x021A)

/* DMUS_E_SCRIPT_ROUTINE_NOT_FOUND
 *
 * The script does not contain a routine with the specified name.
 */
#define DMUS_E_SCRIPT_ROUTINE_NOT_FOUND      MAKE_DMHRESULTERROR(0x021B)

/* DMUS_E_SCRIPT_CONTENT_READONLY
 *
 * Scripts variables for content referenced or embedded in a script cannot be set.
 */
#define DMUS_E_SCRIPT_CONTENT_READONLY       MAKE_DMHRESULTERROR(0x021C)

/* DMUS_E_SCRIPT_NOT_A_REFERENCE
 *
 * Attempt was made to set a script's variable by reference to a value that was
 * not an object type.
 */
#define DMUS_E_SCRIPT_NOT_A_REFERENCE        MAKE_DMHRESULTERROR(0x021D)

/* DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED
 *
 * Attempt was made to set a script's variable by value to an object that does
 * not support a default value property.
 */
#define DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED    MAKE_DMHRESULTERROR(0x021E)

/* DMUS_E_INVALID_SEGMENTTRIGGERTRACK
 *
 * The file contains an invalid segment trigger track.
 */
#define DMUS_E_INVALID_SEGMENTTRIGGERTRACK   MAKE_DMHRESULTERROR(0x0220)

/* DMUS_E_INVALID_LYRICSTRACK
 *
 * The file contains an invalid lyrics track.
 */
#define DMUS_E_INVALID_LYRICSTRACK           MAKE_DMHRESULTERROR(0x0221)

/* DMUS_E_INVALID_PARAMCONTROLTRACK
 *
 * The file contains an invalid parameter control track.
 */
#define DMUS_E_INVALID_PARAMCONTROLTRACK     MAKE_DMHRESULTERROR(0x0222)

/* DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR
 *
 * A script written in AudioVBScript could not be read because it contained a statement that
 * is not allowed by the AudioVBScript language.
 */
#define DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR     MAKE_DMHRESULTERROR(0x0223)

/* DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR
 *
 * A script routine written in AudioVBScript failed because an invalid operation occurred.  For example,
 * adding the number 3 to a segment object would produce this error.  So would attempting to call a routine
 * that doesn't exist.
 */
#define DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR     MAKE_DMHRESULTERROR(0x0224)

/* DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE
 *
 * A script routine written in AudioVBScript failed because a function outside of a script failed to complete.
 * For example, a call to PlaySegment that fails to play because of low memory would return this error.
 */
#define DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE     MAKE_DMHRESULTERROR(0x0225)

/* DMUS_E_AUDIOPATHS_NOT_VALID
 *
 * The Performance has set up some PChannels using the AssignPChannel command, which 
 * makes it not capable of supporting audio paths.
 */
#define DMUS_E_AUDIOPATHS_NOT_VALID     MAKE_DMHRESULTERROR(0x0226)

/* DMUS_E_AUDIOPATHS_IN_USE
 *
 * This is the inverse of the previous error. 
 * The Performance has set up some audio paths, which makes is incompatible
 * with the calls to allocate pchannels, etc. 
 */
#define DMUS_E_AUDIOPATHS_IN_USE     MAKE_DMHRESULTERROR(0x0227)

/* DMUS_E_NO_AUDIOPATH_CONFIG
 *
 * A segment or song was asked for its embedded audio path configuration,
 * but there isn't any. 
 */
#define DMUS_E_NO_AUDIOPATH_CONFIG     MAKE_DMHRESULTERROR(0x0228)

/* DMUS_E_AUDIOPATH_INACTIVE
 *
 * An audiopath is inactive, perhaps because closedown was called.
 */
#define DMUS_E_AUDIOPATH_INACTIVE     MAKE_DMHRESULTERROR(0x0229)

/* DMUS_E_AUDIOPATH_NOBUFFER
 *
 * An audiopath failed to create because a requested buffer could not be created.
 */
#define DMUS_E_AUDIOPATH_NOBUFFER     MAKE_DMHRESULTERROR(0x022A)

/* DMUS_E_AUDIOPATH_NOPORT
 *
 * An audiopath could not be used for playback because it lacked port assignments.
 */
#define DMUS_E_AUDIOPATH_NOPORT     MAKE_DMHRESULTERROR(0x022B)

/* DMUS_E_NO_AUDIOPATH
 *
 * Attempt was made to play segment in audiopath mode and there was no audiopath.
 */
#define DMUS_E_NO_AUDIOPATH     MAKE_DMHRESULTERROR(0x022C)

/* DMUS_E_INVALIDCHUNK
 *
 * Invalid data was found in a RIFF file chunk.
 */
#define DMUS_E_INVALIDCHUNK     MAKE_DMHRESULTERROR(0x022D)

/* DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER
 *
 * Attempt was made to create an audiopath that sends to a global effects buffer which did not exist.
 */
#define DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER     MAKE_DMHRESULTERROR(0x022E)

/* DMUS_E_INVALID_CONTAINER_OBJECT
 *
 * The file does not contain a valid container object.
 */
#define DMUS_E_INVALID_CONTAINER_OBJECT    MAKE_DMHRESULTERROR(0x022F)

#endif
#else
#include "dmusicip.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dmusicc.h ===
/************************************************************************
*                                                                       *
*   dmusicc.h -- This module defines the DirectMusic core API's         *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICC_
#define _DMUSICC_

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>
#endif // XBOX

#ifndef XBOX
#include <mmsystem.h>
#endif // XBOX

#include "dls1.h"
#include "dmerror.h"
#include "dmdls.h"
#include "dsound.h"
#include "dmusbuff.h"

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef ULONGLONG    SAMPLE_TIME;
typedef ULONGLONG    SAMPLE_POSITION;	
typedef SAMPLE_TIME *LPSAMPLE_TIME;

#define DMUS_MAX_DESCRIPTION 128
#define DMUS_MAX_DRIVER 128

typedef struct _DMUS_BUFFERDESC *LPDMUS_BUFFERDESC;
typedef struct _DMUS_BUFFERDESC
{
    DWORD dwSize;
    DWORD dwFlags;
    GUID guidBufferFormat;
    DWORD cbBuffer;
} DMUS_BUFFERDESC;

/* DMUS_EFFECT_ flags are used in the dwEffectFlags fields of both DMUS_PORTCAPS 
 * and DMUS_PORTPARAMS.
 */
#define DMUS_EFFECT_NONE             0x00000000
#define DMUS_EFFECT_REVERB           0x00000001
#define DMUS_EFFECT_CHORUS           0x00000002

/* For DMUS_PORTCAPS dwClass
 */ 
#define DMUS_PC_INPUTCLASS       (0)
#define DMUS_PC_OUTPUTCLASS      (1)

/* For DMUS_PORTCAPS dwFlags
 */
#define DMUS_PC_DLS              (0x00000001)   // Supports DLS downloading and DLS level 1.
#define DMUS_PC_EXTERNAL         (0x00000002)   // External MIDI module.
#define DMUS_PC_SOFTWARESYNTH    (0x00000004)   // Software synthesizer.
#define DMUS_PC_MEMORYSIZEFIXED  (0x00000008)   // Memory size is fixed.
#define DMUS_PC_GMINHARDWARE     (0x00000010)   // GM sound set is built in, no need to download.
#define DMUS_PC_GSINHARDWARE     (0x00000020)   // GS sound set is built in.
#define DMUS_PC_XGINHARDWARE     (0x00000040)   // XG sound set is built in.
#define DMUS_PC_DIRECTSOUND      (0x00000080)   // Connects to DirectSound via a DSound buffer.
#define DMUS_PC_SHAREABLE        (0x00000100)   // Synth can be actively shared by multiple apps at once.
#define DMUS_PC_DLS2             (0x00000200)   // Supports DLS2 instruments.
#define DMUS_PC_AUDIOPATH        (0x00000400)   // Multiple outputs can be connected to DirectSound for audiopaths.
#define DMUS_PC_WAVE             (0x00000800)   // Supports streaming and one shot waves.

#define DMUS_PC_SYSTEMMEMORY     (0x7FFFFFFF)   // Sample memory is system memory.


typedef struct _DMUS_PORTCAPS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    GUID    guidPort;
    DWORD   dwClass;
    DWORD   dwType;
    DWORD   dwMemorySize;
    DWORD   dwMaxChannelGroups;
    DWORD   dwMaxVoices;    
    DWORD   dwMaxAudioChannels;
    DWORD   dwEffectFlags;
    WCHAR   wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_PORTCAPS;

typedef DMUS_PORTCAPS *LPDMUS_PORTCAPS;

/* Values for DMUS_PORTCAPS dwType. This field indicates the underlying 
 * driver type of the port.
 */
#define DMUS_PORT_WINMM_DRIVER      (0)
#define DMUS_PORT_USER_MODE_SYNTH   (1)
#define DMUS_PORT_KERNEL_MODE       (2)

/* These flags (set in dwValidParams) indicate which other members of the */
/* DMUS_PORTPARAMS are valid. */
/* */
#define DMUS_PORTPARAMS_VOICES           0x00000001
#define DMUS_PORTPARAMS_CHANNELGROUPS    0x00000002
#define DMUS_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define DMUS_PORTPARAMS_SAMPLERATE       0x00000008
#define DMUS_PORTPARAMS_EFFECTS          0x00000020
#define DMUS_PORTPARAMS_SHARE            0x00000040
#define DMUS_PORTPARAMS_FEATURES         0x00000080     /* DirectX 8.0 and above */

typedef struct _DMUS_PORTPARAMS
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
} DMUS_PORTPARAMS7;

typedef struct _DMUS_PORTPARAMS8
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
    DWORD   dwFeatures;
} DMUS_PORTPARAMS8;

#define DMUS_PORT_FEATURE_AUDIOPATH     0x00000001	/* Supports audiopath connection to DSound buffers. */
#define DMUS_PORT_FEATURE_STREAMING     0x00000002	/* Supports streaming waves through the synth. */


typedef DMUS_PORTPARAMS8 DMUS_PORTPARAMS;
typedef DMUS_PORTPARAMS *LPDMUS_PORTPARAMS;

typedef struct _DMUS_SYNTHSTATS *LPDMUS_SYNTHSTATS;
typedef struct _DMUS_SYNTHSTATS8 *LPDMUS_SYNTHSTATS8;
typedef struct _DMUS_SYNTHSTATS
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
} DMUS_SYNTHSTATS;

typedef struct _DMUS_SYNTHSTATS8
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
	DWORD   dwSynthMemUse;		/* Memory used by synth wave data */ 
} DMUS_SYNTHSTATS8;

#define DMUS_SYNTHSTATS_VOICES          (1 << 0)
#define DMUS_SYNTHSTATS_TOTAL_CPU       (1 << 1)
#define DMUS_SYNTHSTATS_CPU_PER_VOICE   (1 << 2)
#define DMUS_SYNTHSTATS_LOST_NOTES      (1 << 3)
#define DMUS_SYNTHSTATS_PEAK_VOLUME     (1 << 4)
#define DMUS_SYNTHSTATS_FREE_MEMORY     (1 << 5)

#define DMUS_SYNTHSTATS_SYSTEMMEMORY    DMUS_PC_SYSTEMMEMORY

typedef struct _DMUS_WAVES_REVERB_PARAMS
{
    float   fInGain;        /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;     /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                            Negative values gives less wet signal.
                            The coeficients are calculated so that the overall output level stays 
                            (approximately) constant regardless of the ammount of reverb mix. */
    float   fReverbTime;    /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio; /* The ratio of the high frequencies to the global reverb time. 
                            Unless very 'splashy-bright' reverbs are wanted, this should be set to 
                            a value < 1.0.
                            For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
                            decay time for high frequencies will be 100ms.*/

} DMUS_WAVES_REVERB_PARAMS;

/*  Note: Default values for Reverb are:
    fInGain             = 0.0dB   (no change in level)
    fReverbMix          = -10.0dB   (a reasonable reverb mix)
    fReverbTime         = 1000.0ms (one second global reverb time)
    fHighFreqRTRatio    = 0.001    (the ratio of the high frequencies to the global reverb time) 
*/

typedef enum
{
    DMUS_CLOCK_SYSTEM = 0,
    DMUS_CLOCK_WAVE = 1
} DMUS_CLOCKTYPE;

#define DMUS_CLOCKF_GLOBAL              0x00000001

typedef struct _DMUS_CLOCKINFO7 *LPDMUS_CLOCKINFO7;
typedef struct _DMUS_CLOCKINFO7
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_CLOCKINFO7;

typedef struct _DMUS_CLOCKINFO8 *LPDMUS_CLOCKINFO8;
typedef struct _DMUS_CLOCKINFO8
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
    DWORD           dwFlags;           
} DMUS_CLOCKINFO8;

typedef DMUS_CLOCKINFO8 DMUS_CLOCKINFO;
typedef DMUS_CLOCKINFO *LPDMUS_CLOCKINFO;

/* Default bus identifiers
 *
 * The first 17 are direct mappings to the destinations defined in both
 * the MMA DLS Level 2 specification and the Microsoft Multi-Channel audio
 * specification.
 */
#define DSBUSID_FIRST_SPKR_LOC              0
#define DSBUSID_FRONT_LEFT                  0
#define DSBUSID_LEFT                        0   /* Front left is also just left */
#define DSBUSID_FRONT_RIGHT                 1
#define DSBUSID_RIGHT                       1   /* Ditto front right */ 
#define DSBUSID_FRONT_CENTER                2
#define DSBUSID_LOW_FREQUENCY               3
#define DSBUSID_BACK_LEFT                   4
#define DSBUSID_BACK_RIGHT                  5
#define DSBUSID_FRONT_LEFT_OF_CENTER        6 
#define DSBUSID_FRONT_RIGHT_OF_CENTER       7
#define DSBUSID_BACK_CENTER                 8
#define DSBUSID_SIDE_LEFT                   9
#define DSBUSID_SIDE_RIGHT                 10
#define DSBUSID_TOP_CENTER                 11
#define DSBUSID_TOP_FRONT_LEFT             12
#define DSBUSID_TOP_FRONT_CENTER           13
#define DSBUSID_TOP_FRONT_RIGHT            14
#define DSBUSID_TOP_BACK_LEFT              15
#define DSBUSID_TOP_BACK_CENTER            16
#define DSBUSID_TOP_BACK_RIGHT             17
#define DSBUSID_LAST_SPKR_LOC              17

#define DSBUSID_IS_SPKR_LOC(id) ( ((id) >= DSBUSID_FIRST_SPKR_LOC) && ((id) <= DSBUSID_LAST_SPKR_LOC) )

/* These bus identifiers are for the standard DLS effect sends 
 */
#define DSBUSID_REVERB_SEND                64
#define DSBUSID_CHORUS_SEND                65

/* Dynamic bus identifiers start here. See the documentation for how
 * synthesizers map the output of voices to static and dynamic
 * bus identifiers.
 */ 
#define DSBUSID_DYNAMIC_0                 512 

/* Null bus, used to identify busses that have no function mapping. 
*/
#define DSBUSID_NULL			   0xFFFFFFFF

interface IDirectMusic;
interface IDirectMusic8;
interface IDirectMusicBuffer;
interface IDirectMusicPort;
interface IDirectMusicThru;
interface IReferenceClock;

#ifndef __cplusplus 

typedef interface IDirectMusic IDirectMusic;
typedef interface IDirectMusic8 IDirectMusic8;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicThru IDirectMusicThru;
typedef interface IReferenceClock IReferenceClock;

#endif  /* C++ */

typedef IDirectMusic *LPDIRECTMUSIC;
typedef IDirectMusic8 *LPDIRECTMUSIC8;
typedef IDirectMusicPort *LPDIRECTMUSICPORT;
typedef IDirectMusicBuffer *LPDIRECTMUSICBUFFER;

#undef  INTERFACE
#define INTERFACE  IDirectMusic
DECLARE_INTERFACE_(IDirectMusic, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex, 
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc, 
                                           LPDIRECTMUSICBUFFER *ppBuffer, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort, 
                                           LPDMUS_PORTPARAMS pPortParams, 
                                           LPDIRECTMUSICPORT *ppPort, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex, 
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock, 
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusic8
DECLARE_INTERFACE_(IDirectMusic8, IDirectMusic)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex, 
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc, 
                                           LPDIRECTMUSICBUFFER *ppBuffer, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort, 
                                           LPDMUS_PORTPARAMS pPortParams, 
                                           LPDIRECTMUSICPORT *ppPort, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex, 
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock, 
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    /*  IDirectMusic8 */
    STDMETHOD(SetExternalMasterClock)
                                    (THIS_ IReferenceClock *pClock) PURE;                                          
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicBuffer
DECLARE_INTERFACE_(IDirectMusicBuffer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicBuffer */
    STDMETHOD(Flush)                (THIS) PURE;
    STDMETHOD(TotalTime)            (THIS_ LPREFERENCE_TIME prtTime) PURE;
    
    STDMETHOD(PackStructured)       (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD dwChannelMessage) PURE;
    
    STDMETHOD(PackUnstructured)     (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD cb,
                                           LPBYTE lpb) PURE;
    
    STDMETHOD(ResetReadPtr)         (THIS) PURE;
    STDMETHOD(GetNextEvent)         (THIS_ LPREFERENCE_TIME prt,
                                           LPDWORD pdwChannelGroup,
                                           LPDWORD pdwLength,
                                           LPBYTE *ppData) PURE;

    STDMETHOD(GetRawBufferPtr)      (THIS_ LPBYTE *ppData) PURE;
    STDMETHOD(GetStartTime)         (THIS_ LPREFERENCE_TIME prt) PURE;
    STDMETHOD(GetUsedBytes)         (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetMaxBytes)          (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetBufferFormat)      (THIS_ LPGUID pGuidFormat) PURE;

    STDMETHOD(SetStartTime)         (THIS_ REFERENCE_TIME rt) PURE;
    STDMETHOD(SetUsedBytes)         (THIS_ DWORD cb) PURE;
};

typedef IDirectMusicBuffer IDirectMusicBuffer8;
typedef IDirectMusicBuffer8 *LPDIRECTMUSICBUFFER8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrument
DECLARE_INTERFACE_(IDirectMusicInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicInstrument */
    STDMETHOD(GetPatch)                 (THIS_ DWORD* pdwPatch) PURE;
    STDMETHOD(SetPatch)                 (THIS_ DWORD dwPatch) PURE;
};

typedef IDirectMusicInstrument IDirectMusicInstrument8;
typedef IDirectMusicInstrument8 *LPDIRECTMUSICINSTRUMENT8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrument
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicDownloadedInstrument */
    /* None at this time */
};

typedef IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument8;
typedef IDirectMusicDownloadedInstrument8 *LPDIRECTMUSICDOWNLOADEDINSTRUMENT8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicCollection
DECLARE_INTERFACE_(IDirectMusicCollection, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicCollection */
    STDMETHOD(GetInstrument)            (THIS_ DWORD dwPatch, 
                                               IDirectMusicInstrument** ppInstrument) PURE;
    STDMETHOD(EnumInstrument)           (THIS_ DWORD dwIndex, 
                                               DWORD* pdwPatch, 
                                               LPWSTR pwszName, 
                                               DWORD dwNameLen) PURE;
};

typedef IDirectMusicCollection IDirectMusicCollection8;
typedef IDirectMusicCollection8 *LPDIRECTMUSICCOLLECTION8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownload 
DECLARE_INTERFACE_(IDirectMusicDownload , IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDownload */
    STDMETHOD(GetBuffer)            (THIS_ void** ppvBuffer, 
                                           DWORD* pdwSize) PURE;
};

typedef IDirectMusicDownload IDirectMusicDownload8;
typedef IDirectMusicDownload8 *LPDIRECTMUSICDOWNLOAD8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicPortDownload
DECLARE_INTERFACE_(IDirectMusicPortDownload, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPortDownload */
    STDMETHOD(GetBuffer)            (THIS_ DWORD dwDLId, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(AllocateBuffer)       (THIS_ DWORD dwSize, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(GetDLId)              (THIS_ DWORD* pdwStartDLId, 
                                           DWORD dwCount) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
    STDMETHOD(Unload)               (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
};

typedef IDirectMusicPortDownload IDirectMusicPortDownload8;
typedef IDirectMusicPortDownload8 *LPDIRECTMUSICPORTDOWNLOAD8;

/* Standard values for voice priorities. Numerically higher priorities are higher in priority.
 * These priorities are used to set the voice priority for all voices on a channel. They are
 * used in the dwPriority parameter of IDirectMusicPort::GetPriority and returned in the
 * lpwPriority parameter of pdwPriority.
 *
 * These priorities are shared with DirectSound.
 */

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000) 

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)
 
 
#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */


#undef  INTERFACE
#define INTERFACE  IDirectMusicPort
DECLARE_INTERFACE_(IDirectMusicPort, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPort */
    /*  */
    STDMETHOD(PlayBuffer)           (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(SetReadNotificationHandle) (THIS_ HANDLE hEvent) PURE;
    STDMETHOD(Read)                 (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument *pInstrument, 
                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
                                     DMUS_NOTERANGE *pNoteRanges,
                                     DWORD dwNumNoteRanges) PURE;
    STDMETHOD(UnloadInstrument)     (THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(DeviceIoControl)      (THIS_ DWORD dwIoControlCode, 
                                           LPVOID lpInBuffer, 
                                           DWORD nInBufferSize, 
                                           LPVOID lpOutBuffer, 
                                           DWORD nOutBufferSize, 
                                           LPDWORD lpBytesReturned, 
                                           LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwChannelGroups) PURE;
    STDMETHOD(GetNumChannelGroups)  (THIS_ LPDWORD pdwChannelGroups) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fActive) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize) PURE;
};

typedef IDirectMusicPort IDirectMusicPort8;
typedef IDirectMusicPort8 *LPDIRECTMUSICPORT8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicThru
DECLARE_INTERFACE_(IDirectMusicThru, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    /* IDirectMusicThru 
     */
    STDMETHOD(ThruChannel)          (THIS_ DWORD dwSourceChannelGroup, 
                                           DWORD dwSourceChannel, 
                                           DWORD dwDestinationChannelGroup,
                                           DWORD dwDestinationChannel,
                                           LPDIRECTMUSICPORT pDestinationPort) PURE;
};

typedef IDirectMusicThru IDirectMusicThru8;
typedef IDirectMusicThru8 *LPDIRECTMUSICTHRU8;

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif /* __IReferenceClock_INTERFACE_DEFINED__ */

DEFINE_GUID(CLSID_DirectMusic,0x636b9f10,0x0c7d,0x11d1,0x95,0xb2,0x00,0x20,0xaf,0xdc,0x74,0x21);
//DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);

DEFINE_GUID(IID_IDirectMusic,0x6536115a,0x7b2d,0x11d2,0xba,0x18,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicBuffer,0xd2ac2878, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPort, 0x08f2d8c9,0x37c2,0x11d2,0xb9,0xf9,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicThru, 0xced153e7, 0x3606, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortDownload,0xd2ac287a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownload,0xd2ac287b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicCollection,0xd2ac287c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicInstrument,0xd2ac287d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownloadedInstrument,0xd2ac287e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);


/* Alternate interface ID for IID_IDirectMusic, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusic2,0x6fc2cae1, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

DEFINE_GUID(IID_IDirectMusic8,0x2d3629f7,0x813d,0x4939,0x85,0x08,0xf0,0x5c,0x6b,0x75,0xfd,0x97);

#define IID_IDirectMusicThru8 IID_IDirectMusicThru
#define IID_IDirectMusicPortDownload8 IID_IDirectMusicPortDownload
#define IID_IDirectMusicDownload8 IID_IDirectMusicDownload
#define IID_IDirectMusicCollection8 IID_IDirectMusicCollection
#define IID_IDirectMusicInstrument8 IID_IDirectMusicInstrument
#define IID_IDirectMusicDownloadedInstrument8 IID_IDirectMusicDownloadedInstrument
#define IID_IDirectMusicPort8 IID_IDirectMusicPort


/* Property Query GUID_DMUS_PROP_GM_Hardware - Local GM set, no need to download
 * Property Query GUID_DMUS_PROP_GS_Hardware - Local GS set, no need to download
 * Property Query GUID_DMUS_PROP_XG_Hardware - Local XG set, no need to download
 * Property Query GUID_DMUS_PROP_DLS1        - Support DLS level 1
 * Property Query GUID_DMUS_PROP_INSTRUMENT2 - Support new INSTRUMENT2 download format
 * Property Query GUID_DMUS_PROP_XG_Capable  - Support minimum requirements of XG
 * Property Query GUID_DMUS_PROP_GS_Capable  - Support minimum requirements of GS
 * Property Query GUID_DMUS_PROP_SynthSink_DSOUND - Synthsink talks to DSound
 * Property Query GUID_DMUS_PROP_SynthSink_WAVE - Synthsink talks to Wave device
 *
 * Item 0: Supported
 * Returns a DWORD which is non-zero if the feature is supported
 */
DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_DLS2,        0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_INSTRUMENT2, 0x865fd372, 0x9f67, 0x11d2, 0x87, 0x2a, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_DSOUND,0xaa97844, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_WAVE,0xaa97845, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

/* Property Get/Set GUID_DMUS_PROP_WriteLatency
 *
 * Item 0: Synth buffer write latency, in milliseconds
 * Get/Set SynthSink latency, the average time after the play head that the next buffer gets written.
 */
DEFINE_GUID(GUID_DMUS_PROP_WriteLatency,0x268a0fa0, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get/Set GUID_DMUS_PROP_WritePeriod
 *
 * Item 0: Synth buffer write period, in milliseconds
 * Get/Set SynthSink buffer write period, time span between successive writes.
 */
DEFINE_GUID(GUID_DMUS_PROP_WritePeriod,0x268a0fa1, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get GUID_DMUS_PROP_MemorySize
 *
 * Item 0: Memory size
 * Returns a DWORD containing the total number of bytes of sample RAM
 */
DEFINE_GUID(GUID_DMUS_PROP_MemorySize,  0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_WavesReverb
 *
 * Item 0: DMUS_WAVES_REVERB structure
 * Sets reverb parameters
 */
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb,0x4cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_Effects
 *
 * Item 0: DWORD with effects flags. 
 * Get/Set effects bits, same as dwEffectFlags in DMUS_PORTPARAMS and DMUS_PORTCAPS:
 * DMUS_EFFECT_NONE 
 * DMUS_EFFECT_REVERB 
 * DMUS_EFFECT_CHORUS 
 */
DEFINE_GUID(GUID_DMUS_PROP_Effects, 0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Set GUID_DMUS_PROP_LegacyCaps
 *
 * Item 0: The MIDINCAPS or MIDIOUTCAPS which describes the port's underlying WinMM device. This property is only supported
 * by ports which wrap WinMM devices.
 */

DEFINE_GUID(GUID_DMUS_PROP_LegacyCaps,0xcfa7cdc2, 0x00a1, 0x11d2, 0xaa, 0xd5, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_Volume
 *
 * Item 0: A long which contains an offset, in 1/100 dB, to be added to the final volume
 *
 */
DEFINE_GUID(GUID_DMUS_PROP_Volume, 0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Min and Max values for setting volume with GUID_DMUS_PROP_Volume */

#define DMUS_VOLUME_MAX     2000        /* +20 dB */
#define DMUS_VOLUME_MIN   -20000        /* -200 dB */


#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICC_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dmusicf.h ===
/************************************************************************
*                                                                       *
*   dmusicf.h -- This module defines the DirectMusic file formats       *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICF_
#define _DMUSICF_

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef XBOX
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif
#else
#include <mmsystem.h>
#endif // XBOX

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicCollection;
#ifndef __cplusplus 
typedef interface IDirectMusicCollection IDirectMusicCollection;
#endif

/* Common chunks */

#define DMUS_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DMUS_FOURCC_INFO_LIST         mmioFOURCC('I','N','F','O')
#define DMUS_FOURCC_UNFO_LIST         mmioFOURCC('U','N','F','O')
#define DMUS_FOURCC_UNAM_CHUNK        mmioFOURCC('U','N','A','M')
#define DMUS_FOURCC_UART_CHUNK        mmioFOURCC('U','A','R','T')
#define DMUS_FOURCC_UCOP_CHUNK        mmioFOURCC('U','C','O','P')
#define DMUS_FOURCC_USBJ_CHUNK        mmioFOURCC('U','S','B','J')
#define DMUS_FOURCC_UCMT_CHUNK        mmioFOURCC('U','C','M','T')
#define DMUS_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DMUS_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')

/* The following structures are used by the Tracks, and are the packed structures */
/* that are passed to the Tracks inside the IStream. */


typedef struct _DMUS_IO_SEQ_ITEM
{
    MUSIC_TIME    mtTime;
    MUSIC_TIME    mtDuration;
    DWORD         dwPChannel;
    short         nOffset; 
    BYTE          bStatus;
    BYTE          bByte1;
    BYTE          bByte2;
} DMUS_IO_SEQ_ITEM;


typedef struct _DMUS_IO_CURVE_ITEM
{
    MUSIC_TIME  mtStart;
    MUSIC_TIME  mtDuration;
    MUSIC_TIME  mtResetDuration;
    DWORD       dwPChannel;
    short       nOffset;
    short       nStartValue;
    short       nEndValue;
    short       nResetValue;
    BYTE        bType;
    BYTE        bCurveShape;
    BYTE        bCCData;
    BYTE        bFlags;
    /* Following was added for DX8. */
    WORD        wParamType;      /* RPN or NRPN parameter number. */
    WORD        wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.) */
} DMUS_IO_CURVE_ITEM;


typedef struct _DMUS_IO_TEMPO_ITEM
{
    MUSIC_TIME    lTime;
    double        dblTempo;
} DMUS_IO_TEMPO_ITEM;


typedef struct _DMUS_IO_SYSEX_ITEM
{
    MUSIC_TIME    mtTime;
    DWORD         dwPChannel;
    DWORD         dwSysExLength;
} DMUS_IO_SYSEX_ITEM;

/* Style chunks */

#define DMUS_FOURCC_STYLE_FORM            mmioFOURCC('D','M','S','T')
#define DMUS_FOURCC_STYLE_CHUNK           mmioFOURCC('s','t','y','h')
#define DMUS_FOURCC_PART_LIST             mmioFOURCC('p','a','r','t')
#define DMUS_FOURCC_PART_CHUNK            mmioFOURCC('p','r','t','h')
#define DMUS_FOURCC_NOTE_CHUNK            mmioFOURCC('n','o','t','e')
#define DMUS_FOURCC_CURVE_CHUNK           mmioFOURCC('c','r','v','e')
#define DMUS_FOURCC_MARKER_CHUNK          mmioFOURCC('m','r','k','r')
#define DMUS_FOURCC_RESOLUTION_CHUNK      mmioFOURCC('r','s','l','n')
#define DMUS_FOURCC_ANTICIPATION_CHUNK    mmioFOURCC('a','n','p','n')
#define DMUS_FOURCC_PATTERN_LIST          mmioFOURCC('p','t','t','n')
#define DMUS_FOURCC_PATTERN_CHUNK         mmioFOURCC('p','t','n','h')
#define DMUS_FOURCC_RHYTHM_CHUNK          mmioFOURCC('r','h','t','m')
#define DMUS_FOURCC_PARTREF_LIST          mmioFOURCC('p','r','e','f')
#define DMUS_FOURCC_PARTREF_CHUNK         mmioFOURCC('p','r','f','c')
#define DMUS_FOURCC_STYLE_PERS_REF_LIST   mmioFOURCC('p','r','r','f')
#define DMUS_FOURCC_MOTIFSETTINGS_CHUNK   mmioFOURCC('m','t','f','s')

/* Flags used by variations: these make up the DWORDs in dwVariationChoices.               */

/* These flags determine the types of chords supported by a given variation in DirectMusic */
/* mode.  The first seven flags (bits 1-7) are set if the variation supports major chords  */
/* rooted in scale positions, so, e.g., if bits 1, 2, and 4 are set, the variation         */
/* supports major chords rooted in the tonic, second, and fourth scale positions.  The     */
/* next seven flags serve the same purpose, but for minor chords, and the following seven  */
/* flags serve the same purpose for chords that are not major or minor (e.g., SUS 4        */
/* chords).  Bits 22, 23, and 24 are set if the variation supports chords rooted in the    */
/* scale, chords rooted sharp of scale tones, and chords rooted flat of scale tones,       */
/* respectively.  For example, to support a C# minor chord in the scale of C Major,        */
/* bits 8 (for tonic minor) and 24 (for sharp) need to be set.  Bits 25, 26, an 27 handle  */
/* chords that are triads, 6th or 7th chords, and chords with extensions, respectively.    */
/* bits 28 and 29 handle chords that are followed by tonic and dominant chords,            */
/* respectively.                                                                           */
#define DMUS_VARIATIONF_MAJOR        0x0000007F /* Seven positions in the scale - major chords. */    
#define DMUS_VARIATIONF_MINOR        0x00003F80 /* Seven positions in the scale - minor chords. */    
#define DMUS_VARIATIONF_OTHER        0x001FC000 /* Seven positions in the scale - other chords. */    
#define DMUS_VARIATIONF_ROOT_SCALE   0x00200000 /* Handles chord roots in the scale. */         
#define DMUS_VARIATIONF_ROOT_FLAT    0x00400000 /* Handles flat chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_ROOT_SHARP   0x00800000 /* Handles sharp chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_TYPE_TRIAD   0x01000000 /* Handles simple chords - triads. */  
#define DMUS_VARIATIONF_TYPE_6AND7   0x02000000 /* Handles simple chords - 6 and 7. */  
#define DMUS_VARIATIONF_TYPE_COMPLEX 0x04000000 /* Handles complex chords. */  
#define DMUS_VARIATIONF_DEST_TO1     0x08000000 /* Handles transitions to 1 chord. */  
#define DMUS_VARIATIONF_DEST_TO5     0x10000000 /* Handles transitions to 5 chord. */  
#define DMUS_VARIATIONF_DEST_OTHER   0x40000000 /* Handles transitions to chords other than 1 . */  

/* legacy mask for variation modes */
#define DMUS_VARIATIONF_MODES        0xE0000000
/* Bits 29 and 31 of the variation flags are the Mode bits.  If both are 0, it's IMA. */  
/* If bit 29 is 1, it's Direct Music. */
#define DMUS_VARIATIONF_MODES_EX     (0x20000000 | 0x80000000)
#define DMUS_VARIATIONF_IMA25_MODE   0x00000000
#define DMUS_VARIATIONF_DMUS_MODE    0x20000000

/* Set this if the part uses marker events */
#define DMUS_PARTF_USE_MARKERS       0x1
/* Set this if the part is allowed to switch only on chord-aligned markers */
#define DMUS_PARTF_ALIGN_CHORDS      0x2

/* These specify if the marker event signals whether to stop a variation or start a 
pattern/variation (or both), and whether new variations must align with a chord */
#define DMUS_MARKERF_START            0x1
#define DMUS_MARKERF_STOP             0x2
#define DMUS_MARKERF_CHORD_ALIGN      0x4

/* if this flag is set, variation settings in a playing pattern-based track's state data will 
persist in the track after it stops playing */
#define DMUS_PATTERNF_PERSIST_CONTROL 0x1

/* These specify possible values for DMUS_IO_PARTREF.bRandomVariation
   all but DMUS_VARIATIONT_SEQUENTIAL and DMUS_VARIATIONT_RANDOM are dx8. */
typedef enum enumDMUS_VARIATIONT_TYPES
{
    DMUS_VARIATIONT_SEQUENTIAL       = 0, /* Play sequential starting with variation 1. */
    DMUS_VARIATIONT_RANDOM           = 1, /* Play randomly. */
    DMUS_VARIATIONT_RANDOM_START     = 2, /* Play sequential starting with a random variation. */
    DMUS_VARIATIONT_NO_REPEAT        = 3, /* Play randomly, but don't play the same variation twice. */
    DMUS_VARIATIONT_RANDOM_ROW       = 4  /* Play randomly as a row: don't repeat any variation until all have played. */
} DMUS_VARIATIONT_TYPES;

#pragma pack(2)

typedef struct _DMUS_IO_TIMESIG
{
    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE    bBeat;              /* what note receives the beat (bottom of time sig.) */
                                /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIG;

typedef struct _DMUS_IO_STYLE
{
    DMUS_IO_TIMESIG     timeSig;        /* Styles have a default Time Signature */
    double              dblTempo;   
} DMUS_IO_STYLE;

typedef struct _DMUS_IO_VERSION
{
    DWORD               dwVersionMS;        /* Version # high-order 32 bits */
    DWORD               dwVersionLS;        /* Version # low-order 32 bits  */
} DMUS_IO_VERSION;

typedef struct _DMUS_IO_PATTERN
{
    DMUS_IO_TIMESIG     timeSig;           /* Patterns can override the Style's Time sig. */
    BYTE                bGrooveBottom;     /* bottom of groove range */
    BYTE                bGrooveTop;        /* top of groove range */
    WORD                wEmbellishment;    /* Fill, Break, Intro, End, Normal, Motif */
    WORD                wNbrMeasures;      /* length in measures */
    BYTE                bDestGrooveBottom; /* bottom of groove range for next pattern */
    BYTE                bDestGrooveTop;    /* top of groove range for next pattern */
    DWORD               dwFlags;           /* various flags */
} DMUS_IO_PATTERN;

typedef struct _DMUS_IO_STYLEPART
{
    DMUS_IO_TIMESIG     timeSig;        /* can override pattern's */
    DWORD               dwVariationChoices[32]; /* MOAW choice bitfield */
    GUID                guidPartID;     /* identifies the part */
    WORD                wNbrMeasures;   /* length of the Part */
    BYTE                bPlayModeFlags; /* see PLAYMODE flags */
    BYTE                bInvertUpper;   /* inversion upper limit */
    BYTE                bInvertLower;   /* inversion lower limit */
    BYTE                bPad[3];        /* for DWORD alignment */
    DWORD               dwFlags;        /* various flags */ 
} DMUS_IO_STYLEPART;

typedef struct _DMUS_IO_PARTREF
{
    GUID    guidPartID;         /* unique ID for matching up with parts */
    WORD    wLogicalPartID;     /* corresponds to port/device/midi channel OBSOLETE */
    BYTE    bVariationLockID;   /* parts with the same ID lock variations. */
                                /* high bit is used to identify master Part */
    BYTE    bSubChordLevel;     /* tells which sub chord level this part wants */
    BYTE    bPriority;          /* 256 priority levels. Parts with lower priority */
                                /* aren't played first when a device runs out of */
                                /* notes */
    BYTE    bRandomVariation;   /* when set, matching variations play in random order */
                                /* when clear, matching variations play sequentially */
    WORD    wPad;               /* not used */
    DWORD   dwPChannel;         /* replaces wLogicalPartID */
} DMUS_IO_PARTREF;

typedef struct _DMUS_IO_STYLENOTE
{
    MUSIC_TIME  mtGridStart;    /* when this note occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this note lasts */
    short       nTimeOffset;    /* offset from mtGridStart */
    WORD        wMusicValue;    /* Position in scale. */
    BYTE        bVelocity;      /* Note velocity. */
    BYTE        bTimeRange;     /* Range to randomize start time. */
    BYTE        bDurRange;      /* Range to randomize duration. */
    BYTE        bVelRange;      /* Range to randomize velocity. */
    BYTE        bInversionID;   /* Identifies inversion group to which this note belongs */
    BYTE        bPlayModeFlags; /* Can override part */
    /* Following exists only under DX8 and on */
    BYTE        bNoteFlags;     /* values from DMUS_NOTEF_FLAGS */
} DMUS_IO_STYLENOTE;

typedef struct _DMUS_IO_STYLECURVE
{
    MUSIC_TIME  mtGridStart;    /* when this curve occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this curve lasts */
    MUSIC_TIME  mtResetDuration;/* how long after the end of the curve to reset the curve */
    short       nTimeOffset;    /* offset from mtGridStart */
    short       nStartValue;    /* curve's start value */
    short       nEndValue;      /* curve's end value */
    short       nResetValue;    /* the value to which to reset the curve */
    BYTE        bEventType;     /* type of curve */
    BYTE        bCurveShape;    /* shape of curve */
    BYTE        bCCData;        /* CC# */
    BYTE        bFlags;         /* Bit 1=TRUE means to send nResetValue. Otherwise, don't.
                                   Other bits are reserved. */
    /*  Following was added for DX8. */
    WORD        wParamType;      /* RPN or NRPN parameter number. */
    WORD        wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.) */
} DMUS_IO_STYLECURVE;

typedef struct _DMUS_IO_STYLEMARKER
{
    MUSIC_TIME  mtGridStart;    /* when this marker occurs */
    DWORD       dwVariation;    /* variation bits */
    WORD        wMarkerFlags;   /* how the marker is used */
} DMUS_IO_STYLEMARKER;

typedef struct _DMUS_IO_STYLERESOLUTION
{
    DWORD    dwVariation;       /* variation bits */
    WORD     wMusicValue;       /* Position in scale. */
    BYTE     bInversionID;      /* Identifies inversion group to which this note belongs */
    BYTE     bPlayModeFlags;    /* Can override part */
} DMUS_IO_STYLERESOLUTION;

typedef struct _DMUS_IO_STYLE_ANTICIPATION
{
    MUSIC_TIME    mtGridStart;   /* when this anticipation occurs */
    DWORD         dwVariation;   /* variation bits */
    short         nTimeOffset;   /* offset from mtGridStart */
    BYTE          bTimeRange;    /* Range to randomize start time. */
} DMUS_IO_STYLE_ANTICIPATION;

typedef struct _DMUS_IO_MOTIFSETTINGS
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than mtLoopStart. Or, 0, indicating loop full motif.  */
    DWORD       dwResolution;   /* Default resolution. */
} DMUS_IO_MOTIFSETTINGS;

#pragma pack()


/*
RIFF
(
    'DMST'          // Style
    <styh-ck>       // Style header chunk
    <guid-ck>       // Every Style has a GUID
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<vers-ck>]     // version chunk
    <part-list>...  // Array of parts in the Style, used by patterns
    <pttn-list>...  // Array of patterns in the Style
    <DMBD-form>...  // Array of bands in the Style
    [<prrf-list>]...// Optional array of chord map references in the Style
)

    // <styh-ck>
    styh
    (
        <DMUS_IO_STYLE>
    )

    // <guid-ck>
    guid
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <part-list>
    LIST
    (
        'part'
        <prth-ck>       // Part header chunk
        [<UNFO-list>]   // Name, author, copyright info., comments
        [<note-ck>]     // Optional chunk containing an array of notes in Part
        [<crve-ck>]     // Optional chunk containing an array of curves in Part
        [<mrkr-ck>]     // Optional chunk containing an array of markers in Part
        [<rsln-ck>]     // Optional chunk containing an array of variation resolutions in Part
        [<anpn-ck>]     // Optional chunk containing an array of resolution anticipations in Part
    )

        // <orth-ck>
        prth
        (
            <DMUS_IO_STYLEPART>
        )

        // <note-ck>
        'note'
        (
            // sizeof DMUS_IO_STYLENOTE:DWORD
            <DMUS_IO_STYLENOTE>...
        )

        // <crve-ck>
        'crve'
        (
            // sizeof DMUS_IO_STYLECURVE:DWORD
            <DMUS_IO_STYLECURVE>...
        )

        // <mrkr-ck>
        'mrkr'
        (
            // sizeof DMUS_IO_STYLEMARKER:DWORD
            <DMUS_IO_STYLEMARKER>...
        )

        // <rsln-ck>
        'rsln'
        (
            // sizeof DMUS_IO_STYLERESOLUTION:DWORD
            <DMUS_IO_STYLERESOLUTION>...
        )

        // <anpn-ck>
        'anpn'
        (
            // sizeof DMUS_IO_STYLE_ANTICIPATION:DWORD
            <DMUS_IO_STYLE_ANTICIPATION>...
        )

    // <pttn-list>
    LIST
    (
        'pttn'
        <ptnh-ck>       // Pattern header chunk
        <rhtm-ck>       // Chunk containing an array of rhythms for chord matching
        [<UNFO-list>]   // Name, author, copyright info., comments
        [<mtfs-ck>]     // Motif settings chunk
        [<DMBD-form>]   // Optional band to be associated with the pattern (for motifs)
        <pref-list>...  // Array of part reference id's
    )

        // <ptnh-ck>
        ptnh
        (
            <DMUS_IO_PATTERN>
        )

        // <rhtm-ck>
        'rhtm'
        (
            // DWORD's representing rhythms for chord matching based on number
            // of measures in the pattern
        )


        // pref-list
        LIST
        (
            'pref'
            <prfc-ck>   // part ref chunk
        )

        // <prfc-ck>
        prfc
        (
            <DMUS_IO_PARTREF>
        )

        // <mtfs-ck>
        mtfs
        (
            <DMUS_IO_MOTIFSETTINGS>
        )

    // <prrf-list>
    LIST
    (
        'prrf'
        <DMRF-list>... // Array of Chordmap references
    )
*/

/* Pattern chunk, for use in Pattern tracks */

#define DMUS_FOURCC_PATTERN_FORM        mmioFOURCC('D','M','P','T')

/*
RIFF
(
    'DMPT'          // Pattern
    <styh-ck>       // Style header chunk
    <pttn-list>     // The pattern, in single pattern format (includes DMUS_FOURCC_PART_LIST chunks)
)
*/


/* Chord and command file formats */

/* These specify possible values for DMUS_IO_COMMAND.bRepeatMode (dx8) */
typedef enum enumDMUS_PATTERNT_TYPES
{
    DMUS_PATTERNT_RANDOM           = 0, /* Play randomly. (dx7 behavior) */
    DMUS_PATTERNT_REPEAT           = 1, /* Repeat last pattern. */
    DMUS_PATTERNT_SEQUENTIAL       = 2, /* Play sequential starting with first matching pattern. */
    DMUS_PATTERNT_RANDOM_START     = 3, /* Play sequential starting with a random pattern. */
    DMUS_PATTERNT_NO_REPEAT        = 4, /* Play randomly, but don't play the same pattern twice. */
    DMUS_PATTERNT_RANDOM_ROW       = 5  /* Play randomly as a row: don't repeat any pattern until all have played. */
} DMUS_PATTERNT_TYPES;

#define DMUS_FOURCC_CHORDTRACK_LIST         mmioFOURCC('c','o','r','d')
#define DMUS_FOURCC_CHORDTRACKHEADER_CHUNK  mmioFOURCC('c','r','d','h')
#define DMUS_FOURCC_CHORDTRACKBODY_CHUNK    mmioFOURCC('c','r','d','b')

#define DMUS_FOURCC_COMMANDTRACK_CHUNK      mmioFOURCC('c','m','n','d')

typedef struct _DMUS_IO_CHORD
{
    WCHAR       wszName[16];    /* Name of the chord */
    MUSIC_TIME  mtTime;         /* Time of this chord */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bFlags;         /* Various flags */
} DMUS_IO_CHORD;

typedef struct _DMUS_IO_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_IO_SUBCHORD;

typedef struct _DMUS_IO_COMMAND
{
    MUSIC_TIME  mtTime;         /* Time of this command */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bCommand;       /* Command type (see #defines below) */
    BYTE        bGrooveLevel;   /* Groove level (0 if command is not a groove) */
    BYTE        bGrooveRange;   /* Groove range  */
    BYTE        bRepeatMode;    /* Used to control selection of patterns with same groove level  */
} DMUS_IO_COMMAND;


/*

    // <cord-list>
    LIST
    (
        'cord'
        <crdh-ck>
        <crdb-ck>       // Chord body chunk
    )

        // <crdh-ck>
        crdh
        (
            // Scale: dword (upper 8 bits for root, lower 24 for scale)
        )

        // <crdb-ck>
        crdb
        (
            // sizeof DMUS_IO_CHORD:dword
            <DMUS_IO_CHORD>
            // # of DMUS_IO_SUBCHORDS:dword
            // sizeof DMUS_IO_SUBCHORDS:dword
            // a number of <DMUS_IO_SUBCHORD>
        )


    // <cmnd-list>
    'cmnd'
    (
        //sizeof DMUS_IO_COMMAND: DWORD
        <DMUS_IO_COMMAND>...
    )

*/

/*  File io for DirectMusic Tool and ToolGraph objects
*/

/* RIFF ids: */

#define DMUS_FOURCC_TOOLGRAPH_FORM  mmioFOURCC('D','M','T','G')
#define DMUS_FOURCC_TOOL_LIST       mmioFOURCC('t','o','l','l')
#define DMUS_FOURCC_TOOL_FORM       mmioFOURCC('D','M','T','L')
#define DMUS_FOURCC_TOOL_CHUNK      mmioFOURCC('t','o','l','h')

/* io structures: */

typedef struct _DMUS_IO_TOOL_HEADER
{
    GUID        guidClassID;    /* Class id of tool. */
    long        lIndex;         /* Position in graph. */
    DWORD       cPChannels;     /* Number of items in channels array. */
    FOURCC      ckid;           /* chunk ID of tool's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid. */
    DWORD       dwPChannels[1]; /* Array of PChannels, size determined by cPChannels. */
} DMUS_IO_TOOL_HEADER;

/*
RIFF
(
    'DMTG'          // DirectMusic ToolGraph chunk
    [<guid-ck>]     // GUID for ToolGraph
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <toll-list>     // List of Tools
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <toll-list>
    LIST
    (
        'toll'          // Array of tools
        <DMTL-form>...  // Each tool is encapsulated in a RIFF chunk
    )

// <DMTL-form>      Tools are embedded in a graph. Theoretically, they can be saved as individual files too.
RIFF
(
    'DMTL'
    <tolh-ck>
    [<data>]        // Tool data. Must be a RIFF readable chunk.
)

    // <tolh-ck>            // Tool header chunk
    (
        'tolh'
        <DMUS_IO_TOOL_HEADER>   // Tool header
    )
*/

/*  The AudioPath file carries everything for describing a specific audio path,
    including Tool Graph and Buffer Descriptor.
    This can even be used for configuring a complete performance.
*/

#define DMUS_FOURCC_AUDIOPATH_FORM  mmioFOURCC('D','M','A','P')

/*
RIFF
(
    'DMAP'          // DirectMusic AudioPath chunk
    [<guid-ck>]     // GUID for this Audio Path configuration
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMTG-form>]   // Optional ToolGraph
    [<pcsl-list>]   // Optional list of port configurations
    [<dbfl-list>]...// Optional array of Dsound buffer descriptors
)
*/

#define DMUS_FOURCC_PORTCONFIGS_LIST    mmioFOURCC('p','c','s','l')
#define DMUS_FOURCC_PORTCONFIG_LIST     mmioFOURCC('p','c','f','l')
#define DMUS_FOURCC_PORTCONFIG_ITEM     mmioFOURCC('p','c','f','h')
#define DMUS_FOURCC_PORTPARAMS_ITEM     mmioFOURCC('p','p','r','h')
#define DMUS_FOURCC_DSBUFFER_LIST       mmioFOURCC('d','b','f','l')
#define DMUS_FOURCC_DSBUFFATTR_ITEM     mmioFOURCC('d','d','a','h')
#define DMUS_FOURCC_MIXBINS_ITEM        mmioFOURCC('m','x','b','n')
#define DMUS_FOURCC_PCHANNELS_LIST      mmioFOURCC('p','c','h','l')
#define DMUS_FOURCC_PCHANNELS_ITEM      mmioFOURCC('p','c','h','h')

typedef struct _DMUS_IO_PORTCONFIG_HEADER
{
    GUID    guidPort;           /* GUID of requested port. */
    DWORD   dwPChannelBase;     /* PChannel that this should start on. */
    DWORD   dwPChannelCount;    /* How many channels. */
    DWORD   dwFlags;            /* Various flags. */
} DMUS_IO_PORTCONFIG_HEADER;

#define DMUS_PORTCONFIGF_DRUMSON10  1   /* This port configured for drums on channel 10. */
#define DMUS_PORTCONFIGF_USEDEFAULT 2   /* Use the default port. */

/* Each portconfig has one or more pchannel to buffer mappings. Each buffer
   is identified by a guid. Each pchannel can map to one or more buffers.
   This is defined with one or more DMUS_IO_PCHANNELTOBUFFER_HEADER
   structures. Each defines a range of PChannels and the set of buffers
   that they connect to. 
*/

typedef struct _DMUS_IO_PCHANNELTOBUFFER_HEADER
{
    DWORD   dwPChannelBase;     /* PChannel that this should start on. */
    DWORD   dwPChannelCount;    /* How many PChannels. */
    DWORD   dwBufferCount;      /* How many buffers do these connect to. */
    DWORD   dwFlags;            /* Various flags. Currently reserved for future use. Must be 0. */
} DMUS_IO_PCHANNELTOBUFFER_HEADER;

/* Each buffer is represented by an DSBC form. This is wrapped by the 
   DMUS_IO_BUFFER_ATTRIBUTES_HEADER which identifies how to use the
   buffer. In particular, it indicates whether this gets dynamically duplicated
   or all references to this should share the same instance. 
   To resolve references, the unique GUID of the buffer is also stored
   in this structure. 
*/
   
typedef struct _DMUS_IO_BUFFER_ATTRIBUTES_HEADER
{
    GUID    guidBufferID;       /* Each buffer config has a unique ID. */
    DWORD   dwFlags;            /* Various flags. */
} DMUS_IO_BUFFER_ATTRIBUTES_HEADER;

/* DMUS_IO_BUFFER_ATTRIBUTES_HEADER.dwFlags: */
#define DMUS_BUFFERF_SHARED     1   /* Share this with other audio paths, instead of creating unique copies. */
#define DMUS_BUFFERF_DEFINED    2   /* Use one of the standard predefined buffers (see GUID_Buffer... in dmusici.h.) */
#define DMUS_BUFFERF_MIXIN      8   /* This is a mixin buffer. */

typedef struct _DMUS_IO_BUFFER_MIXBINS_HEADER
{
    DWORD   dwMixBins;          /* Set of mixbins to control. */
    BYTE    bControllers[8];    /* Set of 8 controllers that manage the mixbins. */
} DMUS_IO_BUFFER_MIXBINS_HEADER;


/*

LIST
(
    'pcsl'          // Array of port configurations
    <pcfl-list>...  // One or more port configurations, each in a list chunk
)

LIST
(
    'pcfl'          // List container for one port configuration.
    <pcfh-ck>       // Portconfig header chunk.
    <pprh-ck>       // Port params, to be used to create the port.
    [<dbfl-list>]...// Optional array of Dsound buffer descriptors
    [<pchl-list>]   // Optional list of pchannel to buffer assignments

)

    // <pcfh-ck>            // Port config header chunk
    (
        'pcfh'
        <DMUS_IO_PORTCONFIG_HEADER>   // Port config header
    )

    // <pprh-ck>            // Port params header chunk
    (
        'pprh'
        <DMUS_PORTPARAMS8>   // Port params header
    )

LIST
(
    'pchl'          // List container for one or more pchannel to buffer assignments.
    <pchh-ck>...    // One or more pchannel to buffer assignment headers and data.

    // <pchh-ck>
    (
        'pchh'
        <DMUS_IO_PCHANNELTOBUFFER_HEADER>   // Description of PChannels
        <GUID>...                           // Array of GUIDs defining the buffers they all connect to.
    )
)

LIST
(
    'dbfl'          // List container for one buffer and buffer attributes header.
    <ddah-ck>       // Buffer attributes header. 
    [<mxbn-ck>]     // Optional mixbin list.
    [<DSBC-form>]   // Buffer configuration. Not required when header uses a predefined buffer type.

    // <ddah-ck>
    (
        'ddah'
        <DMUS_IO_BUFFER_ATTRIBUTES_HEADER>   // Buffer attributes.
    )
    // <mxbn-ck>
    (
        'mxbn'
        <DMUS_IO_BUFFER_MIXBINS_HEADER>       // Set of up to 8 mixbins.
    )    
)
*/

/*  File io for DirectMusic Band Track object */


/* RIFF ids: */
#define DMUS_FOURCC_BANDTRACK_FORM  mmioFOURCC('D','M','B','T')
#define DMUS_FOURCC_BANDTRACK_CHUNK mmioFOURCC('b','d','t','h')
#define DMUS_FOURCC_BANDS_LIST      mmioFOURCC('l','b','d','l')
#define DMUS_FOURCC_BAND_LIST       mmioFOURCC('l','b','n','d')
#define DMUS_FOURCC_BANDITEM_CHUNK  mmioFOURCC('b','d','i','h')
#define DMUS_FOURCC_BANDITEM_CHUNK2 mmioFOURCC('b','d','2','h')

/* io structures */
typedef struct _DMUS_IO_BAND_TRACK_HEADER
{
    BOOL bAutoDownload;     /* Determines if Auto-Download is enabled. */
} DMUS_IO_BAND_TRACK_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER
{
    MUSIC_TIME lBandTime;   /* Position in track list. */
} DMUS_IO_BAND_ITEM_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER2
{
    MUSIC_TIME lBandTimeLogical;   /* Position in track list. Time in the music with which band change is associated. */
    MUSIC_TIME lBandTimePhysical;  /* Precise time band change will take effect. Should be close to logical time. */
} DMUS_IO_BAND_ITEM_HEADER2;

/*
RIFF
(
    'DMBT'          // DirectMusic Band Track form-type
    [<bdth-ck>]     // Band track header
    [<guid-ck>]     // GUID for band track
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbdl-list>     // List of Band items
)

    // <bnth-ck>
    'bdth'
    (
        <DMUS_IO_BAND_TRACK_HEADER>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbdl-list>
    LIST
    (
        'lbdl'
        <lbnd-list>...  // Array of bands, each encapsulated in a list chunk
    )

        // <lbnd-list>
        LIST
        (
            'lbnd'
            <bdih-ck> or <bd2h-ck>  // bdih is a legacy format.  bd2h is preferred for new content.
            <DMBD-form> // Band
        )

            // <bdih-ck> or <bd2h-ck>       // band item header
            (
                <DMUS_IO_BAND_ITEM_HEADER> or <DMUS_IO_BAND_ITEM_HEADER2> // Band item header
            )
*/      


/*  File io for DirectMusic Band object
*/

/* RIFF ids: */

#define DMUS_FOURCC_BAND_FORM           mmioFOURCC('D','M','B','D')
#define DMUS_FOURCC_INSTRUMENTS_LIST    mmioFOURCC('l','b','i','l')
#define DMUS_FOURCC_INSTRUMENT_LIST     mmioFOURCC('l','b','i','n')
#define DMUS_FOURCC_INSTRUMENT_CHUNK    mmioFOURCC('b','i','n','s')

/* Flags for DMUS_IO_INSTRUMENT
 */
#define DMUS_IO_INST_PATCH          (1 << 0)        /* dwPatch is valid. */
#define DMUS_IO_INST_BANKSELECT     (1 << 1)        /* dwPatch contains a valid Bank Select MSB and LSB part */
#define DMUS_IO_INST_ASSIGN_PATCH   (1 << 3)        /* dwAssignPatch is valid */
#define DMUS_IO_INST_NOTERANGES     (1 << 4)        /* dwNoteRanges is valid */
#define DMUS_IO_INST_PAN            (1 << 5)        /* bPan is valid */
#define DMUS_IO_INST_VOLUME         (1 << 6 )       /* bVolume is valid */
#define DMUS_IO_INST_TRANSPOSE      (1 << 7)        /* nTranspose is valid */
#define DMUS_IO_INST_GM             (1 << 8)        /* Instrument is from GM collection */
#define DMUS_IO_INST_GS             (1 << 9)        /* Instrument is from GS collection */
#define DMUS_IO_INST_XG             (1 << 10)       /* Instrument is from XG collection */
#define DMUS_IO_INST_CHANNEL_PRIORITY (1 << 11)     /* dwChannelPriority is valid */
#define DMUS_IO_INST_USE_DEFAULT_GM_SET (1 << 12)   /* Always use the default GM set for this patch,  */
                                                    /* don't rely on the synth caps stating GM or GS in hardware. */
#define DMUS_IO_INST_PITCHBENDRANGE (1 << 13)     /* nPitchBendRange is valid */

/* io structures */
typedef struct _DMUS_IO_INSTRUMENT
{
    DWORD   dwPatch;            /* MSB, LSB and Program change to define instrument */
    DWORD   dwAssignPatch;      /* MSB, LSB and Program change to assign to instrument when downloading */
    DWORD   dwNoteRanges[4];    /* 128 bits; one for each MIDI note instrument needs to able to play */
    DWORD   dwPChannel;         /* PChannel instrument plays on */
    DWORD   dwFlags;            /* DMUS_IO_INST_ flags */
    BYTE    bPan;               /* Pan for instrument */
    BYTE    bVolume;            /* Volume for instrument */
    short   nTranspose;         /* Number of semitones to transpose notes */
    DWORD   dwChannelPriority;  /* Channel priority */
    short   nPitchBendRange;    /* Number of semitones shifted by pitch bend */
} DMUS_IO_INSTRUMENT;

/*
// <DMBD-form> bands can be embedded in other forms
RIFF
(
    'DMBD'          // DirectMusic Band chunk
    [<guid-ck>]     // GUID for band
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbil-list>     // List of Instruments
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbil-list>
    LIST
    (
        'lbil'          // Array of instruments
        <lbin-list>...  // Each instrument is encapsulated in a list
    )

        // <lbin-list>
        LIST
        (
            'lbin'
            <bins-ck>
            [<DMRF-list>]       // Optional reference to DLS Collection file.
        )

            // <bins-ck>            // Instrument chunk
            (
                'bins'
                <DMUS_IO_INSTRUMENT>    // Instrument header
            )
*/      

/* This RIFF id and io struct have been added to allow wave files (and the wave object) to 
   differentiate between streaming and one-shot waves, and to give a prefetch for streaming
   waves  */

#define DMUS_FOURCC_WAVEHEADER_CHUNK   mmioFOURCC('w','a','v','h')

typedef struct _DMUS_IO_WAVE_HEADER
{
    REFERENCE_TIME  rtReadAhead;    /* How far ahead in the stream wave data will be read (in REFERENCE_TIME).  Ignored for one-shot waves.  */
    DWORD           dwFlags;        /* Various flags, including whether this is a streaming wave and whether it can be invalidated. */
} DMUS_IO_WAVE_HEADER;


/*  File io for Wave track */

/* RIFF ids: */

#define DMUS_FOURCC_WAVETRACK_LIST      mmioFOURCC('w','a','v','t')
#define DMUS_FOURCC_WAVETRACK_CHUNK     mmioFOURCC('w','a','t','h')
#define DMUS_FOURCC_WAVEPART_LIST       mmioFOURCC('w','a','v','p')
#define DMUS_FOURCC_WAVEPART_CHUNK      mmioFOURCC('w','a','p','h')
#define DMUS_FOURCC_WAVEITEM_LIST       mmioFOURCC('w','a','v','i')
#define DMUS_FOURCC_WAVE_LIST           mmioFOURCC('w','a','v','e')
#define DMUS_FOURCC_WAVEITEM_CHUNK      mmioFOURCC('w','a','i','h')

/* This flag is included in DMUS_IO_WAVE_TRACK_HEADER.dwFlags.  If set, the track will get its 
   variations from a pattern track, via GetParam(GUID_Variations). */
#define DMUS_WAVETRACKF_SYNC_VAR   0x1
/* This is also included in DMUS_IO_WAVE_TRACK_HEADER.dwFlags.  If set, variation control 
   information will persist from one playback instance to the next.*/
#define DMUS_WAVETRACKF_PERSIST_CONTROL 0x2

typedef struct _DMUS_IO_WAVE_TRACK_HEADER
{
    long        lVolume;        /* Gain, in 1/100th of dB, to be applied to all waves.  Note:  All gain values should be negative. */
    DWORD       dwFlags;        /* Flags, including whether this track syncs to a pattern track for its variations. */
} DMUS_IO_WAVE_TRACK_HEADER;

typedef struct _DMUS_IO_WAVE_PART_HEADER
{
    long            lVolume;        /* Gain, in 1/100th of dB, to be applied to all waves in wave part.  Note:  All gain values should be negative. */
    DWORD           dwVariations;   /* Variation mask for which of 32 variations */
    DWORD           dwPChannel;     /* PChannel */
    DWORD           dwLockToPart;   /* Part ID to lock to. */
    DWORD           dwFlags;        /* Flags, including stuff for managing how variations are chosen (in low-order nibble) */
    DWORD           dwIndex;        /* Index for distinguishing multiple parts on the same PChannel*/
} DMUS_IO_WAVE_PART_HEADER;

typedef struct _DMUS_IO_WAVE_ITEM_HEADER
{
    long            lVolume;        /* Gain, in 1/100th of dB.  Note:  All gain values should be negative. */
    long            lPitch;         /* Pitch offset in 1/100th of a semitone. */
    DWORD           dwVariations;   /* Variation flags for which of 32 variations this wave belongs to. */
    REFERENCE_TIME  rtTime;         /* Start time, in REFERENCE_TIME, if clock time track, or MUSIC_TIME for music time track. */
    REFERENCE_TIME  rtStartOffset;  /* Distance into wave to start playback, in reference time units. */
    REFERENCE_TIME  rtReserved;     /* Reserved field. */
    REFERENCE_TIME  rtDuration;     /* Duration, in REFERENCE_TIME or MUSIC_TIME, depending on track timing format. */
    MUSIC_TIME      mtLogicalTime;  /* If in music track format, this indicates the musical boundary where this belongs. Otherwise, ignored. */
    DWORD           dwLoopStart;    /* Start point for a looping wave. */
    DWORD           dwLoopEnd;      /* End point for a looping wave. */
    DWORD           dwFlags;        /* Various flags, including whether this is a streaming wave and whether it can be invalidated. */
    WORD            wVolumeRange;   /* XBOX only: Random range for volume. */
    WORD            wPitchRange;    /* XBOX only: Random range for pitch. */
} DMUS_IO_WAVE_ITEM_HEADER;

/*
LIST
{
    'wavt'          // Wave track chunk
    <wath-ck>       // Wave track header
    <wavp-list>...  // Array of Wave Parts
}
    // <wath-ck>
    'wath'
    {
        <DMUS_IO_WAVE_TRACK_HEADER>
    }

    //  <wavp-list>
    LIST
    {
        'wavp'
        <waph-ck>       //  Wave Part Header
        <wavi-list>     //  List of wave items
    }

        //  <waph-ck>
        'waph'
        {
            <DMUS_IO_WAVE_PART_HEADER>
        }

        //  <wavi-list>
        LIST
        {
            'wavi'
            <wave-list>...  //  Array of waves; each wave is encapsulated in a list
        }

            //  <wave-list>
            LIST
            {
                'wave'
                <waih-ck>       //  Wave item header
                <DMRF-list>     //  Reference to wave object
            }

                //  <waih-ck>
                'waih'
                {
                    <DMUS_IO_WAVE_ITEM_HEADER>
                }

*/

/*  File io for DirectMusic Container file. This embeds a set of related files. And,
    in turn, it can be embedded within a segment or script file.
*/

#define DMUS_FOURCC_CONTAINER_FORM          mmioFOURCC('D','M','C','N')
#define DMUS_FOURCC_CONTAINER_CHUNK         mmioFOURCC('c','o','n','h')
#define DMUS_FOURCC_CONTAINED_ALIAS_CHUNK   mmioFOURCC('c','o','b','a')
#define DMUS_FOURCC_CONTAINED_OBJECT_CHUNK  mmioFOURCC('c','o','b','h')
#define DMUS_FOURCC_CONTAINED_OBJECTS_LIST  mmioFOURCC('c','o','s','l')
#define DMUS_FOURCC_CONTAINED_OBJECT_LIST   mmioFOURCC('c','o','b','l')

typedef struct _DMUS_IO_CONTAINER_HEADER
{
    DWORD       dwFlags;        /* Flags. */
} DMUS_IO_CONTAINER_HEADER;

#define DMUS_CONTAINER_NOLOADS  (1 << 1)   /* Contained items are not loaded when the container is loaded.
                                              Entries will be created in the loader (via SetObject) but
                                              the actual objects will not be created until they are
                                              specifically loaded at a later time. */

typedef struct _DMUS_IO_CONTAINED_OBJECT_HEADER
{
    GUID        guidClassID;    /* Class id of object. */
    DWORD       dwFlags;        /* Flags, for example DMUS_CONTAINED_OBJF_KEEP. */
    FOURCC      ckid;           /* chunk ID of track's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid */
        /* Note that LIST:DMRF may be used for ckid and fccType in order to reference an
           object instead of embedding it within the container. */
} DMUS_IO_CONTAINED_OBJECT_HEADER;

#define DMUS_CONTAINED_OBJF_KEEP    1   /* Keep the object cached in the loader after the container is released. */

/*
RIFF
(
    'DMCN'          // DirectMusic Container chunk
    <conh-ck>       // Container header chunk
    [<guid-ck>]     // GUID for container
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <cosl-list>     // List of objects.
)

    // <conh-ck>        
    'conh'
    (
        <DMUS_IO_CONTAINER_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    LIST
    (
        'cosl'          // Array of embedded objects.
        <cobl-list>...  // Each object is encapsulated in a LIST chunk
    )

    // <cobl-list>      // Encapsulates one object
    LIST
    (
        'cobl'
        [<coba-ck>]         // Alias.  An alternative name by which this object is known
                            // within the container.
        <cobh-ck>           // Required header, includes CLASS ID for object.
        [<data>] or <DMRF>  // Object data of the type specified in <cobh-ck>.
                            // If DMRF, it is a reference of where to find the object.
                            // Otherwise, it could be any RIFF readable chunk in the
                            //    exact same format as a file.  The object will load
                            //    itself from this data.
    )

    // <coba-ck>
    'coba'
    (
        // Alias, stored as NULL terminated string of WCHARs
    )

    // <cobh-ck>
    'cobh'
    (
        <DMUS_IO_CONTAINED_OBJECT_HEADER>
    )
*/

/*  File io for DirectMusic Segment object */

/* RIFF ids: */

#define DMUS_FOURCC_SEGMENT_FORM        mmioFOURCC('D','M','S','G')
#define DMUS_FOURCC_SEGMENT_CHUNK       mmioFOURCC('s','e','g','h')
#define DMUS_FOURCC_TRACK_LIST          mmioFOURCC('t','r','k','l')
#define DMUS_FOURCC_TRACK_FORM          mmioFOURCC('D','M','T','K')
#define DMUS_FOURCC_TRACK_CHUNK         mmioFOURCC('t','r','k','h')
#define DMUS_FOURCC_TRACK_EXTRAS_CHUNK  mmioFOURCC('t','r','k','x')

/* io structures:*/

typedef struct _DMUS_IO_SEGMENT_HEADER
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtLength;       /* Length, in music time. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than dwPlayStart. Or, 0, indicating loop full segment. */
    DWORD       dwResolution;   /* Default resolution. */
    /* Following added for DX8: */
    REFERENCE_TIME rtLength;    /* Length, in reference time (overrides music time length.) */
    DWORD       dwFlags;
    DWORD       dwReserved;     /* Reserved. */
    /* Added for XBOX. */
    REFERENCE_TIME rtLoopStart; /* Clock time loop start. */
    REFERENCE_TIME rtLoopEnd;   /* Clock time loop end. */
} DMUS_IO_SEGMENT_HEADER;

#define DMUS_SEGIOF_REFLENGTH   1  /* Use the time in rtLength for the segment length. */
#define DMUS_SEGIOF_REFLOOP     2  /* Use the values in rtLoopStart and rtLoopEnd to do clock time looping. */

typedef struct _DMUS_IO_TRACK_HEADER
{
    GUID        guidClassID;    /* Class id of track. */
    DWORD       dwPosition;     /* Position in track list. */
    DWORD       dwGroup;        /* Group bits for track. */
    FOURCC      ckid;           /* chunk ID of track's data chunk. */
    FOURCC      fccType;        /* list type if ckid is RIFF or LIST */ 
} DMUS_IO_TRACK_HEADER;

/*  Additional parameters for the track header chunk, introduced in DX8 and
    on, are stored in a separate chunk. */

typedef struct _DMUS_IO_TRACK_EXTRAS_HEADER
{
    DWORD       dwFlags;        /* DX8 Added flags for control tracks. */
    DWORD       dwPriority;     /* Priority for composition. */
} DMUS_IO_TRACK_EXTRAS_HEADER;

/*
RIFF
(
    'DMSG'          // DirectMusic Segment chunk
    <segh-ck>       // Segment header chunk
    [<guid-ck>]     // GUID for segment
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMCN-form>]   // Optional container of objects embedded in file. Must precede tracklist.
    <trkl-list>     // List of Tracks
    [<DMTG-form>]   // Optional ToolGraph
    [<DMAP-form>]   // Optional Audio Path
)

    // <segh-ck>        
    'segh'
    (
        <DMUS_IO_SEGMENT_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <trkl-list>
    LIST
    (
        'trkl'          // Array of tracks
        <DMTK-form>...  // Each track is encapsulated in a RIFF chunk
    )

    // <DMTK-form>      // Tracks can be embedded in a segment or stored as separate files.
    RIFF
    (
        'DMTK'
        <trkh-ck>
        [<trkx-ck>]     // Optional track flags. 
        [<guid-ck>]     // Optional GUID for track object instance (not to be confused with Class id in track header)
        [<vers-ck>]     // Optional version info
        [<UNFO-list>]   // Optional name, author, copyright info., comments
        [<data>]        // Track data. Must be a RIFF readable chunk.
    )

    // <trkh-ck>            // Track header chunk
    (
        'trkh'
        <DMUS_IO_TRACK_HEADER>  // Track header
    )

    // <trkx-ck>            // Track flags chunk
    (
        'trkx'
        <DMUS_IO_TRACK_EXTRAS_HEADER>  // DX8 Track flags header
    )
*/

/*  File io for DirectMusic Song object */
/*  Note: Song file format is not supported in DX8. */

/* RIFF ids: */

#define DMUS_FOURCC_SONG_FORM           mmioFOURCC('D','M','S','O') /* Entire song. */
#define DMUS_FOURCC_SONG_CHUNK          mmioFOURCC('s','n','g','h') /* Song header info. */
#define DMUS_FOURCC_SONGSEGMENTS_LIST   mmioFOURCC('s','e','g','l') /* List of embedded segments. */
#define DMUS_FOURCC_SONGSEGMENT_LIST    mmioFOURCC('s','s','g','l') /* Container for a segment or segment reference. */
#define DMUS_FOURCC_TOOLGRAPHS_LIST     mmioFOURCC('t','l','g','l') /* List of embedded tool graphs. */
#define DMUS_FOURCC_SEGREFS_LIST        mmioFOURCC('s','r','s','l') /* List of segment references. */
#define DMUS_FOURCC_SEGREF_LIST         mmioFOURCC('s','g','r','l') /* Container for a segment reference. */
#define DMUS_FOURCC_SEGREF_CHUNK        mmioFOURCC('s','g','r','h') /* Segment reference header. */
#define DMUS_FOURCC_SEGTRANS_CHUNK      mmioFOURCC('s','t','r','h') /* Set of transitions to this segment. */
#define DMUS_FOURCC_TRACKREFS_LIST      mmioFOURCC('t','r','s','l') /* Set of track references within the segment reference. */
#define DMUS_FOURCC_TRACKREF_LIST       mmioFOURCC('t','k','r','l') /* Container for a track reference. */
#define DMUS_FOURCC_TRACKREF_CHUNK      mmioFOURCC('t','k','r','h') /* Track reference header. */

/* io structures:*/

typedef struct _DMUS_IO_SONG_HEADER
{
    DWORD       dwFlags;
    DWORD       dwStartSegID;   /* Id of the segment that starts playback. */
} DMUS_IO_SONG_HEADER;

typedef struct _DMUS_IO_SEGREF_HEADER
{
    DWORD       dwID;           /* Each has a unique ID. Must be less than DMUS_SONG_MAXSEGID. */
    DWORD       dwSegmentID;    /* Optional segment to link to. */
    DWORD       dwToolGraphID;  /* Optional tool graph to use for processing. */
    DWORD       dwFlags;        /* Various control flags. Currently reserved for future use. Must be 0. */
    DWORD       dwNextPlayID;   /* ID of next segment, to chain segments into a song. */
} DMUS_IO_SEGREF_HEADER;


typedef struct _DMUS_IO_TRACKREF_HEADER
{
    DWORD       dwSegmentID;    /* Which segment to find this in. */
    DWORD       dwFlags;        /* Reference control flags. */
} DMUS_IO_TRACKREF_HEADER;

/*  Transition definition chunk defines a transition, using an optional transition template
    segment.
*/

typedef struct _DMUS_IO_TRANSITION_DEF
{
    DWORD       dwSegmentID;        /* Segment the transition goes to. */
    DWORD       dwTransitionID;     /* Template segment to use for the transition. */
    DWORD       dwPlayFlags;        /* Flags to use for transition. */
} DMUS_IO_TRANSITION_DEF;

#define DMUS_SONG_MAXSEGID      0x7FFFFFFF  /* Segment ids can not go higher than this. */
#define DMUS_SONG_ANYSEG        0x80000000  /* Special ID to indicate any segment. */
#define DMUS_SONG_NOSEG         0xFFFFFFFF  /* Special ID to indicate no segment. */
#define DMUS_SONG_NOFROMSEG     0x80000001  /* Special ID for dwSegmentID to indicate transition from nothing (or outside the song) into this segment. */

/*
RIFF
(
    'DMSO'          // DirectMusic Song chunk
    <sngh-ck>       // Song header chunk
    [<guid-ck>]     // GUID for song
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMCN-form>]   // Optional container of objects embedded in file. Must precede segment list.
    <segl-list>     // List of Segments
    [<tlgl-list>]   // Optional list of ToolGraphs
    [<DMAP-form>]   // Optional Audio Path - to be shared by all segments in song.
    <srsl-list>     // List of segment references.
)

    // <sngh-ck>        
    'sngh'
    (
        <DMUS_IO_SONG_HEADER>
    )
    
    // <segl-list>
    LIST
    (
        'segl'          // Array of segments
        <ssgl-list>...  // Each segment is wrapped in this.
    )

    // <ssgl-list>
    LIST
    (
        'ssgl'          // Segment container.
        [DMSG-form]     // Each segment is either a full embedded segment RIFF form.
        [DMRF-list]     // Or a reference to an external segment.
    )

    // <tlgl-list>
    LIST
    (
        'tlgl'          // Array of toolgraphs
        <DMTG-form>...  // Each toolgraph is a full RIFF form.
    )

    // <srsl-list>
    LIST
    (
        'srsl'          // Array of segment references
        <sgrl-list>...  // Each segment reference is contained in a RIFF list.
    )

    // <sgrl-list>      // Segment reference container.
    LIST
    (
        'sgrl'
        <sgrh-ck>       // Segment reference header chunk.
        <segh-ck>       // Segment header chunk. Defines the segment. 
        <UNFO-list>     // Name, author, etc. Primarily for name, though, which is required for Song->GetSegment().
        [<strh-ck>]     // Segment transition chunk. Defines how to do transitions from other segments.
        [<trsl-list>]   // List of track references, to create a segment from tracks in multiple segments.
    )

    // <sgrh-ck>        // Segment reference header chunk
    (
        'sgrh'
        <DMUS_IO_SEGREF_HEADER>  // Segment reference header
    )

    // <strh-ck>        // Segment transition chunk. 
    (
        'strh'
        <DMUS_IO_TRANSITION_DEF>    // Default transition.
        <DMUS_IO_TRANSITION_DEF>... // Additional transitions.
    )

    // <trsl-list>      // Array of track references
    (
        'trsl'
        <tkrl-list>...  // Each track reference is multiple chunks in a tkrl list.
    )

    // <tkrl-list>      // Track reference container
    (
        'tkrl'
        <tkrh-ck>       // Track reference header chunk.
        <trkh-ck>       // Normal track header chunk.
        [<trkx-ck>]     // Optional track flags. 
    )

    // <tkrh-ck>        // Track reference header chunk
    (
        'tkrh'
        <DMUS_IO_TRACKREF_HEADER>  // Track reference header
    )
*/

/*  File io for DirectMusic reference chunk. 
    This is used to embed a reference to an object.
*/

/*  RIFF ids: */

#define DMUS_FOURCC_REF_LIST        mmioFOURCC('D','M','R','F')
#define DMUS_FOURCC_REF_CHUNK       mmioFOURCC('r','e','f','h')
#define DMUS_FOURCC_DATE_CHUNK      mmioFOURCC('d','a','t','e')
#define DMUS_FOURCC_NAME_CHUNK      mmioFOURCC('n','a','m','e')
#define DMUS_FOURCC_FILE_CHUNK      mmioFOURCC('f','i','l','e')

typedef struct _DMUS_IO_REFERENCE
{
    GUID    guidClassID;    /* Class id is always required. */
    DWORD   dwValidData;    /* Flags. */
} DMUS_IO_REFERENCE;

/*
LIST
(
    'DMRF'          // DirectMusic Reference chunk
    <refh-ck>       // Reference header chunk
    [<guid-ck>]     // Optional object GUID.
    [<date-ck>]     // Optional file date.
    [<name-ck>]     // Optional name.
    [<file-ck>]     // Optional file name.
    [<catg-ck>]     // Optional category name.
    [<vers-ck>]     // Optional version info.
)

    // <refh-ck>
    'refh'
    (
        <DMUS_IO_REFERENCE>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <date-ck>
    date
    (
        <FILETIME>
    )

    // <name-ck>
    name
    (
        // Name, stored as NULL terminated string of WCHARs
    )

    // <file-ck>
    file
    (
        // File name, stored as NULL terminated string of WCHARs
    )

    // <catg-ck>
    catg
    (
        // Category name, stored as NULL terminated string of WCHARs
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )
*/

/* Chord Maps */

/* runtime chunks */
#define DMUS_FOURCC_CHORDMAP_FORM       mmioFOURCC('D','M','P','R')
#define DMUS_FOURCC_IOCHORDMAP_CHUNK    mmioFOURCC('p','e','r','h')
#define DMUS_FOURCC_SUBCHORD_CHUNK      mmioFOURCC('c','h','d','t')
#define DMUS_FOURCC_CHORDENTRY_CHUNK    mmioFOURCC('c','h','e','h')
#define DMUS_FOURCC_SUBCHORDID_CHUNK    mmioFOURCC('s','b','c','n')
#define DMUS_FOURCC_IONEXTCHORD_CHUNK   mmioFOURCC('n','c','r','d')
#define DMUS_FOURCC_NEXTCHORDSEQ_CHUNK  mmioFOURCC('n','c','s','q')
#define DMUS_FOURCC_IOSIGNPOST_CHUNK    mmioFOURCC('s','p','s','h')
#define DMUS_FOURCC_CHORDNAME_CHUNK     mmioFOURCC('I','N','A','M')

/* runtime list chunks */
#define DMUS_FOURCC_CHORDENTRY_LIST     mmioFOURCC('c','h','o','e')
#define DMUS_FOURCC_CHORDMAP_LIST       mmioFOURCC('c','m','a','p')
#define DMUS_FOURCC_CHORD_LIST          mmioFOURCC('c','h','r','d')
#define DMUS_FOURCC_CHORDPALETTE_LIST   mmioFOURCC('c','h','p','l')
#define DMUS_FOURCC_CADENCE_LIST        mmioFOURCC('c','a','d','e')
#define DMUS_FOURCC_SIGNPOSTITEM_LIST   mmioFOURCC('s','p','s','t')

#define DMUS_FOURCC_SIGNPOST_LIST       mmioFOURCC('s','p','s','q')

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
/* DMUS_SIGNPOSTF_ flags are also used in templates (DMUS_IO_SIGNPOST) */
#define DMUS_SIGNPOSTF_A        1      
#define DMUS_SIGNPOSTF_B        2
#define DMUS_SIGNPOSTF_C        4
#define DMUS_SIGNPOSTF_D        8
#define DMUS_SIGNPOSTF_E        0x10
#define DMUS_SIGNPOSTF_F        0x20
#define DMUS_SIGNPOSTF_LETTER   (DMUS_SIGNPOSTF_A | DMUS_SIGNPOSTF_B | DMUS_SIGNPOSTF_C | DMUS_SIGNPOSTF_D | DMUS_SIGNPOSTF_E | DMUS_SIGNPOSTF_F)
#define DMUS_SIGNPOSTF_1        0x100
#define DMUS_SIGNPOSTF_2        0x200
#define DMUS_SIGNPOSTF_3        0x400
#define DMUS_SIGNPOSTF_4        0x800
#define DMUS_SIGNPOSTF_5        0x1000
#define DMUS_SIGNPOSTF_6        0x2000
#define DMUS_SIGNPOSTF_7        0x4000
#define DMUS_SIGNPOSTF_ROOT     (DMUS_SIGNPOSTF_1 | DMUS_SIGNPOSTF_2 | DMUS_SIGNPOSTF_3 | DMUS_SIGNPOSTF_4 | DMUS_SIGNPOSTF_5 | DMUS_SIGNPOSTF_6 | DMUS_SIGNPOSTF_7)
#define DMUS_SIGNPOSTF_CADENCE  0x8000

/* values for dwFlags field of DMUS_IO_CHORDMAP */
#define DMUS_CHORDMAPF_VERSION8  1   /* Chordmap is version 8 or above. */

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
#define DMUS_SPOSTCADENCEF_1  2   /* Use the first cadence chord. */
#define DMUS_SPOSTCADENCEF_2  4   /* Use the second cadence chord. */

/* run time data structs */
typedef struct _DMUS_IO_CHORDMAP
{
    WCHAR   wszLoadName[20];
    DWORD   dwScalePattern;
    DWORD   dwFlags;           /* Various flags. Only lower 16 bits are significant. */
} DMUS_IO_CHORDMAP;

typedef struct _DMUS_IO_CHORDMAP_SUBCHORD
{
    DWORD   dwChordPattern;
    DWORD   dwScalePattern;
    DWORD   dwInvertPattern;
    BYTE    bChordRoot;
    BYTE    bScaleRoot;
    WORD    wCFlags;
    DWORD   dwLevels;   /* parts or which subchord levels this chord supports */
} DMUS_IO_CHORDMAP_SUBCHORD;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SUBCHORD DMUS_IO_PERS_SUBCHORD;

typedef struct _DMUS_IO_CHORDENTRY
{
    DWORD   dwFlags;
    WORD    wConnectionID;  /* replaces runtime "pointer to this" */
} DMUS_IO_CHORDENTRY;

typedef struct _DMUS_IO_NEXTCHORD
{
    DWORD   dwFlags;
    WORD    nWeight;
    WORD    wMinBeats;
    WORD    wMaxBeats;
    WORD    wConnectionID;  /* points to an ioChordEntry */
} DMUS_IO_NEXTCHORD;

typedef struct _DMUS_IO_CHORDMAP_SIGNPOST
{
    DWORD   dwChords;   /* 1bit per group */
    DWORD   dwFlags;
} DMUS_IO_CHORDMAP_SIGNPOST;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SIGNPOST DMUS_IO_PERS_SIGNPOST;

/*
RIFF
(
    'DMPR'
    <perh-ck>           // Chord map header chunk
    [<guid-ck>]         // guid chunk
    [<vers-ck>]         // version chunk (two DWORDS)
    [<UNFO-list>]       // Unfo chunk
    <chdt-ck>           // subchord database
    <chpl-list>         // chord palette
    <cmap-list>         // chord map
    <spsq-list>         // signpost list
 )

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
                                <cheh-ck>   // chord entry data
                                <chrd-list> // chord definition
                                <ncsq-ck>   // connecting(next) chords
                     )

<chrd-list> ::= LIST('chrd' 
                                <INAM-ck>   // name of chord in wide char format
                                <sbcn-ck>   // list of subchords composing chord
                    )

<chpl-list> ::= LIST('chpl' 
                                <chrd-list> ... // chord definition
                    )

<spsq-list> ::== LIST('spsq' <spst-list> ... )

<spst-list> ::= LIST('spst'
                             <spsh-ck>
                             <chrd-list>
                             [<cade-list>]
                    )

<cade-list> ::= LIST('cade' <chrd-list> ...)

<perh-ck> ::= perh(<DMUS_IO_CHORDMAP>)

<chdt-ck> ::= chdt(<cbChordSize::WORD>
                   <DMUS_IO_PERS_SUBCHORD> ... )

<cheh-ck> ::= cheh(<DMUS_IO_CHORDENTRY>)

<sbcn-ck> ::= sbcn(<cSubChordID:WORD> ...)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> 
                   <DMUS_IO_NEXTCHORD>...)

<spsh-ck> ::= spsh(<DMUS_IO_PERS_SIGNPOST>)

*/

/*  File io for DirectMusic Script object */

/* RIFF ids: */

#define DMUS_FOURCC_SCRIPT_FORM             mmioFOURCC('D','M','S','C')
#define DMUS_FOURCC_SCRIPT_CHUNK            mmioFOURCC('s','c','h','d')
#define DMUS_FOURCC_SCRIPTVERSION_CHUNK     mmioFOURCC('s','c','v','e')
#define DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK    mmioFOURCC('s','c','l','a')
#define DMUS_FOURCC_SCRIPTSOURCE_CHUNK      mmioFOURCC('s','c','s','r')

/* io structures:*/

typedef struct _DMUS_IO_SCRIPT_HEADER
{
    DWORD       dwFlags; /* DMUS_SCRIPTIOF_ flags */
} DMUS_IO_SCRIPT_HEADER;

#define DMUS_SCRIPTIOF_LOAD_ALL_CONTENT       (1 << 0)
    /* If set, when the script loads it will also load all the content in its container. */
#define DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS  (1 << 1)
    /* If set and LOAD_ALL_CONTENT is also set, when the script initializes it will also download all the segments in its container.
       If set and LOAD_ALL_CONTENT is not set, when the script calls segment.Load on a segment then the segment will also be downloaded.
       If not set, the script must manually download and unload by calling segment.DownloadSoundData and segment.UnloadSoundData. */

/*
RIFF
(
    'DMSC'              // DirectMusic Script chunk
    <schd-ck>           // Script header chunk
    [<guid-ck>]         // GUID for script
    [<vers-ck>]         // Optional version info
    [<UNFO-list>]       // Name, author, copyright info., comments
    <scve-ck>           // Version of DirectMusic this script was authored to run against
    <DMCN-form>         // Container of content referenced by the script.
    <scla-ck>           // ActiveX scripting language in which the script is written
    <scsr-ck> or <DMRF> // The script's source code.
                        // If scsr-ck, the source is embedding in the chunk.
                        // If DMRF, it is a reference of where to find a text file with the source.
                        //    Class id (guidClassID in DMUS_IO_REFERENCE) must be GUID_NULL because
                        //    this text file is not a DirectMusic object in its own right.
)

    // <schd-ck>
    'schd'
    (
        <DMUS_FOURCC_SCRIPT_CHUNK>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <scve-ck>
    scve
    (
        <DMUS_IO_VERSION>
    )

    'scla'
    (
        // Language name, stored as NULL terminated string of WCHARs
    )

    'scsr'
    (
        // Source code, stored as NULL terminated string of WCHARs
    )
*/

/* Signpost tracks */

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK     mmioFOURCC( 's', 'g', 'n', 'p' )


typedef struct _DMUS_IO_SIGNPOST
{
    MUSIC_TIME  mtTime;
    DWORD       dwChords;
    WORD        wMeasure;
} DMUS_IO_SIGNPOST;

/*

    // <sgnp-list>
    'sgnp'
    (
        //sizeof DMUS_IO_SIGNPOST: DWORD
        <DMUS_IO_SIGNPOST>...
    )

*/

#define DMUS_FOURCC_MUTE_CHUNK  mmioFOURCC('m','u','t','e')

typedef struct _DMUS_IO_MUTE
{
    MUSIC_TIME  mtTime;
    DWORD       dwPChannel;
    DWORD       dwPChannelMap;
} DMUS_IO_MUTE;

/*

    // <mute-list>
    'mute'
    (
        //sizeof DMUS_IO_MUTE:DWORD
        <DMUS_IO_MUTE>...
    )


*/

/* Used for both style and chord map tracks */

#define DMUS_FOURCC_TIME_STAMP_CHUNK    mmioFOURCC('s', 't', 'm', 'p')

/* Style tracks */

#define DMUS_FOURCC_STYLE_TRACK_LIST    mmioFOURCC('s', 't', 't', 'r')
#define DMUS_FOURCC_STYLE_REF_LIST      mmioFOURCC('s', 't', 'r', 'f')

/*

    // <sttr-list>
    LIST('sttr'
    (
        <strf-list>...  // Array of Style references
    )

    // <strf-list>
    LIST('strf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )

*/

/* Chord map tracks */

#define DMUS_FOURCC_PERS_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERS_REF_LIST   mmioFOURCC('p', 'f', 'r', 'f')

/*

    // <pftr-list>
    LIST('pftr'
    (
        <pfrf-list>...  // Array of Chord map references
    )

    // <pfrf-list>
    LIST('pfrf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )

*/

#define DMUS_FOURCC_TEMPO_TRACK     mmioFOURCC('t','e','t','r')

/*
    // tempo array
    'tetr'
    (
        // sizeof DMUS_IO_TEMPO_ITEM: DWORD
        <DMUS_IO_TEMPO_ITEM>...
    )
 */

#define DMUS_FOURCC_SEQ_TRACK       mmioFOURCC('s','e','q','t')
#define DMUS_FOURCC_SEQ_LIST        mmioFOURCC('e','v','t','l')
#define DMUS_FOURCC_CURVE_LIST      mmioFOURCC('c','u','r','l')

/*
    // sequence track
    'seqt'
    (
        // sequence array
        'evtl'
        (
            // sizeof DMUS_IO_SEQ_ITEM: DWORD
            <DMUS_IO_SEQ_ITEM>...
        )
        // curve array
        'curl'
        (
            // sizeof DMUS_IO_CURVE_ITEM: DWORD
            <DMUS_IO_CURVE_ITEM>...
        )
    )
*/

#define DMUS_FOURCC_SYSEX_TRACK     mmioFOURCC('s','y','e','x')

/*
    // sysex track
    'syex'
    (
        {
            <DMUS_IO_SYSEX_ITEM>
            <BYTE>...    // Array of bytes, length defined in the DMUS_IO_SYSEXITEM structure
        }...
    )
*/

#define DMUS_FOURCC_TIMESIGNATURE_TRACK mmioFOURCC('t','i','m','s')

typedef struct _DMUS_IO_TIMESIGNATURE_ITEM
{
    MUSIC_TIME    lTime;
    BYTE          bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE          bBeat;              /* what note receives the beat (bottom of time sig.) */
                                      /* we can assume that 0 means 256th note */
    WORD          wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIGNATURE_ITEM;

/*  DX6 time signature track
    
    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
*/

/*  DX8 Time signature track. The track has been updated from DX7 to support a list of
    RIFF chunks. This will allow the time signature track to expand in the future.
*/

#define DMUS_FOURCC_TIMESIGTRACK_LIST   mmioFOURCC('T','I','M','S')
#define DMUS_FOURCC_TIMESIG_CHUNK       DMUS_FOURCC_TIMESIGNATURE_TRACK

/*
LIST
(
    'TIMS'          // Time Signature Track list-type
    <tims-ck>       // Chunk containing an array of time signatures
)

    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
 
*/

/*  DX8 Marker track. This is used to store valid start points and other
    flow control parameters that may come later. For example, if we want
    to implement more sophisticated looping and branching constructs, they
    would live in this track.
*/

#define DMUS_FOURCC_MARKERTRACK_LIST    mmioFOURCC('M','A','R','K')
#define DMUS_FOURCC_VALIDSTART_CHUNK    mmioFOURCC('v','a','l','s')
#define DMUS_FOURCC_PLAYMARKER_CHUNK    mmioFOURCC('p','l','a','y')

/* io structures */
typedef struct _DMUS_IO_VALID_START
{
    MUSIC_TIME mtTime;      /* Time of a legal start. */
} DMUS_IO_VALID_START;

typedef struct _DMUS_IO_PLAY_MARKER
{
    MUSIC_TIME mtTime;      /* Time of a next legal play point marker. */
} DMUS_IO_PLAY_MARKER;

/*
LIST
(
    'MARK'          // Marker Track list-type
    [<vals-ck>]     // Chunk containing an array of start points
    [<play-ck>]     // Chunk containing an array of play start markers
)

    'vals'
    (
        // size of DMUS_IO_VALID_START : DWORD
        <DMUS_IO_VALID_START>...
    )

    'play'
    (
        // size of DMUS_IO_PLAY_MARKER : DWORD
        <DMUS_IO_PLAY_MARKER>...
    )
  
*/

/* segment trigger tracks */

/* RIFF ids: */
#define DMUS_FOURCC_SEGTRACK_LIST                   mmioFOURCC('s','e','g','t')
#define DMUS_FOURCC_SEGTRACK_CHUNK                  mmioFOURCC('s','g','t','h')
#define DMUS_FOURCC_SEGMENTS_LIST                   mmioFOURCC('l','s','g','l')
#define DMUS_FOURCC_SEGMENT_LIST                    mmioFOURCC('l','s','e','g')
#define DMUS_FOURCC_SEGMENTITEM_CHUNK               mmioFOURCC('s','g','i','h')
#define DMUS_FOURCC_SEGMENTITEMNAME_CHUNK           mmioFOURCC('s','n','a','m')

/* io structures */
typedef struct _DMUS_IO_SEGMENT_TRACK_HEADER
{
    DWORD dwFlags; /* Reserved leave as 0. */
} DMUS_IO_SEGMENT_TRACK_HEADER;

typedef struct _DMUS_IO_SEGMENT_ITEM_HEADER
{
    MUSIC_TIME      lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME      lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
    DWORD           dwPlayFlags;     /* Flags for PlaySegment(). */
    DWORD           dwFlags;         /* Flags. */
} DMUS_IO_SEGMENT_ITEM_HEADER;

/* values for dwflags field of DMUS_IO_SEGMENT_ITEM_HEADER */
#define DMUS_SEGMENTTRACKF_MOTIF                 1        /* interpret DMRF as link to style, and use snam as the name of a motif within the style */

/*
LIST
(
    'segt'          // DirectMusic Segment Trigger Track form-type
    [<sgth-ck>]     // Segment track header
    <lsgl-list>     // List of Segment Lists
)

    // <sgth-ck>
    'sgth'
    (
        <DMUS_IO_SEGMENT_TRACK_HEADER>
    )

    // <lsgl-list>
    LIST
    (
        'lsgl'          // Array of segments
        <lseg-list>...  // Each segment is encapsulated in a list (that way it can still be riff parsed.)
    )

        // <lseg-list>
        LIST
        (
            'lseg'
            <sgih-ck>
            <DMRF-list>    // Link to a segment or style file.
            [<snam-ck>]    // Name field.  Used with DMUS_SEGMENTTRACKF_MOTIF flag.
        )

            // <sgih-ck>            // segment item header
            (
                <DMUS_IO_SEGMENT_ITEM_HEADER>  // Segment item header
            )

            // <snam-ck>
            (
                // Name, stored as NULL terminated string of WCHARs
            )
*/      

/* Script track. */

/* RIFF ids: */
#define DMUS_FOURCC_SCRIPTTRACK_LIST                mmioFOURCC('s','c','r','t')
#define DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST          mmioFOURCC('s','c','r','l')
#define DMUS_FOURCC_SCRIPTTRACKEVENT_LIST           mmioFOURCC('s','c','r','e')
#define DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK    mmioFOURCC('s','c','r','h')
#define DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK      mmioFOURCC('s','c','r','n')

/* Flags for DMUS_IO_SCRIPTTRACK_TIMING
 */
#define DMUS_IO_SCRIPTTRACKF_PREPARE (1 << 0)        /* Fire event in advance of time stamp, at Prepare time.  This is the default because it leaves the script time to change the music happening at the target time. */
#define DMUS_IO_SCRIPTTRACKF_QUEUE   (1 << 1)        /* Fire event just before time stamp, at Queue time. */
#define DMUS_IO_SCRIPTTRACKF_ATTIME  (1 << 2)        /* Fire event right at the time stamp. */

typedef struct _DMUS_IO_SCRIPTTRACK_EVENTHEADER
{
    DWORD dwFlags;              /* various bits (see DMUS_IO_SCRIPTTRACKF_*) */
    MUSIC_TIME lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
} DMUS_IO_SCRIPTTRACK_EVENTHEADER;

/*
    // Script Track

    // <scrt-list>
    LIST
    (
        <scrl-list>       // List of script events
    )

        // <scrl-list>
        LIST
        (
            <scre-list>...    // Array of event descriptions
        )

            // <scre-list>
            LIST
            (
                <scrh-ck>         // Event header chunk
                <DMRF>
                <scrn-ck>         // Routine name
            )

                'scrh'
                (
                    <DMUS_IO_SCRIPTTRACK_EVENTHEADER>
                )

                'scrn'
                (
                    // Name, stored as NULL terminated string of WCHARs
                )
*/

/* Lyrics/Notification track. */

/* RIFF ids: */
#define DMUS_FOURCC_LYRICSTRACK_LIST                mmioFOURCC('l','y','r','t')
#define DMUS_FOURCC_LYRICSTRACKEVENTS_LIST          mmioFOURCC('l','y','r','l')
#define DMUS_FOURCC_LYRICSTRACKEVENT_LIST           mmioFOURCC('l','y','r','e')
#define DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK    mmioFOURCC('l','y','r','h')
#define DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK      mmioFOURCC('l','y','r','n')

typedef struct _DMUS_IO_LYRICSTRACK_EVENTHEADER
{
    DWORD dwFlags;              /* Reserved leave as 0. */
    DWORD dwTimingFlags;        /* Combination DMUS_PMSGF_TOOL_* flags.  Determines the precise timing of when the notification happens. Invalid with the flag DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSICTIME, DMUS_PMSGF_TOOL_FLUSH, or DMUS_PMSGF_LOCKTOREFTIME. */
    MUSIC_TIME lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
} DMUS_IO_LYRICSTRACK_EVENTHEADER;

/*
    // Lyrics/Notification Track

    // <lyrt-list>
    LIST
    (
        <lyrl-list>       // List of notification events
    )

        // <lyrl-list>
        LIST
        (
            <lyre-list>...    // Array of event descriptions
        )

            // <lyre-list>
            LIST
            (
                <lyrh-ck>         // Event header chunk
                <lyrn-ck>         // Notification text
            )

                'lyrh'
                (
                    <DMUS_IO_LYRICSTRACK_EVENTHEADER>
                )

                'lyrn'
                (
                    // Name, stored as NULL terminated string of WCHARs
                )
*/

/* Parameter control track */

/* RIFF ids: */
#define DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST            mmioFOURCC('p','r','m','t')
#define DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST           mmioFOURCC('p','r','o','l')
#define DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK          mmioFOURCC('p','r','o','h')
#define DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST            mmioFOURCC('p','r','p','l')
#define DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK           mmioFOURCC('p','r','p','h')
#define DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK          mmioFOURCC('p','r','c','c')

typedef struct _DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER
{
    DWORD dwFlags;              /* Reserved.  Must be zero. */
    GUID guidTimeFormat;        /* Time format to set the object to.  Must be GUID_TIME_REFERNCE or GUID_TIME_MUSIC from medparam.h. */
    /* Path for finding the object. These fields correspond to the first five parameters of IDirectMusicSegmentState::GetObjectInPath. */
    DWORD dwPChannel;
    DWORD dwStage;
    DWORD dwBuffer;
    GUID guidObject;
    DWORD dwIndex;
} DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER;

typedef struct _DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER
{
    DWORD dwFlags;              /* Reserved.  Must be zero. */
    DWORD dwIndex;              /* Index number of the parameter on the object */
} DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER;

typedef struct _DMUS_IO_PARAMCONTROLTRACK_CURVEINFO
{
    MUSIC_TIME  mtStartTime;
    MUSIC_TIME  mtEndTime;
    float       fltStartValue;
    float       fltEndValue;
    DWORD       dwCurveType;   /* One of the items from the MP_CURVE_TYPE enum in medparam.h */
    DWORD       dwFlags;       /* A combination of the MPF_ENVLP_* constants in medparam.h */
} DMUS_IO_PARAMCONTROLTRACK_CURVEINFO;

/*
    // <prmt-list>
    LIST
    (
        <prol-list>...   // one for each object
    )

        // <prol-list>
        LIST
        (
            <proh-ck>       // object header chunk
            <prpl-list>...  // one for each parameter
        )

            // <proh-ck>
            proh
            (
                <DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER>
            )

            // <prpl-list>
            LIST
            (
                <prph-ck>       // parameter header chunk
                <prcc-ck>       // chunk containing an array of curves
            )

                // <prph-ck>
                prph
                (
                    <DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER>
                )

                // <prcc-ck>
                prcc
                (
                    // sizeof DMUS_IO_PARAMCONTROLTRACK_CURVEINFO:DWORD
                    <DMUS_IO_PARAMCONTROLTRACK_CURVEINFO>... // curves, sorted in order of mtTime
                )
*/

/* Melody formulation track */
/* Note: Melody formulation file format is not supported in DX8. */

typedef DMUS_CONNECTION_RULE DMUS_IO_CONNECTION_RULE; /* defined in dmusici.h */

typedef DMUS_MELODY_FRAGMENT DMUS_IO_MELODY_FRAGMENT; /* defined in dmusici.h */

#define DMUS_FOURCC_MELODYFORM_TRACK_LIST     mmioFOURCC( 'm', 'f', 'r', 'm' )
#define DMUS_FOURCC_MELODYFORM_HEADER_CHUNK   mmioFOURCC( 'm', 'l', 'f', 'h' )
#define DMUS_FOURCC_MELODYFORM_BODY_CHUNK     mmioFOURCC( 'm', 'l', 'f', 'b' )

typedef struct _DMUS_IO_MELFORM
{
    DWORD        dwPlaymode;       /* NOT CURRENTLY USED - MUST BE 0 */   
} DMUS_IO_MELFORM;


/*
    // <mfrm-list>
    LIST
    (
        'mfrm'
        <mlfh-ck>       // Melody formulation header chunk
        <mlfb-ck>       // Melody formulation body chunk
    )

    // <mlfb-ck>
    'mlfb'
    (
        <DMUS_IO_MELFORM>
    )

  // <mlfb-ck>
    'mlfb'
    (
        //sizeof DMUS_IO_MELODY_FRAGMENT: DWORD
        <DMUS_IO_MELODY_FRAGMENT>...
    )

*/

#if (DIRECTSOUND_VERSION >= 0x0800) || defined(XBOX)

/* DirectSoundBufferConfig FX Map */

/* RIFF ids: */

#define DMUS_FOURCC_DSBC_FORM       mmioFOURCC('D','S','B','C')
#define DMUS_FOURCC_DSBD_CHUNK      mmioFOURCC('d','s','b','d')
#define DMUS_FOURCC_BSID_CHUNK      mmioFOURCC('b','s','i','d')
#define DMUS_FOURCC_DS3D_CHUNK      mmioFOURCC('d','s','3','d')
#define DMUS_FOURCC_DSBC_LIST       mmioFOURCC('f','x','l','s')
#define DMUS_FOURCC_DSFX_FORM       mmioFOURCC('D','S','F','X')
#define DMUS_FOURCC_DSFX_CHUNK      mmioFOURCC('f','x','h','r')
#define DMUS_FOURCC_DSFX_DATA       mmioFOURCC('d','a','t','a')

/* io structures */

typedef struct _DSOUND_IO_DSBUFFERDESC
{
    DWORD dwFlags;        /* DirectSound buffer creation flags */
    WORD nChannels;       /* No. of channels (rest of buffer format is determined by owning sink) */
    LONG lVolume;         /* Initial pan; only used if CTRLVOLUME is specified */
    LONG lPan;            /* Initial pan; only used if CTRLPAN is specified */
    DWORD dwReserved;     /* Reserved - must be 0 */
} DSOUND_IO_DSBUFFERDESC;

typedef struct _DSOUND_IO_DSBUSID
{
    DWORD busid[1];       /* Array size determined from chunk size */
} DSOUND_IO_DSBUSID;

typedef struct _DSOUND_IO_3D
{
    GUID guid3DAlgorithm; /* GUID identifying the 3D algorithm to use (defined in dsound.h) */
    DS3DBUFFER ds3d;      /* Initial 3D parameters */
} DSOUND_IO_3D;

typedef struct _DSOUND_IO_DXDMO_HEADER
{
    DWORD dwEffectFlags;  /* Effect creation flags - equivalent to DSEFFECTDESC::dwFlags */
    GUID guidDSFXClass;   /* GUID identifying the effect to use - corresponds to a COM CLSID */
    GUID guidReserved;    /* Reserved - must be the null GUID */
    GUID guidSendBuffer;  /* GUID identifying the buffer to send to if this is a send effect */
    DWORD dwReserved;     /* Reserved - must be 0 */
} DSOUND_IO_DXDMO_HEADER;

typedef struct _DSOUND_IO_DXDMO_DATA
{
    DWORD data[1];      /* Array size determined by the DMO involved */
} DSOUND_IO_DXDMO_DATA;

/*
RIFF
(
    'DSBC'          // DirectSoundBufferConfig chunk
    [<guid-ck>]     // GUID identifier for this DirectSoundBufferConfig
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <dsbd-ck>       // DirectSound Buffer descriptor chunk
    [<bsid-ck>]     // Optional bus id array
    [<ds3d-ck>]     // Optional 3d Parameters
    [<fxls-list>]   // Optional list of FX descriptors
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    'vers'
    (
        <DMUS_IO_VERSION>
    )

    // <dsbd-ck>
    'dsbd'
    (
        <DSOUND_IO_DSBUFFERDESC>  // Creation parameters and initial settings for the buffer
    )

    // <bsid-ck>
    'bsid'
    (
        <DSOUND_IO_DSBUSID>  // The size of DSOUND_IO_DSBUSID is determined by the chunk size 
    )

    // <ds3d-ck>
    'ds3d'
    (
        <DSOUND_IO_3D>  // Initial 3D buffer parameters: position, etc.
    )

    // <fx-list>
    LIST
    (
        'fxls'          // Array of DMO creation parameter blocks
        <DSFX-form>...  // Each DMO is encapsulated in a RIFF chunk
    )

// <DSFX-form>          // DMOs can be embedded in a buffer configuration or stored as separate files
RIFF
(
    'DSFX'
    <fxhr-ck>           // FX header chunk
    [<data-ck>]         // FX initial settings chunk
)

    // <fxhr-ck>
    'fxhr'
    (
        <DSOUND_IO_DXDMO_HEADER>
    )

    // <data-ck>
    'data'
    (
        <DSOUND_IO_DXDMO_DATA>  // Opaque data block used by the DMO to load itself.
        // For our standard included DMOs, this is simply the structure accepted by
        // the DMO's SetAllParameters() method - e.g. struct DSFXChorus for Chorus.
    )
*/

#endif

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICF_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dmusics.h ===
/************************************************************************
*                                                                       *
*   dmusics.h -- Definitions for created a DirectMusic software synth   *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICS_
#define _DMUSICS_

#include "dmusicc.h"

/* Software synths are enumerated from under this registry key.
 */
#define REGSTR_PATH_SOFTWARESYNTHS  "Software\\Microsoft\\DirectMusic\\SoftwareSynths"

interface IDirectMusicSynth;
interface IDirectMusicSynthSink;

#ifndef __cplusplus 
typedef interface IDirectMusicSynth IDirectMusicSynth;
typedef interface IDirectMusicSynthSink IDirectMusicSynthSink;
#endif

#ifndef _DMUS_VOICE_STATE_DEFINED
#define _DMUS_VOICE_STATE_DEFINED

typedef struct _DMUS_VOICE_STATE
{
    BOOL                bExists;
    SAMPLE_POSITION     spPosition;
} DMUS_VOICE_STATE; 

#endif /* _DMUS_VOICE_STATE_DEFINED */

/* IDirectMusicSynth::Refresh
 *
 * This is the last buffer of the stream. It may be a partial block.
 */
#define REFRESH_F_LASTBUFFER        0x00000001

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth
DECLARE_INTERFACE_(IDirectMusicSynth, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
};

#undef  INTERFACE

#define INTERFACE  IDirectMusicSynth8
DECLARE_INTERFACE_(IDirectMusicSynth8, IDirectMusicSynth)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;

	/* IDirectMusicSynth8 */
    STDMETHOD(PlayVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId, 
										   DWORD dwChannelGroup, 
										   DWORD dwChannel, 
										   DWORD dwDLId, 
										   long	 prPitch,			/* PREL not defined here */
										   long  vrVolume,          /* VREL not defined here */
                                           SAMPLE_TIME stVoiceStart,
                                           SAMPLE_TIME stLoopStart,
                                           SAMPLE_TIME stLoopEnd) PURE;

    STDMETHOD(StopVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId ) PURE;

    STDMETHOD(GetVoiceState)        (THIS_ DWORD dwVoice[], 
										   DWORD cbVoice,
										   DMUS_VOICE_STATE dwVoiceState[] ) PURE;
    STDMETHOD(Refresh)              (THIS_ DWORD dwDownloadID,
                                           DWORD dwFlags) PURE;
#ifdef XBOX
    STDMETHOD(IsReadyForData)       (THIS_ DWORD dwDownloadID) PURE;
#endif
#ifdef XBOX
    STDMETHOD(AssignChannelToOutput) (THIS_ DWORD dwChannelGroup,                   // Channel group and
		                                    DWORD dwChannel,                        // channel to assign
                                            IDirectSoundBuffer *pBuffer,            // Buffer, if assigned to buffer.
                                            DWORD dwMixBins,
                                            BYTE *pbMixBins)PURE;
#else
    STDMETHOD(AssignChannelToBuses) (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwBuses,
                                           DWORD cBuses) PURE;   
#endif
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ IDirectMusicSynth *pSynth) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;                                           
    STDMETHOD(GetDesiredBufferSize) (THIS_ LPDWORD pdwBufferSizeInSamples) PURE;                                           
};

DEFINE_GUID(IID_IDirectMusicSynth, 0x9823661,  0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSynth8,0x53cab625, 0x2711, 0x4c9f, 0x9d, 0xe7, 0x1b, 0x7f, 0x92, 0x5f, 0x6f, 0xc8);
DEFINE_GUID(IID_IDirectMusicSynthSink,0x9823663, 0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_SetSynthSink
 *
 * Item 0: An IUnknown on which the port can QueryInterface for a user-mode synth sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SetSynthSink,0x0a3a5ba5, 0x37b6, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_SinkUsesDSound
 *
 * Item 0: A DWORD boolean indicating whether or not the sink requires an IDirectSound interface. The
 * default is FALSE if this property item is not implemented by the sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SinkUsesDSound, 0xbe208857, 0x8952, 0x11d2, 0xba, 0x1c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dmusicip.h ===
/************************************************************************
*                                    ~~                                   *
*   dmusici.h -- This module contains the API for the                   *
*                DirectMusic performance layer                          *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICI_
#define _DMUSICI_

#include <xtl.h>
#ifndef _DUMMY_MSG
#define _DUMMY_MSG
struct MSG;
typedef struct MSG* LPMSG;
#endif
#include <xobjbase.h>
//@@BEGIN_MSINTERNAL
#include <dmusicc.h>
/* plugin (track and tool) interfaces.  This will eventually go away. */
#include <dmplugin.h>
//@@END_MSINTERNAL
#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef WORD            TRANSITION_TYPE;
typedef long            MUSIC_TIME;

#define MT_MIN          0x80000000  /* Minimum music time value. */
#define MT_MAX          0x7FFFFFFF  /* Maximum music time value. */

#define DMUS_PPQ        768     /* parts per quarter note */

interface IDirectMusicPerformance;
interface IDirectMusicSegment;
interface IDirectMusicSegmentState;
interface IDirectMusicLoader;
interface IDirectMusicScript;
interface IDirectMusicAudioPath;
interface IDirectMusicTool;
interface IDirectMusicGraph;
interface IDirectMusicObject;
//@@BEGIN_MSINTERNAL
interface IDirectMusicBand;
//interface IDirectMusicTool8;
interface IDirectMusicTrack8;
interface IDirectMusicTrack;
interface IDirectMusicBuffer;
interface IDirectMusicInstrument;
interface IDirectMusicDownloadedInstrument;
interface IDirectMusicChordMap;
interface IDirectMusicStyle8;
interface IDirectMusicPatternTrack;
interface IDirectMusicContainer;
interface IDirectMusicSong;
interface IDirectMusicSynthX;
//@@END_MSINTERNAL
#ifndef __cplusplus 
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicObject IDirectMusicObject;
typedef interface IDirectMusicLoader IDirectMusicLoader;
typedef interface IDirectMusicScript IDirectMusicScript;
typedef interface IDirectMusicAudioPath IDirectMusicAudioPath;
typedef interface IDirectMusicTool IDirectMusicTool;
typedef interface IDirectMusicGraph IDirectMusicGraph;
//@@BEGIN_MSINTERNAL
typedef interface IDirectMusicTool8 IDirectMusicTool8;
typedef interface IDirectMusicTrack8 IDirectMusicTrack8;
typedef interface IDirectMusicBand IDirectMusicBand;
typedef interface IDirectMusicTrack IDirectMusicTrack;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicInstrument IDirectMusicInstrument;
typedef interface IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument;
typedef interface IDirectMusicChordMap IDirectMusicChordMap;
typedef interface IDirectMusicStyle8 IDirectMusicStyle8;
typedef interface IDirectMusicPatternTrack IDirectMusicPatternTrack;
typedef interface IDirectMusicContainer IDirectMusicContainer;
typedef interface IDirectMusicSong IDirectMusicSong;
typedef interface IDirectMusicSynthX IDirectMusicSynthX;
//@@END_MSINTERNAL
#endif

//@@BEGIN_MSINTERNAL
typedef enum enumDMUS_STYLET_TYPES
{
    DMUS_STYLET_PATTERN         = 0,
    DMUS_STYLET_MOTIF           = 1,
    DMUS_STYLET_FRAGMENT        = 2,
} DMUS_STYLET_TYPES;


typedef enum enumDMUS_COMMANDT_TYPES
{
    DMUS_COMMANDT_GROOVE            = 0,
    DMUS_COMMANDT_FILL              = 1,
    DMUS_COMMANDT_INTRO             = 2,
    DMUS_COMMANDT_BREAK             = 3,
    DMUS_COMMANDT_END               = 4,
    DMUS_COMMANDT_ENDANDINTRO       = 5
} DMUS_COMMANDT_TYPES;

typedef enum enumDMUS_SHAPET_TYPES
{
    DMUS_SHAPET_FALLING             = 0,
    DMUS_SHAPET_LEVEL               = 1,
    DMUS_SHAPET_LOOPABLE            = 2,
    DMUS_SHAPET_LOUD                = 3,
    DMUS_SHAPET_QUIET               = 4,
    DMUS_SHAPET_PEAKING             = 5,
    DMUS_SHAPET_RANDOM              = 6,
    DMUS_SHAPET_RISING              = 7,
    DMUS_SHAPET_SONG                = 8
}   DMUS_SHAPET_TYPES;

typedef enum enumDMUS_COMPOSEF_FLAGS
{       
    DMUS_COMPOSEF_NONE              = 0,
    DMUS_COMPOSEF_ALIGN             = 0x1,
    DMUS_COMPOSEF_OVERLAP           = 0x2,
    DMUS_COMPOSEF_IMMEDIATE         = 0x4,
    DMUS_COMPOSEF_GRID              = 0x8,
    DMUS_COMPOSEF_BEAT              = 0x10,
    DMUS_COMPOSEF_MEASURE           = 0x20,
    DMUS_COMPOSEF_AFTERPREPARETIME  = 0x40,
    DMUS_COMPOSEF_VALID_START_BEAT  = 0x80,   /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur on any beat. */
    DMUS_COMPOSEF_VALID_START_GRID  = 0x100,  /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur on any grid. */
    DMUS_COMPOSEF_VALID_START_TICK  = 0x200,  /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur any time. */
    DMUS_COMPOSEF_SEGMENTEND        = 0x400,  /* Play the transition at the end of the current segment. */
    DMUS_COMPOSEF_MARKER            = 0x800,  /* Play the transition at the next marker in the current segment. */
    DMUS_COMPOSEF_MODULATE          = 0x1000,
    DMUS_COMPOSEF_LONG              = 0x2000,
    DMUS_COMPOSEF_ENTIRE_TRANSITION = 0x4000,  /* play the entire transition pattern */
    DMUS_COMPOSEF_1BAR_TRANSITION   = 0x8000,  /* play one bar of the transition pattern */
    DMUS_COMPOSEF_ENTIRE_ADDITION   = 0x10000, /* play the additional pattern in its entirety */
    DMUS_COMPOSEF_1BAR_ADDITION     = 0x20000,  /* play one bar of the additional pattern */
    DMUS_COMPOSEF_VALID_START_MEASURE = 0x40000, /* In conjunction with DMUS_COMPOSEF_ALIGN, allows the switch to occur on any bar. */
    DMUS_COMPOSEF_DEFAULT           = 0x80000,  /* Use segment's default boundary */
    DMUS_COMPOSEF_NOINVALIDATE      = 0x100000,  /* Play without invalidating the currently playing segment(s) */
    DMUS_COMPOSEF_USE_AUDIOPATH     = 0x200000,  /* Uses the audio paths that are embedded in the segments */
	DMUS_COMPOSEF_INVALIDATE_PRI    = 0x400000   /* Invalidate only the current primary seg state */
}   DMUS_COMPOSEF_FLAGS;
//@@END_MSINTERNAL

#define DMUS_PMSG_PART                                                                              \
    DWORD               dwSize;                                                                     \
    REFERENCE_TIME      rtTime;             /* real time (in 100 nanosecond increments) */          \
    MUSIC_TIME          mtTime;             /* music time */                                        \
    DWORD               dwFlags;            /* various bits (see DMUS_PMSGF_FLAGS enumeration) */    \
    DWORD               dwPChannel;         /* Performance Channel. The Performance can */          \
                                            /* use this to determine the port/channel. */           \
    DWORD               dwVirtualTrackID;   /* virtual track ID */                                  \
    IDirectMusicTool*   pTool;              /* tool interface pointer */                            \
    IDirectMusicGraph*  pGraph;             /* tool graph interface pointer */                      \
    DWORD               dwType;             /* PMSG type (see DMUS_PMSGT_TYPES defines) */              \
    DWORD               dwVoiceID;          /* unique voice id which allows synthesizers to */      \
                                            /* identify a specific event. For DirectX 6.0, */       \
                                            /* this field should always be 0. */                    \
    DWORD               dwGroupID;          /* Track group id */                                 \
    IUnknown*           punkUser;           /* user com pointer, auto released upon PMSG free */

/* every DMUS_PMSG is based off of this structure. The Performance needs 
   to access these members consistently in every PMSG that goes through it. */
typedef struct _DMUS_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

} DMUS_PMSG;

#define DMUS_PCHANNEL_BROADCAST_PERFORMANCE	0xFFFFFFFF  /* PMsg is sent on all PChannels of the performance. */
#define DMUS_PCHANNEL_BROADCAST_AUDIOPATH   0xFFFFFFFE  /* PMsg is sent on all PChannels of the audio path. */
#define DMUS_PCHANNEL_BROADCAST_SEGMENT	    0xFFFFFFFD  /* PMsg is sent on all PChannels of the segment. */
#define DMUS_PCHANNEL_BROADCAST_GROUPS  	0xFFFFFFFC  /* A duplicate PMsg is for each Channels Groups in the performance. */

/*  The DMUS_PATH constants are used in conjunction with GetObjectInPath to find a requested
    interface at a particular stage in the audio path. 
*/
#define DMUS_PATH_SEGMENT          0x1000      /* Get the segment itself (from a segment state.) */
//@@BEGIN_MSINTERNAL
#define DMUS_PATH_SEGMENT_TRACK    0x1100      /* Look in Track List of Segment. */
//@@END_MSINTERNAL
#define DMUS_PATH_SEGMENT_GRAPH    0x1200      /* Get the segment's tool graph. */
#define DMUS_PATH_SEGMENT_TOOL     0x1300      /* Look in Tool Graph of Segment. */
#define DMUS_PATH_AUDIOPATH        0x2000      /* Get the audiopath itself (from a segment state.) */
#define DMUS_PATH_AUDIOPATH_GRAPH  0x2200      /* Get the audiopath's tool graph. */
#define DMUS_PATH_AUDIOPATH_TOOL   0x2300      /* Look in Tool Graph of Audio Path. */
#define DMUS_PATH_PERFORMANCE      0x3000      /* Access the performance. */
#define DMUS_PATH_PERFORMANCE_GRAPH 0x3200     /* Get the performance's tool graph. */
#define DMUS_PATH_PERFORMANCE_TOOL 0x3300      /* Look in Tool Graph of Performance. */
//@@BEGIN_MSINTERNAL
#define DMUS_PATH_PORT             0x4000      /* Access the synth. */
//@@END_MSINTERNAL
#define DMUS_PATH_BUFFER           0x6000      /* Look in DirectSoundBuffer. */
//@@BEGIN_MSINTERNAL
#define DMUS_PATH_BUFFER_DMO       0x6100      /* Access a DMO in the buffer. */
#define DMUS_PATH_MIXIN_BUFFER     0x7000      /* Look in a global mixin buffer. */ 
#define DMUS_PATH_MIXIN_BUFFER_DMO 0x7100      /* Access a DMO in a global mixin buffer. */ 
#define DMUS_PATH_PRIMARY_BUFFER   0x8000      /* Access the primary buffer. */ 
//@@END_MSINTERNAL

/*  To ignore PChannels when calling GetObjectInPath(), use the DMUS_PCHANNEL_ALL constant. */
#define DMUS_PCHANNEL_ALL           0xFFFFFFFB      

/*  The DMUS_APATH types are used in conjunction with CreateStandardAudioPath to
    build default path types. _SHARED_ means the same buffer is shared across multiple
    instantiations of the audiopath type. _DYNAMIC_ means a unique buffer is created
    every time. 
*/

/* A standard music set up with stereo outs and no reverb or chorus send. */
#define DMUS_APATH_SHARED_STEREO             0xFFFF0001
/* A standard music set up with stereo outs and reverb & chorus sends. */
#define DMUS_APATH_SHARED_STEREOPLUSREVERB   0xFFFF0002
/* An audio path with one dynamic bus from the synth feeding to a dynamic mono buffer. */
#define DMUS_APATH_DYNAMIC_MONO              0xFFFF0003   
/* An audio path with one dynamic bus from the synth feeding to a dynamic 3d buffer.*/
#define DMUS_APATH_DYNAMIC_3D                0xFFFF0004
/* Sends to quad mixbins on channels 1 through 4. */
#define DMUS_APATH_MIXBIN_QUAD               ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT) )
/* Sends to quad mixbins on channels 1 through 4 and environmental reverb on 5. */
#define DMUS_APATH_MIXBIN_QUAD_ENV           ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT ) | (1 << DSMIXBIN_I3DL2) )
/* Sends to quad mixbins on channels 1 through 4 and music reverb and chorus on 5, 6. */
#define DMUS_APATH_MIXBIN_QUAD_MUSIC         ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT ) | (1 << DSMIXBIN_FXSEND_0 ) | (1 << DSMIXBIN_FXSEND_1) )
/* Sends to 5.1 mixbins on channels 1 through 6. */
#define DMUS_APATH_MIXBIN_5DOT1              ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_FRONT_CENTER ) | (1 << DSMIXBIN_LOW_FREQUENCY ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT) )
/* Sends to 5.1 mixbins on channels 1 through 6 and environmental reverb on 7. */
#define DMUS_APATH_MIXBIN_5DOT1_ENV          ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_FRONT_CENTER ) | (1 << DSMIXBIN_LOW_FREQUENCY ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT ) | (1 << DSMIXBIN_I3DL2) )
/* Sends to 5.1 mixbins on channels 1 through 6 and music reverb and chorus on 7, 8. */
#define DMUS_APATH_MIXBIN_5DOT1_MUSIC        ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_FRONT_CENTER ) | (1 << DSMIXBIN_LOW_FREQUENCY ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT ) | (1 << DSMIXBIN_FXSEND_0 ) | (1 << DSMIXBIN_FXSEND_1) )
/* 1,2 -> Stereo, 3 -> environmental reverb, 4 through 8 -> effects. */
#define DMUS_APATH_MIXBIN_STEREO_EFFECTS     ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_I3DL2 ) | (1 << DSMIXBIN_FXSEND_0 ) | (1 << DSMIXBIN_FXSEND_1 ) | (1 << DSMIXBIN_FXSEND_2 ) | (1 << DSMIXBIN_FXSEND_3 ) | (1 << DSMIXBIN_FXSEND_4) )

//@@BEGIN_MSINTERNAL
#define DMUS_APATH_DYNAMIC_STEREO            0xFFFF0005       /* An audio path with two dynamic buses from the synth feeding to a dynamic stereo buffer. */

typedef struct _DMUS_AUDIOPARAMS
{
    DWORD   dwSize;             /* Size of this structure. */
    BOOL    fInitNow;           /* If true, the sink and synth are created immediately and results returned in this structure. */
    DWORD   dwValidData;        /* Flags indicating which fields below are valid. */
    DWORD   dwFeatures;         /* Required DMUS_AUDIOF features. */
    DWORD   dwVoices;           /* Required number of voices. */
    DWORD   dwSampleRate;       /* Sample rate of synths and sink. */
    CLSID   clsidDefaultSynth;  /* Class ID of default synthesizer. */
} DMUS_AUDIOPARAMS;

/* dwFeatures flags. These indicate which features are required for the audio environment. */
#define DMUS_AUDIOF_3D          0x1   /* Require 3D buffers. */
#define DMUS_AUDIOF_ENVIRON     0x2   /* Require environmental modeling. */
#define DMUS_AUDIOF_EAX         0x4   /* Require use of EAX effects. */
#define DMUS_AUDIOF_DMOS        0x8   /* Require use of additional DMOs. */
#define DMUS_AUDIOF_STREAMING   0x10  /* Require support for streaming waves. */
#define DMUS_AUDIOF_BUFFERS     0x20  /* Require support for multiple buffers (all above cases need this.) */
#define DMUS_AUDIOF_ALL         0x3F  /* Requires everything. */

/* dwValidData flags. These indicate which fields in DMUS_AUDIOPARAMS have been filled in. If fInitNow is set, these also return what was allocated. */
#define DMUS_AUDIOPARAMS_FEATURES       0x00000001
#define DMUS_AUDIOPARAMS_VOICES         0x00000002
#define DMUS_AUDIOPARAMS_SAMPLERATE     0x00000004
#define DMUS_AUDIOPARAMS_DEFAULTSYNTH   0x00000008
//@@END_MSINTERNAL

#define DMUS_INITAUDIO_NOTHREADS     0x1     /* If this is set, the app must call DirectMusicDoWork. */

/* DMUS_PMSGF_FLAGS fill the DMUS_PMSG's dwFlags member */
typedef enum enumDMUS_PMSGF_FLAGS
{
    DMUS_PMSGF_REFTIME          = 1,      /* if rtTime is valid */
    DMUS_PMSGF_MUSICTIME        = 2,      /* if mtTime is valid */
    DMUS_PMSGF_TOOL_IMMEDIATE   = 4,      /* if PMSG should be processed immediately */ 
    DMUS_PMSGF_TOOL_QUEUE       = 8,      /* if PMSG should be processed a little early, at Queue time */
    DMUS_PMSGF_TOOL_ATTIME      = 0x10,   /* if PMSG should be processed at the time stamp */
    DMUS_PMSGF_TOOL_FLUSH       = 0x20,   /* if PMSG is being flushed */
    DMUS_PMSGF_LOCKTOREFTIME    = 0x40,   /* if rtTime can not be overriden by a tempo change. */
    DMUS_PMSGF_DX8              = 0x80    /* if the message has DX8 or later extensions. */
    /* The values of DMUS_TIME_RESOLVE_FLAGS may also be used inside the */
    /* DMUS_PMSG's dwFlags member. */
} DMUS_PMSGF_FLAGS;

/* DMUS_PMSGT_TYPES fill the DMUS_PMSG's dwType member */
typedef enum enumDMUS_PMSGT_TYPES
{
    DMUS_PMSGT_MIDI             = 0,      /* MIDI short message */
    DMUS_PMSGT_NOTE             = 1,      /* Interactive Music Note */
    DMUS_PMSGT_SYSEX            = 2,      /* MIDI long message (system exclusive message) */
    DMUS_PMSGT_NOTIFICATION     = 3,      /* Notification message */
    DMUS_PMSGT_TEMPO            = 4,      /* Tempo message */
    DMUS_PMSGT_CURVE            = 5,      /* Control change / pitch bend, etc. curve */
    DMUS_PMSGT_TIMESIG          = 6,      /* Time signature */
    DMUS_PMSGT_PATCH            = 7,      /* Patch changes */
    DMUS_PMSGT_TRANSPOSE        = 8,      /* Transposition messages */
    DMUS_PMSGT_CHANNEL_PRIORITY = 9,      /* Channel priority */
    DMUS_PMSGT_STOP             = 10,     /* Stop message */
    DMUS_PMSGT_DIRTY            = 11,     /* Tells Tools that cache GetParam() info to refresh */
    DMUS_PMSGT_WAVE             = 12,     /* Carries control information for playing a wave. */
    DMUS_PMSGT_LYRIC            = 13,     /* Lyric message from lyric track. */
    DMUS_PMSGT_SCRIPTLYRIC      = 14,     /* Lyric message sent by a script with the Trace function. */
    DMUS_PMSGT_USER             = 255     /* User message */
} DMUS_PMSGT_TYPES;

/* DMUS_SEGF_FLAGS correspond to IDirectMusicPerformance::PlaySegment, and other API */
typedef enum enumDMUS_SEGF_FLAGS
{
    DMUS_SEGF_REFTIME           = 1<<6,   /* 0x40 Time parameter is in reference time  */
    DMUS_SEGF_SECONDARY         = 1<<7,   /* 0x80 Secondary segment */
    DMUS_SEGF_QUEUE             = 1<<8,   /* 0x100 Queue at the end of the primary segment queue (primary only) */
    DMUS_SEGF_CONTROL           = 1<<9,   /* 0x200 Play as a control track (secondary segments only) */
    DMUS_SEGF_AFTERPREPARETIME  = 1<<10,  /* 0x400 Play after the prepare time (See IDirectMusicPerformance::GetPrepareTime) */
    DMUS_SEGF_GRID              = 1<<11,  /* 0x800 Play on grid boundary */
    DMUS_SEGF_BEAT              = 1<<12,  /* 0x1000 Play on beat boundary */
    DMUS_SEGF_MEASURE           = 1<<13,  /* 0x2000 Play on measure boundary */
    DMUS_SEGF_DEFAULT           = 1<<14,  /* 0x4000 Use segment's default boundary */
    DMUS_SEGF_NOINVALIDATE      = 1<<15,  /* 0x8000 Play without invalidating the currently playing segment(s) */
    DMUS_SEGF_ALIGN             = 1<<16,  /* 0x10000 Align segment with requested boundary, but switch at first valid point */
    DMUS_SEGF_VALID_START_BEAT  = 1<<17,  /* 0x20000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any beat. */
    DMUS_SEGF_VALID_START_GRID  = 1<<18,  /* 0x40000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any grid. */
    DMUS_SEGF_VALID_START_TICK  = 1<<19,  /* 0x80000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur any time. */
    DMUS_SEGF_AUTOTRANSITION    = 1<<20,  /* 0x100000 Compose and play a transition segment, using either the transition template or transition embedded in song. */
    DMUS_SEGF_AFTERQUEUETIME    = 1<<21,  /* 0x200000 Make sure to play after the queue time. This is default for primary segments */
    DMUS_SEGF_AFTERLATENCYTIME  = 1<<22,  /* 0x400000 Make sure to play after the latency time. This is true for all segments, so this is a nop */
    DMUS_SEGF_SEGMENTEND        = 1<<23,  /* 0x800000 Play at the next end of segment. */
    DMUS_SEGF_MARKER            = 1<<24,  /* 0x1000000 Play at next marker in the primary segment. If there are no markers, default to any other resolution requests. */
    DMUS_SEGF_TIMESIG_ALWAYS    = 1<<25,  /* 0x2000000 Even if there is no primary segment, align start time with current time signature. */
    DMUS_SEGF_USE_AUDIOPATH     = 1<<26,  /* 0x4000000 Uses the audio path that is embedded in the segment or song. */
    DMUS_SEGF_VALID_START_MEASURE = 1<<27,/* 0x8000000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any bar. */
    DMUS_SEGF_INVALIDATE_PRI    = 1<<28   /* 0x10000000 invalidate only the current primary seg state */
} DMUS_SEGF_FLAGS;

#define DMUS_SEG_REPEAT_INFINITE    0xFFFFFFFF  /* For IDirectMusicSegment::SetRepeat*/
#define DMUS_SEG_ALLTRACKS          0x80000000  /* For IDirectMusicSegment::SetParam() and SetTrackConfig() - selects all tracks instead on nth index. */
#define DMUS_SEG_ANYTRACK           0x80000000  /* For IDirectMusicSegment::GetParam() - checks each track until it finds one that returns data (not DMUS_E_NOT_FOUND.) */
                                                

/* DMUS_TIME_RESOLVE_FLAGS correspond to IDirectMusicPerformance::GetResolvedTime, and can */
/* also be used interchangeably with the corresponding DMUS_SEGF_FLAGS, since their values */
/* are intentionally the same */
typedef enum enumDMUS_TIME_RESOLVE_FLAGS
{
    DMUS_TIME_RESOLVE_AFTERPREPARETIME  = DMUS_SEGF_AFTERPREPARETIME,
    DMUS_TIME_RESOLVE_AFTERQUEUETIME    = DMUS_SEGF_AFTERQUEUETIME,
    DMUS_TIME_RESOLVE_AFTERLATENCYTIME  = DMUS_SEGF_AFTERLATENCYTIME,
    DMUS_TIME_RESOLVE_GRID              = DMUS_SEGF_GRID,
    DMUS_TIME_RESOLVE_BEAT              = DMUS_SEGF_BEAT,
    DMUS_TIME_RESOLVE_MEASURE           = DMUS_SEGF_MEASURE,
    DMUS_TIME_RESOLVE_MARKER            = DMUS_SEGF_MARKER,
    DMUS_TIME_RESOLVE_SEGMENTEND        = DMUS_SEGF_SEGMENTEND,
} DMUS_TIME_RESOLVE_FLAGS;

/* The following flags are sent inside the DMUS_CHORD_KEY.dwFlags parameter */
typedef enum enumDMUS_CHORDKEYF_FLAGS
{
    DMUS_CHORDKEYF_SILENT            = 1,      /* is the chord silent? */
} DMUS_CHORDKEYF_FLAGS;

#define DMUS_MAXSUBCHORD 8

typedef struct _DMUS_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_SUBCHORD;

typedef struct _DMUS_CHORD_KEY
{
    WCHAR           wszName[16];        /* Name of the chord */
    WORD            wMeasure;           /* Measure this falls on */
    BYTE            bBeat;              /* Beat this falls on */
    BYTE            bSubChordCount;     /* Number of chords in the list of subchords */
    DMUS_SUBCHORD   SubChordList[DMUS_MAXSUBCHORD]; /* List of sub chords */
    DWORD           dwScale;            /* Scale underlying the entire chord */
    BYTE            bKey;               /* Key underlying the entire chord */
    BYTE            bFlags;             /* Miscelaneous flags */
} DMUS_CHORD_KEY;

typedef DMUS_CHORD_KEY DMUS_CHORD_PARAM; /* DMUS_CHORD_KEY defined in dmusici.h */

/* DMUS_NOTE_PMSG */
typedef struct _DMUS_NOTE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME mtDuration;     /* duration */
    WORD    wMusicValue;       /* Description of note in chord and key. */
    WORD    wMeasure;          /* Measure in which this note occurs */
    short   nOffset;           /* Offset from grid at which this note occurs */
    BYTE    bBeat;             /* Beat (in measure) at which this note occurs */
    BYTE    bGrid;             /* Grid offset from beat at which this note occurs */
    BYTE    bVelocity;         /* Note velocity */
    BYTE    bFlags;            /* see DMUS_NOTEF_FLAGS */
    BYTE    bTimeRange;        /* Range to randomize time. */
    BYTE    bDurRange;         /* Range to randomize duration. */
    BYTE    bVelRange;         /* Range to randomize velocity. */
    BYTE    bPlayModeFlags;    /* Play mode */
    BYTE    bSubChordLevel;    /* Which subchord level this note uses.  */
    BYTE    bMidiValue;        /* The MIDI note value, converted from wMusicValue */
    char    cTranspose;        /* Transposition to add to midi note value after converted from wMusicValue. */
} DMUS_NOTE_PMSG;

typedef enum enumDMUS_NOTEF_FLAGS
{
    DMUS_NOTEF_NOTEON = 1,              /* Set if this is a MIDI Note On. Otherwise, it is MIDI Note Off */
    DMUS_NOTEF_NOINVALIDATE = 2,        /* Don't invalidate this note off. */
    DMUS_NOTEF_NOINVALIDATE_INSCALE = 4,/* Don't invalidate if still within the scale. */
    DMUS_NOTEF_NOINVALIDATE_INCHORD = 8,/* Don't invalidate if still within the chord. */
    DMUS_NOTEF_REGENERATE = 0x10,       /* Regenerate the note on an invalidate. */
} DMUS_NOTEF_FLAGS;

/* The DMUS_PLAYMODE_FLAGS are used to determine how to convert wMusicValue
   into the appropriate bMidiValue.
*/

typedef enum enumDMUS_PLAYMODE_FLAGS
{
    DMUS_PLAYMODE_KEY_ROOT          = 1,  /* Transpose on top of the key root. */
    DMUS_PLAYMODE_CHORD_ROOT        = 2,  /* Transpose on top of the chord root. */
    DMUS_PLAYMODE_SCALE_INTERVALS   = 4,  /* Use scale intervals from scale pattern. */
    DMUS_PLAYMODE_CHORD_INTERVALS   = 8,  /* Use chord intervals from chord pattern. */
    DMUS_PLAYMODE_NONE              = 16, /* No mode. Indicates the parent part's mode should be used. */
} DMUS_PLAYMODE_FLAGS;

/* The following are playback modes that can be created by combining the DMUS_PLAYMODE_FLAGS
   in various ways:
*/

/* Fixed. wMusicValue holds final MIDI note value. This is used for drums, sound effects, and sequenced
   notes that should not be transposed by the chord or scale.
*/
#define DMUS_PLAYMODE_FIXED             0  
/* In fixed to key, the musicvalue is again a fixed MIDI value, but it
   is transposed on top of the key root. 
*/
#define DMUS_PLAYMODE_FIXEDTOKEY        DMUS_PLAYMODE_KEY_ROOT
/* In fixed to chord, the musicvalue is also a fixed MIDI value, but it
   is transposed on top of the chord root. 
*/
#define DMUS_PLAYMODE_FIXEDTOCHORD      DMUS_PLAYMODE_CHORD_ROOT
/* In Pedalpoint, the key root is used and the notes only track the intervals in
   the scale. The chord root and intervals are completely ignored. This is useful
   for melodic lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINT        (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* In the Melodic mode, the chord root is used but the notes only track the intervals in
   the scale. The key root and chord intervals are completely ignored. This is useful
   for melodic lines that play relative to the chord root. 
*/
#define DMUS_PLAYMODE_MELODIC           (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* Normal chord mode is the prevalent playback mode. 
   The notes track the intervals in the chord, which is based on the chord root. 
   If there is a scale component to the MusicValue, the additional intervals 
   are pulled from the scale and added.
   If the chord does not have an interval to match the chord component of
   the MusicValue, the note is silent.
*/
#define DMUS_PLAYMODE_NORMALCHORD       (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)
/* If it is desirable to play a note that is above the top of the chord, the
   always play mode (known as "purpleized" in a former life) finds a position
   for the note by using intervals from the scale. Essentially, this mode is
   a combination of the Normal and Melodic playback modes, where a failure
   in Normal causes a second try in Melodic mode.
*/
#define DMUS_PLAYMODE_ALWAYSPLAY        (DMUS_PLAYMODE_MELODIC | DMUS_PLAYMODE_NORMALCHORD)

/* In PedalpointChord, the key root is used and the notes only track the intervals in
   the chord. The chord root and scale intervals are completely ignored. This is useful
   for chordal lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINTCHORD   (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)

/* For completeness, here's a mode that tries for pedalpointchord, but if it fails
   uses scale intervals
*/
#define DMUS_PLAYMODE_PEDALPOINTALWAYS  (DMUS_PLAYMODE_PEDALPOINT | DMUS_PLAYMODE_PEDALPOINTCHORD)


/*  Legacy names for modes... */
#define DMUS_PLAYMODE_PURPLEIZED        DMUS_PLAYMODE_ALWAYSPLAY
#define DMUS_PLAYMODE_SCALE_ROOT        DMUS_PLAYMODE_KEY_ROOT
#define DMUS_PLAYMODE_FIXEDTOSCALE      DMUS_PLAYMODE_FIXEDTOKEY

/* DMUS_MIDI_PMSG */
typedef struct _DMUS_MIDI_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    bStatus;
    BYTE    bByte1;
    BYTE    bByte2;
    BYTE    bPad[1];
} DMUS_MIDI_PMSG;

/* DMUS_PATCH_PMSG */
typedef struct _DMUS_PATCH_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    byInstrument;
    BYTE    byMSB;
    BYTE    byLSB;
    BYTE    byPad[1];
} DMUS_PATCH_PMSG;

/* DMUS_TRANSPOSE_PMSG */
typedef struct _DMUS_TRANSPOSE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    short   nTranspose;
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_TRANSPOSE_PMSG;

/* DMUS_CHANNEL_PRIORITY_PMSG */
typedef struct _DMUS_CHANNEL_PRIORITY_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwChannelPriority;
} DMUS_CHANNEL_PRIORITY_PMSG;

/* DMUS_TEMPO_PMSG */
typedef struct _DMUS_TEMPO_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    double  dblTempo;                       /* the tempo */
} DMUS_TEMPO_PMSG;

#define DMUS_TEMPO_MAX          1000
#define DMUS_TEMPO_MIN          1

#define DMUS_MASTERTEMPO_MAX    100.0f
#define DMUS_MASTERTEMPO_MIN    0.01f

/* DMUS_SYSEX_PMSG */
typedef struct _DMUS_SYSEX_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwLen;          /* length of the data */
    BYTE    abData[1];      /* array of data, length equal to dwLen */
} DMUS_SYSEX_PMSG;

/* DMUS_CURVE_PMSG */
typedef struct _DMUS_CURVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME      mtDuration;      /* how long this curve lasts */
    MUSIC_TIME      mtOriginalStart; /* must be set to either zero when this PMSG is created or to the original mtTime of the curve */
    MUSIC_TIME      mtResetDuration; /* how long after the curve is finished to allow a flush or
                                        invalidation to reset to the reset value, nResetValue */
    short           nStartValue;     /* curve's start value */
    short           nEndValue;       /* curve's end value */
    short           nResetValue;     /* curve's reset value, set when a flush or invalidation
                                        occurs within mtDuration + mtResetDuration */
    WORD            wMeasure;        /* Measure in which this curve occurs */
    short           nOffset;         /* Offset from grid at which this curve occurs */
    BYTE            bBeat;           /* Beat (in measure) at which this curve occurs */
    BYTE            bGrid;           /* Grid offset from beat at which this curve occurs */
    BYTE            bType;           /* type of curve */
    BYTE            bCurveShape;     /* shape of curve */
    BYTE            bCCData;         /* CC# if this is a control change type */
    BYTE            bFlags;          /* Curve reset and start from current value flags. */
    WORD            wParamType;      /* RPN or NRPN parameter number. */
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_CURVE_PMSG;

typedef enum enumDMUS_CURVE_FLAGS
{
    DMUS_CURVE_RESET = 1,            /* When set, the nResetValue must be sent when the 
                                        time is reached or an invalidate occurs because
                                        of a transition. If not set, the curve stays
                                        permanently stuck at the new value. */
    DMUS_CURVE_START_FROM_CURRENT = 2/* Ignore Start, start the curve at the current value. 
                                        This only works for volume, expression, and pitchbend. */
} DMUS_CURVE_FLAGS;

     

/* Curve shapes */
enum
{ 
    DMUS_CURVES_LINEAR  = 0,
    DMUS_CURVES_INSTANT = 1,
    DMUS_CURVES_EXP     = 2,
    DMUS_CURVES_LOG     = 3,
    DMUS_CURVES_SINE    = 4
};
/* curve types */
#define DMUS_CURVET_PBCURVE      0x03   /* Pitch bend curve. */
#define DMUS_CURVET_CCCURVE      0x04   /* Control change curve. */
#define DMUS_CURVET_MATCURVE     0x05   /* Mono aftertouch curve. */
#define DMUS_CURVET_PATCURVE     0x06   /* Poly aftertouch curve. */
#define DMUS_CURVET_RPNCURVE     0x07   /* RPN curve with curve type in wParamType. */
#define DMUS_CURVET_NRPNCURVE    0x08   /* NRPN curve with curve type in wParamType. */

/* DMUS_TIMESIG_PMSG */
typedef struct _DMUS_TIMESIG_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIG_PMSG;



/* notification type values */
/* The following correspond to GUID_NOTIFICATION_SEGMENT */
#define DMUS_NOTIFICATION_SEGSTART       0
#define DMUS_NOTIFICATION_SEGEND         1
#define DMUS_NOTIFICATION_SEGALMOSTEND   2
#define DMUS_NOTIFICATION_SEGLOOP        3
#define DMUS_NOTIFICATION_SEGABORT       4
/* The following correspond to GUID_NOTIFICATION_PERFORMANCE */
#define DMUS_NOTIFICATION_MUSICSTARTED   0
#define DMUS_NOTIFICATION_MUSICSTOPPED   1
#define DMUS_NOTIFICATION_MUSICALMOSTEND 2
/* The following corresponds to GUID_NOTIFICATION_MEASUREANDBEAT */
#define DMUS_NOTIFICATION_MEASUREBEAT    0
/* The following corresponds to GUID_NOTIFICATION_CHORD */
#define DMUS_NOTIFICATION_CHORD          0
/* The following correspond to GUID_NOTIFICATION_COMMAND */
#define DMUS_NOTIFICATION_GROOVE         0
#define DMUS_NOTIFICATION_EMBELLISHMENT  1
/* The following corresponds to GUID_NOTIFICATION_RECOMPOSE */
#define DMUS_NOTIFICATION_RECOMPOSE          0

/* DMUS_NOTIFICATION_PMSG */
typedef struct _DMUS_NOTIFICATION_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    GUID    guidNotificationType;
    DWORD   dwNotificationOption;
    DWORD   dwField1;
    DWORD   dwField2;
} DMUS_NOTIFICATION_PMSG;

/* DMUS_WAVE_PMSG */
typedef struct _DMUS_WAVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    REFERENCE_TIME rtDuration;      /* Duration of the wave, in either reference time or music time. */  
    long    lOffset;                /* Offset from actual time to logical time, in music or ref time. */
    long    lVolume;		        /* Initial volume, in 100ths of a dB. */
    long    lPitch;			        /* Initial pitch, in 100ths of a semitone. */
    DWORD   dwStartOffset;          /* How far into the wave to start, in sample time units. (XBOX only) */
    DWORD   dwLoopStart;            /* Starting loop point. (XBOX only) */
    DWORD   dwLoopEnd;              /* Ending loop point. (XBOX only) */
    BYTE    bFlags;                 /* Flags, including DMUS_WAVEF_OFF... */
} DMUS_WAVE_PMSG;


#define DMUS_READAHEAD_MIN          50         /* Readahead min in milliseconds */

#define DMUS_WAVEF_OFF              0x01       /* If wave is playing and this is the off message. */
#define DMUS_WAVEF_STREAMING        0x02       /* If wave is streaming. */
#define DMUS_WAVEF_NOINVALIDATE     0x04       /* Don't invalidate this wave. */
#define DMUS_WAVEF_NOPREROLL        0x08       /* Don't preroll any wave data. */  
#define DMUS_WAVEF_IGNORELOOPS      0x20       /* Ignore segment looping. */

/* DMUS_LYRIC_PMSG */
typedef struct _DMUS_LYRIC_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    WCHAR    wszString[1];      /* null-terminated Unicode lyric string (structure is actually larger than size 1) */
} DMUS_LYRIC_PMSG;

#define DMUS_MAX_NAME           64         /* Maximum object name length. */
#define DMUS_MAX_CATEGORY       64         /* Maximum object category name length. */
#define DMUS_MAX_FILENAME       MAX_PATH

typedef struct _DMUS_VERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DMUS_VERSION, FAR *LPDMUS_VERSION;

/* Time Signature structure, used by IDirectMusicStyle */
/* Also used as a parameter for GetParam() and SetParam */
typedef struct _DMUS_TIMESIGNATURE
{
    MUSIC_TIME mtTime;
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIGNATURE;

typedef struct _DMUS_RHYTHM_PARAM
{
    DMUS_TIMESIGNATURE  TimeSig;
    DWORD               dwRhythmPattern;
} DMUS_RHYTHM_PARAM;

typedef struct _DMUS_TEMPO_PARAM
{
    MUSIC_TIME  mtTime;
    double      dblTempo;
} DMUS_TEMPO_PARAM;


typedef struct _DMUS_MUTE_PARAM
{
    DWORD   dwPChannel;
    DWORD   dwPChannelMap;
    BOOL    fMute;
} DMUS_MUTE_PARAM;

typedef struct _DMUS_VALID_START_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal start 
                                               point after (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_VALID_START_PARAM;

typedef struct _DMUS_PLAY_MARKER_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal segment play 
                                               marker before (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_PLAY_MARKER_PARAM;

/*      The DMUSOBJECTDESC structure is used to communicate everything you could */
/*      possibly use to describe a DirectMusic object.  */

typedef struct _DMUS_OBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
    IStream *      pStream;                /* Stream with data. */
} DMUS_OBJECTDESC;

typedef DMUS_OBJECTDESC *LPDMUS_OBJECTDESC;

/*      Flags for dwValidData. When set, a flag indicates that the  */
/*      corresponding field in DMUSOBJECTDESC holds valid data. */

#define DMUS_OBJ_OBJECT         (1 << 0)     /* Object GUID is valid. */
#define DMUS_OBJ_CLASS          (1 << 1)     /* Class GUID is valid. */
#define DMUS_OBJ_NAME           (1 << 2)     /* Name is valid. */
#define DMUS_OBJ_CATEGORY       (1 << 3)     /* Category is valid. */
#define DMUS_OBJ_FILENAME       (1 << 4)     /* File path is valid. */
#define DMUS_OBJ_FULLPATH       (1 << 5)     /* Path is full path. */
#define DMUS_OBJ_URL            (1 << 6)     /* Path is URL. */
#define DMUS_OBJ_VERSION        (1 << 7)     /* Version is valid. */
#define DMUS_OBJ_DATE           (1 << 8)     /* Date is valid. */
#define DMUS_OBJ_LOADED         (1 << 9)     /* Object is currently loaded in memory. */
#define DMUS_OBJ_MEMORY         (1 << 10)    /* Object is pointed to by pbMemData. */
#define DMUS_OBJ_STREAM         (1 << 11)    /* Object is stored in pStream. */

/*      The DMUS_SCRIPT_ERRORINFO structure describes an error that occurred in a script.
        It is returned by methods in IDirectMusicScript. */
typedef struct _DMUS_SCRIPT_ERRORINFO
{
    DWORD dwSize; /* Size of this structure. */
    HRESULT hr;
    ULONG ulLineNumber;
    LONG ichCharPosition;
    CHAR wszSourceFile[DMUS_MAX_FILENAME];
    CHAR wszSourceComponent[DMUS_MAX_FILENAME];
    CHAR wszDescription[DMUS_MAX_FILENAME];
    CHAR wszSourceLineText[DMUS_MAX_FILENAME];
} DMUS_SCRIPT_ERRORINFO;

//@@BEGIN_MSINTERNAL
/*  Track configuration flags, used with IDirectMusicSegment8::SetTrackConfig() */

#define DMUS_TRACKCONFIG_OVERRIDE_ALL           1	  /* This track should get parameters from this segment before controlling and primary tracks. */
#define DMUS_TRACKCONFIG_OVERRIDE_PRIMARY       2	  /* This track should get parameters from this segment before the primary segment tracks. */
#define DMUS_TRACKCONFIG_FALLBACK               4  	  /* This track should get parameters from this segment if the primary and controlling segments don't succeed. */
#define DMUS_TRACKCONFIG_CONTROL_ENABLED        8     /* GetParam() enabled for this track. */
#define DMUS_TRACKCONFIG_PLAY_ENABLED           0x10  /* Play() enabled for this track. */
#define DMUS_TRACKCONFIG_NOTIFICATION_ENABLED	0x20  /* Notifications enabled for this track. */
#define DMUS_TRACKCONFIG_PLAY_CLOCKTIME         0x40  /* This track plays in clock time, not music time. */
#define DMUS_TRACKCONFIG_PLAY_COMPOSE 	        0x80  /* This track should regenerate data each time it starts playing. */
#define DMUS_TRACKCONFIG_LOOP_COMPOSE           0x100 /* This track should regenerate data each time it repeats. */
#define DMUS_TRACKCONFIG_COMPOSING              0x200 /* This track is used to compose other tracks. */
#define DMUS_TRACKCONFIG_CONTROL_PLAY           0x10000 /* This track, when played in a controlling segment, overrides playback of primary segment tracks. */
#define DMUS_TRACKCONFIG_CONTROL_NOTIFICATION   0x20000 /* This track, when played in a controlling segment, overrides notification of primary segment tracks. */
/* Additional track config flags for composing transitions */
#define DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART    0x400  /* Get track info from start of From segment */
#define DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT  0x800  /* Get track info from current place in From segment */
#define DMUS_TRACKCONFIG_TRANS1_TOSEGSTART      0x1000 /* Get track info from start of To segment */
#define DMUS_TRACKCONFIG_DEFAULT    (DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)

/* #defines for melody fragments */

#define DMUS_MAX_FRAGMENTLABEL 20

#define DMUS_FRAGMENTF_USE_REPEAT      0x1
#define DMUS_FRAGMENTF_REJECT_REPEAT   (0x1 << 1)
#define DMUS_FRAGMENTF_USE_LABEL       (0x1 << 2)

#define DMUS_CONNECTIONF_INTERVALS     (0x1 << 1) /* Use transition intervals */
#define DMUS_CONNECTIONF_OVERLAP       (0x1 << 2) /* Use overlapping notes for transitions */

/* Get/SetParam structs for commands */
/* PARAM structures, used by GetParam() and SetParam() */
typedef struct _DMUS_COMMAND_PARAM
{
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
    BYTE bRepeatMode;
} DMUS_COMMAND_PARAM;

//@@END_MSINTERNAL

typedef struct _DMUS_COMMAND_PARAM_2
{
	MUSIC_TIME mtTime;
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
    BYTE bRepeatMode;
} DMUS_COMMAND_PARAM_2;

//@@BEGIN_MSINTERNAL
/* Get/SetParam structs for melody fragments */
typedef struct _DMUS_CONNECTION_RULE
{
    DWORD       dwFlags;      /* DMUS_CONNECTIONF_ flags */
    DWORD       dwIntervals;  /* Legal transition intervals (first 24 bits; two-octave range) */
} DMUS_CONNECTION_RULE;

typedef struct _DMUS_MELODY_FRAGMENT
{
    MUSIC_TIME  mtTime;
    DWORD       dwID;                   /* This fragment's ID */
    WCHAR       wszVariationLabel[DMUS_MAX_FRAGMENTLABEL]; /* Each style translates this into a set of variations (held in part ref) */
    DWORD       dwVariationFlags;       /* A set of variations */
    DWORD       dwRepeatFragmentID;     /* ID of a fragment to repeat */
    DWORD       dwFragmentFlags;        /* DMUS_FRAGMENTF_ flags */
    DWORD       dwPlayModeFlags;        /* NOT CURRENTLY USED - MUST BE 0 */
    DWORD       dwTransposeIntervals;   /* Legal transposition intervals (first 24 bits; two-octave range) */
    DMUS_COMMAND_PARAM      Command;
    DMUS_CONNECTION_RULE    ConnectionArc;
} DMUS_MELODY_FRAGMENT;

typedef IDirectMusicObject __RPC_FAR *LPDMUS_OBJECT;
typedef IDirectMusicLoader __RPC_FAR *LPDMUS_LOADER;
typedef IDirectMusicBand __RPC_FAR *LPDMUS_BAND;

#define DMUSB_LOADED    (1 << 0)        /* Set when band has been loaded */
#define DMUSB_DEFAULT   (1 << 1)        /* Set when band is default band for a style */

/*////////////////////////////////////////////////////////////////////
// IDirectMusicBand */
#undef  INTERFACE
#define INTERFACE  IDirectMusicBand
DECLARE_INTERFACE_(IDirectMusicBand, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicBand */
    STDMETHOD(CreateSegment)        (THIS_ IDirectMusicSegment** ppSegment) PURE;
//    STDMETHOD(Download)             (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
//    STDMETHOD(Unload)               (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
};

typedef IDirectMusicBand IDirectMusicBand8;
//@@END_MSINTERNAL

/*////////////////////////////////////////////////////////////////////
// IDirectMusicObject */
#undef  INTERFACE
#define INTERFACE  IDirectMusicObject
DECLARE_INTERFACE_(IDirectMusicObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicObject */
    STDMETHOD(GetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(ParseDescriptor)      (THIS_ LPSTREAM pStream, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};

typedef IDirectMusicObject IDirectMusicObject8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicLoader */
#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader
DECLARE_INTERFACE_(IDirectMusicLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicLoader */
    /* IDirectMusicLoader */
    STDMETHOD(GetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc,
                                           REFIID riid,
                                           LPVOID FAR *ppv) PURE;
    STDMETHOD(SetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, 
                                           const char *pzPath, 
                                           BOOL fClear) PURE;
    STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
    STDMETHOD_(void, CollectGarbage)                (THIS) PURE;
    STDMETHOD(ReleaseObjectByUnknown)               (THIS_ IUnknown *pObject) PURE;
    STDMETHOD(LoadObjectFromFile)                   (THIS_ REFGUID rguidClassID, 
                                                           REFIID iidInterfaceID, 
                                                           const char *pzFilePath, 
                                                           void ** ppObject) PURE;
//@@BEGIN_MSINTERNAL
    STDMETHOD(ReleaseObject)        (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(EnableCache)          (THIS_ REFGUID rguidClass, 
                                           BOOL fEnable) PURE;
//    STDMETHOD(ScanDirectory)        (THIS_ REFGUID rguidClass, 
//                                           const WCHAR *pwzFileExtension, 
//                                           const WCHAR *pwzScanFileName) PURE;
//    STDMETHOD(CacheObject)          (THIS_ IDirectMusicObject * pObject) PURE;
//    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
//                                           DWORD dwIndex, 
//                                           LPDMUS_OBJECTDESC pDesc) PURE;
//@@END_MSINTERNAL
};                                  

typedef IDirectMusicLoader IDirectMusicLoader8;

/*  Stream objects must support IDirectMusicGetLoader interface to access loader while file parsing. 
	If you write your own loader, you will need to add this interface to the stream object.
*/

#undef  INTERFACE
#define INTERFACE  IDirectMusicGetLoader
DECLARE_INTERFACE_(IDirectMusicGetLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicGetLoader */
    STDMETHOD(GetLoader)            (THIS_ IDirectMusicLoader ** ppLoader) PURE;
};

typedef IDirectMusicGetLoader IDirectMusicGetLoader8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment
DECLARE_INTERFACE_(IDirectMusicSegment, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegment */
    STDMETHOD(SetRepeats)               (THIS_ DWORD  dwRepeats) PURE;
    STDMETHOD(Compose)                  (THIS_ MUSIC_TIME mtTime,
                                               IDirectMusicSegment* pFromSegment,
                                               IDirectMusicSegment* pToSegment,
                                               IDirectMusicSegment** ppComposedSegment) PURE;
    STDMETHOD(Download)                 (THIS_ IUnknown *pAudioPath) PURE;
    STDMETHOD(Unload)                   (THIS_ IUnknown *pAudioPath) PURE;
    STDMETHOD(GetLength)                (THIS_ MUSIC_TIME* pmtLength) PURE;
    STDMETHOD(SetLength)                (THIS_ MUSIC_TIME mtLength) PURE;
    STDMETHOD(SetClockTimeLength)		(THIS_ REFERENCE_TIME rtLength, BOOL fClockTime) PURE;
    STDMETHOD(GetClockTimeLength)		(THIS_ REFERENCE_TIME *prtLength, BOOL *pfClockTime) PURE;
    STDMETHOD(SetLoopPoints)            (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd) PURE;
    STDMETHOD(GetLoopPoints)            (THIS_ MUSIC_TIME* pmtStart, 
                                               MUSIC_TIME* pmtEnd) PURE;
    STDMETHOD(SetStartPoint)            (THIS_ MUSIC_TIME mtStart) PURE;
    STDMETHOD(GetStartPoint)            (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(SetWavePlaybackParams)    (THIS_ DWORD dwFlags, DWORD dwReadAhead) PURE;
    STDMETHOD(AddNotificationType)      (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)   (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetRepeats)               (THIS_ DWORD* pdwRepeats) PURE;

//@@BEGIN_MSINTERNAL
//    STDMETHOD(SetClockTimeLoopPoints)   (THIS_ REFERENCE_TIME rtStart, 
//                                               REFERENCE_TIME rtEnd) PURE;
//    STDMETHOD(GetClockTimeLoopPoints)   (THIS_ REFERENCE_TIME* prtStart, 
//                                               REFERENCE_TIME* prtEnd) PURE;
    STDMETHOD(GetDefaultResolution)     (THIS_ DWORD* pdwResolution) PURE;
    STDMETHOD(SetDefaultResolution)     (THIS_ DWORD  dwResolution) PURE;
    STDMETHOD(GetTrack)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               IDirectMusicTrack** ppTrack) PURE;
    STDMETHOD(GetTrackGroup)            (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD* pdwGroupBits) PURE;
    STDMETHOD(InsertTrack)              (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(RemoveTrack)              (THIS_ IDirectMusicTrack* pTrack) PURE;
    STDMETHOD(GetGraph)                 (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(GetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               MUSIC_TIME* pmtNext, 
                                               void* pParam) PURE; 
    STDMETHOD(SetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               void* pParam) PURE;
    STDMETHOD(Clone)                    (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd, 
                                               IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetPChannelsUsed)         (THIS_ DWORD dwNumPChannels, 
                                               DWORD* paPChannels) PURE;
    /*  IDirectMusicSegment8 */
//    STDMETHOD(SetTrackConfig)           (THIS_ REFGUID rguidTrackClassID,   /* Class ID of the type of track on which to set the configuration flags. */
//                                               DWORD dwGroupBits,           /* Group bits. */
//                                               DWORD dwIndex,               /* Nth track (or DMUS_SEG_ALLTRACKS) that matches class id and group id. */
//                                               DWORD dwFlagsOn,             /* DMUS_TRACKCONFIG_ flags to enable. */
//                                               DWORD dwFlagsOff) PURE;      /* DMUS_TRACKCONFIG_ flags to disable. */
    STDMETHOD(GetAudioPathConfig)       (THIS_ IUnknown ** ppAudioPathConfig) PURE;
//@@END_MSINTERNAL
};

typedef IDirectMusicSegment IDirectMusicSegment8;


/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState
DECLARE_INTERFACE_(IDirectMusicSegmentState, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegmentState */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
    STDMETHOD(SetVolume)            (THIS_ long lVolume,        /* Gain, in 100ths of a dB. This must be negative (0 represents full volume.) */
                                           DWORD dwDuration) PURE;/* Duration of volume ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(SetPitch)             (THIS_ long lPitch,         /* Pitch bend, in 100ths of a semitone. */
                                           DWORD dwDuration) PURE;/* Duration of pitch ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(GetSegment )          (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetStartTime)         (THIS_ MUSIC_TIME* pmtStart) PURE;
//@@BEGIN_MSINTERNAL
    STDMETHOD(GetRepeats)           (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(GetSeek)              (THIS_ MUSIC_TIME* pmtSeek) PURE;
    STDMETHOD(GetStartPoint)        (THIS_ MUSIC_TIME* pmtStart) PURE;

    /* IDirectMusicSegmentState8 */
//    STDMETHOD(SetTrackConfig)       (THIS_ REFGUID rguidTrackClassID,   /* Class ID of the type of track on which to set the configuration flags. */
//                                           DWORD dwGroupBits,           /* Group bits. */
//                                           DWORD dwIndex,               /* Nth track (or DMUS_SEG_ALLTRACKS) that matches class id and group id. */
//                                           DWORD dwFlagsOn,             /* DMUS_TRACKCONFIG_ flags to enable. */
//                                           DWORD dwFlagsOff) PURE;      /* DMUS_TRACKCONFIG_ flags to disable. */
//@@END_MSINTERNAL
};

typedef IDirectMusicSegmentState IDirectMusicSegmentState8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicAudioPath */
#undef  INTERFACE
#define INTERFACE  IDirectMusicAudioPath
DECLARE_INTERFACE_(IDirectMusicAudioPath, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicAudioPath */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
    STDMETHOD(Activate)             (THIS_ BOOL fActivate) PURE;/* True to activate, False to deactivate. */
    STDMETHOD(SetVolume)            (THIS_ long lVolume,        /* Gain, in 100ths of a dB. This must be negative (0 represents full volume.) */
                                           DWORD dwDuration) PURE;/* Duration of volume ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(SetPitch)             (THIS_ long lPitch,         /* Pitch bend, in 100ths of a semitone. */
                                           DWORD dwDuration) PURE;/* Duration of pitch ramp in  milliseconds. Note that 0 is more efficient. */
//@@BEGIN_MSINTERNAL
    STDMETHOD(ConvertPChannel)      (THIS_ DWORD dwPChannelIn,   /* Pchannel of source. */
                                           DWORD *pdwPChannelOut) PURE; /* Equivalent pchannel on performance. */
//@@END_MSINTERNAL
};

typedef IDirectMusicAudioPath IDirectMusicAudioPath8;


/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance */

#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance
DECLARE_INTERFACE_(IDirectMusicPerformance, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPerformance */
    STDMETHOD(GetSegmentState)      (THIS_ IDirectMusicSegmentState** ppSegmentState, 
                                           MUSIC_TIME mtTime) PURE;
    STDMETHOD(SendPMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, 
                                           REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, 
                                           MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)            (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegState) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME* prtNow, 
                                           MUSIC_TIME* pmtNow) PURE;
    STDMETHOD(AllocPMsg)            (THIS_ ULONG cb, 
                                           DMUS_PMSG** ppPMSG) PURE;
    STDMETHOD(FreePMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
    STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(SetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(PlaySegmentEx)        (THIS_ IUnknown* pSource,                       /* Segment to play. Alternately, could be an IDirectMusicSong  */
                                           const char *pzSegmentName,                     /* If song, which segment in the song  */
                                           IUnknown* pTransition,                   /* Optional template segment to compose transition with. */
                                           DWORD dwFlags,                           /* DMUS_SEGF_ flags. */ 
                                           __int64 i64StartTime,                    /* Time to start playback. */
                                           IDirectMusicSegmentState** ppSegmentState, /* Returned Segment State. */
                                           IUnknown *pFrom,                         /* Optional segmentstate or audiopath to replace. */
                                           IUnknown *pAudioPath) PURE;              /* Optional audioPath to play on. */
    STDMETHOD(StopEx)               (THIS_ IUnknown *pObjectToStop,                 /* Segstate, AudioPath, Segment, or Song. */ 
                                           __int64 i64StopTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(ClonePMsg)            (THIS_ DMUS_PMSG* pSourcePMSG,
                                           DMUS_PMSG** ppCopyPMSG) PURE;
    STDMETHOD(CreateAudioPath)      (THIS_ IUnknown *pSourceConfig,                 /* Source configuration, from AudioPathConfig file. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */                                           
    STDMETHOD(CreateStandardAudioPath)(THIS_ DWORD dwType,                          /* Type of path to create. */
                                           DWORD dwPChannelCount,                   /* How many PChannels to allocate for it. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */
    STDMETHOD(SetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath *pAudioPath) PURE;
    STDMETHOD(GetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath **ppAudioPath) PURE;
    STDMETHOD(GetParamEx)           (THIS_ REFGUID rguidType,                       /* GetParam command ID. */
                                           DWORD dwTrackID,                         /* Virtual track ID of caller. */
                                           DWORD dwGroupBits,                       /* Group bits of caller. */
                                           DWORD dwIndex,                           /* Index to Nth parameter. */
                                           MUSIC_TIME mtTime,                       /* Time of requested parameter. */
                                           MUSIC_TIME* pmtNext,                     /* Returned delta to next parameter. */
                                           void* pParam) PURE;                      /* Data structure to fill with parameter. */
    STDMETHOD(InitAudioX)           (THIS_ DWORD dwDefaultPathType,                 /* Requested default audio path type, also optional. */
                                           DWORD dwPChannelCount,                   /* Number of PChannels, if default audio path to be created. */
                                           DWORD dwVoiceCount,                      /* Number of Voices (DSoundBuffers) allocated by synth. */
						                   DWORD dwFlags) PURE;                 
    STDMETHOD(CloseDown)            (THIS) PURE;
    STDMETHOD(Invalidate)           (THIS_ MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
//@@BEGIN_MSINTERNAL
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pParam) PURE; 
    STDMETHOD(PlaySegment)          (THIS_ IDirectMusicSegment* pSegment, 
                                           DWORD dwFlags, 
                                           __int64 i64StartTime, 
                                           IDirectMusicSegmentState** ppSegmentState) PURE;
    STDMETHOD(Stop)                 (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegmentState, 
                                           MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(MIDIToMusic)          (THIS_ BYTE bMIDIValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           WORD *pwMusicValue) PURE;
    STDMETHOD(MusicToMIDI)          (THIS_ WORD wMusicValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           BYTE *pbMIDIValue) PURE;
    STDMETHOD(GetLatencyTime)       (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(GetQueueTime)         (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(GetResolvedTime)      (THIS_ REFERENCE_TIME rtTime,
                                           REFERENCE_TIME* prtResolved,
                                           DWORD dwTimeResolveFlags) PURE;
    STDMETHOD(GetSynth)				(THIS_ IDirectMusicSynthX **ppSynth) PURE;
//    STDMETHOD(SetPrepareTime)       (THIS_ DWORD dwMilliSeconds) PURE;
//    STDMETHOD(GetPrepareTime)       (THIS_ DWORD* pdwMilliSeconds) PURE;
//    STDMETHOD(SetBumperLength)      (THIS_ DWORD dwMilliSeconds) PURE;
//    STDMETHOD(GetBumperLength)      (THIS_ DWORD* pdwMilliSeconds) PURE;
//    STDMETHOD(GetGraph)             (THIS_ IDirectMusicGraph** ppGraph) PURE;
//    STDMETHOD(SetGraph)             (THIS_ IDirectMusicGraph* pGraph) PURE;
//    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hNotification, 
//                                           REFERENCE_TIME rtMinimum) PURE;
//    STDMETHOD(SetParam)             (THIS_ REFGUID rguidType, 
//                                           DWORD dwGroupBits, 
//                                           DWORD dwIndex, 
//                                           MUSIC_TIME mtTime, 
//                                           void* pParam) PURE;
//    STDMETHOD(AdjustTime)           (THIS_ REFERENCE_TIME rtAmount) PURE;
    /*  IDirectMusicPerformance8 */
//@@END_MSINTERNAL
};

typedef IDirectMusicPerformance IDirectMusicPerformance8;


/*////////////////////////////////////////////////////////////////////
// IDirectMusicGraph */
#undef  INTERFACE
#define INTERFACE  IDirectMusicGraph
DECLARE_INTERFACE_(IDirectMusicGraph, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicGraph */
    STDMETHOD(StampPMsg)            (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(InsertTool)           (THIS_ IDirectMusicTool* pTool, 
                                           DWORD* pdwPChannels, 
                                           DWORD cPChannels, 
                                           LONG lIndex) PURE;
    STDMETHOD(GetTool)              (THIS_ DWORD dwIndex, 
                                           IDirectMusicTool** ppTool) PURE;
    STDMETHOD(RemoveTool)           (THIS_ IDirectMusicTool* pTool) PURE;
};

typedef IDirectMusicGraph IDirectMusicGraph8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTool */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTool
DECLARE_INTERFACE_(IDirectMusicTool, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicTool */
    STDMETHOD(Init)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(GetMsgDeliveryType)   (THIS_ DWORD* pdwDeliveryType ) PURE;
    STDMETHOD(GetMediaTypeArraySize)(THIS_ DWORD* pdwNumElements ) PURE;
    STDMETHOD(GetMediaTypes)        (THIS_ DWORD** padwMediaTypes, 
                                           DWORD dwNumElements) PURE;
    STDMETHOD(ProcessPMsg)          (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(Flush)                (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG, 
                                           REFERENCE_TIME rtTime) PURE;
};

//@@BEGIN_MSINTERNAL
/*////////////////////////////////////////////////////////////////////
// IDirectMusicTool8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTool8
DECLARE_INTERFACE_(IDirectMusicTool8, IDirectMusicTool)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicTool */
    STDMETHOD(Init)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(GetMsgDeliveryType)   (THIS_ DWORD* pdwDeliveryType ) PURE;
    STDMETHOD(GetMediaTypeArraySize)(THIS_ DWORD* pdwNumElements ) PURE;
    STDMETHOD(GetMediaTypes)        (THIS_ DWORD** padwMediaTypes, 
                                           DWORD dwNumElements) PURE;
    STDMETHOD(ProcessPMsg)          (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(Flush)                (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG, 
                                           REFERENCE_TIME rtTime) PURE;
    /*  IDirectMusicTool8 */
    STDMETHOD(Clone)                (THIS_ IDirectMusicTool ** ppTool) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicStyle */
#undef  INTERFACE
#define INTERFACE  IDirectMusicStyle
DECLARE_INTERFACE_(IDirectMusicStyle, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicStyle */
    STDMETHOD(GetBand)                (THIS_ const WCHAR* pwszName, 
                                             IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumBand)               (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetDefaultBand)         (THIS_ IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumMotif)              (THIS_ DWORD dwIndex, 
                                             WCHAR* pwszName) PURE;
    STDMETHOD(GetMotif)               (THIS_ const WCHAR* pwszName, 
                                             IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetDefaultChordMap)     (THIS_ IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(EnumChordMap)           (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetChordMap)            (THIS_ const WCHAR* pwszName, 
                                             IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(GetTimeSignature)       (THIS_ DMUS_TIMESIGNATURE* pTimeSig) PURE;
    STDMETHOD(GetEmbellishmentLength) (THIS_ DWORD dwType, 
                                             DWORD dwLevel, 
                                             DWORD* pdwMin, 
                                             DWORD* pdwMax) PURE;
    STDMETHOD(GetTempo)               (THIS_ double* pTempo) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicStyle8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicStyle8
DECLARE_INTERFACE_(IDirectMusicStyle8, IDirectMusicStyle)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicStyle */
    STDMETHOD(GetBand)                (THIS_ const WCHAR* pwszName, 
                                             IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumBand)               (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetDefaultBand)         (THIS_ IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumMotif)              (THIS_ DWORD dwIndex, 
                                             WCHAR* pwszName) PURE;
    STDMETHOD(GetMotif)               (THIS_ const WCHAR* pwszName, 
                                             IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetDefaultChordMap)     (THIS_ IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(EnumChordMap)           (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetChordMap)            (THIS_ const WCHAR* pwszName, 
                                             IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(GetTimeSignature)       (THIS_ DMUS_TIMESIGNATURE* pTimeSig) PURE;
    STDMETHOD(GetEmbellishmentLength) (THIS_ DWORD dwType, 
                                             DWORD dwLevel, 
                                             DWORD* pdwMin, 
                                             DWORD* pdwMax) PURE;
    STDMETHOD(GetTempo)               (THIS_ double* pTempo) PURE;

    /*  IDirectMusicStyle8 */
    STDMETHOD(EnumPattern)            (THIS_ DWORD dwIndex, 
                                             DWORD dwPatternType,
                                             WCHAR* pwszName) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicChordMap */
#undef  INTERFACE
#define INTERFACE  IDirectMusicChordMap
DECLARE_INTERFACE_(IDirectMusicChordMap, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicChordMap */
    STDMETHOD(GetScale)             (THIS_ DWORD* pdwScale) PURE;
};

typedef IDirectMusicChordMap IDirectMusicChordMap8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicComposer */
#undef  INTERFACE
#define INTERFACE  IDirectMusicComposer
DECLARE_INTERFACE_(IDirectMusicComposer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicComposer */
    STDMETHOD(ComposeSegmentFromTemplate)   (THIS_ IDirectMusicStyle* pStyle, 
                                                   IDirectMusicSegment* pTemplate, 
                                                   WORD wActivity, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(ComposeSegmentFromShape)      (THIS_ IDirectMusicStyle* pStyle, 
                                                   WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   WORD wActivity, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment ) PURE;
    STDMETHOD(ComposeTransition)            (THIS_ IDirectMusicSegment* pFromSeg, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   MUSIC_TIME mtTime, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg) PURE;
    STDMETHOD(AutoTransition)               (THIS_ IDirectMusicPerformance* pPerformance, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg, 
                                                   IDirectMusicSegmentState** ppToSegState, 
                                                   IDirectMusicSegmentState** ppTransSegState) PURE;
    STDMETHOD(ComposeTemplateFromShape)     (THIS_ WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   WORD wEndLength, 
                                                   IDirectMusicSegment** ppTemplate) PURE;
    STDMETHOD(ChangeChordMap)            (THIS_ IDirectMusicSegment* pSegment, 
                                                   BOOL fTrackScale, 
                                                   IDirectMusicChordMap* pChordMap) PURE;
};

typedef IDirectMusicComposer IDirectMusicComposer8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicPatternTrack */

#undef  INTERFACE
#define INTERFACE  IDirectMusicPatternTrack
DECLARE_INTERFACE_(IDirectMusicPatternTrack, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicPatternTrack */
    STDMETHOD(CreateSegment)             (THIS_ IDirectMusicStyle* pStyle,
                                                IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetVariation)              (THIS_ IDirectMusicSegmentState* pSegState,
                                                DWORD dwVariationFlags,
                                                DWORD dwPart) PURE;
    STDMETHOD(SetPatternByName)          (THIS_ IDirectMusicSegmentState* pSegState,
                                                WCHAR* wszName,
                                                IDirectMusicStyle* pStyle,
                                                DWORD dwPatternType,
                                                DWORD* pdwLength) PURE;
};

typedef IDirectMusicPatternTrack IDirectMusicPatternTrack8;
//@@END_MSINTERNAL

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicScript */

#undef  INTERFACE
#define INTERFACE  IDirectMusicScript
DECLARE_INTERFACE_(IDirectMusicScript, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicScript */
    STDMETHOD(Init)                     (THIS_ IDirectMusicPerformance *pPerformance,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(CallRoutine)              (THIS_ const char *pszRoutineName,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableNumber)        (THIS_ const char *pszVariableName,
                                               LONG lValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableNumber)        (THIS_ const char *pszVariableName,
                                               LONG *plValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableObject)        (THIS_ const char *pszVariableName,
                                               IUnknown *punkValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableObject)        (THIS_ const char *pszVariableName,
                                               REFIID riid,
                                               LPVOID FAR *ppv,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableString)        (THIS_ const char *pszVariableName,
                                               const char * pszValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableString)        (THIS_ const char *pszVariableName,
                                               char *pszValue,
                                               LONG lLength,
                                               LONG *plConverted, 
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
};

typedef IDirectMusicScript IDirectMusicScript8;

//@@BEGIN_MSINTERNAL

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicContainer */

#undef  INTERFACE
#define INTERFACE  IDirectMusicContainer
DECLARE_INTERFACE_(IDirectMusicContainer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicContainer */
    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
                                           DWORD dwIndex, 
                                           LPDMUS_OBJECTDESC pDesc,
                                           WCHAR *pwszAlias) PURE;
};

typedef IDirectMusicContainer IDirectMusicContainer8;

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSong */

#undef  INTERFACE
#define INTERFACE  IDirectMusicSong
DECLARE_INTERFACE_(IDirectMusicSong, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSong */
    STDMETHOD(Compose)               (THIS) PURE;
    STDMETHOD(GetParam)              (THIS_ REFGUID rguidType, 
                                            DWORD dwGroupBits, 
                                            DWORD dwIndex, 
                                            MUSIC_TIME mtTime, 
                                            MUSIC_TIME* pmtNext, 
                                            void* pParam) PURE;
    STDMETHOD(GetSegment)            (THIS_ const WCHAR *pwzName,                         /* Retrieve a specific segment by name. */
                                            IDirectMusicSegment **ppSegment) PURE;  /* Returned segment. */
    STDMETHOD(GetAudioPathConfig)    (THIS_ IUnknown ** ppAudioPathConfig) PURE;    /* Retrieve embedded audiopath configuration. */
    STDMETHOD(Download)              (THIS_ IUnknown *pAudioPath) PURE;             /* Download entire song to ports on performance or audiopath. */
    STDMETHOD(Unload)                (THIS_ IUnknown *pAudioPath) PURE;             /* Unload entire song from port on performance or audiopath. */
    STDMETHOD(EnumSegment)           (THIS_ DWORD dwIndex,                          /* Nth segment to retrieve. */
		                                    IDirectMusicSegment **ppSegment) PURE;  /* Pointer to segment. */
};

typedef IDirectMusicSong IDirectMusicSong8;
//@@END_MSINTERNAL

/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicPerformance,0xd2ac2881, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegment,0xd2ac2882, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicLoader,0xd2ac2892, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
//@@BEGIN_MSINTERNAL
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
//@@END_MSINTERNAL
DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSegmentState,0xd2ac2883, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicGraph,0xd2ac2884, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyle,0xd2ac288a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMap,0xd2ac288f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicComposer,0xd2ac2890, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScript,0x810b5013, 0xe88d, 0x11d2, 0x8b, 0xc1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {810B5013-E88D-11d2-8BC1-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicContainer,0x9301e380, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
DEFINE_GUID(CLSID_DirectMusicAudioPathConfig,0xee0b9ca0, 0xa81e, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicPatternTrack,0xd2ac2897, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectSoundWave,0x8a667154, 0xf9cb, 0x11d2, 0xad, 0x8a, 0x0, 0x60, 0xb0, 0x57, 0x5a, 0xbc);
DEFINE_GUID(CLSID_DirectMusicSong, 0xaed5f0a5, 0xd972, 0x483d, 0xa3, 0x84, 0x64, 0x9d, 0xfe, 0xb9, 0xc1, 0x81);
DEFINE_GUID(CLSID_DirectMusicStreamStream, 0xf34feac1, 0xe3af, 0x49ad, 0x83, 0x97, 0xb, 0xed, 0x32, 0x3e, 0xf9, 0x6b);
DEFINE_GUID(CLSID_DirectMusicMemStream, 0x75ccb447, 0x8d3f, 0x4154, 0xab, 0xad, 0x59, 0x60, 0xae, 0xd4, 0xba, 0x63);
DEFINE_GUID(CLSID_DirectMusicFileStream, 0xf12f2c7d, 0x3651, 0x486f, 0xb9, 0xfa, 0x16, 0xe1, 0x1d, 0x15, 0x24, 0xfd);

/* Special GUID for all object types. This is used by the loader. */
DEFINE_GUID(GUID_DirectMusicAllTypes,0xd2ac2893, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Notification guids */
DEFINE_GUID(GUID_NOTIFICATION_SEGMENT,0xd2ac2899, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_PERFORMANCE,0x81f75bc5, 0x4e5d, 0x11d2, 0xbc, 0xc7, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_NOTIFICATION_MEASUREANDBEAT,0xd2ac289a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_CHORD,0xd2ac289b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_COMMAND,0xd2ac289c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_RECOMPOSE, 0xd348372b, 0x945b, 0x45ae, 0xa5, 0x22, 0x45, 0xf, 0x12, 0x5b, 0x84, 0xa5);

/* Track param type guids */
//@@BEGIN_MSINTERNAL
/* Use to get/set a DMUS_COMMAND_PARAM param in the Command track */
DEFINE_GUID(GUID_CommandParam,0xd2ac289d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
//@@END_MSINTERNAL

/* Use to get a DMUS_COMMAND_PARAM_2 param in the Command track */
DEFINE_GUID(GUID_CommandParam2, 0x28f97ef7, 0x9538, 0x11d2, 0x97, 0xa9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_COMMAND_PARAM_2 param to be used as the command following all commands in
the Command track (this information can't be saved) */
DEFINE_GUID(GUID_CommandParamNext, 0x472afe7a, 0x281b, 0x11d3, 0x81, 0x7d, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_CHORD_PARAM param in the Chord track */
DEFINE_GUID(GUID_ChordParam,0xd2ac289e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_RHYTHM_PARAM param in the Chord track */
DEFINE_GUID(GUID_RhythmParam,0xd2ac289f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicStyle param in the Style track */
DEFINE_GUID(GUID_IDirectMusicStyle,0xd2ac28a1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_TIMESIGNATURE param in the Style and TimeSig tracks */
DEFINE_GUID(GUID_TimeSignature,0xd2ac28a4, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_TEMPO_PARAM param in the Tempo track */
DEFINE_GUID(GUID_TempoParam,0xd2ac28a5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get the next valid point in a segment at which it may start */
DEFINE_GUID(GUID_Valid_Start_Time,0x7f6b1760, 0x1fdb, 0x11d3, 0x82, 0x26, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/* Use to get the next point in the currently playing primary segment at which a new segment may start */
DEFINE_GUID(GUID_Play_Marker,0xd8761a41, 0x801a, 0x11d3, 0x9b, 0xd1, 0xda, 0xf7, 0xe1, 0xc3, 0xd8, 0x34);

//@@BEGIN_MSINTERNAL
/* Use to get (GetParam) or add (SetParam) bands in the Band track */
DEFINE_GUID(GUID_BandParam,0x2bb1938, 0xcb8b, 0x11d2, 0x8b, 0xb9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6);
typedef struct _DMUS_BAND_PARAM
{
    MUSIC_TIME  mtTimePhysical; /* Note: If this is a clock-time track, then this field is interpreted in the track's internal time format, which is the number of milliseconds after the beginning of playback. */
    IDirectMusicBand *pBand;
} DMUS_BAND_PARAM;

/* Obsolete -- doesn't distinguish physical and logical time.  Use GUID_BandParam instead. */
DEFINE_GUID(GUID_IDirectMusicBand,0xd2ac28ac, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicChordMap param in the ChordMap track */
DEFINE_GUID(GUID_IDirectMusicChordMap,0xd2ac28ad, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
//@@END_MSINTERNAL

/* Use to get/set a DMUS_MUTE_PARAM param in the Mute track */
DEFINE_GUID(GUID_MuteParam,0xd2ac28af, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

//@@BEGIN_MSINTERNAL
/* These guids are used in IDirectMusicSegment::SetParam to tell the band track to perform various actions.
   Some of these guids (where noted) also apply to wave tracks.
 */
/* Download bands/waves for the IDirectMusicSegment */
DEFINE_GUID(GUID_Download,0xd2ac28a7, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Unload bands/waves for the IDirectMusicSegment */
DEFINE_GUID(GUID_Unload,0xd2ac28a8, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Connect segment's bands to an IDirectMusicCollection */
//DEFINE_GUID(GUID_ConnectToDLSCollection, 0x1db1ae6b, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);

/* Enable/disable autodownloading of bands/waves */
//DEFINE_GUID(GUID_Enable_Auto_Download,0xd2ac28a9, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
//DEFINE_GUID(GUID_Disable_Auto_Download,0xd2ac28aa, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Clear all bands */
DEFINE_GUID(GUID_Clear_All_Bands,0xd2ac28ab, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Set segment to manage all program changes, bank selects, etc. for simple playback of a standard MIDI file */
//DEFINE_GUID(GUID_StandardMIDIFile, 0x6621075, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
/* For compatibility with beta releases... */
//#define GUID_IgnoreBankSelectForGM 	GUID_StandardMIDIFile

/* Disable/enable param guids. Use these in SetParam calls to disable or enable sending
 * specific PMsg types.
 */
//DEFINE_GUID(GUID_DisableTimeSig, 0x45fc707b, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
//DEFINE_GUID(GUID_EnableTimeSig, 0x45fc707c, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
//DEFINE_GUID(GUID_DisableTempo, 0x45fc707d, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
//DEFINE_GUID(GUID_EnableTempo, 0x45fc707e, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* Used in SetParam calls for pattern-based tracks.  A nonzero value seeds the random number 
generator for variation selection; a value of zero reverts to the default behavior of 
getting the seed from the system clock.
*/
DEFINE_GUID(GUID_SeedVariations, 0x65b76fa5, 0xff37, 0x11d2, 0x81, 0x4e, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Used to get/set melody fragments (pParam points to a DMUS_MELODY_FRAGMENT) */
DEFINE_GUID(GUID_MelodyFragment, 0xb291c7f2, 0xb616, 0x11d2, 0x97, 0xfa, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Used to clear all melody fragments */
DEFINE_GUID(GUID_Clear_All_MelodyFragments, 0x8509fee6, 0xb617, 0x11d2, 0x97, 0xfa, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Used to get the variations currently in effect across PChannels */
DEFINE_GUID(GUID_Variations, 0x11f72cce, 0x26e6, 0x4ecd, 0xaf, 0x2e, 0xd6, 0x68, 0xe6, 0x67, 0x7, 0xd8);
typedef struct _DMUS_VARIATIONS_PARAM
{
    DWORD   dwPChannelsUsed; /* number of PChannels in use */
    DWORD*  padwPChannels;   /* array of PChannels in use */
    DWORD*  padwVariations;  /* array of variations in effect for each PChannel */
} DMUS_VARIATIONS_PARAM;

/* Download bands/waves for the IDirectMusicSegment, passed an IDirectMusicAudioPath instead of an IDirectMusicPerformance */
DEFINE_GUID(GUID_DownloadToAudioPath,0x9f2c0341, 0xc5c4, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/* Unload bands/waves for the IDirectMusicSegment, passed an IDirectMusicAudioPath instead of an IDirectMusicPerformance */
DEFINE_GUID(GUID_UnloadFromAudioPath,0x9f2c0342, 0xc5c4, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/* Set wave behavior: Streaming vs non streamed, preroll size, activate filter. */
DEFINE_GUID(GUID_WavePlayParams, 0x1162a3db, 0x2680, 0x4106, 0x8a, 0x66, 0x3a, 0xd4, 0xfa, 0xe7, 0xd9, 0xe6);


//@@END_MSINTERNAL


/* Global data guids */
DEFINE_GUID(GUID_PerfMasterTempo,0xd2ac28b0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterVolume,0xd2ac28b1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterGrooveLevel,0xd2ac28b2, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
//@@BEGIN_MSINTERNAL
//DEFINE_GUID(GUID_PerfAutoDownload, 0xfb09565b, 0x3631, 0x11d2, 0xbc, 0xb8, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* GUID to define default synth, placed in AudioPath configuration file. */
DEFINE_GUID(GUID_Synth_Default,0x26bb9432, 0x45fe, 0x48d3, 0xa3, 0x75, 0x24, 0x72, 0xc5, 0xe3, 0xe7, 0x86);
//@@END_MSINTERNAL

/* GUID for default GM/GS dls collection. */
DEFINE_GUID(GUID_DefaultGMCollection, 0xf17e8673, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

//@@BEGIN_MSINTERNAL
/* GUIDs to define default buffer configurations to place in AudioPath configuration file. */
DEFINE_GUID(GUID_Buffer_Reverb,0x186cc541, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_EnvReverb,0x186cc542, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_Stereo,0x186cc545, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_3D_Dry,0x186cc546, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_Mono,0x186cc547, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(GUID_Buffer_3D,0xdf61c19, 0xdea3, 0x4a91, 0xb8, 0x47, 0xb, 0x39, 0xb8, 0x44, 0x3c, 0x28);
DEFINE_GUID(GUID_Buffer_Chorus,0x97a8b60f, 0x63a6, 0x4f45, 0x84, 0x56, 0xee, 0x76, 0x41, 0xe1, 0xe4, 0x83);
DEFINE_GUID(GUID_Buffer_MixBins,0xc056971, 0x4efe, 0x4846, 0x8a, 0x3f, 0x44, 0xc4, 0xaa, 0x4c, 0x96, 0x17);
//@@END_MSINTERNAL

/* IID's */
DEFINE_GUID(IID_IDirectMusicLoader,0x4fdad3f6, 0xe642, 0x4a1b, 0x90, 0x28, 0x1c, 0x2f, 0xfd, 0x91, 0x5c, 0x2a);
DEFINE_GUID(IID_IDirectMusicSegment, 0x3fc8898, 0xac24, 0x4bb8, 0xaf, 0x2f, 0x6f, 0xba, 0xb6, 0x40, 0x8a, 0x8e);
DEFINE_GUID(IID_IDirectMusicSegmentState, 0xfbdf2f1d, 0x6378, 0x43ba, 0x97, 0x29, 0x4b, 0x74, 0xb1, 0xdb, 0x3b, 0xd5);
DEFINE_GUID(IID_IDirectMusicPerformance,0x37a8aa56, 0x79fd, 0x4fcc, 0x8b, 0x58, 0xd3, 0x9d, 0x75, 0x86, 0x1f, 0x3);
DEFINE_GUID(IID_IDirectMusicGraph,0x5ae1e2a9, 0x38d7, 0x42a2, 0x9d, 0x31, 0xa1, 0x9c, 0x9a, 0x93, 0x6a, 0x4a);
DEFINE_GUID(IID_IDirectMusicGetLoader,0xb0e1656f, 0x3e45, 0x418e, 0x9b, 0x2d, 0x34, 0xd5, 0x33, 0xd1, 0x77, 0xe1);
DEFINE_GUID(IID_IDirectMusicObject,0x632aee51, 0xb9d, 0x4ea4, 0x9b, 0x60, 0x23, 0xcc, 0x58, 0xf5, 0x56, 0x1e);
DEFINE_GUID(IID_IDirectMusicTool,0xe59eeefe, 0x7a62, 0x4ca7, 0x8b, 0x47, 0x1f, 0xdd, 0x72, 0x8f, 0xba, 0x57);
//@@BEGIN_MSINTERNAL
DEFINE_GUID(IID_IDirectMusicBand,0x70a433c2, 0x4637, 0x40e0, 0xb5, 0xa4, 0x1, 0x91, 0x1c, 0x95, 0xaa, 0x2c);
DEFINE_GUID(IID_IDirectMusicStyle,0x865d0e99, 0xada1, 0x4b4d, 0xb4, 0x8f, 0x48, 0x86, 0xd5, 0xce, 0xbf, 0x99);
DEFINE_GUID(IID_IDirectMusicChordMap,0xd4d1e9c7, 0xeefc, 0x4edb, 0x9a, 0x62, 0x13, 0xd8, 0xe, 0x8e, 0x43, 0x83);
DEFINE_GUID(IID_IDirectMusicComposer,0xe4eae325, 0x8530, 0x4c81, 0xab, 0x26, 0x2, 0x50, 0x5c, 0x28, 0x2, 0x22);

/* Alternate interface IDs, available in DX7 release and after. */
//DEFINE_GUID(IID_IDirectMusicPerformance2,0x6fc2cae0, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
//DEFINE_GUID(IID_IDirectMusicSegment2, 0xd38894d1, 0xc052, 0x11d2, 0x87, 0x2f, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* new interfaces (GUID + alias) */
DEFINE_GUID(IID_IDirectMusicPatternTrack, 0x51c22e10, 0xb49f, 0x46fc, 0xbe, 0xc2, 0xe6, 0x28, 0x8f, 0xb9, 0xed, 0xe6);
#define IID_IDirectMusicPatternTrack8 IID_IDirectMusicPatternTrack
//@@END_MSINTERNAL
DEFINE_GUID(IID_IDirectMusicScript, 0x801413c2, 0x392, 0x4265, 0xb3, 0x1a, 0x13, 0xd, 0x7, 0xdf, 0x31, 0xd0);
#define IID_IDirectMusicScript8 IID_IDirectMusicScript
//@@BEGIN_MSINTERNAL
DEFINE_GUID(IID_IDirectMusicContainer, 0xed6f38a0, 0xdd4f, 0x4177, 0x97, 0xbf, 0x5e, 0xbd, 0x77, 0x54, 0x1a, 0x9d);
#define IID_IDirectMusicContainer8 IID_IDirectMusicContainer
DEFINE_GUID(IID_IDirectMusicSong, 0x81e2115c, 0x6901, 0x492b, 0xa9, 0xc9, 0x58, 0x39, 0x2a, 0x19, 0x4f, 0xcf);
#define IID_IDirectMusicSong8 IID_IDirectMusicSong
//@@END_MSINTERNAL
DEFINE_GUID(IID_IDirectMusicAudioPath,0x242ed927, 0xf094, 0x42e4, 0x9b, 0xb9, 0x52, 0xd2, 0x14, 0x19, 0x94, 0x4a);
#define IID_IDirectMusicAudioPath8 IID_IDirectMusicAudioPath
/* unchanged interfaces (alias only) */
//@@BEGIN_MSINTERNAL
#define IID_IDirectMusicStyle8 IID_IDirectMusicStyle
#define IID_IDirectMusicGetLoader8 IID_IDirectMusicGetLoader
#define IID_IDirectMusicObject8 IID_IDirectMusicObject
#define IID_IDirectMusicChordMap8 IID_IDirectMusicChordMap
#define IID_IDirectMusicComposer8 IID_IDirectMusicComposer
#define IID_IDirectMusicBand8 IID_IDirectMusicBand
//@@END_MSINTERNAL
#define IID_IDirectMusicGraph8 IID_IDirectMusicGraph
#define IID_IDirectMusicLoader8 IID_IDirectMusicLoader
#define IID_IDirectMusicPerformance8 IID_IDirectMusicPerformance
#define IID_IDirectMusicSegment8 IID_IDirectMusicSegment
#define IID_IDirectMusicSegmentState8 IID_IDirectMusicSegmentState

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

HRESULT WINAPI DirectMusicCreateInstance(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface);
void WINAPI DirectMusicDoWork(DWORD dwQuantum);

typedef HRESULT (CALLBACK* LPDIRECTMUSICFACTORYFN)(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface);
HRESULT CALLBACK DirectMusicDefaultFactory(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface);

#undef  INTERFACE
#define INTERFACE  IDirectMusicHeap
DECLARE_INTERFACE_(IDirectMusicHeap, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD cbSize, PVOID* pData) PURE;
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize) PURE;
    STDMETHOD(Free)   (THIS_ PVOID pData) PURE;
};

void* WINAPI DirectMusicAlloc(size_t cb);
void  WINAPI DirectMusicFree(void *pv);
void* WINAPI DirectMusicPhysicalAlloc(size_t dwSize);
void WINAPI DirectMusicPhysicalFree(void* lpAddress);

HRESULT WINAPI DirectMusicCreateDefaultHeap(IDirectMusicHeap** ppHeap);
HRESULT WINAPI DirectMusicCreateDefaultPhysicalHeap(IDirectMusicHeap** ppHeap);

HRESULT WINAPI DirectMusicCreateFixedSizeHeap(DWORD cbSize, IDirectMusicHeap** ppHeap);
HRESULT WINAPI DirectMusicCreateFixedSizePhysicalHeap(DWORD cbSize, IDirectMusicHeap** ppHeap);

HRESULT WINAPI DirectMusicInitialize();
HRESULT WINAPI DirectMusicInitializeEx(IDirectMusicHeap* pNormalHeap, 
    IDirectMusicHeap* pPhysicalHeap,
    LPDIRECTMUSICFACTORYFN pFactory);
HRESULT WINAPI DirectMusicInitializeFixedSizeHeaps(DWORD cbNormalHeapSize, 
    DWORD cbPhysicalHeapSize,
    LPDIRECTMUSICFACTORYFN pFactory);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

long WINAPI DirectMusicMemCheck(DWORD dwMemType, char **ppName);
void WINAPI DirectMusicMemDump();
void WINAPI DirectMusicSetDebugLevel(int iDebugLevel, int iRIPLevel);

#endif /* #ifndef _DMUSICI_ */

/************************************************************************
*                                                                       *
*   dmerror.h -- Error code returned by DirectMusic API's               *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif
    
#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */
#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

//@@BEGIN_MSINTERNAL
#define DMUS_S_STRING_TRUNCATED         S_OK
//@@END_MSINTERNAL
/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that no note has been calculated because the music value has the note 
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is below 0, 
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is above 127, 
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)

//@@BEGIN_MSINTERNAL
#define DMUS_S_NOBUFFERCONTROL          MAKE_DMHRESULTSUCCESS(0x215)
//@@END_MSINTERNAL

/* DMUS_S_GARBAGE_COLLECTED
 *
 * The requested operation was not performed because during CollectGarbage
 * the loader determined that the object had been released.
 */
#define DMUS_S_GARBAGE_COLLECTED        MAKE_DMHRESULTSUCCESS(0x216)

//@@BEGIN_MSINTERNAL
#define DMUS_E_DRIVER_FAILED            E_FAIL
#define DMUS_E_PORTS_OPEN               E_FAIL
#define DMUS_E_DEVICE_IN_USE            E_FAIL
#define DMUS_E_INSUFFICIENTBUFFER       E_FAIL
#define DMUS_E_BUFFERNOTSET             E_FAIL
#define DMUS_E_BUFFERNOTAVAILABLE       E_FAIL
#define DMUS_E_NOTADLSCOL               E_FAIL
#define DMUS_E_INVALIDOFFSET            E_FAIL
#define DMUS_E_ALREADY_LOADED           E_FAIL
#define DMUS_E_INVALIDPOS               E_FAIL
#define DMUS_E_INVALIDPATCH             E_FAIL
#define DMUS_E_CANNOTSEEK               E_FAIL
#define DMUS_E_CANNOTWRITE              E_FAIL
#define DMUS_E_CHUNKNOTFOUND            E_FAIL
#define DMUS_E_INVALID_DOWNLOADID       E_FAIL
#define DMUS_E_NOT_DOWNLOADED_TO_PORT   E_FAIL
#define DMUS_E_ALREADY_DOWNLOADED       E_FAIL
#define DMUS_E_UNKNOWN_PROPERTY         E_FAIL
//@@END_MSINTERNAL

/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */ 
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)

//@@BEGIN_MSINTERNAL
#define DMUS_E_NOTMONO                  E_FAIL
#define DMUS_E_BADARTICULATION          E_FAIL
#define DMUS_E_BADINSTRUMENT            E_FAIL
#define DMUS_E_BADWAVELINK              E_FAIL
#define DMUS_E_NOARTICULATION           E_FAIL
#define DMUS_E_NOTPCM                   E_FAIL
#define DMUS_E_BADWAVE                  E_FAIL
#define DMUS_E_BADOFFSETTABLE           E_FAIL
#define DMUS_E_UNKNOWNDOWNLOAD          E_FAIL
#define DMUS_E_NOSYNTHSINK              E_FAIL
#define DMUS_E_ALREADYOPEN              E_FAIL 
#define DMUS_E_ALREADYCLOSED            E_FAIL 
#define DMUS_E_SYNTHNOTCONFIGURED       E_FAIL 
#define DMUS_E_SYNTHACTIVE              E_FAIL 
#define DMUS_E_CANNOTREAD               E_FAIL 
#define DMUS_E_DMUSIC_RELEASED          E_FAIL 
#define DMUS_E_BUFFER_EMPTY             E_FAIL 
#define DMUS_E_BUFFER_FULL              E_FAIL 
#define DMUS_E_PORT_NOT_CAPTURE         E_FAIL 
#define DMUS_E_PORT_NOT_RENDER          E_FAIL 
#define DMUS_E_DSOUND_NOT_SET           E_FAIL 
#define DMUS_E_ALREADY_ACTIVATED        E_FAIL 
#define DMUS_E_INVALIDBUFFER            E_FAIL 
#define DMUS_E_WAVEFORMATNOTSUPPORTED   E_FAIL 
#define DMUS_E_SYNTHINACTIVE            E_FAIL 
#define DMUS_E_DSOUND_ALREADY_SET       E_FAIL 
#define DMUS_E_INVALID_EVENT            E_FAIL 
#define DMUS_E_UNSUPPORTED_STREAM       E_FAIL 
#define DMUS_E_ALREADY_INITED           E_FAIL 
#define DMUS_E_INVALID_BAND             E_FAIL 
#define DMUS_E_TRACK_HDR_NOT_FIRST_CK   E_FAIL 
#define DMUS_E_TOOL_HDR_NOT_FIRST_CK    E_FAIL 
#define DMUS_E_INVALID_TRACK_HDR        E_FAIL 
#define DMUS_E_INVALID_TOOL_HDR         E_FAIL 
#define DMUS_E_ALL_TOOLS_FAILED         E_FAIL 
#define DMUS_E_ALL_TRACKS_FAILED        E_FAIL 
//@@END_MSINTERNAL

/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)

//@@BEGIN_MSINTERNAL
#define DMUS_E_TYPE_DISABLED            E_FAIL 
#define DMUS_E_TYPE_UNSUPPORTED         E_FAIL 
//@@END_MSINTERNAL

/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)
//@@BEGIN_MSINTERNAL
#define DMUS_E_TRACK_NOT_FOUND			E_FAIL 
#define DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT   E_FAIL 
#define DMUS_E_NO_MASTER_CLOCK          E_FAIL 
#define DMUS_E_LOADER_NOCLASSID         E_FAIL 
#define DMUS_E_LOADER_BADPATH           E_FAIL 
#define DMUS_E_LOADER_FAILEDOPEN        E_FAIL 
#define DMUS_E_LOADER_FORMATNOTSUPPORTED    E_FAIL 
//@@END_MSINTERNAL

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)
//@@BEGIN_MSINTERNAL
#define DMUS_E_LOADER_NOFILENAME	    E_FAIL 
//@@END_MSINTERNAL

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200) 
//@@BEGIN_MSINTERNAL
#define DMUS_E_ALREADY_EXISTS           E_FAIL 
#define DMUS_E_OUT_OF_RANGE             E_FAIL 
#define DMUS_E_SEGMENT_INIT_FAILED      E_FAIL 
#define DMUS_E_ALREADY_SENT             E_FAIL 
#define DMUS_E_CANNOT_FREE              E_FAIL 
#define DMUS_E_CANNOT_OPEN_PORT         E_FAIL 
//@@END_MSINTERNAL

/* DMUS_E_CANNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CANNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)
//@@BEGIN_MSINTERNAL
#define DMUS_E_DESCEND_CHUNK_FAIL       E_FAIL 
#define DMUS_E_NOT_LOADED               E_FAIL 
#define DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE  E_FAIL 
#define DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE    E_FAIL 
//@@END_MSINTERNAL

/* DMUS_E_SCRIPT_ERROR_IN_SCRIPT
 *
 * An error was encountered while parsing or executing the script.
 * The pErrorInfo parameter (if supplied) was filled with information about the error.
 */
#define DMUS_E_SCRIPT_ERROR_IN_SCRIPT        MAKE_DMHRESULTERROR(0x0215)
//@@BEGIN_MSINTERNAL
#define DMUS_E_SCRIPT_CANTLOAD_OLEAUT32      E_FAIL 
#define DMUS_E_SCRIPT_LOADSCRIPT_ERROR       E_FAIL 
#define DMUS_E_SCRIPT_INVALID_FILE           E_FAIL 
#define DMUS_E_INVALID_SCRIPTTRACK           E_FAIL 
//@@END_MSINTERNAL

/* DMUS_E_SCRIPT_VARIABLE_NOT_FOUND
 *
 * The script does not contain a variable with the specified name.
 */
#define DMUS_E_SCRIPT_VARIABLE_NOT_FOUND     MAKE_DMHRESULTERROR(0x021A)

/* DMUS_E_SCRIPT_ROUTINE_NOT_FOUND
 *
 * The script does not contain a routine with the specified name.
 */
#define DMUS_E_SCRIPT_ROUTINE_NOT_FOUND      MAKE_DMHRESULTERROR(0x021B)

/* DMUS_E_SCRIPT_CONTENT_READONLY
 *
 * Scripts variables for content referenced or embedded in a script cannot be set.
 */
#define DMUS_E_SCRIPT_CONTENT_READONLY       MAKE_DMHRESULTERROR(0x021C)

/* DMUS_E_SCRIPT_NOT_A_REFERENCE
 *
 * Attempt was made to set a script's variable by reference to a value that was
 * not an object type.
 */
#define DMUS_E_SCRIPT_NOT_A_REFERENCE        MAKE_DMHRESULTERROR(0x021D)

/* DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED
 *
 * Attempt was made to set a script's variable by value to an object that does
 * not support a default value property.
 */
#define DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED    MAKE_DMHRESULTERROR(0x021E)

//@@BEGIN_MSINTERNAL
#define DMUS_E_INVALID_SEGMENTTRIGGERTRACK   E_FAIL 
#define DMUS_E_INVALID_LYRICSTRACK           E_FAIL 
#define DMUS_E_INVALID_PARAMCONTROLTRACK     E_FAIL 
//@@END_MSINTERNAL

/* DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR
 *
 * A script written in AudioVBScript could not be read because it contained a statement that
 * is not allowed by the AudioVBScript language.
 */
#define DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR     MAKE_DMHRESULTERROR(0x0223)

/* DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR
 *
 * A script routine written in AudioVBScript failed because an invalid operation occurred.  For example,
 * adding the number 3 to a segment object would produce this error.  So would attempting to call a routine
 * that doesn't exist.
 */
#define DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR     MAKE_DMHRESULTERROR(0x0224)

/* DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE
 *
 * A script routine written in AudioVBScript failed because a function outside of a script failed to complete.
 * For example, a call to PlaySegment that fails to play because of low memory would return this error.
 */
#define DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE     MAKE_DMHRESULTERROR(0x0225)
//@@BEGIN_MSINTERNAL
#define DMUS_E_AUDIOPATHS_NOT_VALID     E_FAIL 
#define DMUS_E_AUDIOPATHS_IN_USE     E_FAIL 
//@@END_MSINTERNAL

/* DMUS_E_NO_AUDIOPATH_CONFIG
 *
 * A segment or song was asked for its embedded audio path configuration,
 * but there isn't any. 
 */
#define DMUS_E_NO_AUDIOPATH_CONFIG     MAKE_DMHRESULTERROR(0x0228)
//@@BEGIN_MSINTERNAL
#define DMUS_E_AUDIOPATH_INACTIVE     E_FAIL 
#define DMUS_E_AUDIOPATH_NOBUFFER     E_FAIL 
#define DMUS_E_AUDIOPATH_NOPORT     E_FAIL 
#define DMUS_E_NO_AUDIOPATH     E_FAIL 
#define DMUS_E_INVALIDCHUNK     E_FAIL 
#define DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER     E_FAIL 
#define DMUS_E_INVALID_CONTAINER_OBJECT    E_FAIL 
//@@END_MSINTERNAL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dpaddrp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpaddr.h
 *  Content:   DirectPlayAddress include file
//@@BEGIN_MSINTERNAL
 *  History:
 *  Date        By      Reason
 *  ==========================
 *  01/31/2000  rmt     created
 *  02/12/2000  rmt     Split Get into GetByIndex and GetByName
 *  02/14/2000  vpo     Hid remaining references to Internal
 *  02/17/2000  rmt     Added dnet header def and removed error codes (see dplay8.h for error codes for them)
 *  02/21/2000  rmt     Cleared out redundant interfaces, added defines, added new macros
 *  03/22/2000  rmt     Updated to add SetEqual, BuildFromDPAddress and new ANSI data type
 *  03/24/2000  rmt     Added IsEqual function
 *  05/04/2000  rmt     Bug #34155 - Incorrect defines
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *  08/03/2000  rmt     Bug #41246 - Remove IP versions of Duplicate, SetEqual, IsEqual, BuildURL
 *  08/07/2000  rmt     Bug #41185 - Header Cleanup
//@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DIRECTPLAYADDRESS__
#define __DIRECTPLAYADDRESS__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//@@BEGIN_MSINTERNAL
#include <dplay8p.h>
//@@END_MSINTERNAL
#include <dplay8.h>


/****************************************************************************
 *
 * DirectPlay8Address Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDirectPlay8Address IDirectPlay8Address;
typedef IDirectPlay8Address         *PDIRECTPLAY8ADDRESS, *LPDIRECTPLAY8ADDRESS;

/****************************************************************************
 *
 * DirectPlay8Address Forward Declarations For External Types
 *
 ****************************************************************************/

typedef struct sockaddr SOCKADDR;

/****************************************************************************
 *
 * DirectPlay8Address Constants
 *
 ****************************************************************************/
//
// Asynchronous operation flags
//
#define DPNA_DATATYPE_STRING                0x00000001
#define DPNA_DATATYPE_DWORD                 0x00000002
#define DPNA_DATATYPE_GUID                  0x00000003
#define DPNA_DATATYPE_BINARY                0x00000004
#define DPNA_DATATYPE_STRING_ANSI           0x00000005

#define DPNA_INDEX_INVALID                  0xFFFFFFFF

/****************************************************************************
 *
 * DirectPlay8Address Address Elements
 *
 ****************************************************************************/

#define DPNA_DPNSVR_PORT                                      6073

#define DPNA_SEPARATOR_KEYVALUE             L'='
#define DPNA_SEPARATOR_USERDATA             L'#'
#define DPNA_SEPARATOR_COMPONENT            L';'
#define DPNA_ESCAPECHAR                     L'%'

// Header
#define DPNA_HEADER                         L"x-directplay:/"

// key names for address components
#define DPNA_KEY_APPLICATION_INSTANCE       L"applicationinstance"
#define DPNA_KEY_BAUD                       L"baud"
#define DPNA_KEY_DEVICE                     L"device"
#define DPNA_KEY_FLOWCONTROL                L"flowcontrol"
#define DPNA_KEY_HOSTNAME                   L"hostname"
#define DPNA_KEY_PARITY                     L"parity"
#define DPNA_KEY_PHONENUMBER                L"phonenumber"
#define DPNA_KEY_PORT                       L"port"
#define DPNA_KEY_PROGRAM                    L"program"
#define DPNA_KEY_PROVIDER                   L"provider"
#define DPNA_KEY_STOPBITS                   L"stopbits"

//// ANSI DEFINITIONS

// Header
#define DPNA_HEADER_A                       "x-directplay:/"
#define DPNA_SEPARATOR_KEYVALUE_A           '='
#define DPNA_SEPARATOR_USERDATA_A           '#'
#define DPNA_SEPARATOR_COMPONENT_A          ';'
#define DPNA_ESCAPECHAR_A                   '%'

// key names for address components
#define DPNA_KEY_APPLICATION_INSTANCE_A     "applicationinstance"
#define DPNA_KEY_BAUD_A                     "baud"
#define DPNA_KEY_DEVICE_A                   "device"
#define DPNA_KEY_FLOWCONTROL_A              "flowcontrol"
#define DPNA_KEY_HOSTNAME_A                 "hostname"
#define DPNA_KEY_PARITY_A                   "parity"
#define DPNA_KEY_PHONENUMBER_A              "phonenumber"
#define DPNA_KEY_PORT_A                     "port"
#define DPNA_KEY_PROGRAM_A                  "program"
#define DPNA_KEY_PROVIDER_A                 "provider"
#define DPNA_KEY_STOPBITS_A                 "stopbits"

// Shortcut values
//
// These can be used instead of the corresponding CLSID_DP8SP_XXXX guids
//
#define DPNA_VALUE_TCPIPPROVIDER            L"IP"
#define DPNA_VALUE_TCPIPPROVIDER_A            "IP"

#define IID_IDirectPlay8Address		0
#define IID_IDirectPlay8AddressIP	1

/****************************************************************************
 *
 * DirectPlay8Address Functions
 *
 ****************************************************************************/

extern HRESULT WINAPI DirectPlay8AddressCreate( DWORD dwIID, void ** ppvInterface, void **pUnknown);

/****************************************************************************
 *
 * DirectPlay8Address Application Interfaces
 *
 ****************************************************************************/

// IUnknown methods
ULONG WINAPI IDirectPlay8Address_AddRef(LPDIRECTPLAY8ADDRESS pDirectPlay8Address);
ULONG WINAPI IDirectPlay8Address_Release(LPDIRECTPLAY8ADDRESS pDirectPlay8Address);

// IDirectPlay8Address methods
HRESULT WINAPI IDirectPlay8Address_BuildFromURLW(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, WCHAR *pwszSourceURL);
HRESULT WINAPI IDirectPlay8Address_BuildFromURLA(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, CHAR *pszSourceURL);
HRESULT WINAPI IDirectPlay8Address_Duplicate(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, PDIRECTPLAY8ADDRESS *ppdpaNewAddress);
HRESULT WINAPI IDirectPlay8Address_SetEqual(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, PDIRECTPLAY8ADDRESS pdpaAddress);
HRESULT WINAPI IDirectPlay8Address_IsEqual(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, PDIRECTPLAY8ADDRESS pdpaAddress);
HRESULT WINAPI IDirectPlay8Address_Clear(LPDIRECTPLAY8ADDRESS pDirectPlay8Address);
HRESULT WINAPI IDirectPlay8Address_GetURLW(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, WCHAR *pwszURL, PDWORD pdwNumChars);
HRESULT WINAPI IDirectPlay8Address_GetURLA(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, CHAR *pszURL, PDWORD pdwNumChars);
HRESULT WINAPI IDirectPlay8Address_GetSP(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, GUID *pguidSP);
HRESULT WINAPI IDirectPlay8Address_GetUserData(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, void *pvUserData, PDWORD pdwBufferSize);
HRESULT WINAPI IDirectPlay8Address_SetSP(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const GUID *const pguidSP);
HRESULT WINAPI IDirectPlay8Address_SetUserData(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const void * const pvUserData, const DWORD dwDataSize);
HRESULT WINAPI IDirectPlay8Address_GetNumComponents(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, PDWORD pdwNumComponents);
HRESULT WINAPI IDirectPlay8Address_GetComponentByName(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const WCHAR * const pwszName, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType);
HRESULT WINAPI IDirectPlay8Address_GetComponentByIndex(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const DWORD dwComponentID, WCHAR * pwszName, PDWORD pdwNameLen, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType);
HRESULT WINAPI IDirectPlay8Address_AddComponent(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const WCHAR * const pwszName, const void * const lpvData, const DWORD dwDataSize, const DWORD dwDataType);
HRESULT WINAPI IDirectPlay8Address_GetDevice(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, GUID *pGUID);
HRESULT WINAPI IDirectPlay8Address_SetDevice(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const GUID * const pGUID);
HRESULT WINAPI IDirectPlay8Address_BuildFromSockAddr(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const SOCKADDR * const pSockAddr);
HRESULT WINAPI IDirectPlay8Address_BuildAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const WCHAR * const wszAddress, const USHORT usPort);
HRESULT WINAPI IDirectPlay8Address_BuildLocalAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const GUID * const pguidAdapter, const USHORT usPort);
HRESULT WINAPI IDirectPlay8Address_GetSockAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, SOCKADDR *pSockAddr, PDWORD pDword);
HRESULT WINAPI IDirectPlay8Address_GetLocalAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, GUID *pguidAdapter, USHORT *pusPort);
HRESULT WINAPI IDirectPlay8Address_GetAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, WCHAR *wszAddress, PDWORD pdwAddressLength, USHORT *psPort);
//@@BEGIN_MSINTERNAL
HRESULT WINAPI IDirectPlay8Address_Lock(LPDIRECTPLAY8ADDRESS pDirectPlay8Address);
HRESULT WINAPI IDirectPlay8Address_UnLock(LPDIRECTPLAY8ADDRESS pDirectPlay8Address);
//@@END_MSINTERNAL

#ifdef __cplusplus

// IDirectPlay8Address wrapper class
struct IDirectPlay8Address
{
    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlay8Address_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlay8Address_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE QueryInterface(DWORD riid, LPVOID *ppvObj)
    {
	if (ppvObj != NULL)
            *ppvObj = this;

        return S_OK;
    }

    __inline HRESULT STDMETHODCALLTYPE BuildFromURLW(WCHAR *pwszSourceURL)
    {
        return IDirectPlay8Address_BuildFromURLW(this, pwszSourceURL);
    }

    __inline HRESULT STDMETHODCALLTYPE BuildFromURLA(CHAR *pszSourceURL)
    {
        return IDirectPlay8Address_BuildFromURLA(this, pszSourceURL);
    }

    __inline HRESULT STDMETHODCALLTYPE Duplicate(PDIRECTPLAY8ADDRESS *ppdpaNewAddress)
    {
        return IDirectPlay8Address_Duplicate(this, ppdpaNewAddress);
    }

    __inline HRESULT STDMETHODCALLTYPE SetEqual(PDIRECTPLAY8ADDRESS pdpaAddress)
    {
        return IDirectPlay8Address_SetEqual(this, pdpaAddress);
    }

    __inline HRESULT STDMETHODCALLTYPE IsEqual(PDIRECTPLAY8ADDRESS pdpaAddress)
    {
        return IDirectPlay8Address_IsEqual(this, pdpaAddress);
    }

    __inline HRESULT STDMETHODCALLTYPE Clear(void)
    {
        return IDirectPlay8Address_Clear(this);
    }

    __inline HRESULT STDMETHODCALLTYPE GetURLW(WCHAR *pwszURL, PDWORD pdwNumChars)
    {
        return IDirectPlay8Address_GetURLW(this, pwszURL, pdwNumChars);
    }

    __inline HRESULT STDMETHODCALLTYPE GetURLA(CHAR *pszURL, PDWORD pdwNumChars)
    {
        return IDirectPlay8Address_GetURLA(this, pszURL, pdwNumChars);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSP(GUID *pguidSP)
    {
        return IDirectPlay8Address_GetSP(this, pguidSP);
    }

    __inline HRESULT STDMETHODCALLTYPE GetUserData(void *pvUserData, PDWORD pdwBufferSize)
    {
        return IDirectPlay8Address_GetUserData(this, pvUserData, pdwBufferSize);
    }

    __inline HRESULT STDMETHODCALLTYPE SetSP(const GUID *const pguidSP)
    {
        return IDirectPlay8Address_SetSP(this, pguidSP);
    }

    __inline HRESULT STDMETHODCALLTYPE SetUserData(const void * const pvUserData, const DWORD dwDataSize)
    {
        return IDirectPlay8Address_SetUserData(this, pvUserData, dwDataSize);
    }

    __inline HRESULT STDMETHODCALLTYPE GetNumComponents(PDWORD pdwNumComponents)
    {
        return IDirectPlay8Address_GetNumComponents(this, pdwNumComponents);
    }

    __inline HRESULT STDMETHODCALLTYPE GetComponentByName(const WCHAR * const pwszName, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType)
    {
        return IDirectPlay8Address_GetComponentByName(this, pwszName, pvBuffer, pdwBufferSize, pdwDataType);
    }

    __inline HRESULT STDMETHODCALLTYPE GetComponentByIndex(const DWORD dwComponentID, WCHAR * pwszName, PDWORD pdwNameLen, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType)
    {
        return IDirectPlay8Address_GetComponentByIndex(this, dwComponentID, pwszName, pdwNameLen, pvBuffer, pdwBufferSize, pdwDataType);
    }

    __inline HRESULT STDMETHODCALLTYPE AddComponent(const WCHAR * const pwszName, const void * const lpvData, const DWORD dwDataSize, const DWORD dwDataType)
    {
        return IDirectPlay8Address_AddComponent(this, pwszName, lpvData, dwDataSize, dwDataType);
    }

    __inline HRESULT STDMETHODCALLTYPE GetDevice(GUID *pGUID)
    {
        return IDirectPlay8Address_GetDevice(this, pGUID);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDevice(const GUID * const pGUID)
    {
        return IDirectPlay8Address_SetDevice(this, pGUID);
    }

    // Constructs a IDirectPlay8 TCP Address from a SOCKADDR structure
    __inline HRESULT STDMETHODCALLTYPE BuildFromSockAddr(const SOCKADDR * const pSockAddr)
    {
        return IDirectPlay8Address_BuildFromSockAddr(this, pSockAddr);
    }

    // Constructs a TCP Address from a string (hostname) and port
    __inline HRESULT STDMETHODCALLTYPE BuildAddress(const WCHAR * const wszAddress, const USHORT usPort)
    {
        return IDirectPlay8Address_BuildAddress(this, wszAddress, usPort);
    }

    // Builds a local TCP Address
    __inline HRESULT STDMETHODCALLTYPE BuildLocalAddress(const GUID * const pguidAdapter, const USHORT usPort)
    {
        return IDirectPlay8Address_BuildLocalAddress(this, pguidAdapter, usPort);
    }

    // Gets the address from the structure in SOCKADR format
    __inline HRESULT STDMETHODCALLTYPE GetSockAddress(SOCKADDR *pSockAddr, PDWORD pDword)
    {
        return IDirectPlay8Address_GetSockAddress(this, pSockAddr, pDword);
    }

    // Gets the local afddress
    __inline HRESULT STDMETHODCALLTYPE GetLocalAddress(GUID *pguidAdapter, USHORT *pusPort)
    {
        return IDirectPlay8Address_GetLocalAddress(this, pguidAdapter, pusPort);
    }

    // Gets the remote address
    __inline HRESULT STDMETHODCALLTYPE GetAddress(WCHAR *wszAddress, PDWORD pdwAddressLength, USHORT *psPort)
    {
        return IDirectPlay8Address_GetAddress(this, wszAddress, pdwAddressLength, psPort);
    }

//@@BEGIN_MSINTERNAL
    // Used by SP or DNet to mark this object read-only.  Only GetXXX funcs will work
    __inline HRESULT STDMETHODCALLTYPE Lock(void)
    {
        return IDirectPlay8Address_Lock(this);
    }

    // Used by SP or DNet to mark this object read-write.  All funcs will work.
    __inline HRESULT STDMETHODCALLTYPE UnLock(void)
    {
        return IDirectPlay8Address_UnLock(this);
    }
//@@END_MSINTERNAL
};

#endif // __cplusplus

#ifdef __cplusplus
}
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dpsp8p.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DPSP8.h
 *  Content:	Service provider include file
 *  History:
 *	Date   By  Reason
 *	============
 *	10/12/98	jwo		created
 *	03/22/2000	jtk		Changed interface names
 *	05/16/2000	jtk		Derived from DNSP.h
 ***************************************************************************/

#ifndef __DIRECT_PLAY_SERVICE_PROVIDER_8__
#define __DIRECT_PLAY_SERVICE_PROVIDER_8__

#include <dplay8p.h>
#include <dpaddrp.h>
#include <xobjbase.h>

#ifdef __cplusplus
extern "C" {
#endif



//**********************************************************************
// Constant definitions
//**********************************************************************

//
// Enumerated values for service provider events
//
typedef	enum _SP_EVENT_TYPE
{
	SPEV_UNKNOWN = 0,
	SPEV_DATA,
	SPEV_CONNECT,
	SPEV_DISCONNECT,
	SPEV_ENUMQUERY,
	SPEV_QUERYRESPONSE,
	SPEV_LISTENSTATUS,
	SPEV_LISTENADDRESSINFO,
	SPEV_ENUMADDRESSINFO,
	SPEV_CONNECTADDRESSINFO

} SP_EVENT_TYPE;

/* Flags */

#define DPNSPF_OKTOSHOWSTATUS		0x00000001		// OK for SP to show status windows
#define DPNSPF_RELIABLE				0x00000004		// reliable delivery/connection
#define DPNSPF_UNRELIABLE			0x00000008		// unreliable delivery/connection
#define	DPNSPF_NOBROADCASTFALLBACK	0x00000010		// don't allow SP to fallback to broadcast with insufficient information
													// (only if the SP supports broadcast)
#define	DPNSPF_BINDLISTENTOGATEWAY	0x00000020		// when performing a 'listen' attempt create a mapping between the local
													// 'port' to the same 'port' on the network 'gateway'.

//
// flags for joining groups
//
#define	SP_ADD_TO_MULTICAST_GROUP_RECEIVE	0x00000001
#define	SP_ADD_TO_MULTICAST_GROUP_SEND		0x00000002

//
// flags for getting address information
//
typedef	enum
{
	SP_GET_ADDRESS_INFO_LOCAL_ADAPTER = 0x00000001,			// local adapter address
	SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES,				// local adapter address (in 'host' form to be passed to connect/enum)
	SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS,			// local adapter address as mapped on the 'gateway' (in 'host' form for connect/enum)
	SP_GET_ADDRESS_INFO_REMOTE_HOST							// address of other end of an endpoint (in 'host' form to be passed to connect/enum)
} SP_GET_ADDRESS_INFO_FLAGS;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// data received from the SP
//
typedef	struct	_SPRECEIVEDBUFFER
{
	_SPRECEIVEDBUFFER	*pNext;						// link to next item in list
	DWORD				dwProtocolData;				// reserved for protocol
	PVOID				pServiceProviderDescriptor;	// reserved for protocol
	BUFFERDESC			BufferDesc;					// received buffer description

} SPRECEIVEDBUFFER, *PSPRECEIVEDBUFFER;

//
// connect indication
//
typedef struct	_SPIE_CONNECT
{	
	HANDLE	hEndpoint;			// handle of the new endpoint
	void	*pEndpointContext;	// user context associated with this endpoint
	void	*pCommandContext;	// user context for associated command

} SPIE_CONNECT, *PSPIE_CONNECT;

//
// disconnect indication
//
typedef	struct	_SPIE_DISCONNECT
{
	HANDLE	hEndpoint;			// handle of endpoint being disconnected
	void	*pEndpointContext;	// user context associated with this endpoint

} SPIE_DISCONNECT, *PSPIE_DISCONNECT;

//
// user data indication
//
typedef struct _SPIE_DATA
{
	HANDLE				hEndpoint;			// EP from which this data was received
	void				*pEndpointContext;	// user context associated with this endpoint
	SPRECEIVEDBUFFER	*pReceivedData;		// pointer to received data

} SPIE_DATA, *PSPIE_DATA;

//
// enum data indication
//
typedef struct _SPIE_QUERY
{
	IDirectPlay8Address	*pAddressSender;		// address from which the query came (may be NULL)
	IDirectPlay8Address	*pAddressDevice;		// address of device on which query was received
	SPRECEIVEDBUFFER	*pReceivedData;			// pointer to received data
	void				*pUserContext;			// user context passed into listen command

} SPIE_QUERY, *PSPIE_QUERY;

//
// enum response data indication
//
typedef	struct	_SPIE_QUERYRESPONSE
{
	IDirectPlay8Address		*pAddressSender;		// address from which the query came (may be NULL)
	IDirectPlay8Address		*pAddressDevice;		// address of device on which query response was received
	SPRECEIVEDBUFFER		*pReceivedData;			// pointer to received data
	DWORD					dwRoundTripTime;		// round trip time for enum (milliseconds)
	void					*pUserContext;			// user context passed into enum command
} SPIE_QUERYRESPONSE, *PSPIE_QUERYRESPONSE;


//
// event sent to indicate status of 'listen' on an adapter
//
typedef	struct	_SPIE_LISTENSTATUS
{
	GUID		ListenAdapter;		// adapter GUID
	HRESULT		hResult;			// result of listen
	HANDLE		hCommand;			// handle of associated command
	void		*pUserContext;		// user context passed into command
	HANDLE		hEndpoint;			// handle of endpoint associated with this listen
} SPIE_LISTENSTATUS, *PSPIE_LISTENSTATUS;


//
// event sent to indicate address info for 'listen' on an adapter
//
typedef	struct	_SPIE_LISTENADDRESSINFO
{
	IDirectPlay8Address		*pDeviceAddress;		// device address used to complete this command
	HRESULT					hCommandStatus;			// command status
	void					*pCommandContext;		// command context
} SPIE_LISTENADDRESSINFO, *PSPIE_LISTENADDRESSINFO;


//
// event sent to indicate address info for 'enum' on an adapter
//
typedef	struct	_SPIE_ENUMADDRESSINFO
{
	IDirectPlay8Address		*pHostAddress;			// host address used to complete this command
	IDirectPlay8Address		*pDeviceAddress;		// device address used to complete this command
	HRESULT					hCommandStatus;			// command status
	void					*pCommandContext;		// command context
} SPIE_ENUMADDRESSINFO, *PSPIE_ENUMADDRESSINFO;


//
// event sent to indicate status of 'connect' on an adapter
//
typedef	struct	_SPIE_CONNECTADDRESSINFO
{
	IDirectPlay8Address		*pHostAddress;			// host address used to complete this command
	IDirectPlay8Address		*pDeviceAddress;		// device address used to complete this command
	HRESULT					hCommandStatus;			// command status
	void					*pCommandContext;		// command context
} SPIE_CONNECTADDRESSINFO, *PSPIE_CONNECTADDRESSINFO;

//
// data passed through the service provider interface
//
typedef struct IDP8SPCallback	FAR *PDP8SPCALLBACK;
typedef struct IDP8SPCallback	IDP8SPCallback;

// Love to use SPINITDATA, but the old DPlay already took it, and compilers
// don't like namespace collisions for some strange reason.
typedef struct	_SPINITIALIZEDATA
{
	IDP8SPCallback	*pIDP;		// pointer to callback interface
	DWORD			dwFlags;	// flags

} SPINITIALIZEDATA, *PSPINITIALIZEDATA;


typedef	struct	_SPGETCAPSDATA
{
	DWORD		dwSize;							// size of this structure

	HANDLE		hEndpoint;						// Handle of endpoint to check.  If this parameter
												// is NULL, the best-case capabilities of the SP are
												// returned.

	DWORD		dwUserFrameSize;				// Maximum data payload allowed in an outgoing
												// message from this SP.  It is the SP's responsibility
												// to account for any extra header information it's
												// going to attach when sending a message, and for any
												// underlying protocol overhead (IP packet headers).

	DWORD		dwEnumFrameSize;				// maximum payload for an enum query (NOT ENUM RESPONSE!)

	DWORD		dwLocalLinkSpeed;				// speed of link in bits per second

	DWORD		dwIOThreadCount;				// count of threads in operation by this SP

	DWORD		dwDefaultEnumRetryCount;		// default retry count

	DWORD		dwDefaultEnumRetryInterval;		// default retry interval

	DWORD		dwDefaultEnumTimeout;			// default timeout

	DWORD		dwFlags;						// SP flags

	DWORD		dwBuffersPerThread;				// buffers per thread
	
	DWORD		dwSystemBufferSize;				// system buffer size

} SPGETCAPSDATA, *PSPGETCAPSDATA;


typedef	struct	_SPSETCAPSDATA
{
	DWORD	dwSize;					// size of this structure

	DWORD	dwIOThreadCount;		// number of threads in operation by this SP
	DWORD	dwBuffersPerThread;		// buffers per thread
	DWORD	dwSystemBufferSize;		// system buffer size

} SPSETCAPSDATA, *PSPSETCAPSDATA;


typedef	struct	_SPGETADDRESSINFODATA
{
	HANDLE				hEndpoint;		// handle of endpoint to check
	IDirectPlay8Address	*pAddress;		// pointer to output address
	SP_GET_ADDRESS_INFO_FLAGS	Flags;	// flags

} SPGETADDRESSINFODATA, *PSPGETADDRESSINFODATA;


typedef struct	_SPENUMQUERYDATA
{
	IDirectPlay8Address	*pAddressHost;			// address to which to send
	IDirectPlay8Address	*pAddressDeviceInfo;	// device to enumerate on
	BUFFERDESC			*pBuffers;				// pointer to buffers to send
	DWORD				dwBufferCount;			// count of buffers to send
	DWORD				dwTimeout;				// how long to wait for replies (0 means infinite)
	DWORD				dwRetryCount;			// how many times to send it (0 means infinite)
	DWORD				dwRetryInterval;		// how long to wait between retries
	DWORD				dwFlags;
	void				*pvContext;				// caller's toy, returned in the completion indication
	HANDLE				hCommand;				// Returned
	DWORD				dwCommandDescriptor;	// Returned

} SPENUMQUERYDATA, *PSPENUMQUERYDATA;


typedef struct	_SPENUMRESPONDDATA
{
	SPIE_QUERY		*pQuery;				// pointer to the query indication to which you're responding
	BUFFERDESC		*pBuffers;
	DWORD			dwBufferCount;
	DWORD			dwFlags;				// must be zero!
	void			*pvContext;				// caller's toy, returned in the completion indication
	HANDLE			hCommand;				// Returned
	DWORD			dwCommandDescriptor;	// Returned

} SPENUMRESPONDDATA, *PSPENUMRESPONDDATA;


typedef struct	_SPCONNECTDATA
{
	IDirectPlay8Address	*pAddressHost;			// address to which to connect
	IDirectPlay8Address	*pAddressDeviceInfo;	// address to which to connect
	DWORD				dwTimeout;				// how long to wait before failing
	DWORD				dwFlags;
	void				*pvContext;				// caller's toy, returned in the completion indication
	HANDLE				hCommand;				// Returned
	DWORD				dwCommandDescriptor;	// Returned

} SPCONNECTDATA, *PSPCONNECTDATA;


typedef struct	_SPDISCONNECTDATA
{
	HANDLE			hEndpoint;				// handle to the endpoint to disconnect
	DWORD			dwFlags;				// must be zero!
	void			*pvContext;				// caller's toy, returned in the completion indication
	HANDLE			hCommand;				// Returned
	DWORD			dwCommandDescriptor;	// Returned

} SPDISCONNECTDATA, *PSPDISCONNECTDATA;


typedef struct	_SPLISTENDATA
{
	IDirectPlay8Address	*pAddressDeviceInfo;	// address to listen on
	DWORD				dwFlags;
	void				*pvContext;				// caller's toy, returned in the completion indication
	HANDLE				hCommand;				// Returned
	DWORD				dwCommandDescriptor;	// Returned

} SPLISTENDATA, *PSPLISTENDATA;


typedef struct	_SPSENDDATA
{
	HANDLE			hEndpoint;				// handle of endpoint on which to send the data
	BUFFERDESC		*pBuffers;				// data to send
	DWORD			dwBufferCount;			// count of buffers to send
	DWORD			dwFlags;				// send flags
	void			*pvContext;				// caller's toy, returned in the completion indication
	HANDLE			hCommand;				// Returned
	DWORD			dwCommandDescriptor;	// Returned

} SPSENDDATA, *PSPSENDDATA;


typedef struct	_SPCREATEGROUPDATA
{
	IDirectPlay8Address	*pGroupAddress;		// pointer to group address (may be NULL)
	const GUID 			*pAdapterGuid;		// pointer to GUID of adapter to create group with
	void 				*pGroupData;		// pointer to store protocol-specific group data (to be propagated to other machines)
	DWORD				dwGroupDataSize;	// size of protocol specific group data
	DWORD				dwFlags;			// flags (must be zero)

} SPCREATEGROUPDATA, *PSPCREATEGROUPDATA;


typedef	struct	_SPADDTOGROUPDATA
{
	const GUID	*pAdapterGuid;		// pointer to GUID of adapter used to join the group
	const void	*pGroupData;		// pointer to group data
	DWORD		dwGroupDataSize;	// size of group data
	HANDLE		hMulticastEndpoint;	// handle of multicast endpoint associated with group (returned)
	DWORD		dwFlags;			// flags (must not be zero)

} SPADDTOGROUPDATA, *PSPADDTOGROUPDATA;


typedef struct	_SPREMOVEFROMGROUPDATA
{
	HANDLE		hEndpoint;			// handle of group endpoint
	const void	*pGroupData;		// pointer to protocol-specific group data
	DWORD		dwGroupDataSize;	// size of protocol specific group data
	DWORD		dwFlags;			// flags (must be zero)

} SPREMOVEFROMGROUPDATA, *PSPREMOVEFROMGROUPDATA;


typedef struct	_SPDELETEGROUPDATA
{
	const GUID	*pAdapterGuid;		// pointer to GUID of adapter to delete group with
	const void	*pGroupData;		// protocol-specific group data
	DWORD		dwGroupDataSize;	// size of protocol specific group data
	DWORD		dwFlags;

} SPDELETEGROUPDATA, *PSPDELETEGROUPDATA;


typedef struct	_SPISAPPLICATIONSUPPORTEDDATA
{
	const GUID	*pApplicationGuid;
	DWORD		dwFlags;

} SPISAPPLICATIONSUPPORTEDDATA, *PSPISAPPLICATIONSUPPORTEDDATA;


typedef struct	_SPENUMADAPTERSDATA
{
	DPN_SERVICE_PROVIDER_INFO	*pAdapterData;
	DWORD	dwAdapterDataSize;
	DWORD	dwAdapterCount;
	DWORD	dwFlags;

} SPENUMADAPTERSDATA, *PSPENUMADAPTERSDATA;


typedef struct	_SPPROXYENUMQUERYDATA
{
	DWORD				dwFlags;
	SPIE_QUERY			*pIncomingQueryData;
	IDirectPlay8Address	*pDestinationAdapter;

} SPPROXYENUMQUERYDATA, *PSPPROXYENUMQUERYDATA;


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


/****************************************************************************
 * IDirectPlay8SP Interface- SP's call back into DPLAY via this interface
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDP8SPCallback
DECLARE_INTERFACE_( IDP8SPCallback, IUnknown )
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)		(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
	STDMETHOD_(ULONG,Release)		(THIS) PURE;
	/*** IDirectPlay8SP methods ***/
	STDMETHOD(IndicateEvent) 		(THIS_ SP_EVENT_TYPE,LPVOID) PURE;
	STDMETHOD(CommandComplete) 		(THIS_ HANDLE,HRESULT,LPVOID) PURE;
};


/****************************************************************************
 * IDirectPlay8SP interface macros
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDP8SPCallback_QueryInterface(p,a,b)		(p)->lpVtbl->QueryInterface(p,a,b)
#define IDP8SPCallback_AddRef(p)					(p)->lpVtbl->AddRef(p)
#define IDP8SPCallback_Release(p)			   		(p)->lpVtbl->Release(p)
#define IDP8SPCallback_IndicateEvent(p,a,b)	  		(p)->lpVtbl->IndicateEvent(p,a,b)
#define IDP8SPCallback_CommandComplete(p,a,b,c)		(p)->lpVtbl->CommandComplete(p,a,b,c)

#else /* C++ */

#define IDP8SPCallback_QueryInterface(p,a,b)		(p)->QueryInterface(a,b)
#define IDP8SPCallback_AddRef(p)					(p)->AddRef()
#define IDP8SPCallback_Release(p)			   		(p)->Release()
#define IDP8SPCallback_IndicateEvent(p,a,b)			(p)->IndicateEvent(a,b)
#define IDP8SPCallback_CommandComplete(p,a,b,c)		(p)->CommandComplete(a,b,c)

#endif


/****************************************************************************
 * IDirectPlay8ServiceProvider Interface
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDP8ServiceProvider
DECLARE_INTERFACE_( IDP8ServiceProvider, IUnknown )
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)	   		(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)	   		(THIS) PURE;
	/*** IDP8ServiceProvider methods ***/
	STDMETHOD(Initialize)				(THIS_ PSPINITIALIZEDATA) PURE;
	STDMETHOD(Close)  					(THIS) PURE;
	STDMETHOD(Connect)		  			(THIS_ PSPCONNECTDATA) PURE;
	STDMETHOD(Disconnect)		  		(THIS_ PSPDISCONNECTDATA) PURE;
	STDMETHOD(Listen)					(THIS_ PSPLISTENDATA) PURE;
	STDMETHOD(SendData)					(THIS_ PSPSENDDATA) PURE;
	STDMETHOD(EnumQuery)				(THIS_ PSPENUMQUERYDATA) PURE;
	STDMETHOD(EnumRespond)				(THIS_ PSPENUMRESPONDDATA) PURE;
	STDMETHOD(CancelCommand)			(THIS_ HANDLE, DWORD) PURE;
	STDMETHOD(CreateGroup)		  		(THIS_ PSPCREATEGROUPDATA) PURE;
	STDMETHOD(DeleteGroup)		  		(THIS_ PSPDELETEGROUPDATA) PURE;
	STDMETHOD(AddToGroup)				(THIS_ PSPADDTOGROUPDATA) PURE;
	STDMETHOD(RemoveFromGroup)			(THIS_ PSPREMOVEFROMGROUPDATA) PURE;
	STDMETHOD(GetCaps)					(THIS_ PSPGETCAPSDATA) PURE;
	STDMETHOD(SetCaps)					(THIS_ PSPSETCAPSDATA) PURE;
	STDMETHOD(ReturnReceiveBuffers)		(THIS_ PSPRECEIVEDBUFFER) PURE;
	STDMETHOD(GetAddressInfo)			(THIS_ PSPGETADDRESSINFODATA) PURE;
	STDMETHOD(IsApplicationSupported)	(THIS_ PSPISAPPLICATIONSUPPORTEDDATA) PURE;
	STDMETHOD(ProxyEnumQuery)			(THIS_ PSPPROXYENUMQUERYDATA) PURE;
};

/****************************************************************************
 * IDDP8ServiceProvider interface macros
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDP8ServiceProvider_QueryInterface(p,a,b)		(p)->lpVtbl->QueryInterface(p,a,b)
#define IDP8ServiceProvider_AddRef(p)					(p)->lpVtbl->AddRef(p)
#define IDP8ServiceProvider_Release(p)					(p)->lpVtbl->Release(p)
#define IDP8ServiceProvider_Initialize(p,a)				(p)->lpVtbl->Initialize(p,a)
#define IDP8ServiceProvider_Connect(p,a)				(p)->lpVtbl->Connect(p,a)
#define IDP8ServiceProvider_Disconnect(p,a)		  		(p)->lpVtbl->Disconnect(p,a)
#define IDP8ServiceProvider_Listen(p,a)					(p)->lpVtbl->Listen(p,a)
#define IDP8ServiceProvider_SendData(p,a)				(p)->lpVtbl->SendData(p,a)
#define IDP8ServiceProvider_EnumQuery(p,a)				(p)->lpVtbl->EnumQuery(p,a)
#define IDP8ServiceProvider_EnumRespond(p,a)			(p)->lpVtbl->EnumRespond(p,a)
#define IDP8ServiceProvider_CancelCommand(p,a,b)		(p)->lpVtbl->CancelCommand(p,a,b)
#define IDP8ServiceProvider_Close(p)					(p)->lpVtbl->Close(p)
#define IDP8ServiceProvider_CreateGroup(p,a)			(p)->lpVtbl->CreateGroup(p,a)
#define IDP8ServiceProvider_DeleteGroup(p,a)			(p)->lpVtbl->DeleteGroup(p,a)
#define IDP8ServiceProvider_AddToGroup(p,a)				(p)->lpVtbl->AddToGroup(p,a)
#define IDP8ServiceProvider_RemoveFromGroup(p,a)		(p)->lpVtbl->RemoveFromGroup(p,a)
#define	IDP8ServiceProvider_GetCaps(p,a)				(p)->lpVtbl->GetCaps(p,a)
#define	IDP8ServiceProvider_SetCaps(p,a)				(p)->lpVtbl->SetCaps(p,a)
#define IDP8ServiceProvider_ReturnReceiveBuffers(p,a)	(p)->lpVtbl->ReturnReceiveBuffers(p,a)
#define IDP8ServiceProvider_GetAddressInfo(p,a)			(p)->lpVtbl->GetAddressInfo(p,a)
#define IDP8ServiceProvider_IsApplicationSupported(p,a)	(p)->lpVtbl->IsApplicationSupported(p,a)
#define	IDP8ServiceProvider_ProxyEnumQuery(p,a)			(p)->lpVtbl->ProxyEnumQuery(p,a)

#else /* C++ */

#define IDP8ServiceProvider_QueryInterface(p,a,b)		(p)->QueryInterface(a,b)
#define IDP8ServiceProvider_AddRef(p)					(p)->AddRef()
#define IDP8ServiceProvider_Release(p)					(p)->Release()
#define IDP8ServiceProvider_Initialize(p,a)				(p)->Initialize(a)
#define IDP8ServiceProvider_Connect(p,a)				(p)->Connect(a)
#define IDP8ServiceProvider_Disconnect(p,a)				(p)->Disconnect(a)
#define IDP8ServiceProvider_Listen(p,a)					(p)->Listen(a)
#define IDP8ServiceProvider_SendData(p,a)				(p)->SendData(a)
#define IDP8ServiceProvider_EnumQuery(p,a)				(p)->EnumQuery(a)
#define IDP8ServiceProvider_EnumRespond(p,a)			(p)->EnumRespond(a)
#define IDP8ServiceProvider_CancelCommand(p,a,b)		(p)->CancelCommand(a,b)
#define IDP8ServiceProvider_Close(p)					(p)->Close()
#define IDP8ServiceProvider_CreateGroup(p,a)			(p)->CreateGroup(a)
#define IDP8ServiceProvider_DeleteGroup(p,a)			(p)->DeleteGroup(a)
#define IDP8ServiceProvider_AddToGroup(p,a)				(p)->AddToGroup(a)
#define IDP8ServiceProvider_RemoveFromGroup(p,a)		(p)->RemoveFromGroup(a)
#define	IDP8ServiceProvider_GetCaps(p,a)				(p)->GetCaps(a)
#define	IDP8ServiceProvider_SetCaps(p,a)				(p)->SetCaps(a)
#define IDP8ServiceProvider_ReturnReceiveBuffers(p,a)	(p)->ReturnReceiveBuffers(a)
#define IDP8ServiceProvider_GetAddressInfo(p,a)			(p)->GetAddressInfo(a)
#define IDP8ServiceProvider_IsApplicationSupported(p,a)	(p)->IsApplicationSupported(a)
#define	IDP8ServiceProvider_ProxyEnumQuery(p,a)			(p)->ProxyEnumQuery(a)

#endif	// C++

#ifdef __cplusplus
};
#endif

#endif	// __DIRECT_PLAY_SERVICE_PROVIDER_8__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dsoundp.h ===
/**************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    X-Box DirectSound.
//@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/19/00    dereks  Created.
//@@END_MSINTERNAL
 *
 **************************************************************************/

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

#include <xtl.h>
//@@BEGIN_MSINTERNAL
#include <dsfxparmp.h>
//@@END_MSINTERNAL
#include <dsfxparm.h>

#pragma warning(disable:4201)

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(p)
#endif // UNREFERENCED_PARAMETER

//
// Forward declarations
//

typedef struct XMediaObject XMediaObject;
typedef XMediaObject *LPXMEDIAOBJECT;

typedef struct XFileMediaObject XFileMediaObject;
typedef XFileMediaObject *LPXFILEMEDIAOBJECT;

typedef struct XWaveFileMediaObject XWaveFileMediaObject;
typedef XWaveFileMediaObject *LPXWAVEFILEMEDIAOBJECT;

typedef struct XWmaFileMediaObject XWmaFileMediaObject;
typedef XWmaFileMediaObject *LPXWMAFILEMEDIAOBJECT;

typedef struct IDirectSound IDirectSound;
typedef IDirectSound *LPDIRECTSOUND;

#define IDirectSound8 IDirectSound
#define LPDIRECTSOUND8 LPDIRECTSOUND

#define IDirectSound3DListener IDirectSound
#define LPDIRECTSOUND3DLISTENER LPDIRECTSOUND

typedef struct IDirectSoundBuffer IDirectSoundBuffer;
typedef IDirectSoundBuffer *LPDIRECTSOUNDBUFFER;

#define IDirectSoundBuffer8 IDirectSoundBuffer
#define LPDIRECTSOUNDBUFFER8 LPDIRECTSOUNDBUFFER

#define IDirectSound3DBuffer IDirectSoundBuffer
#define LPDIRECTSOUND3DBUFFER LPDIRECTSOUNDBUFFER

#define IDirectSoundNotify IDirectSoundBuffer
#define LPDIRECTSOUNDNOTIFY LPDIRECTSOUNDBUFFER

typedef struct IDirectSoundStream IDirectSoundStream;
typedef IDirectSoundStream *LPDIRECTSOUNDSTREAM;

typedef struct XAc97MediaObject XAc97MediaObject;
typedef XAc97MediaObject *LPAC97MEDIAOBJECT;

//
// Structures and types
//

#pragma pack(push, 1)

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_

typedef struct tWAVEFORMATEX
{
    WORD            wFormatTag;             // Format type
    WORD            nChannels;              // Channel count
    DWORD           nSamplesPerSec;         // Sampling rate
    DWORD           nAvgBytesPerSec;        // Average number of bytes per second
    WORD            nBlockAlign;            // Block size of data
    WORD            wBitsPerSample;         // Count of bits per mono sample
    WORD            cbSize;                 // Bytes of extra format information following this structure
} WAVEFORMATEX, *PWAVEFORMATEX, *LPWAVEFORMATEX;

typedef const WAVEFORMATEX *LPCWAVEFORMATEX;

#endif // _WAVEFORMATEX_

typedef struct xbox_adpcmwaveformat_tag 
{
    WAVEFORMATEX    wfx;                    // WAVEFORMATEX data
    WORD            wSamplesPerBlock;       // Count of samples per encoded block.  Must be 64.
} XBOXADPCMWAVEFORMAT, *PXBOXADPCMWAVEFORMAT, *LPXBOXADPCMWAVEFORMAT;

typedef const XBOXADPCMWAVEFORMAT *LPCXBOXADPCMWAVEFORMAT;

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_

typedef struct 
{
    WAVEFORMATEX    Format;                 // WAVEFORMATEX data

    union 
    {
        WORD        wValidBitsPerSample;    // Bits of precision
        WORD        wSamplesPerBlock;       // Samples per block of audio data
        WORD        wReserved;              // Unused -- must be 0
    } Samples;

    DWORD           dwChannelMask;          // Channel usage bitmask
    GUID            SubFormat;              // Sub-format identifier
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE, *LPWAVEFORMATEXTENSIBLE;

typedef const WAVEFORMATEXTENSIBLE *LPCWAVEFORMATEXTENSIBLE;

#endif // _WAVEFORMATEXTENSIBLE_
//@@BEGIN_MSINTERNAL

typedef struct voicecodecwaveformat_tag 
{
    WAVEFORMATEX    wfx;                    // WAVEFORMATEX data
    WORD            dwReserved;             // Reserved
    BYTE            dwTrailFrames;          // Count of trail frames
    BYTE            dwMilliSecPerFrame;     // Count of milliseconds per frame
} VOICECODECWAVEFORMAT, *PVOICECODECWAVEFORMAT, *LPVOICECODECWAVEFORMAT;

typedef const VOICECODECWAVEFORMAT *LPCVOICECODECWAVEFORMAT;
//@@END_MSINTERNAL

#pragma pack(pop)

typedef LONGLONG REFERENCE_TIME, *PREFERENCE_TIME, *LPREFERENCE_TIME;

typedef struct _XMEDIAPACKET
{
    LPVOID          pvBuffer;               // Packet data buffer
    DWORD           dwMaxSize;              // Packet data buffer size, in bytes
    LPDWORD         pdwCompletedSize;       // Optional pointer to completed size, in bytes
    LPDWORD         pdwStatus;              // Optional pointer to buffer status
    union 
    {
        HANDLE      hCompletionEvent;       // Optional packet completion event
        LPVOID      pContext;               // Optional callback function packet context
    };
    PREFERENCE_TIME prtTimestamp;           // Optional packet timestamp
} XMEDIAPACKET, *PXMEDIAPACKET, *LPXMEDIAPACKET;

typedef const XMEDIAPACKET *LPCXMEDIAPACKET;

typedef struct _XMEDIAINFO
{
    DWORD           dwFlags;                // Object flags (XMEDIA_STREAMF_*)
    DWORD           dwInputSize;            // Input buffer size
    DWORD           dwOutputSize;           // Output buffer size
    DWORD           dwMaxLookahead;         // Maximum amount of data that must be buffered to prevent underrun
} XMEDIAINFO, *PXMEDIAINFO, *LPXMEDIAINFO;

typedef const XMEDIAINFO *LPCXMEDIAINFO;

//@@BEGIN_MSINTERNAL
//
// the following data struct needs to be overlaid the virtual mmemory address
// mapped to EP_OFFSET_OUTPUT_LEVELS_ANALOG_PEAK above
//
//@@END_MSINTERNAL
typedef struct _DSOUTPUTLEVELS 
{
    DWORD   dwAnalogLeftTotalPeak;          // analog peak
    DWORD   dwAnalogRightTotalPeak;
    DWORD   dwAnalogLeftTotalRMS;           // analog RMS
    DWORD   dwAnalogRightTotalRMS;
    DWORD   dwDigitalFrontLeftPeak;         // digital peak levels
    DWORD   dwDigitalFrontCenterPeak;
    DWORD   dwDigitalFrontRightPeak;
    DWORD   dwDigitalBackLeftPeak;
    DWORD   dwDigitalBackRightPeak;
    DWORD   dwDigitalLowFrequencyPeak;
    DWORD   dwDigitalFrontLeftRMS;          // digital RMS levels
    DWORD   dwDigitalFrontCenterRMS;
    DWORD   dwDigitalFrontRightRMS;
    DWORD   dwDigitalBackLeftRMS;
    DWORD   dwDigitalBackRightRMS;
    DWORD   dwDigitalLowFrequencyRMS;
} DSOUTPUTLEVELS, *PDSOUTPUTLEVELS, *LPDSOUTPUTLEVELS;

typedef struct _DSCAPS                                  
{                                                       
    DWORD           dwFree2DBuffers;        // Number of available 2D sound buffers
    DWORD           dwFree3DBuffers;        // Number of available 3D sound buffers
    DWORD           dwFreeBufferSGEs;       // Number of available buffer scatter/gather entries
    DWORD           dwMemoryAllocated;      // Total amount of memory allocated by DirectSound
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSMIXBINVOLUMEPAIR
{
    DWORD           dwMixBin;               // MixBin identifier
    LONG            lVolume;                // MixBin volume
} DSMIXBINVOLUMEPAIR, *LPDSMIXBINVOLUMEPAIR;

typedef const DSMIXBINVOLUMEPAIR *LPCDSMIXBINVOLUMEPAIR;

typedef struct _DSMIXBINS
{
    DWORD                   dwMixBinCount;          // Count of mixbins to assign the voice to or mixbins to set volume on
    LPCDSMIXBINVOLUMEPAIR   lpMixBinVolumePairs;    // MixBin identifier/volume pairs
} DSMIXBINS, *LPDSMIXBINS;

typedef const DSMIXBINS *LPCDSMIXBINS;

typedef struct _DSBUFFERDESC
{
    DWORD               dwSize;             // Structure size, in bytes
    DWORD               dwFlags;            // DSBCAPS flags
    DWORD               dwBufferBytes;      // Buffer size, in bytes
    LPWAVEFORMATEX      lpwfxFormat;        // Buffer format
    LPCDSMIXBINS        lpMixBins;          // Output mixbin identifier/volume pairs
    DWORD               dwInputMixBin;      // Input mixbin identifier (FXIN buffers only)
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;               // Play cursor position
    HANDLE          hEventNotify;           // Notification event
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

typedef VOID (CALLBACK *LPFNXMEDIAOBJECTCALLBACK)(LPVOID pStreamContext, LPVOID pPacketContext, DWORD dwStatus);
typedef LPFNXMEDIAOBJECTCALLBACK PFNXMEDIAOBJECTCALLBACK;

typedef struct _DSSTREAMDESC
{
    DWORD                       dwFlags;                // DSSTREAMCAPS flags
    DWORD                       dwMaxAttachedPackets;   // Maximum count of packets that will be simultaneously submitted to the stream
    LPWAVEFORMATEX              lpwfxFormat;            // Stream format
    LPFNXMEDIAOBJECTCALLBACK    lpfnCallback;           // Packet completion callback routine
    LPVOID                      lpvContext;             // Packet completion callback routine context
    LPCDSMIXBINS                lpMixBins;              // Output mixbin identifier/volume pairs
} DSSTREAMDESC, *LPDSSTREAMDESC;

typedef const DSSTREAMDESC *LPCDSSTREAMDESC;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;                 // Structure size, in bytes
    D3DXVECTOR3     vPosition;              // Buffer 3D position
    D3DXVECTOR3     vVelocity;              // Buffer 3D velocity
    DWORD           dwInsideConeAngle;      // Buffer inside cone angle
    DWORD           dwOutsideConeAngle;     // Buffer outside cone angle
    D3DXVECTOR3     vConeOrientation;       // Buffer cone orientation
    LONG            lConeOutsideVolume;     // Volume outside the cone
    FLOAT           flMinDistance;          // Minimum distance value
    FLOAT           flMaxDistance;          // Maximum distance value
    DWORD           dwMode;                 // 3D processing mode
    FLOAT           flDistanceFactor;       // Distance factor
    FLOAT           flRolloffFactor;        // Rolloff factor
    FLOAT           flDopplerFactor;        // Doppler factor
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;                 // Structure size, in bytes
    D3DXVECTOR3     vPosition;              // Listener 3D position
    D3DXVECTOR3     vVelocity;              // Listener 3D velocity
    D3DXVECTOR3     vOrientFront;           // Listener front orientation
    D3DXVECTOR3     vOrientTop;             // Listener top orientation
    FLOAT           flDistanceFactor;       // Distance factor
    FLOAT           flRolloffFactor;        // Rolloff factor
    FLOAT           flDopplerFactor;        // Doppler factor
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSI3DL2OBSTRUCTION
{
    LONG            lHFLevel;               // [-10000, 0] default: 0 mB
    FLOAT           flLFRatio;              // [0.0, 1.0] default: 0.0
} DSI3DL2OBSTRUCTION, *LPDSI3DL2OBSTRUCTION;

typedef const DSI3DL2OBSTRUCTION *LPCDSI3DL2OBSTRUCTION;

typedef struct _DSI3DL2OCCLUSION
{
    LONG            lHFLevel;               // [-10000, 0] default: 0 mB
    FLOAT           flLFRatio;              // [0.0, 1.0] default: 0.25
} DSI3DL2OCCLUSION, *LPDSI3DL2OCCLUSION;

typedef const DSI3DL2OCCLUSION *LPCDSI3DL2OCCLUSION;

typedef struct _DSI3DL2BUFFER
{
    LONG                lDirect;            // [-10000, 1000] default: 0 mB
    LONG                lDirectHF;          // [-10000, 0] default: 0 mB
    LONG                lRoom;              // [-10000, 1000] default: 0 mB
    LONG                lRoomHF;            // [-10000, 0] default: 0 mB
    FLOAT               flRoomRolloffFactor;// [0.0, 10.0] default: 0.0
    DSI3DL2OBSTRUCTION  Obstruction;        // Source obstruction parameters
    DSI3DL2OCCLUSION    Occlusion;          // Source occlusion parameters
} DSI3DL2BUFFER, *LPDSI3DL2BUFFER;

typedef const DSI3DL2BUFFER *LPCDSI3DL2BUFFER;

typedef struct _DSI3DL2LISTENER
{
    LONG            lRoom;                  // [-10000, 0] default: -10000 mB
    LONG            lRoomHF;                // [-10000, 0] default: 0 mB
    FLOAT           flRoomRolloffFactor;    // [0.0, 10.0] default: 0.0
    FLOAT           flDecayTime;            // [0.1, 20.0] default: 1.0 s
    FLOAT           flDecayHFRatio;         // [0.1, 2.0] default: 0.5
    LONG            lReflections;           // [-10000, 1000] default: -10000 mB
    FLOAT           flReflectionsDelay;     // [0.0, 0.3] default: 0.02 s
    LONG            lReverb;                // [-10000, 2000] default: -10000 mB
    FLOAT           flReverbDelay;          // [0.0, 0.1] default: 0.04 s
    FLOAT           flDiffusion;            // [0.0, 100.0] default: 100.0 %
    FLOAT           flDensity;              // [0.0, 100.0] default: 100.0 %
    FLOAT           flHFReference;          // [20.0, 20000.0] default: 5000.0 Hz
} DSI3DL2LISTENER, *LPDSI3DL2LISTENER;

typedef const DSI3DL2LISTENER *LPCDSI3DL2LISTENER;

typedef struct _DSLFODESC
{
    DWORD           dwLFO;                  // LFO to set data on
    DWORD           dwDelay;                // Initial delay before LFO is applied, in 32-sample blocks
    DWORD           dwDelta;                // Delta added to LFO each frame
    LONG            lPitchModulation;       // Pitch modulation
    LONG            lFilterCutOffRange;     // Frequency cutoff range (multi-function LFO only)
    LONG            lAmplitudeModulation;   // Amplitude modulation (multi-function LFO only)
} DSLFODESC, *LPDSLFODESC;

typedef const DSLFODESC *LPCDSLFODESC;

typedef struct _DSENVELOPEDESC
{
    DWORD           dwEG;                   // Envelope generator to set data on
    DWORD           dwMode;                 // Envelope mode
    DWORD           dwDelay;                // Count of 512-sample blocks to delay before attack
    DWORD           dwAttack;               // Attack segment length, in 512-sample blocks
    DWORD           dwHold;                 // Count of 512-sample blocks to hold after attack
    DWORD           dwDecay;                // Decay segment length, in 512-sample blocks
    DWORD           dwRelease;              // Release segment length, in 512-sample blocks
    DWORD           dwSustain;              // Sustain level
    LONG            lPitchScale;            // Pitch scale (multi-function envelope only)
    LONG            lFilterCutOff;          // Filter cut-off (multi-function envelope only)
} DSENVELOPEDESC, *LPDSENVELOPEDESC;

typedef const DSENVELOPEDESC *LPCDSENVELOPEDESC;

typedef struct _DSFILTERDESC
{
    DWORD           dwMode;                 // Filter mode
    DWORD           dwQCoefficient;         // Q-coefficient (PEQ only)
    DWORD           adwCoefficients[4];     // Filter coefficients
} DSFILTERDESC, *LPDSFILTERDESC;

typedef const DSFILTERDESC *LPCDSFILTERDESC;

typedef struct _DSEFFECTMAP
{
    LPVOID          lpvCodeSegment;         // Starting address of the DSP code segment
    DWORD           dwCodeSize;             // Code segment size, in DWORDs
    LPVOID          lpvStateSegment;        // Starting address of the effect state segment
    DWORD           dwStateSize;            // Effect state segment size, in DWORDs
    LPVOID          lpvYMemorySegment;      // Starting address of the DSP Y-memory segment
    DWORD           dwYMemorySize;          // Y-memory segment size, in DWORDs            
    LPVOID          lpvScratchSegment;      // Starting address of the scratch memory segment
    DWORD           dwScratchSize;          // Scratch segment size, in DWORDs
} DSEFFECTMAP, *LPDSEFFECTMAP;

typedef const DSEFFECTMAP *LPCDSEFFECTMAP;

typedef struct _DSEFFECTIMAGEDESC
{
    DWORD           dwEffectCount;          // Count of effects in the image
    DWORD           dwTotalScratchSize;     // total FX delay line scratch used
    DSEFFECTMAP     aEffectMaps[1];         // Variable-length array of effect maps
} DSEFFECTIMAGEDESC, *LPDSEFFECTIMAGEDESC;

typedef const DSEFFECTIMAGEDESC *LPCDSEFFECTIMAGEDESC;

typedef struct _DSEFFECTIMAGELOC
{
    DWORD           dwI3DL2ReverbIndex;     // I3DL2 reverb effect index
    DWORD           dwCrosstalkIndex;       // Crosstalk cancellation effect index
} DSEFFECTIMAGELOC, *LPDSEFFECTIMAGELOC;

typedef const DSEFFECTIMAGELOC *LPCDSEFFECTIMAGELOC;

#include <pshpack1.h>

typedef struct _WMAXMOFileContDesc
{
    WORD        wTitleLength;
    WORD        wAuthorLength;
    WORD        wCopyrightLength;
    WORD        wDescriptionLength;
    WORD        wRatingLength;
    WCHAR *     pTitle;
    WCHAR *     pAuthor;
    WCHAR *     pCopyright;
    WCHAR *     pDescription;
    WCHAR *     pRating;
} WMAXMOFileContDesc, *LPWMAXMOFileContDesc;

#include <poppack.h>

typedef struct _WMAXMOFileHeader
{
    DWORD       dwVersion;
    DWORD       dwSampleRate;
    DWORD       dwNumChannels;
    DWORD       dwDuration;
    DWORD       dwBitrate;
} WMAXMOFileHeader;

typedef DWORD FOURCC, *PFOURCC, *LPFOURCC;

//
// Return Codes
//

#define _FACDS 0x878
#define MAKE_DSHRESULT(code) MAKE_HRESULT(1, _FACDS, code)

// The function completed successfully
#define DS_OK                   S_OK                    

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL    MAKE_DSHRESULT(30)      

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL       MAKE_DSHRESULT(50)      

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC           E_FAIL                  

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY       E_OUTOFMEMORY           

// The function called is not supported at this time
#define DSERR_UNSUPPORTED       E_NOTIMPL               

// No sound driver is available for use
#define DSERR_NODRIVER          MAKE_DSHRESULT(120)     

// This object does not support aggregation
#define DSERR_NOAGGREGATION     CLASS_E_NOAGGREGATION   

//
// Format tags
//

#define WAVE_FORMAT_PCM                     1
#define WAVE_FORMAT_XBOX_ADPCM              0x0069
#define WAVE_FORMAT_VOXWARE_VR12            0x0077
#define WAVE_FORMAT_VOXWARE_SC03            0x007A
#define WAVE_FORMAT_VOXWARE_SC06            0x007B
#define WAVE_FORMAT_EXTENSIBLE              0xFFFE

//
// WAVEFORMATEXTENSIBLE sub-format identifiers
//

EXTERN_C const GUID KSDATAFORMAT_SUBTYPE_PCM;
EXTERN_C const GUID KSDATAFORMAT_SUBTYPE_XBOX_ADPCM;

//
// FOURCC codes
//

#ifndef MAKEFOURCC

#define MAKEFOURCC(ch0, ch1, ch2, ch3) \
    ((FOURCC)(BYTE)(ch0) | ((FOURCC)(BYTE)(ch1) << 8) | \
    ((FOURCC)(BYTE)(ch2) << 16) | ((FOURCC)(BYTE)(ch3) << 24 ))

#endif // MAKEFOURCC

//
// XMediaObject constants
//

#define XMO_STATUSF_ACCEPT_INPUT_DATA           0x00000001      // The object is ready to accept input data
#define XMO_STATUSF_ACCEPT_OUTPUT_DATA          0x00000002      // The object is ready to provide output data
#define XMO_STATUSF_MASK                        0x00000003
                                                
#define XMO_STREAMF_FIXED_SAMPLE_SIZE           0x00000001      // The object supports only a fixed sample size
#define XMO_STREAMF_FIXED_PACKET_ALIGNMENT      0x00000002      // The object supports only a fixed packet alignment
#define XMO_STREAMF_INPUT_ASYNC                 0x00000004      // The object supports receiving input data asynchronously
#define XMO_STREAMF_OUTPUT_ASYNC                0x00000008      // The object supports providing output data asynchronously
#define XMO_STREAMF_IN_PLACE                    0x00000010      // The object supports in-place modification of data
#define XMO_STREAMF_MASK                        0x0000001F

#define XMEDIAPACKET_STATUS_SUCCESS             S_OK            // The packet completed successfully
#define XMEDIAPACKET_STATUS_PENDING             E_PENDING       // The packet is waiting to be processed
#define XMEDIAPACKET_STATUS_FLUSHED             E_ABORT         // The packet was completed as a result of a Flush operation
#define XMEDIAPACKET_STATUS_FAILURE             E_FAIL          // The packet was completed as a result of a failure

//
// Cooperative levels (not used on Xbox)
//

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004
//@@BEGIN_MSINTERNAL
#define DSSCL_NONE                  0x00000000
#define DSSCL_FIRST                 DSSCL_NORMAL
#define DSSCL_LAST                  DSSCL_WRITEPRIMARY
//@@END_MSINTERNAL

//
// Speaker configuration
//

#define DSSPEAKER_SURROUND          XC_AUDIO_FLAGS_SURROUND     // Dolby Surround
#define DSSPEAKER_STEREO            XC_AUDIO_FLAGS_STEREO       // Stereo
#define DSSPEAKER_MONO              XC_AUDIO_FLAGS_MONO         // Mono
#define DSSPEAKER_ENABLE_AC3        XC_AUDIO_FLAGS_ENABLE_AC3   // Enable Dolby Digital output
#define DSSPEAKER_ENABLE_DTS        XC_AUDIO_FLAGS_ENABLE_DTS   // Enable DTS output
#define DSSPEAKER_USE_DEFAULT       0xFFFFFFFF                  // Use the speaker config set in the Dashboard

#define DSSPEAKER_BASIC(c)          XC_AUDIO_FLAGS_BASIC(c)
#define DSSPEAKER_ENCODED(c)        XC_AUDIO_FLAGS_ENCODED(c)
#define DSSPEAKER_COMBINED(b,e)     XC_AUDIO_FLAGS_COMBINED(b,e)

#define XAudioGetSpeakerConfig      XGetAudioFlags
//@@BEGIN_MSINTERNAL

#define DSSPEAKER_DEFAULT           0
#define DSSPEAKER_BASIC_FIRST       0
#define DSSPEAKER_BASIC_LAST        2
#define DSSPEAKER_ENCODED_VALID     (DSSPEAKER_ENABLE_AC3 | DSSPEAKER_ENABLE_DTS)
#define DSSPEAKER_ENABLE_HEADPHONES 0x80000000

#define DSSPEAKER_IS_VALID_BASIC(c) \
    ((DSSPEAKER_BASIC(c) >= DSSPEAKER_BASIC_FIRST) && (DSSPEAKER_BASIC(c) <= DSSPEAKER_BASIC_LAST))

#define DSSPEAKER_IS_VALID_ENCODED(c) \
    (!(DSSPEAKER_ENCODED(c) & ~DSSPEAKER_ENCODED_VALID))

#define DSSPEAKER_IS_VALID(c) \
    (DSSPEAKER_IS_VALID_BASIC(c) && DSSPEAKER_IS_VALID_ENCODED(c))

#define DSSPEAKER_IS_AC3(c) \
    ((c) & DSSPEAKER_ENABLE_AC3)

#define DSSPEAKER_IS_SURROUND(c) \
    ((DSSPEAKER_SURROUND == DSSPEAKER_BASIC(c)) || DSSPEAKER_IS_AC3(c))

#define DSSPEAKER_IS_HEADPHONES(c) \
    ((c) & DSSPEAKER_ENABLE_HEADPHONES)
//@@END_MSINTERNAL                      
                                        
//
// DirectSound global headroom ranges
//

#define DSHEADROOM_MIN              0               // Minimum valid headroom value
#define DSHEADROOM_MAX              7               // Maximum valid headroom value
#define DSHEADROOM_DEFAULT          1               // Default headroom value
                                                                        
//
// DirectSound Buffer creation flags
//

#define DSBCAPS_CTRL3D              0x00000010      // The buffer supports 3D
#define DSBCAPS_CTRLFREQUENCY       0x00000020      // The buffer supports frequency changes
#define DSBCAPS_CTRLVOLUME          0x00000080      // The buffer supports volume changes
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100      // The buffer supports position notifications
#define DSBCAPS_MIXIN               0x00002000      // The buffer is to be used as the destination of a submix operation
#define DSBCAPS_LOCDEFER            0x00040000      // The buffer does not acquire resources at creation
#define DSBCAPS_FXIN                0x00080000      // The buffer is to be used as the destination of a post-effects submix operation
//@@BEGIN_MSINTERNAL                                
#define DSBCAPS_APPALLOCBUFFER      0x80000000      // The application allocated the buffer memory

#define DSBCAPS_VALID \
    (DSBCAPS_CTRL3D | \
     DSBCAPS_CTRLFREQUENCY | \
     DSBCAPS_CTRLVOLUME | \
     DSBCAPS_CTRLPOSITIONNOTIFY | \
     DSBCAPS_MIXIN | \
     DSBCAPS_LOCDEFER | \
     DSBCAPS_FXIN)

#define DSBCAPS_SUBMIXMASK          (DSBCAPS_MIXIN | DSBCAPS_FXIN)
//@@END_MSINTERNAL                                                      
                                                                        
//
// IDirectSoundBuffer::Play(Ex) flags
//

#define DSBPLAY_LOOPING             0x00000001      // The buffer should play in a loop
#define DSBPLAY_FROMSTART           0x00000002      // Play the buffer from the beginning, regardless of current position
//@@BEGIN_MSINTERNAL
#define DSBPLAY_VALID               (DSBPLAY_LOOPING | DSBPLAY_FROMSTART)
//@@END_MSINTERNAL

//
// IDirectSoundBuffer::StopEx flags
//

#define DSBSTOPEX_IMMEDIATE         0x00000000      // The buffer should stop immediately
#define DSBSTOPEX_ENVELOPE          0x00000001      // The buffer should enter it's release phase
#define DSBSTOPEX_RELEASEWAVEFORM   0x00000002      // The buffer should break out of the loop region and enter it's release phase
//@@BEGIN_MSINTERNAL                                                   
#define DSBSTOPEX_VALID             (DSBSTOPEX_ENVELOPE | DSBSTOPEX_RELEASEWAVEFORM)
//@@END_MSINTERNAL                                                      
                                                                        
//
// Buffer status flags
//

#define DSBSTATUS_PLAYING           0x00000001      // The buffer is playing
#define DSBSTATUS_LOOPING           0x00000004      // The buffer is playing in a loop
//@@BEGIN_MSINTERNAL
#define DSBSTATUS_VALID             (DSBSTATUS_PLAYING | DSBSTATUS_LOOPING)
//@@END_MSINTERNAL
                                                                            
//
// IDirectSoundBuffer::Lock flags
//

#define DSBLOCK_FROMWRITECURSOR     0x00000001      // Lock the buffer from the current write cursor position
#define DSBLOCK_ENTIREBUFFER        0x00000002      // Lock the entire buffer
//@@BEGIN_MSINTERNAL                                                        
#define DSBLOCK_VALID               (DSBLOCK_FROMWRITECURSOR | DSBLOCK_ENTIREBUFFER)
//@@END_MSINTERNAL                                                          
                                                                            
//
// Buffer frequency range
//

#define DSBFREQUENCY_MIN            188             // Minimum valid frequency value
#define DSBFREQUENCY_MAX            191983          // Maximum valid frequency value
#define DSBFREQUENCY_ORIGINAL       0               // Reserved value meaning original frequency
                                                                        
//
// Buffer volume range
//

#define DSBVOLUME_MIN               -10000          // Maximum valid attenuation value
#define DSBVOLUME_MAX               0               // Minimum valid attenuation value

//
// Buffer headroom range 
//

#define DSBHEADROOM_MIN             0               // Minimum valid headroom value
#define DSBHEADROOM_MAX             10000           // Maximum valid headroom value
#define DSBHEADROOM_DEFAULT_2D      600             // Default headroom value for 2D voices
#define DSBHEADROOM_DEFAULT_3D      0               // Default headroom value for 3D voices
#define DSBHEADROOM_DEFAULT_SUBMIX  0               // Default headroom value for submix destinations

//
// Buffer pitch range
//

#define DSBPITCH_MIN                -32767          // Minimum valid pitch value
#define DSBPITCH_MAX                8191            // Maximum valid pitch value
                                                                        
//
// Buffer size range
//

#define DSBSIZE_MIN                 4               // Minimum valid buffer size, in bytes
#define DSBSIZE_MAX                 0x0FFFFFFF      // Maximum valid buffer size, in bytes
                                                                        
//
// Reserved notification offset values
//

#define DSBPN_OFFSETSTOP            0xFFFFFFFF      // Offset value representing "stop" to IDirectSoundNotify

//
// DirectSound Stream creation flags
//

#define DSSTREAMCAPS_CTRL3D         DSBCAPS_CTRL3D              // The stream supports 3D
#define DSSTREAMCAPS_CTRLFREQUENCY  DSBCAPS_CTRLFREQUENCY       // The stream supports frequency changes
#define DSSTREAMCAPS_CTRLVOLUME     DSBCAPS_CTRLVOLUME          // The stream supports volume changes
#define DSSTREAMCAPS_LOCDEFER       DSBCAPS_LOCDEFER            // The stream does not acquire resources at creation
#define DSSTREAMCAPS_ACCURATENOTIFY 0x40000000                  // The stream should provide more accurate packet completion notifications
//@@BEGIN_MSINTERNAL                                                

#define DSSTREAMCAPS_VALID \
    (DSSTREAMCAPS_CTRL3D | \
     DSSTREAMCAPS_CTRLFREQUENCY | \
     DSSTREAMCAPS_CTRLVOLUME | \
     DSSTREAMCAPS_LOCDEFER | \
     DSSTREAMCAPS_ACCURATENOTIFY)

#define DSSTREAMCAPS_VADREQUIRED \
    (DSSTREAMCAPS_LOCDEFER)

#define DSSTREAMCAPS_VADIGNORED \
    (DSSTREAMCAPS_CTRLVOLUME)
//@@END_MSINTERNAL                                                  
                                                                    
//
// Stream frequency range
//

#define DSSTREAMFREQUENCY_MIN       DSBFREQUENCY_MIN            // Minimum valid frequency value
#define DSSTREAMFREQUENCY_MAX       DSBFREQUENCY_MAX            // Maximum valid frequency value
#define DSSTREAMFREQUENCY_ORIGINAL  DSBFREQUENCY_ORIGINAL       // Reserved value meaning original frequency
                                                                    
//
// Stream volume range
//

#define DSSTREAMVOLUME_MIN          DSBVOLUME_MIN               // Minimum valid volume value
#define DSSTREAMVOLUME_MAX          DSBVOLUME_MAX               // Maximum valid volume value

//
// Stream headroom range 
//

#define DSSTREAMHEADROOM_MIN        DSBHEADROOM_MIN             // Minimum valid headroom value
#define DSSTREAMHEADROOM_MAX        DSBHEADROOM_MAX             // Maximum valid headroom value
#define DSSTREAMHEADROOM_DEFAULT_2D DSBHEADROOM_DEFAULT_2D      // Default headroom value for 2D voices
#define DSSTREAMHEADROOM_DEFAULT_3D DSBHEADROOM_DEFAULT_3D      // Default headroom value for 3D voices

//
// Buffer pitch range
//

#define DSSTREAMPITCH_MIN           DSBPITCH_MIN                // Minimum valid pitch value
#define DSSTREAMPITCH_MAX           DSBPITCH_MAX                // Maximum valid pitch value
                                                                        
//
// Stream pause state
//

#define DSSTREAMPAUSE_RESUME        0x00000000                  // Resume a paused stream
#define DSSTREAMPAUSE_PAUSE         0x00000001                  // Pause the stream
//@@BEGIN_MSINTERNAL
#define DSSTREAMPAUSE_FIRST         DSSTREAMPAUSE_RESUME
#define DSSTREAMPAUSE_LAST          DSSTREAMPAUSE_PAUSE
//@@END_MSINTERNAL

//
// IDirectSoundStream::Stop flags
//

#define DSSTREAMFLUSHEX_IMMEDIATE   0x00000000      // The stream should flush immediately (same as calling Flush)
#define DSSTREAMFLUSHEX_ASYNC       0x00000001      // The stream should begin a flush operation and complete it during DoWork
#define DSSTREAMFLUSHEX_ENVELOPE    0x00000002      // The stream should begin a flush operation using a release envelope
//@@BEGIN_MSINTERNAL                                                   
#define DSSTREAMFLUSHEX_VALID       (DSSTREAMFLUSHEX_ASYNC | DSSTREAMFLUSHEX_ENVELOPE)
//@@END_MSINTERNAL                                                      

//
// Stream status flags
//

#define DSSTREAMSTATUS_READY        XMO_STATUSF_ACCEPT_INPUT_DATA   // The object is ready to accept input data
#define DSSTREAMSTATUS_PLAYING      0x00010000                      // The stream is playing
#define DSSTREAMSTATUS_PAUSED       0x00020000                      // The stream is paused
#define DSSTREAMSTATUS_STARVED      0x00040000                      // The stream is starved
                                                                        
//
// 3D modes
//

#define DS3DMODE_NORMAL             0x00000000      // Normal 3D mode
#define DS3DMODE_HEADRELATIVE       0x00000001      // Head-relative 3D mode
#define DS3DMODE_DISABLE            0x00000002      // Disable 3D processing
//@@BEGIN_MSINTERNAL
#define DS3DMODE_FIRST              DS3DMODE_NORMAL
#define DS3DMODE_LAST               DS3DMODE_DISABLE
//@@END_MSINTERNAL

//
// 3D parameter flags
//

#define DS3D_IMMEDIATE              0x00000000      // Apply the values immediately
#define DS3D_DEFERRED               0x00000001      // Defer the values until CommitDeferredSettings is called
//@@BEGIN_MSINTERNAL
#define DS3D_VALID                  DS3D_DEFERRED
//@@END_MSINTERNAL

//
// 3D bounds and defaults
//

#define DS3D_MINDISTANCEFACTOR          FLT_MIN         // Minimum valid distance factor value
#define DS3D_MAXDISTANCEFACTOR          FLT_MAX         // Maximum valid distance factor value
#define DS3D_DEFAULTDISTANCEFACTOR      1.0f            // Default distance factor value
                                        
#define DS3D_MINROLLOFFFACTOR           0.0f            // Minimum valid rolloff factor value
#define DS3D_MAXROLLOFFFACTOR           10.0f           // Maximum valid rolloff factor value
#define DS3D_DEFAULTROLLOFFFACTOR       1.0f            // Default rolloff factor value
                                        
#define DS3D_MINDOPPLERFACTOR           0.0f            // Minimum valid Doppler factor value
#define DS3D_MAXDOPPLERFACTOR           10.0f           // Maximum valid Doppler factor value
#define DS3D_DEFAULTDOPPLERFACTOR       1.0f            // Default Doppler factor value
                                        
#define DS3D_MINMINDISTANCE             1.17549e-37f    // Minimum minimum distance value
#define DS3D_MAXMINDISTANCE             FLT_MAX         // Maximum minimum distance value
#define DS3D_DEFAULTMINDISTANCE         1.0f            // Default minimum distance value

#define DS3D_MINMAXDISTANCE             1.17549e-37f    // Minimum maximum distance value
#define DS3D_MAXMAXDISTANCE             FLT_MAX         // Maximum maximum distance value
#define DS3D_DEFAULTMAXDISTANCE         1000000000.0f   // Default maximum distance value
                                        
#define DS3D_MINCONEANGLE               0               // Minimum valid cone angle value
#define DS3D_MAXCONEANGLE               360             // Maximum valid cone angle value
#define DS3D_DEFAULTCONEANGLE           360             // Default cone angle value
                                        
#define DS3D_DEFAULTORIENTFRONT_X       0.0f            // Default front orientation (x)
#define DS3D_DEFAULTORIENTFRONT_Y       0.0f            // Default front orientation (y)
#define DS3D_DEFAULTORIENTFRONT_Z       1.0f            // Default front orientation (z)
                                        
#define DS3D_DEFAULTORIENTTOP_X         0.0f            // Default top orientation (x)
#define DS3D_DEFAULTORIENTTOP_Y         1.0f            // Default top orientation (y)
#define DS3D_DEFAULTORIENTTOP_Z         0.0f            // Default top orientation (z)
                                        
#define DS3D_DEFAULTCONEORIENT_X        0.0f            // Default cone orientation (x)
#define DS3D_DEFAULTCONEORIENT_Y        0.0f            // Default cone orientation (y)
#define DS3D_DEFAULTCONEORIENT_Z        1.0f            // Default cone orientation (z)
                                        
#define DS3D_DEFAULTPOSITION_X          0.0f            // Default position (x)
#define DS3D_DEFAULTPOSITION_Y          0.0f            // Default position (y)
#define DS3D_DEFAULTPOSITION_Z          0.0f            // Default position (z)
                                        
#define DS3D_DEFAULTVELOCITY_X          0.0f            // Default velocity (x)
#define DS3D_DEFAULTVELOCITY_Y          0.0f            // Default velocity (y)
#define DS3D_DEFAULTVELOCITY_Z          0.0f            // Default velocity (z)

#define DS3D_DEFAULTCONEOUTSIDEVOLUME   DSBVOLUME_MAX   // Default cone outside volume

//
// I3DL2 bounds and defaults
//

#define DSI3DL2LISTENER_MINROOM                     -10000
#define DSI3DL2LISTENER_MAXROOM                     0
#define DSI3DL2LISTENER_DEFAULTROOM                 -10000
#define DSI3DL2LISTENER_MINROOMHF                   -10000
#define DSI3DL2LISTENER_MAXROOMHF                   0
#define DSI3DL2LISTENER_DEFAULTROOMHF               0
#define DSI3DL2LISTENER_MINROOMROLLOFFFACTOR        0.0f
#define DSI3DL2LISTENER_MAXROOMROLLOFFFACTOR        10.0f
#define DSI3DL2LISTENER_DEFAULTROOMROLLOFFFACTOR    0.0f
#define DSI3DL2LISTENER_MINDECAYTIME                0.1f
#define DSI3DL2LISTENER_MAXDECAYTIME                20.0f
#define DSI3DL2LISTENER_DEFAULTDECAYTIME            1.0f
#define DSI3DL2LISTENER_MINDECAYHFRATIO             0.1f
#define DSI3DL2LISTENER_MAXDECAYHFRATIO             2.0f
#define DSI3DL2LISTENER_DEFAULTDECAYHFRATIO         0.5f
#define DSI3DL2LISTENER_MINREFLECTIONS              -10000
#define DSI3DL2LISTENER_MAXREFLECTIONS              1000
#define DSI3DL2LISTENER_DEFAULTREFLECTIONS          -10000
#define DSI3DL2LISTENER_MINREFLECTIONSDELAY         0.0f
#define DSI3DL2LISTENER_MAXREFLECTIONSDELAY         0.3f
#define DSI3DL2LISTENER_DEFAULTREFLECTIONSDELAY     0.02f
#define DSI3DL2LISTENER_MINREVERB                   -10000
#define DSI3DL2LISTENER_MAXREVERB                   2000
#define DSI3DL2LISTENER_DEFAULTREVERB               -10000
#define DSI3DL2LISTENER_MINREVERBDELAY              0.0f
#define DSI3DL2LISTENER_MAXREVERBDELAY              0.1f
#define DSI3DL2LISTENER_DEFAULTREVERBDELAY          0.04f
#define DSI3DL2LISTENER_MINDIFFUSION                0.0f
#define DSI3DL2LISTENER_MAXDIFFUSION                100.0f
#define DSI3DL2LISTENER_DEFAULTDIFFUSION            100.0f
#define DSI3DL2LISTENER_MINDENSITY                  0.0f
#define DSI3DL2LISTENER_MAXDENSITY                  100.0f
#define DSI3DL2LISTENER_DEFAULTDENSITY              100.0f
#define DSI3DL2LISTENER_MINHFREFERENCE              20.0f
#define DSI3DL2LISTENER_MAXHFREFERENCE              20000.0f
#define DSI3DL2LISTENER_DEFAULTHFREFERENCE          5000.0f

#define DSI3DL2BUFFER_MINDIRECT                     -10000
#define DSI3DL2BUFFER_MAXDIRECT                     1000
#define DSI3DL2BUFFER_DEFAULTDIRECT                 0
#define DSI3DL2BUFFER_MINDIRECTHF                   -10000
#define DSI3DL2BUFFER_MAXDIRECTHF                   0
#define DSI3DL2BUFFER_DEFAULTDIRECTHF               0
#define DSI3DL2BUFFER_MINROOM                       -10000
#define DSI3DL2BUFFER_MAXROOM                       1000
#define DSI3DL2BUFFER_DEFAULTROOM                   0
#define DSI3DL2BUFFER_MINROOMHF                     -10000
#define DSI3DL2BUFFER_MAXROOMHF                     0
#define DSI3DL2BUFFER_DEFAULTROOMHF                 0
#define DSI3DL2BUFFER_MINROOMROLLOFFFACTOR          0.0f
#define DSI3DL2BUFFER_MAXROOMROLLOFFFACTOR          10.f
#define DSI3DL2BUFFER_DEFAULTROOMROLLOFFFACTOR      0.0f
#define DSI3DL2BUFFER_MINOBSTRUCTION                -10000
#define DSI3DL2BUFFER_MAXOBSTRUCTION                0
#define DSI3DL2BUFFER_DEFAULTOBSTRUCTION            0
#define DSI3DL2BUFFER_MINOBSTRUCTIONLFRATIO         0.0f
#define DSI3DL2BUFFER_MAXOBSTRUCTIONLFRATIO         1.0f
#define DSI3DL2BUFFER_DEFAULTOBSTRUCTIONLFRATIO     0.0f
#define DSI3DL2BUFFER_MINOCCLUSION                  -10000
#define DSI3DL2BUFFER_MAXOCCLUSION                  0
#define DSI3DL2BUFFER_DEFAULTOCCLUSION              0
#define DSI3DL2BUFFER_MINOCCLUSIONLFRATIO           0.0f
#define DSI3DL2BUFFER_MAXOCCLUSIONLFRATIO           1.0f
#define DSI3DL2BUFFER_DEFAULTOCCLUSIONLFRATIO       0.25f

//
// I3DL2 listener environmental presets
//

#define DSI3DL2_ENVIRONMENT_PRESET_DEFAULT           -1000,   -100, 0.0f, 1.49f, 0.83f,  -2602, 0.007f,    200, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_GENERIC           -1000,   -100, 0.0f, 1.49f, 0.83f,  -2602, 0.007f,    200, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL        -1000,  -6000, 0.0f, 0.17f, 0.10f,  -1204, 0.001f,    207, 0.002f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_ROOM              -1000,   -454, 0.0f, 0.40f, 0.83f,  -1646, 0.002f,     53, 0.003f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_BATHROOM          -1000,  -1200, 0.0f, 1.49f, 0.54f,   -370, 0.007f,   1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM        -1000,  -6000, 0.0f, 0.50f, 0.10f,  -1376, 0.003f,  -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_STONEROOM         -1000,   -300, 0.0f, 2.31f, 0.64f,   -711, 0.012f,     83, 0.017f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM        -1000,   -476, 0.0f, 4.32f, 0.59f,   -789, 0.020f,   -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL       -1000,   -500, 0.0f, 3.92f, 0.70f,  -1230, 0.020f,     -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_CAVE              -1000,      0, 0.0f, 2.91f, 1.30f,   -602, 0.015f,   -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_ARENA             -1000,   -698, 0.0f, 7.24f, 0.33f,  -1166, 0.020f,     16, 0.030f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_HANGAR            -1000,  -1000, 0.0f,10.05f, 0.23f,   -602, 0.020f,    198, 0.030f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY   -1000,  -4000, 0.0f, 0.30f, 0.10f,  -1831, 0.002f,  -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_HALLWAY           -1000,   -300, 0.0f, 1.49f, 0.59f,  -1219, 0.007f,    441, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR     -1000,   -237, 0.0f, 2.70f, 0.79f,  -1214, 0.013f,    395, 0.020f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_ALLEY             -1000,   -270, 0.0f, 1.49f, 0.86f,  -1204, 0.007f,     -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_FOREST            -1000,  -3300, 0.0f, 1.49f, 0.54f,  -2560, 0.162f,   -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_CITY              -1000,   -800, 0.0f, 1.49f, 0.67f,  -2273, 0.007f,  -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS         -1000,  -2500, 0.0f, 1.49f, 0.21f,  -2780, 0.300f,  -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_QUARRY            -1000,  -1000, 0.0f, 1.49f, 0.83f, -10000, 0.061f,    500, 0.025f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_PLAIN             -1000,  -2000, 0.0f, 1.49f, 0.50f,  -2466, 0.179f,  -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT        -1000,      0, 0.0f, 1.65f, 1.50f,  -1363, 0.008f,  -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE         -1000,  -1000, 0.0f, 2.81f, 0.14f,    429, 0.014f,    648, 0.021f,  80.0f,  60.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER        -1000,  -4000, 0.0f, 1.49f, 0.10f,   -449, 0.007f,   1700, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_NOREVERB         -10000, -10000, 0.0f, 1.00f, 1.00f, -10000, 0.000f, -10000, 0.000f,   0.0f,   0.0f, 5000.0f

//
// I3DL2 source material presets
//

#define DSI3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800, 0.71f
#define DSI3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000, 0.40f
#define DSI3DL2_MATERIAL_PRESET_THINDOOR        -1800, 0.66f
#define DSI3DL2_MATERIAL_PRESET_THICKDOOR       -4400, 0.64f
#define DSI3DL2_MATERIAL_PRESET_WOODWALL        -4000, 0.50f
#define DSI3DL2_MATERIAL_PRESET_BRICKWALL       -5000, 0.60f
#define DSI3DL2_MATERIAL_PRESET_STONEWALL       -6000, 0.68f
#define DSI3DL2_MATERIAL_PRESET_CURTAIN         -1200, 0.15f

//
// MixBin identifiers
//

#define DSMIXBIN_FRONT_LEFT         0
#define DSMIXBIN_FRONT_RIGHT        1
#define DSMIXBIN_FRONT_CENTER       2
#define DSMIXBIN_LOW_FREQUENCY      3
#define DSMIXBIN_BACK_LEFT          4
#define DSMIXBIN_BACK_RIGHT         5
#define DSMIXBIN_SPEAKERS_FIRST     DSMIXBIN_FRONT_LEFT
#define DSMIXBIN_SPEAKERS_LAST      DSMIXBIN_BACK_RIGHT
#define DSMIXBIN_SPEAKERS_COUNT     (DSMIXBIN_SPEAKERS_LAST - DSMIXBIN_SPEAKERS_FIRST + 1)
                                    
#define DSMIXBIN_XTLK_FRONT_LEFT    6
#define DSMIXBIN_XTLK_FRONT_RIGHT   7
#define DSMIXBIN_XTLK_BACK_LEFT     8
#define DSMIXBIN_XTLK_BACK_RIGHT    9
#define DSMIXBIN_XTLK_FIRST         DSMIXBIN_XTLK_FRONT_LEFT
#define DSMIXBIN_XTLK_LAST          DSMIXBIN_XTLK_BACK_RIGHT
#define DSMIXBIN_XTLK_COUNT         (DSMIXBIN_XTLK_LAST - DSMIXBIN_XTLK_FIRST + 1)
                                    
#define DSMIXBIN_I3DL2              10
                                    
#define DSMIXBIN_FXSEND_0           11
#define DSMIXBIN_FXSEND_1           12
#define DSMIXBIN_FXSEND_2           13
#define DSMIXBIN_FXSEND_3           14
#define DSMIXBIN_FXSEND_4           15
#define DSMIXBIN_FXSEND_5           16
#define DSMIXBIN_FXSEND_6           17
#define DSMIXBIN_FXSEND_7           18
#define DSMIXBIN_FXSEND_8           19
#define DSMIXBIN_FXSEND_9           20
#define DSMIXBIN_FXSEND_10          21
#define DSMIXBIN_FXSEND_11          22
#define DSMIXBIN_FXSEND_12          23
#define DSMIXBIN_FXSEND_13          24
#define DSMIXBIN_FXSEND_14          25
#define DSMIXBIN_FXSEND_15          26
#define DSMIXBIN_FXSEND_16          27
#define DSMIXBIN_FXSEND_17          28
#define DSMIXBIN_FXSEND_18          29
#define DSMIXBIN_FXSEND_19          30
#define DSMIXBIN_FXSEND_FIRST       DSMIXBIN_FXSEND_0
#define DSMIXBIN_FXSEND_LAST        DSMIXBIN_FXSEND_19
#define DSMIXBIN_FXSEND_COUNT       (DSMIXBIN_FXSEND_LAST - DSMIXBIN_FXSEND_FIRST + 1)
                                    
#define DSMIXBIN_SUBMIX             31

#define DSMIXBIN_FIRST              DSMIXBIN_FRONT_LEFT
#define DSMIXBIN_LAST               DSMIXBIN_SUBMIX
#define DSMIXBIN_COUNT              (DSMIXBIN_LAST - DSMIXBIN_FIRST + 1)
                                    
#define DSMIXBIN_3D_FRONT_LEFT      DSMIXBIN_XTLK_FRONT_LEFT
#define DSMIXBIN_3D_FRONT_RIGHT     DSMIXBIN_XTLK_FRONT_RIGHT
#define DSMIXBIN_3D_BACK_LEFT       DSMIXBIN_XTLK_BACK_LEFT
#define DSMIXBIN_3D_BACK_RIGHT      DSMIXBIN_XTLK_BACK_RIGHT
#define DSMIXBIN_3D_FIRST           DSMIXBIN_XTLK_FIRST
#define DSMIXBIN_3D_LAST            DSMIXBIN_XTLK_LAST
#define DSMIXBIN_3D_COUNT           DSMIXBIN_XTLK_COUNT

//
// Maximum mixbin assignment count
//

#define DSMIXBIN_ASSIGNMENT_MAX     8

//
// Default and required mixbin assignments
//

#define DSMIXBINVOLUMEPAIRS_DEFAULT_MONO \
    { DSMIXBIN_FRONT_LEFT, 0 }, \
    { DSMIXBIN_FRONT_RIGHT, 0 }

#define DSMIXBINVOLUMEPAIRS_DEFAULT_STEREO \
    { DSMIXBIN_FRONT_LEFT, 0 }, \
    { DSMIXBIN_FRONT_RIGHT, 0 }

#define DSMIXBINVOLUMEPAIRS_DEFAULT_4CHANNEL \
    { DSMIXBIN_FRONT_LEFT, 0 }, \
    { DSMIXBIN_FRONT_RIGHT, 0 }, \
    { DSMIXBIN_BACK_LEFT, 0 }, \
    { DSMIXBIN_BACK_RIGHT, 0 }

#define DSMIXBINVOLUMEPAIRS_DEFAULT_6CHANNEL \
    { DSMIXBIN_FRONT_LEFT, 0 }, \
    { DSMIXBIN_FRONT_RIGHT, 0 }, \
    { DSMIXBIN_FRONT_CENTER, 0 }, \
    { DSMIXBIN_LOW_FREQUENCY, 0 }, \
    { DSMIXBIN_BACK_LEFT, 0 }, \
    { DSMIXBIN_BACK_RIGHT, 0 }

#define DSMIXBINVOLUMEPAIRS_REQUIRED_3D \
    { DSMIXBIN_3D_FRONT_LEFT, 0 }, \
    { DSMIXBIN_3D_BACK_LEFT, 0 }, \
    { DSMIXBIN_3D_FRONT_RIGHT, 0 }, \
    { DSMIXBIN_3D_BACK_RIGHT, 0 }
        
#define DSMIXBINVOLUMEPAIRS_DEFAULT_3D \
    DSMIXBINVOLUMEPAIRS_REQUIRED_3D, \
    { DSMIXBIN_I3DL2, 0 }

//
// WAVEFORMATEXTENSIBLE speaker identifiers
//

#define SPEAKER_FRONT_LEFT          0x00000001
#define SPEAKER_FRONT_RIGHT         0x00000002
#define SPEAKER_FRONT_CENTER        0x00000004
#define SPEAKER_LOW_FREQUENCY       0x00000008
#define SPEAKER_BACK_LEFT           0x00000010
#define SPEAKER_BACK_RIGHT          0x00000020
#define SPEAKER_MASK                0x0000003F

//
// Low-frequency occilator identifiers
//

#define DSLFO_MULTI                 0x00000000      // Multi-function LFO
#define DSLFO_PITCH                 0x00000001      // Pitch-only LFO
//@@BEGIN_MSINTERNAL
#define DSLFO_FIRST                 DSLFO_MULTI
#define DSLFO_LAST                  DSLFO_PITCH
//@@END_MSINTERNAL

//
// Low-frequency occilator parameter boundaries and defaults
//

#define DSLFO_DELAY_MIN             0
#define DSLFO_DELAY_MAX             65535
#define DSLFO_DELAY_DEFAULT         0

#define DSLFO_DELTA_MIN             0
#define DSLFO_DELTA_MAX             1023
#define DSLFO_DELTA_DEFAULT         0

#define DSLFO_PITCHMOD_MIN          -128
#define DSLFO_PITCHMOD_MAX          127
#define DSLFO_PITCHMOD_DEFAULT      0

#define DSLFO_FCRANGE_MIN           -128
#define DSLFO_FCRANGE_MAX           127
#define DSLFO_FCRANGE_DEFAULT       0

#define DSLFO_AMPMOD_MIN            -128
#define DSLFO_AMPMOD_MAX            128
#define DSLFO_AMPMOD_DEFAULT        0

//
// Envelope generator identifiers
//

#define DSEG_MULTI                  0x00000000      // Multi-function EG
#define DSEG_AMPLITUDE              0x00000001      // Amplitude-only EG
//@@BEGIN_MSINTERNAL
#define DSEG_FIRST                  DSEG_MULTI
#define DSEG_LAST                   DSEG_AMPLITUDE
//@@END_MSINTERNAL

//
// Envelope generator modes
//

#define DSEG_MODE_DISABLE           0x00000000      // The envelope is disabled and the envelope value is always full-scale
#define DSEG_MODE_DELAY             0x00000001      // Starts with the envelope at zero amplitude with an initial delay
#define DSEG_MODE_ATTACK            0x00000002      // Bypasses the initial delay and goes directly to the attack envelope
#define DSEG_MODE_HOLD              0x00000003      // Bypasses the attack segment and immediately goes full scale
//@@BEGIN_MSINTERNAL
#define DSEG_MODE_FIRST             DSEG_MODE_DISABLE
#define DSEG_MODE_LAST              DSEG_MODE_HOLD
//@@END_MSINTERNAL

//
// Envelope generator parameter boundaries and defaults
//

#define DSEG_DELAY_MIN              0
#define DSEG_DELAY_MAX              8191
#define DSEG_DELAY_DEFAULT          0

#define DSEG_ATTACK_MIN             0
#define DSEG_ATTACK_MAX             8191
#define DSEG_ATTACK_DEFAULT         0

#define DSEG_HOLD_MIN               0
#define DSEG_HOLD_MAX               8191
#define DSEG_HOLD_DEFAULT           0

#define DSEG_DECAY_MIN              0
#define DSEG_DECAY_MAX              8191
#define DSEG_DECAY_DEFAULT          0

#define DSEG_RELEASE_MIN            0
#define DSEG_RELEASE_MAX            8191
#define DSEG_RELEASE_DEFAULT        0

#define DSEG_SUSTAIN_MIN            0
#define DSEG_SUSTAIN_MAX            255
#define DSEG_SUSTAIN_DEFAULT        255

#define DSEG_PITCHSCALE_MIN         -128
#define DSEG_PITCHSCALE_MAX         127
#define DSEG_PITCHSCALE_DEFAULT     0

#define DSEG_FILTERCUTOFF_MIN       -128
#define DSEG_FILTERCUTOFF_MAX       127
#define DSEG_FILTERCUTOFF_DEFAULT   0

//
// Filter modes
//

#define DSFILTER_MODE_BYPASS        0x00000000      // The filter is bypassed
#define DSFILTER_MODE_DLS2          0x00000001      // DLS2 mode
#define DSFILTER_MODE_PARAMEQ       0x00000002      // Parametric equalizer mode
#define DSFILTER_MODE_MULTI         0x00000003      // Multifunction mode
//@@BEGIN_MSINTERNAL
#define DSFILTER_MODE_FIRST         DSFILTER_MODE_BYPASS
#define DSFILTER_MODE_LAST          DSFILTER_MODE_MULTI
//@@END_MSINTERNAL

//
// Effects parameter flags
//

#define DSFX_IMMEDIATE              0x00000000      // Apply the values immediately
#define DSFX_DEFERRED               0x00000001      // Defer the values until CommitEffectsData is called
//@@BEGIN_MSINTERNAL
#define DSFX_VALID                  DSFX_DEFERRED
//@@END_MSINTERNAL

//
// Effect index identifiers (for DSEFFECTIMAGELOC)
//

#define DSFX_IMAGELOC_UNUSED        0xFFFFFFFF      // The effect does not appear in the image
//@@BEGIN_MSINTERNAL

//
// Voice compression type identifiers
//

// PCM
DEFINE_GUID(DSCTID_NONE, 0x8de12fd4, 0x7cb3, 0x48ce, 0xa7, 0xe8, 0x9c, 0x47, 0xa2, 0x2e, 0x8a, 0xc5);

// Voxware SC03 3.2kbit/s
DEFINE_GUID(DSCTID_SC03, 0x7d82a29b, 0x2242, 0x4f82, 0x8f, 0x39, 0x5d, 0x11, 0x53, 0xdf, 0x3e, 0x41);

// Voxware SC06 6.4kbit/s
DEFINE_GUID(DSCTID_SC06, 0x53def900, 0x7168, 0x4633, 0xb4, 0x7f, 0xd1, 0x43, 0x91, 0x6a, 0x13, 0xc7);

// Voxware VR12 1.4kbit/s
DEFINE_GUID(DSCTID_VR12, 0xfe44a9fe, 0x8ed4, 0x48bf, 0x9d, 0x66, 0x1b, 0x1a, 0xdf, 0xf9, 0xff, 0x6d);
//@@END_MSINTERNAL

//
// AC'97 channel types
//

#define DSAC97_CHANNEL_ANALOG       0x00000000
#define DSAC97_CHANNEL_DIGITAL      0x00000001

//
// AC'97 digital channel modes
//

#define DSAC97_MODE_PCM             0x02000000
#define DSAC97_MODE_ENCODED         0x02000002
//@@BEGIN_MSINTERNAL
#define DSAC97_MODE_DEFAULT         DSAC97_MODE_PCM
//@@END_MSINTERNAL

//
// AC'97 packet counts
//

#define DSAC97_MAX_ATTACHED_PACKETS 31

//
// WMA in-memory decoder data callback
//

typedef DWORD (CALLBACK *LPFNWMAXMODATACALLBACK)(LPVOID pvContext, DWORD dwOffset, DWORD dwByteCount, LPVOID *ppvData);

//
// XAudioDownloadEffectsImage flags
//

#define XAUDIO_DOWNLOADFX_EXTERNFILE        0x00000000
#define XAUDIO_DOWNLOADFX_XBESECTION        0x00000001
//@@BEGIN_MSINTERNAL
#define XAUDIO_DOWNLOADFX_VALID             0x00000001
//@@END_MSINTERNAL

//
// Globals
//

EXTERN_C const DSMIXBINS DirectSoundDefaultMixBins_Mono;
EXTERN_C const DSMIXBINS DirectSoundDefaultMixBins_Stereo;
EXTERN_C const DSMIXBINS DirectSoundDefaultMixBins_4Channel;
EXTERN_C const DSMIXBINS DirectSoundDefaultMixBins_6Channel;

EXTERN_C const DSMIXBINS DirectSoundRequiredMixBins_3D;
EXTERN_C const DSMIXBINS DirectSoundDefaultMixBins_3D;

EXTERN_C const DS3DBUFFER DirectSoundDefault3DBuffer;
EXTERN_C const DSI3DL2BUFFER DirectSoundDefaultI3DL2Buffer;

EXTERN_C const DS3DLISTENER DirectSoundDefault3DListener;

EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Default;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Generic;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_PaddedCell;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Room;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Bathroom;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_LivingRoom;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_StoneRoom;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Auditorium;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_ConcertHall;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Cave;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Arena;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Hangar;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_CarpetedHallway;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Hallway;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_StoneCorridor;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Alley;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Forest;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_City;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Mountains;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Quarry;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Plain;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_ParkingLot;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_SewerPipe;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Underwater;
EXTERN_C const DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_NoReverb;
//@@BEGIN_MSINTERNAL

EXTERN_C DWORD g_dwDirectSoundDebugLevel;
EXTERN_C DWORD g_dwDirectSoundDebugBreakLevel;
EXTERN_C BOOL g_fDirectSoundDebugBreak;

EXTERN_C DWORD g_dwDirectSoundPoolMemoryUsage;
EXTERN_C DWORD g_dwDirectSoundPhysicalMemoryUsage;

EXTERN_C DWORD g_dwDirectSoundPhysicalMemorySlop;
EXTERN_C DWORD g_dwDirectSoundPhysicalMemoryRecovered;

EXTERN_C DWORD g_dwDirectSoundFree2dVoices;
EXTERN_C DWORD g_dwDirectSoundFree3dVoices;
EXTERN_C DWORD g_dwDirectSoundFreeBufferSGEs;

EXTERN_C DWORD g_dwDirectSoundOverrideSpeakerConfig;

EXTERN_C BOOL g_fDirectSoundInFinalRelease;
EXTERN_C BOOL g_fDirectSoundDisableBusyWaitWarning;
EXTERN_C BOOL g_fDirectSoundI3DL2Overdelay;

EXTERN_C CRITICAL_SECTION g_DirectSoundCriticalSection;
//@@END_MSINTERNAL

//
// API
//

STDAPI DirectSoundCreate(LPGUID pguidDeviceId, LPDIRECTSOUND *ppDirectSound, LPUNKNOWN pUnkOuter);
STDAPI DirectSoundCreateBuffer(LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer);
STDAPI DirectSoundCreateStream(LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream);
STDAPI_(void) DirectSoundDoWork(void);
STDAPI_(void) DirectSoundUseFullHRTF(void);
STDAPI_(void) DirectSoundUseLightHRTF(void);
//@@BEGIN_MSINTERNAL
STDAPI_(void) DirectSoundUsePan3D(void);
//@@END_MSINTERNAL
STDAPI_(void) DirectSoundOverrideSpeakerConfig(DWORD dwSpeakerConfig);
STDAPI_(DWORD) DirectSoundGetSampleTime(void);
STDAPI_(VOID) DirectSoundDumpMemoryUsage(BOOL fAssertNone);

STDAPI_(void) XAudioCreatePcmFormat(WORD nChannels, DWORD nSamplesPerSec, WORD wBitsPerSample, LPWAVEFORMATEX pwfx);
STDAPI_(void) XAudioCreateAdpcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPXBOXADPCMWAVEFORMAT pwfx);

STDAPI_(LONG) XAudioCalculatePitch(DWORD dwFrequency);
//@@BEGIN_MSINTERNAL

STDAPI DirectSoundLoadEncoder(LPCVOID pvImageBuffer, DWORD dwImageSize, LPVOID *ppvScratchData, LPDIRECTSOUND *ppDirectSound);

STDAPI VoxwareCreateConverter(WORD wEncodeFormatTag, BOOL fCreateEncoder, LPVOICECODECWAVEFORMAT pwfxEncoded, LPWAVEFORMATEX pwfxDecoded, LPXMEDIAOBJECT *ppMediaObject);

STDAPI XVoiceDecoderCreateMediaObject(DWORD dwCodecTag, LPWAVEFORMATEX pwfxDecoded, LPXMEDIAOBJECT *ppMediaObject);
STDAPI XVoiceEncoderCreateMediaObject(BOOL fAutoMode, DWORD dwCodecTag, LPWAVEFORMATEX pwfxEncoded, DWORD dwThreshold, LPXMEDIAOBJECT *ppMediaObject);

STDAPI XVoiceCreateMediaObject(PXPP_DEVICE_TYPE XppDeviceType, DWORD dwPort, DWORD dwMaxAttachedPackets, LPWAVEFORMATEX pwfxFormat, LPXMEDIAOBJECT *ppMediaObject);
STDAPI XVoiceCreateMediaObjectInternal(PXPP_DEVICE_TYPE XppDeviceType, DWORD dwPort, DWORD dwMaxAttachedPackets, LPWAVEFORMATEX pwfxFormat OPTIONAL, PFNXMEDIAOBJECTCALLBACK pfnCallback, PVOID pvContext, XMediaObject **ppXmediaObject);
//@@END_MSINTERNAL

STDAPI WmaCreateDecoder(LPCSTR pszFileName, HANDLE hFile, BOOL fAsyncMode, DWORD dwLookaheadBufferSize, DWORD dwMaxPackets, DWORD dwYieldRate, LPWAVEFORMATEX pwfxCompressed, XFileMediaObject **ppMediaObject);
STDAPI WmaCreateInMemoryDecoder(LPFNWMAXMODATACALLBACK pfnCallback, LPVOID pvContext, DWORD dwYieldRate, LPWAVEFORMATEX pwfxCompressed, LPXMEDIAOBJECT *ppMediaObject);

STDAPI WmaCreateDecoderEx(LPCSTR pszFileName, HANDLE hFile, BOOL fAsyncMode, DWORD dwLookaheadBufferSize, DWORD dwMaxPackets, DWORD dwYieldRate, LPWAVEFORMATEX pwfxCompressed, XWmaFileMediaObject **ppMediaObject);
STDAPI WmaCreateInMemoryDecoderEx(LPFNWMAXMODATACALLBACK pfnCallback, LPVOID pvContext, DWORD dwYieldRate, LPWAVEFORMATEX pwfxCompressed, XWmaFileMediaObject **ppMediaObject);

STDAPI Ac97CreateMediaObject(DWORD dwChannel, LPFNXMEDIAOBJECTCALLBACK pfnCallback, LPVOID pvContext, LPAC97MEDIAOBJECT *ppMediaObject);

STDAPI XFileCreateMediaObject(LPCSTR pszFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, XFileMediaObject **ppMediaObject);
STDAPI XFileCreateMediaObjectEx(HANDLE hFile, XFileMediaObject **ppMediaObject);
STDAPI XWaveFileCreateMediaObject(LPCSTR pszFileName, LPCWAVEFORMATEX *ppwfxFormat, XFileMediaObject **ppMediaObject);
STDAPI XWaveFileCreateMediaObjectEx(LPCSTR pszFileName, HANDLE hFile, XWaveFileMediaObject **ppMediaObject);

STDAPI XAudioDownloadEffectsImage(LPCSTR pszImageName, LPCDSEFFECTIMAGELOC pImageLoc, DWORD dwFlags, LPDSEFFECTIMAGEDESC *ppImageDesc);

//
// IUnknown
//

#ifndef IUnknown_AddRef
#if defined(__cplusplus) && !defined(CINTERFACE)
#define IUnknown_AddRef(p)  p->AddRef()
#else // defined(__cplusplus) && !defined(CINTERFACE)
#define IUnknown_AddRef(p)  p->lpVtbl->AddRef(p)
#endif // defined(__cplusplus) && !defined(CINTERFACE)
#endif // IUnknown_Addref

#ifndef IUnknown_Release
#if defined(__cplusplus) && !defined(CINTERFACE)
#define IUnknown_Release(p) p->Release()
#else // defined(__cplusplus) && !defined(CINTERFACE)
#define IUnknown_Release(p) p->lpVtbl->Release(p)
#endif // defined(__cplusplus) && !defined(CINTERFACE)
#endif // IUnknown_Release

//
// XMediaObject
//

#undef INTERFACE
#define INTERFACE XMediaObject

DECLARE_INTERFACE(XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;
};

#define XMediaObject_AddRef             IUnknown_AddRef
#define XMediaObject_Release            IUnknown_Release

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XMediaObject_GetInfo(p, a)      p->GetInfo(a)
#define XMediaObject_GetStatus(p, a)    p->GetStatus(a)
#define XMediaObject_Process(p, a, b)   p->Process(a, b)
#define XMediaObject_Discontinuity(p)   p->Discontinuity()
#define XMediaObject_Flush(p)           p->Flush()

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XMediaObject_GetInfo(p, a)      p->lpVtbl->GetInfo(p, a)
#define XMediaObject_GetStatus(p, a)    p->lpVtbl->GetStatus(p, a)
#define XMediaObject_Process(p, a, b)   p->lpVtbl->Process(p, a, b)
#define XMediaObject_Discontinuity(p)   p->lpVtbl->Discontinuity(p)
#define XMediaObject_Flush(p)           p->lpVtbl->Flush(p)

#endif // defined(__cplusplus) && !defined(CINTERFACE)
//@@BEGIN_MSINTERNAL

__inline void XMOAcceptPacket(LPCXMEDIAPACKET pxmp)
{
    if(pxmp->pdwCompletedSize)
    {
        *pxmp->pdwCompletedSize = 0;
    }

    if(pxmp->pdwStatus)
    {
        *pxmp->pdwStatus = XMEDIAPACKET_STATUS_PENDING;
    }
}

#ifdef __cplusplus
__inline void XMOCompletePacket(LPCXMEDIAPACKET pxmp, DWORD dwCompletedSize, LPFNXMEDIAOBJECTCALLBACK pfnCallback = NULL, LPVOID pvStreamContext = NULL, DWORD dwStatus = XMEDIAPACKET_STATUS_SUCCESS)
#else // __cplusplus
__inline void XMOCompletePacket(LPCXMEDIAPACKET pxmp, DWORD dwCompletedSize, LPFNXMEDIAOBJECTCALLBACK pfnCallback, LPVOID pvStreamContext, DWORD dwStatus)
#endif // __cplusplus
{
    if(pxmp->pdwCompletedSize)
    {
        *pxmp->pdwCompletedSize = dwCompletedSize;
    }

    if(pxmp->pdwStatus)
    {
        *pxmp->pdwStatus = dwStatus;
    }

    if(pfnCallback)
    {
        pfnCallback(pvStreamContext, pxmp->pContext, dwStatus);
    }
    else if(pxmp->hCompletionEvent)
    {

#ifdef _NTEXAPI_

        NtSetEvent(pxmp->hCompletionEvent, NULL);

#else // _NTEXAPI_

        SetEvent(pxmp->hCompletionEvent);

#endif // _NTEXAPI_

    }
}

__inline void XMOCompletePacketSync(LPCXMEDIAPACKET pxmp, DWORD dwCompletedSize, DWORD dwStatus)

{
    if(pxmp->pdwCompletedSize)
    {
        *pxmp->pdwCompletedSize = dwCompletedSize;
    }

    if(pxmp->pdwStatus)
    {
        *pxmp->pdwStatus = dwStatus;
    }
}
//@@END_MSINTERNAL

//
// XFileMediaObject
//

#undef INTERFACE
#define INTERFACE XFileMediaObject

DECLARE_INTERFACE_(XFileMediaObject, XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    // XFileMediaObject methods
    STDMETHOD(Seek)(THIS_ LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute) PURE;
    STDMETHOD(GetLength)(THIS_ LPDWORD pdwLength) PURE;
};

#define XFileMediaObject_AddRef             IUnknown_AddRef
#define XFileMediaObject_Release            IUnknown_Release

#define XFileMediaObject_GetInfo            XMediaObject_GetInfo
#define XFileMediaObject_GetStatus          XMediaObject_GetStatus
#define XFileMediaObject_Process            XMediaObject_Process
#define XFileMediaObject_Discontinuity      XMediaObject_Discontinuity
#define XFileMediaObject_Flush              XMediaObject_Flush

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XFileMediaObject_Seek(p, a, b, c)   p->Seek(a, b, c)
#define XFileMediaObject_GetLength(p, a)    p->GetLength(a)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XFileMediaObject_Seek(p, a, b, c)   p->lpVtbl->Seek(p, a, b, c)
#define XFileMediaObject_GetLength(p, a)    p->lpVtbl->GetLength(p, a)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

//
// XWaveFileMediaObject
//

#undef INTERFACE
#define INTERFACE XWaveFileMediaObject

DECLARE_INTERFACE_(XWaveFileMediaObject, XFileMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    // XFileMediaObject methods
    STDMETHOD(Seek)(THIS_ LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute) PURE;
    STDMETHOD(GetLength)(THIS_ LPDWORD pdwLength) PURE;

    // XWaveFileMediaObject methods
    STDMETHOD(GetFormat)(THIS_ LPCWAVEFORMATEX *ppwfxFormat) PURE;
    STDMETHOD(GetLoopRegion)(THIS_ LPDWORD pdwLoopStart, LPDWORD pdwLoopLength) PURE;
};

#define XFileMediaObject_AddRef             IUnknown_AddRef
#define XFileMediaObject_Release            IUnknown_Release

#define XWaveFileMediaObject_GetInfo        XFileMediaObject_GetInfo
#define XWaveFileMediaObject_GetStatus      XFileMediaObject_GetStatus
#define XWaveFileMediaObject_Process        XFileMediaObject_Process
#define XWaveFileMediaObject_Discontinuity  XFileMediaObject_Discontinuity
#define XWaveFileMediaObject_Flush          XFileMediaObject_Flush
#define XWaveFileMediaObject_Seek           XFileMediaObject_Seek
#define XWaveFileMediaObject_GetLength      XFileMediaObject_GetLength

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XWaveFileMediaObject_GetFormat(p, a)        p->GetFormat(a)
#define XWaveFileMediaObject_GetLoopRegion(p, a, b) p->GetLoopRegion(a, b)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XWaveFileMediaObject_GetFormat(p, a)        p->lpVtbl->GetFormat(p, a)
#define XWaveFileMediaObject_GetLoopRegion(p, a, b) p->lpVtbl->GetLoopRegion(p, a, b)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

//
// XWmaFileMediaObject
//

#undef INTERFACE
#define INTERFACE XWmaFileMediaObject

DECLARE_INTERFACE_(XWmaFileMediaObject, XFileMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    // XFileMediaObject methods
    STDMETHOD(Seek)(THIS_ LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute) PURE;
    STDMETHOD(GetLength)(THIS_ LPDWORD pdwLength) PURE;

    // XWmaFileMediaObject methods
    STDMETHOD(GetFileHeader)(THIS_ WMAXMOFileHeader* pFileHeader) PURE;
    STDMETHOD(GetFileContentDescription)(THIS_ WMAXMOFileContDesc* pContentDesc) PURE;
    
};

#define XWmaFileMediaObject_AddRef          IUnknown_AddRef
#define XWmaFileMediaObject_Release         IUnknown_Release

#define XWmaFileMediaObject_GetInfo         XMediaObject_GetInfo
#define XWmaFileMediaObject_GetStatus       XMediaObject_GetStatus
#define XWmaFileMediaObject_Process         XMediaObject_Process
#define XWmaFileMediaObject_Discontinuity   XMediaObject_Discontinuity
#define XWmaFileMediaObject_Flush           XMediaObject_Flush

#define XWmaFileMediaObject_Seek            XFileMediaObject_Seek
#define XWmaFileMediaObject_GetLength       XFileMediaOjbect_GetLength

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XWmaFileMediaObject_GetFileHeader(p, a)             p->GetFileHeader(a)
#define XWmaFileMediaObject_GetFileContentDescription(p, a) p->GetFileContentDescription(a)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XWmaFileMediaObject_GetFileHeader(p, a)             p->lpVtbl->GetFileHeader(p, a)
#define XWmaFileMediaObject_GetFileContentDescription(p, a) p->lpVtbl->GetFileContentDescription(p,a)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

//
// IDirectSound
//

#if defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSound_QueryInterface(LPDIRECTSOUND pDirectSound, REFIID iid, LPVOID *ppvInterface);

#else // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSound_QueryInterfaceC(LPDIRECTSOUND pDirectSound, const IID *iid, LPVOID *ppvInterface);
#define IDirectSound_QueryInterface IDirectSound_QueryInterfaceC

#endif // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI_(ULONG) IDirectSound_AddRef(LPDIRECTSOUND pDirectSound);
STDAPI_(ULONG) IDirectSound_Release(LPDIRECTSOUND pDirectSound);
STDAPI IDirectSound_GetCaps(LPDIRECTSOUND pDirectSound, LPDSCAPS pdsc);
STDAPI IDirectSound_CreateSoundBuffer(LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter);
STDAPI IDirectSound_CreateSoundStream(LPDIRECTSOUND pDirectSound, LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter);
STDAPI IDirectSound_GetSpeakerConfig(LPDIRECTSOUND pDirectSound, LPDWORD pdwSpeakerConfig);
STDAPI IDirectSound_SetCooperativeLevel(LPDIRECTSOUND pDirectSound, HWND hWnd, DWORD dwLevel);
STDAPI IDirectSound_Compact(LPDIRECTSOUND pDirectSound);
STDAPI IDirectSound_DownloadEffectsImage(LPDIRECTSOUND pDirectSound, LPCVOID pvImageBuffer, DWORD dwImageSize, LPCDSEFFECTIMAGELOC pImageLoc, LPDSEFFECTIMAGEDESC *ppImageDesc);
STDAPI IDirectSound_GetEffectData(LPDIRECTSOUND pDirectSound, DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize);
STDAPI IDirectSound_SetEffectData(LPDIRECTSOUND pDirectSound, DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwApply);
STDAPI IDirectSound_CommitEffectData(LPDIRECTSOUND pDirectSound);
STDAPI IDirectSound_EnableHeadphones(LPDIRECTSOUND pDirectSound, BOOL fEnabled);
STDAPI IDirectSound_SetMixBinHeadroom(LPDIRECTSOUND pDirectSound, DWORD dwMixBin, DWORD dwHeadroom);
STDAPI IDirectSound_SetAllParameters(LPDIRECTSOUND pDirectSound, LPCDS3DLISTENER pds3dl, DWORD dwApply);
STDAPI IDirectSound_SetOrientation(LPDIRECTSOUND pDirectSound, FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop, DWORD dwApply);
STDAPI IDirectSound_SetPosition(LPDIRECTSOUND pDirectSound, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSound_SetVelocity(LPDIRECTSOUND pDirectSound, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSound_SetDistanceFactor(LPDIRECTSOUND pDirectSound, FLOAT flDistanceFactor, DWORD dwApply);
STDAPI IDirectSound_SetDopplerFactor(LPDIRECTSOUND pDirectSound, FLOAT flDopplerFactor, DWORD dwApply);
STDAPI IDirectSound_SetRolloffFactor(LPDIRECTSOUND pDirectSound, FLOAT flRolloffFactor, DWORD dwApply);
STDAPI IDirectSound_SetI3DL2Listener(LPDIRECTSOUND pDirectSound, LPCDSI3DL2LISTENER pds3dl, DWORD dwApply);
STDAPI IDirectSound_CommitDeferredSettings(LPDIRECTSOUND pDirectSound);
STDAPI IDirectSound_GetTime(LPDIRECTSOUND pDirectSound, REFERENCE_TIME *prtCurrent);
STDAPI IDirectSound_GetOutputLevels(LPDIRECTSOUND pDirectSound, DSOUTPUTLEVELS *pOutputLevels, BOOL bResetPeakValues);

#if defined(__cplusplus) && !defined(CINTERFACE)

struct IDirectSound
{
    __inline HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return IDirectSound_QueryInterface(this, iid, ppvInterface);
    }

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectSound_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectSound_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE GetCaps(LPDSCAPS pdsc)
    {
        return IDirectSound_GetCaps(this, pdsc);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateSoundBuffer(LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter)
    {
        return IDirectSound_CreateSoundBuffer(this, pdsbd, ppBuffer, pUnkOuter);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateSoundStream(LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter)
    {
        return IDirectSound_CreateSoundStream(this, pdssd, ppStream, pUnkOuter);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSpeakerConfig(LPDWORD pdwSpeakerConfig)
    {
        return IDirectSound_GetSpeakerConfig(this, pdwSpeakerConfig);
    }

    __inline HRESULT STDMETHODCALLTYPE SetCooperativeLevel(HWND hWnd, DWORD dwLevel)
    {
        return IDirectSound_SetCooperativeLevel(this, hWnd, dwLevel);
    }

    __inline HRESULT STDMETHODCALLTYPE Compact(void)
    {
        return IDirectSound_Compact(this);
    }

    __inline HRESULT STDMETHODCALLTYPE DownloadEffectsImage(LPCVOID pvImageBuffer, DWORD dwImageSize, LPCDSEFFECTIMAGELOC pImageLoc, LPDSEFFECTIMAGEDESC *ppImageDesc)
    {
        return IDirectSound_DownloadEffectsImage(this, pvImageBuffer, dwImageSize, pImageLoc, ppImageDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE GetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize)
    {
        return IDirectSound_GetEffectData(this, dwEffectIndex, dwOffset, pvData, dwDataSize);
    }

    __inline HRESULT STDMETHODCALLTYPE SetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwApply)
    {
        return IDirectSound_SetEffectData(this, dwEffectIndex, dwOffset, pvData, dwDataSize, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE CommitEffectData(void)
    {
        return IDirectSound_CommitEffectData(this);
    }

    __inline HRESULT STDMETHODCALLTYPE EnableHeadphones(BOOL fEnabled)
    {
        return IDirectSound_EnableHeadphones(this, fEnabled);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBinHeadroom(DWORD dwMixBin, DWORD dwHeadroom)
    {
        return IDirectSound_SetMixBinHeadroom(this, dwMixBin, dwHeadroom);
    }

    __inline HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DLISTENER pds3dl, DWORD dwApply)
    {
        return IDirectSound_SetAllParameters(this, pds3dl, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwApply)
    {
        return IDirectSound_SetDistanceFactor(this, flDistanceFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwApply)
    {
        return IDirectSound_SetDopplerFactor(this, flDopplerFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetOrientation(FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop, DWORD dwApply)
    {
        return IDirectSound_SetOrientation(this, xFront, yFront, zFront, xTop, yTop, zTop, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSound_SetPosition(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwApply)
    {
        return IDirectSound_SetRolloffFactor(this, flRolloffFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSound_SetVelocity(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetI3DL2Listener(LPCDSI3DL2LISTENER pds3dl, DWORD dwApply)
    {
        return IDirectSound_SetI3DL2Listener(this, pds3dl, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE CommitDeferredSettings(void)
    {
        return IDirectSound_CommitDeferredSettings(this);
    }

    __inline HRESULT STDMETHODCALLTYPE GetTime(REFERENCE_TIME *prtCurrent)
    {
        return IDirectSound_GetTime(this, prtCurrent);
    }

    __inline HRESULT STDMETHODCALLTYPE GetOutputLevels(DSOUTPUTLEVELS *pOutputLevels, BOOL bResetPeakValues)
    {
        return IDirectSound_GetOutputLevels(this, pOutputLevels, bResetPeakValues);
    }

};

#endif // defined(__cplusplus) && !defined(CINTERFACE)

#define IDirectSound8_QueryInterface                        IDirectSound_QueryInterface
#define IDirectSound8_AddRef                                IDirectSound_AddRef
#define IDirectSound8_Release                               IDirectSound_Release
#define IDirectSound8_GetCaps                               IDirectSound_GetCaps
#define IDirectSound8_CreateSoundBuffer                     IDirectSound_CreateSoundBuffer
#define IDirectSound8_GetSpeakerConfig                      IDirectSound_GetSpeakerConfig
#define IDirectSound8_Compact                               IDirectSound_Compact
#define IDirectSound8_SetCooperativeLevel                   IDirectSound_SetCooperativeLevel

#define IDirectSound3DListener_QueryInterface               IDirectSound_QueryInterface
#define IDirectSound3DListener_AddRef                       IDirectSound_AddRef
#define IDirectSound3DListener_Release                      IDirectSound_Release
#define IDirectSound3DListener_SetAllParameters             IDirectSound_SetAllParameters
#define IDirectSound3DListener_SetDistanceFactor            IDirectSound_SetDistanceFactor
#define IDirectSound3DListener_SetDopplerFactor             IDirectSound_SetDopplerFactor
#define IDirectSound3DListener_SetOrientation               IDirectSound_SetOrientation
#define IDirectSound3DListener_SetPosition                  IDirectSound_SetPosition
#define IDirectSound3DListener_SetRolloffFactor             IDirectSound_SetRolloffFactor
#define IDirectSound3DListener_SetVelocity                  IDirectSound_SetVelocity
#define IDirectSound3DListener_CommitDeferredSettings       IDirectSound_CommitDeferredSettings

#define IReferenceClock_QueryInterface                      IDirectSound_QueryInterface
#define IReferenceClock_AddRef                              IDirectSound_AddRef
#define IReferenceClock_Release                             IDirectSound_Release
#define IReferenceClock_GetTime                             IDirectSound_GetTime

//
// IDirectSoundBuffer
//

#if defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundBuffer_QueryInterface(LPDIRECTSOUNDBUFFER pBuffer, REFIID iid, LPVOID *ppvInterface);

#else // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundBuffer_QueryInterfaceC(LPDIRECTSOUNDBUFFER pBuffer, const IID *iid, LPVOID *ppvInterface);
#define IDirectSoundBuffer_QueryInterface IDirectSoundBuffer_QueryInterfaceC

#endif // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI_(ULONG) IDirectSoundBuffer_AddRef(LPDIRECTSOUNDBUFFER pBuffer);
STDAPI_(ULONG) IDirectSoundBuffer_Release(LPDIRECTSOUNDBUFFER pBuffer);
STDAPI IDirectSoundBuffer_SetFormat(LPDIRECTSOUNDBUFFER pBuffer, LPCWAVEFORMATEX pwfxFormat);
STDAPI IDirectSoundBuffer_SetFrequency(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwFrequency);
STDAPI IDirectSoundBuffer_SetVolume(LPDIRECTSOUNDBUFFER pBuffer, LONG lVolume);
STDAPI IDirectSoundBuffer_SetPitch(LPDIRECTSOUNDBUFFER pBuffer, LONG lPitch);
STDAPI IDirectSoundBuffer_SetLFO(LPDIRECTSOUNDBUFFER pBuffer, LPCDSLFODESC pLFODesc);
STDAPI IDirectSoundBuffer_SetEG(LPDIRECTSOUNDBUFFER pBuffer, LPCDSENVELOPEDESC pEnvelopeDesc);
STDAPI IDirectSoundBuffer_SetFilter(LPDIRECTSOUNDBUFFER pBuffer, LPCDSFILTERDESC pFilterDesc);
STDAPI IDirectSoundBuffer_SetHeadroom(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwHeadroom);
STDAPI IDirectSoundBuffer_SetOutputBuffer(LPDIRECTSOUNDBUFFER pBuffer, LPDIRECTSOUNDBUFFER pOutputBuffer);
STDAPI IDirectSoundBuffer_SetMixBins(LPDIRECTSOUNDBUFFER pBuffer, LPCDSMIXBINS pMixBins);
STDAPI IDirectSoundBuffer_SetMixBinVolumes(LPDIRECTSOUNDBUFFER pBuffer, LPCDSMIXBINS pMixBins);
STDAPI IDirectSoundBuffer_SetAllParameters(LPDIRECTSOUNDBUFFER pBuffer, LPCDS3DBUFFER pds3db, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetConeAngles(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetConeOrientation(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetConeOutsideVolume(LPDIRECTSOUNDBUFFER pBuffer, LONG lConeOutsideVolume, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetMaxDistance(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flMaxDistance, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetMinDistance(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flMinDistance, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetMode(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwMode, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetPosition(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetVelocity(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetDistanceFactor(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flDistanceFactor, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetDopplerFactor(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flDopplerFactor, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetRolloffFactor(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flRolloffFactor, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetRolloffCurve(LPDIRECTSOUNDBUFFER pBuffer, const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetI3DL2Source(LPDIRECTSOUNDBUFFER pBuffer, LPCDSI3DL2BUFFER pds3db, DWORD dwApply);
STDAPI IDirectSoundBuffer_Play(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags);
STDAPI IDirectSoundBuffer_PlayEx(LPDIRECTSOUNDBUFFER pBuffer, REFERENCE_TIME rtTimeStamp, DWORD dwFlags);
STDAPI IDirectSoundBuffer_Stop(LPDIRECTSOUNDBUFFER pBuffer);
STDAPI IDirectSoundBuffer_StopEx(LPDIRECTSOUNDBUFFER pBuffer, REFERENCE_TIME rtTimeStamp, DWORD dwFlags);
STDAPI IDirectSoundBuffer_SetPlayRegion(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwPlayStart, DWORD dwPlayLength);
STDAPI IDirectSoundBuffer_SetLoopRegion(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwLoopStart, DWORD dwLoopLength);
STDAPI IDirectSoundBuffer_GetStatus(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwStatus);
STDAPI IDirectSoundBuffer_GetCurrentPosition(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor);
STDAPI IDirectSoundBuffer_SetCurrentPosition(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwPlayCursor);
STDAPI IDirectSoundBuffer_SetBufferData(LPDIRECTSOUNDBUFFER pBuffer, LPVOID pvBufferData, DWORD dwBufferBytes);
STDAPI IDirectSoundBuffer_Lock(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags);
STDAPI IDirectSoundBuffer_Unlock(LPDIRECTSOUNDBUFFER pBuffer, LPVOID pvLock1, DWORD dwLockSize1, LPVOID pvLock2, DWORD dwLockSize2);
STDAPI IDirectSoundBuffer_Restore(LPDIRECTSOUNDBUFFER pBuffer);
STDAPI IDirectSoundBuffer_SetNotificationPositions(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies);

#if defined(__cplusplus) && !defined(CINTERFACE)                

struct IDirectSoundBuffer
{
    __inline HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return IDirectSoundBuffer_QueryInterface(this, iid, ppvInterface);
    }

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectSoundBuffer_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectSoundBuffer_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFormat(LPCWAVEFORMATEX pwfxFormat)
    {
        return IDirectSoundBuffer_SetFormat(this, pwfxFormat);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFrequency(DWORD dwFrequency)
    {
        return IDirectSoundBuffer_SetFrequency(this, dwFrequency);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVolume(LONG lVolume)
    {
        return IDirectSoundBuffer_SetVolume(this, lVolume);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPitch(LONG lPitch)
    {
        return IDirectSoundBuffer_SetPitch(this, lPitch);
    }

    __inline HRESULT STDMETHODCALLTYPE SetLFO(LPCDSLFODESC pLFODesc)
    {
        return IDirectSoundBuffer_SetLFO(this, pLFODesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetEG(LPCDSENVELOPEDESC pEnvelopeDesc)
    {
        return IDirectSoundBuffer_SetEG(this, pEnvelopeDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFilter(LPCDSFILTERDESC pFilterDesc)
    {
        return IDirectSoundBuffer_SetFilter(this, pFilterDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetHeadroom(DWORD dwHeadroom)
    {
        return IDirectSoundBuffer_SetHeadroom(this, dwHeadroom);
    }

    __inline HRESULT STDMETHODCALLTYPE SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer)
    {
        return IDirectSoundBuffer_SetOutputBuffer(this, pOutputBuffer);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBins(LPCDSMIXBINS pMixBins)
    {
        return IDirectSoundBuffer_SetMixBins(this, pMixBins);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBinVolumes(LPCDSMIXBINS pMixBins)
    {
        return IDirectSoundBuffer_SetMixBinVolumes(this, pMixBins);
    }

    __inline HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetAllParameters(this, pds3db, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetConeAngles(this, dwInsideConeAngle, dwOutsideConeAngle, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetConeOrientation(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetConeOutsideVolume(this, lConeOutsideVolume, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMaxDistance(FLOAT flMaxDistance, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetMaxDistance(this, flMaxDistance, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMinDistance(FLOAT flMinDistance, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetMinDistance(this, flMinDistance, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMode(DWORD dwMode, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetMode(this, dwMode, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetPosition(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetVelocity(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetDistanceFactor(this, flDistanceFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetDopplerFactor(this, flDopplerFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetRolloffFactor(this, flRolloffFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetRolloffCurve(const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetRolloffCurve(this, pflPoints, dwPointCount, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetI3DL2Source(this, pds3db, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE Play(DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags)
    {   
        return IDirectSoundBuffer_Play(this, dwReserved1, dwReserved2, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE PlayEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
    {
        return IDirectSoundBuffer_PlayEx(this, rtTimeStamp, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Stop(void)
    {
        return IDirectSoundBuffer_Stop(this);
    }

    __inline HRESULT STDMETHODCALLTYPE StopEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
    {
        return IDirectSoundBuffer_StopEx(this, rtTimeStamp, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPlayRegion(DWORD dwPlayStart, DWORD dwPlayLength)
    {
        return IDirectSoundBuffer_SetPlayRegion(this, dwPlayStart, dwPlayLength);
    }

    __inline HRESULT STDMETHODCALLTYPE SetLoopRegion(DWORD dwLoopStart, DWORD dwLoopLength)
    {
        return IDirectSoundBuffer_SetLoopRegion(this, dwLoopStart, dwLoopLength);
    }

    __inline HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus)
    {
        return IDirectSoundBuffer_GetStatus(this, pdwStatus);
    }

    __inline HRESULT STDMETHODCALLTYPE GetCurrentPosition(LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor)
    {
        return IDirectSoundBuffer_GetCurrentPosition(this, pdwPlayCursor, pdwWriteCursor);
    }

    __inline HRESULT STDMETHODCALLTYPE SetCurrentPosition(DWORD dwPlayCursor)
    {
        return IDirectSoundBuffer_SetCurrentPosition(this, dwPlayCursor);
    }

    __inline HRESULT STDMETHODCALLTYPE SetBufferData(LPVOID pvBufferData, DWORD dwBufferBytes)
    {
        return IDirectSoundBuffer_SetBufferData(this, pvBufferData, dwBufferBytes);
    }

    __inline HRESULT STDMETHODCALLTYPE Lock(DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
    {
        return IDirectSoundBuffer_Lock(this, dwOffset, dwBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Unlock(LPVOID pvLock1, DWORD dwLockSize1, LPVOID pvLock2, DWORD dwLockSize2)
    {
        return IDirectSoundBuffer_Unlock(this, pvLock1, dwLockSize1, pvLock2, dwLockSize2);
    }

    __inline HRESULT STDMETHODCALLTYPE Restore(void)
    {
        return IDirectSoundBuffer_Restore(this);
    }

    __inline HRESULT STDMETHODCALLTYPE SetNotificationPositions(DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies)
    {
        return IDirectSoundBuffer_SetNotificationPositions(this, dwNotifyCount, paNotifies);
    }
};

#endif // defined(__cplusplus) && !defined(CINTERFACE)                

#define IDirectSoundBuffer8_QueryInterface          IDirectSoundBuffer_QueryInterface
#define IDirectSoundBuffer8_AddRef                  IDirectSoundBuffer_AddRef
#define IDirectSoundBuffer8_Release                 IDirectSoundBuffer_Release
#define IDirectSoundBuffer8_SetFormat               IDirectSoundBuffer_SetFormat
#define IDirectSoundBuffer8_Play                    IDirectSoundBuffer_Play              
#define IDirectSoundBuffer8_Stop                    IDirectSoundBuffer_Stop              
#define IDirectSoundBuffer8_GetStatus               IDirectSoundBuffer_GetStatus         
#define IDirectSoundBuffer8_GetCurrentPosition      IDirectSoundBuffer_GetCurrentPosition
#define IDirectSoundBuffer8_SetCurrentPosition      IDirectSoundBuffer_SetCurrentPosition
#define IDirectSoundBuffer8_Lock                    IDirectSoundBuffer_Lock              
#define IDirectSoundBuffer8_SetFrequency            IDirectSoundBuffer_SetFrequency
#define IDirectSoundBuffer8_SetVolume               IDirectSoundBuffer_SetVolume         
                                                    
#define IDirectSound3DBuffer_QueryInterface         IDirectSoundBuffer_QueryInterface
#define IDirectSound3DBuffer_AddRef                 IDirectSoundBuffer_AddRef
#define IDirectSound3DBuffer_Release                IDirectSoundBuffer_Release
#define IDirectSound3DBuffer_SetAllParameters       IDirectSoundBuffer_SetAllParameters  
#define IDirectSound3DBuffer_SetConeAngles          IDirectSoundBuffer_SetConeAngles     
#define IDirectSound3DBuffer_SetConeOrientation     IDirectSoundBuffer_SetConeOrientation
#define IDirectSound3DBuffer_SetConeOutsideVolume   IDirectSoundBuffer_SetConeOutsideVolume
#define IDirectSound3DBuffer_SetMaxDistance         IDirectSoundBuffer_SetMaxDistance    
#define IDirectSound3DBuffer_SetMinDistance         IDirectSoundBuffer_SetMinDistance    
#define IDirectSound3DBuffer_SetMode                IDirectSoundBuffer_SetMode           
#define IDirectSound3DBuffer_SetPosition            IDirectSoundBuffer_SetPosition       
#define IDirectSound3DBuffer_SetVelocity            IDirectSoundBuffer_SetVelocity       
                                                    
#define IDirectSoundNotify_QueryInterface           IDirectSoundBuffer_QueryInterface
#define IDirectSoundNotify_AddRef                   IDirectSoundBuffer_AddRef
#define IDirectSoundNotify_Release                  IDirectSoundBuffer_Release
#define IDirectSoundNotify_SetNotificationPositions IDirectSoundBuffer_SetNotificationPositions

//
// IDirectSoundStream
//

#if defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundStream_QueryInterface(LPDIRECTSOUNDSTREAM pStream, REFIID iid, LPVOID *ppvInterface);

#else // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundStream_QueryInterfaceC(LPDIRECTSOUNDSTREAM pStream, const IID *iid, LPVOID *ppvInterface);
#define IDirectSoundStream_QueryInterface IDirectSoundStream_QueryInterfaceC

#endif // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundStream_SetFormat(LPDIRECTSOUNDSTREAM pStream, LPCWAVEFORMATEX pwfxFormat);
STDAPI IDirectSoundStream_SetFrequency(LPDIRECTSOUNDSTREAM pStream, DWORD dwFrequency);
STDAPI IDirectSoundStream_SetVolume(LPDIRECTSOUNDSTREAM pStream, LONG lVolume);
STDAPI IDirectSoundStream_SetPitch(LPDIRECTSOUNDSTREAM pStream, LONG lPitch);
STDAPI IDirectSoundStream_SetLFO(LPDIRECTSOUNDSTREAM pStream, LPCDSLFODESC pLFODesc);
STDAPI IDirectSoundStream_SetEG(LPDIRECTSOUNDSTREAM pStream, LPCDSENVELOPEDESC pEnvelopeDesc);
STDAPI IDirectSoundStream_SetFilter(LPDIRECTSOUNDSTREAM pStream, LPCDSFILTERDESC pFilterDesc);
STDAPI IDirectSoundStream_SetHeadroom(LPDIRECTSOUNDSTREAM pStream, DWORD dwHeadroom);
STDAPI IDirectSoundStream_SetOutputBuffer(LPDIRECTSOUNDSTREAM pStream, LPDIRECTSOUNDBUFFER pOutputBuffer);
STDAPI IDirectSoundStream_SetMixBins(LPDIRECTSOUNDSTREAM pStream, LPCDSMIXBINS pMixBins);
STDAPI IDirectSoundStream_SetMixBinVolumes(LPDIRECTSOUNDSTREAM pStream, LPCDSMIXBINS pMixBins);
STDAPI IDirectSoundStream_SetAllParameters(LPDIRECTSOUNDSTREAM pStream, LPCDS3DBUFFER pds3db, DWORD dwApply);
STDAPI IDirectSoundStream_SetConeAngles(LPDIRECTSOUNDSTREAM pStream, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply);
STDAPI IDirectSoundStream_SetConeOrientation(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundStream_SetConeOutsideVolume(LPDIRECTSOUNDSTREAM pStream, LONG lConeOutsideVolume, DWORD dwApply);
STDAPI IDirectSoundStream_SetMaxDistance(LPDIRECTSOUNDSTREAM pStream, FLOAT flMaxDistance, DWORD dwApply);
STDAPI IDirectSoundStream_SetMinDistance(LPDIRECTSOUNDSTREAM pStream, FLOAT flMinDistance, DWORD dwApply);
STDAPI IDirectSoundStream_SetMode(LPDIRECTSOUNDSTREAM pStream, DWORD dwMode, DWORD dwApply);
STDAPI IDirectSoundStream_SetPosition(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundStream_SetVelocity(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundStream_SetDistanceFactor(LPDIRECTSOUNDSTREAM pStream, FLOAT flDistanceFactor, DWORD dwApply);
STDAPI IDirectSoundStream_SetDopplerFactor(LPDIRECTSOUNDSTREAM pStream, FLOAT flDopplerFactor, DWORD dwApply);
STDAPI IDirectSoundStream_SetRolloffFactor(LPDIRECTSOUNDSTREAM pStream, FLOAT flRolloffFactor, DWORD dwApply);
STDAPI IDirectSoundStream_SetRolloffCurve(LPDIRECTSOUNDSTREAM pStream, const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwApply);
STDAPI IDirectSoundStream_SetI3DL2Source(LPDIRECTSOUNDSTREAM pStream, LPCDSI3DL2BUFFER pds3db, DWORD dwApply);
STDAPI IDirectSoundStream_Pause(LPDIRECTSOUNDSTREAM pStream, DWORD dwPause);
STDAPI IDirectSoundStream_PauseEx(LPDIRECTSOUNDSTREAM pStream, REFERENCE_TIME rtTimestamp, DWORD dwPause);
STDAPI IDirectSoundStream_FlushEx(LPDIRECTSOUNDSTREAM pStream, REFERENCE_TIME rtTimeStamp, DWORD dwFlags);

#define IDirectSoundStream_AddRef           IUnknown_AddRef
#define IDirectSoundStream_Release          IUnknown_Release

#define IDirectSoundStream_GetInfo          XMediaObject_GetInfo
#define IDirectSoundStream_GetStatus        XMediaObject_GetStatus
#define IDirectSoundStream_Process          XMediaObject_Process
#define IDirectSoundStream_Discontinuity    XMediaObject_Discontinuity
#define IDirectSoundStream_Flush            XMediaObject_Flush

#undef INTERFACE
#define INTERFACE IDirectSoundStream

DECLARE_INTERFACE_(IDirectSoundStream, XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

#if defined(__cplusplus) && !defined(CINTERFACE)

    __inline HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return IDirectSoundStream_QueryInterface(this, iid, ppvInterface);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFormat(LPCWAVEFORMATEX pwfxFormat)
    {
        return IDirectSoundStream_SetFormat(this, pwfxFormat);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFrequency(DWORD dwFrequency)
    {
        return IDirectSoundStream_SetFrequency(this, dwFrequency);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVolume(LONG lVolume)
    {
        return IDirectSoundStream_SetVolume(this, lVolume);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPitch(LONG lPitch)
    {
        return IDirectSoundStream_SetPitch(this, lPitch);
    }

    __inline HRESULT STDMETHODCALLTYPE SetLFO(LPCDSLFODESC pLFODesc)
    {
        return IDirectSoundStream_SetLFO(this, pLFODesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetEG(LPCDSENVELOPEDESC pEnvelopeDesc)
    {
        return IDirectSoundStream_SetEG(this, pEnvelopeDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFilter(LPCDSFILTERDESC pFilterDesc)
    {
        return IDirectSoundStream_SetFilter(this, pFilterDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetHeadroom(DWORD dwHeadroom)
    {
        return IDirectSoundStream_SetHeadroom(this, dwHeadroom);
    }

    __inline HRESULT STDMETHODCALLTYPE SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer)
    {
        return IDirectSoundStream_SetOutputBuffer(this, pOutputBuffer);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBins(LPCDSMIXBINS pMixBins)
    {
        return IDirectSoundStream_SetMixBins(this, pMixBins);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBinVolumes(LPCDSMIXBINS pMixBins)
    {
        return IDirectSoundStream_SetMixBinVolumes(this, pMixBins);
    }

    __inline HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwApply)
    {
        return IDirectSoundStream_SetAllParameters(this, pds3db, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply)
    {
        return IDirectSoundStream_SetConeAngles(this, dwInsideConeAngle, dwOutsideConeAngle, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundStream_SetConeOrientation(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwApply)
    {
        return IDirectSoundStream_SetConeOutsideVolume(this, lConeOutsideVolume, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMaxDistance(FLOAT flMaxDistance, DWORD dwApply)
    {
        return IDirectSoundStream_SetMaxDistance(this, flMaxDistance, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMinDistance(FLOAT flMinDistance, DWORD dwApply)
    {
        return IDirectSoundStream_SetMinDistance(this, flMinDistance, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMode(DWORD dwMode, DWORD dwApply)
    {
        return IDirectSoundStream_SetMode(this, dwMode, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundStream_SetPosition(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundStream_SetVelocity(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwApply)
    {
        return IDirectSoundStream_SetDistanceFactor(this, flDistanceFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwApply)
    {
        return IDirectSoundStream_SetDopplerFactor(this, flDopplerFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwApply)
    {
        return IDirectSoundStream_SetRolloffFactor(this, flRolloffFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetRolloffCurve(const FLOAT *pflPoints, DWORD dwPointCount, DWORD dwApply)
    {
        return IDirectSoundStream_SetRolloffCurve(this, pflPoints, dwPointCount, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwApply)
    {
        return IDirectSoundStream_SetI3DL2Source(this, pds3db, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE Pause(DWORD dwPause)
    {
        return IDirectSoundStream_Pause(this, dwPause);
    }

    __inline HRESULT STDMETHODCALLTYPE PauseEx(REFERENCE_TIME rtTimestamp, DWORD dwPause)
    {
        return IDirectSoundStream_PauseEx(this, rtTimestamp, dwPause);
    }

    __inline HRESULT STDMETHODCALLTYPE FlushEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
    {
        return IDirectSoundStream_FlushEx(this, rtTimeStamp, dwFlags);
    }

#endif // defined(__cplusplus) && !defined(CINTERFACE)

};

//
// XAc97MediaObject
//

#undef INTERFACE
#define INTERFACE XAc97MediaObject

DECLARE_INTERFACE_(XAc97MediaObject, XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    // XAc97MediaObject methods
    STDMETHOD(SetMode)(THIS_ DWORD dwMode) PURE;
    STDMETHOD(GetCurrentPosition)(THIS_ LPDWORD pdwMode) PURE;
};

#define XAc97MediaObject_AddRef                     IUnknown_AddRef
#define XAc97MediaObject_Release                    IUnknown_Release
                                                    
#define XAc97MediaObject_GetInfo                    XMediaObject_GetInfo
#define XAc97MediaObject_GetStatus                  XMediaObject_GetStatus
#define XAc97MediaObject_Process                    XMediaObject_Process
#define XAc97MediaObject_Discontinuity              XMediaObject_Discontinuity
#define XAc97MediaObject_Flush                      XMediaObject_Flush

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XAc97MediaObject_SetMode(p, a)              p->SetMode(a)
#define XAc97MediaObject_GetCurrentPosition(p, a)   p->GetCurrentPosition(a)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XAc97MediaObject_SetMode(p, a)              p->lpVtbl->SetMode(p, a)
#define XAc97MediaObject_GetCurrentPosition(p, a)   p->lpVtbl->GetCurrentPosition(p, a)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

//
// Multimedia timer support
//

#define MMSYSERR_BASE               0
#define MMSYSERR_NOERROR            0                   // No error

#define TIMERR_BASE                 96
#define TIMERR_NOERROR              (0)                 // No error
#define TIMERR_NOCANDO              (TIMERR_BASE+1)     // Request not completed
#define TIMERR_STRUCT               (TIMERR_BASE+33)    // Time struct size

#define TIME_MS                     0x0001              // Time in milliseconds
#define TIME_SAMPLES                0x0002              // Number of wave samples
#define TIME_BYTES                  0x0004              // Current byte offset
#define TIME_SMPTE                  0x0008              // SMPTE time
#define TIME_MIDI                   0x0010              // MIDI time
#define TIME_TICKS                  0x0020              // Ticks within MIDI stream

#define TIME_ONESHOT                0x0000              // Program timer for single event
#define TIME_PERIODIC               0x0001              // Program for continuous periodic event

#define TIME_CALLBACK_FUNCTION      0x0000              // Callback is function
#define TIME_CALLBACK_EVENT_SET     0x0010              // Callback is event - use SetEvent
#define TIME_CALLBACK_EVENT_PULSE   0x0020              // Callback is event - use PulseEvent

typedef void (CALLBACK TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);

typedef TIMECALLBACK *LPTIMECALLBACK;

typedef struct mmtime_tag
{
    UINT            wType;                  // Indicates the contents of the union
    union
    {
        DWORD       ms;                     // Milliseconds
        DWORD       sample;                 // Samples
        DWORD       cb;                     // Byte count
        DWORD       ticks;                  // Ticks in MIDI stream

        struct
        {
            BYTE    hour;                   // Hours
            BYTE    min;                    // Minutes
            BYTE    sec;                    // Seconds
            BYTE    frame;                  // Frames
            BYTE    fps;                    // Frames per second
            BYTE    dummy;                  // Pad
            BYTE    pad[2];
        } smpte;

        struct
        {
            DWORD songptrpos;               // Song pointer position
        } midi;
    } u;
} MMTIME, *PMMTIME, *LPMMTIME;

typedef const MMTIME *LPCMMTIME;

typedef UINT MMRESULT;

EXTERN_C MMRESULT WINAPI timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt);
EXTERN_C MMRESULT WINAPI timeSetEvent(UINT uDelay, UINT uResolution, LPTIMECALLBACK fptc, DWORD dwUser, UINT fuEvent);
EXTERN_C MMRESULT WINAPI timeKillEvent(UINT uTimerID);

#define timeGetTime GetTickCount

#pragma warning(default:4201)

#endif // __DSOUND_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\err.h ===
/***********************************************************************
//
// ERR.H
//
//		Copyright (c) 1992-1998 Microsoft Corp.
//		All rights reserved.
//		Microsoft Confidential
//
// Error values for file engine functions.
//
// johnhe - 03-13-92
***********************************************************************/

//**********************************************************************
//	Parsing errors
//**********************************************************************

#define	ERR_UNKNOWN					-1		// Unknown error
#define	ERR_UNKNOWN_SWITCH		-2		// Unknown criteria switch was specified
#define	ERR_NO_END_SEARCHSTR		-3		// No end search string delimiter
#define	ERR_DATE_FORMAT			-4		// Invalid date format
#define	ERR_TIME_FORMAT			-5		// Invalid time format
#define	ERR_DATE_COMBO				-6		// Invalid date combination
#define	ERR_SIZE_FORMAT			-7		// Invalid size format
#define	ERR_SIZE_COMBO				-8		// Invalid size combination
#define	ERR_ATTR_FORMAT			-9		// Invalid attribute format
#define	ERR_ATTR_COMBO				-10	// Invalid attribute combination
#define	ERR_MULT_SRCHSTR			-11	// Multiple search strings specified
#define	ERR_STRLST_LEN				-12	// Search string length is too long
#define	ERR_SRCH_EXPRESSION		-13	// Invalid search expression

#define	ERR_DUP_DESTINATION		-14	// Duplicate destination file specs
#define	ERR_SWITCH_COMBO			-15	// Invalid switch combination
#define	ERR_NO_SOURCE				-16	// No source filespec given
#define	ERR_NOT_ON_NAME			-17	// /NOT was applied to single filename

#define	ERR_FILESPEC_LEN			-18	// More than 1K of filespec strings
#define	ERR_NOT_FILE_LEN			-19	// More than 1K of !filespec strings

#define	ERR_INVALID_SRC_PATH		-20	// Invalid source path (not found)

#define	ERR_SOURCE_ISDEVICE		-21	// Source filespec is reserved device
#define	ERR_DEST_ISDEVICE			-22	// Dest. filespec is reserved device
#define	ERR_NO_DESTINATION		-23	// No destination was specified
#define	ERR_INVALID_PARAMETR		-24	// Extra parameter on cmd line

//**********************************************************************
//	System errors
//**********************************************************************

#define	ERR_NOMEMORY				-25	// Insuffient memory error
#define	ERR_MEM_CORRUPT			-26	// Error returned on MemFree()
#define	ERR_USER_ABORT				-27	// User aborted (CTRL+C)
#define	ERR_NOT_SUPPORTED			-28	// Unsupported callback request
#define	ERR_COLLATE_TABLE			-29	// Error on DOS call get collate table

//**********************************************************************
//	File or disk errors
//**********************************************************************

#define	ERR_BAD_FILESPEC			-50	// Bad file specification
#define	ERR_DIR_CREATE				-51	// Error creating a subdirectory entry
#define	ERR_FILE_READ				-52	// Error reading a file
#define	ERR_INVALID_DRIVE			-53	// Invalid drive specification
#define	ERR_INVALID_DESTINATION	-54	// Invalid destination filespec

//**********************************************************************
//	Copy errors
//**********************************************************************

#define	ERR_CPY_OVER_SELF			-75	// File cannot be copied over itself
#define	ERR_CLEAR_ARCHIVE			-76	// Error clearing file's archive bit
#define	ERR_RDONLY_DESTINATION	-77	// Destination file is readonly
#define	ERR_CYLINDRIC_COPY		-79	// Destination path is child of source

//**********************************************************************
//	Errors accessing a specified list file
//**********************************************************************

#define	ERR_FILELIST				-80	// Unknown error accessing the file list
#define	ERR_BAD_LISTFILE			-81	// File list was not found
#define	ERR_FILELIST_ACCESS		-82	// Sharing error accessing file list

//**********************************************************************
//	Resource load errors
//**********************************************************************

#define	ERR_READING_MSG			-100	// Error reading string resource
#define	ERR_MSG_LOADED				-101	// Strings have already been loaded

//**********************************************************************
//	Misc error values
//**********************************************************************

#define	ERR_DO_HELP					ERR_NO_SOURCE	// Display help
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dsfxparmp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsfxparm.h
 *  Content:    DirectSound effect parameters.
//@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/01/00    dereks  Created.
//@@END_MSINTERNAL
 *
 ****************************************************************************/

#ifndef __DSFXPARM_H__
#define __DSFXPARM_H__

//
// data structs describing effect state parameters
// The generated header from xgpimage will contain these for each
// effect in the image and all of their parameters
//

#define DSFX_PARAM_TYPE_INTEGER    0x1
#define DSFX_PARAM_TYPE_FLOAT      0x2

typedef struct _FX_PARAM_DESCRIPTION {

    BYTE  ParameterName[255];
	BYTE  ParameterDesc[255];
    BYTE  UnitsName[64];
	DWORD dwOffset;
	DWORD dwDefaultValue;
    DWORD dwParameterType;
    DWORD dwParameterMin;
    DWORD dwParameterMax;
    BOOL  bIsAtomic;

} FX_PARAM_DESCRIPTION, *PFX_PARAM_DESCRIPTION;


typedef struct _FX_STATE_PARAMETERS {

    BYTE  EffectName[255];
    DWORD dwNumParams;
    FX_PARAM_DESCRIPTION aParamDescriptions[1];

} FX_STATE_PARAMETERS, *PFX_STATE_PARAMETERS;

//
// State flags
//

#define DSFX_STATE_INITIALIZED  0x00000001
#define DSFX_STATE_GLOBAL       0x00000002
#define DSFX_STATE_UPDATE       0x00000004

//
// Amplitude modulation (mono)
//

typedef struct _DSFX_AMPMOD_MONO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_AMPMOD_MONO_STATE, *LPDSFX_AMPMOD_MONO_STATE;

typedef const DSFX_AMPMOD_MONO_STATE *LPCDSFX_AMPMOD_MONO_STATE;

typedef struct _DSFX_AMPMOD_MONO_PARAMS
{
    DSFX_AMPMOD_MONO_STATE  State;
} DSFX_AMPMOD_MONO_PARAMS, *LPDSFX_AMPMOD_MONO_PARAMS;

typedef const DSFX_AMPMOD_MONO_PARAMS *LPCDSFX_AMPMOD_MONO_PARAMS;

//
// Amplitude modulation (stereo)
//

typedef struct _DSFX_AMPMOD_STEREO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[3];
    DWORD       dwOutMixbinPtrs[2];
} DSFX_AMPMOD_STEREO_STATE, *LPDSFX_AMPMOD_STEREO_STATE;

typedef const DSFX_AMPMOD_STEREO_STATE *LPCDSFX_AMPMOD_STEREO_STATE;

typedef struct _DSFX_AMPMOD_STEREO_PARAMS
{
    DSFX_AMPMOD_STEREO_STATE    State;
} DSFX_AMPMOD_STEREO_PARAMS, *LPDSFX_AMPMOD_STEREO_PARAMS;

typedef const DSFX_AMPMOD_STEREO_PARAMS *LPCDSFX_AMPMOD_STEREO_PARAMS;

//
// Chorus (mono)
//

typedef struct _DSFX_CHORUS_MONO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_CHORUS_MONO_STATE, *LPDSFX_CHORUS_MONO_STATE;

typedef const DSFX_CHORUS_MONO_STATE *LPCDSFX_CHORUS_MONO_STATE;

typedef struct _DSFX_CHORUS_MONO_PARAMS
{
    DSFX_CHORUS_MONO_STATE  State;
    DWORD                   dwGain;
    DWORD                   dwModScale;
} DSFX_CHORUS_MONO_PARAMS, *LPDSFX_CHORUS_MONO_PARAMS;

typedef const DSFX_CHORUS_MONO_PARAMS *LPCDSFX_CHORUS_MONO_PARAMS;

//
// Chorus (stereo)
//

typedef struct _DSFX_CHORUS_STEREO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[3];
    DWORD       dwOutMixbinPtrs[2];
} DSFX_CHORUS_STEREO_STATE, *LPDSFX_CHORUS_STEREO_STATE;

typedef const DSFX_CHORUS_STEREO_STATE *LPCDSFX_CHORUS_STEREO_STATE;

typedef struct _DSFX_CHORUS_STEREO_PARAMS
{
    DSFX_CHORUS_STEREO_STATE    State;
    DWORD                       dwGain;
    DWORD                       dwModScale;
} DSFX_CHORUS_STEREO_PARAMS, *LPDSFX_CHORUS_STEREO_PARAMS;

typedef const DSFX_CHORUS_STEREO_PARAMS *LPCDSFX_CHORUS_STEREO_PARAMS;
//@@BEGIN_MSINTERNAL

//
// Crosstalk cancellation
//

typedef struct _DSFX_CROSSTALK_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[4];
    DWORD       dwOutMixbinPtrs[4];
} DSFX_CROSSTALK_STATE, *LPDSFX_CROSSTALK_STATE;

typedef const DSFX_CROSSTALK_STATE *LPCDSFX_CROSSTALK_STATE;

typedef struct _DSFX_CROSSTALK_PARAMS
{
    DSFX_CROSSTALK_STATE    State;
} DSFX_CROSSTALK_PARAMS, *LPDSFX_CROSSTALK_PARAMS;

typedef const DSFX_CROSSTALK_PARAMS *LPCDSFX_CROSSTALK_PARAMS;
//@@END_MSINTERNAL

//
// Distortion
//

typedef struct _DSFX_DISTORTION_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_DISTORTION_STATE, *LPDSFX_DISTORTION_STATE;

typedef const DSFX_DISTORTION_STATE *LPCDSFX_DISTORTION_STATE;

typedef struct _DSFX_DISTORTION_PARAMS
{
    DSFX_DISTORTION_STATE   State;
    DWORD                   dwGain;
    DWORD                   dwPreFilterB0;
    DWORD                   dwPreFilterB1;
    DWORD                   dwPreFilterB2;
    DWORD                   dwPreFilterA1;
    DWORD                   dwPreFilterA2;
    DWORD                   dwPostFilterB0;
    DWORD                   dwPostFilterB1;
    DWORD                   dwPostFilterB2;
    DWORD                   dwPostFilterA1;
    DWORD                   dwPostFilterA2;
} DSFX_DISTORTION_PARAMS, *LPDSFX_DISTORTION_PARAMS;

typedef const DSFX_DISTORTION_PARAMS *LPCDSFX_DISTORTION_PARAMS;

//
// Echo (mono)
//

typedef struct _DSFX_ECHO_MONO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_ECHO_MONO_STATE, *LPDSFX_ECHO_MONO_STATE;

typedef const DSFX_ECHO_MONO_STATE *LPCDSFX_ECHO_MONO_STATE;

typedef struct _DSFX_ECHO_MONO_PARAMS
{
    DSFX_ECHO_MONO_STATE    State;
    DWORD                   dwGain;
} DSFX_ECHO_MONO_PARAMS, *LPDSFX_ECHO_MONO_PARAMS;

typedef const DSFX_ECHO_MONO_PARAMS *LPCDSFX_ECHO_MONO_PARAMS;

//
// Echo (stereo)
//

typedef struct _DSFX_ECHO_STEREO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[2];
} DSFX_ECHO_STEREO_STATE, *LPDSFX_ECHO_STEREO_STATE;

typedef const DSFX_ECHO_STEREO_STATE *LPCDSFX_ECHO_STEREO_STATE;

typedef struct _DSFX_ECHO_STEREO_PARAMS
{
    DSFX_ECHO_STEREO_STATE  State;
    DWORD                   dwGain;
} DSFX_ECHO_STEREO_PARAMS, *LPDSFX_ECHO_STEREO_PARAMS;

typedef const DSFX_ECHO_STEREO_PARAMS *LPCDSFX_ECHO_STEREO_PARAMS;

//
// Flange (mono)
//

typedef struct _DSFX_FLANGE_MONO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_FLANGE_MONO_STATE, *LPDSFX_FLANGE_MONO_STATE;

typedef const DSFX_FLANGE_MONO_STATE *LPCDSFX_FLANGE_MONO_STATE;

typedef struct _DSFX_FLANGE_MONO_PARAMS
{
    DSFX_FLANGE_MONO_STATE  State;
    DWORD                   dwFeedback;
    DWORD                   dwModScale;
} DSFX_FLANGE_MONO_PARAMS, *LPDSFX_FLANGE_MONO_PARAMS;

typedef const DSFX_FLANGE_MONO_PARAMS *LPCDSFX_FLANGE_MONO_PARAMS;

//
// Flange (stereo)
//

typedef struct _DSFX_FLANGE_STEREO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[3];
    DWORD       dwOutMixbinPtrs[2];
} DSFX_FLANGE_STEREO_STATE, *LPDSFX_FLANGE_STEREO_STATE;

typedef const DSFX_FLANGE_STEREO_STATE *LPCDSFX_FLANGE_STEREO_STATE;

typedef struct _DSFX_FLANGE_STEREO_PARAMS
{
    DSFX_FLANGE_STEREO_STATE    State;
    DWORD                       dwFeedback;
    DWORD                       dwModScale;
} DSFX_FLANGE_STEREO_PARAMS, *LPDSFX_FLANGE_STEREO_PARAMS;

typedef const DSFX_FLANGE_STEREO_PARAMS *LPCDSFX_FLANGE_STEREO_PARAMS;

//
// IIR
//

typedef struct _DSFX_IIR_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_IIR_STATE, *LPDSFX_IIR_STATE;

typedef const DSFX_IIR_STATE *LPCDSFX_IIR_STATE;

typedef struct _DSFX_IIR_PARAMS
{
    DSFX_IIR_STATE  State;
    DWORD           dwDelayLength;
    DWORD           dwGain;
    DWORD           dwType;
} DSFX_IIR_PARAMS, *LPDSFX_IIR_PARAMS;

typedef const DSFX_IIR_PARAMS *LPCDSFX_IIR_PARAMS;

//
// Second-order IIR
//

typedef struct _DSFX_IIR2_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_IIR2_STATE, *LPDSFX_IIR2_STATE;

typedef const DSFX_IIR2_STATE *LPCDSFX_IIR2_STATE;

typedef struct _DSFX_IIR2_PARAMS
{
    DSFX_IIR2_STATE State;
    DWORD           dwFilterB0;
    DWORD           dwFilterB1;
    DWORD           dwFilterB2;
    DWORD           dwFilterA1;
    DWORD           dwFilterA2;    
} DSFX_IIR2_PARAMS, *LPDSFX_IIR2_PARAMS;

typedef const DSFX_IIR2_PARAMS *LPCDSFX_IIR2_PARAMS;

//
// Oscillator
//

typedef struct _DSFX_OSCILLATOR_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwOutMixbinPtrs[4];
} DSFX_OSCILLATOR_STATE, *LPDSFX_OSCILLATOR_STATE;

typedef const DSFX_OSCILLATOR_STATE *LPCDSFX_OSCILLATOR_STATE;

//@@BEGIN_MSINTERNAL
// the struct below is used for the IIR based oscillator
// right now we are using the table based oscillator
/*
typedef struct _DSFX_OSCILLATOR_PARAMS
{
    DSFX_OSCILLATOR_STATE   State;
    DWORD                   dwOscillator_H;
    DWORD                   dwOscillator_Y1;
    DWORD                   dwOscillator_Y2;
} DSFX_OSCILLATOR_PARAMS, *LPDSFX_OSCILLATOR_PARAMS;
*/
//@@END_MSINTERNAL

typedef struct _DSFX_OSCILLATOR_PARAMS
{
    DSFX_OSCILLATOR_STATE   State;
    DWORD                   dwNumOutputs;
    DWORD                   adwFrequency[4];
} DSFX_OSCILLATOR_PARAMS, *LPDSFX_OSCILLATOR_PARAMS;

typedef const DSFX_OSCILLATOR_PARAMS *LPCDSFX_OSCILLATOR_PARAMS;

//
// I3DL2 reverb
//

typedef struct _DSFX_I3DL2REVERB_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[35];
} DSFX_I3DL2REVERB_STATE, *LPDSFX_I3DL2REVERB_STATE;

typedef const DSFX_I3DL2REVERB_STATE *LPCDSFX_I3DL2REVERB_STATE;

typedef struct _DSFX_I3DL2REVERB_DELAYLINE
{
    DWORD       dwBase;
    DWORD       dwLength;
} DSFX_I3DL2REVERB_DELAYLINE, *LPDSFX_I3DL2REVERB_DELAYLINE;

typedef const DSFX_I3DL2REVERB_DELAYLINE *LPCDSFX_I3DL2REVERB_DELAYLINE;

typedef struct _DSFX_I3DL2REVERB_IIR
{
    DWORD       dwDelay;
    DWORD       dwCoefficients[2];
} DSFX_I3DL2REVERB_IIR, *LPDSFX_I3DL2REVERB_IIR;

typedef const DSFX_I3DL2REVERB_IIR *LPCDSFX_I3DL2REVERB_IIR;

typedef struct _DSFX_I3DL2REVERB_PARAMS
{
    DSFX_I3DL2REVERB_STATE      State;
    DSFX_I3DL2REVERB_DELAYLINE  DelayLines[14];
    DWORD                       dwReflectionsInputDelay[5];
    DWORD                       dwShortReverbInputDelay;
    DWORD                       dwLongReverbInputDelay[8];
    DWORD                       dwReflectionsFeedbackDelay[4];
    DWORD                       dwLongReverbFeedbackDelay;
    DWORD                       dwShortReverbInputGain[8];
    DWORD                       dwLongReverbInputGain;
    DWORD                       dwLongReverbCrossfeedGain;
    DWORD                       dwReflectionsOutputGain[4];
    DWORD                       dwShortReverbOutputGain;
    DWORD                       dwLongReverbOutputGain;
    DWORD                       dwChannelCount;
    DSFX_I3DL2REVERB_IIR        IIR[10];
} DSFX_I3DL2REVERB_PARAMS, *LPDSFX_I3DL2REVERB_PARAMS;

typedef const DSFX_I3DL2REVERB_PARAMS *LPCDSFX_I3DL2REVERB_PARAMS;

//
// Simple reverb
//

typedef struct _DSFX_MINIREVERB_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[12];
} DSFX_MINIREVERB_STATE, *LPDSFX_MINIREVERB_STATE;

typedef const DSFX_MINIREVERB_STATE *LPCDSFX_MINIREVERB_STATE;

typedef struct _DSFX_MINIREVERB_PARAMS
{
    DSFX_MINIREVERB_STATE   State;
    DWORD                   dwDelayLineLengths[8];
    DWORD                   dwReflectionTaps[8];
    DWORD                   dwReflectionGains[8];
    DWORD                   dwInputIIRCoefficients[2];
    DWORD                   dwInputIIRDelay;
    DWORD                   dwOutputIIRCoefficients[2];
    DWORD                   dwOutputIIRDelay;
} DSFX_MINIREVERB_PARAMS, *LPDSFX_MINIREVERB_PARAMS;

typedef const DSFX_MINIREVERB_PARAMS *LPCDSFX_MINIREVERB_PARAMS;

//
// RMS peak meter
//

typedef struct _DSFX_RMS_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[6];
} DSFX_RMS_STATE, *LPDSFX_RMS_STATE;

typedef const DSFX_RMS_STATE *LPCDSFX_RMS_STATE;

typedef struct _DSFX_RMS_PARAMS
{
    DSFX_RMS_STATE  State;
    DWORD           dwNumMixBins;
    DWORD           dwRMSValues[6];
    DWORD           dwPeakValues[6];
} DSFX_RMS_PARAMS, *LPDSFX_RMS_PARAMS;

typedef const DSFX_RMS_PARAMS *LPCDSFX_RMS_PARAMS;

//
// Splitter
//

typedef struct _DSFX_SPLITTER_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[8];
} DSFX_SPLITTER_STATE, *LPDSFX_SPLITTER_STATE;

typedef const DSFX_SPLITTER_STATE *LPCDSFX_SPLITTER_STATE;

typedef struct _DSFX_SPLITTER_PARAMS
{
    DSFX_SPLITTER_STATE State;
    DWORD               dwNumOutputs;
    DWORD               dwGains[8];
} DSFX_SPLITTER_PARAMS, *LPDSFX_SPLITTER_PARAMS;

typedef const DSFX_SPLITTER_PARAMS *LPCDSFX_SPLITTER_PARAMS;

//
// Sample Rate Converter
//

typedef struct _DSFX_SAMPLE_RATE_CONVERTER_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_SAMPLE_RATE_CONVERTER_STATE, *LPDSFX_SAMPLE_RATE_CONVERTER_STATE;

typedef const DSFX_SPLITTER_STATE *LPCDSFX_SPLITTER_STATE;

typedef struct _DSFX_SAMPLE_RATE_CONVERTER_PARAMS
{
    DSFX_SAMPLE_RATE_CONVERTER_STATE State;
    DWORD               dwConversionRatio;
    DWORD               dwReserved[4];
    DWORD               dwScratchSampleOffset;
} DSFX_SAMPLE_RATE_CONVERTER_PARAMS, *LPDSFX_SAMPLE_RATE_CONVERTER_PARAMS;

typedef const DSFX_SAMPLE_RATE_CONVERTER_PARAMS *LPCDSFX_SAMPLE_RATE_CONVERTER_PARAMS;


#endif // __DSFXPARM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dplay8p.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPlay8.h
 *  Content:    DirectPlay8 include file
//@@BEGIN_MSINTERNAL
 *  History:
 *  Date        By      Reason
 *  ==========================
 *  10/12/98    jwo     created
 *  11/06/98    ejs     removed BUFFERELEMENT, reversed fields in BUFFERDESC, defined new ERRORs
 *  11/10/98    ejs     started adding upper-edge COM interface for DirectPlay8
 *  07/20/99    mjn     added interface GUIDs for DirectPlay8 peer,client and server
 *  07/29/99    mjn     changed DPNID typedef from HANDLE to DWORD
 *  08/09/99    mjn     added DPN_SERVICE_PROVIDER_INFO structure for SP and adapter enumeration
 *  12/03/99    jtk     Replaced IID_IDirectPlay8 with the Client, Server, and Peer interfaces
 *  01/08/00    mjn     Added DPNERR's and fixed DPN_APPLICATION_DESC
 *  01/09/00    mjn     Added dwSize to DPN_APPLICATION_DESC
 *  01/14/00    mjn     Added pvUserContext to Host API call
 *  01/16/00    mjn     New DPlay8 MessageHandler and associated structures
 *  01/18/00    mjn     Added DPNGROUP_AUTODESTRUCT flag
 *  01/22/00    mjn     Added ability for Host to destroy a player
 *  01/24/00    mjn     Reordered error codes and DPN_MSGID's
 *  01/24/00    mjn     Added DPNERR_NOHOSTPLAYER error
 *  01/27/00    vpo     Removed all remaing traces of LP pointers.
 *  01/28/00    mjn     Implemented ReturnBuffer in API and DPN_MSGID_CONNECTION_TERMINATED
 *  02/01/00    mjn     Added GetCaps and SetCaps to APIs and player context values to messages
 *  02/13/00    jtk     Renamed to DPlay8.h
 *  02/15/00    mjn     Added INFO flags and MS_INTERNAL stuff
 *  02/17/00    rmt     Added additional error codes for address library
 *  02/17/00    mjn     Implemented GetPlayerContext and GetGroupContext
 *  02/17/00    mjn     Reordered parameters in EnumServiceProviders,EnumHosts,Connect,Host
 *  03/17/00    rmt     Added Get/SetSPCaps, GetConnectionInfo and supporting structures
 *              rmt     Updated Caps structure.
 *              rmt     Updated Security structures to add dwSize member
 *  03/22/00    mjn     changed dpid's to dpnid's
 *              mjn     removed DPNGROUP_ALLPLAYERS and added DPNID_ALL_PLAYERS_GROUP
 *              mjn     added dwPriority to Send and SendTo
 *              mjn     removed pDpnid from CreateGroup
 *              mjn     replaced HANDLE with DPNHANDLE
 *              mjn     Added dpnid to GetSendQueueInfo for Server and Peer interfaces
 *              mjn     Changed RegisterMessageHandler to Initialize
 *  03/23/00    mjn     Added pvGroupContext to CreateGroup
 *              mjn     Added pvPlayerContext to Host and Connect
 *              mjn     Added RegisterLobby API Call
 *  03/24/00    rmt     Added IsEqual function return codes
 *              mjn     Added pvPlayerContext to INDICATE_CONNECT and renamed pvUserContext to pvReplyContext
 *  03/25/00    rmt     Added new fields to caps
 *  04/04/00    rmt     Added new flag to enable/disable param validation on Initialize call
 *              rmt     Added new flag to enable/disable DPNSVR functionality in session.
 *  04/04/00    mjn     Added DPNERR_INVALIDVERSION
 *  04/05/00    mjn     Added TerminateSession() API Call
 *  04/04/00    aarono  made security structures internal, since not yet supported
 *  04/05/00    mjn     Modified DPNMSG_HOST_DESTROY_PLAYER structure
 *              mjn     Modified DestroyClient to take void* instead of BYTE* for data
 *              mjn     Added typedefs for security structures
 *  04/06/00    mjn     Added Address to INDICATE_CONNECT message
 *              mjn     Added GetClientAddress, GetServerAddress, GetPeerAddress to API
 *              mjn     Added GetHostAddress to API
 *  04/17/00    mjn     Removed DPNPLAYER_SERVER
 *              mjn     Replaced BUFFERDESC with DPN_BUFFER_DESC in API
 *  04/18/00    mjn     Added ResponseData to DPNMSG_ENUM_HOSTS_QUERY
 *              mjn     Added DPN_MSGID_RETURN_BUFFER and DPNMSG_RETURN_BUFFER
 *              mjn     Removed TerminateSession from Server interface.
 *  04/19/00    mjn     SendTo and Send API calls accept a range of DPN_BUFFER_DESCs and a count
 *              mjn     Removed DPN_BUFFER_DESC from DPNMSG_ENUM_HOSTS_QUERY and DPNMSG_ENUM_HOSTS_RESPONSE structs
 *              mjn     Removed hAsyncOp (unused) from DPNMSG_INDICATE_CONNECT
 *  05/02/00    mjn     Removed DPN_ACCEPTED and DPN_REJECTED #define's
 *  05/03/00    mjn     Added DPNENUMSERVICEPROVIDERS_ALL flag
 *  05/04/00    rmt     Bug #34156 - No PDPNID or PDPNHANDLE defined
 *  05/31/00    mjn     Added SYNC flags for EACH API call which supports synchronous operation
 *  06/05/00    mjn     Added short-cut interface macros and converted errors to HEX
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *  06/12/00    mjn     MSINTERNAL'd out DPNSEND_ENCRYPTED,DPNSEND_SIGNED,DPNGROUP_MULTICAST and DPNENUM_GROUP_MULTICAST flags
 *  06/15/00    rmt     Bug #36380 - Removing old CLSID
 *  06/23/00    mjn     Added DPNSEND_PRIORITY_HIGH and DPNSEND_PRIORITY_LOW flags
 *              mjn     Removed dwPriority from Send() and SendTo() API calls
 *  06/26/00    mjn     Added dwReason to DPNMSG_DESTROY_PLAYER and DPNMSG_DESTROY_GROUP structures and added reason constants
 *              mjn     MAJOR API/FLAGS/CONSTANTS/STRUCTURES RENAME
 *  06/27/00    mjn     Added DPNGETSENDQUEUEINFO_PRIORITY_HIGH and DPNGETSENDQUEUEINFO_PRIORITY_LOW flags
 *              mjn     Dropped pvPlayerContext from IDirectPlay8Client::Connect()
 *              mjn     Added DPNENUMHOSTS_DONTSENDADDRESS,DPNSEND_NONSEQUENTIAL and DPNGETSENDQUEUEINFO_PRIORITY_NORMAL flags
 *              mjn     Renumbered SEND flags
 *  07/09/00    rmt     Bug #38323 When registering lobby object w/DP8 object must be able to specify connection to update
 *  07/29/00    mjn     Added DPN_MSGID_INDICATED_CONNECT_ABORTED and DPNMSG_INDICATED_CONNECT_ABORTED structure
 *              mjn     Added pvTerminateData and dwTerminateDataSize to DPNMSG_CONNECTION_TERMINATED structure
 *              mjn     Added hResultCode to DPNMSG_RETURN_BUFFER structure
 *              mjn     Added hResultCode to DPNMSG_TERMINATE_SESSION structure
 *              mjn     Added dwMaxResponseDataSize to DPNMSG_ENUM_HOSTS_QUERY structure
 *              mjn     Changed dwRetryCount to dwEnumCount in EnumHosts API call (no impact - just name change)
 *              mjn     Added DPNERR_ENUMQUERYTOOLARGE,DPNERR_ENUMRESPONSETOOLARGE,DPNERR_HOSTTERMINATEDSESSION
 *              mjn     Reordered DPN_MSGID's alphabetically
 *  07/30/00    mjn     Added pAddressDevice to DPNMSG_INDICATE_CONNECT
 *  07/31/00    mjn     Added DPNDESTROYPLAYERREASON_SESSIONTERMINATED,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER,DPNDESTROYGROUPREASON_SESSIONTERMINATED
 *              mjn     Added DPNERR_PLAYERNOTREACHABLE
 *              mjn     Renamed pAddress to pAddressPlayer in DPNMSG_INDICATE_CONNECT
 *              mjn     Renamed DPN_MSGID_ASYNC_OPERATION_COMPLETE to DPN_MSGID_ASYNC_OP_COMPLETE
 *              mjn     Renamed dwDefaultEnumRetryCount to dwDefaultEnumCount in DPN_SP_CAPS
 *              mjn     Removed DPNENUM_ALL
 *              mjn     Removed DPN_MSGID_HOST_DESTROY_PLAYER
 *              mjn     Removed DPN_MSGID_CONNECTION_TERMINATED
 *              mjn     Removed ALL_ADAPTERS_GUID
 * 08/03/2000   rmt     Bug #41246 - Registering lobby in wrong state returns ambiguous return codes
 *  08/03/00    mjn     Added dwFlags to GetPeerAddress(),GetServerAddress(),GetClientAddress(),GetLocalHostAddresses(),
 *                      Close(),ReturnBuffer(),GetPlayerContext(),GetGroupContext(),GetCaps(),GetSPCaps(),GetConnectionInfo()
 *              mjn     Removed DPNMSG_CONNECTION_TERMINATED,DPNMSG_HOST_DESTROY_PLAYER
 *              mjn     Added dwRoundTripTime to DPNMSG_ENUM_HOSTS_RESPONSE
 *              mjn     Changed GUID *pGuid to GUID guid in DPN_SERVICE_PROVIDER_INFO and added pvReserved,dwReserved
 * 08/06/2000   rmt     Bug #41185 - Cleanup dplay8.h header file.
 * 08/08/2000   rmt     Bug #41724 - Users should only have to include one header
 *              rmt     Bug #41705 - DPNERR_PENDING should be defined as STATUS_PENDING
//@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DIRECTPLAY8_H__
#define __DIRECTPLAY8_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//@@BEGIN_MSINTERNAL
#include <dpaddrp.h>
//@@END_MSINTERNAL
#include <dpaddr.h>

/****************************************************************************
 *
 * DirectPlay8 Callback Functions
 *
 ****************************************************************************/

//
// Callback Function Type Definition
//
typedef HRESULT (WINAPI *PFNDPNMESSAGEHANDLER)(PVOID,DWORD,PVOID);

/****************************************************************************
 *
 * DirectPlay8 Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

//
// Player IDs.  Used to uniquely identify a player in a session
//
typedef DWORD   DPNID,      *PDPNID;

//
// Used as identifiers for operations
//
typedef DWORD   DPNHANDLE, *PDPNHANDLE;

/****************************************************************************
 *
 * DirectPlay8 Message Identifiers
 *
 ****************************************************************************/

#define DPN_MSGID_OFFSET                    0xFFFF0000
#define DPN_MSGID_ADD_PLAYER_TO_GROUP       ( DPN_MSGID_OFFSET | 0x0001 )
#define DPN_MSGID_APPLICATION_DESC          ( DPN_MSGID_OFFSET | 0x0002 )
#define DPN_MSGID_ASYNC_OP_COMPLETE         ( DPN_MSGID_OFFSET | 0x0003 )
#define DPN_MSGID_CLIENT_INFO               ( DPN_MSGID_OFFSET | 0x0004 )
#define DPN_MSGID_CONNECT_COMPLETE          ( DPN_MSGID_OFFSET | 0x0005 )
#define DPN_MSGID_CREATE_GROUP              ( DPN_MSGID_OFFSET | 0x0006 )
#define DPN_MSGID_CREATE_PLAYER             ( DPN_MSGID_OFFSET | 0x0007 )
#define DPN_MSGID_DESTROY_GROUP             ( DPN_MSGID_OFFSET | 0x0008 )
#define DPN_MSGID_DESTROY_PLAYER            ( DPN_MSGID_OFFSET | 0x0009 )
#define DPN_MSGID_ENUM_HOSTS_QUERY          ( DPN_MSGID_OFFSET | 0x000a )
#define DPN_MSGID_ENUM_HOSTS_RESPONSE       ( DPN_MSGID_OFFSET | 0x000b )
#define DPN_MSGID_GROUP_INFO                ( DPN_MSGID_OFFSET | 0x000c )
#define DPN_MSGID_HOST_MIGRATE              ( DPN_MSGID_OFFSET | 0x000d )
#define DPN_MSGID_INDICATE_CONNECT          ( DPN_MSGID_OFFSET | 0x000e )
#define DPN_MSGID_INDICATED_CONNECT_ABORTED ( DPN_MSGID_OFFSET | 0x000f )
#define DPN_MSGID_PEER_INFO                 ( DPN_MSGID_OFFSET | 0x0010 )
#define DPN_MSGID_RECEIVE                   ( DPN_MSGID_OFFSET | 0x0011 )
#define DPN_MSGID_REMOVE_PLAYER_FROM_GROUP  ( DPN_MSGID_OFFSET | 0x0012 )
#define DPN_MSGID_RETURN_BUFFER             ( DPN_MSGID_OFFSET | 0x0013 )
#define DPN_MSGID_SEND_COMPLETE             ( DPN_MSGID_OFFSET | 0x0014 )
#define DPN_MSGID_SERVER_INFO               ( DPN_MSGID_OFFSET | 0x0015 )
#define DPN_MSGID_TERMINATE_SESSION         ( DPN_MSGID_OFFSET | 0x0016 )

/****************************************************************************
 *
 * DirectPlay8 Constants
 *
 ****************************************************************************/

#define IID_IDirectPlay8Peer		0
#define IID_IDirectPlay8Client		1
#define IID_IDirectPlay8Server		2


// {EBFE7BA0-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_TCPIP, 0xebfe7ba0, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

#define DPNID_ALL_PLAYERS_GROUP             0

//
// DESTROY_GROUP reasons
//
#define DPNDESTROYGROUPREASON_NORMAL                0x0001
#define DPNDESTROYGROUPREASON_AUTODESTRUCTED        0x0002
#define DPNDESTROYGROUPREASON_SESSIONTERMINATED     0x0003

//
// DESTROY_PLAYER reasons
//
#define DPNDESTROYPLAYERREASON_NORMAL               0x0001
#define DPNDESTROYPLAYERREASON_CONNECTIONLOST       0x0002
#define DPNDESTROYPLAYERREASON_SESSIONTERMINATED    0x0003
#define DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER  0x0004

/****************************************************************************
 *
 * DirectPlay8 Flags
 *
 ****************************************************************************/

//
// Cancel flags
//
#define DPNCANCEL_CONNECT                   0x0001
#define DPNCANCEL_ENUM                      0x0002
#define DPNCANCEL_SEND                      0x0004
#define DPNCANCEL_ALL_OPERATIONS            0x8000

//
// Enumerate clients and groups flags (For EnumPlayersAndGroups)
//
#define DPNENUM_PLAYERS                     0x0001
#define DPNENUM_GROUPS                      0x0010

//
// Enum hosts flags (For EnumHosts)
//
#define DPNENUMHOSTS_NOBROADCASTFALLBACK    0x0002
//@@BEGIN_MSINTERNAL
#define DPNENUMHOSTS_DONTSENDADDRESS        0x0004
//@@END_MSINTERNAL

//
// Enum service provider flags (For EnumSP)
//
#define DPNENUMSERVICEPROVIDERS_ALL         0x0001

//
// Get send queue info flags (For GetSendQueueInfo)
//
#define DPNGETSENDQUEUEINFO_PRIORITY_NORMAL 0x0001
#define DPNGETSENDQUEUEINFO_PRIORITY_HIGH   0x0002
#define DPNGETSENDQUEUEINFO_PRIORITY_LOW    0x0004

//
// Group information flags (For Group Info)
//
#define DPNGROUP_AUTODESTRUCT               0x0001

//
// Host flags (For Host)
//

//
// Set info
//
#define DPNINFO_NAME                        0x0001
#define DPNINFO_DATA                        0x0002

//
// Register Lobby flags
//
#define DPNLOBBY_REGISTER                   0x0001
#define DPNLOBBY_UNREGISTER                 0x0002

//
// Player information flags (For Player Info / Player Messages)
//
#define DPNPLAYER_LOCAL                     0x0002
#define DPNPLAYER_HOST                      0x0004

//
// Send flags (For Send/SendTo)
//
#define DPNSEND_NOCOPY                      0x0001
#define DPNSEND_NOCOMPLETE                  0x0002
#define DPNSEND_COMPLETEONPROCESS           0x0004
#define DPNSEND_GUARANTEED                  0x0008
#define DPNSEND_NONSEQUENTIAL               0x0010
#define DPNSEND_NOLOOPBACK                  0x0020
#define DPNSEND_PRIORITY_LOW                0x0040
#define DPNSEND_PRIORITY_HIGH               0x0080

//
// Session Flags (for DPN_APPLICATION_DESC)
//
#define DPNSESSION_CLIENT_SERVER            0x0001
#define DPNSESSION_MIGRATE_HOST             0x0004
#define DPNSESSION_REQUIREPASSWORD          0x0080

//
// SP capabilities flags
//
#define DPNSPCAPS_SUPPORTSDPNSRV            0x0001
#define DPNSPCAPS_SUPPORTSBROADCAST         0x0002
#define DPNSPCAPS_SUPPORTSALLADAPTERS       0x0004

/****************************************************************************
 *
 * DirectPlay8 Structures (Non-Message)
 *
 ****************************************************************************/

//
// Application description
//
typedef struct  _DPN_APPLICATION_DESC
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwFlags;                        // Flags (DPNSESSION_...)
    GUID    guidInstance;                   // Instance GUID
    GUID    guidApplication;                // Application GUID
    DWORD   dwMaxPlayers;                   // Maximum # of players allowed (0=no limit)
    DWORD   dwCurrentPlayers;               // Current # of players allowed
    WCHAR   *pwszSessionName;               // Name of the session
    WCHAR   *pwszPassword;                  // Password for the session
    PVOID   pvReservedData;
    DWORD   dwReservedDataSize;
    PVOID   pvApplicationReservedData;
    DWORD   dwApplicationReservedDataSize;
} DPN_APPLICATION_DESC, *PDPN_APPLICATION_DESC;

//
// Generic Buffer Description
//
typedef struct  _BUFFERDESC
{
    DWORD               dwBufferSize;
    BYTE * UNALIGNED    pBufferData;
} BUFFERDESC, DPN_BUFFER_DESC, *PDPN_BUFFER_DESC;

typedef BUFFERDESC  FAR * PBUFFERDESC;

//
// DirectPlay8 capabilities
//
typedef struct  _DPN_CAPS
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwFlags;                        // Flags
    DWORD   dwConnectTimeout;               // ms before a connect request times out
    DWORD   dwConnectRetries;               // # of times to attempt the connection
    DWORD   dwTimeoutUntilKeepAlive;        // ms of inactivity before a keep alive is sent
} DPN_CAPS, *PDPN_CAPS;

// Connection Statistics information

typedef struct _DPN_CONNECTION_INFO
{
    DWORD   dwSize;
    DWORD   dwRoundTripLatencyMS;
    DWORD   dwThroughputBPS;
    DWORD   dwPeakThroughputBPS;

    DWORD   dwBytesSentGuaranteed;
    DWORD   dwPacketsSentGuaranteed;
    DWORD   dwBytesSentNonGuaranteed;
    DWORD   dwPacketsSentNonGuaranteed;

    DWORD   dwBytesRetried;     // Guaranteed only
    DWORD   dwPacketsRetried;   // Guaranteed only
    DWORD   dwBytesDropped;     // Non Guaranteed only
    DWORD   dwPacketsDropped;   // Non Guaranteed only

    DWORD   dwMessagesTransmittedHighPriority;
    DWORD   dwMessagesTimedOutHighPriority;
    DWORD   dwMessagesTransmittedNormalPriority;
    DWORD   dwMessagesTimedOutNormalPriority;
    DWORD   dwMessagesTransmittedLowPriority;
    DWORD   dwMessagesTimedOutLowPriority;

    DWORD   dwBytesReceivedGuaranteed;
    DWORD   dwPacketsReceivedGuaranteed;
    DWORD   dwBytesReceivedNonGuaranteed;
    DWORD   dwPacketsReceivedNonGuaranteed;
    DWORD   dwMessagesReceived;

} DPN_CONNECTION_INFO, *PDPN_CONNECTION_INFO;

//
// Group information strucutre
//
typedef struct  _DPN_GROUP_INFO
{
    DWORD   dwSize;             // size of this structure
    DWORD   dwInfoFlags;        // information contained
    PWSTR   pwszName;           // Unicode Name
    PVOID   pvData;             // data block
    DWORD   dwDataSize;         // size in BYTES of data block
    DWORD   dwGroupFlags;       // group flags (DPNGROUP_...)
} DPN_GROUP_INFO, *PDPN_GROUP_INFO;

//
// Player information structure
//
typedef struct  _DPN_PLAYER_INFO
{
    DWORD   dwSize;             // size of this structure
    DWORD   dwInfoFlags;        // information contained
    PWSTR   pwszName;           // Unicode Name
    PVOID   pvData;             // data block
    DWORD   dwDataSize;         // size in BYTES of data block
    DWORD   dwPlayerFlags;      // player flags (DPNPLAYER_...)
} DPN_PLAYER_INFO, *PDPN_PLAYER_INFO;

typedef struct _DPN_SECURITY_CREDENTIALS    DPN_SECURITY_CREDENTIALS, *PDPN_SECURITY_CREDENTIALS;
typedef struct _DPN_SECURITY_DESC           DPN_SECURITY_DESC, *PDPN_SECURITY_DESC;

//
// Service provider & adapter enumeration structure
//
typedef struct _DPN_SERVICE_PROVIDER_INFO
{
    DWORD       dwFlags;
    GUID        guid;       // SP Guid
    WCHAR       *pwszName;  // Friendly Name
    PVOID       pvReserved;
    DWORD       dwReserved;
} DPN_SERVICE_PROVIDER_INFO, *PDPN_SERVICE_PROVIDER_INFO;

//
// Service provider caps structure
//
typedef struct _DPN_SP_CAPS
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwFlags;                        // Flags ((DPNSPCAPS_...)
    DWORD   dwNumThreads;                   // # of worker threads to use
    DWORD   dwDefaultEnumCount;             // default # of enum requests
    DWORD   dwDefaultEnumRetryInterval;     // default ms between enum requests
    DWORD   dwDefaultEnumTimeout;           // default enum timeout
    DWORD   dwMaxEnumPayloadSize;           // maximum size in bytes for enum payload data
    DWORD   dwBuffersPerThread;             // number of receive buffers per thread
    DWORD   dwSystemBufferSize;             // amount of buffering to do in addition to posted receive buffers
} DPN_SP_CAPS, *PDPN_SP_CAPS;

//@@BEGIN_MSINTERNAL

//
// Security credentials
//
typedef struct  _DPN_SECURITY_CREDENTIALS
{
    DWORD   dwSize;
    DWORD   dwFlags;
} DPN_SECURITY_CREDENTIALS, *PDPN_SECURITY_CREDENTIALS;

//
// Security description
//
typedef struct  _DPN_SECURITY_DESC
{
    DWORD   dwSize;
    DWORD   dwFlags;
} DPN_SECURITY_DESC, *PDPN_SECURITY_DESC;

//@@END_MSINTERNAL


/****************************************************************************
 *
 * IDirectPlay8 message handler call back structures
 *
 ****************************************************************************/

//
// Add player to group strucutre for message handler
// (DPN_MSGID_ADD_PLAYER_TO_GROUP)
//
typedef struct  _DPNMSG_ADD_PLAYER_TO_GROUP
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidGroup;         // DPNID of group
    PVOID   pvGroupContext;     // Group context value
    DPNID   dpnidPlayer;        // DPNID of added player
    PVOID   pvPlayerContext;    // Player context value
} DPNMSG_ADD_PLAYER_TO_GROUP, *PDPNMSG_ADD_PLAYER_TO_GROUP;

//
// Async operation completion structure for message handler
// (DPN_MSGID_ASYNC_OP_COMPLETE)
//
typedef struct  _DPNMSG_ASYNC_OP_COMPLETE
{
    DWORD       dwSize;         // Size of this structure
    DPNHANDLE   hAsyncOp;       // DirectPlay8 async operation handle
    PVOID       pvUserContext;  // User context supplied
    HRESULT     hResultCode;    // HRESULT of operation
} DPNMSG_ASYNC_OP_COMPLETE, *PDPNMSG_ASYNC_OP_COMPLETE;

//
// Client info structure for message handler
// (DPN_MSGID_CLIENT_INFO)
//
typedef struct  _DPNMSG_CLIENT_INFO
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidClient;        // DPNID of client
    PVOID   pvPlayerContext;    // Player context value
} DPNMSG_CLIENT_INFO, *PDPNMSG_CLIENT_INFO;

//
// Connect complete structure for message handler
// (DPN_MSGID_CONNECT_COMPLETE)
//
typedef struct  _DPNMSG_CONNECT_COMPLETE
{
    DWORD       dwSize;                     // Size of this structure
    DPNHANDLE   hAsyncOp;                   // DirectPlay8 Async operation handle
    PVOID       pvUserContext;              // User context supplied at Connect
    HRESULT     hResultCode;                // HRESULT of connection attempt
    PVOID       pvApplicationReplyData;     // Connection reply data from Host/Server
    DWORD       dwApplicationReplyDataSize; // Size (in bytes) of pvApplicationReplyData
} DPNMSG_CONNECT_COMPLETE, *PDPNMSG_CONNECT_COMPLETE;

//
// Create group structure for message handler
// (DPN_MSGID_CREATE_GROUP)
//
typedef struct  _DPNMSG_CREATE_GROUP
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidGroup;         // DPNID of new group
    DPNID   dpnidOwner;         // Owner of newgroup
    PVOID   pvGroupContext;     // Group context value
} DPNMSG_CREATE_GROUP, *PDPNMSG_CREATE_GROUP;

//
// Create player structure for message handler
// (DPN_MSGID_CREATE_PLAYER)
//
typedef struct  _DPNMSG_CREATE_PLAYER
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidPlayer;        // DPNID of new player
    PVOID   pvPlayerContext;    // Player context value
} DPNMSG_CREATE_PLAYER, *PDPNMSG_CREATE_PLAYER;

//
// Destroy group structure for message handler
// (DPN_MSGID_DESTROY_GROUP)
//
typedef struct  _DPNMSG_DESTROY_GROUP
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidGroup;         // DPNID of destroyed group
    PVOID   pvGroupContext;     // Group context value
    DWORD   dwReason;           // Information only
} DPNMSG_DESTROY_GROUP, *PDPNMSG_DESTROY_GROUP;

//
// Destroy player structure for message handler
// (DPN_MSGID_DESTROY_PLAYER)
//
typedef struct  _DPNMSG_DESTROY_PLAYER
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidPlayer;        // DPNID of leaving player
    PVOID   pvPlayerContext;    // Player context value
    DWORD   dwReason;           // Information only
} DPNMSG_DESTROY_PLAYER, *PDPNMSG_DESTROY_PLAYER;

//
// Enumeration request received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_QUERY)
//
typedef struct  _DPNMSG_ENUM_HOSTS_QUERY
{
    DWORD               dwSize;                 // Size of this structure.
    IDirectPlay8Address *pAddressSender;        // Address of client who sent the request
    IDirectPlay8Address *pAddressDevice;        // Address of device request was received on
    PVOID               pvReceivedData;         // Request data (set on client)
    DWORD               dwReceivedDataSize;     // Request data size (set on client)
    DWORD               dwMaxResponseDataSize;  // Max allowable size of enum response
    PVOID               pvResponseData;         // Optional query repsonse (user set)
    DWORD               dwResponseDataSize;     // Optional query response size (user set)
    PVOID               pvResponseContext;      // Optional query response context (user set)
} DPNMSG_ENUM_HOSTS_QUERY, *PDPNMSG_ENUM_HOSTS_QUERY;

//
// Enumeration response received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_RESPONSE)
//
typedef struct  _DPNMSG_ENUM_HOSTS_RESPONSE
{
    DWORD                       dwSize;                     // Size of this structure
    IDirectPlay8Address         *pAddressSender;            // Address of host who responded
    IDirectPlay8Address         *pAddressDevice;            // Device response was received on
    const DPN_APPLICATION_DESC  *pApplicationDescription;   // Application description for the session
    PVOID                       pvResponseData;             // Optional response data (set on host)
    DWORD                       dwResponseDataSize;         // Optional response data size (set on host)
    PVOID                       pvUserContext;              // Context value supplied for enumeration
    DWORD                       dwRoundTripLatencyMS;       // Round trip latency in MS
} DPNMSG_ENUM_HOSTS_RESPONSE, *PDPNMSG_ENUM_HOSTS_RESPONSE;

//
// Group info structure for message handler
// (DPN_MSGID_GROUP_INFO)
//
typedef struct  _DPNMSG_GROUP_INFO
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidGroup;             // DPNID of group
    PVOID   pvGroupContext;         // Group context value
} DPNMSG_GROUP_INFO, *PDPNMSG_GROUP_INFO;

//
// Migrate host structure for message handler
// (DPN_MSGID_HOST_MIGRATE)
//
typedef struct  _DPNMSG_HOST_MIGRATE
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidNewHost;           // DPNID of new Host player
    PVOID   pvPlayerContext;        // Player context value
} DPNMSG_HOST_MIGRATE, *PDPNMSG_HOST_MIGRATE;

//
// Indicate connect structure for message handler
// (DPN_MSGID_INDICATE_CONNECT)
//
typedef struct  _DPNMSG_INDICATE_CONNECT
{
    DWORD       dwSize;                 // Size of this structure
    PVOID       pvUserConnectData;      // Connecting player data
    DWORD       dwUserConnectDataSize;  // Size (in bytes) of pvUserConnectData
    PVOID       pvReplyData;            // Connection reply data
    DWORD       dwReplyDataSize;        // Size (in bytes) of pvReplyData
    PVOID       pvReplyContext;         // Buffer context for pvReplyData
    PVOID       pvPlayerContext;        // Player context preset
    IDirectPlay8Address *pAddressPlayer;// Address of connecting player
    IDirectPlay8Address *pAddressDevice;// Address of device receiving connect attempt
} DPNMSG_INDICATE_CONNECT, *PDPNMSG_INDICATE_CONNECT;

//
// Indicated connect aborted structure for message handler
// (DPN_MSGID_INDICATED_CONNECT_ABORTED)
//
typedef struct  _DPNMSG_INDICATED_CONNECT_ABORTED
{
    DWORD       dwSize;             // Size of this structure
    PVOID       pvPlayerContext;    // Player context preset from DPNMSG_INDICATE_CONNECT
} DPNMSG_INDICATED_CONNECT_ABORTED, *PDPNMSG_INDICATED_CONNECT_ABORTED;

//
// Peer info structure for message handler
// (DPN_MSGID_PEER_INFO)
//
typedef struct  _DPNMSG_PEER_INFO
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidPeer;              // DPNID of peer
    PVOID   pvPlayerContext;        // Player context value
} DPNMSG_PEER_INFO, *PDPNMSG_PEER_INFO;

//
// Receive structure for message handler
// (DPN_MSGID_RECEIVE)
//
typedef struct  _DPNMSG_RECEIVE
{
    DWORD       dwSize;             // Size of this structure
    DPNID       dpnidSender;        // DPNID of sending player
    PVOID       pvPlayerContext;    // Player context value of sending player
    PBYTE       pReceiveData;       // Received data
    DWORD       dwReceiveDataSize;  // Size (in bytes) of pReceiveData
    DPNHANDLE   hBufferHandle;      // Buffer handle for pReceiveData
} DPNMSG_RECEIVE, *PDPNMSG_RECEIVE;

//
// Remove player from group structure for message handler
// (DPN_MSGID_REMOVE_PLAYER_FROM_GROUP)
//
typedef struct  _DPNMSG_REMOVE_PLAYER_FROM_GROUP
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidGroup;             // DPNID of group
    PVOID   pvGroupContext;         // Group context value
    DPNID   dpnidPlayer;            // DPNID of deleted player
    PVOID   pvPlayerContext;        // Player context value
} DPNMSG_REMOVE_PLAYER_FROM_GROUP, *PDPNMSG_REMOVE_PLAYER_FROM_GROUP;

//
// Returned buffer structure for message handler
// (DPN_MSGID_RETURN_BUFFER)
//
typedef struct  _DPNMSG_RETURN_BUFFER
{
    DWORD       dwSize;             // Size of this structure
    HRESULT     hResultCode;        // Return value of operation
    PVOID       pvBuffer;           // Buffer being returned
    PVOID       pvUserContext;      // Context associated with buffer
} DPNMSG_RETURN_BUFFER, *PDPNMSG_RETURN_BUFFER;

//
// Send complete structure for message handler
// (DPN_MSGID_SEND_COMPLETE)
//
typedef struct  _DPNMSG_SEND_COMPLETE
{
    DWORD       dwSize;             // Size of this structure
    DPNHANDLE   hAsyncOp;           // DirectPlay8 Async operation handle
    PVOID       pvUserContext;      // User context supplied at Send/SendTo
    HRESULT     hResultCode;        // HRESULT of send
    DWORD       dwSendTime;         // Send time in ms
} DPNMSG_SEND_COMPLETE, *PDPNMSG_SEND_COMPLETE;

//
// Server info structure for message handler
// (DPN_MSGID_SERVER_INFO)
//
typedef struct  _DPNMSG_SERVER_INFO
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidServer;            // DPNID of server
    PVOID   pvPlayerContext;        // Player context value
} DPNMSG_SERVER_INFO, *PDPNMSG_SERVER_INFO;

//
// Terminated session structure for message handler
// (DPN_MSGID_TERMINATE_SESSION)
//
typedef struct  _DPNMSG_TERMINATE_SESSION
{
    DWORD       dwSize;             // Size of this structure
    HRESULT     hResultCode;        // Reason
    PVOID       pvTerminateData;    // Data passed from Host/Server
    DWORD       dwTerminateDataSize;// Size (in bytes) of pvTerminateData
} DPNMSG_TERMINATE_SESSION, *PDPNMSG_TERMINATE_SESSION;

typedef struct IDirectPlay8Peer     IDirectPlay8Peer;
typedef IDirectPlay8Peer    *PDIRECTPLAY8PEER, *LPDIRECTPLAY8PEER;

typedef struct IDirectPlay8Server   IDirectPlay8Server;
typedef IDirectPlay8Server  *PDIRECTPLAY8SERVER, *LPDIRECTPLAY8SERVER;

typedef struct IDirectPlay8Client   IDirectPlay8Client;
typedef IDirectPlay8Client  *PDIRECTPLAY8CLIENT, *LPDIRECTPLAY8CLIENT;

//@@BEGIN_MSINTERNAL
//typedef struct IDirectPlay8         *LPDIRECTNET;
typedef struct IDirectPlay8Protocol FAR *PDIRECTPLAY8PROTOCOL, FAR *LPDIRECTPLAY8PROTOCOL;
typedef struct IDP8ServiceProvider  IDP8ServiceProvider;
//@@END_MSINTERNAL



/****************************************************************************
 *
 * DirectPlay8 Functions
 *
 ****************************************************************************/

extern HRESULT WINAPI DPlayInitialize(DWORD dwMaxMemUsage);
extern HRESULT WINAPI DPlayCleanup(void);

extern HRESULT WINAPI DirectPlay8Create(DWORD dwIID, void **ppvInterface, void **pUnknown);

/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/


//
// COM definition for DirectPlay8 Client interface
//
// IUnknown methods
ULONG WINAPI IDirectPlay8Client_AddRef(LPDIRECTPLAY8CLIENT pDirectPlay8Client);
ULONG WINAPI IDirectPlay8Client_Release(LPDIRECTPLAY8CLIENT pDirectPlay8Client);

// IDirectPlay8Client methods
HRESULT WINAPI IDirectPlay8Client_Initialize(LPDIRECTPLAY8CLIENT pDirectPlay8Client, PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_EnumServiceProviders(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_EnumHosts(LPDIRECTPLAY8CLIENT pDirectPlay8Client, PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_CancelAsyncOperation(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPNHANDLE hAsyncHandle, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_Connect(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_Send(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetSendQueueInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetApplicationDesc(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_SetClientInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetServerInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetServerAddress(LPDIRECTPLAY8CLIENT pDirectPlay8Client, IDirectPlay8Address **const pAddress,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_Close(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_ReturnBuffer(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPNHANDLE hBufferHandle,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_CAPS *const pdpCaps,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_SetCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_CAPS *const pdpCaps, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_SetSPCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetSPCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const GUID *const pguidSP,DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetConnectionInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_RegisterLobby(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_DoWork(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DWORD dwFlags);

#ifdef __cplusplus

// IDirectPlay8Client wrapper class
struct IDirectPlay8Client
{
    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlay8Client_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlay8Client_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE Initialize(PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags)
    {
        return IDirectPlay8Client_Initialize(this, pvUserContext, pfn, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumServiceProviders(const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags)
    {
        return IDirectPlay8Client_EnumServiceProviders(this, pguidServiceProvider, pguidApplication, pSPInfoBuffer, pcbEnumData, pcReturned, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumHosts(PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Client_EnumHosts(this, pApplicationDesc, pAddrHost, pDeviceInfo, pUserEnumData, dwUserEnumDataSize, dwEnumCount, dwRetryInterval, dwTimeOut, pvUserContext, pAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE CancelAsyncOperation(const DPNHANDLE hAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Client_CancelAsyncOperation(this, hAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Connect(const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Client_Connect(this, pdnAppDesc, pHostAddr, pDeviceInfo, pdnSecurity, pdnCredentials, pvUserConnectData, dwUserConnectDataSize, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Send(const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Client_Send(this, prgBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSendQueueInfo(DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetSendQueueInfo(this, pdwNumMsgs, pdwNumBytes, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetApplicationDesc(this, pAppDescBuffer, pcbDataSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetClientInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Client_SetClientInfo(this, pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetServerInfo(DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetServerInfo(this, pdpnPlayerInfo, pdwSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetServerAddress(IDirectPlay8Address **const pAddress,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetServerAddress(this, pAddress, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Close(const DWORD dwFlags)
    {
        return IDirectPlay8Client_Close(this, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE ReturnBuffer(const DPNHANDLE hBufferHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Client_ReturnBuffer(this, hBufferHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetCaps(DPN_CAPS *const pdpCaps,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetCaps(this, pdpCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetCaps(const DPN_CAPS *const pdpCaps, const DWORD dwFlags)
    {
        return IDirectPlay8Client_SetCaps(this, pdpCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetSPCaps(const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags)
    {
        return IDirectPlay8Client_SetSPCaps(this, pguidSP, pdpspCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSPCaps(const GUID *const pguidSP,DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetSPCaps(this, pguidSP, pdpspCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetConnectionInfo(DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetConnectionInfo(this, pdpConnectionInfo, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE RegisterLobby(const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags)
    {
        return IDirectPlay8Client_RegisterLobby(this, dpnHandle, pIDP8LobbiedApplication, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE DoWork(const DWORD dwFlags)
    {
        return IDirectPlay8Client_DoWork(this, dwFlags);
    }
};

#endif // __cplusplus



//
// COM definition for DirectPlay8 Server interface
//
// IUnknown methods
ULONG WINAPI IDirectPlay8Server_AddRef(LPDIRECTPLAY8SERVER pDirectPlay8Server);
ULONG WINAPI IDirectPlay8Server_Release(LPDIRECTPLAY8SERVER pDirectPlay8Server);

// IDirectPlay8Server methods
HRESULT WINAPI IDirectPlay8Server_Initialize(LPDIRECTPLAY8SERVER pDirectPlay8Server, PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_EnumServiceProviders(LPDIRECTPLAY8SERVER pDirectPlay8Server, const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,PDWORD const pcbEnumData,PDWORD const pcReturned,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_CancelAsyncOperation(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNHANDLE hAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetSendQueueInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetApplicationDesc(LPDIRECTPLAY8SERVER pDirectPlay8Server, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetServerInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetClientInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetClientAddress(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetLocalHostAddresses(LPDIRECTPLAY8SERVER pDirectPlay8Server, IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetApplicationDesc(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_Host(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SendTo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_CreateGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_DestroyGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_AddPlayerToGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_RemovePlayerFromGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetGroupInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetGroupInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_EnumPlayersAndGroups(LPDIRECTPLAY8SERVER pDirectPlay8Server, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_EnumGroupMembers(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_Close(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_DestroyClient(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_ReturnBuffer(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNHANDLE hBufferHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetPlayerContext(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetGroupContext(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, DPN_CAPS *const pdpCaps,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_CAPS *const pdpCaps, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetSPCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetSPCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, const GUID *const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetConnectionInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_RegisterLobby(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags );
//@@BEGIN_MSINTERNAL
HRESULT WINAPI IDirectPlay8Server_DumpNameTable(LPDIRECTPLAY8SERVER pDirectPlay8Server, char *const Buffer );
//@@END_MSINTERNAL
HRESULT WINAPI IDirectPlay8Server_DoWork(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DWORD dwFlags);


#ifdef __cplusplus

// IDirectPlay8Server wrapper class
struct IDirectPlay8Server
{
    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlay8Server_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlay8Server_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE Initialize(PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags )
    {
        return IDirectPlay8Server_Initialize(this, pvUserContext, pfn, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE EnumServiceProviders(const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,PDWORD const pcbEnumData,PDWORD const pcReturned,const DWORD dwFlags )
    {
        return IDirectPlay8Server_EnumServiceProviders(this, pguidServiceProvider, pguidApplication, pSPInfoBuffer, pcbEnumData, pcReturned, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE CancelAsyncOperation(const DPNHANDLE hAsyncHandle,const DWORD dwFlags )
    {
        return IDirectPlay8Server_CancelAsyncOperation(this, hAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetSendQueueInfo(const DPNID dpnid,DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetSendQueueInfo(this, dpnid, pdwNumMsgs, pdwNumBytes, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetApplicationDesc(this, pAppDescBuffer, pcbDataSize, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetServerInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetServerInfo(this, pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetClientInfo(const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetClientInfo(this, dpnid, pdpnPlayerInfo, pdwSize, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetClientAddress(const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetClientAddress(this, dpnid, pAddress, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetLocalHostAddresses(IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetLocalHostAddresses(this, prgpAddress, pcAddress, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetApplicationDesc(const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetApplicationDesc(this, pad, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE Host(const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags )
    {
        return IDirectPlay8Server_Host(this, pdnAppDesc, prgpDeviceInfo, cDeviceInfo, pdnSecurity, pdnCredentials, pvPlayerContext, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SendTo(const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags )
    {
        return IDirectPlay8Server_SendTo(this, dpnid, prgBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE CreateGroup(const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags )
    {
        return IDirectPlay8Server_CreateGroup(this, pdpnGroupInfo, pvGroupContext, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE DestroyGroup(const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_DestroyGroup(this, idGroup, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE AddPlayerToGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_AddPlayerToGroup(this, idGroup, idClient, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE RemovePlayerFromGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_RemovePlayerFromGroup(this, idGroup, idClient, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetGroupInfo(const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetGroupInfo(this, dpnid, pdpnGroupInfo, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetGroupInfo(const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetGroupInfo(this, dpnid, pdpnGroupInfo, pdwSize, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE EnumPlayersAndGroups(DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags )
    {
        return IDirectPlay8Server_EnumPlayersAndGroups(this, prgdpnid, pcdpnid, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE EnumGroupMembers(const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags )
    {
        return IDirectPlay8Server_EnumGroupMembers(this, dpnid, prgdpnid, pcdpnid, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE Close(const DWORD dwFlags )
    {
        return IDirectPlay8Server_Close(this, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE DestroyClient(const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags )
    {
        return IDirectPlay8Server_DestroyClient(this, dpnidClient, pvDestroyData, dwDestroyDataSize, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE ReturnBuffer(const DPNHANDLE hBufferHandle,const DWORD dwFlags )
    {
        return IDirectPlay8Server_ReturnBuffer(this, hBufferHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetPlayerContext(const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetPlayerContext(this, dpnid, ppvPlayerContext, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetGroupContext(const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetGroupContext(this, dpnid, ppvGroupContext, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetCaps(DPN_CAPS *const pdpCaps,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetCaps(this, pdpCaps, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetCaps(const DPN_CAPS *const pdpCaps, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetCaps(this, pdpCaps, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetSPCaps(const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetSPCaps(this, pguidSP, pdpspCaps, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetSPCaps(const GUID *const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetSPCaps(this, pguidSP, pdpspCaps, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetConnectionInfo(const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetConnectionInfo(this, dpnid, pdpConnectionInfo, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE RegisterLobby(const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags )
    {
        return IDirectPlay8Server_RegisterLobby(this, dpnHandle, pIDP8LobbiedApplication, dwFlags );
    }

//@@BEGIN_MSINTERNAL
    __inline HRESULT STDMETHODCALLTYPE DumpNameTable(char *const Buffer )
    {
        return IDirectPlay8Server_DumpNameTable(this, Buffer );
    }
//@@END_MSINTERNAL

    __inline HRESULT STDMETHODCALLTYPE DoWork(const DWORD dwFlags)
    {
        return IDirectPlay8Server_DoWork(this, dwFlags);
    }
};

#endif // __cplusplus

//
// COM definition for DirectPlay8 Peer interface
//
// IUnknown methods
ULONG WINAPI IDirectPlay8Peer_AddRef(LPDIRECTPLAY8PEER pDirectPlay8Peer);
ULONG WINAPI IDirectPlay8Peer_Release(LPDIRECTPLAY8PEER pDirectPlay8Peer);

// IDirectPlay8Peer methods
HRESULT WINAPI IDirectPlay8Peer_Initialize(LPDIRECTPLAY8PEER pDirectPlay8Peer, PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_EnumServiceProviders(LPDIRECTPLAY8PEER pDirectPlay8Peer, const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, DWORD *const pcbEnumData, DWORD *const pcReturned, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_CancelAsyncOperation(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNHANDLE hAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_Connect(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SendTo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetSendQueueInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_Host(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetApplicationDesc(LPDIRECTPLAY8PEER pDirectPlay8Peer, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetApplicationDesc(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_CreateGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_DestroyGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_AddPlayerToGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_RemovePlayerFromGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetGroupInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetGroupInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_EnumPlayersAndGroups(LPDIRECTPLAY8PEER pDirectPlay8Peer, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_EnumGroupMembers(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetPeerInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetPeerInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetPeerAddress(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetLocalHostAddresses(LPDIRECTPLAY8PEER pDirectPlay8Peer, IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_Close(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_EnumHosts(LPDIRECTPLAY8PEER pDirectPlay8Peer, PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_DestroyPeer(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_ReturnBuffer(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNHANDLE hBufferHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetPlayerContext(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetGroupContext(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, DPN_CAPS *const pdpCaps,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_CAPS *const pdpCaps, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetSPCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetSPCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, const GUID *const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetConnectionInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_RegisterLobby(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_TerminateSession(LPDIRECTPLAY8PEER pDirectPlay8Peer, void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags );
//@@BEGIN_MSINTERNAL
HRESULT WINAPI IDirectPlay8Peer_DumpNameTable(LPDIRECTPLAY8PEER pDirectPlay8Peer, char *const Buffer );
//@@END_MSINTERNAL
HRESULT WINAPI IDirectPlay8Peer_DoWork(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DWORD dwFlags);

#ifdef __cplusplus

// IDirectPlay8Peer wrapper class
struct IDirectPlay8Peer
{
    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlay8Peer_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlay8Peer_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE Initialize(PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_Initialize(this, pvUserContext, pfn, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumServiceProviders(const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, DWORD *const pcbEnumData, DWORD *const pcReturned, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_EnumServiceProviders(this, pguidServiceProvider, pguidApplication, pSPInfoBuffer, pcbEnumData, pcReturned, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE CancelAsyncOperation(const DPNHANDLE hAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_CancelAsyncOperation(this, hAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Connect(const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_Connect(this, pdnAppDesc, pHostAddr, pDeviceInfo, pdnSecurity, pdnCredentials, pvUserConnectData, dwUserConnectDataSize, pvPlayerContext, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SendTo(const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SendTo(this, dpnid, prgBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSendQueueInfo(const DPNID dpnid, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetSendQueueInfo(this, dpnid, pdwNumMsgs, pdwNumBytes, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Host(const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_Host(this, pdnAppDesc, prgpDeviceInfo, cDeviceInfo, pdnSecurity, pdnCredentials, pvPlayerContext, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetApplicationDesc(this, pAppDescBuffer, pcbDataSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetApplicationDesc(const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetApplicationDesc(this, pad, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateGroup(const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_CreateGroup(this, pdpnGroupInfo, pvGroupContext, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE DestroyGroup(const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_DestroyGroup(this, idGroup, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE AddPlayerToGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_AddPlayerToGroup(this, idGroup, idClient, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE RemovePlayerFromGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_RemovePlayerFromGroup(this, idGroup, idClient, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetGroupInfo(const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetGroupInfo(this, dpnid, pdpnGroupInfo, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetGroupInfo(const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetGroupInfo(this, dpnid, pdpnGroupInfo, pdwSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumPlayersAndGroups(DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_EnumPlayersAndGroups(this, prgdpnid, pcdpnid, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumGroupMembers(const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_EnumGroupMembers(this, dpnid, prgdpnid, pcdpnid, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPeerInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetPeerInfo(this, pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetPeerInfo(const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetPeerInfo(this, dpnid, pdpnPlayerInfo, pdwSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetPeerAddress(const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetPeerAddress(this, dpnid, pAddress, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetLocalHostAddresses(IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetLocalHostAddresses(this, prgpAddress, pcAddress, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Close(const DWORD dwFlags)
    {
        return IDirectPlay8Peer_Close(this, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumHosts(PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_EnumHosts(this, pApplicationDesc, pAddrHost, pDeviceInfo, pUserEnumData, dwUserEnumDataSize, dwEnumCount, dwRetryInterval, dwTimeOut, pvUserContext, pAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE DestroyPeer(const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_DestroyPeer(this, dpnidClient, pvDestroyData, dwDestroyDataSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE ReturnBuffer(const DPNHANDLE hBufferHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_ReturnBuffer(this, hBufferHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetPlayerContext(const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetPlayerContext(this, dpnid, ppvPlayerContext, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetGroupContext(const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetGroupContext(this, dpnid, ppvGroupContext, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetCaps(DPN_CAPS *const pdpCaps,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetCaps(this, pdpCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetCaps(const DPN_CAPS *const pdpCaps, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetCaps(this, pdpCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetSPCaps(const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetSPCaps(this, pguidSP, pdpspCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSPCaps(const GUID *const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetSPCaps(this, pguidSP, pdpspCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetConnectionInfo(const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetConnectionInfo(this, dpnid, pdpConnectionInfo, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE RegisterLobby(const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_RegisterLobby(this, dpnHandle, pIDP8LobbiedApplication, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE TerminateSession(void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_TerminateSession(this, pvTerminateData, dwTerminateDataSize, dwFlags);
    }

//@@BEGIN_MSINTERNAL
    __inline HRESULT STDMETHODCALLTYPE DumpNameTable(char *const Buffer )
    {
        return IDirectPlay8Peer_DumpNameTable(this, Buffer );
    }
//@@END_MSINTERNAL

    __inline HRESULT STDMETHODCALLTYPE DoWork(const DWORD dwFlags)
    {
        return IDirectPlay8Peer_DoWork(this, dwFlags);
    }
};

#endif // __cplusplus



//@@BEGIN_MSINTERNAL

//
// COM definition for DirectPlay8 Protocol interface
//
// IUnknown methods
ULONG WINAPI IDirectPlay8Protocol_AddRef(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol);
ULONG WINAPI IDirectPlay8Protocol_Release(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol);

// IDirectPlay8Protocol methods
HRESULT WINAPI IDirectPlay8Protocol_Initialize(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol );
HRESULT WINAPI IDirectPlay8Protocol_AddServiceProvider(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, IDP8ServiceProvider *const );
HRESULT WINAPI IDirectPlay8Protocol_Connect(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, IDirectPlay8Address *const, IDirectPlay8Address *const, DWORD, ULONG, PVOID, PHANDLE );
HRESULT WINAPI IDirectPlay8Protocol_Listen(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, IDirectPlay8Address *const, ULONG, PVOID, PHANDLE );
HRESULT WINAPI IDirectPlay8Protocol_SendData(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, HANDLE, UINT, PBUFFERDESC, UINT, UINT, ULONG, PVOID, PHANDLE );
HRESULT WINAPI IDirectPlay8Protocol_Disconnect(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, HANDLE, PVOID, PHANDLE );
HRESULT WINAPI IDirectPlay8Protocol_Abort(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, HANDLE );
HRESULT WINAPI IDirectPlay8Protocol_Cancel(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, HANDLE );
HRESULT WINAPI IDirectPlay8Protocol_Terminate(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol );
HRESULT WINAPI IDirectPlay8Protocol_Debug(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, UINT, HANDLE, PVOID );
HRESULT WINAPI IDirectPlay8Protocol_EnumAdapters(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, PVOID );
HRESULT WINAPI IDirectPlay8Protocol_ReturnReceiveBuffers(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, HANDLE );
HRESULT WINAPI IDirectPlay8Protocol_GetEndpointCaps(LPDIRECTPLAY8PROTOCOL pDirectPlay8Protocol, HANDLE, PVOID );

//@@END_MSINTERNAL



/****************************************************************************
 *
 * DIRECTPLAY8 ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DPN_FACILITY_CODE  0x015
#define _DPNHRESULT_BASE        0x8000
#define MAKE_DPNHRESULT( code )         MAKE_HRESULT( 1, _DPN_FACILITY_CODE, ( code + _DPNHRESULT_BASE ) )

#define DPN_OK                          S_OK

#define DPNSUCCESS_EQUAL                MAKE_HRESULT( 0, _DPN_FACILITY_CODE, ( 0x5 + _DPNHRESULT_BASE ) )
#define DPNSUCCESS_NOTEQUAL             MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0A + _DPNHRESULT_BASE ) )
#define DPNSUCCESS_PENDING              MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0e + _DPNHRESULT_BASE ) )

#define DPNERR_ABORTED                  MAKE_DPNHRESULT(  0x30 )
#define DPNERR_ADDRESSING               MAKE_DPNHRESULT(  0x40 )
#define DPNERR_ALREADYCLOSING           MAKE_DPNHRESULT(  0x50 )
#define DPNERR_ALREADYCONNECTED         MAKE_DPNHRESULT(  0x60 )
#define DPNERR_ALREADYDISCONNECTING     MAKE_DPNHRESULT(  0x70 )
#define DPNERR_ALREADYINITIALIZED       MAKE_DPNHRESULT(  0x80 )
#define DPNERR_ALREADYREGISTERED        MAKE_DPNHRESULT(  0x90 )
#define DPNERR_BUFFERTOOSMALL           MAKE_DPNHRESULT( 0x100 )
#define DPNERR_CANNOTCANCEL             MAKE_DPNHRESULT( 0x110 )
#define DPNERR_CANTCREATEGROUP          MAKE_DPNHRESULT( 0x120 )
#define DPNERR_CANTCREATEPLAYER         MAKE_DPNHRESULT( 0x130 )
#define DPNERR_CANTLAUNCHAPPLICATION    MAKE_DPNHRESULT( 0x140 )
#define DPNERR_CONNECTING               MAKE_DPNHRESULT( 0x150 )
#define DPNERR_CONNECTIONLOST           MAKE_DPNHRESULT( 0x160 )
#define DPNERR_CONVERSION               MAKE_DPNHRESULT( 0x170 )
#define DPNERR_DATATOOLARGE             MAKE_DPNHRESULT( 0x175 )
#define DPNERR_DOESNOTEXIST             MAKE_DPNHRESULT( 0x180 )
#define DPNERR_DUPLICATECOMMAND         MAKE_DPNHRESULT( 0x190 )
#define DPNERR_ENDPOINTNOTRECEIVING     MAKE_DPNHRESULT( 0x200 )
#define DPNERR_ENUMQUERYTOOLARGE        MAKE_DPNHRESULT( 0x210 )
#define DPNERR_ENUMRESPONSETOOLARGE     MAKE_DPNHRESULT( 0x220 )
#define DPNERR_EXCEPTION                MAKE_DPNHRESULT( 0x230 )
#define DPNERR_GENERIC                  E_FAIL
#define DPNERR_GROUPNOTEMPTY            MAKE_DPNHRESULT( 0x240 )
#define DPNERR_HOSTING                  MAKE_DPNHRESULT( 0x250 )
#define DPNERR_HOSTREJECTEDCONNECTION   MAKE_DPNHRESULT( 0x260 )
#define DPNERR_HOSTTERMINATEDSESSION    MAKE_DPNHRESULT( 0x270 )
#define DPNERR_INCOMPLETEADDRESS        MAKE_DPNHRESULT( 0x280 )
#define DPNERR_INVALIDADDRESSFORMAT     MAKE_DPNHRESULT( 0x290 )
#define DPNERR_INVALIDAPPLICATION       MAKE_DPNHRESULT( 0x300 )
#define DPNERR_INVALIDCOMMAND           MAKE_DPNHRESULT( 0x310 )
#define DPNERR_INVALIDDEVICEADDRESS     MAKE_DPNHRESULT( 0x320 )
#define DPNERR_INVALIDENDPOINT          MAKE_DPNHRESULT( 0x330 )
#define DPNERR_INVALIDFLAGS             MAKE_DPNHRESULT( 0x340 )
#define DPNERR_INVALIDGROUP             MAKE_DPNHRESULT( 0x350 )
#define DPNERR_INVALIDHANDLE            MAKE_DPNHRESULT( 0x360 )
#define DPNERR_INVALIDHOSTADDRESS       MAKE_DPNHRESULT( 0x370 )
#define DPNERR_INVALIDINSTANCE          MAKE_DPNHRESULT( 0x380 )
#define DPNERR_INVALIDINTERFACE         MAKE_DPNHRESULT( 0x390 )
#define DPNERR_INVALIDOBJECT            MAKE_DPNHRESULT( 0x400 )
#define DPNERR_INVALIDPARAM             E_INVALIDARG
#define DPNERR_INVALIDPASSWORD          MAKE_DPNHRESULT( 0x410 )
#define DPNERR_INVALIDPLAYER            MAKE_DPNHRESULT( 0x420 )
#define DPNERR_INVALIDPOINTER           E_POINTER
#define DPNERR_INVALIDPRIORITY          MAKE_DPNHRESULT( 0x430 )
#define DPNERR_INVALIDSTRING            MAKE_DPNHRESULT( 0x440 )
#define DPNERR_INVALIDURL               MAKE_DPNHRESULT( 0x450 )
#define DPNERR_INVALIDVERSION           MAKE_DPNHRESULT( 0x460 )
#define DPNERR_NOCAPS                   MAKE_DPNHRESULT( 0x470 )
#define DPNERR_NOCONNECTION             MAKE_DPNHRESULT( 0x480 )
#define DPNERR_NOHOSTPLAYER             MAKE_DPNHRESULT( 0x490 )
#define DPNERR_NOINTERFACE              E_NOINTERFACE
#define DPNERR_NOMOREADDRESSCOMPONENTS  MAKE_DPNHRESULT( 0x500 )
#define DPNERR_NORESPONSE               MAKE_DPNHRESULT( 0x510 )
#define DPNERR_NOTALLOWED               MAKE_DPNHRESULT( 0x520 )
#define DPNERR_NOTHOST                  MAKE_DPNHRESULT( 0x530 )
#define DPNERR_NOTREADY                 MAKE_DPNHRESULT( 0x540 )
#define DPNERR_NOTREGISTERED            MAKE_DPNHRESULT( 0x550 )
#define DPNERR_OUTOFMEMORY              E_OUTOFMEMORY
#define DPNERR_PENDING                  DPNSUCCESS_PENDING
#define DPNERR_PLAYERALREADYINGROUP     MAKE_DPNHRESULT( 0x560 )
#define DPNERR_PLAYERLOST               MAKE_DPNHRESULT( 0x570 )
#define DPNERR_PLAYERNOTINGROUP         MAKE_DPNHRESULT( 0x580 )
#define DPNERR_PLAYERNOTREACHABLE       MAKE_DPNHRESULT( 0x590 )
#define DPNERR_SENDTOOLARGE             MAKE_DPNHRESULT( 0x600 )
#define DPNERR_SESSIONFULL              MAKE_DPNHRESULT( 0x610 )
#define DPNERR_TABLEFULL                MAKE_DPNHRESULT( 0x620 )
#define DPNERR_TIMEDOUT                 MAKE_DPNHRESULT( 0x630 )
#define DPNERR_UNINITIALIZED            MAKE_DPNHRESULT( 0x640 )
#define DPNERR_UNSUPPORTED              E_NOTIMPL
#define DPNERR_USERCANCEL               MAKE_DPNHRESULT( 0x650 )
#define DPNERR_NOAGGREGATION                CLASS_E_NOAGGREGATION

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\error.h ===
/*static char *SCCSID = "@(#)error.h    12.18 88/12/02";*/
/* WARNING If modifying this file, may have to also modify files: */
/*      src\inc\errtab.inc                                              */
/*      src\dos\error.inc                                               */
/* XENIX calls all return error codes through AX.  If an error occurred then */
/* the carry bit will be set and the error code is in AX.  If no error occurred */
/* then the carry bit is reset and AX contains returned info. */
/* */
/* Since the set of error codes is being extended as we extend the operating */
/* system, we have provided a means for applications to ask the system for a */
/* recommended course of action when they receive an error. */
/* */
/* The GetExtendedError system call returns a universal error, an error */
/* location and a recommended course of action. The universal error code is */
/* a symptom of the error REGARDLESS of the context in which GetExtendedError */
/* is issued. */
/* */

/* */
/* These are the 2.0 error codes */
/* */
#define NO_ERROR                        0
#define ERROR_INVALID_FUNCTION          1
#define ERROR_FILE_NOT_FOUND            2
#define ERROR_PATH_NOT_FOUND            3
#define ERROR_TOO_MANY_OPEN_FILES       4
#define ERROR_ACCESS_DENIED             5
#define ERROR_INVALID_HANDLE            6
#define ERROR_ARENA_TRASHED             7
#define ERROR_NOT_ENOUGH_MEMORY         8
#define ERROR_INVALID_BLOCK             9
#define ERROR_BAD_ENVIRONMENT           10
#define ERROR_BAD_FORMAT                11
#define ERROR_INVALID_ACCESS            12
#define ERROR_INVALID_DATA              13
/***** reserved                 EQU     14      ; ***** */
#define ERROR_INVALID_DRIVE             15
#define ERROR_CURRENT_DIRECTORY         16
#define ERROR_NOT_SAME_DEVICE           17
#define ERROR_NO_MORE_FILES             18
/* */
/* These are the universal int 24 mappings for the old INT 24 set of errors */
/* */
#define ERROR_WRITE_PROTECT             19
#define ERROR_BAD_UNIT                  20
#define ERROR_NOT_READY                 21
#define ERROR_BAD_COMMAND               22
#define ERROR_CRC                       23
#define ERROR_BAD_LENGTH                24
#define ERROR_SEEK                      25
#define ERROR_NOT_DOS_DISK              26
#define ERROR_SECTOR_NOT_FOUND          27
#define ERROR_OUT_OF_PAPER              28
#define ERROR_WRITE_FAULT               29
#define ERROR_READ_FAULT                30
#define ERROR_GEN_FAILURE               31
/* */
/* These are the new 3.0 error codes reported through INT 24 */
/* */
#define ERROR_SHARING_VIOLATION         32
#define ERROR_LOCK_VIOLATION            33
#define ERROR_WRONG_DISK                34
#define ERROR_FCB_UNAVAILABLE           35
#define ERROR_SHARING_BUFFER_EXCEEDED   36
/* */
/* New OEM network-related errors are 50-79 */
/* */
#define ERROR_NOT_SUPPORTED             50
#define ERROR_REM_NOT_LIST              51      /* Remote computer not listening */
#define ERROR_DUP_NAME                  52      /* Duplicate name on network */
#define ERROR_BAD_NETPATH               53      /* Network path not found */
#define ERROR_NETWORK_BUSY              54      /* Network busy */
#define ERROR_DEV_NOT_EXIST             55      /* Network device no longer exists */
#define ERROR_TOO_MANY_CMDS             56      /* Net BIOS command limit exceeded */
#define ERROR_ADAP_HDW_ERR              57      /* Network adapter hardware error */
#define ERROR_BAD_NET_RESP              58      /* Incorrect response from network */
#define ERROR_UNEXP_NET_ERR             59      /* Unexpected network error */
#define ERROR_BAD_REM_ADAP              60      /* Incompatible remote adapter */
#define ERROR_PRINTQ_FULL               61      /* Print queue full */
#define ERROR_NO_SPOOL_SPACE            62      /* Not enough space for print file */
#define ERROR_PRINT_CANCELLED           63      /* Print file was cancelled */
#define ERROR_NETNAME_DELETED           64      /* Network name was deleted */
#define ERROR_NETWORK_ACCESS_DENIED             65      /* Access denied */
#define ERROR_BAD_DEV_TYPE              66      /* Network device type incorrect */
#define ERROR_BAD_NET_NAME              67      /* Network name not found */
#define ERROR_TOO_MANY_NAMES            68      /* Network name limit exceeded */
#define ERROR_TOO_MANY_SESS             69      /* Net BIOS session limit exceeded */
#define ERROR_SHARING_PAUSED            70      /* Sharing temporarily paused */
#define ERROR_REQ_NOT_ACCEP             71      /* Network request not accepted */
#define ERROR_REDIR_PAUSED              72      /* Print or disk redirection is paused */
/* */
/* End of INT 24 reportable errors */
/* */
#define ERROR_FILE_EXISTS               80
#define ERROR_DUP_FCB                   81        /* ***** */
#define ERROR_CANNOT_MAKE               82
#define ERROR_FAIL_I24                  83
/* */
/* New 3.0 network related error codes */
/* */
#define ERROR_OUT_OF_STRUCTURES         84
#define ERROR_ALREADY_ASSIGNED          85
#define ERROR_INVALID_PASSWORD          86
#define ERROR_INVALID_PARAMETER         87
#define ERROR_NET_WRITE_FAULT           88
/* */
/* New error codes for 4.0 */
/* */
#define ERROR_NO_PROC_SLOTS             89        /* no process slots available */
#define ERROR_NOT_FROZEN                90
#define ERR_TSTOVFL                     91        /* timer service table overflow */
#define ERR_TSTDUP                      92        /* timer service table duplicate */
#define ERROR_NO_ITEMS                  93        /* There were no items to operate upon */
#define ERROR_INTERRUPT                 95        /* interrupted system call */

#define ERROR_TOO_MANY_SEMAPHORES       100
#define ERROR_EXCL_SEM_ALREADY_OWNED    101
#define ERROR_SEM_IS_SET                102
#define ERROR_TOO_MANY_SEM_REQUESTS     103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104

#define ERROR_SEM_OWNER_DIED            105       /* waitsem found owner died */
#define ERROR_SEM_USER_LIMIT            106       /* too many procs have this sem */
#define ERROR_DISK_CHANGE               107       /* insert disk b into drive a */
#define ERROR_DRIVE_LOCKED              108       /* drive locked by another process */
#define ERROR_BROKEN_PIPE               109       /* write on pipe with no reader */
/* */
/* New error codes for 5.0 */
/* */
#define ERROR_OPEN_FAILED               110       /* open/created failed due to */
                                                  /* explicit fail command */
#define ERROR_BUFFER_OVERFLOW           111       /* buffer passed to system call */
                                                  /* is too small to hold return */
                                                  /* data. */
#define ERROR_DISK_FULL                 112       /* not enough space on the disk */
                                                  /* (DOSNEWSIZE/w_NewSize) */
#define ERROR_NO_MORE_SEARCH_HANDLES    113       /* can't allocate another search */
                                                  /* structure and handle. */
                                                  /* (DOSFINDFIRST/w_FindFirst) */
#define ERROR_INVALID_TARGET_HANDLE     114       /* Target handle in DOSDUPHANDLE */
                                                  /* is invalid */
#define ERROR_PROTECTION_VIOLATION      115       /* Bad user virtual address */
#define ERROR_VIOKBD_REQUEST            116
#define ERROR_INVALID_CATEGORY          117       /* Category for DEVIOCTL in not */
                                                  /* defined */
#define ERROR_INVALID_VERIFY_SWITCH     118       /* invalid value passed for */
                                                  /* verify flag */
#define ERROR_BAD_DRIVER_LEVEL          119       /* DosDevIOCTL looks for a level */
                                                  /* four driver.       If the driver */
                                                  /* is not level four we return */
                                                  /* this code */
#define ERROR_CALL_NOT_IMPLEMENTED      120       /* returned from stub api calls. */
                                                  /* This call will disappear when */
                                                  /* all the api's are implemented. */
#define ERROR_SEM_TIMEOUT               121       /* Time out happened from the */
                                                  /* semaphore api functions. */
#define ERROR_INSUFFICIENT_BUFFER       122       /* Some call require the  */
                                          /* application to pass in a buffer */
                                          /* filled with data.  This error is */
                                          /* returned if the data buffer is too */
                                          /* small.  For example: DosSetFileInfo */
                                          /* requires 4 bytes of data.  If a */
                                          /* two byte buffer is passed in then */
                                          /* this error is returned.   */
                                          /* error_buffer_overflow is used when */
                                          /* the output buffer in not big enough. */
#define ERROR_INVALID_NAME              123       /* illegal character or malformed */
                                                  /* file system name */
#define ERROR_INVALID_LEVEL             124       /* unimplemented level for info */
                                                  /* retrieval or setting */
#define ERROR_NO_VOLUME_LABEL           125       /* no volume label found with */
                                                  /* DosQFSInfo command */
/* NOTE:  DosQFSInfo no longer returns the above error; it is still here for */
/*        api\d_qfsinf.asm.                                                  */

#define ERROR_MOD_NOT_FOUND             126       /* w_getprocaddr,w_getmodhandle */
#define ERROR_PROC_NOT_FOUND            127       /* w_getprocaddr */

#define ERROR_WAIT_NO_CHILDREN          128       /* CWait finds to children */

#define ERROR_CHILD_NOT_COMPLETE        129       /* CWait children not dead yet */

/*This is a temporary fix for the 4-19-86 build this should be changed when */
/* we get the file from MS */
#define ERROR_DIRECT_ACCESS_HANDLE      130       /* handle operation is invalid */
                                                  /* for direct disk access */
                                                  /* handles */
#define ERROR_NEGATIVE_SEEK             131       /* application tried to seek  */
                                                  /* with negitive offset */
#define ERROR_SEEK_ON_DEVICE            132       /* application tried to seek */
                                                  /* on device or pipe */
/* */
/* The following are errors generated by the join and subst workers */
/* */
#define ERROR_IS_JOIN_TARGET            133
#define ERROR_IS_JOINED                 134
#define ERROR_IS_SUBSTED                135
#define ERROR_NOT_JOINED                136
#define ERROR_NOT_SUBSTED               137
#define ERROR_JOIN_TO_JOIN              138
#define ERROR_SUBST_TO_SUBST            139
#define ERROR_JOIN_TO_SUBST             140
#define ERROR_SUBST_TO_JOIN             141
#define ERROR_BUSY_DRIVE                142
#define ERROR_SAME_DRIVE                143
#define ERROR_DIR_NOT_ROOT              144
#define ERROR_DIR_NOT_EMPTY             145
#define ERROR_IS_SUBST_PATH             146
#define ERROR_IS_JOIN_PATH              147
#define ERROR_PATH_BUSY                 148
#define ERROR_IS_SUBST_TARGET           149
#define ERROR_SYSTEM_TRACE              150     /* system trace error */
#define ERROR_INVALID_EVENT_COUNT       151     /* DosMuxSemWait errors */
#define ERROR_TOO_MANY_MUXWAITERS       152
#define ERROR_INVALID_LIST_FORMAT       153
#define ERROR_LABEL_TOO_LONG            154
#define ERROR_TOO_MANY_TCBS             155
#define ERROR_SIGNAL_REFUSED            156
#define ERROR_DISCARDED                 157
#define ERROR_NOT_LOCKED                158
#define ERROR_BAD_THREADID_ADDR         159
#define ERROR_BAD_ARGUMENTS             160
#define ERROR_BAD_PATHNAME              161
#define ERROR_SIGNAL_PENDING            162
#define ERROR_UNCERTAIN_MEDIA           163
#define ERROR_MAX_THRDS_REACHED         164
#define ERROR_MONITORS_NOT_SUPPORTED    165
#define ERROR_UNC_DRIVER_NOT_INSTALLED  166

/*      The following error codes refer to errors demand loading segments */

#define ERROR_LOCK_FAILED               167
#define ERROR_SWAPIO_FAILED             168
#define ERROR_SWAPIN_FAILED             169
#define ERROR_BUSY                      170

#define ERROR_INVALID_SEGMENT_NUMBER    180
#define ERROR_INVALID_CALLGATE          181
#define ERROR_INVALID_ORDINAL           182
#define ERROR_ALREADY_EXISTS            183
#define ERROR_NO_CHILD_PROCESS          184
#define ERROR_CHILD_ALIVE_NOWAIT        185
#define ERROR_INVALID_FLAG_NUMBER       186
#define ERROR_SEM_NOT_FOUND             187

/*      following error codes have added  to make the loader error
        messages distinct
*/

#define ERROR_INVALID_STARTING_CODESEG          188
#define ERROR_INVALID_STACKSEG                  189
#define ERROR_INVALID_MODULETYPE                190
#define ERROR_INVALID_EXE_SIGNATURE             191
#define ERROR_EXE_MARKED_INVALID                192
#define ERROR_BAD_EXE_FORMAT                    193
#define ERROR_ITERATED_DATA_EXCEEDS_64k         194
#define ERROR_INVALID_MINALLOCSIZE              195
#define ERROR_DYNLINK_FROM_INVALID_RING         196
#define ERROR_IOPL_NOT_ENABLED                  197
#define ERROR_INVALID_SEGDPL                    198
#define ERROR_AUTODATASEG_EXCEEDS_64k           199
#define ERROR_RING2SEG_MUST_BE_MOVABLE          200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM          201
#define ERROR_INFLOOP_IN_RELOC_CHAIN            202

#define ERROR_ENVVAR_NOT_FOUND                  203
#define ERROR_NOT_CURRENT_CTRY                  204
#define ERROR_NO_SIGNAL_SENT                    205
#define ERROR_FILENAME_EXCED_RANGE              206     /* if filename > 8.3 */
#define ERROR_RING2_STACK_IN_USE                207     /* for FAPI */
#define ERROR_META_EXPANSION_TOO_LONG           208     /* if "*a" > 8.3 */
#define ERROR_INVALID_SIGNAL_NUMBER             209
#define ERROR_THREAD_1_INACTIVE                 210
#define ERROR_INFO_NOT_AVAIL                    211 /* PTM 5550 */
#define ERROR_LOCKED                            212
#define ERROR_BAD_DYNALINK                      213 /* PTM 5760 */
#define ERROR_TOO_MANY_MODULES                  214
#define ERROR_NESTING_NOT_ALLOWED               215

#define ERROR_CANNOT_SHRINK                     216 /* attempt made to shrink
                                                        ring 2 stack */
#define ERROR_ZOMBIE_PROCESS                    217
#define ERROR_STACK_IN_HIGH_MEMORY              218
#define ERROR_INVALID_EXITROUTINE_RING          219 /* 1.1 DCR 87 */
#define ERROR_GETBUF_FAILED                     220
#define ERROR_FLUSHBUF_FAILED                   221
#define ERROR_TRANSFER_TOO_LONG                 222
#define ERROR_NO_CHILDREN                       228
#define ERROR_INVALID_SCREEN_GROUP              229

/*
 * Error codes 230 - 249 are reserved for MS Networks
 */
#define ERROR_BAD_PIPE                          230 /* Non-existant pipe or bad operation */
#define ERROR_PIPE_BUSY                         231 /* Pipe is busy */
#define ERROR_NO_DATA                           232 /* No data on non-blocking read */
#define ERROR_PIPE_NOT_CONNECTED                233 /* Pipe was disconnected by server */
#define ERROR_MORE_DATA                         234 /* More data is available */

#define ERROR_VC_DISCONNECTED           240     /* Session was dropped due to errors */

/*  The following added to Dos_Rename */

#define ERROR_CIRCULARITY_REQUESTED             250 /* When renaming a dir  */
                                                    /* which would cause a  */
                                                    /* circularity          */
#define ERROR_DIRECTORY_IN_CDS                  251 /* When renameing a dir */
                                                    /* which is "in use"    */

/* The following error code is 1.2 FileSystem for FSDs */

#define ERROR_INVALID_FSD_NAME                  252 /* when trying to access */
                                                    /* nonexistent FSD       */
#define ERROR_INVALID_PATH                      253 /* bad pseudo device     */

/* Error codes for extended attribute support */

#define ERROR_INVALID_EA_NAME                   254 /* Illegal chars in name */
#define ERROR_EA_LIST_INCONSISTENT              255 /* Size or some field bad */
#define ERROR_EA_LIST_TOO_LONG                  256 /* FEAlist > 64K-1 bytes */

/* Error code for FSH_WILDMATCH */

#define ERROR_NO_META_MATCH                     257 /* string doesn't match expression */

#define ERROR_FINDNOTIFY_TIMEOUT                258 /* FindNotify request
                                                       timeout */
#define ERROR_NO_MORE_ITEMS                     259 /* QFSAttach ordinal query */

#define ERROR_SEARCH_STRUC_REUSED               260 /* 3xbox findfirst/next
                                                       search structure reused */

/* Error code for FSH_FINDCHAR */

#define ERROR_CHAR_NOT_FOUND                    261 /* can't find char */

#define ERROR_TOO_MUCH_STACK                    262 /* Stack request exceeds
                                                       sys limit */

#define ERROR_INVALID_ATTR                      263 /* invalid FS_ATTRIBUTE */

#define ERROR_INVALID_STARTING_RING             264 /* 1.2 DCR 116 */
#define ERROR_INVALID_DLL_INIT_RING             265 /* 1.2 DCR 116 */

#define ERROR_CANNOT_COPY                       266 /* doscopy */
#define ERROR_DIRECTORY                         267 /* doscopy */

#define ERROR_OPLOCKED_FILE                     268 /* oplock */
#define ERROR_OPLOCK_THREAD_EXISTS              269 /* oplock */
#define ERROR_VOLUME_CHANGED                    270 /* MSG%none */
#define ERROR_FINDNOTIFY_HANDLE_IN_USE          271 /* MSG%none */
#define ERROR_FINDNOTIFY_HANDLE_CLOSED          272 /* MSG%none */
#define ERROR_NOTIFY_OBJECT_REMOVED             273 /* MSG%none */
#define ERROR_ALREADY_SHUTDOWN                  274 /* MSG%none */
#define ERROR_EAS_DIDNT_FIT                     275 /* MSG%none */
#define ERROR_EA_FILE_CORRUPT                   276 /* MSG%ERROR_EAS_CORRUPT */
#define ERROR_EA_TABLE_FULL                     277 /* MSG%EA_TABLE_FULL */
#define ERROR_INVALID_EA_HANDLE                 278 /* MSG%INVALID_EA_HANDLE */
#define ERROR_NO_CLUSTER                        279 /* MSG%NO_CLUSTER */
#define ERROR_CREATE_EA_FILE                    280 /* MSG%ERROR_CREATE_EA_FILE */
#define ERROR_CANNOT_OPEN_EA_FILE               281 /* MSG%CANNOT_OPEN_FILE */
#define ERROR_EAS_NOT_SUPPORTED                 282 /* MSG%EAS_NOT_SUPPORTED */
#define ERROR_NEED_EAS_FOUND                    283 /* MSG%NEED_EAS_FOUND */
#define ERROR_DUPLICATE_HANDLE                  284 /* MSG%EAS_DISCARDED */
#define ERROR_DUPLICATE_NAME                    285 /* MSG%none */
#define ERROR_EMPTY_MUXWAIT                     286 /* MSG%none */
#define ERROR_MUTEX_OWNED                       287 /* MSG%none */
#define ERROR_NOT_OWNER                         288 /* MSG%none */
#define ERROR_PARAM_TOO_SMALL                   289 /* MSG%none */
#define ERROR_TOO_MANY_HANDLES                  290 /* MSG%none */
#define ERROR_TOO_MANY_OPENS                    291 /* MSG%none */
#define ERROR_WRONG_TYPE                        292 /* MSG%none */
#define ERROR_UNUSED_CODE                       293 /* MSG%none */
#define ERROR_THREAD_NOT_TERMINATED             294 /* MSG%none */
#define ERROR_INIT_ROUTINE_FAILED               295 /* MSG%none */
#define ERROR_MODULE_IN_USE                     296 /* MSG%none */
#define ERROR_NOT_ENOUGH_WATCHPOINTS            297 /* MSG%none */
#define ERROR_TOO_MANY_POSTS                    298 /* MSG%none */
#define ERROR_ALREADY_POSTED                    299 /* MSG%none */
#define ERROR_ALREADY_RESET                     300 /* MSG%none */
#define ERROR_SEM_BUSY                          301 /* MSG%none */

/*      REMINDER: don't forget to update error.inc,     */
/*                oso001.txt and basemid.inc            */


#define ERROR_USER_DEFINED_BASE         0xFF00

#define ERROR_I24_WRITE_PROTECT         0
#define ERROR_I24_BAD_UNIT              1
#define ERROR_I24_NOT_READY             2
#define ERROR_I24_BAD_COMMAND           3
#define ERROR_I24_CRC                   4
#define ERROR_I24_BAD_LENGTH            5
#define ERROR_I24_SEEK                  6
#define ERROR_I24_NOT_DOS_DISK          7
#define ERROR_I24_SECTOR_NOT_FOUND      8
#define ERROR_I24_OUT_OF_PAPER          9
#define ERROR_I24_WRITE_FAULT           0x0A
#define ERROR_I24_READ_FAULT            0x0B
#define ERROR_I24_GEN_FAILURE           0x0C
#define ERROR_I24_DISK_CHANGE           0x0D
#define ERROR_I24_WRONG_DISK            0x0F
#define ERROR_I24_UNCERTAIN_MEDIA       0x10
#define ERROR_I24_CHAR_CALL_INTERRUPTED 0x11
#define ERROR_I24_NO_MONITOR_SUPPORT    0x12
#define ERROR_I24_INVALID_PARAMETER     0x13

#define ALLOWED_FAIL                    0x0001
#define ALLOWED_ABORT                   0x0002
#define ALLOWED_RETRY                   0x0004
#define ALLOWED_IGNORE                  0x0008
#define ALLOWED_DETACHED                0x8000

#define I24_OPERATION                   0x1
#define I24_AREA                        0x6
                                                          /* 01 if FAT */
                                                          /* 10 if root DIR */
                                                          /* 11 if DATA */
#define I24_CLASS                       0x80


/* Values for error CLASS */

#define ERRCLASS_OUTRES                 1         /* Out of Resource */
#define ERRCLASS_TEMPSIT                2         /* Temporary Situation */
#define ERRCLASS_AUTH                   3         /* Permission problem */
#define ERRCLASS_INTRN                  4         /* Internal System Error */
#define ERRCLASS_HRDFAIL                5         /* Hardware Failure */
#define ERRCLASS_SYSFAIL                6         /* System Failure */
#define ERRCLASS_APPERR                 7         /* Application Error */
#define ERRCLASS_NOTFND                 8         /* Not Found */
#define ERRCLASS_BADFMT                 9         /* Bad Format */
#define ERRCLASS_LOCKED                 10        /* Locked */
#define ERRCLASS_MEDIA                  11        /* Media Failure */
#define ERRCLASS_ALREADY                12        /* Collision with Existing Item */
#define ERRCLASS_UNK                    13        /* Unknown/other */
#define ERRCLASS_CANT                   14
#define ERRCLASS_TIME                   15

/* Values for error ACTION */

#define ERRACT_RETRY                    1         /* Retry */
#define ERRACT_DLYRET                   2         /* Delay Retry, retry after pause */
#define ERRACT_USER                     3         /* Ask user to regive info */
#define ERRACT_ABORT                    4         /* abort with clean up */
#define ERRACT_PANIC                    5         /* abort immediately */
#define ERRACT_IGNORE                   6         /* ignore */
#define ERRACT_INTRET                   7         /* Retry after User Intervention */

/* Values for error LOCUS */

#define ERRLOC_UNK                      1         /* No appropriate value */
#define ERRLOC_DISK                     2         /* Random Access Mass Storage */
#define ERRLOC_NET                      3         /* Network */
#define ERRLOC_SERDEV                   4         /* Serial Device */
#define ERRLOC_MEM                      5         /* Memory */

/* Abnormal termination codes */

#define TC_NORMAL               0
#define TC_HARDERR              1
#define TC_GP_TRAP              2
#define TC_SIGNAL               3

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\dvoicep.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvoice.h
 *  Content:    DirectPlayVoice include file
//@@BEGIN_MSINTERNAL
 *  History:
 *  Date        By          Reason
 *  =====       =======     ==================================================
 *  07/01/99    rodtoll     created
 *  06/23/2000  rodtoll     Bug #37556 - Hexify the DPVERR codes
 //@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DVOICE__
#define __DVOICE__


/****************************************************************************
 *
 * DirectPlayVoice Callback Functions
 *
 ****************************************************************************/
typedef HRESULT (FAR PASCAL *PDVMESSAGEHANDLER)(
    PVOID   pvUserContext,
    DWORD   dwMessageType,
    LPVOID  lpMessage
);

typedef PDVMESSAGEHANDLER LPDVMESSAGEHANDLER;

/****************************************************************************
 *
 * DirectPlayVoice Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

typedef DWORD DVID, *LPDVID, *PDVID;

/****************************************************************************
 *
 * DirectPlayVoice Message Types
 *
 ****************************************************************************/

#define DVMSGID_BASE                        0x0000

#define DVMSGID_MINBASE                     (DVMSGID_CREATEVOICEPLAYER)
#define DVMSGID_CREATEVOICEPLAYER           (DVMSGID_BASE+0x0001)
#define DVMSGID_DELETEVOICEPLAYER           (DVMSGID_BASE+0x0002)
#define DVMSGID_SESSIONLOST                 (DVMSGID_BASE+0x0003)
#define DVMSGID_PLAYERVOICESTART            (DVMSGID_BASE+0x0004)
#define DVMSGID_PLAYERVOICESTOP             (DVMSGID_BASE+0x0005)
#define DVMSGID_RECORDSTART                 (DVMSGID_BASE+0x0006)
#define DVMSGID_RECORDSTOP                  (DVMSGID_BASE+0x0007)
#define DVMSGID_CONNECTRESULT               (DVMSGID_BASE+0x0008)
#define DVMSGID_DISCONNECTRESULT            (DVMSGID_BASE+0x0009)
#define DVMSGID_INPUTLEVEL                  (DVMSGID_BASE+0x000A)
#define DVMSGID_VOICEPERIPHERALNOTPRESENT   (DVMSGID_BASE+0x000B)
#define DVMSGID_HOSTMIGRATED                (DVMSGID_BASE+0x000C)
#define DVMSGID_SETTARGETS                  (DVMSGID_BASE+0x000D)
#define DVMSGID_PLAYEROUTPUTLEVEL           (DVMSGID_BASE+0x000E)
#define DVMSGID_LOCALHOSTSETUP              (DVMSGID_BASE+0x0012)
#define DVMSGID_MAXBASE                     (DVMSGID_LOCALHOSTSETUP)

/****************************************************************************
 *
 * DirectPlayVoice Constants
 *
 ****************************************************************************/

#define DVID_SYS                0

//
// Used to identify the session host in client/server
//
#define DVID_SERVERPLAYER       1

//
// Used to target all players
//
#define DVID_ALLPLAYERS         0

//
// Used to identify the main buffer
//
#define DVID_REMAINING          0xFFFFFFFF

//
// Input level range
//
#define DVINPUTLEVEL_MIN                    0x00000000
#define DVINPUTLEVEL_MAX                    0x00000063  // 99 decimal

#define DVNOTIFYPERIOD_MINPERIOD            20

//
// Use the default value
//
#define DVTHRESHOLD_DEFAULT               0xFFFFFFFF

//
// Sensitivity Ranges
//
#define DVTHRESHOLD_MIN                   0x00000000
#define DVTHRESHOLD_MAX                   0x00000063    // 99 decimal

//
// Sensitivity field is not used
//
#define DVTHRESHOLD_UNUSED                0xFFFFFFFE

//
// Session Types
//
#define DVSESSIONTYPE_PEER                  0x00000001
#define DVSESSIONTYPE_MIXING                0x00000002
#define DVSESSIONTYPE_FORWARDING            0x00000003
#define DVSESSIONTYPE_ECHO                  0x00000004


/****************************************************************************
 *
 * DirectPlayVoice Flags
 *
 ****************************************************************************/

//
// Mute the recording
//
#define DVCLIENTCONFIG_RECORDMUTE           0x00000001

//
// Mute the playback
//
#define DVCLIENTCONFIG_PLAYBACKMUTE         0x00000002

//
// Voice Activation manual mode
//
#define DVCLIENTCONFIG_MANUALVOICEACTIVATED 0x00000004

//
// Only playback voices that have buffers created for them
//
#define DVCLIENTCONFIG_MUTEGLOBAL           0x00000010

//
// Enable automatic voice activation
//
#define DVCLIENTCONFIG_AUTOVOICEACTIVATED   0x00000020

//
// disables recording from the local player
// will also be set automatically if the voice peripheral gets removed
//

#define DVCLIENTCONFIG_HALFDUPLEX           0x00000040

//
// determines the behavior of DirectPlay Voice in the case where
// there is no voice peripheral attached to dwPort. If this flag is set,
// all voices that would have been sent to the voice peripheral for 
// playback will not be played at all. If this flag is not set, 
// all voices that would have been sent to the voice peripheral 
// for playback will be sent to the main audio output device (MCPX).
//

#define DVCLIENTCONFIG_MUTEIFNODEVICE       0x00000080

//
// API flags dwFlags field in Connect, etc
//

//
// Shutdown the voice session without migrating the host
//
#define DVFLAGS_NOHOSTMIGRATE               0x00000008

//
// Disable host migration in the voice session
//
#define DVSESSION_NOHOSTMIGRATION           0x00000001

//
// Server controlled targetting
//
#define DVSESSION_SERVERCONTROLTARGET       0x00000002

//
// Player is in half duplex mode
//
#define DVPLAYERCAPS_HALFDUPLEX             0x00000001

//
// Specifies that player is the local player
//
#define DVPLAYERCAPS_LOCAL                  0x00000002


/****************************************************************************
 *
 * DirectPlayVoice Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDirectPlayVoiceClient IDirectPlayVoiceClient;
typedef IDirectPlayVoiceClient *LPDIRECTPLAYVOICECLIENT, *PDIRECTPLAYVOICECLIENT;

typedef struct IDirectPlayVoiceServer IDirectPlayVoiceServer;
typedef IDirectPlayVoiceServer *LPDIRECTPLAYVOICESERVER, *PDIRECTPLAYVOICESERVER;

//@@BEGIN_MSINTERNAL

typedef struct IDirectPlayVoiceNotify IDirectPlayVoiceNotify;
typedef IDirectPlayVoiceNotify *LPDIRECTPLAYVOICENOTIFY, *PDIRECTPLAYVOICENOTIFY;

typedef struct IDirectPlayVoiceTransport IDirectPlayVoiceTransport;
typedef IDirectPlayVoiceTransport *LPDIRECTPLAYVOICETRANSPORT, *PDIRECTPLAYVOICETRANSPORT;

/****************************************************************************
 *
 * DirectPlayVoice Structures (Non-Message)
 *
 ****************************************************************************/

// DVTRANSPORTINFO
//
typedef struct
{
    // = sizeof( DVTRANSPORTINFO )
    DWORD           dwSize;
    // Combination of following flags:
    // DVTRANSPORT_MIGRATEHOST, DVTRANSPORT_MULTICAST
    // DVTRANSPORT_LOCALHOST
    DWORD           dwFlags;
    // Session Type the transport is running.  One of:
    // DVTRANSPORT_SESSION_PEERTOPEER
    // DVTRANSPORT_SESSION_CLIENTSERVER
    DWORD           dwSessionType;
    // ID of the player (Regular ID, not system) that
    // is the sesion host.
    DVID            dvidSessionHost;
    // ID of the local player (Regular ID, not system)
    DVID            dvidLocalID;
    // Maximum # of players allowed in the session,
    // 0 = unlimited.
    DWORD           dwMaxPlayers;
} DVTRANSPORTINFO, *LPDVTRANSPORTINFO, *PDVTRANSPORTINFO;


//
// Tunable definitions for deterministic memory usage
//

#define DV_MAX_REMOTE_PLAYERS   32
#define DV_MAX_QUEUED_SPEECH_FRAMES 32

//@@END_MSINTERNAL

//
// DirectPlayVoice Client Configuration
// (Connect / GetClientConfig)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Flags for client config (DVCLIENTCONFIG_...)
    DWORD   dwThreshold;            // Voice Activation Threshold 
    DWORD   dwPort;                 // Player Number(slot # on the xbox) to use for this dvoice instance
} DVCLIENTCONFIG, *LPDVCLIENTCONFIG, *PDVCLIENTCONFIG;

//
// DirectPlayVoice Session Description
// (Host / GetSessionDesc)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Session flags (DVSESSION_...)
    DWORD   dwSessionType;          // Session type (DVSESSIONTYPE_...)
    GUID    guidCT;                 // Compression Type to use
//@@BEGIN_MSINTERNAL
    DWORD   dwBufferQuality;        // Buffer quality
    DWORD   dwBufferAggressiveness; // Buffer aggresiveness
//@@END_MSINTERNAL

} DVSESSIONDESC, *LPDVSESSIONDESC, *PDVSESSIONDESC;

/****************************************************************************
 *
 * DirectPlayVoice message handler call back structures
 *
 ****************************************************************************/

//
// Result of the Connect() call.  (If it wasn't called Async)
// (DVMSGID_CONNECTRESULT)
//

typedef struct
{
    DWORD   dwSize;                         // Size of this structure
} DVMSG_VOICEPERIPHERALNOTPRESENT, *LPDVMSG_VOICEPERIPHERALNOTPRESENT, *PDVMSG_VOICEPERIPHERALNOTPRESENT;

//
// Result of the Connect() call.  (If it wasn't called Async)
// (DVMSGID_CONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Connect() call
} DVMSG_CONNECTRESULT, *LPDVMSG_CONNECTRESULT, *PDVMSG_CONNECTRESULT;

//
// A new player has entered the voice session
// (DVMSGID_CREATEVOICEPLAYER)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who joined
    DWORD   dwFlags;                        // Player flags (DVPLAYERCAPS_...)
    PVOID   pvPlayerContext;                // Context value for this player (user set)
} DVMSG_CREATEVOICEPLAYER, *LPDVMSG_CREATEVOICEPLAYER, *PDVMSG_CREATEVOICEPLAYER;

//
// A player has left the voice session
// (DVMSGID_DELETEVOICEPLAYER)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who left
    PVOID   pvPlayerContext;                // Context value for the player
} DVMSG_DELETEVOICEPLAYER, *LPDVMSG_DELETEVOICEPLAYER, *PDVMSG_DELETEVOICEPLAYER;

//
// Result of the Disconnect() call.  (If it wasn't called Async)
// (DVMSGID_DISCONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Disconnect() call
} DVMSG_DISCONNECTRESULT, *LPDVMSG_DISCONNECTRESULT, *PDVMSG_DISCONNECTRESULT;

//
// The voice session host has migrated.
// (DVMSGID_HOSTMIGRATED)
//
typedef struct
{
    DWORD                   dwSize;         // Size of this structure
    DVID                    dvidNewHostID;  // DVID of the player who is now the host
    LPDIRECTPLAYVOICESERVER pdvServerInterface;
                                            // Pointer to the new host object (if local player is now host)
} DVMSG_HOSTMIGRATED, *LPDVMSG_HOSTMIGRATED, *PDVMSG_HOSTMIGRATED;

//
// The current input level / recording volume on the local machine
// (DVMSGID_INPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Current peak level of the audio
    LONG    lRecordVolume;                  // Current recording volume
    PVOID   pvLocalPlayerContext;           // Context value for the local player
} DVMSG_INPUTLEVEL, *LPDVMSG_INPUTLEVEL, *PDVMSG_INPUTLEVEL;

//
// The local client is about to become the new host
// (DVMSGID_LOCALHOSTSETUP)
//
typedef struct
{
    DWORD               dwSize;             // Size of this structure
    PVOID               pvContext;          // Context value to be passed to Initialize() of new host object
    PDVMESSAGEHANDLER   pMessageHandler;    // Message handler to be used by new host object
} DVMSG_LOCALHOSTSETUP, *LPDVMSG_LOCALHOSTSETUP, *PDVMSG_LOCALHOSTSETUP;

//
// The current peak level of an individual player's incoming audio stream as it is
// being played back.
// (DVMSGID_PLAYEROUTPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;                   // DVID of the player
    DWORD   dwPeakLevel;                    // Peak level of the player's stream
    PVOID   pvPlayerContext;                // Context value for the player
} DVMSG_PLAYEROUTPUTLEVEL, *LPDVMSG_PLAYEROUTPUTLEVEL, *PDVMSG_PLAYEROUTPUTLEVEL;

//
// An audio stream from the specified player has started playing back on the local client.
// (DVMSGID_PLAYERVOICESTART).
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the Player
    PVOID   pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTART, *LPDVMSG_PLAYERVOICESTART, *PDVMSG_PLAYERVOICESTART;

//
// The audio stream from the specified player has stopped playing back on the local client.
// (DVMSGID_PLAYERVOICESTOP)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the player
    PVOID   pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTOP, *LPDVMSG_PLAYERVOICESTOP, *PDVMSG_PLAYERVOICESTOP;

//
// Transmission has started on the local machine
// (DVMSGID_RECORDSTART)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to start
    PVOID   pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTART, *LPDVMSG_RECORDSTART, *PDVMSG_RECORDSTART;

//
// Transmission has stopped on the local machine
// (DVMSGID_RECORDSTOP)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to stop
    PVOID   pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTOP, *LPDVMSG_RECORDSTOP, *PDVMSG_RECORDSTOP;

//
// The voice session has been lost
// (DVMSGID_SESSIONLOST)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Reason the session was disconnected
} DVMSG_SESSIONLOST, *LPDVMSG_SESSIONLOST, *PDVMSG_SESSIONLOST;

//
// The target list has been updated for the local client
// (DVMSGID_SETTARGETS)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwNumTargets;                   // # of targets
    PDVID   pdvidTargets;                   // An array of DVIDs specifying the current targets
} DVMSG_SETTARGETS, *LPDVMSG_SETTARGETS, *PDVMSG_SETTARGETS;

//@@BEGIN_MSINTERNAL

/****************************************************************************
 *
 * DirectPlayVoice Transport Defines / Types / Constants -- MS INTERNAL
 *
 ****************************************************************************/

// Transport session is peer-to-peer
#define DVTRANSPORT_SESSION_PEERTOPEER      0x00000001

// Transport session is client/server
#define DVTRANSPORT_SESSION_CLIENTSERVER    0x00000002

// Host can migrate
#define DVTRANSPORT_MIGRATEHOST             0x00000001

// Multicast optimizations are enabled
#define DVTRANSPORT_MULTICAST               0x00000002

// The local player is the host of the session
#define DVTRANSPORT_LOCALHOST               0x00000004

// Send the message guaranteed
#define DVTRANSPORT_SEND_GUARANTEED         0x00000001
#define DVTRANSPORT_SEND_SYNC               0x00000002

#define DVPEFLAGS_FIRSTPLAYER               0x00000001

#define DVTRANSPORT_OBJECTTYPE_SERVER       0x00000001
#define DVTRANSPORT_OBJECTTYPE_CLIENT       0x00000002
#define DVTRANSPORT_OBJECTTYPE_BOTH         (DVTRANSPORT_OBJECTTYPE_SERVER | DVTRANSPORT_OBJECTTYPE_CLIENT)

typedef struct _DVTRANSPORT_BUFFERDESC
{
    DWORD   dwBufferSize;
    PBYTE   pBufferData;
    LONG    lRefCount;
    PVOID   pvContext;
    DWORD   dwObjectType;
    DWORD   dwFlags;
} DVTRANSPORT_BUFFERDESC, *PDVTRANSPORT_BUFFERDESC;

/*
 * DIRECTVOICENOTIFY DEFINES
 *
 * Used to identify the type of notification in calls
 * to IDirectPlayVoiceNotify::NotifyEvent
 */

// No longer used
#define DVEVENT_STARTSESSION                0x00000001

// If the transport session is lost or shutdown
#define DVEVENT_STOPSESSION                 0x00000002

// A player was added to the system,
// Param1 = DVID of new player
// Param2 = Player context (set by handler and then returned)
#define DVEVENT_ADDPLAYER                   0x00000003

// A player disconnected.
// Param1 = DVID of disconnected player
// Param1 = Player context
#define DVEVENT_REMOVEPLAYER                0x00000004

// A group was created.  Param1 = DVID of created group
#define DVEVENT_CREATEGROUP                 0x00000005

// A group was deleted.  Param1 = DVID of deleted group
#define DVEVENT_DELETEGROUP                 0x00000006

// Player was added to a group.
// Param1 = DVID of group    Param2 = DVID of player
#define DVEVENT_ADDPLAYERTOGROUP            0x00000007

// Player was removed from the group
// Param1 = DVID of group    Param2 = DVID of player
#define DVEVENT_REMOVEPLAYERFROMGROUP       0x00000008

// Called when the host migrates
// Param1 = DVID of new host (player ID, not system ID)
#define DVEVENT_MIGRATEHOST                 0x00000009

// Called when a buffer the voice layer has given
// the transport is completed.
// Param1 = pointer to DVEVENTMSG_SENDCOMPLETE structure
//
#define DVEVENT_SENDCOMPLETE                0x0000000A

typedef struct _DVEVENTMSG_SENDCOMPLETE
{
    LPVOID                  pvUserContext;
    HRESULT                 hrSendResult;
} DVEVENTMSG_SENDCOMPLETE, *PDVEVENTMSG_SENDCOMPLETE;

//@@END_MSINTERNAL



/****************************************************************************
 *
 * DirectPlayVoice Functions
 *
 ****************************************************************************/

#define IID_IDirectPlayVoiceClient 1
#define IID_IDirectPlayVoiceServer 2

extern HRESULT WINAPI DirectPlayVoiceCreate(
    DWORD dwIID,
    void **ppvInterface,
    void *pUnknown);

extern HRESULT WINAPI XDirectPlayVoiceCreate(
	DWORD dwIID, 
	void** ppvInterface);

/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

ULONG WINAPI IDirectPlayVoiceClient_AddRef(LPDIRECTPLAYVOICECLIENT pArg1);
ULONG WINAPI IDirectPlayVoiceClient_Release(LPDIRECTPLAYVOICECLIENT pArg1);

HRESULT WINAPI IDirectPlayVoiceClient_Initialize(LPDIRECTPLAYVOICECLIENT pArg0, PVOID pArg1, PDVMESSAGEHANDLER pArg2, PVOID pArg3, LPDWORD pArg4, DWORD Arg5);
HRESULT WINAPI IDirectPlayVoiceClient_Connect(LPDIRECTPLAYVOICECLIENT pArg0, PDVCLIENTCONFIG pArg1, DWORD Arg2 );
HRESULT WINAPI IDirectPlayVoiceClient_Disconnect(LPDIRECTPLAYVOICECLIENT pArg0, DWORD Arg1 );
HRESULT WINAPI IDirectPlayVoiceClient_DoWork(LPDIRECTPLAYVOICECLIENT pArg0);
HRESULT WINAPI IDirectPlayVoiceClient_GetSessionDesc(LPDIRECTPLAYVOICECLIENT pArg0, PDVSESSIONDESC pArg1 );
HRESULT WINAPI IDirectPlayVoiceClient_GetClientConfig(LPDIRECTPLAYVOICECLIENT pArg0, PDVCLIENTCONFIG pArg1 );
HRESULT WINAPI IDirectPlayVoiceClient_SetClientConfig(LPDIRECTPLAYVOICECLIENT pArg0, PDVCLIENTCONFIG pArg1 );
HRESULT WINAPI IDirectPlayVoiceClient_CreateSoundTarget(LPDIRECTPLAYVOICECLIENT pArg0, DVID dvidID, PWAVEFORMATEX *ppwfxMediaFormat, XMediaObject **ppMediaObject);
HRESULT WINAPI IDirectPlayVoiceClient_DeleteSoundTarget(LPDIRECTPLAYVOICECLIENT pArg0, DVID dvidID, XMediaObject **ppMediaObject);
HRESULT WINAPI IDirectPlayVoiceClient_SetTransmitTargets(LPDIRECTPLAYVOICECLIENT pArg0, PDVID pArg1, DWORD Arg2, DWORD Arg3 );
HRESULT WINAPI IDirectPlayVoiceClient_GetTransmitTargets(LPDIRECTPLAYVOICECLIENT pArg0, PDVID pArg1, PDWORD pArg2, DWORD Arg3 );
HRESULT WINAPI IDirectPlayVoiceClient_SetNotifyMask(LPDIRECTPLAYVOICECLIENT pArg0, PDWORD pArg1, DWORD Arg2 );


#ifdef __cplusplus
}
#endif // __cplusplus

/*
 * DIRECTVOICE Interface Definition
 *
 */

#ifdef __cplusplus

struct IDirectPlayVoiceClient
{

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlayVoiceClient_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlayVoiceClient_Release(this);
    }

    /*** IDirectPlayVoiceClient methods ***/
    __inline HRESULT STDMETHODCALLTYPE Initialize (PVOID pArg1, PDVMESSAGEHANDLER pArg2, PVOID pArg3, LPDWORD pArg4, DWORD Arg5 )
    {
        return IDirectPlayVoiceClient_Initialize(this,pArg1,pArg2,pArg3,pArg4, Arg5);
    }

    __inline HRESULT STDMETHODCALLTYPE Connect (PDVCLIENTCONFIG pArg1, DWORD Arg2 )
    {
        return IDirectPlayVoiceClient_Connect(this,pArg1,Arg2);
    }

    __inline HRESULT STDMETHODCALLTYPE Disconnect (DWORD Arg1 )
    {
        return IDirectPlayVoiceClient_Disconnect(this,Arg1);
    }

    __inline HRESULT STDMETHODCALLTYPE DoWork ()
    {

        return IDirectPlayVoiceClient_DoWork(this);

    }

    __inline HRESULT STDMETHODCALLTYPE GetSessionDesc (PDVSESSIONDESC pArg1 )
    {
        return IDirectPlayVoiceClient_GetSessionDesc(this,pArg1);
    }

    __inline HRESULT STDMETHODCALLTYPE GetClientConfig (PDVCLIENTCONFIG pArg1 )
    {
        return IDirectPlayVoiceClient_GetClientConfig(this,pArg1);
    }

    __inline HRESULT STDMETHODCALLTYPE SetClientConfig (PDVCLIENTCONFIG pArg1 )
    {
        return IDirectPlayVoiceClient_SetClientConfig(this,pArg1);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateSoundTarget( DVID dvidID, PWAVEFORMATEX *ppwfxMediaFormat, XMediaObject **ppMediaObject)
    {
        return IDirectPlayVoiceClient_CreateSoundTarget( this, dvidID, ppwfxMediaFormat, ppMediaObject);
    }

    __inline HRESULT STDMETHODCALLTYPE DeleteSoundTarget( DVID dvidID, XMediaObject **ppMediaObject )
    {
        return IDirectPlayVoiceClient_DeleteSoundTarget( this, dvidID, ppMediaObject );
    }

    __inline HRESULT STDMETHODCALLTYPE SetTransmitTargets (PDVID pArg1, DWORD Arg2, DWORD Arg3 )
    {
        return IDirectPlayVoiceClient_SetTransmitTargets(this, pArg1, Arg2, Arg3);
    }

    __inline HRESULT STDMETHODCALLTYPE GetTransmitTargets (PDVID pArg1, PDWORD pArg2, DWORD Arg3 )
    {
        return IDirectPlayVoiceClient_GetTransmitTargets(this, pArg1, pArg2, Arg3);
    }

    __inline HRESULT STDMETHODCALLTYPE SetNotifyMask (PDWORD pArg1, DWORD Arg2 )
    {
        return IDirectPlayVoiceClient_SetNotifyMask(this, pArg1, Arg2);
    }

};

#endif // __cplusplus

//@@BEGIN_MSINTERNAL

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

ULONG WINAPI IDirectPlayVoiceNotify_AddRef(LPDIRECTPLAYVOICENOTIFY pArg1);
ULONG WINAPI IDirectPlayVoiceNotify_Release(LPDIRECTPLAYVOICENOTIFY pArg1);

HRESULT WINAPI IDirectPlayVoiceNotify_Initialize(LPDIRECTPLAYVOICENOTIFY pArg1);
HRESULT WINAPI IDirectPlayVoiceNotify_NotifyEvent(LPDIRECTPLAYVOICENOTIFY pArg0, DWORD Arg1, DWORD Arg2, DWORD Arg3);
HRESULT WINAPI IDirectPlayVoiceNotify_ReceiveSpeechMessage(LPDIRECTPLAYVOICENOTIFY pArg0, DVID Arg1, DVID Arg2, PVOID pArg3, DWORD Arg4);

#ifdef __cplusplus
}
#endif // __cplusplus


#ifdef __cplusplus

struct IDirectPlayVoiceNotify
{

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlayVoiceNotify_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlayVoiceNotify_Release(this);
    }

    // Initialize
    //
    // Initializes the DirectPlayVoice interface associated with this
    // interface.  During this call DirectPlayVoice will call
    // GetSessionInfo on the associated Transport interface.
    //

    __inline HRESULT STDMETHODCALLTYPE Initialize()
    {
        return IDirectPlayVoiceNotify_Initialize(this);
    }

    // NotifyEvent
    //
    // Called when an event occurs that DirectPlayVoice needs to be informed
    // of.  See descriptions of DVEVENT_XXXXX for how the parameters are
    // used for each message.
    //
    // DWORD - Type of message (DVEVENT_XXXXXX)
    // DWORD - Param1
    // DWORD - Param2
    //

    __inline HRESULT STDMETHODCALLTYPE NotifyEvent(DWORD Arg1, DWORD Arg2, DWORD Arg3)
    {
        return IDirectPlayVoiceNotify_NotifyEvent(this, Arg1, Arg2, Arg3);
    }

    // ReceiveSpeechMessage
    //
    // Called when a message is received by DirectPlay that is for
    // DirectPlayVoice.
    //
    // DVID - Source of the message
    // LPVOID - Pointer to message buffer
    // DWORD - Size of the received message
    //
    __inline HRESULT STDMETHODCALLTYPE ReceiveSpeechMessage(DVID Arg1, DVID Arg2, PVOID pArg3, DWORD Arg4)
    {
        return IDirectPlayVoiceNotify_ReceiveSpeechMessage(this, Arg1, Arg2, pArg3, Arg4);
    }

};

#endif // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

ULONG WINAPI IDirectPlayVoiceTransport_AddRef(LPDIRECTPLAYVOICETRANSPORT pArg1);
ULONG WINAPI IDirectPlayVoiceTransport_Release(LPDIRECTPLAYVOICETRANSPORT pArg1);

HRESULT WINAPI IDirectPlayVoiceTransport_DoWork(LPDIRECTPLAYVOICETRANSPORT pArg0, DWORD Arg1);
HRESULT WINAPI IDirectPlayVoiceTransport_Advise(LPDIRECTPLAYVOICETRANSPORT pArg0, LPUNKNOWN pArg1, DWORD pArg2);
HRESULT WINAPI IDirectPlayVoiceTransport_UnAdvise(LPDIRECTPLAYVOICETRANSPORT pArg0, DWORD Arg1);
HRESULT WINAPI IDirectPlayVoiceTransport_IsGroupMember(LPDIRECTPLAYVOICETRANSPORT pArg0, DVID Arg1, DVID Arg2);
HRESULT WINAPI IDirectPlayVoiceTransport_SendSpeech(LPDIRECTPLAYVOICETRANSPORT pArg0, DVID Arg1, DVID Arg2, PVOID pArg3, PVOID pArg4, DWORD Arg5);
HRESULT WINAPI IDirectPlayVoiceTransport_GetSessionInfo(LPDIRECTPLAYVOICETRANSPORT pArg0, PDVTRANSPORTINFO pArg1);
HRESULT WINAPI IDirectPlayVoiceTransport_IsValidEntity(LPDIRECTPLAYVOICETRANSPORT pArg0, DVID Arg1, PBOOL pArg2);
HRESULT WINAPI IDirectPlayVoiceTransport_SendSpeechEx(LPDIRECTPLAYVOICETRANSPORT pArg0, DVID Arg1, DWORD Arg2, PDVID pArg3, PVOID pArg4, PVOID Arg5, DWORD Arg6);
HRESULT WINAPI IDirectPlayVoiceTransport_IsValidGroup(LPDIRECTPLAYVOICETRANSPORT pArg0, DVID Arg1, PBOOL pArg2);
HRESULT WINAPI IDirectPlayVoiceTransport_IsValidPlayer(LPDIRECTPLAYVOICETRANSPORT pArg0, DVID Arg1, PBOOL pArg2);

#ifdef __cplusplus
}
#endif // __cplusplus

#ifdef __cplusplus

struct IDirectPlayVoiceTransport
{

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlayVoiceTransport_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlayVoiceTransport_Release(this);
    }

    /*** IDirectPlayVoiceTransport methods ***/

    // DoWork
    //

    __inline HRESULT STDMETHODCALLTYPE DoWork(DWORD Arg1)
    {
        return IDirectPlayVoiceTransport_DoWork(this, Arg1);
    }

    // Advise
    //
    // Advises the transport to call us back via the interface passed in the
    // LLPUNKNOWN parameter.  QueryInterface on the LPUNKNOWN for a
    // IDirectPlayVoiceNotify.  Must call IDirectPlayVoiceNotify::INitialize
    // on the interface before returning.
    //
    // LPUNKNOWN - IUnknown interface for the IDirectPlayVoiceNotify to
    //             make notifications on.
    // DWORD - Voice Object Type (DVTRANSPORT_OBJECTTYPE_XXXX)
    //

    __inline HRESULT STDMETHODCALLTYPE Advise(LPUNKNOWN pArg1, DWORD Arg2)
    {
        return IDirectPlayVoiceTransport_Advise(this, pArg1, Arg2);
    }

    // UnAdvise
    //
    // Tells the transport that we no longer need to be called back on our
    // notify interface.  The transport should Release the instance of the
    // notify interface that they have.
    //
    // DWORD - Voice Object Type (DVTRANSPORT_OBJECTTYPE_XXXX)
    //

    __inline HRESULT STDMETHODCALLTYPE UnAdvise(DWORD Arg1)
    {
        return IDirectPlayVoiceTransport_UnAdvise(this, Arg1);
    }

    // IsGroupMember
    //
    // This function returns DP_OK if the specified user is a member of
    // the specified group.
    //
    // DVID - DVID of the group to check
    // DVID - DVID of the player
    //
    __inline HRESULT STDMETHODCALLTYPE IsGroupMember(DVID Arg1, DVID Arg2)
    {
        return IDirectPlayVoiceTransport_IsGroupMember(this, Arg1, Arg2);
    }


    // SendSpeech
    //
    // Transmits a message from the specified user ID to the specified user ID.
    // (Speech specific).  Messages sent through this interface are always
    // sent ASYNC and if the DVTRANSPORT_SEND_GUARANTEED flag is specified
    // then the message MUST be sent guaranteed.
    //
    // DVID - ID of the player this will be from.
    // DVID - ID of the player this will be sent to.
    // LPVOID - Pointer to the data to send
    // LPVOID - User context for send
    // DWORD - FLags (Combination of DVTRANSPORT_SEND_GUARANTEED).
    //

    __inline HRESULT STDMETHODCALLTYPE SendSpeech(DVID Arg1, DVID Arg2, PVOID pArg3, PVOID pArg4, DWORD Arg5)
    {
        return IDirectPlayVoiceTransport_SendSpeech(this, Arg1, Arg2, pArg3, pArg4, Arg5);
    }

    // GetSessionInfo
    //
    // Fills the passed structure with details on the session that is running
    // on the transport object.  See description of DVTRANSPORTINFO for details.
    //
    __inline HRESULT STDMETHODCALLTYPE GetSessionInfo(PDVTRANSPORTINFO pArg1)
    {
        return IDirectPlayVoiceTransport_GetSessionInfo(this, pArg1);
    }

    // IsValidEntity
    //
    // Checks to see if specified user is valid player or group in session
    // DVID = ID of the entity to check
    // LPBOOL = Pointer to BOOL to place result.  TRUE for Valid Player/
    //          Group, FALSE if it is not.
    //
    // Not needed in Client/Server Mode
    __inline HRESULT STDMETHODCALLTYPE IsValidEntity(DVID Arg1, PBOOL pArg2)
    {
        return IDirectPlayVoiceTransport_IsValidEntity(this, Arg1, pArg2);
    }

    // SendSpeechEx
    //
    // Transmits a message from the specified user ID to the specified user ID.
    // (Speech specific).  Messages sent through this interface are always
    // sent ASYNC and if the DVTRANSPORT_SEND_GUARANTEED flag is specified
    // then the message MUST be sent guaranteed.
    //
    // DVID - ID of the player this will be from.
    // DWORD - count on entries in (DVID *)[] array
    // LPDVID - Array of send targets
    // LPVOID - Pointer to the data to send
    // LPVOID - User context for send
    // DWORD - Flags (Combination of DVTRANSPORT_SEND_GUARANTEED).
    //

    __inline HRESULT STDMETHODCALLTYPE SendSpeechEx(DVID Arg1, DWORD Arg2, PDVID pArg3, PVOID pArg4, PVOID pArg5, DWORD Arg6)
    {
        return IDirectPlayVoiceTransport_SendSpeechEx(this, Arg1, Arg2, pArg3, pArg4, pArg5, Arg6);
    }

    // IsValidGroup
    //
    // Checks to see if the specified ID is a valid Group ID
    //
    // DVID = ID of the entity to check
    //
    __inline HRESULT STDMETHODCALLTYPE IsValidGroup(DVID Arg1, PBOOL pArg2)
    {
        return IDirectPlayVoiceTransport_IsValidGroup(this, Arg1, pArg2);
    }

    // IsValidPlayer
    //
    // Checks to see if the specified ID is a valid Player ID
    //
    // DVID = ID of the entity to check
    //
    __inline HRESULT STDMETHODCALLTYPE IsValidPlayer(DVID Arg1, PBOOL pArg2)
    {
        return IDirectPlayVoiceTransport_IsValidPlayer(this, Arg1, pArg2);
    }



};

#endif // __cplusplus

//@@END_MSINTERNAL


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

ULONG WINAPI IDirectPlayVoiceServer_AddRef(LPDIRECTPLAYVOICESERVER pArg1);
ULONG WINAPI IDirectPlayVoiceServer_Release(LPDIRECTPLAYVOICESERVER pArg1);

HRESULT WINAPI IDirectPlayVoiceServer_Initialize(LPDIRECTPLAYVOICESERVER pArg0,PVOID pArg1, PDVMESSAGEHANDLER pArg2, PVOID pArg3, LPDWORD pArg4, DWORD Arg5 );
HRESULT WINAPI IDirectPlayVoiceServer_StartSession(LPDIRECTPLAYVOICESERVER pArg0,PDVSESSIONDESC pArg1, DWORD Arg2);
HRESULT WINAPI IDirectPlayVoiceServer_StopSession(LPDIRECTPLAYVOICESERVER pArg0,DWORD Arg1);
HRESULT WINAPI IDirectPlayVoiceServer_GetSessionDesc(LPDIRECTPLAYVOICESERVER pArg0,PDVSESSIONDESC pArg1 );
HRESULT WINAPI IDirectPlayVoiceServer_SetTransmitTargets(LPDIRECTPLAYVOICESERVER pArg0,DVID Arg1, PDVID pArg2, DWORD Arg3, DWORD Arg4 );
HRESULT WINAPI IDirectPlayVoiceServer_GetTransmitTargets(LPDIRECTPLAYVOICESERVER pArg0,DVID Arg1, PDVID pArg2, PDWORD Arg3, DWORD Arg4 );
HRESULT WINAPI IDirectPlayVoiceServer_SetNotifyMask(LPDIRECTPLAYVOICESERVER pArg0,PDWORD pArg1, DWORD Arg2 );

#ifdef __cplusplus
}
#endif // __cplusplus

#ifdef __cplusplus

struct IDirectPlayVoiceServer
{
    /*** IUnknown methods ***/

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlayVoiceServer_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlayVoiceServer_Release(this);
    }

    /*** IDirectPlayVoiceServer methods ***/
    __inline HRESULT STDMETHODCALLTYPE Initialize (PVOID pArg1, PDVMESSAGEHANDLER pArg2, PVOID pArg3, LPDWORD pArg4, DWORD Arg5 )
    {
        return IDirectPlayVoiceServer_Initialize(this,pArg1,pArg2,pArg3,pArg4, Arg5);
    }

    __inline HRESULT STDMETHODCALLTYPE StartSession(PDVSESSIONDESC pArg1, DWORD Arg2)
    {
        return IDirectPlayVoiceServer_StartSession(this,pArg1,Arg2);
    }

    __inline HRESULT STDMETHODCALLTYPE StopSession(DWORD Arg1)
    {
        return IDirectPlayVoiceServer_StopSession(this,Arg1);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSessionDesc (PDVSESSIONDESC pArg1 )
    {
        return IDirectPlayVoiceServer_GetSessionDesc(this,pArg1);
    }

    __inline HRESULT STDMETHODCALLTYPE SetTransmitTargets (DVID Arg1, PDVID pArg2, DWORD Arg3, DWORD Arg4 )
    {
        return IDirectPlayVoiceServer_SetTransmitTargets(this, Arg1, pArg2, Arg3, Arg4);
    }

    __inline HRESULT STDMETHODCALLTYPE GetTransmitTargets (DVID Arg1, PDVID pArg2, PDWORD pArg3, DWORD Arg4 )
    {
        return IDirectPlayVoiceServer_GetTransmitTargets(this, Arg1, pArg2, pArg3, Arg4);
    }

    __inline HRESULT STDMETHODCALLTYPE SetNotifyMask (PDWORD pArg1, DWORD Arg2 )
    {
        return IDirectPlayVoiceServer_SetNotifyMask(this, pArg1, Arg2);
    }

};

#endif // __cplusplus


/****************************************************************************
 *
 * DIRECTPLAYVOICE ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _FACDPV  0x15
#define MAKE_DVHRESULT( code )          MAKE_HRESULT( 1, _FACDPV, code )

#define DV_OK                           S_OK
#define DV_FULLDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x0005 )
#define DV_HALFDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x000A )
#define DV_PENDING                      MAKE_HRESULT( 0, _FACDPV,  0x0010 )

#define DVERR_BUFFERTOOSMALL            MAKE_DVHRESULT(  0x001E )
#define DVERR_EXCEPTION                 MAKE_DVHRESULT(  0x004A )
#define DVERR_GENERIC                   E_FAIL
#define DVERR_INVALIDFLAGS              MAKE_DVHRESULT( 0x0078 )
#define DVERR_INVALIDOBJECT             MAKE_DVHRESULT( 0x0082 )
#define DVERR_INVALIDPARAM              E_INVALIDARG
#define DVERR_INVALIDPLAYER             MAKE_DVHRESULT( 0x0087 )
#define DVERR_INVALIDGROUP              MAKE_DVHRESULT( 0x0091 )
#define DVERR_INVALIDHANDLE             MAKE_DVHRESULT( 0x0096 )
#define DVERR_OUTOFMEMORY               E_OUTOFMEMORY
#define DVERR_PENDING                   DV_PENDING
#define DVERR_NOTSUPPORTED              E_NOTIMPL
#define DVERR_NOINTERFACE               E_NOINTERFACE
#define DVERR_SESSIONLOST               MAKE_DVHRESULT( 0x012C )
#define DVERR_NOVOICESESSION            MAKE_DVHRESULT( 0x012E )
#define DVERR_CONNECTIONLOST            MAKE_DVHRESULT( 0x0168 )
#define DVERR_NOTINITIALIZED            MAKE_DVHRESULT( 0x0169 )
#define DVERR_CONNECTED                 MAKE_DVHRESULT( 0x016A )
#define DVERR_NOTCONNECTED              MAKE_DVHRESULT( 0x016B )
#define DVERR_CONNECTABORTING           MAKE_DVHRESULT( 0x016E )
#define DVERR_NOTALLOWED                MAKE_DVHRESULT( 0x016F )
#define DVERR_INVALIDTARGET             MAKE_DVHRESULT( 0x0170 )
#define DVERR_TRANSPORTNOTHOST          MAKE_DVHRESULT( 0x0171 )
#define DVERR_COMPRESSIONNOTSUPPORTED   MAKE_DVHRESULT( 0x0172 )
#define DVERR_ALREADYPENDING            MAKE_DVHRESULT( 0x0173 )
#define DVERR_SOUNDINITFAILURE          MAKE_DVHRESULT( 0x0174 )
#define DVERR_TIMEOUT                   MAKE_DVHRESULT( 0x0175 )
#define DVERR_CONNECTABORTED            MAKE_DVHRESULT( 0x0176 )
#define DVERR_NO3DSOUND                 MAKE_DVHRESULT( 0x0177 )
#define DVERR_ALREADYBUFFERED           MAKE_DVHRESULT( 0x0178 )
#define DVERR_NOTBUFFERED               MAKE_DVHRESULT( 0x0179 )
#define DVERR_HOSTING                   MAKE_DVHRESULT( 0x017A )
#define DVERR_NOTHOSTING                MAKE_DVHRESULT( 0x017B )
#define DVERR_INVALIDDEVICE             MAKE_DVHRESULT( 0x017C )
#define DVERR_RECORDSYSTEMERROR         MAKE_DVHRESULT( 0x017D )
#define DVERR_PLAYBACKSYSTEMERROR       MAKE_DVHRESULT( 0x017E )
#define DVERR_SENDERROR                 MAKE_DVHRESULT( 0x017F )
#define DVERR_USERCANCEL                MAKE_DVHRESULT( 0x0180 )
#define DVERR_RUNSETUP                  MAKE_DVHRESULT( 0x0183 )
#define DVERR_INCOMPATIBLEVERSION       MAKE_DVHRESULT( 0x0184 )
#define DVERR_INITIALIZED               MAKE_DVHRESULT( 0x0187 )
#define DVERR_INVALIDPOINTER            E_POINTER
#define DVERR_NOTRANSPORT               MAKE_DVHRESULT( 0x0188 )
#define DVERR_NOCALLBACK                MAKE_DVHRESULT( 0x0189 )
#define DVERR_TRANSPORTNOTINIT          MAKE_DVHRESULT( 0x018A )
#define DVERR_TRANSPORTNOSESSION        MAKE_DVHRESULT( 0x018B )
#define DVERR_TRANSPORTNOPLAYER         MAKE_DVHRESULT( 0x018C )
#define DVERR_INVALIDBUFFER             MAKE_DVHRESULT( 0x018F )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\iadsp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0266 */
/* at Thu Jun 03 10:51:13 1999
 */
/* Compiler settings for adsp.odl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __iadsp_h__
#define __iadsp_h__

/* Forward Declarations */ 

#ifndef __IADsValue_FWD_DEFINED__
#define __IADsValue_FWD_DEFINED__
typedef interface IADsValue IADsValue;
#endif 	/* __IADsValue_FWD_DEFINED__ */


#ifndef __IADsObjOptPrivate_FWD_DEFINED__
#define __IADsObjOptPrivate_FWD_DEFINED__
typedef interface IADsObjOptPrivate IADsObjOptPrivate;
#endif 	/* __IADsObjOptPrivate_FWD_DEFINED__ */


#ifndef __IADsPathnameProvider_FWD_DEFINED__
#define __IADsPathnameProvider_FWD_DEFINED__
typedef interface IADsPathnameProvider IADsPathnameProvider;
#endif 	/* __IADsPathnameProvider_FWD_DEFINED__ */


#ifndef __PathnameProvider_FWD_DEFINED__
#define __PathnameProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class PathnameProvider PathnameProvider;
#else
typedef struct PathnameProvider PathnameProvider;
#endif /* __cplusplus */

#endif 	/* __PathnameProvider_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_adsp_0000 */
/* [local] */ 

#define IID_IDirectoryAttrMgmt IID_IDirectorySchemaMgmt
#define IDirectoryAttrMgmt IDirectorySchemaMgmt


extern RPC_IF_HANDLE __MIDL_itf_adsp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_adsp_0000_v0_0_s_ifspec;


#ifndef __ActiveDsP_LIBRARY_DEFINED__
#define __ActiveDsP_LIBRARY_DEFINED__

/* library ActiveDsP */
/* [helpstring][version][uuid] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_adsp_0000_0001
    {	ADS_PRIVATE_OPTION_SPECIFIC_SERVER	= 101,
	ADS_PRIVATE_OPTION_KEEP_HANDLES	= 102
    }	ADS_PRIVATE_OPTION_ENUM;

typedef struct _path_component
    {
    LPTSTR szComponent;
    LPTSTR szValue;
    }	PATH_COMPONENT;

typedef struct _path_component __RPC_FAR *PPATH_COMPONENT;

typedef struct _path_objectinfo
    {
    LPTSTR ProviderName;
    LPTSTR ServerName;
    LPTSTR DisplayServerName;
    DWORD dwPathType;
    DWORD NumComponents;
    PATH_COMPONENT ComponentArray[ 64 ];
    PATH_COMPONENT DisplayComponentArray[ 64 ];
    PATH_COMPONENT ProvSpecComponentArray[ 64 ];
    }	PATH_OBJECTINFO;

typedef struct _path_objectinfo __RPC_FAR *PPATH_OBJECTINFO;


enum __MIDL___MIDL_itf_adsp_0109_0001
    {	ADS_PARSE_FULL	= 1,
	ADS_PARSE_DN	= 2,
	ADS_PARSE_COMPONENT	= 3
    };

enum __MIDL___MIDL_itf_adsp_0109_0002
    {	ADS_PATHTYPE_ROOTFIRST	= 1,
	ADS_PATHTYPE_LEAFFIRST	= 2
    };

enum __MIDL___MIDL_itf_adsp_0109_0003
    {	ADS_CONSTRUCT_NAMINGATTRIBUTE	= 1
    };

EXTERN_C const IID LIBID_ActiveDsP;

#ifndef __IADsValue_INTERFACE_DEFINED__
#define __IADsValue_INTERFACE_DEFINED__

/* interface IADsValue */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1e3ef0aa-aef5-11d0-8537-00c04fd8d503")
    IADsValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConvertADsValueToPropertyValue( 
            PADSVALUE pADsValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertPropertyValueToADsValue( 
            PADSVALUE pADsValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertPropertyValueToADsValue2( 
            PADSVALUE pADsValue,
            BSTR pszServerName,
            BSTR userName,
            BSTR passWord,
            LONG flags,
            BOOL fNTDSType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IADsValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IADsValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IADsValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertADsValueToPropertyValue )( 
            IADsValue __RPC_FAR * This,
            PADSVALUE pADsValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertPropertyValueToADsValue )( 
            IADsValue __RPC_FAR * This,
            PADSVALUE pADsValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertPropertyValueToADsValue2 )( 
            IADsValue __RPC_FAR * This,
            PADSVALUE pADsValue,
            BSTR pszServerName,
            BSTR userName,
            BSTR passWord,
            LONG flags,
            BOOL fNTDSType);
        
        END_INTERFACE
    } IADsValueVtbl;

    interface IADsValue
    {
        CONST_VTBL struct IADsValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsValue_ConvertADsValueToPropertyValue(This,pADsValue)	\
    (This)->lpVtbl -> ConvertADsValueToPropertyValue(This,pADsValue)

#define IADsValue_ConvertPropertyValueToADsValue(This,pADsValue)	\
    (This)->lpVtbl -> ConvertPropertyValueToADsValue(This,pADsValue)

#define IADsValue_ConvertPropertyValueToADsValue2(This,pADsValue,pszServerName,userName,passWord,flags,fNTDSType)	\
    (This)->lpVtbl -> ConvertPropertyValueToADsValue2(This,pADsValue,pszServerName,userName,passWord,flags,fNTDSType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsValue_ConvertADsValueToPropertyValue_Proxy( 
    IADsValue __RPC_FAR * This,
    PADSVALUE pADsValue);


void __RPC_STUB IADsValue_ConvertADsValueToPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsValue_ConvertPropertyValueToADsValue_Proxy( 
    IADsValue __RPC_FAR * This,
    PADSVALUE pADsValue);


void __RPC_STUB IADsValue_ConvertPropertyValueToADsValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsValue_ConvertPropertyValueToADsValue2_Proxy( 
    IADsValue __RPC_FAR * This,
    PADSVALUE pADsValue,
    BSTR pszServerName,
    BSTR userName,
    BSTR passWord,
    LONG flags,
    BOOL fNTDSType);


void __RPC_STUB IADsValue_ConvertPropertyValueToADsValue2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsValue_INTERFACE_DEFINED__ */


#ifndef __IADsObjOptPrivate_INTERFACE_DEFINED__
#define __IADsObjOptPrivate_INTERFACE_DEFINED__

/* interface IADsObjOptPrivate */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsObjOptPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46f14fda-232b-11d1-a808-00c04fd8d5a8")
    IADsObjOptPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOption( 
            DWORD dwOption,
            void __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            DWORD dwOption,
            void __RPC_FAR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsObjOptPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IADsObjOptPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IADsObjOptPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IADsObjOptPrivate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )( 
            IADsObjOptPrivate __RPC_FAR * This,
            DWORD dwOption,
            void __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )( 
            IADsObjOptPrivate __RPC_FAR * This,
            DWORD dwOption,
            void __RPC_FAR *pValue);
        
        END_INTERFACE
    } IADsObjOptPrivateVtbl;

    interface IADsObjOptPrivate
    {
        CONST_VTBL struct IADsObjOptPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsObjOptPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsObjOptPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsObjOptPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsObjOptPrivate_GetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> GetOption(This,dwOption,pValue)

#define IADsObjOptPrivate_SetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> SetOption(This,dwOption,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsObjOptPrivate_GetOption_Proxy( 
    IADsObjOptPrivate __RPC_FAR * This,
    DWORD dwOption,
    void __RPC_FAR *pValue);


void __RPC_STUB IADsObjOptPrivate_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsObjOptPrivate_SetOption_Proxy( 
    IADsObjOptPrivate __RPC_FAR * This,
    DWORD dwOption,
    void __RPC_FAR *pValue);


void __RPC_STUB IADsObjOptPrivate_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsObjOptPrivate_INTERFACE_DEFINED__ */


#ifndef __IADsPathnameProvider_INTERFACE_DEFINED__
#define __IADsPathnameProvider_INTERFACE_DEFINED__

/* interface IADsPathnameProvider */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsPathnameProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aacd1d30-8bd0-11d2-92a9-00c04f79f834")
    IADsPathnameProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParsePath( 
            /* [in] */ BSTR bstrPath,
            /* [in] */ DWORD dwType,
            /* [in] */ PPATH_OBJECTINFO pObjectInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConstructPath( 
            /* [in] */ PPATH_OBJECTINFO pObjectInfo,
            /* [in] */ DWORD dwType,
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwEscapedMode,
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEscapedElement( 
            /* [in] */ LONG lnReserved,
            /* [in] */ BSTR bstrInStr,
            /* [out] */ BSTR __RPC_FAR *pbstrOutStr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPathnameProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IADsPathnameProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IADsPathnameProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IADsPathnameProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParsePath )( 
            IADsPathnameProvider __RPC_FAR * This,
            /* [in] */ BSTR bstrPath,
            /* [in] */ DWORD dwType,
            /* [in] */ PPATH_OBJECTINFO pObjectInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConstructPath )( 
            IADsPathnameProvider __RPC_FAR * This,
            /* [in] */ PPATH_OBJECTINFO pObjectInfo,
            /* [in] */ DWORD dwType,
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwEscapedMode,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEscapedElement )( 
            IADsPathnameProvider __RPC_FAR * This,
            /* [in] */ LONG lnReserved,
            /* [in] */ BSTR bstrInStr,
            /* [out] */ BSTR __RPC_FAR *pbstrOutStr);
        
        END_INTERFACE
    } IADsPathnameProviderVtbl;

    interface IADsPathnameProvider
    {
        CONST_VTBL struct IADsPathnameProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPathnameProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPathnameProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPathnameProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPathnameProvider_ParsePath(This,bstrPath,dwType,pObjectInfo)	\
    (This)->lpVtbl -> ParsePath(This,bstrPath,dwType,pObjectInfo)

#define IADsPathnameProvider_ConstructPath(This,pObjectInfo,dwType,dwFlag,dwEscapedMode,pbstrPath)	\
    (This)->lpVtbl -> ConstructPath(This,pObjectInfo,dwType,dwFlag,dwEscapedMode,pbstrPath)

#define IADsPathnameProvider_GetEscapedElement(This,lnReserved,bstrInStr,pbstrOutStr)	\
    (This)->lpVtbl -> GetEscapedElement(This,lnReserved,bstrInStr,pbstrOutStr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsPathnameProvider_ParsePath_Proxy( 
    IADsPathnameProvider __RPC_FAR * This,
    /* [in] */ BSTR bstrPath,
    /* [in] */ DWORD dwType,
    /* [in] */ PPATH_OBJECTINFO pObjectInfo);


void __RPC_STUB IADsPathnameProvider_ParsePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsPathnameProvider_ConstructPath_Proxy( 
    IADsPathnameProvider __RPC_FAR * This,
    /* [in] */ PPATH_OBJECTINFO pObjectInfo,
    /* [in] */ DWORD dwType,
    /* [in] */ DWORD dwFlag,
    /* [in] */ DWORD dwEscapedMode,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IADsPathnameProvider_ConstructPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsPathnameProvider_GetEscapedElement_Proxy( 
    IADsPathnameProvider __RPC_FAR * This,
    /* [in] */ LONG lnReserved,
    /* [in] */ BSTR bstrInStr,
    /* [out] */ BSTR __RPC_FAR *pbstrOutStr);


void __RPC_STUB IADsPathnameProvider_GetEscapedElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPathnameProvider_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_PathnameProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("b4f5e650-8bd0-11d2-92a9-00c04f79f834")
PathnameProvider;
#endif
#endif /* __ActiveDsP_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\icmpriv.h ===
/****************************Module*Header******************************\
* Module Name: ICMPRIV.H
*
* Module Descripton: Internal data structures and constants for ICM
*
* Warnings:
*
* Issues:
*
* Created:  8 January 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#ifndef _ICMPRIV_H_
#define _ICMPRIV_H_

#include "icm.h"          // include external stuff first

#ifdef __cplusplus
extern "C" {
#endif

//
// External (but OS internal) functional declarations
//

BOOL    InternalGetPS2ColorSpaceArray (PBYTE, DWORD, DWORD, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetPS2ColorRenderingIntent(PBYTE, DWORD, PBYTE, PDWORD);
BOOL    InternalGetPS2ColorRenderingDictionary(PBYTE, DWORD, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetPS2PreviewCRD(PBYTE, PBYTE, DWORD, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetPS2CSAFromLCS(LPLOGCOLORSPACE, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetDeviceConfig(LPCTSTR,DWORD,DWORD,PVOID,PDWORD);
BOOL    InternalSetDeviceConfig(LPCTSTR,DWORD,DWORD,PVOID,DWORD);

//
// Function ID for InternalGet/SetDeviceConfig
//

#define MSCMS_PROFILE_ENUM_MODE     1

#if !defined(_GDI32_)  // not include from here if gdi32.

//
// Useful macros
//

#define ABS(x)                      ((x) > 0 ? (x) : -(x))
#define DWORD_ALIGN(x)              (((x) + 3) & ~3)

#ifdef LITTLE_ENDIAN
#define FIX_ENDIAN(x)               (((x) & 0xff000000) >> 24 | \
                                     ((x) & 0xff0000)   >> 8  | \
                                     ((x) & 0xff00)     << 8  | \
                                     ((x) & 0xff)       << 24 )

#define FIX_ENDIAN16(x)             (((x) & 0xff00) >> 8 | ((x) & 0xff) << 8)
#else
#define FIX_ENDIAN(x)               (x)
#define FIX_ENDIAN16(x)             (x)
#endif

#if !defined(FROM_PS) // not include from here if postscript driver.

//
// MSCMS Internal definition
//

typedef struct tagTAGDATA {
    TAGTYPE tagType;
    DWORD   dwOffset;
    DWORD   cbSize;
} TAGDATA;
typedef TAGDATA *PTAGDATA;

//
// ICM supports the following  objects:
// 1. Profile object: This is created when an application requsts a handle
//      to a profile.
// 2. Color transform object: This is created when an application creates
//      a color transform.
// 3. CMM object: This is created when ICM loads a CMM into memory to
//      perform color matching.
//

typedef enum {
    OBJ_PROFILE             = 'PRFL',
    OBJ_TRANSFORM           = 'XFRM',
    OBJ_CMM                 = ' CMM',
} OBJECTTYPE;

typedef struct tagOBJHEAD {
    OBJECTTYPE  objType;
    DWORD       dwUseCount;
} OBJHEAD;
typedef OBJHEAD *POBJHEAD;

//
// Profile object:
// Memory for profile objects is allocated from ICM's per process heap.
// These objects use handles from ICM's per process handle table.
//

typedef struct tagPROFOBJ {
    OBJHEAD   objHdr;           // common object header info
    DWORD     dwType;           // type (from profile structure)
    PVOID     pProfileData;     // data (from profile structure)
    DWORD     cbDataSize;       // size of data (from profile structure)
    DWORD     dwFlags;          // miscellaneous flags
    HANDLE    hFile;            // handle to open profile
    HANDLE    hMap;             // handle to profile mapping
    DWORD     dwMapSize;        // size of the file mapping object
    PBYTE     pView;            // pointer to mapped view of profile
} PROFOBJ;
typedef PROFOBJ *PPROFOBJ;

//
// Flags for ((PPROFOBJ)0)->dwFlags
//

#define MEMORY_MAPPED       1   // memory mapped profile
#define PROFILE_TEMP        2   // temporary profile has been created
#define READWRITE_ACCESS    4   // if this bit is set, app has read & write
                                // access to profile, else it has only read
                                // read access.

//
// Transform returned by CMM
//

typedef HANDLE  HCMTRANSFORM;

//
// For internal use, compiler doesn't accept PBYTE* below
//

typedef PBYTE*  PPBYTE;

//
// CMM function calltable
//

typedef struct tagCMMFNS {

    //
    // Required functions
    //

    DWORD          (WINAPI *pCMGetInfo)(DWORD);
    HCMTRANSFORM   (WINAPI *pCMCreateTransform)(LPLOGCOLORSPACE, PVOID, PVOID);
    HCMTRANSFORM   (WINAPI *pCMCreateTransformExt)(LPLOGCOLORSPACE, PVOID, PVOID, DWORD);
    BOOL           (WINAPI *pCMDeleteTransform)(HCMTRANSFORM);
    BOOL           (WINAPI *pCMTranslateRGBs)(HCMTRANSFORM, PVOID, BMFORMAT,
                       DWORD, DWORD, DWORD, PVOID, BMFORMAT, DWORD);
    BOOL           (WINAPI *pCMTranslateRGBsExt)(HCMTRANSFORM, PVOID, BMFORMAT,
                       DWORD, DWORD, DWORD, PVOID, BMFORMAT, DWORD, PBMCALLBACKFN, LPARAM);
    BOOL           (WINAPI *pCMCheckRGBs)(HCMTRANSFORM, PVOID, BMFORMAT,
                       DWORD, DWORD, DWORD, PBYTE, PBMCALLBACKFN, LPARAM);
    HCMTRANSFORM   (WINAPI *pCMCreateMultiProfileTransform)(PHPROFILE, DWORD, PDWORD, DWORD, DWORD);
    BOOL           (WINAPI *pCMTranslateColors)(HCMTRANSFORM, PCOLOR, DWORD,
                       COLORTYPE, PCOLOR, COLORTYPE);
    BOOL           (WINAPI *pCMCheckColors)(HCMTRANSFORM, PCOLOR, DWORD,
                       COLORTYPE, PBYTE);
    //
    // Optional functions
    //

    BOOL           (WINAPI *pCMCreateProfile)(LPLOGCOLORSPACE, PPBYTE);
    BOOL           (WINAPI *pCMGetNamedProfileInfo)(HPROFILE, PNAMED_PROFILE_INFO);
    BOOL           (WINAPI *pCMConvertColorNameToIndex)(HPROFILE, LPCOLOR_NAME, LPDWORD, DWORD);
    BOOL           (WINAPI *pCMConvertIndexToColorName)(HPROFILE, LPDWORD, LPCOLOR_NAME, DWORD);
    BOOL           (WINAPI *pCMCreateDeviceLinkProfile)(PHPROFILE, DWORD, PDWORD, DWORD, DWORD, PPBYTE);
    BOOL           (WINAPI *pCMIsProfileValid)(HPROFILE, PBOOL);
    BOOL           (WINAPI *pCMGetPS2ColorSpaceArray)(HPROFILE, DWORD, DWORD, PBYTE, PDWORD, PBOOL);
    BOOL           (WINAPI *pCMGetPS2ColorRenderingIntent)(HPROFILE, DWORD, PBYTE, PDWORD);
    BOOL           (WINAPI *pCMGetPS2ColorRenderingDictionary)(HPROFILE, DWORD,
                       PBYTE, PDWORD, PBOOL);
} CMMFNS;
typedef CMMFNS *PCMMFNS;

//
// CMM object:
// Memory for CMM objects is allocated from ICM's per process heap.
// They are maintained in a linked list.
//

typedef struct tagCMMOBJ {
    OBJHEAD           objHdr;
    DWORD             dwFlags;  // miscellaneous flags
    DWORD             dwCMMID;  // ICC identifier
    DWORD             dwTaskID; // process ID of current task
    HINSTANCE         hCMM;     // handle to instance of CMM dll
    CMMFNS            fns;      // function calltable
    struct tagCMMOBJ* pNext;    // pointer to next object
} CMMOBJ;
typedef CMMOBJ *PCMMOBJ;

//
//  dwFlags for CMMOBJ
//

#define CMM_DONT_USE_PS2_FNS        0x00001

//
// Color transform object
//

typedef struct tagTRANSFORMOBJ {
    OBJHEAD      objHdr;
    PCMMOBJ      pCMMObj;       // pointer to CMM object
    HCMTRANSFORM hcmxform;      // transform returned by CMM
} TRANSFORMOBJ;
typedef TRANSFORMOBJ *PTRANSFORMOBJ;

//
// Parameter to InternalHandleColorProfile
//

typedef enum {
    ADDPROFILES,
    REMOVEPROFILES,
    ENUMPROFILES,
} PROFILEOP;

//
// CMM returned transform should be larger than this value
//

#define TRANSFORM_ERROR    (HTRANSFORM)255

#define PROFILE_SIGNATURE          'psca'

#define HEADER(pProfObj)           ((PPROFILEHEADER)pProfObj->pView)
#define VIEW(pProfObj)             (pProfObj->pView)
#define PROFILE_SIZE(pProfObj)     (FIX_ENDIAN(HEADER(pProfObj)->phSize))
#define TAG_COUNT(pProfObj)        (*((DWORD *)(VIEW(pProfObj) + \
                                   sizeof(PROFILEHEADER))))
#define TAG_DATA(pProfObj)         ((PTAGDATA)(VIEW(pProfObj) + \
                                   sizeof(PROFILEHEADER) + sizeof(DWORD)))

#define MAGIC                      'ICM '
#define PTRTOHDL(x)                ((HANDLE)((ULONG_PTR)(x) ^ MAGIC))
#define HDLTOPTR(x)                ((ULONG_PTR)(x) ^ MAGIC)

PVOID   MemAlloc(DWORD);
PVOID   MemReAlloc(PVOID, DWORD);
VOID    MemFree(PVOID);
VOID    MyCopyMemory(PBYTE, PBYTE, DWORD);
PVOID   AllocateHeapObject(OBJECTTYPE);
VOID    FreeHeapObject(HANDLE);
BOOL    ValidHandle(HANDLE, OBJECTTYPE);
PCMMOBJ GetColorMatchingModule(DWORD);
BOOL    ValidColorMatchingModule(DWORD,PTSTR);
PCMMOBJ GetPreferredCMM();
VOID    ReleaseColorMatchingModule(PCMMOBJ);
BOOL    ValidProfile(PPROFOBJ);
BOOL    ConvertToAnsi(PCWSTR, PSTR*, BOOL);
BOOL    ConvertToUnicode(PCSTR, PWSTR*, BOOL);
PTSTR   GetFilenameFromPath(PTSTR);

//
// For use with the new Device Settings tag
//

typedef struct _SETTINGS {
    DWORD         dwSettingType;     // 'rsln', 'mdia' etc.
    DWORD         dwSizePerValue;    // number of bytes per value
    DWORD         nValues;           // number of values
    DWORD         Value[1];          // array of value entries
} SETTINGS, *PSETTINGS;

typedef struct _SETTINGCOMBOS {
    DWORD         dwSize;           // size of this structure, including sub structures
    DWORD         nSettings;        // number of setting structures
    SETTINGS      Settings[1];      // array of setting entries
} SETTINGCOMBOS, *PSETTINGCOMBOS;

typedef struct _PERPLATFORMENTRY {
    DWORD         PlatformID;        // platform signature ('msft', 'appl' etc.)
    DWORD         dwSize;            // size of this structure, including sub structures
    DWORD         nSettingCombos;    // number of setting combo structures
    SETTINGCOMBOS SettingCombos[1];  // array of setting combos entries
} PLATFORMENTRY, *PPLATFORMENTRY;

typedef struct _DEVICESETTINGS {
    DWORD         dwTagID;           // 'devs'
    DWORD         dwReserved;        // must be 0
    DWORD         nPlatforms;        // number of platform structures
    PLATFORMENTRY PlatformEntry[1];  // array of platform entries
} DEVICESETTINGS, *PDEVICESETTINGS;

#endif  // ifndef FROM_PS

#endif  // ifndef _GDI32_

#ifdef __cplusplus
}
#endif

#endif  // ifndef _ICMPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\intlid.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    intlid.h

Abstract:

    This module contains the resource ids for the Regional Options applet.

Revision History:

--*/


//
//  Text String Constants.
//

//
//  Make sure the next two definitions are not redefined.
//     (This file included by main.cpl)
//
#ifndef IDS_NAME
  #define IDS_NAME                     1
#endif
#ifndef IDS_INFO
  #define IDS_INFO                     2
#endif

#define IDS_LOCALE_GET_ERROR           3
#define IDS_INVALID_USE_OF_NUM         4
#define IDS_INVALID_TIME_STYLE         5
#define IDS_INVALID_DATE_STYLE         6
#define IDS_NO_LZERO                   7
#define IDS_LZERO                      8
#define IDS_METRIC                     9
#define IDS_US                         10
#define IDS_LOCALE_SET_ERROR           11
#define IDS_LOCALE_NO_NUMS_IN          12
#define IDS_LOCALE_DECIMAL_SYM         13
#define IDS_LOCALE_NEG_SIGN            15
#define IDS_LOCALE_GROUP_SYM           16
#define IDS_LOCALE_TIME_SEP            17
#define IDS_LOCALE_AM_SYM              18
#define IDS_LOCALE_PM_SYM              19
#define IDS_LOCALE_DATE_SEP            20
#define IDS_LOCALE_CURR_SYM            21
#define IDS_LOCALE_CDECIMAL_SYM        22
#define IDS_LOCALE_CGROUP_SYM          23
#define IDS_LOCALE_STYLE_ERR           24
#define IDS_LOCALE_TIME                25
#define IDS_LOCALE_SDATE               26
#define IDS_LOCALE_LDATE               27
#define IDS_LOCALE_YEAR_ERROR          28

#define IDS_STYLEUH                    55
#define IDS_STYLELH                    56
#define IDS_STYLEUM                    57
#define IDS_STYLELM                    58
#define IDS_STYLELS                    59
#define IDS_STYLELT                    60
#define IDS_STYLELD                    61
#define IDS_STYLELY                    62
#define IDS_TIMECHARS                  63
#define IDS_TCASESWAP                  64
#define IDS_SDATECHARS                 65
#define IDS_SDCASESWAP                 66
#define IDS_LDATECHARS                 67
#define IDS_LDCASESWAP                 68
#define IDS_REBOOT_STRING              69
#define IDS_TITLE_STRING               70
#define IDS_SETUP_STRING               71

#define IDS_ML_PERMANENT               72
#define IDS_ML_CANNOT_MODIFY           73
#define IDS_ML_COPY_FAILED             74
#define IDS_ML_INSTALL_FAILED          75
#define IDS_ML_SETUP_FAILED            76

#define IDS_KBD_NO_DEF_LANG            80
#define IDS_KBD_NO_DEF_LANG2           81
#define IDS_KBD_SETUP_FAILED           82
#define IDS_KBD_LOAD_KBD_FAILED        83
#define IDS_KBD_UNLOAD_KBD_FAILED      84
#define IDS_KBD_NEED_LAYOUT            85
#define IDS_KBD_LOAD_LINE_BAD          86
#define IDS_KBD_NO_MORE_TO_ADD         87
#define IDS_KBD_LAYOUT_FAILED          88
#define IDS_KBD_SWITCH_LOCALE          89
#define IDS_KBD_SWITCH_TO              90
#define IDS_KBD_MOD_CONTROL            91
#define IDS_KBD_MOD_LEFT_ALT           92
#define IDS_KBD_MOD_SHIFT              93
#define IDS_KBD_CONFLICT_HOTKEY        94
#define IDS_KBD_INVALID_HOTKEY         95

#define IDS_SPANISH_NAME               96
#define IDS_DEFAULT                    97

#define IDS_CHANGE_UI_LANG             98
#define IDS_DEFAULT_USER_ERROR         99
#define IDS_CHANGE_UI_LANG_NOT_ADMIN   100

#ifndef IDS_UNKNOWN
  #define IDS_UNKNOWN                  198
#endif



//
//  Dialogs.
//

#define DLG_GENERAL                              102
#define DLG_NUMBER                               103
#define DLG_CURRENCY                             104
#define DLG_TIME                                 105
#define DLG_DATE                                 106
#define DLG_KEYBOARD_LOCALES                     107

#define DLG_REGION_SET_DEFAULT                   108
#define DLG_REGION_ADVANCED                      109

#define DLG_KEYBOARD_LOCALE_ADD                  110
#define DLG_KEYBOARD_LOCALE_EDIT                 111
#define DLG_KEYBOARD_HOTKEY_INPUT_LOCALE         112
#define DLG_KEYBOARD_HOTKEY_INPUT_LOCALE_THAI    113
#define DLG_KEYBOARD_HOTKEY_KEYBOARD_LAYOUT      114
#define DLG_KEYBOARD_HOTKEY_IME                  115



//
//  Icons.
//

#define IDI_ICON                       200
#define IDI_DEFAULT_CHECK              201   // small black circled check



//
//  Bitmaps.
//



//
//  Digit Substitution Strings.
//

#define IDS_DIGIT_SUBST_CONTEXT        900
#define IDS_DIGIT_SUBST_NONE           (IDS_DIGIT_SUBST_CONTEXT + 1)
#define IDS_DIGIT_SUBST_NATIONAL       (IDS_DIGIT_SUBST_CONTEXT + 2)



//
//  Misc. Controls.
//

#define IDC_STATIC                     -1
#define IDC_GROUPBOX1                  1001
#define IDC_GROUPBOX2                  1002
#define IDC_GROUPBOX3                  1003
#define IDC_SAMPLE1                    1004
#define IDC_SAMPLE2                    1005
#define IDC_SAMPLELBL1                 1006
#define IDC_SAMPLELBL2                 1007
#define IDC_SAMPLELBL3                 1008
#define IDC_SAMPLE1A                   1009
#define IDC_SAMPLE2A                   1010
#define IDC_SAMPLELBL1A                1011
#define IDC_SAMPLELBL2A                1012



//
//  General Page Controls.
//

#define IDC_USER_LOCALE                1030
#define IDC_SORTING_TEXT               1031
#define IDC_SORTING                    1032
#define IDC_UI_LANGUAGE_TEXT           1033
#define IDC_UI_LANGUAGE                1034
#define IDC_LANGUAGE_GROUPS            1035
#define IDC_SET_DEFAULT                1036
#define IDC_ADVANCED                   1037



//
//  Set Default Dialog Controls.
//

#define IDC_SYSTEM_LOCALE_TEXT1        1050
#define IDC_SYSTEM_LOCALE_TEXT2        1051
#define IDC_SYSTEM_LOCALE              1052



//
//  Advanced Dialog Controls.
//

#define IDC_CODEPAGES                  1060



//
//  Number and Currency Page Controls.
//

#define IDC_DECIMAL_SYMBOL             1070
#define IDC_CURRENCY_SYMBOL            1071
#define IDC_NUM_DECIMAL_DIGITS         1072
#define IDC_DIGIT_GROUP_SYMBOL         1073
#define IDC_NUM_DIGITS_GROUP           1074
#define IDC_POS_SIGN                   1075
#define IDC_NEG_SIGN                   1076
#define IDC_POS_CURRENCY_SYM           1077
#define IDC_NEG_NUM_FORMAT             1078
#define IDC_SEPARATOR                  1079
#define IDC_DISPLAY_LEAD_0             1080
#define IDC_MEASURE_SYS                1081
#define IDC_NATIVE_DIGITS_TEXT         1082
#define IDC_NATIVE_DIGITS              1083
#define IDC_DIGIT_SUBST_TEXT           1084
#define IDC_DIGIT_SUBST                1085



//
//  Time Page Controls.
//

#define IDC_TIME_STYLE                 1090
#define IDC_AM_SYMBOL                  1091
#define IDC_PM_SYMBOL                  1092



//
//  Date Page Controls.
//

#define IDC_CALENDAR_TYPE_TEXT         1100
#define IDC_CALENDAR_TYPE              1101
#define IDC_TWO_DIGIT_YEAR_LOW         1102
#define IDC_TWO_DIGIT_YEAR_HIGH        1103
#define IDC_TWO_DIGIT_YEAR_ARROW       1104
#define IDC_ADD_HIJRI_DATE             1105
#define IDC_SHORT_DATE_STYLE           1106
#define IDC_LONG_DATE_STYLE            1107
#define IDC_ADD_HIJRI_DATE_TEXT        1108



//
//  Input Locale Property Page Controls.
//

#define IDC_KBDL_INPUT_FRAME           1200
#define IDC_KBDL_LOCALE                1201
#define IDC_KBDL_LAYOUT_TEXT           1202
#define IDC_KBDL_LOCALE_LIST           1203
#define IDC_KBDL_ADD                   1204
#define IDC_KBDL_EDIT                  1205
#define IDC_KBDL_DELETE                1206
#define IDC_KBDL_DISABLED              1207
#define IDC_KBDL_DISABLED_2            1208
#define IDC_KBDL_CAPSLOCK_FRAME        1209
#define IDC_KBDL_CAPSLOCK              1210
#define IDC_KBDL_SHIFTLOCK             1211
#define IDC_KBDL_SET_DEFAULT           1213
#define IDC_KBDL_SHORTCUT_FRAME        1214
#define IDC_KBDL_ALT_SHIFT             1215
#define IDC_KBDL_CTRL_SHIFT            1216
#define IDC_KBDL_NO_SHIFT              1217
#define IDC_KBDL_INDICATOR             1218
#define IDC_KBDLA_LOCALE               1219
#define IDC_KBDLA_LAYOUT               1220
#define IDC_KBDLE_LOCALE_TXT           1221
#define IDC_KBDLE_LOCALE               1222
#define IDC_KBDLE_LAYOUT               1223
#define IDC_KBDL_ONSCRNKBD             1226
#define IDC_KBDL_UP                    1227
#define IDC_KBDL_DOWN                  1228

#define IDC_KBDL_IME_SETTINGS          1230
#define IDC_KBDL_HOTKEY_LIST           1231
#define IDC_KBDL_HOTKEY_SEQUENCE       1232
#define IDC_KBDL_HOTKEY                1233
#define IDC_KBDL_HOTKEY_FRAME          1234
#define IDC_KBDL_CHANGE_HOTKEY         1235
#define IDC_KBDLH_KEY_COMBO            1236
#define IDC_KBDLH_CTRL                 1237
#define IDC_KBDLH_L_ALT                1238
#define IDC_KBDLH_SHIFT                1239
#define IDC_KBDLH_LAYOUT_TEXT          1240
#define IDC_KBDLH_ENABLE               1241
#define IDC_KBDLH_GRAVE                1242
#define IDC_KBDLH_VLINE                1243
#define IDC_KBDLH_PLUS                 1244



//
//  Hotkey Strings.
//

#define IDS_VK_NONE                    2200
#define IDS_VK_SPACE                   2201
#define IDS_VK_PRIOR                   2202
#define IDS_VK_NEXT                    2203
#define IDS_VK_END                     2204
#define IDS_VK_HOME                    2205
#define IDS_VK_F1                      2206
#define IDS_VK_F2                      2207
#define IDS_VK_F3                      2208
#define IDS_VK_F4                      2209
#define IDS_VK_F5                      2210
#define IDS_VK_F6                      2211
#define IDS_VK_F7                      2212
#define IDS_VK_F8                      2213
#define IDS_VK_F9                      2214
#define IDS_VK_F10                     2215
#define IDS_VK_F11                     2216
#define IDS_VK_F12                     2217
#define IDS_VK_OEM_SEMICLN             2218
#define IDS_VK_OEM_EQUAL               2219
#define IDS_VK_OEM_COMMA               2220
#define IDS_VK_OEM_MINUS               2221
#define IDS_VK_OEM_PERIOD              2222
#define IDS_VK_OEM_SLASH               2223
#define IDS_VK_OEM_3                   2224
#define IDS_VK_OEM_LBRACKET            2225
#define IDS_VK_OEM_BSLASH              2226
#define IDS_VK_OEM_RBRACKET            2227
#define IDS_VK_OEM_QUOTE               2228
#define IDS_VK_A                       2229
#define IDS_VK_NONE1                   (IDS_VK_A + 26)
#define IDS_VK_0                       (IDS_VK_A + 27)
//
// the below HOTKEYS are only for CHT IMEs
//
#define IDS_RESEND_RESULTSTR_CHT       2300
#define IDS_PREVIOUS_COMPOS_CHT        2302
#define IDS_UISTYLE_TOGGLE_CHT         2304
#define IDS_IME_NONIME_TOGGLE_CHT      2306
#define IDS_SHAPE_TOGGLE_CHT           2308
#define IDS_SYMBOL_TOGGLE_CHT          2310
//
// the below HOTKEYS are only for CHS IMEs
//
#define IDS_IME_NONIME_TOGGLE_CHS      2312
#define IDS_SHAPE_TOGGLE_CHS           2314
#define IDS_SYMBOL_TOGGLE_CHS          2316
//
//
//
#define IDS_KBD_SET_HOTKEY_ERR         2320



//
//  Ordinal for LocaleDlgProc function - Input Locale Page.
//

#define ORD_LOCALE_DLG_PROC            100
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\isltrack.h ===
#ifndef _ISLTRACK_H_
#define _ISLTRACK_H_

#if defined(ENABLE_TRACK)

//===========================================================================
//
// Interface: IShellLinkTracker
//
//  The IShellLinkTracker interface is used to access the ShellLink's
// CTracker object.  For example, Monikers call this interface to set
// the creation flags in the CTracker.
//
//
// [Member functions]
//
//    Initialize
//          This function is called to set the Creation Flags on
//          a ShellLinkTracker object
//
//          Parameters: [DWORD] dwCreationFlags
//
//    GetTrackFlags
//          This function is used to get the creation flags (known externally
//          as "track flags").
//  
//          Parameters: [DWORD *] pdwTrackFlags
//
//    Resolve
//          This function resolves the shell link, searching for the
//          link if necessary.
//
//          Parameters: [HWND] hwnd
//                          -   The window of the caller (can be GetDesktopWindow()).
//                      [DWORD] fFlags
//                          -   Flags to control the Resolve, from the SLR_ enumeration.
//                      [DWORD] dwRestricted
//                          -   Track Flags to be OR-ed with the ShellLink object's
//                              internal Track Flags (a.k.a. Creation Flags).
//                      [DWORD] dwTickCountDeadline
//                          -   The maximum amount of time, in milliseconds, for
//                              which a search should execute (if a search is necessary).
//                      
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellLinkTracker

DECLARE_INTERFACE_(IShellLinkTracker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IShellLinkTracker methods ***
    STDMETHOD(Initialize)(THIS_
                          DWORD dwTrackFlags) PURE;
    STDMETHOD(GetTrackFlags)(THIS_
                             DWORD * pdwTrackFlags) PURE;
    STDMETHOD(Resolve)(THIS_
                       HWND        hwnd,
                       DWORD       fFlags,
                       DWORD       dwRestriction,
                       DWORD       dwTickCountDeadline,
                       DWORD       dwReserved ) PURE;


};


typedef IShellLinkTracker * LPSHELLLINKTRACKER;

DEFINE_GUID(IID_IShellLinkTracker, 0x5E35D200L, 0xF3BB, 0x11CE, 0x9B, 0xDB, 0x00, 0xAA, 0x00, 0x4C, 0xD0, 0x1A);

#endif  // _CAIRO_
#endif  // _ISLTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\intlshar.h ===
/**********************************************************************/
/*      INTLSHAR.H - SHARED HEADER FOR INTERNAT.EXE                   */
/*                                                                    */
/*      Copyright (c) 1997-1998  Microsoft Corporation                */
/**********************************************************************/

#ifndef _INTLSHAR_
#define _INTLSHAR_

/*
 * Ordinal exports in indicdll.dll
 */
#define ORD_REGISTERHOOK          1
#define ORD_STARTSHELL            2
#define ORD_STOPSHELL             3
#define ORD_GETLASTACTIVE         4
#define ORD_GETLASTFOCUS          5
#define ORD_SETNOTIFYWND          6
#define ORD_GETLAYOUT             7
#define ORD_GETIMESTAT            8
#define ORD_GETIMEMENU            9
#define ORD_BUILDIMEMENU          10
#define ORD_GETIMEMENUITEMID      11
#define ORD_GETIMEMENUITEMDATA    12
#define ORD_DESTROYIMEMENU        13
#define ORD_SETIMEMENUITEMDATA    14
#define ORD_GETCONSOLEIMEWND      15
#define ORD_GETDEFAULTIMEMENUITEM 16

#if !defined(NEED_ORDINAL_ONLY)

struct NotifyWindows {
    DWORD cbSize;
    HWND hwndNotify;
    HWND hwndTaskBar;
};

typedef int        (CALLBACK* REGHOOKPROC)(LPVOID, LPARAM);
typedef int        (CALLBACK* FPGETIMESTAT)(void);
typedef BOOL       (CALLBACK* FPGETIMEMENU)(HWND, BOOL);
typedef HKL        (CALLBACK* FPGETLAYOUT)(void);
typedef BOOL       (CALLBACK* FPBUILDIMEMENU)(HMENU, BOOL);
typedef UINT       (CALLBACK* FPGETIMEMENUITEMID)(int);
typedef int        (CALLBACK* FPDESTROYIMEMENU)(void);
typedef void       (CALLBACK* FPSETNOTIFYWND)(const struct NotifyWindows*);
typedef HWND       (CALLBACK* FPGETLASTACTIVE)(void);
typedef HWND       (CALLBACK* FPGETLASTFOCUS)(void);
typedef void       (CALLBACK* FPSETIMEMENUITEMDATA)(DWORD);
typedef BOOL       (CALLBACK* FPGETIMEMENUITEMDATA)(PUINT, PDWORD);
typedef HWND       (CALLBACK* FPGETCONSOLEIMEWND)(void);
typedef int        (CALLBACK* FPGETDEFAULTIMEMENUITEM)(void);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\ixbconn.h ===
/*
 *
 * ixbconn.h
 *
 * C++ Interface for host-Xbox connections
 *
 */

#ifndef _IXBCONN
#define _IXBCONN

#include <objbase.h>

#define XBCONN_VERSION 4

#ifdef __cplusplus
extern "C++" {
#endif

#undef INTERFACE
#define INTERFACE IXboxConnection

DECLARE_INTERFACE_(IXboxConnection, IUnknown)
{
    // IUnknown (we don't support QI)
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IXboxConnection
    STDMETHOD(HrSetConnectionTimeout) (THIS_ DWORD dwConnectTimeout,
        DWORD dwConversationTimeout) PURE;
    STDMETHOD(HrUseSharedConnection) (THIS_ BOOL fShare) PURE;
    STDMETHOD(HrUseSecureConnection) (THIS_ LPCSTR szPasswd) PURE;
    STDMETHOD(HrSendCommand) (THIS_ LPCSTR szCommand, LPSTR szResponse,
        LPDWORD lpdwResponseSize) PURE;
    STDMETHOD(HrResolveXboxName) (THIS_ LPDWORD lpdwAddress) PURE;
    STDMETHOD(HrGetNameOfXbox) (THIS_ LPSTR szName, LPDWORD lpdwSize,
        BOOL fResolvable) PURE;
    STDMETHOD(HrSendFile) (THIS_ LPCSTR szLocalName, LPCSTR szRemoteName) PURE;
    STDMETHOD(HrReceiveFile) (THIS_ LPCSTR szLocalName, LPCSTR szRemoteName) PURE;
    STDMETHOD(HrGetFileAttributes) (THIS_ LPCSTR szFileName, PDM_FILE_ATTRIBUTES pfa) PURE;
    STDMETHOD(HrSetFileAttributes) (THIS_ LPCSTR szFileName, PDM_FILE_ATTRIBUTES pfa) PURE;
    STDMETHOD(HrMkdir) (THIS_ LPCSTR szDirectoryName) PURE;
    STDMETHOD(HrRenameFile) (THIS_ LPCSTR szOldName, LPCSTR szNewName) PURE;
    STDMETHOD(HrDeleteFile) (THIS_ LPCSTR szFileName, BOOL fIsDirectory) PURE;
    STDMETHOD(HrOpenDir) (THIS_ PDM_WALK_DIR *ppwd, LPCSTR szDir, LPDWORD pdw) PURE;
    STDMETHOD(HrWalkDir) (THIS_ PDM_WALK_DIR *ppwd, LPCSTR szDir, PDM_FILE_ATTRIBUTES pfa) PURE;
    STDMETHOD(HrCloseDir) (THIS_ PDM_WALK_DIR pwd) PURE;
    STDMETHOD(HrGetDriveList) (THIS_ LPSTR rgchDrives, LPDWORD pcDrives) PURE;
    STDMETHOD(HrGetDiskFreeSpace) (THIS_ LPSTR szDrive,
        PULARGE_INTEGER pnFreeBytesAvailableToCaller,
        PULARGE_INTEGER pnTotalNumberOfBytes,
        PULARGE_INTEGER pnTotalNumberOfFreeBytes) PURE;
    STDMETHOD(HrReboot)(THIS_ DWORD dwFlags, LPCSTR pszXbeName) PURE;
    STDMETHOD(HrGetXbeInfo)(THIS_ LPCSTR szName, PDM_XBE pxbe) PURE;
    STDMETHOD(HrGetSystemTime)(THIS_ LPSYSTEMTIME lpSysTime) PURE;
    STDMETHOD(HrGetAltAddress)(THIS_ LPDWORD lpdw) PURE;
    STDMETHOD(HrScreenShot)(THIS_ LPCSTR filename) PURE;
    STDMETHOD(HrEnableSecurity)(THIS_ BOOL fEnable) PURE;
    STDMETHOD(HrIsSecurityEnabled)(THIS_ LPBOOL pfEnabled) PURE;
    STDMETHOD(HrSetAdminPassword)(THIS_ LPCSTR szPasswd) PURE;
    STDMETHOD(HrSetUserAccess)(THIS_ LPCSTR szUserName, DWORD dwAccess) PURE;
    STDMETHOD(HrGetUserAccess)(THIS_ LPCSTR szUserName, LPDWORD lpdwAccess) PURE;
    STDMETHOD(HrAddUser)(THIS_ LPCSTR szUserName, DWORD dwAccess) PURE;
    STDMETHOD(HrRemoveUser)(THIS_ LPCSTR szUserName) PURE;
    STDMETHOD(HrOpenUserList)(THIS_ PDM_WALK_USERS *, LPDWORD) PURE;
    STDMETHOD(HrWalkUserList)(THIS_ PDM_WALK_USERS *, PDM_USER) PURE;
    STDMETHOD(HrCloseUserList)(THIS_ PDM_WALK_USERS) PURE;
};

#ifdef __cplusplus
}
extern "C" {
#endif

DMHRAPI DmGetXboxConnection(LPCSTR szXboxName, DWORD dwVersion,
    IXboxConnection **ppvObj);

#ifdef __cplusplus
}
#endif

#endif _IXBOXCONN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\isnkrnl.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    isnkrnl.h

Abstract:

    This header file contains interface definitions for NT clients
    of the ISN IPX/SPX/Netbios stack.

Author:

    Adam Barr (adamba) 10 November 1993

Revision History:

--*/



#include <packon.h>

//
// Defines a local target. The NicId is assigned by IPX
// for each adapter or WAN line it is bound to. The MacAddress
// is generally the address of the remote machine or the
// router that is used to get to the remote machine.
//
//

//
// [SanjayAn] Changed LocalTarget to include a NicHandle
//

#ifdef	_PNP_POWER

typedef	struct _NIC_HANDLE {
	USHORT	NicId;

#ifdef  _PNP_LATER
	ULONG	Version;
	CSHORT	Signature;
#endif  _PNP_LATER

} NIC_HANDLE, *PNIC_HANDLE;


typedef struct _IPX_LOCAL_TARGET {
    union {
        USHORT      NicId;
    	NIC_HANDLE	NicHandle;
    };
    UCHAR MacAddress[6];
} IPX_LOCAL_TARGET, *PIPX_LOCAL_TARGET;

#else

typedef USHORT  NIC_HANDLE;
typedef PUSHORT PNIC_HANDLE;

typedef struct _IPX_LOCAL_TARGET {
    USHORT NicId;
    UCHAR MacAddress[6];
} IPX_LOCAL_TARGET, *PIPX_LOCAL_TARGET;

#endif	_PNP_POWER

//
// Definition of the options on a TDI datagram. These
// can be passed in as the Options field of a send
// datagram. It is indicated as the Options on a receive
// datagram, and will be copied into the Options field
// of a posted receive datagram if there is room.
//
// The complete structure does not need to be passed.
// Only the packet type can be passed, or nothing.
//

typedef struct _IPX_DATAGRAM_OPTIONS {
    UCHAR PacketType;
    UCHAR Reserved;
    IPX_LOCAL_TARGET LocalTarget;
} IPX_DATAGRAM_OPTIONS, *PIPX_DATAGRAM_OPTIONS;


//
// The extended address that some addresses want. If
// the proper ioctl is set (MIPX_SENDADDROPT) then
// this structure is passed as the remote address on
// send datagrams...
//

typedef struct _IPX_ADDRESS_EXTENDED {
    TA_IPX_ADDRESS IpxAddress;
    UCHAR PacketType;
} IPX_ADDRESS_EXTENDED, *PIPX_ADDRESS_EXTENDED;

//
// ...and this structure is passed on receive indications.
// The values for Flags are defined right after it.
// By using the MIPX_SETRCVFLAGS ioctl you can also
// enable this format for receive addresses without
// changing what is passed on sends.
//

typedef struct _IPX_ADDRESS_EXTENDED_FLAGS {
    TA_IPX_ADDRESS IpxAddress;
    UCHAR PacketType;
    UCHAR Flags;
} IPX_ADDRESS_EXTENDED_FLAGS, *PIPX_ADDRESS_EXTENDED_FLAGS;

//
// Just appends Nic to the above structure.
//
typedef struct _IPX_ADDRESS_EXTENDED_FLAGS2 {
    TA_IPX_ADDRESS IpxAddress;
    UCHAR PacketType;
    UCHAR Flags;
    ULONG Nic;
} IPX_ADDRESS_EXTENDED_FLAGS2, *PIPX_ADDRESS_EXTENDED_FLAGS2;

#define IPX_EXTENDED_FLAG_BROADCAST   0x01   // the frame was sent as a broadcast
#define IPX_EXTENDED_FLAG_LOCAL       0x02   // the frame was sent from this machine



//
// The various states of the NICs (LAN/WAN)
//
#define NIC_CREATED         1
#define NIC_DELETED         2
#define NIC_CONNECTED       3
#define NIC_DISCONNECTED    4
#define NIC_LINE_DOWN       5
#define NIC_LINE_UP         6
#define NIC_CONFIGURED      7

//
// The mother of all hacks - tell the forwarder if it should shrink or
// expand all the NICIds...
//
#define NIC_OPCODE_DECREMENT_NICIDS 0x10
#define NIC_OPCODE_INCREMENT_NICIDS 0x20

//
// BUGBUG - Move the isnipx.h definitions over here
//
// Frame types.  For now these mirror those in isnipx.h.
//
#define MISN_FRAME_TYPE_ETHERNET_II  0
#define MISN_FRAME_TYPE_802_3        1
#define MISN_FRAME_TYPE_802_2        2
#define MISN_FRAME_TYPE_SNAP         3
#define MISN_FRAME_TYPE_ARCNET       4    // we ignore this
#define MISN_FRAME_TYPE_MAX          4    // of the four standard ones

#define ISN_FRAME_TYPE_AUTO         0xff

#include <packoff.h>

//***NIC  Info ***


//
// For now, we assume that there will not be more than 256 bindings.
// This is a big enough number for most cases that we will encounter now
// or the foreseeable future.  We allocate an array of ULONGS of the above
// dimension. This array stores in its first n elements pointers to the
// bindings created for the various LAN and WAN adapters.
//
#define IPX_MAXIMUM_BINDINGS               256


//
// This is the interface that the Router process in address space uses
// to open an address end point.  Only one point can currently be opened.
// The ea buffer should have the end point information in exactly the same
// format as is used for TdiTransportAddress endpoint.
//
#define ROUTER_INTERFACE  "RouterInterface"
#define ROUTER_INTERFACE_LENGTH  (sizeof("RouterInterface") - 1)

//
// Max. no. of ports that the Router can open
//
#define IPX_RT_MAX_ADDRESSES         16


// Structure for MIPX_CONFIG Ioctl parameters
typedef struct _ISN_ACTION_GET_DETAILS {
    USHORT NicId;          // passed by caller
    BOOLEAN BindingSet;    // returns TRUE if in set
    UCHAR Type;            // 1 = lan, 2 = up wan, 3 = down wan
    ULONG FrameType;       // returns 0 through 3
    ULONG NetworkNumber;   // returns virtual net if NicId is 0
    UCHAR Node[6];         // adapter's MAC address.
    WCHAR AdapterName[64]; // terminated with Unicode NULL
} ISN_ACTION_GET_DETAILS, *PISN_ACTION_GET_DETAILS;


//
// IPX_NIC_INFO.  One or more such structures can be retrieved by a user
//                app through the MIPX_GETNEWNICS ioctl.
//
typedef struct _IPX_NIC_INFO {

    ULONG   InterfaceIndex; // relevant only for demand dial WAN interfaces
    UCHAR   RemoteNodeAddress[6];        //remote nic address (only for WAN)
    ULONG   LinkSpeed;            //speed of link
    ULONG   PacketType;           //packet type 802.3 or whatever
    ULONG   MaxPacketSize;        //Max. pkt size allowed on the link
    ULONG   NdisMediumType;       //Medium type
    ULONG   NdisMediumSubtype;    //
    BOOLEAN Status;
    ULONG ConnectionId; 	 // used to match TimeSinceLastActivity IOCtls
    ULONG IpxwanConfigRequired;	 // 1 - IPXWAN Required
    ISN_ACTION_GET_DETAILS Details;
    } IPX_NIC_INFO, *PIPX_NIC_INFO;

//
// structure to be passed in the input buffer for the MIPX_GETNEWNICS IOCTL
//
typedef struct _IPX_NICS {
       ULONG NoOfNics;
       ULONG TotalNoOfNics;
       ULONG fAllNicsDesired;   //indicates that the client wants
                                  //ipx to start afresh
       UCHAR Data[1];              //memory holding an array of IPX_NIC_INFO
                                   //structures starts here
       } IPX_NICS, *PIPX_NICS;

//
// Enhanced OPTIONS structure for use with the MIPX_GETNEWNICS ioctl
//
typedef struct _IPX_DATAGRAM_OPTIONS2 {
    IPX_DATAGRAM_OPTIONS DgrmOptions;
    TDI_ADDRESS_IPX  RemoteAddress;
    ULONG            LengthOfExtraOpInfo;  //set it to the size of the extra
                                           //option info.
    char             Data[1];          //for future extensibility
} IPX_DATAGRAM_OPTIONS2, *PIPX_DATAGRAM_OPTIONS2;

//
// Invalid NicId passed down only once so IPX can map the ConnectionId
// to a NicId, which is used later.
//
#define INVALID_NICID   0xffffffff

//
// Structure to be passed with the MIPX_QUERY_WAN_INACTIVITY IOCTL
//
typedef struct _IPX_QUERY_WAN_INACTIVITY {
    ULONG   ConnectionId;
    USHORT  NicId;                  // if equals INVALID_NICID, AdapterIndex is filled in
                                    // adapter index; should change to NicHandle [ZZ]
    ULONG   WanInactivityCounter;   // filled in on return
} IPX_QUERY_WAN_INACTIVITY, *PIPX_QUERY_WAN_INACTIVITY;

//
// Structure to be passed with the MIPX_IPXWAN_CONFIG_DONE IOCTL
//
typedef struct _IPXWAN_CONFIG_DONE {
    USHORT  NicId;           // adapter index; should change to NicHandle [ZZ]
    ULONG   Network;
    UCHAR   LocalNode[6];
    UCHAR   RemoteNode[6];
} IPXWAN_CONFIG_DONE, *PIPXWAN_CONFIG_DONE;

//
// Definitions for TDI_ACTION calls supported by ISN.
// In general the structure defined is passed in the
// OutputBuffer (which becomes the MDL chain when
// the transport receives it) and is used for input
// and output as specified.
//

//
// This is the TransportId to use in the action header
// (it is the string "MISN").
//

#define ISN_ACTION_TRANSPORT_ID   (('N' << 24) | ('S' << 16) | ('I' << 8) | ('M'))


//
// Get local target is used to force a re-RIP and also
// obtain the local target information if desired. The
// IpxAddress is passed on input and the LocalTarget
// is returned on output. The structure defined here
// goes in the Data section of an NWLINK_ACTION
// structure with the Option set to MIPX_LOCALTARGET.
//

typedef struct _ISN_ACTION_GET_LOCAL_TARGET {
    TDI_ADDRESS_IPX IpxAddress;
    IPX_LOCAL_TARGET LocalTarget;
} ISN_ACTION_GET_LOCAL_TARGET, *PISN_ACTION_GET_LOCAL_TARGET;


//
// Get network information is used to return information
// about the path to a network. The information may not
// be accurate since it only reflects what IPX knows
// about the first hop to the remote. Network is an
// input and LinkSpeed (in bytes per second) and
// MaximumPacketSize (not including the IPX header)
// are returned. The structure defined here goes
// in the Data section of an NWLINK_ACTION structure
// with the Options set to MIPX_NETWORKINFO.
//

typedef struct _ISN_ACTION_GET_NETWORK_INFO {
    ULONG Network;
    ULONG LinkSpeed;
    ULONG MaximumPacketSize;
} ISN_ACTION_GET_NETWORK_INFO, *PISN_ACTION_GET_NETWORK_INFO;



//
// This is the structure that the streams IPX transport used
// for its action requests. Because of the way in which nwlink
// was implemented, when passing this structure in a TDI_ACTION
// it should be specified as the InputBuffer, not the output
// buffer.
//
// In the action header, the TransportId is "MIPX" and the
// ActionCode is 0. DatagramOption is TRUE for IPX ioctls
// and FALSE for SPX. The BufferLength includes the length
// of everything after it, which is sizeof(ULONG) for Option
// plus whatever Data is present. Option is one of the
// ioctl codes defined after the structure; in most cases
// Data is not needed.
//

typedef struct _NWLINK_ACTION {
    TDI_ACTION_HEADER Header;
    UCHAR OptionType;
    ULONG BufferLength;
    ULONG Option;
    CHAR Data[1];
} NWLINK_ACTION, *PNWLINK_ACTION;

//
// Defines the values for OptionType (note that for
// NWLINK this is a BOOLEAN DatagramOption, so we
// define these to match, adding the control channel
// one for ISN only).
//

#define NWLINK_OPTION_CONNECTION    0   // action is on a connection
#define NWLINK_OPTION_ADDRESS       1   // action is on an address
#define NWLINK_OPTION_CONTROL       2   // action is on the control channel,
                                        // may also be submitted on an
                                        // open connection or address object



//
// The following IOCTLs are taken from nwlink; the only
// ones added for ISN are the ones in the 200 range.
//


/** Ioctls for IPX - (X) = User callable **/

/**
    ioctls will values 100 - 150 were added for the NT port.
**/

#define I_MIPX          (('I' << 24) | ('D' << 16) | ('P' << 8))
#define MIPX_SETNODEADDR   (I_MIPX | 0)   /* Set the node address */
#define MIPX_SETNETNUM     (I_MIPX | 1)   /* Set the network number */
#define MIPX_SETPTYPE      (I_MIPX | 2)   /* (X) Set the packet type */
#define MIPX_SENTTYPE      (I_MIPX | 3)   /* (X) Set the xport type */
#define MIPX_SETPKTSIZE    (I_MIPX | 4)   /* Set the packet size */
#define MIPX_SETSAP        (I_MIPX | 5)   /* Set the sap/type field */
#define MIPX_SENDOPTS      (I_MIPX | 6)   /* (X) Send options on recv */
#define MIPX_NOSENDOPTS    (I_MIPX | 7)   /* (X) Don't send options on recv */
#define MIPX_SENDSRC       (I_MIPX | 8)   /* (X) Send source address up */
#define MIPX_NOSENDSRC     (I_MIPX | 9)   /* (X) Don't Send source address up */
#define MIPX_CONVBCAST     (I_MIPX | 10)  /* Convert TKR bcast to func addr */
#define MIPX_NOCONVBCAST   (I_MIPX | 11)  /* Don't cnvrt TKR bcast to funcaddr */
#define MIPX_SETCARDTYPE   (I_MIPX | 12)  /* Set 802.3 or ETH type */
#define MIPX_STARGROUP     (I_MIPX | 13)  /* This is stargroup */
#define MIPX_SWAPLENGTH    (I_MIPX | 14)  /* Set flag for swapping 802.3 length */
#define MIPX_SENDDEST      (I_MIPX | 15)  /* (X) Send dest. address up */
#define MIPX_NOSENDDEST    (I_MIPX | 16)  /* (X) Don't send dest. address up */
#define MIPX_SENDFDEST     (I_MIPX | 17)  /* (X) Send final dest. address up */
#define MIPX_NOSENDFDEST   (I_MIPX | 18)  /* (X) Don't send final dest. up */

/** Added for NT port **/

#define MIPX_SETVERSION    (I_MIPX | 100) /* Set card version */
#define MIPX_GETSTATUS     (I_MIPX | 101)
#define MIPX_SENDADDROPT   (I_MIPX | 102) /* (X) Send ptype w/addr on recv */
#define MIPX_NOSENDADDROPT (I_MIPX | 103) /* (X) Stop sending ptype on recv */
#define MIPX_CHECKSUM      (I_MIPX | 104) /* Enable/Disable checksum      */
#define MIPX_GETPKTSIZE    (I_MIPX | 105) /* Get max packet size          */
#define MIPX_SENDHEADER    (I_MIPX | 106) /* Send header with data        */
#define MIPX_NOSENDHEADER  (I_MIPX | 107) /* Don't send header with data  */
#define MIPX_SETCURCARD    (I_MIPX | 108) /* Set current card for IOCTLs  */
#define MIPX_SETMACTYPE    (I_MIPX | 109) /* Set the Cards MAC type       */
#define MIPX_DOSROUTE      (I_MIPX | 110) /* Do source routing on this card*/
#define MIPX_NOSROUTE      (I_MIPX | 111) /* Don't source routine the card*/
#define MIPX_SETRIPRETRY   (I_MIPX | 112) /* Set RIP retry count          */
#define MIPX_SETRIPTO      (I_MIPX | 113) /* Set RIP timeout              */
#define MIPX_SETTKRSAP     (I_MIPX | 114) /* Set the token ring SAP       */
#define MIPX_SETUSELLC     (I_MIPX | 115) /* Put LLC hdr on packets       */
#define MIPX_SETUSESNAP    (I_MIPX | 116) /* Put SNAP hdr on packets      */
#define MIPX_8023LEN       (I_MIPX | 117) /* 1=make even, 0=dont make even*/
#define MIPX_SENDPTYPE     (I_MIPX | 118) /* Send ptype in options on recv*/
#define MIPX_NOSENDPTYPE   (I_MIPX | 119) /* Don't send ptype in options  */
#define MIPX_FILTERPTYPE   (I_MIPX | 120) /* Filter on recv ptype         */
#define MIPX_NOFILTERPTYPE (I_MIPX | 121) /* Don't Filter on recv ptype   */
#define MIPX_SETSENDPTYPE  (I_MIPX | 122) /* Set pkt type to send with    */
#define MIPX_GETCARDINFO   (I_MIPX | 123) /* Get info on a card           */
#define MIPX_SENDCARDNUM   (I_MIPX | 124) /* Send card num up in options  */
#define MIPX_NOSENDCARDNUM (I_MIPX | 125) /* Dont send card num in options*/
#define MIPX_SETROUTER     (I_MIPX | 126) /* Set router enabled flag      */
#define MIPX_SETRIPAGE     (I_MIPX | 127) /* Set RIP age timeout          */
#define MIPX_SETRIPUSAGE   (I_MIPX | 128) /* Set RIP usage timeout        */
#define MIPX_SETSROUTEUSAGE (I_MIPX| 129) /* Set the SROUTE usage timeout */
#define MIPX_SETINTNET     (I_MIPX | 130) /* Set internal network number  */
#define MIPX_NOVIRTADDR    (I_MIPX | 131) /* Turn off virtual net num     */
#define MIPX_VIRTADDR      (I_MIPX | 132) /* Turn on  virtual net num     */
#define MIPX_GETNETINFO    (I_MIPX | 135) /* Get info on a network num    */
#define MIPX_SETDELAYTIME  (I_MIPX | 136) /* Set cards delay time         */
#define MIPX_SETROUTEADV   (I_MIPX | 137) /* Route advertise timeout      */
#define MIPX_SETSOCKETS    (I_MIPX | 138) /* Set default sockets          */
#define MIPX_SETLINKSPEED  (I_MIPX | 139) /* Set the link speed for a card*/
#define MIPX_SETWANFLAG    (I_MIPX | 140)
#define MIPX_GETCARDCHANGES (I_MIPX | 141) /* Wait for card changes	*/
#define MIPX_GETMAXADAPTERS (I_MIPX | 142)
#define MIPX_REUSEADDRESS   (I_MIPX | 143)
#define MIPX_RERIPNETNUM    (I_MIPX | 144) /* ReRip a network         */
#define MIPX_GETNETINFO_NR  (I_MIPX | 145) /* Get info on a net num - NO RIP */

#define MIPX_SETNIC         (I_MIPX | 146)
#define MIPX_NOSETNIC       (I_MIPX | 147)

/** For Source Routing Support **/

#define MIPX_SRCLEAR       (I_MIPX | 200) /* Clear the source routing table*/
#define MIPX_SRDEF         (I_MIPX | 201) /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRBCAST       (I_MIPX | 202) /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRMULTI       (I_MIPX | 203) /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRREMOVE      (I_MIPX | 204) /* Remove a node from the table */
#define MIPX_SRLIST        (I_MIPX | 205) /* Get the source routing table */
#define MIPX_SRGETPARMS    (I_MIPX | 206) /* Get source routing parms     */

#define MIPX_SETSHOULDPUT  (I_MIPX | 210) /* Turn on should put call      */
#define MIPX_DELSHOULDPUT  (I_MIPX | 211) /* Turn off should put call     */
#define MIPX_GETSHOULDPUT  (I_MIPX | 212) /* Get ptr to mipx_shouldput    */

/** Added for ISN **/

#define MIPX_RCVBCAST      (I_MIPX | 300) /* (X) Enable broadcast reception */
#define MIPX_NORCVBCAST    (I_MIPX | 301) /* (X) Disable broadcast reception */
#define MIPX_ADAPTERNUM    (I_MIPX | 302) /* Get maximum adapter number */
#define MIPX_NOTIFYCARDINFO (I_MIPX | 303) /* Pend until card info changes */
#define MIPX_LOCALTARGET   (I_MIPX | 304) /* Get local target for address */
#define MIPX_NETWORKINFO   (I_MIPX | 305) /* Return info about remote net */
#define MIPX_ZEROSOCKET    (I_MIPX | 306) /* Use 0 as source socket on sends */
#define MIPX_SETRCVFLAGS   (I_MIPX | 307) /* Turn on flags in receive addr   */
#define MIPX_NORCVFLAGS    (I_MIPX | 308) /* Turn off flags in receive addr  */
#define MIPX_CONFIG        (I_MIPX | 309) /* used by IPXROUTE for config info */
#define MIPX_LINECHANGE    (I_MIPX | 310) /* queued until WAN line goes up/down */
#define MIPX_GETCARDINFO2  (I_MIPX | 311) /* Get info, return real send size for token-ring */
#define MIPX_ADAPTERNUM2   (I_MIPX | 312) /* Max. number including duplicates */


//
// Used by a user mode process to get nic info defined by the IPX_NIC_INFO
// structure.
//
// NOTE NOTE NOTE
//
// This is supposed to be used only by the FWRDR process and nobody else.
// If some other app. uses it, the FWRDR will be affected
//
//
#define MIPX_GETNEWNICINFO  (I_MIPX | 313) /*Get any new NIC info that might
                                            *be there*/

//
// IOCTL to be used if the interface is  ROUTER_INTERFACE
//
#define MIPX_SEND_DATAGRAM     _TDI_CONTROL_CODE((I_MIPX | 314), METHOD_IN_DIRECT) // send dgram
#define MIPX_RCV_DATAGRAM     _TDI_CONTROL_CODE((I_MIPX | 315), METHOD_OUT_DIRECT) // send dgram

#define MIPX_RT_CREATE      (I_MIPX | 316)
#define MIPX_IPXWAN_CONFIG_DONE   (I_MIPX | 317)
#define MIPX_QUERY_WAN_INACTIVITY (I_MIPX | 318)

/** Ioctls for SPX **/

#define I_MSPX          (('S' << 24) | ('P' << 16) | ('P' << 8))
#define MSPX_SETADDR       (I_MSPX | 0)   /* Set the network address      */
#define MSPX_SETPKTSIZE    (I_MSPX | 1)   /* Set the packet size per card */
#define MSPX_SETDATASTREAM (I_MSPX | 2)   /* Set datastream type          */

/** Added for NT port **/

#define MSPX_SETASLISTEN   (I_MSPX | 100) /* Set as a listen socket       */
#define MSPX_GETSTATUS     (I_MSPX | 101) /* Get running status           */
#define MSPX_GETQUEUEPTR   (I_MSPX | 102) /* Get ptr to the streams queue */
#define MSPX_SETDATAACK    (I_MSPX | 103) /* Set DATA ACK option          */
#define MSPX_NODATAACK     (I_MSPX | 104) /* Turn off DATA ACK option     */
#define MSPX_SETMAXPKTSOCK (I_MSPX | 105) /* Set the packet size per socket */
#define MSPX_SETWINDOWCARD (I_MSPX | 106) /* Set window size for card     */
#define MSPX_SETWINDOWSOCK (I_MSPX | 107) /* Set window size for 1 socket */
#define MSPX_SENDHEADER    (I_MSPX | 108) /* Send header with data        */
#define MSPX_NOSENDHEADER  (I_MSPX | 109) /* Don't send header with data  */
#define MSPX_GETPKTSIZE    (I_MSPX | 110) /* Get the packet size per card */
#define MSPX_SETCONNCNT    (I_MSPX | 111) /* Set the conn req count       */
#define MSPX_SETCONNTO     (I_MSPX | 112) /* Set the conn req timeout     */
#define MSPX_SETALIVECNT   (I_MSPX | 113) /* Set the keepalive count      */
#define MSPX_SETALIVETO    (I_MSPX | 114) /* Set the keepalive timeout    */
#define MSPX_SETALWAYSEOM  (I_MSPX | 115) /* Turn on always EOM flag      */
#define MSPX_NOALWAYSEOM   (I_MSPX | 116) /* Turn off always EOM flag     */
#define MSPX_GETSTATS      (I_MSPX | 119) /* Get connection stats         */
#define MSPX_NOACKWAIT     (I_MSPX | 120) /* Disable piggyback wait       */
#define MSPX_ACKWAIT       (I_MSPX | 121) /* Enable pback wait (default)  */

//
// Taken out of isn\inc\bind.h
//
typedef struct _IPXCP_CONFIGURATION {
    USHORT Version;
    USHORT Length;
    UCHAR Network[4];
    UCHAR LocalNode[6];
    UCHAR RemoteNode[6];
    ULONG ConnectionClient;  // 0 - Server, 1 - Client
    ULONG InterfaceIndex;
    ULONG ConnectionId; 	 // used to match TimeSinceLastActivity IOCtls
    ULONG IpxwanConfigRequired;	 // 1 - IPXWAN Required
} IPXCP_CONFIGURATION, *PIPXCP_CONFIGURATION;

#define IPXWAN_SOCKET   (USHORT)0x490



=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\irioctl.h ===
/*++                                          
Copyright (c) 1998  Microsoft Corporation

Module Name:

    irioctl.h

Abstract:

    Contains definitions for private ioctls for the IrDA TDI driver used
    by irmon and the IrDA winsock helper dll.

Author:

    mbert   9-98

--*/

typedef struct
{
    UINT    Flags;
        #define     LF_CONNECTED    0x00000001
        #define     LF_TX           0x00000002
        #define     LF_RX           0x00000004
        #define     LF_INTERRUPTED  0x00000008
        #define     LF_NO_UI        0x80000000
    UINT    ConnectSpeed;
    CHAR    ConnectedDeviceId[4];
} IRLINK_STATUS, *PIRLINK_STATUS;

#define FSCTL_IRDA_BASE     FILE_DEVICE_NETWORK

#define _IRDA_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_IRDA_BASE, function, method, access)

#define IOCTL_IRDA_GET_INFO_ENUM_DEV \
            _IRDA_CTL_CODE(0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_SET_OPTIONS \
            _IRDA_CTL_CODE(1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_GET_SEND_PDU_LEN \
            _IRDA_CTL_CODE(2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_QUERY_IAS \
            _IRDA_CTL_CODE(3, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_SET_IAS \
            _IRDA_CTL_CODE(4, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_DEL_IAS_ATTRIB \
            _IRDA_CTL_CODE(5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_LAZY_DISCOVERY \
            _IRDA_CTL_CODE(6, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_LINK_STATUS \
            _IRDA_CTL_CODE(10, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_SET_LAZY_DISCOVERY_INTERVAL \
            _IRDA_CTL_CODE(11, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_LINK_STATUS_NB \
            _IRDA_CTL_CODE(12, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_FLUSH_DISCOVERY_CACHE \
            _IRDA_CTL_CODE(13, METHOD_BUFFERED, FILE_ANY_ACCESS)                         

#define IOCTL_IRDA_GET_DBG_MSGS \
            _IRDA_CTL_CODE(20, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_GET_DBG_SETTINGS \
            _IRDA_CTL_CODE(21, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_SET_DBG_SETTINGS \
            _IRDA_CTL_CODE(22, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
            
#define OPT_IRLPT_MODE      0x01
#define OPT_9WIRE_MODE      0x02

#define LINK_STATUS_IDLE            0
#define LINK_STATUS_DISCOVERING     1
#define LINK_STATUS_CONNECTED       2
#define LINK_STATUS_INTERRUPTED     3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\jet.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1993 Microsoft Corporation.
*
* Component:
*
* File: jet.h
*
* File Comments:
*
*     Public header file with JET API definition.
*
* Revision History:
*
*    [0]  04-Jan-92  richards	Added this header
*
***********************************************************************/

//
// This __JET500 essentially creates two version of this file in this
// same file. All the jet500 stuff is in __JET500 macro
//
#if __JET500
#include "jet500.h"
//
// End of 500 series jet.h
#else
//
// Original jet.h starts here. i.e jet.h of 200 series db.
//

#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#pragma pack(4)

#if defined(_M_ALPHA)				/* 0:32 Flat Model (Alpha AXP) */

#define _far
#define JET_API   __stdcall
#define JET_NODSAPI __stdcall

#elif	defined(M_MRX000)				/* 0:32 Flat Model (MIPS Rx000) */

#define _far
#define JET_API   __stdcall
#define JET_NODSAPI  __stdcall

#else										/*	0:32 flat model (Intel 32-bit ) */

#define _far
#define JET_API     __stdcall		/* CONSIDER: Switch to __stdcall */
#define JET_NODSAPI __stdcall		/* CONSIDER: Switch to __stdcall */

#endif

typedef long JET_ERR;

typedef unsigned long JET_INSTANCE;	/* Instance Identifier */
typedef ULONG_PTR JET_SESID;		/* Session Identifier */
typedef ULONG_PTR JET_TABLEID;	    /* Table Identifier */
typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef ULONG_PTR JET_DBID; 		/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;		/* Group of Bits */
typedef unsigned long JET_ACM;		/* Access Mask */
typedef unsigned long JET_RNT;		/* Repair Notification Type */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */

typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */

#if defined(_M_ALPHA)				/* 0:32 Flat Model (Intel 80x86) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#elif	defined(M_MRX000)				/* 0:32 Flat Model (MIPS Rx000) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#else										/*	0:32 flat model (Alpha AXP ) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#endif


	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty							 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* JetGetLastErrorInfo structure */

typedef struct
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_ERR 			err;			/* Extended error code (if any) */
	unsigned long	ul1;			/* First general purpose integer */
	unsigned long	ul2;			/* Second general purpose integer */
	unsigned long	ul3;			/* Third general purpose integer */
	} JET_EXTERR;

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

	/* ErrCount Notification Structures */

typedef struct						/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cRecUniqueKeyViolation;
	unsigned long	cRecTypeConversionFail;
	unsigned long	cRecRecordLocked;
	unsigned long	cRecTotal;	/* Total number of units of work */
	} JET_SNERRCNT;


typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC 	snc;					/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char		sz[256];				/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long	cbStruct;
	JET_OBJTYP	objtyp;
	JET_DATESERIAL	dtCreate;
	JET_DATESERIAL	dtUpdate;
	JET_GRBIT	grbit;
	unsigned long	flags;
	unsigned long	cRecord;
	unsigned long	cPage;
	} JET_OBJECTINFO;
	
typedef struct
	{
	unsigned	int dbid;
	char		szDatabaseName[256];
	char		szNewDatabaseName[256];
	} JET_RSTMAP;			/* restore map */

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableInfoRestartable	0x00000008
#define JET_bitTableInfoNoInserts	0x00000010

	/* The following flags occur in the flags field above */

#define JET_bitSaveUIDnPWD		0x20000000	/* this bit is only 		 */
											/* appropriate for rmt links */
#define JET_bitObjectExclusive	0x40000000	/* Open link exclusively */
#define JET_bitObjectSystem		0x80000000


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;
	JET_COLUMNID	columniddtUpdate;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidSid;
	JET_COLUMNID	columnidACM;
	JET_COLUMNID	columnidgrbit; /* grbit from JetSetAccess */
	} JET_OBJECTACMLIST;

#define cObjectAcmCols 3	       /* CONSIDER: Internal */


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP	coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT	grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP	coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT	grbit;
	char		szBaseTableName[256];	/* CONSIDER: Too large? */
	char		szBaseColumnName[256];	/* CONSIDER: Too large? */
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID	tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	} JET_INDEXLIST;

#define cIndexInfoCols 15	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID	tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidReferenceName;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidReferencingTableName;
	JET_COLUMNID	columnidReferencingColumnName;
	JET_COLUMNID	columnidReferencedTableName;
	JET_COLUMNID	columnidReferencedColumnName;
	} JET_RELATIONSHIPLIST;

/* for backward compatibility */
typedef JET_RELATIONSHIPLIST JET_REFERENCELIST;

#define cReferenceInfoCols 8	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	} PERS_OLCSTAT;
	
typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	unsigned long	cpgCompactFreed;
	} JET_OLCSTAT;

typedef struct
	{
	unsigned long	ctableid;
	JET_TABLEID	rgtableid[1];
	} JET_MGBLIST;

/*** Property Manager Structure ***/
typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID 	tableid;
	JET_COLUMNID 	columnidColumnName;
	JET_COLUMNID 	columnidPropertyName;
	JET_COLUMNID	columnidGrbit;
	JET_COLUMNID	columnidPropertyValue;
	JET_COLUMNID	columnidColtyp;
	} JET_PROPERTYLIST;


/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define JET_tableidNil			((JET_TABLEID) 	0xFFFFFFFF)

#define	JET_sesidNil			((JET_SESID) 	0xFFFFFFFF)

	/* Max size of a bookmark */

#define JET_cbBookmarkMost		256

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost			64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost		255

	/* Max size of non-long-value column data */

#define JET_cbColumnMost		255

	/* Max size of a sort/index key */

#define JET_cbKeyMost			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost			10

	/* Max number of columns in a table/query */

#define JET_ccolTableMost		255

	/* Max Length of a property in the property manager */
#define JET_cbPropertyMost 2048

	/* Largest initial substring of a long value used in an expression */

#define JET_cbExprLVMost		0x8000L	/*** 32 K ***/

	/* Max size of returned (from SQLDriverConnect) conn string */

#define JET_cbConnectMost		255

	/* Max number of levels in an MGB */

#define JET_wGroupLevelMax		12

	/* Size restrictions for Pins */
#define JET_cchPINMax			20
#define JET_cchPINMin			4


	/* System parameter codes for JetSetSystemParameter */

#define JET_paramSysDbPath			0	/* Path to the system database */
#define JET_paramTempPath			1	/* Path to the temporary file directory */
#define JET_paramPfnStatus			2	/* Status callback function */
#define JET_paramPfnError			3	/* Error callback function */
#define JET_paramHwndODBC			4	/* Window handle for ODBC use */
#define JET_paramIniPath			5	/* Path to the ini file */
#define JET_paramPageTimeout		6	/* Red ISAM page timeout value */
#define JET_paramODBCQueryTimeout	7	/* ODBC async query timeout value */
#define JET_paramMaxBuffers			8	/* Bytes to use for page buffers */
#define JET_paramMaxSessions		9	/* Maximum number of sessions */
#define JET_paramMaxOpenTables		10	/* Maximum number of open tables */
#define JET_paramMaxVerPages		11	/* Maximum number of modified pages */
#define JET_paramMaxCursors			12	/* Maximum number of open cursors */
#define JET_paramLogFilePath		13	/* Path to the log file directory */
#define JET_paramMaxOpenTableIndexes 14	/* Maximum open table indexes */
#define JET_paramMaxTemporaryTables	15	/* Maximum concurrent JetCreateIndex */
#define JET_paramLogBuffers			16	/* Maximum log buffers */
#define JET_paramLogFileSectors		17	/* Maximum log sectors per log file */
#define JET_paramLogFlushThreshold	18	/* Log buffer flush threshold */
#define JET_paramBfThrshldLowPrcnt	19	/* Low threshold ( % ) for buffers */
#define JET_paramBfThrshldHighPrcnt	20	/* High threshold ( % ) for buffers */
#define JET_paramWaitLogFlush		21	/* msec for waiting log flush */
#define JET_paramLogFlushPeriod		22	/* msec for waiting log flush */
#define JET_paramLogCheckpointPeriod 23	/* msec for waiting log flush */
#define JET_paramLogWaitingUserMax	24	/* Maximum # user waiting log flush */
#define JET_paramODBCLoginTimeout	25	/* ODBC connection attempt timeout value */
#define JET_paramExprObject			26  /* Expression Evaluation callback */
#define JET_paramGetTypeComp			27	/* Expression Evaluation callback */
#define JET_paramHostVersion			28	/* Host Version callback */
#define JET_paramSQLTraceMode			29	/* Enable/disable SQL tracing */
#define JET_paramRecovery				30	/* Switch for log on/off */
#define JET_paramRestorePath			31	/* Path to restoring directory */
#define JET_paramTransactionLevel	32	/* Transaction level of session */
#define JET_paramSessionInfo			33	/* Session info */
#define JET_paramPageFragment			34	/* Largest page extent considered fragment */
#define JET_paramJetInternal			35	/* Whether internal to JET; if set, allows ISAM to do things which are prevented in general */
#define JET_paramMaxOpenDatabases	36	/*	Maximum number of open databases */
#define JET_paramOnLineCompact		37 /*	Options for compact pages on-line */
#define JET_paramFullQJet		38	/* Allow full QJet functionality */
#define JET_paramRmtXactIsolation	39	/* Do not share connections with other sessions */
#define JET_paramBufLRUKCorrInterval 40
#define JET_paramBufBatchIOMax		41
#define JET_paramPageReadAheadMax	42
#define JET_paramAsynchIOMax		43

#define JET_paramAssertAction		44 /*	debug only determines action on assert */

#define JET_paramEventSource		45	/* NT event log */
#define JET_paramEventId			46	/* NT event id */
#define JET_paramEventCategory		47	/* NT event category */


	/* Flags for JetIdle */

#define JET_bitIdleRemoveReadLocks	0x00000001
#define JET_bitIdleFlushBuffers		0x00000002
#define JET_bitIdleCompact				0x00000004

	/* Flags for JetEndSession */

#define JET_bitForceSessionClosed	0x00000001

	/* Flags for JetOpenDatabase */

#define JET_bitDbReadOnly			0x00000001
#define JET_bitDbExclusive			0x00000002 /* multiple opens allowed */
#define JET_bitDbRemoteSilent		0x00000004
#define JET_bitDbSingleExclusive	0x00000008 /* opened exactly once */

	/* Flags for JetCloseDatabase */

#define JET_bitDbForceClose		0x00000001

	/* Flags for JetCreateDatabase */

#define JET_bitDbEncrypt			0x00000001
#define JET_bitDbVersion10			0x00000002
#define JET_bitDbVersion1x			0x00000004
#define JET_bitDbRecoveryOff 		0x00000008 /* disable logging/recovery */
#define JET_bitDbNoLogging	 		0x00000010 /* no logging */
#define JET_bitDbCompleteConnstr	0x00000020

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitOverwriteExisting		0x00000004

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */

	/* Flags for JetCreateLink */

/* Can use JET_bitObjectExclusive to cause linked to database to be opened */
/* exclusively.															   */

	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged			0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement	0x00000010
#define JET_bitColumnUpdatable		0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending	0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnNotLast			0x00000100 /* Installable ISAM option */
#define JET_bitColumnRmtGraphic		0x00000200 /* JetGetColumnInfo */
#define JET_bitColumnMultiValued		0x00000400

	/* Flags for JetMakeKey */

#define JET_bitNewKey				0x00000001
#define JET_bitStrLimit 			0x00000002
#define JET_bitSubStrLimit			0x00000004
#define JET_bitNormalizedKey 		0x00000008
#define JET_bitKeyDataZeroLength	0x00000010

#ifdef DBCS /* johnta: LIKE "ABC" not converted to ="ABC" for Japanese */
#define JET_bitLikeExtra1			0x00000020
#endif /* DBCS */

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive		0x00000001    /* CONSIDER: Internal */
#define JET_bitRangeUpperLimit		0x00000002    /* CONSIDER: Internal */

	/* Constants for JetMove */

#define JET_MoveFirst			(0x80000000)
#define JET_MovePrevious		(-1)
#define JET_MoveNext				(+1)
#define JET_MoveLast				(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE		0x00000001
#define JET_bitMoveCheckTS		0x00000002
#define JET_bitMoveInPage		0x00000004

	/* Flags for JetSeek */

#define JET_bitSeekEQ			0x00000001
#define JET_bitSeekLT			0x00000002
#define JET_bitSeekLE			0x00000004
#define JET_bitSeekGE			0x00000008
#define JET_bitSeekGT		 	0x00000010
#define JET_bitSetIndexRange	0x00000020

	/* Flags for JetFastFind */

#define JET_bitFFindBackwards		0x00000001
#define JET_bitFFindFromCursor		0x00000004

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique		0x00000001
#define JET_bitIndexPrimary		0x00000002
#define JET_bitIndexDisallowNull	0x00000004
#define JET_bitIndexIgnoreNull		0x00000008
#define JET_bitIndexClustered		0x00000010
#define JET_bitIndexIgnoreAnyNull	0x00000020
#define JET_bitIndexReference		0x80000000    /* IndexInfo only */

	/* Flags for index key definition */

#define JET_bitKeyAscending		0x00000000
#define JET_bitKeyDescending		0x00000001


	/* Flags for JetCreateRelationship */

#define JET_bitRelationUnique			0x00000001
#define JET_bitRelationDontEnforce		0x00000002
#define JET_bitRelationInherited		0x00000004
#define JET_bitRelationTestLegal		0x00000008	/* don't create relationship */

#define JET_bitRelationshipMatchMask	0x000000F0
#define JET_bitRelationMatchDefault		0x00000000
#define JET_bitRelationMatchFull		0x00000010

#define JET_bitRelationUpdateActionMask	0x00000F00
#define JET_bitRelationUpdateDisallow	0x00000000
#define JET_bitRelationUpdateCascade	0x00000100
#define JET_bitRelationUpdateSetNull	0x00000200
#define JET_bitRelationUpdateSetDefault	0x00000300

#define JET_bitRelationDeleteActionMask	0x0000F000
#define JET_bitRelationDeleteDisallow	0x00000000
#define JET_bitRelationDeleteCascade	0x00001000
#define JET_bitRelationDeleteSetNull	0x00002000
#define JET_bitRelationDeleteSetDefault	0x00003000

#define JET_bitRelationUserMask			0xFF000000	/* non-enforced values */
#define JET_bitRelationJoinMask			0x03000000
#define JET_bitRelationInner			0x00000000
#define JET_bitRelationLeft				0x01000000
#define JET_bitRelationRight			0x02000000


	/* Flags for JetCreateReference/JetCreateRelationship */
	/* NOTE: use the bitRelationship flags instead! */

#define JET_ReferenceUnique				JET_bitRelationUnique
#define JET_ReferenceDontEnforce		JET_bitRelationDontEnforce
#define JET_ReferenceMatchTypeMask		JET_bitRelationMatchMask
#define JET_ReferenceMatchDefault		JET_bitRelationMatchDefault
#define JET_ReferenceMatchFull			JET_bitRelationMatchFull
#define JET_ReferenceUpdateActionMask	JET_bitRelationUpdateActionMask
#define JET_ReferenceUpdateDisallow		JET_bitRelationUpdateDisallow
#define JET_ReferenceUpdateCascade		JET_bitRelationUpdateCascade
#define JET_ReferenceUpdateSetNull		JET_bitRelationUpdateSetNull
#define JET_ReferenceUpdateSetDefault	JET_bitRelationUpdateSetDefault
#define JET_ReferenceDeleteActionMask	JET_bitRelationDeleteActionMask
#define JET_ReferenceDeleteDisallow		JET_bitRelationDeleteDisallow
#define JET_ReferenceDeleteCascade		JET_bitRelationDeleteCascade
#define JET_ReferenceDeleteSetNull		JET_bitRelationDeleteSetNull
#define JET_ReferenceDeleteSetDefault	JET_bitRelationDeleteSetDefault


	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableAppendOnly		0x00000008
#define JET_bitTableUpdatable		0x00000010
#define JET_bitTableScrollable		0x00000020
#define JET_bitTableFixedSet		0x00000040	/* Fixed working set */
#define JET_bitTableInconsistent	0x00000080
#define JET_bitTableBulk			0x00000100
#define JET_bitTableUsePrimaryIndex	0x00000200	/* Use with FixedSet */
#define JET_bitTableSampleData		0x00000400
#define JET_bitTableQuickBrowse		0x00000800	/* Bias optimizer toward index usage */
#define JET_bitTableDDL				0x00001000	/* similar to JET_bitTableBulk, for DDL */
#define JET_bitTablePassThrough		0x00002000  /* Remote DBs Only */
#define JET_bitTableRowReturning	0x00004000

	/* Flags for JetSetQoSql/JetRetrieveQoSql */
#define JET_bitSqlPassThrough		0x00000001	/* Pass through Query returning records */
#define JET_bitSqlSPTBulkOp			0x00000002  /* SPT query returning no table */
	
	/* Flags for JetOpenVtQbe */

#define JET_bitQBEAddBrackets		0x00000001
#define JET_bitQBERemoveEquals		0x00000002

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed		0x00000001	/* Allow seek */
#define JET_bitTTUnique 		0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable		0x00000004	/* Allow updates */
#define JET_bitTTScrollable		0x00000008	/* Allow backwards scrolling */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV			0x00000001
#define JET_bitSetValidate			0x00000002
#define JET_bitSetOverwriteLV		0x00000004
#define JET_bitSetSizeLV			0x00000008
#define JET_bitSetValidateColumn	0x00000010
#define JET_bitSetZeroLength		0x00000020

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void _far 		*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert			0
#define JET_prepInsertBeforeCurrent	1
#define JET_prepReplace 		2
#define JET_prepCancel			3
#define JET_prepReplaceNoLock		4
#define JET_prepInsertCopy			5

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy			0x00000001
#define JET_bitRetrieveFromIndex		0x00000002
#define JET_bitRetrieveCase			0x00000004
#define JET_bitRetrieveTag				0x00000008
#define JET_bitRetrieveRecord			0x80000000
#define JET_bitRetrieveFDB				0x40000000
#define JET_bitRetrieveBookmarks		0x20000000

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void _far 			*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;

	/* Flags for JetFillFatCursor */

#define JET_bitFCFillRange		0x00000001
#define JET_bitFCRefreshRange		0x00000002
#define JET_bitFCFillMemos		0x00000004

	/* Flags for JetCommitTransaction */

#define JET_bitCommitFlush		0x00000001

	/* Flags for JetRollback */

#define JET_bitRollbackAll		0x00000001

	/* Flags for JetSetAccess and JetGetAccess */

#define JET_bitACEInheritable		0x00000001

	/* Flags for JetCreateSystemDatabase */

#define JET_bitSysDbOverwrite	0x00000001

	/* Flags for Jet Property Management */
#define JET_bitPropDDL				0x00000001		/* also used for setting */
#define JET_bitPropInherited		0x00000002		/* not used for setting */

	/* JPM Flags that are only used for setting properties */
#define JET_bitPropReplaceOnly		0x00000010
#define JET_bitPropInsertOnly		0x00000020
#define JET_bitPropDeleteOnly		0x00000040
	
	/* InfoLevels for Jet Property Management */
#define JET_PropertyValue				0
#define JET_PropertyCount				1
#define JET_PropertySingleCollection 	2
#define JET_PropertyAllCollections		3

	/* Collate values for JetGetColumnInfo and JetGetIndexInfo */

#define JET_sortBinary			0x0000
#define JET_sortEFGPI			0x0100
#define JET_sortSNIFD			0x0101
#define JET_sortSpanish 		0x0102
#define JET_sortDutch			0x0103
#define JET_sortSweFin			0x0104
#define JET_sortNorDan			0x0105
#define JET_sortIcelandic		0x0106
#define JET_sortCyrillic		0x0107
#define JET_sortCzech			0x0108
#define JET_sortHungarian		0x0109
#define JET_sortPolish			0x010A
#define JET_sortArabic			0x010B
#define JET_sortHebrew			0x010C
#define JET_sortMax				0x010C		/* Max for nonDBCS sort orders */

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
#define JET_sortJapanese		0x010D
#endif /* DBCS */

#define JET_sortUnknown 		0xFFFF

	/* Paradox ISAM specific collate values */

#define JET_sortPdxIntl 		0x1000
#define JET_sortPdxSwedFin		0x1001
#define JET_sortPdxNorDan		0x1002

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename		0
#define JET_DbInfoConnect		1
#define JET_DbInfoCountry		2
#define JET_DbInfoLangid		3
#define JET_DbInfoCp			4
#define JET_DbInfoCollate		5
#define JET_DbInfoOptions		6
#define JET_DbInfoTransactions	7
#define JET_DbInfoVersion		8
#define JET_DbInfoIsam			9

	/* Database versions returned by JetGetDatabaseInfo */

#define JET_DbVersion10			0x00010000
#define JET_DbVersion11			0x00010001
#define JET_DbVersion20			0x00020000


	/* Isam specific info returned by JetGetDatabaseInfo */

#define JET_IsamInvalid			0
#define JET_IsamBuiltinRed		1
#define JET_IsamBuiltinBlue		2

#define	JET_IsamInstRed			21
#define JET_IsamInstBlue		22
#define	JET_IsamInstFox			23
#define JET_IsamInstParadox		24
#define JET_IsamInstDbase		25
#define	JET_IsamInstBtrieve		26

#define JET_IsamBuilinMost		JET_BuiltinBlue
#define JET_IsamInstMin			JET_IsamInstRed
#define	JET_IsamInstMost		JET_IsamInstBtrieve

	/* Link specific info for link identification */
#define JET_bitLinkInvalid		0x00000000
#define JET_bitLinkRemote		0x00100000
#define JET_bitLinkBuiltinRed	0x00200000
#define JET_bitLinkBuiltinBlue	0x00300000
#define JET_bitLinkInstRed		0x00400000
#define JET_bitLinkInstBlue		0x00500000
#define JET_bitLinkInstFox		0x00600000
#define JET_bitLinkInstParadox	0x00700000
#define JET_bitLinkInstDbase	0x00800000
#define JET_bitLinkInstBtrieve	0x00900000

#define JET_bitFourByteBookmark		0x00000001
#define	JET_bitContiguousBookmarks	0x00000002

	/* Column data types */

	/* the column types are represented with 4 bits */
	/* make sure the choices below fit!				*/
	/* NOTE:  all comb of the 4 bits are now used! */
	/* CONSIDER:  to allow more datatypes, either 				 */
	/* CONSIDER:  JET_coltypDatabase and JET_coltypTableid	must */
	/* CONSIDER:  change or the 4 bit dependancy must be removed */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */

	/* The following are additional types used for query parameters */
	/* NOTE:  Code depends on these being contiguous with the normal coltyps */
	/* CONSIDER:  Remove the above dependency on contiguous coltyps in QJET */

#define JET_coltypDatabase			13		/* Database name parameter */
#define JET_coltypTableid			14		/* Tableid parameter */

#define JET_coltypOLE				15		/* OLE blob */

#define JET_coltypMax				16		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U

	/* Info levels for JetGetReferenceInfo and JetGetTableReferenceInfo */

#define JET_ReferenceInfo		0U
#define JET_ReferenceInfoReferencing	1U
#define JET_ReferenceInfoReferenced	2U
#define JET_ReferenceInfoAll		3U
#define JET_ReferenceInfoCursor 	4U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#define JET_ColInfo			0U
#define JET_ColInfoList 		1U

	/* CONSIDER: Info level 2 is valid */

#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 		4U


	/* Attribute types for query definitions */

#define JET_qoaBeginDef 		0
#define JET_qoaOperation		1
#define JET_qoaParameter		2
#define JET_qoaOptions			3
#define JET_qoaDatabase 		4
#define JET_qoaInputTable		5
#define JET_qoaOutput			6
#define JET_qoaJoin			7
#define JET_qoaRestriction		8
#define JET_qoaGroup			9
#define JET_qoaGroupRstr		10
#define JET_qoaOrdering 		11
#define JET_qoaEndDef			255
#define JET_qoaValidLeast		JET_qoaOperation
#define JET_qoaValidMost		JET_qoaOrdering


	/* Query object options */

#define JET_bitFqoOutputAllCols 	0x0001
#define JET_bitFqoRemoveDups		0x0002
#define JET_bitFqoOwnerAccess		0x0004
#define JET_bitFqoDistinctRow		0x0008
#define JET_bitFqoTop				0x0010
#define JET_bitFqoPercent			0x0020
#define JET_bitFqoCorresponding		0x0040 /* JET_qopSetOperation */

	/* Query object join type */

#define JET_fjoinInner			1
#define JET_fjoinLeftOuter		2
#define JET_fjoinRightOuter		3

	/* Query object operations */

#define JET_qopSelect			1
#define JET_qopSelectInto		2
#define JET_qopInsertSelection	3
#define JET_qopUpdate			4
#define JET_qopDelete			5
#define JET_qopTransform		6
#define JET_qopDDL				7
#define JET_qopSqlPassThrough	8
#define JET_qopSetOperation		9
#define JET_qopSPTBulk			10

#define JET_bitqopSelect			0x0000
#define JET_bitqopTransform			0x0010
#define JET_bitqopDelete			0x0020
#define JET_bitqopUpdate			0x0030
#define JET_bitqopInsertSelection	0x0040
#define JET_bitqopSelectInto		0x0050
#define JET_bitqopDDL				0x0060
#define JET_bitqopSqlPassThrough	0x0070
#define JET_bitqopSetOperation		0x0080
#define JET_bitqopSPTBulk			0x0090

	/* Engine Object Types */

#define JET_objtypNil			0
#define JET_objtypTable 		1
#define JET_objtypDb			2
#define JET_objtypContainer		3
#define JET_objtypSQLLink		4
#define JET_objtypQuery 		5
#define JET_objtypLink			6
#define JET_objtypTemplate		7
#define JET_objtypRelationship		8

	/* All types less than JET_objtypClientMin are reserved by JET */

#define JET_objtypClientMin		0x8000

	/* Security Constant Values */

#define JET_cchUserNameMax		20
#define JET_cchPasswordMax		14

	/* Security Access Masks */

#define JET_acmNoAccess 		0x00000000L
#define JET_acmFullAccess		0x000FFFFFL

#define JET_acmSpecificMask		0x0000FFFFL
#define JET_acmSpecific_1		0x00000001L
#define JET_acmSpecific_2		0x00000002L
#define JET_acmSpecific_3		0x00000004L
#define JET_acmSpecific_4		0x00000008L
#define JET_acmSpecific_5		0x00000010L
#define JET_acmSpecific_6		0x00000020L
#define JET_acmSpecific_7		0x00000040L
#define JET_acmSpecific_8		0x00000080L
#define JET_acmSpecific_9		0x00000100L
#define JET_acmSpecific_10		0x00000200L
#define JET_acmSpecific_11		0x00000400L
#define JET_acmSpecific_12		0x00000800L
#define JET_acmSpecific_13		0x00001000L
#define JET_acmSpecific_14		0x00002000L
#define JET_acmSpecific_15		0x00004000L
#define JET_acmSpecific_16		0x00008000L

#define JET_acmStandardMask		0x00FF0000L
#define JET_acmDelete			0x00010000L
#define JET_acmReadControl		0x00020000L
#define JET_acmWriteDac 		0x00040000L
#define JET_acmWriteOwner		0x00080000L

#define JET_acmTblCreate		(JET_acmSpecific_1)
#define JET_acmTblAccessRcols		(JET_acmSpecific_2)
#define JET_acmTblReadDef		(JET_acmSpecific_3)
#define JET_acmTblWriteDef		(JET_acmSpecific_4)
#define JET_acmTblRetrieveData		(JET_acmSpecific_5)
#define JET_acmTblInsertData		(JET_acmSpecific_6)
#define JET_acmTblReplaceData		(JET_acmSpecific_7)
#define JET_acmTblDeleteData		(JET_acmSpecific_8)

#define JET_acmDbCreate 		(JET_acmSpecific_1)
#define JET_acmDbOpen			(JET_acmSpecific_2)

	/* Compact Options */

#define JET_bitCompactEncrypt		0x00000001	/* Dest is encrypted */
#define JET_bitCompactDecrypt		0x00000002	/* Dest is not encrypted */
#define JET_bitCompactDontCopyLocale	0x00000004	/* Don't copy locale from source to dest */
#define JET_bitCompactVersion10		0x00000008	/* Destination is version 1.0 format */
#define JET_bitCompactVersion1x		0x00000010	/* Destination is version 1.x format */

	/* On-line Compact Options */

#define JET_bitCompactOn	 		0x00000001	/* enable on-line compaction */

	/* Repair Notification Types */

#define JET_rntSelfContained		0	/* CONSIDER: These are SNCs */
#define JET_rntDeletedIndex		1
#define JET_rntDeletedRec		2
#define JET_rntDeletedLv		3
#define JET_rntTruncated		4

	/* Status Notification Processes */

#define JET_snpIndex			0
#define JET_snpQuery			1
#define JET_snpRepair			2
#define JET_snpImex				3
#define JET_snpCompact			4
#define JET_snpFastFind 		5
#define JET_snpODBCNotReady		6
#define JET_snpQuerySort		7
#define JET_snpRestore			8

	/* Status Notification Types */

#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntMessage			1
#define JET_sntBulkRecords		2	/* callback for # rec for bulk op */
#define JET_sntFail				3	/* callback for failure during progress */
#define JET_sntErrCount 		4	/* callback for err count */
#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntCantRollback		7	/* callback for no rollback */
#define JET_sntRestoreMap		8	/* callback for restore map */

	/* Message codes for JET_snpCompact */

#define JET_sncCopyObject		0	/* Starting to copy object */
#define JET_sncCopyFailed		1	/* Copy of this object failed */
#define JET_sncYield			2	/* Client can yield/check for user interrupt */
#define JET_sncTransactionFull		3	/* Client can yield/check for user interrupt */
#define JET_sncAboutToWrap		4	/* Find find is about to wrap */

	/* Message codes for JET_snpODBCNotReady */
#define JET_sncODBCNotReady		0	/* Waiting for results from ODBC */


	/* Constants for the [ODBC] section of JET.INI */

#define JET_SQLTraceCanonical	0x0001	/* Output ODBC Generic SQL */

	/* Constants for the [Debug] section of JET.INI */

	/* APITrace */

#define JET_APITraceEnter	0x0001
#define JET_APITraceExit	0x0002
#define JET_APITraceExitError	0x0004
#define JET_APIBreakOnError	0x0008
#define JET_APITraceCount	0x0010
#define JET_APITraceNoIdle	0x0020
#define JET_APITraceParameters	0x0040

	/* IdleTrace */

#define JET_IdleTraceCursor	0x0001
#define JET_IdleTraceBuffer	0x0002
#define JET_IdleTraceFlush	0x0004

	/* AssertAction */

#define JET_AssertExit		0x0000		/* Exit the application */
#define JET_AssertBreak 	0x0001		/* Break to debugger */
#define JET_AssertMsgBox	0x0002		/* Display message box */
#define JET_AssertStop		0x0004		/* Alert and stop */

	/* IOTrace */

#define JET_IOTraceAlloc	0x0001		/* DB Page Allocation */
#define JET_IOTraceFree 	0x0002		/* DB Page Free */
#define JET_IOTraceRead 	0x0004		/* DB Page Read */
#define JET_IOTraceWrite	0x0008		/* DB Page Write */
#define JET_IOTraceError	0x0010		/* DB Page I/O Error */

	/* MemTrace */

#define JET_MemTraceAlloc	0x0001		/* Memory allocation */
#define JET_MemTraceRealloc	0x0002		/* Memory reallocation */
#define JET_MemTraceFree	0x0004		/* Memory free */

	/* RmtTrace */

#define JET_RmtTraceError	0x0001	/* Remote server error message */
#define JET_RmtTraceSql		0x0002	/* Remote SQL Prepares & Exec's */
#define JET_RmtTraceAPI		0x0004	/* Remote ODBC API calls */
#define JET_RmtTraceODBC	0x0008
#define JET_RmtSyncODBC		0x0010	/* Turn on ODBC Sync mode */

/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess			 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100	/* JET_errRfsFailure */
#define JET_errRfsNotArmed					-101	/* JET_errRfsFailure */
#define JET_errFileClose					-102	/* Could not close DOS file */
#define JET_errNoMoreThreads				-103	/* Could not start thread */
#define JET_errNoComputerName	  			-104	/* fail to get computername */
#define JET_errTooManyIO		  			-105	/* System busy due to too many IOs */

/*	BUFFER MANAGER errors
/**/
#define wrnBFNotSynchronous					200			/* Buffer page evicted */
#define wrnBFPageNotFound		  			201			/* Page not found */
#define errBFInUse				  			-202		/* Cannot abandon buffer */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300		/* Out of page space */
#define errPMItagTooBig 		  			-301		/* Itag too big */
#define errPMRecDeleted 		  			-302		/* Record deleted */
#define errPMTagsUsedUp 		  			-303		/* Tags used up */
#define wrnBMConflict			  			304     	/* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305		/* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306		/* Cannot horizontally split FDP */
#define errDIRTop				  			-307		/* Cannot go up */
#define errDIRFDP							308			/* On an FDP Node */
#define errDIRNotSynchronous				-309		/* May have left critical section */
#define wrnDIREmptyPage						310			/* Moved through empty page */
#define errSPConflict						-311		/* Device extent being extended */
#define wrnNDFoundLess						312			/* Found Less */
#define wrnNDFoundGreater					313			/* Found Greater */
#define errNDOutSonRange					-314		/* Son out of range */
#define errNDOutItemRange					-315		/* Item out of range */
#define errNDGreaterThanAllItems 			-316		/* Greater than all items */
#define errNDLastItemNode					-317		/* Last node of item list */
#define errNDFirstItemNode					-318		/* First node of item list */
#define wrnNDDuplicateItem					319			/* Duplicated Item */
#define errNDNoItem							-320		/* Item not there */
#define JET_wrnRemainingVersions 			321			/* Some versions couldn't be cleaned */
#define JET_wrnPreviousVersion				322			/* Version already existed */
#define JET_errPageBoundary					-323		/* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324		/* Reached Key Boundary */
#define errDIRInPageFather  				-325		/* sridFather in page to free

/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					400			/* Key too big (truncated it) */
#define errFLDTooManySegments				-401		/* Too many key segments */
#define wrnFLDNullKey						402			/* Key is entirely NULL */
#define wrnFLDOutOfKeys 					403			/* No more keys to extract */
#define wrnFLDNullSeg						404			/* Null segment in key */
#define wrnRECLongField 					405			/* Separated long field */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid

/*	LOGGING/RECOVERY errors
/**/
#define JET_errRestoreFailed   				-500		/* Restore failed */
#define JET_errLogFileCorrupt		  		-501		/* Log file is corrupt */
#define errLGNoMoreRecords					-502		/* Last log record read */
#define JET_errNoBackupDirectory 			-503		/* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504		/* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505		/* Backup is active already */
#define JET_errFailRestoreDatabase 			-506		/* Fail to restore (copy) database */
#define JET_errNoDatabasesForRestore 		-507		/* No databases for restor found */
#define JET_errMissingLogFile	   			-508		/* jet.log for restore is missing */
#define JET_errMissingPreviousLogFile		-509		/* Missing the log file for check point */
#define JET_errLogWriteFail					-510		/* Fail when writing to log file */
#define JET_errLogNotContigous	 			-511		/* Fail to incremental backup for non-contiguous generation number */
#define JET_errFailToMakeTempDirectory		-512		/* Fail to make a temp directory */
#define JET_errFailToCleanTempDirectory		-513		/* Fail to clean up temp directory */
#define JET_errBadLogVersion  	  			-514		/* Version of log file is not compatible with Jet version */
#define JET_errBadNextLogVersion   			-515		/* Version of next log file is not compatible with current one */
#define JET_errLoggingDisabled 				-516		/* Log is not active */
#define JET_errLogBufferTooSmall			-517		/* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518		/* retry to LGLogRec */

#define JET_errFeatureNotAvailable	-1001 /* API not supported */
#define JET_errInvalidName		-1002 /* Invalid name */
#define JET_errInvalidParameter 	-1003 /* Invalid API parameter */
#define JET_wrnColumnNull		 1004 /* Column is NULL-valued */
#define JET_errReferenceNotFound	-1005 /* No such reference */
#define JET_wrnBufferTruncated		 1006 /* Buf too short, data truncated */
#define JET_wrnDatabaseAttached 	 1007 /* Database is already attached */
#define JET_wrnOnEndPoint		 1008 /* On end point */
#define JET_wrnSortOverflow		 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId	-1010 /* Invalid database id */
#define JET_errOutOfMemory		-1011 /* Out of Memory */
#define JET_errCantAllocatePage 	-1012 /* Couldn't allocate a page */
#define JET_errNoMoreCursors		-1013 /* Max # of cursors allocated */
#define JET_errOutOfBuffers		-1014 /* JET_errOutOfBuffers */
#define JET_errTooManyIndexes		-1015 /* Too many indexes */
#define JET_errTooManyKeys		-1016 /* Too many columns in an index */
#define JET_errRecordDeleted		-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure	-1018 /* Read verification error */
#define JET_errFilesysVersion		-1019 /* Obsolete database format */
#define JET_errNoMoreFiles		-1020 /* No more file handles */
#define JET_errDiskNotReady		-1021 /* Disk not ready */
#define JET_errDiskIO			-1022 /* JET_errDiskIO */
#define JET_errInvalidPath		-1023 /* JET_errInvalidPath */
#define JET_errFileShareViolation	-1024 /* JET_errFileShareViolation */
#define JET_errFileLockViolation	-1025 /* JET_errFileLockViolation */
#define JET_errRecordTooBig		-1026 /* JET_errRecordTooBig */
#define JET_errTooManyOpenDatabases	-1027 /* Database limit reached */
#define JET_errInvalidDatabase		-1028 /* This isn't a database */
#define JET_errNotInitialized		-1029 /* JetInit not yet called */
#define JET_errAlreadyInitialized	-1030 /* JetInit already called */
#define JET_errFileLockingUnavailable	-1031 /* JET_errFileLockingUnavailable */
#define JET_errFileAccessDenied 	-1032 /* JET_errFileAccessDenied */
#define JET_errSharingBufferExceeded	-1033 /* OS sharing buffer exceeded */
#define JET_errQueryNotSupported	-1034 /* Query support unavailable */
#define JET_errSQLLinkNotSupported	-1035 /* SQL Link support unavailable */
#define JET_errTaskLimitExceeded	-1036 /* Too many client tasks */
#define JET_errUnsupportedOSVersion	-1037 /* Unsupported OS version */
#define JET_errBufferTooSmall		-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual		 1039 /* SeekLE or SeekGE didn't find exact match */
#define JET_errTooManyColumns		-1040 /* Too many columns defined */
#define JET_errTooManyFixedColumns	-1041 /* Too many fixed columns defined */
#define JET_errTooManyVariableColumns	-1042 /* Too many variable columns defined */
#define JET_errContainerNotEmpty	-1043 /* Container is not empty */
#define JET_errInvalidFilename		-1044 /* Filename is invalid */
#define JET_errInvalidBookmark		-1045 /* Invalid bookmark */
#define JET_errColumnInUse		-1046 /* Column used in an index */
#define JET_errInvalidBufferSize	-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable	-1048 /* Can't set column value */
#define JET_wrnCommitNotFlushed 	 1049 /* Commit did not flush to disk */
#define JET_errAbortSalvage		-1050 /* Forced Salvager abort */
#define JET_errIndexInUse		-1051 /* Index is in use */
#define JET_errLinkNotSupported 	-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed	-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 	-1054 /* JET_errNotInTransaction */
#define JET_wrnNoErrorInfo		 1055 /* No extended error information */
#define JET_errInstallableIsamNotFound	-1056 /* Installable ISAM not found */
#define JET_errOperationCancelled	-1057 /* Operation canceled by client */
#define JET_wrnNoIdleActivity		 1058 /* No idle activity occured */
#define JET_errTooManyActiveUsers	-1059 /* Too many active database users */
#define JET_errInvalidAppend		-1060 /* Cannot append long value */
#define JET_errInvalidCountry		-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId	-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage		-1063 /* Invalid or unknown code page */
#define JET_errCantBuildKey		-1064 /* Can't build key for this sort order. */
#define JET_errIllegalReentrancy	-1065 /* Re-entrancy on same cursor family */
#define JET_errIllegalRelationship	-1066 /* Can't create relationship */
#define JET_wrnNoWriteLock					1067	/* No write lock at transaction level 0 */
#define JET_errDBVerFeatureNotAvailable	-1067 /* API not supported using old database format*/

#define JET_errCantBegin		-1101 /* Cannot BeginSession */
#define JET_errWriteConflict		-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep		-1103 /* Xactions nested too deeply */
#define JET_errInvalidSesid		-1104 /* Invalid session handle */
#define JET_errReadConflict		-1105 /* Commit lock failed due to outstanding read lock */
#define JET_errCommitConflict		-1106 /* Read lock failed due to outstanding commit lock */
#define JET_errSessionWriteConflict	-1107 /* Another session has private version of page */
#define JET_errInTransaction		-1108 /* Operation not allowed within a transaction */

#define JET_errDatabaseDuplicate	-1201 /* Database already exists */
#define JET_errDatabaseInUse		-1202 /* Database in use */
#define JET_errDatabaseNotFound 	-1203 /* No such database */
#define JET_errDatabaseInvalidName	-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages	-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted	-1206 /* non-db file or corrupted db */
#define JET_errDatabaseLocked		-1207 /* Database exclusively locked */
#define JET_wrnDatabaseEncrypted	 1208 /* Database is encrypted */

#define JET_wrnTableEmpty			 1301 /* Open an empty table */
#define JET_errTableLocked			-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate		-1303 /* Table already exists */
#define JET_errTableInUse			-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound		-1305 /* No such table or object */
#define JET_errCannotRename			-1306 /* Cannot rename temporary file */
#define JET_errDensityInvalid		-1307 /* Bad file/index density */
#define JET_errTableNotEmpty		-1308 /* Cannot define clustered index */
#define JET_errTableNotLocked		-1309 /* No DDLs w/o exclusive lock */
#define JET_errInvalidTableId		-1310 /* Invalid table id */
#define JET_errTooManyOpenTables	-1311 /* Cannot open any more tables */
#define JET_errIllegalOperation 	-1312 /* Oper. not supported on table */
#define JET_wrnExecSegReleased		 1313 /* Query Execution segment is released */
#define JET_errObjectDuplicate		-1314 /* Table or object name in use */
#define JET_errRulesLoaded			-1315 /* Rules loaded, can't define more */
#define JET_errInvalidObject		-1316 /* object is invalid for operation */

#define JET_errIndexCantBuild		-1401 /* Cannot build clustered index */
#define JET_errIndexHasPrimary		-1402 /* Primary index already defined */
#define JET_errIndexDuplicate		-1403 /* Index is already defined */
#define JET_errIndexNotFound		-1404 /* No such index */
#define JET_errIndexMustStay		-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef		-1406 /* Illegal index definition */
#define JET_errSelfReference		-1407 /* Referencing/Referenced index is the same */
#define JET_errIndexHasClustered	-1408 /* Clustered index already defined */

#define JET_errColumnLong			-1501 /* column value is long */
#define JET_errColumnNoChunk		-1502 /* no such chunk in field */
#define JET_errColumnDoesNotFit 	-1503 /* Field will not fit in record */
#define JET_errNullInvalid			-1504 /* Null not valid */
#define JET_errColumnIndexed		-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig			-1506 /* Field length is > maximum */
#define JET_errColumnNotFound		-1507 /* No such column */
#define JET_errColumnDuplicate		-1508 /* Field is already defined */
#define JET_errTaggedDefault		-1509 /* No defaults on tagged fields */
#define JET_errColumn2ndSysMaint	-1510 /* Second autoinc or version column */
#define JET_errInvalidColumnType	-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 1512 /* Max length too big, truncated */
#define JET_errColumnCannotIndex	-1513 /* Cannot index Bit,LongText,LongBinary */
#define JET_errTaggedNotNULL		-1514 /* No non-NULL tagged fields */
#define JET_errNoCurrentIndex		-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade			-1516 /* The key is completely made */
#define JET_errBadColumnId			-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence		-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship	-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue		1520	/*	Single instance column bursted */
#define JET_errCannotBeTagged		-1521 /* AutoIncrement and Version cannot be tagged */

#define JET_errRecordNotFound		-1601 /* The key was not found */
#define JET_errRecordNoCopy			-1602 /* No working buffer */
#define JET_errNoCurrentRecord		-1603 /* Currency not on a record */
#define JET_errRecordClusteredChanged	-1604 /* Primary key may not change */
#define JET_errKeyDuplicate			-1605 /* Illegal duplicate key */
#define JET_errCannotInsertBefore	-1606 /* Cannot insert before current */
#define JET_errAlreadyPrepared		-1607 /* Already copy/clear current */
#define JET_errKeyNotMade			-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared	-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 1610 /* Data has changed */
#define JET_errDataHasChanged		-1611 /* Data has changed; operation aborted */
#define JET_errIntegrityViolationMaster -1612 /* References to key exist */
#define JET_errIntegrityViolationSlave	-1613 /* No referenced key exists */
#define JET_wrnMuchDataChanged		 1614 /* Repaint whole datasheet */
#define JET_errIncorrectJoinKey		-1615 /* Master key does not match lookup key */
#define JET_wrnKeyChanged			 1618 /* Moved to new key */
#define JET_wrnSyncedToDelRec		 1699 /* CONSIDER: QJET INTERNAL */
#define JET_errRedoPrepUpdate		 1698 /* CONSIDER: QJET INTERNAL(jpbulk.c)*/

#define JET_errTooManySorts			-1701 /* Too many sort processes */
#define JET_errInvalidOnSort		-1702 /* Invalid operation on Sort */

#define JET_errConfigOpenError		-1801 /* Config. file can't be opened */
#define JET_errSysDatabaseOpenError	-1802 /* System db could not be opened */
#define JET_errTempFileOpenError	-1803 /* Temp file could not be opened */
#define JET_errDatabaseOpenError	-1804 /* Database file can't be opened */
#define JET_errTooManyAttachedDatabases -1805 /* Too many open databases */
#define JET_errDatabaseCloseError	-1806 /* Db file could not be closed */
#define JET_errTooManyOpenFiles 	-1807 /* Too many files open */
#define JET_errDiskFull 			-1808 /* No space left on disk */
#define JET_errPermissionDenied 	-1809 /* Permission denied */
#define JET_errSortFileOpenError	-1810 /* Could not open sort file */
#define JET_errFileNotFound			-1811 /* File not found */
#define JET_errTempDiskFull			-1812 /* No space left on disk */
#define JET_wrnFileOpenReadOnly		1813 /* Database file is read only */

#define JET_errAfterInitialization	-1850 /* Cannot Restore after init. */
#define JET_errSeriesTooLong		-1851 /* New log generation id too big */
#define JET_errLogCorrupted			-1852 /* Logs could not be interpreted */

#define JET_errCannotOpenSystemDb	-1901 /* failed sysdb on beginsession */
#define JET_errInvalidLogon			-1902 /* invalid logon at beginsession */
#define JET_errInvalidAccountName	-1903 /* invalid account name */
#define JET_errInvalidSid			-1904 /* invalid SID */
#define JET_errInvalidPassword		-1905 /* invalid password */
#define JET_errInvalidOperation 	-1906 /* invalid operation */
#define JET_errAccessDenied			-1907 /* access denied */
#define JET_errNoMSysAccounts		-1908 /* Can't open MSysAccounts */
#define JET_errNoMSysGroups			-1909 /* Can't open MSysGroups */
#define JET_errInvalidPin			-1910	/* invalid pin */

#define JET_errRmtSqlError			-2001 /* RMT: ODBC call failed */
#define JET_errRmtMissingOdbcDll	-2006 /* RMT: Can't load ODBC DLL */
#define JET_errRmtInsertFailed		-2007 /* RMT: Insert statement failed */
#define JET_errRmtDeleteFailed		-2008 /* RMT: Delete statement failed */
#define JET_errRmtUpdateFailed		-2009 /* RMT: Update statement failed */
#define JET_errRmtColDataTruncated	-2010 /* RMT: data truncated */
#define JET_errRmtTypeIncompat		-2011 /* RMT: Can't create JET type on server */
#define JET_errRmtCreateTableFailed	-2012 /* RMT: Create table stmt failed */
#define JET_errRmtNotSupported		-2014 /* RMT: Function not legal for rdb */
#define JET_errRmtValueOutOfRange	-2020 /* RMT: Data value out of range */
#define JET_errRmtStillExec		-2021 /* RMT INTERNAL: SQL_STILL_EXECUTING */
#define JET_errRmtQueryTimeout		-2022 /* RMT: Server Not Responding */
#define JET_wrnRmtNeedLvData		 2023 /* RMT: Internal only - need Lv data */
#define JET_wrnFatCursorUseless		 2024 /* Fat cursor has no effect ***/
#define JET_errRmtWrongSPVer		-2025 /* RMT: INTERNAL: wrong SProc ver ***/
#define JET_errRmtLinkOutOfSync		-2026 /* RMT: the def for the rmt tbl has changed */
#define JET_errRmtDenyWriteIsInvalid	-2027 /* RMT: Can't open DenyWrite */
#define JET_errRmtDriverCantConv	-2029 /* RMT: INTERNAL: driver cannot convert */
#define JET_errRmtTableAmbiguous	-2030 /* RMT: Table ambiguous: must specifier owner */
#define JET_errRmtBogusConnStr		-2031 /* RMT: SPT: Bad connect string */

#define JET_errQueryInvalidAttribute	-3001 /* Invalid query attribute */
#define JET_errQueryOnlyOneRow		-3002 /* Only 1 such row allowed */
#define JET_errQueryIncompleteRow	-3003 /* Missing value in row */
#define JET_errQueryInvalidFlag 	-3004 /* Invalid value in Flag field */
#define JET_errQueryCycle		-3005 /* Cycle in query definition */
#define JET_errQueryInvalidJoinTable	-3006 /* Invalid table in join */
#define JET_errQueryAmbigRef		-3007 /* Ambiguous column reference */
#define JET_errQueryUnboundRef		-3008 /* Cannot bind name */
#define JET_errQueryParmRedef		-3009 /* Parm redefined with different type */
#define JET_errQueryMissingParms	-3010 /* Too few parameters supplied */
#define JET_errQueryInvalidOutput	-3011 /* Invalid query output */
#define JET_errQueryInvalidHaving	-3012 /* HAVING clause without aggregation */
#define JET_errQueryDuplicateAlias	-3013 /* Duplicate output alias */
#define JET_errQueryInvalidMGBInput	-3014 /* Cannot input from MGB */
#define JET_errQueryInvalidOrder	-3015 /* Invalid ORDER BY expression */
#define JET_errQueryTooManyLevels	-3016 /* Too many levels on MGB */
#define JET_errQueryMissingLevel	-3017 /* Missing intermediate MGB level */
#define JET_errQueryIllegalAggregate	-3018 /* Aggregates not allowed */
#define JET_errQueryDuplicateOutput	-3019 /* Duplicate destination output */
#define JET_errQueryIsBulkOp		-3020 /* Grbit should be set for Bulk Operation */
#define JET_errQueryIsNotBulkOp 	-3021 /* Query is not a Bulk Operation */
#define JET_errQueryIllegalOuterJoin	-3022 /* No inconsistent updates on outer joins */
#define JET_errQueryNullRequired	-3023 /* Column must be NULL */
#define JET_errQueryNoOutputs		-3024 /* Query must have an output */
#define JET_errQueryNoInputTables	-3025 /* Query must have an input */
#define JET_wrnQueryNonUpdatableRvt	 3026 /* Query is not updatable (but IS RVT) */
#define JET_errQueryInvalidAlias	-3027 /* Bogus character in alias name */
#define JET_errQueryInvalidBulkInput	-3028 /* Cannot input from bulk operation */
#define JET_errQueryNotDirectChild	-3029 /* T.* must use direct child */
#define JET_errQueryExprEvaluation	-3030 /* Expression evaluation error */
#define JET_errQueryIsNotRowReturning	-3031 /* Query does not return rows */
#define JET_wrnQueryNonRvt		 3032 /* Can't create RVT, query is static */
#define JET_errQueryParmTypeMismatch	-3033 /* Wrong parameter type given */
#define JET_errQueryChanging		-3034 /* Query Objects are being updated */
#define JET_errQueryNotUpdatable	-3035 /* Operation must use an updatable query */
#define JET_errQueryMissingColumnName	-3036 /* Missing destination column */
#define JET_errQueryTableDuplicate	-3037 /* Repeated table name in FROM list */
#define JET_errQueryIsMGB		-3038 /* Query is an MGB */
#define JET_errQueryInsIntoBulkMGB	-3039 /* Cannot insert into Bulk/MGB */
#define JET_errQueryDistinctNotAllowed	-3040 /* DISTINCT not allowed for MGB */
#define JET_errQueryDistinctRowNotAllow -3041 /* DISTINCTROW not allowed for MGB */
#define JET_errQueryNoDbForParmDestTbl	-3045 /* Dest DB for VT parm not allowed */
#define JET_errQueryDuplicatedFixedSet	-3047 /* Duplicated Fixed Value */
#define JET_errQueryNoDeleteTables	-3048 /* Must specify tables to delete from */
#define JET_errQueryCannotDelete	-3049 /* Cannot delete from specified tables */
#define JET_errQueryTooManyGroupExprs	-3050 /* Too many GROUP BY expressions */
#define JET_errQueryTooManyOrderExprs	-3051 /* Too many ORDER BY expressions */
#define JET_errQueryTooManyDistExprs	-3052 /* Too many DISTINCT output expressions */
#define JET_errQueryBadValueList	-3053 /* Malformed value list in Transform */
#define JET_errConnStrTooLong		-3054 /* Connect string too long */
#define JET_errQueryInvalidParm		-3055 /* Invalid Parmeter Name (>64 char) */
#define JET_errQueryContainsDbParm	-3056 /* Can't get parameters with Db Parm */
#define JET_errQueryBadUpwardRefed	-3057 /* Illegally Upward ref'ed */
#define JET_errQueryAmbiguousJoins	-3058 /* Joins in a QO are ambiguous */
#define JET_errQueryIsNotDDL		-3059 /* Not a DDL Operation */
#define JET_errNoDbInConnStr		-3060 /* No database in connect string */
#define JET_wrnQueryIsNotRowReturning	 3061 /* Not row returning */
#define JET_errTooManyFindSessions	-3062 /* RVT already has a find session open  */
#define JET_errSingleValueExpected	-3063 /* At most one record with one column can be returned from a scalar subquery */
#define JET_errColumnCountMismatch	-3064 /* Union Query: number of columns in children dont match */
#define JET_errQueryTopNotAllowed	-3065 /* Top not allowed for MGB */
#define JET_errQueryIsDDL			-3066 /* Must set JET_bitTableDDL */
#define JET_errQueryIsCorrupt		-3067 /* Query is Corrupt */
#define JET_errQuerySPTBulkSucceeded -3068 /* INTERNAL only */
#define JET_errSPTReturnedNoRecords -3069 /* SPT marked as RowReturning did not return a table */

#define JET_errExprSyntax		-3100 /* Syntax error in expression */
#define JET_errExprIllegalType		-3101 /* Illegal type in expression */
#define JET_errExprUnknownFunction	-3102 /* Unknown function in expression */

#define JET_errSQLSyntax		-3500 /* Bogus SQL statement type */
#define JET_errSQLParameterSyntax	-3501 /* Parameter clause syntax error */
#define JET_errSQLInsertSyntax		-3502 /* INSERT clause syntax error */
#define JET_errSQLUpdateSyntax		-3503 /* UPDATE clause syntax error */
#define JET_errSQLSelectSyntax		-3504 /* SELECT clause syntax error */
#define JET_errSQLDeleteSyntax		-3505 /* Expected 'FROM' after 'DELETE' */
#define JET_errSQLFromSyntax		-3506 /* FROM clause syntax error */
#define JET_errSQLGroupBySyntax 	-3507 /* GROUP BY clause syntax error */
#define JET_errSQLOrderBySyntax 	-3508 /* ORDER BY clause syntax error */
#define JET_errSQLLevelSyntax		-3509 /* LEVEL syntax error */
#define JET_errSQLJoinSyntax		-3510 /* JOIN syntax error */
#define JET_errSQLTransformSyntax	-3511 /* TRANSFORM syntax error */
#define JET_errSQLHavingSyntax		-3512 /* HAVING clause syntax error */
#define JET_errSQLWhereSyntax		-3513 /* WHERE clause syntax error */
#define JET_errSQLProcedureSyntax	-3514 /* Expected query name after 'PROCEDURE' */
#define JET_errSQLNotEnoughBuf		-3515 /* Buffer too small for SQL string */
#define JET_errSQLMissingSemicolon	-3516 /* Missing ; at end of SQL statement */
#define JET_errSQLTooManyTokens 	-3517 /* Characters after end of SQL statement */
#define JET_errSQLOwnerAccessSyntax -3518 /* OWNERACCESS OPTION syntax error */

#define	JET_errV11NotSupported		-3519 /* not supported in V11 */
#define JET_errV10Format			-3520 /* can be present in V10 format only */
#define JET_errSQLUnionSyntax		-3521 /* UNION query syntax error */
#define JET_errSqlPassThrough		-3523 /* Pass Through query Disallowed */
#define JET_wrnSqlPassThrough		 3524 /* Pass Through query involved */

#define JET_errDDLConstraintSyntax	-3550 /* constraint syntax error */
#define JET_errDDLCreateTableSyntax	-3551 /* create table syntax error */
#define JET_errDDLCreateIndexSyntax	-3552 /* create index syntax error */
#define JET_errDDLColumnDefSyntax	-3553 /* column def syntax error */
#define JET_errDDLAlterTableSyntax	-3554 /* alter table syntax error */
#define JET_errDDLDropIndexSyntax	-3555 /* drop index syntax error */
#define JET_errDDLDropSyntax		-3556 /* drop view/procedure syntax error */
#define JET_errDDLCreateViewSyntax	-3557 /* create view syntax error */

#define JET_errNoSuchProperty	-3600 /* Property was not found */
#define JET_errPropertyTooLarge -3601 /* Small Property larger than 2K */
#define JET_errJPMInvalidForV1x -3602 /* No JPM for V1.x databases */
#define JET_errPropertyExists	-3603 /* Property already exists */
#define JET_errInvalidDelete	-3604 /* DeleteOnly called with non-zero cbData */

#define JET_wrnFindWrapped		 3700 /* Cursor wrapped during fast find */

#define JET_errTLVNativeUserTablesOnly -3700 /* TLVs can only be placed on native user tables/columns */
#define JET_errTLVNoNull		  	   -3701 /* This field cannot be null */
#define JET_errTLVNoBlank			   -3702 /* This column cannot be blank */
#define	JET_errTLVRuleViolation 	   -3703 /* This validation rule must be met */
#define	JET_errTLVInvalidColumn	   	   -3704 /* This TLV property cannot be placed on this column */
#define JET_errTLVExprEvaluation	   -3705 /* Expression evaluation error */
#define JET_errTLVExprUnknownFunc	   -3706 /* Unknown function in TLV expression */
#define JET_errTLVExprSyntax		   -3707 /* Syntax error in TLV expression */

	/* CONSIDER: Remove the following error. */

#define JET_errGeneral			-5001 /* I-ISAM: assert failure */
#define JET_errRecordLocked		-5002 /* I-ISAM: record locked */
#define JET_wrnColumnDataTruncated	 5003 /* I-ISAM: data truncated */
#define JET_errTableNotOpen		-5004 /* I-ISAM: table is not open */
#define JET_errDecryptFail		-5005 /* I-ISAM: incorrect password */
#define JET_wrnCurrencyLost		 5007 /* I-ISAM: currency lost - must first/last */
#define JET_errDateOutOfRange		-5008 /* I-ISAM: invalid date */
#define JET_wrnOptionsIgnored		 5011 /* I-ISAM: options were ignored */
#define JET_errTableNotComplete		-5012 /* I-ISAM: incomplete table definition */
#define JET_errIllegalNetworkOption	-5013 /* I-ISAM: illegal network option */
#define JET_errIllegalTimeoutOption	-5014 /* I-ISAM: illegal timeout option */
#define JET_errNotExternalFormat	-5015 /* I-ISAM: invalid file format */
#define JET_errUnexpectedEngineReturn	-5016 /* I-ISAM: unexpected engine error code */
#define JET_errNumericFieldOverflow     -5017 /* I-ISAM: can't convert to native type */

#define JET_errIndexHasNoPrimary	-5020 /* Paradox: no primary index */
#define JET_errTableSortOrderMismatch	-5021 /* Paradox: sort order mismatch */
#define JET_errNoConfigParameters	-5023 /* Paradox: net path or user name missing */
#define JET_errCantAccessParadoxNetDir	-5024 /* Paradox: bad Paradox net path */
#define JET_errObsoleteLockFile 	-5025 /* Paradox: obsolete lock file */
#define JET_errIllegalCollatingSequence -5026 /* Paradox: invalid sort sequence */
#define JET_errWrongCollatingSequence	-5027 /* Paradox: wrong sort sequence */
#define JET_errCantUseUnkeyedTable	-5028 /* Paradox: can't open unkeyed table */

#define JET_errINFFileError		-5101 /* dBase: invalid .INF file */
#define JET_errCantMakeINFFile		-5102 /* dBase: can't open .INF file */
#define JET_wrnCantMaintainIndex	 5103 /* dBase: unmaintainable index */
#define JET_errMissingMemoFile		-5104 /* dBase: missing memo file */
#define JET_errIllegalCenturyOption	-5105 /* dBase: Illegal century option */
#define JET_errIllegalDeletedOption	-5106 /* dBase: Illegal deleted option */
#define JET_errIllegalStatsOption	-5107 /* dBase: Illegal statistics option */
#define JET_errIllegalDateOption	-5108 /* dBase: Illegal date option */
#define JET_errIllegalMarkOption	-5109 /* dBase: Illegal mark option */
#define JET_wrnDuplicateIndexes		 5110 /* dBase: duplicate indexes in INF file */
#define JET_errINFIndexNotFound		-5111 /* dBase: missing index in INF file */
#define JET_errWrongMemoFileType	-5112 /* dBase: wrong memo file type */
#define JET_errIllegalExactOption       -5113 /* dBase: Illegal exact option */

#define JET_errTooManyLongFields	-5200 /* Btrieve: more than one memo field */
#define JET_errCantStartBtrieve 	-5201 /* Btrieve: wbtrcall.dll missing */
#define JET_errBadConfigParameters	-5202 /* Btrieve: win.ini [btrieve] options wrong */
#define JET_errIndexesChanged		-5203 /* Btrieve: need to GetIndexInfo */
#define JET_errNonModifiableKey 	-5204 /* Btrieve: can't modify record column */
#define JET_errOutOfBVResources 	-5205 /* Btrieve: out of resources */
#define JET_errBtrieveDeadlock		-5206 /* Btrieve: locking deadlock */
#define JET_errBtrieveFailure		-5207 /* Btrieve: Btrieve DLL failure */
#define JET_errBtrieveDDCorrupted	-5208 /* Btrieve: data dictionary corrupted */
#define JET_errBtrieveTooManyTasks	-5209 /* Btrieve: too many tasks */
#define JET_errIllegalIndexDDFOption    -5210 /* Btrieve: Illegal IndexDDF option */
#define JET_errIllegalDataCodePage      -5211 /* Btrieve: Illeagl DataCodePage option */
#define JET_errXtrieveEnvironmentError  -5212 /* Btrieve: Xtrieve INI options bad */
#define JET_errMissingDDFFile           -5213 /* Btrieve: Missing field.ddf */
#define JET_errIlleaglIndexNumberOption -5214 /* Btrieve: Illeagl IndexRenumber option */

	/* Extended error codes must be in the following range. */
	/* Major error codes may not be in this range. */

#define JET_errMinorLeast		-8000
#define JET_errMinorMost		-8999

#define JET_errFindExprSyntax		-8001 /* Syntax error in FastFind expression */
#define JET_errQbeExprSyntax		-8002 /* Syntax error in QBE expression */
#define JET_errInputTableNotFound	-8003 /* Non-existant object in FROM list */
#define JET_errQueryExprSyntax		-8004 /* Syntax error in some query expression */
#define JET_errQodefExprSyntax		-8005 /* Syntax error in expression column */
#define JET_errExpAliasAfterAS		-8006 /* Expected alias after 'AS' in FROM list */
#define JET_errExpBYAfterGROUP		-8007 /* Expected 'BY' after 'GROUP' */
#define JET_errExpBYAfterORDER		-8008 /* Expected 'BY' after 'ORDER' */
#define JET_errExpClsParenAfterColList	-8009 /* Expected ')' after column list */
#define JET_errExpColNameAfterPIVOT	-8010 /* Expected column name after 'PIVOT' */
#define JET_errExpDatabaseAfterIN	-8011 /* Expected database name after 'IN' */
#define JET_errExpDatatypeAfterParmName -8012 /* Expected datatype after parameter name */
#define JET_errExpEqualAfterUpdColName	-8013 /* Expected '=' after update column name */
#define JET_errExpExprAfterON		-8014 /* Expected join expression after 'ON' */
#define JET_errExpExprAfterTRANSFORM	-8015 /* Expected expression after 'TRANSFORM' */
#define JET_errExpExprAfterWHERE	-8016 /* Expected expression after 'WHERE' */
#define JET_errExpGroupClauseInXform	-8017 /* Transform expects GROUP BY clause */
#define JET_errExpGroupingExpr		-8018 /* Expected grouping expression */
#define JET_errExpHavingExpr		-8019 /* Expected HAVING expression */
#define JET_errExpINTOAfterINSERT	-8020 /* Expected 'INTO' after 'INSERT' */
#define JET_errExpJOINAfterJoinType	-8021 /* Expected 'JOIN' after INNER/LEFT/RIGHT */
#define JET_errExpLEVELAfterSelectList	-8022 /* Expected LEVEL after select list */
#define JET_errExpNumberAfterLEVEL	-8023 /* Expected number after 'LEVEL' */
#define JET_errExpONAfterRightTable	-8024 /* Expected 'ON' after right join table */
#define JET_errExpOrderExpr		-8025 /* Expected ordering expression */
#define JET_errExpOutputAliasAfterAS	-8026 /* Expected output alias after 'AS' */
#define JET_errExpOutputExpr		-8027 /* Expected output expression */
#define JET_errExpPIVOTAfterSelectStmt	-8028 /* Expected 'PIVOT' after SELECT statement */
#define JET_errExpRightJoinTable	-8029 /* Expected right join table after 'JOIN' */
#define JET_errExpSELECTAfterInsClause	-8030 /* Expected 'SELECT' after INSERT clause */
#define JET_errExpSELECTAfterXformExpr	-8031 /* Expected 'SELECT' after Transform fact */
#define JET_errExpSETAfterTableName	-8032 /* Expected 'SET' after table name */
#define JET_errExpSemiAfterLevelNumber	-8033 /* Expected ';' after level number */
#define JET_errExpSemiAfterParmList	-8034 /* Expected ';' after parmeter list */
#define JET_errExpSemiAfterPivotClause	-8035 /* Expected ';' after PIVOT clause */
#define JET_errExpSemiAtEndOfSQL	-8036 /* Expected ';' at end of SQL statement */
#define JET_errExpTableName		-8037 /* Expected table name */
#define JET_errExpTableNameAfterINTO	-8038 /* Expected table name after 'INTO' */
#define JET_errExpUpdExprAfterEqual	-8039 /* Expected update expression after '=' */
#define JET_errExpUpdateColName 	-8040 /* Expected update column name */
#define JET_errInvTokenAfterFromList	-8041 /* Bogus token after FROM list */
#define JET_errInvTokenAfterGroupList	-8042 /* Bogus token after GROUP BY list */
#define JET_errInvTokenAfterHavingCls	-8043 /* Bogus token after HAVING clause */
#define JET_errInvTokenAfterOrderClause -8044 /* Bogus token after ORDER BY clause */
#define JET_errInvTokenAfterSelectCls	-8045 /* Bogus token after SELECT clause */
#define JET_errInvTokenAfterWhereClause -8046 /* Bogus token after WHERE clause */
#define JET_errLevelNumberTooBig	-8047 /* Number after 'LEVEL' too big */
#define JET_errLevelOnNonMGB		-8048 /* LEVEL allowed only in MGB */
#define JET_errIllegalDetailReference	-8049 /* Not group key or agg, but not MGB detail */
#define JET_errAggOverMixedLevels	-8050 /* Agg. arg. uses outputs from > 1 level */
#define JET_errAggregatingHigherLevel	-8051 /* Agg. over output of same/higher level */
#define JET_errNullInJoinKey		-8052 /* Cannot set column in join key to NULL */
#define JET_errValueBreaksJoin		-8053 /* Join is broken by column value(s) */
#define JET_errInsertIntoUnknownColumn	-8054 /* INSERT INTO unknown column name */
#define JET_errNoSelectIntoColumnName	-8055 /* No dest. col. name in SELECT INTO stmt */
#define JET_errNoInsertColumnName	-8056 /* No dest. col. name in INSERT stmt */
#define JET_errColumnNotInJoinTable	-8057 /* Join expr refers to non-join table */
#define JET_errAggregateInJoin		-8058 /* Aggregate in JOIN clause */
#define JET_errAggregateInWhere 	-8059 /* Aggregate in WHERE clause */
#define JET_errAggregateInOrderBy	-8060 /* Aggregate in ORDER BY clause */
#define JET_errAggregateInGroupBy	-8061 /* Aggregate in GROUP BY clause */
#define JET_errAggregateInArgument	-8062 /* Aggregate in argument expression */
#define JET_errHavingOnTransform	-8063 /* HAVING clause on TRANSFORM query */
#define JET_errHavingWithoutGrouping	-8064 /* HAVING clause w/o grouping/aggregation */
#define JET_errHavingOnMGB		-8065 /* HAVING clause on MGB query */
#define JET_errOutputAliasCycle 	-8066 /* Cycle in SELECT list (via aliases) */
#define JET_errDotStarWithGrouping	-8067 /* 'T.*' with grouping, but not MGB level 0 */
#define JET_errStarWithGrouping 	-8068 /* '*' with grouping, but not MGB detail */
#define JET_errQueryTreeCycle		-8069 /* Cycle in tree of query objects */
#define JET_errTableRepeatInFromList	-8072 /* Table appears twice in FROM list */
#define JET_errTooManyXformLevels	-8073 /* Level > 2 in TRANSFORM query */
#define JET_errTooManyMGBLevels 	-8074 /* Too many levels in MGB */
#define JET_errNoUpdateColumnName	-8075 /* No dest. column name in UPDATE stmt */
#define JET_errJoinTableNotInput	-8076 /* Join table not in FROM list */
#define JET_errUnaliasedSelfJoin	-8077 /* Join tables have same name */
#define JET_errOutputLevelTooBig	-8078 /* Output w/ level > 1+max group level */
#define JET_errOrderVsGroup		-8079 /* ORDER BY conflicts with GROUP BY */
#define JET_errOrderVsDistinct		-8080 /* ORDER BY conflicts with DISTINCT */
#define JET_errExpLeftParenthesis	-8082 /* Expected '(' */
#define JET_errExpRightParenthesis	-8083 /* Expected ')' */
#define JET_errEvalEBESErr		-8084 /* EB/ES error evaluating expression */
#define JET_errQueryExpCloseQuote	-8085 /* Unmatched quote for database name */
#define JET_errQueryParmNotDatabase	-8086 /* Parameter type should be database */
#define JET_errQueryParmNotTableid	-8087 /* Parameter type should be tableid */
#define JET_errExpIdentifierM		-8088 /* Expected identifier */
#define JET_errExpQueryName		-8089 /* Expected query name after PROCEDURE */
#define JET_errExprUnknownFunctionM	-8090 /* Unknown function in expression */
#define JET_errQueryAmbigRefM		-8091 /* Ambiguous column reference */
#define JET_errQueryBadBracketing	-8092 /* Bad bracketing of identifier */
#define JET_errQueryBadQodefName	-8093 /* Invalid name in QODEF row */
#define JET_errQueryBulkColNotUpd	-8094 /* Column not updatable (bulk op) */
#define JET_errQueryDistinctNotAllowedM	-8095 /* DISTINCT not allowed for MGB */
#define JET_errQueryDuplicateAliasM	-8096 /* Duplicate output alias */
#define JET_errQueryDuplicateOutputM	-8097 /* Duplicate destination output */
#define JET_errQueryDuplicatedFixedSetM	-8098 /* Duplicated Fixed Value */
#define JET_errQueryIllegalOuterJoinM	-8099 /* No inconsistent updates on outer joins */
#define JET_errQueryIncompleteRowM	-8100 /* Missing value in row */
#define JET_errQueryInvalidAttributeM	-8101 /* Invalid query attribute */
#define JET_errQueryInvalidBulkInputM	-8102 /* Cannot input from bulk operation */
#define JET_errQueryInvalidFlagM	-8103 /* Invalid value in Flag field */
#define JET_errQueryInvalidMGBInputM	-8104 /* Cannot input from MGB */
#define JET_errQueryLVInAggregate	-8105 /* Illegal long value in aggregate */
#define JET_errQueryLVInDistinct	-8106 /* Illegal long value in DISTINCT */
#define JET_errQueryLVInGroupBy		-8107 /* Illegal long value in GROUP BY */
#define JET_errQueryLVInHaving		-8108 /* Illegal long value in HAVING */
#define JET_errQueryLVInJoin		-8109 /* Illegal long value in JOIN */
#define JET_errQueryLVInOrderBy		-8110 /* Illegal long value in ORDER BY */
#define JET_errQueryMissingLevelM	-8111 /* Missing intermediate MGB level */
#define JET_errQueryMissingParmsM	-8112 /* Too few parameters supplied */
#define JET_errQueryNoDbForParmDestTblM	-8113 /* Dest DB for VT parm not allowed */
#define JET_errQueryNoDeletePerm	-8114 /* No delete permission on table/query */
#define JET_errQueryNoInputTablesM	-8115 /* Query must have an input */
#define JET_errQueryNoInsertPerm	-8116 /* No insert permission on table/query */
#define JET_errQueryNoOutputsM		-8117 /* Query must have an output */
#define JET_errQueryNoReadDefPerm	-8118 /* No permission to read query definition */
#define JET_errQueryNoReadPerm		-8119 /* No read permission on table/query */
#define JET_errQueryNoReplacePerm	-8120 /* No replace permission on table/query */
#define JET_errQueryNoTblCrtPerm	-8121 /* No CreateTable permission (bulk op) */
#define JET_errQueryNotDirectChildM	-8122 /* T.* must use direct child */
#define JET_errQueryNullRequiredM	-8123 /* Column must be NULL */
#define JET_errQueryOnlyOneRowM		-8124 /* Only 1 such row allowed */
#define JET_errQueryOutputColNotUpd	-8125 /* Query output column not updatable */
#define JET_errQueryParmRedefM		-8126 /* Parm redefined with different type */
#define JET_errQueryParmTypeMismatchM	-8127 /* Wrong parameter type given */
#define JET_errQueryUnboundRefM		-8128 /* Cannot bind name */
#define JET_errRmtConnectFailedM	-8129 /* RMT: Connection attempt failed */
#define JET_errRmtDeleteFailedM		-8130 /* RMT: Delete statement failed */
#define JET_errRmtInsertFailedM		-8131 /* RMT: Insert statement failed */
#define JET_errRmtMissingOdbcDllM	-8132 /* RMT: Can't load ODBC DLL */
#define JET_errRmtSqlErrorM		-8133 /* RMT: ODBC call failed */
#define JET_errRmtUpdateFailedM		-8134 /* RMT: Update statement failed */
#define JET_errSQLDeleteSyntaxM		-8135 /* Expected 'FROM' after 'DELETE' */
#define JET_errSQLSyntaxM		-8136 /* Bogus SQL statement type */
#define JET_errSQLTooManyTokensM	-8137 /* Characters after end of SQL statement */
#define JET_errStarNotAtLevel0		-8138 /* '*' illegal above level 0 */
#define JET_errQueryParmTypeNotAllowed	-8139 /* Parameter type not allowed for expression */
#define JET_errQueryTooManyDestColumn	-8142 /* Too many destination column sepcified */
#define JET_errSQLNoInsertColumnName	-8143 /* No dest. col. name in INSERT stmt */
#define JET_errRmtLinkNotFound		-8144 /* RMT: link not found */
#define JET_errRmtTooManyColumns	-8145 /* RMT: Too many columns on Select Into */
#define JET_errWriteConflictM		-8146 /* Write lock failed due to outstanding write lock */
#define JET_errReadConflictM		-8147 /* Commit lock failed due to outstanding read lock */
#define JET_errCommitConflictM		-8148 /* Read lock failed due to outstanding commit lock */
#define JET_errTableLockedM		-8149 /* Table is exclusively locked */
#define JET_errTableInUseM		-8150 /* Table is in use, cannot lock */
#define JET_errQueryTooManyXvtColumn	-8151 /* Too many cross table column headers */
#define JET_errOutputTableNotFound	-8152 /* Non-existent table in Insert Into */
#define JET_errTableLockedQM		-8153 /* Table is exclusively locked */
#define JET_errTableInUseQM		-8154 /* Table is in use, cannot lock */
#define JET_errTableLockedMUQM		-8155 /* Table is exclusively locked */
#define JET_errTableInUseMUQM		-8156 /* Table is in use, cannot lock */
#define JET_errQueryInvalidParmM	-8157 /* Invalid Parmeter Name (>64 char) */
#define JET_errFileNotFoundM		-8158 /* File not found */
#define JET_errFileShareViolationM	-8159 /* File sharing violation */
#define JET_errFileAccessDeniedM	-8160 /* Access denied */
#define JET_errInvalidPathM		-8161 /* Invalid Path */
#define JET_errTableDuplicateM		-8162 /* Table already exists */
#define JET_errQueryBadUpwardRefedM	-8163 /* Illegally Upward ref'ed */
#define JET_errIntegrityViolMasterM	-8164 /* References to key exist */
#define JET_errIntegrityViolSlaveM	-8165 /* No referenced key exists */
#define JET_errSQLUnexpectedWithM	-8166 /* Unexpected 'with' in this place */
#define JET_errSQLOwnerAccessM		-8167 /* Owner Access Option is defined Twice */
#define	JET_errSQLOwnerAccessSyntaxM 	-8168 /* Owner Access Option Syntax Error */
#define	JET_errSQLOwnerAccessDef 	-8169 /* Owner Access Option is defined more than once */
#define JET_errAccessDeniedM     	-8170 /* Generic Access Denied */
#define JET_errUnexpectedEngineReturnM	-8171 /* I-ISAM: unexpected engine error code */
#define JET_errQueryTopNotAllowedM	-8172 /* Top not allowed for MGB */
#define JET_errInvTokenAfterTableCls -8173 /* Bogus token after table clause */
#define JET_errInvTokenAfterRParen  -8174 /* Unexpected tokens after a closing paren */
#define JET_errQueryBadValueListM	-8175 /* Malformed value list in Transform */
#define JET_errQueryIsCorruptM		-8176 /* Query is Corrupt */
#define	JET_errInvalidTopArgumentM	-8177 /* Select Top argument is invalid */
#define JET_errQueryIsSnapshot		-8178 /* Query is a snapshot */
#define JET_errQueryExprOutput		-8179 /* Output is a calculated column */
#define JET_errQueryTableRO		-8180 /* Column comes from read-only table */
#define JET_errQueryRowDeleted		-8181 /* Column comes from deleted row */
#define JET_errQueryRowLocked		-8182 /* Column comes from locked row */
#define JET_errQueryFixupChanged	-8183 /* Would row-fixup away from pending changes */
#define JET_errQueryCantFillIn		-8184 /* Fill-in-the-blank only on most-many */
#define JET_errQueryWouldOrphan		-8185 /* Would orphan joined records */
#define JET_errIncorrectJoinKeyM	-8186 /* Must match join key in lookup table */
#define JET_errQueryLVInSubqueryM	-8187 /* Illegal long value in subquery */
#define JET_errInvalidDatabaseM		-8188 /* Unrecognized database format */
#define JET_errOrderVsUnion 		-8189 /* You can only order by an outputted column in a union */
#define JET_errTLVCouldNotBindRef 	-8190 /* Unknown token in TLV expression */
#define JET_errCouldNotBindRef		-8191 /* Unknown token in FastFind expression */
#define JET_errQueryPKeyNotOutput	-8192 /* Primary key not output */
#define JET_errQueryJKeyNotOutput	-8193 /* Join key not output */
#define JET_errExclusiveDBConflict	-8194 /* Conflict with exclusive user */
#define JET_errQueryNoJoinedRecord	-8195 /* No F.I.T.B. insert if no joined record */
#define JET_errQueryLVInSetOp		-8196 /* Illegal long value in set operation */
#define JET_errTLVExprUnknownFunctionM	-8197 /* Unknown function in TLV expression */
#define JET_errInvalidNameM		-8198 /* Invalid name */

#define JET_errDDLExpColName		-8200 /* expect column name */
#define JET_errDDLExpLP			-8201 /* expect '(' */
#define JET_errDDLExpRP			-8202 /* expect ')' */
#define JET_errDDLExpIndex		-8203 /* expect INDEX */
#define JET_errDDLExpIndexName		-8204 /* expect index name */
#define JET_errDDLExpOn			-8205 /* expect ON */
#define JET_errDDLExpKey		-8206 /* expect KEY */
#define JET_errDDLExpReferences		-8207 /* expect REFERENCES */
#define JET_errDDLExpTableName		-8208 /* expect table name */
#define JET_errDDLExpFullOrPartial	-8209 /* expect FULL or PARTIAL */
#define JET_errDDLExpCascadeOrSet	-8210 /* expect CASCADE or SET */
#define JET_errDDLExpNull		-8211 /* expect NULL */
#define JET_errDDLExpUpdateOrDelete	-8212 /* expect UPDATE or DELETE */
#define JET_errDDLExpConstraintName	-8213 /* expect constraint name */
#define JET_errDDLExpForeign		-8214 /* expect FOREIGN */
#define JET_errDDLExpDatatype		-8215 /* expect data type */
#define JET_errDDLExpIndexOpt		-8216 /* expect index options */
#define JET_errDDLExpWith		-8217 /* expect WITH */
#define JET_errDDLExpTable		-8218 /* expect TABLE */
#define JET_errDDLExpEos		-8219 /* expect End Of String */
#define JET_errDDLExpAddOrDrop		-8220 /* expect ADD or Drop */
#define JET_errDDLCreateView		-8221 /* Create view not supported */
#define JET_errDDLCreateProc		-8222 /* Create proc not supported */
#define JET_errDDLExpObjectName		-8223 /* expect object name */
#define JET_errDDLExpColumn		-8224 /* expect COLUMN */

#define	JET_errV11TableNameNotInScope 	-8250 /* referenced table not in join clause */
#define JET_errV11OnlyTwoTables		-8251 /* exactly two tables should be referenced in join */
#define JET_errV11OneSided		-8252 /* all tables come from one side of input */
#define JET_errV11Ambiguous		-8253 /* Join clause is ambiguous when stored in V1 format */

#define JET_errTLVExprSyntaxM		-8260 /* Syntax error in TLV expression */
#define JET_errTLVNoNullM			-8261 /* This field cannot be null */
#define JET_errTLVNoBlankM			-8262 /* This column cannot be blank */
#define	JET_errTLVRuleViolationM 	-8263 /* This validation rule must be met */
#define JET_errDDLCreateViewSyntaxM	-8264 /* create view syntax error */

/***********************
 The following error code ranges are reserved for external use.
 As is true for Jet error codes, these ranges cover the negative
 as well as positive form of the numbers in the range.

 30000 through 30999 for use by Vt Object as defined in jeteb.h
 32000 through 32767 for use by Import/Export as defined in jetutil.h

 ***********************/



/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

/****************************************************************************

	ISAM API

*****************************************************************************/

JET_ERR JET_API JetInit(JET_INSTANCE _far *pinstance);

JET_ERR JET_API JetTerm(JET_INSTANCE instance);

JET_ERR JET_API JetSetSystemParameter(JET_INSTANCE _far *pinstance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char _far *sz);

JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR _far *plParam, char _far *sz, unsigned long cbMax);

JET_ERR JET_API JetGetLastErrorInfo(JET_SESID sesid,
	JET_EXTERR _far *pexterr, unsigned long cbexterrMax,
	char _far *sz1, unsigned long cch1Max,
	char _far *sz2, unsigned long cch2Max,
	char _far *sz3, unsigned long cch3Max,
	unsigned long _far *pcch3Actual);

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID _far *psesid,
	const char _far *szUserName, const char _far *szPassword);

JET_ERR JET_API JetDupSession(JET_SESID sesid, JET_SESID _far *psesid);

JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long _far *pwVersion);

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetCapability(JET_SESID sesid, JET_DBID dbid,
	unsigned long lArea, unsigned long lFunction, JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
	const char _far *szFilename, const char _far *szConnect,
	JET_DBID _far *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char _far *szFilename, JET_GRBIT grbit );

JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char _far *szFilename);

JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, unsigned long lPages, unsigned long lDensity,
	JET_TABLEID _far *ptableid);

JET_ERR JET_API JetRenameTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szTableNew);

JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName);

JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumnName, void _far *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szColumnName,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn, const JET_COLUMNDEF _far *pcolumndef,
	const void _far *pvDefault, unsigned long cbDefault,
	JET_COLUMNID _far *pcolumnid);

JET_ERR JET_API JetRenameColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn, const char _far *szColumnNew);

JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn);

JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName, void _far *pvResult, unsigned long cbResult,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetTableReferenceInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName, void _far *pvResult,
	unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szIndexName,
	void _far *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetGetReferenceInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szReference,
	void _far *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName, JET_GRBIT grbit,
	const char _far *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API JetRenameIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndex, const char _far *szIndexNew);

JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName);

JET_ERR JET_API JetCreateReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName, const char _far *szColumns,
	const char _far *szReferencedTable,
	const char _far *szReferencedColumns, JET_GRBIT grbit);

JET_ERR JET_API JetRenameReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReference, const char _far *szReferenceNew);

JET_ERR JET_API JetDeleteReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName);

JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char _far *szContainerName,
	const char _far *szObjectName, void _far *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetCreateObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	JET_OBJTYP objtyp);

JET_ERR JET_API JetDeleteObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName);

JET_ERR JET_API JetRenameObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szObjectNew);

JET_ERR JET_API JetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetUpdateUserFunctions(JET_SESID sesid);

JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetCloseDatabase(JET_SESID sesid, JET_DBID dbid,
	JET_GRBIT grbit);

JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char _far *szFilename,
	const char _far *szConnect, JET_DBID _far *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetOpenTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const void _far *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void _far *pvData, unsigned long cbData,
	unsigned long _far *pcbActual, JET_GRBIT grbit, JET_RETINFO _far *pretinfo);

JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn );

JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void _far *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO _far *psetinfo);

JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn );

JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep);

JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS _far *precpos, unsigned long cbRecpos);

JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos );

JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID _far *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char _far *szIndexName, unsigned long cchIndexName);

JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName);

JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit);

JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void _far *pvData, unsigned long cbData, JET_GRBIT grbit);

JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit);

JET_ERR JET_API JetFastFind(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szExpr, JET_GRBIT grbit,
	signed long _far *pcrow);

JET_ERR JET_API JetFastFindBegin(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szExpr, JET_GRBIT grbit);

JET_ERR JET_API JetFastFindEnd(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbMax,
	unsigned long _far *pcbActual);
	
JET_ERR JET_API JetRefreshLink(JET_SESID sesid, JET_DBID dbid,
	const char _far *szLinkName, const char _far *szConnect,
	const char _far *szDatabase);

#ifdef	_MSC_VER		       /* CONSIDER: CSL doesn't like this */

JET_ERR JET_API JetRepairDatabase(JET_SESID sesid, const char _far *lszDbFile,
	JET_PFNSTATUS pfnstatus);

#endif	/* _MSC_VER */

JET_ERR JET_API JetCompact(JET_SESID sesid, const char _far *szDatabaseSrc,
	const char _far *szConnectSrc, const char _far *szDatabaseDest,
	const char _far *szConnectDest, JET_PFNSTATUS pfnStatus,
	JET_GRBIT grbit);

JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark);

JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetCreateRelationship(JET_SESID sesid,JET_DBID dbidIn,
	const char _far *szRelationshipName, const char _far *szObjectName,
	const char _far *szColumns, const char _far *szReferencedObject,
	const char _far *szReferncedColumns, char _far *szLongName,
	unsigned long cbMax, unsigned long _far *pcbActual, JET_GRBIT grbit);

JET_ERR JET_API JetDeleteRelationship(JET_SESID sesid, JET_DBID dbidIn,
	const char _far *szName);

JET_ERR JET_API JetGetRelationshipInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szRelationship,
	void _far *pvResult, unsigned long cbResult);

/*****************************************************************************

	SEC API

*****************************************************************************/

JET_ERR JET_API JetGetSidFromName(JET_SESID sesid, const char _far *szName,
	void _far *pvSid, unsigned long cbMax, unsigned long _far *pcbActual,
	long _far *pfGroup);

JET_ERR JET_API JetGetNameFromSid(JET_SESID sesid,
	const void _far *pvSid, unsigned long cbSid,
	char _far *szName, unsigned long cchName, long _far *pfGroup);

JET_ERR JET_API JetCreateUser(JET_SESID sesid, const char _far *szUser,
	const char _far *szPassword, const char _far *szPin);

JET_ERR JET_API JetChangeUserPassword(JET_SESID sesid,
	const char _far *szUser, const char _far *szOldPassword,
	const char _far *szNewPassword);

JET_ERR JET_API JetDeleteUser(JET_SESID sesid, const char _far *szUser);

JET_ERR JET_API JetCreateGroup(JET_SESID sesid, const char _far *szGroup,
	const char _far *szPin);

JET_ERR JET_API JetAddMember(JET_SESID sesid,
	const char _far *szGroup, const char _far *szUser);

JET_ERR JET_API JetRemoveMember(JET_SESID sesid,
	const char _far *szGroup, const char _far *szUser);

JET_ERR JET_API JetDeleteGroup(JET_SESID sesid, const char _far *szGroup);

JET_ERR JET_API JetSetAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName, JET_ACM acm, JET_GRBIT grbit);

JET_ERR JET_API JetGetAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName, long fIndividual,
	JET_ACM _far *pacm, JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetValidateAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	JET_ACM acmRequired);

JET_ERR JET_API JetSetOwner(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName);

JET_ERR JET_API JetGetOwner(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	char _far *szName, unsigned long cchMax);

/*****************************************************************************

	Property Management API

*****************************************************************************/
JET_ERR JET_API JetSetProperty(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, JET_COLTYP coltyp,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveProperty(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, unsigned long _far *pcbActual,
	JET_COLTYP _far *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel);

JET_ERR JET_API JetSetTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, JET_COLTYP coltyp,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, unsigned long _far *pcbActual,
	JET_COLTYP _far *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel);

/*****************************************************************************

	LINK API

*****************************************************************************/

JET_ERR JET_API JetCreateLink(JET_SESID sesid, JET_DBID dbid,
	const char _far *szLink, JET_DBID dbidFrom, const char _far *szFrom,
	JET_GRBIT grbit);

JET_ERR JET_API JetExecuteSql(JET_SESID sesid, JET_DBID dbid,
	const char _far *szSql);

/***************************************************************************

	Query API

*****************************************************************************/

JET_ERR JET_API JetOpenVtQbe(JET_SESID sesid, const char _far *szExpn,
	long _far *plCols, JET_TABLEID _far *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetCreateQuery(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetOpenQueryDef(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, JET_TABLEID _far *ptableid);

/* CONSIDER: Is rgchSql a zero-terminated string?  Maybe it should be for
 *		   consistency.
 */

JET_ERR JET_API JetSetQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char _far *rgchSql, unsigned long cchSql, const char _far *szConnect,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char _far *rgchSql, unsigned long cchMax,
	unsigned long _far *pcchActual, void _far *pvConnect,
	unsigned long cbConnectMax, unsigned long _far *pcbConnectActual,
	JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetCopyQuery(JET_SESID sesid, JET_TABLEID tableidSrc,
	JET_DBID dbidDest, const char _far *szQueryDest,
	JET_TABLEID _far *ptableidDest);

JET_ERR JET_API JetOpenSVT(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, const void _far *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void _far *pmgblist, unsigned long cbMax, unsigned long _far *pcbActual);

JET_ERR JET_API JetGetQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, void _far *pvResult, unsigned long cbMax,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetRestartQuery(JET_SESID sesid, JET_TABLEID tableid,
	const void _far *pvParameters, unsigned long cbParameters);

JET_ERR JET_API JetSetFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark, unsigned long crowSize);

JET_ERR JET_API JetFillFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark, unsigned long crow,
	unsigned long _far *pcrow, JET_GRBIT grbit);

JET_ERR JET_API JetExecuteTempQuery(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void _far *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetExecuteTempSVT(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void _far *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void _far *pmgblist, unsigned long cbMax, unsigned long _far *pcbActual);

JET_ERR JET_API JetGetTempQueryColumnInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szColumnName,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetTempQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, void _far *pvResult, unsigned long cbMax,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetValidateData(JET_SESID sesid, JET_TABLEID tableidBase,
		JET_TABLEID _far *ptableid );

/***************************************************************************

	API for Installable ISAMs

****************************************************************************/

typedef ULONG_PTR JET_VSESID;         /* Received from dispatcher */

struct tagVDBFNDEF;

typedef ULONG_PTR JET_VDBID;          /* Received from dispatcher */

JET_ERR JET_API JetAllocateDbid(JET_SESID sesid, JET_DBID _far *pdbid, JET_VDBID vdbid, const struct tagVDBFNDEF _far *pvdbfndef, JET_VSESID vsesid);

JET_ERR JET_API JetUpdateDbid(JET_SESID sesid, JET_DBID dbid, JET_VDBID vdbid, const struct tagVDBFNDEF _far *pvdbfndef);

JET_ERR JET_API JetReleaseDbid(JET_SESID sesid, JET_DBID dbid);

struct tagVTFNDEF;

typedef ULONG_PTR JET_VTID;            /* Received from dispatcher */

JET_ERR JET_API JetAllocateTableid(JET_SESID sesid, JET_TABLEID _far *ptableid, JET_VTID vtid, const struct tagVTFNDEF _far *pvtfndef, JET_VSESID vsesid);

JET_ERR JET_API JetUpdateTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID vtid, const struct tagVTFNDEF _far *pvtfndef);

JET_ERR JET_API JetReleaseTableid(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF _far *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID _far *ptableid,
	JET_COLUMNID _far *prgcolumnid);


/***************************************************************************

	MISC JET API

****************************************************************************/

JET_ERR JET_API JetStringCompare(char _far *pb1, unsigned long cb1,
	char _far *pb2, unsigned long cb2, unsigned long sort,
	long _far *plResult);

/***************************************************************************

	ADDITIONAL JET BLUE API

****************************************************************************/
JET_ERR JET_API JetBackup( const char _far *szBackupPath, JET_GRBIT grbit );
JET_ERR JET_API JetRestore(const char _far *sz, int crstmap, JET_RSTMAP *rgrstmap, JET_PFNSTATUS pfn );
JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);
JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long _far *pcrec, unsigned long crecMax );
JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void _far *pvData, unsigned long cbMax,
	unsigned long _far *pcbActual, JET_GRBIT grbit );

#ifdef JETSER
JET_ERR JET_API JetGetChecksum( JET_SESID sesid,
	JET_TABLEID tableid, unsigned long _far *pulChecksum );
JET_ERR JET_API JetGetObjidFromName(JET_SESID sesid,
	JET_DBID dbid, const char _far *szContainerName,
	const char _far *szObjectName,
	unsigned long _far *pulObjectId );
#endif

#endif	/* _JET_NOPROTOTYPES */

#undef	_far

#pragma pack()

#ifdef	__cplusplus
}
#endif


#endif	/* _JET_INCLUDED */

#endif  __JET500
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\jet500.h ===
#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#if defined(_M_ALPHA)
#pragma pack(8)
#else
#pragma pack(4)
#endif

#define JET_API     __stdcall
#define JET_NODSAPI __stdcall

typedef long JET_ERR;

typedef unsigned long JET_INSTANCE;	/* Instance Identifier */
typedef ULONG_PTR JET_SESID;        /* Session Identifier */
typedef ULONG_PTR JET_TABLEID;  	/* Table Identifier */
typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef ULONG_PTR JET_DBID;        	/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;  	/* Group of Bits */
typedef unsigned long JET_ACM;		/* Access Mask */
typedef unsigned long JET_RNT;		/* Repair Notification Type */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */
typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */
typedef unsigned long JET_HANDLE;	/* backup file handle */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv);

typedef struct tagCONVERT
	{
	char			*szOldDll;
	char			*szOldSysDb;
	unsigned long	fDbAttached;		// Return value indicating if Db was attached
	} JET_CONVERT;


typedef enum
	{
	opDBUTILConsistency,
	opDBUTILDumpData,
	opDBUTILDumpMetaData,
	opDBUTILDumpSpace,
	opDBUTILSetHeaderState,
	opDBUTILDumpHeader,
	opDBUTILDumpLogfile,
	opDBUTILDumpCheckpoint
	} DBUTIL_OP;

typedef struct tagDBUTIL
	{
	unsigned long	cbStruct;
	char			*szDatabase;
	char			*szTable;
	char			*szIndex;
	DBUTIL_OP		op;
	JET_GRBIT		grbitOptions;
	} JET_DBUTIL;	

#define JET_bitDBUtilOptionAllNodes				0x00000001
#define JET_bitDBUtilOptionKeyStats				0x00000002
#define JET_bitDBUtilOptionPageDump				0x00000004
#define JET_bitDBUtilOptionDumpVerbose			0x10000000	// DEBUG only
#define JET_bitDBUtilOptionCheckBTree			0x20000000	// DEBUG only


	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty	 					 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* JetGetLastErrorInfo structure */

typedef struct
	{
	unsigned long	cbStruct;		/* Size of this structure */
	JET_ERR 	   	err;			/* Extended error code (if any) */
	unsigned long	ul1;			/* First general purpose integer */
	unsigned long	ul2;			/* Second general purpose integer */
	unsigned long	ul3;			/* Third general purpose integer */
	} JET_EXTERR;

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

	/* ErrCount Notification Structures */

typedef struct						/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cRecUniqueKeyViolation;
	unsigned long	cRecTypeConversionFail;
	unsigned long	cRecRecordLocked;
	unsigned long	cRecTotal;	/* Total number of units of work */
	} JET_SNERRCNT;


typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC  		snc;	  	/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char	 		sz[256];  	/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long		cbStruct;
	JET_OBJTYP			objtyp;
	JET_DATESERIAL		dtCreate;
	JET_DATESERIAL		dtUpdate;
	JET_GRBIT			grbit;
	unsigned long		flags;
	unsigned long		cRecord;
	unsigned long		cPage;
	} JET_OBJECTINFO;


/*	required for Exchange to make RSTMAP RPC capable
/**/
#ifdef	MIDL_PASS
#define	xRPC_STRING [string]
#else
#define	xRPC_STRING
typedef unsigned short WCHAR;
#endif

typedef struct
	{
	xRPC_STRING char		*szDatabaseName;
	xRPC_STRING char		*szNewDatabaseName;
	} JET_RSTMAP;			/* restore map */

/*	required for Exchange unicode support
/**/
#define	UNICODE_RSTMAP

typedef struct tagJET_RSTMAPW {
	xRPC_STRING WCHAR *wszDatabaseName;
	
	xRPC_STRING WCHAR *wszNewDatabaseName;
	} JET_RSTMAPW, *PJET_RSTMAPW;

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableInfoRestartable	0x00000008
#define JET_bitTableInfoNoInserts	0x00000010

	/* The following flags occur in the flags field above */

#define JET_bitSaveUIDnPWD		0x20000000	/* this bit is only 		 */
											/* appropriate for rmt links */
#define JET_bitObjectExclusive	0x40000000	/* Open link exclusively */
#define JET_bitObjectSystem		0x80000000


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;
	JET_COLUMNID	columniddtUpdate;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidSid;
	JET_COLUMNID	columnidACM;
	JET_COLUMNID	columnidgrbit; /* grbit from JetSetAccess */
	} JET_OBJECTACMLIST;

#define cObjectAcmCols 3


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	char			szBaseTableName[256];
	char			szBaseColumnName[256];
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	} JET_INDEXLIST;



typedef struct tag_JET_COLUMNCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szColumnName;			// column name
	JET_COLTYP		coltyp;					// column type
	unsigned long	cbMax;					// the maximum length of this column (only relevant for binary and text columns)
	JET_GRBIT		grbit;					// column options
	void			*pvDefault;				// default value (NULL if none)
	unsigned long	cbDefault;				// length of default value
	unsigned long	cp;						// code page (for text columns only)
	JET_COLUMNID	columnid;				// returned column id
	JET_ERR			err;					// returned error code
	} JET_COLUMNCREATE;


typedef struct tagJET_INDEXCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szIndexName;			// index name
	char			*szKey;					// index key
	unsigned long	cbKey;					// length of key
	JET_GRBIT		grbit;					// index options
	unsigned long	ulDensity;				// index density
	JET_ERR			err;					// returned error code
	} JET_INDEXCREATE;


typedef struct tagJET_TABLECREATE
	{
	unsigned long		cbStruct;				// size of this structure (for future expansion)
	char				*szTableName;			// name of table to create.
	unsigned long		ulPages;				// initial pages to allocate for table.
	unsigned long		ulDensity;				// table density.
	JET_COLUMNCREATE	*rgcolumncreate;		// array of column creation info
	unsigned long		cColumns;				// number of columns to create
	JET_INDEXCREATE		*rgindexcreate;			// array of index creation info
	unsigned long		cIndexes;				// number of indexes to create
	JET_GRBIT			grbit;					// Abort column/index creation on error?
	JET_TABLEID			tableid;				// returned tableid.
	unsigned long		cCreated;				// count of objects created (columns+table+indexes).
	} JET_TABLECREATE;


#define cIndexInfoCols 15

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidReferenceName;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidReferencingTableName;
	JET_COLUMNID	columnidReferencingColumnName;
	JET_COLUMNID	columnidReferencedTableName;
	JET_COLUMNID	columnidReferencedColumnName;
	} JET_RELATIONSHIPLIST;

/* for backward compatibility */
typedef JET_RELATIONSHIPLIST JET_REFERENCELIST;

#define cReferenceInfoCols 8

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	unsigned long	cpgCompactFreed;
	} JET_OLCSTAT;

typedef struct
	{
	unsigned long	ctableid;
	JET_TABLEID		rgtableid[1];
	} JET_MGBLIST;

/*** Property Manager Structure ***/
typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID 	tableid;
	JET_COLUMNID 	columnidColumnName;
	JET_COLUMNID 	columnidPropertyName;
	JET_COLUMNID	columnidGrbit;
	JET_COLUMNID	columnidPropertyValue;
	JET_COLUMNID	columnidColtyp;
	} JET_PROPERTYLIST;


/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define JET_tableidNil			((JET_TABLEID) 	0xFFFFFFFF)

#define	JET_sesidNil			((JET_SESID) 	0xFFFFFFFF)

	/* Max size of a bookmark */

#define JET_cbBookmarkMost		4

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost			64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost		255

	/* Max size of long-value column chunk */

#define JET_cbColumnLVChunkMost		4035

	/* Max size of non-long-value column data */

#define JET_cbColumnMost		255

	/* Max size of a sort/index key */

#define JET_cbKeyMost			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost			12

	/* Max number of columns in a table/query */

#define JET_ccolTableMost		255

	/* Max Length of a property in the property manager */
#define JET_cbPropertyMost 2048

	/* Largest initial substring of a long value used in an expression */

#define JET_cbExprLVMost		0x8000L	/*** 32 K ***/

	/* Max size of returned (from SQLDriverConnect) conn string */

#define JET_cbConnectMost		255

	/* Max number of levels in an MGB */

#define JET_wGroupLevelMax		12

	/* Size restrictions for Pins */
#define JET_cchPINMax			20
#define JET_cchPINMin			4

	/* System parameter codes for JetSetSystemParameter */

/* not supported */
#define JET_paramPfnStatus				2	/* Status callback function */
#define JET_paramPfnError				3	/* Error callback function */
#define JET_paramHwndODBC				4	/* Window handle for ODBC use */
#define JET_paramIniPath				5	/* Path to the ini file */
#define JET_paramPageTimeout			6	/* Red ISAM page timeout value */
#define JET_paramODBCQueryTimeout		7	/* ODBC async query timeout value */
#define JET_paramODBCLoginTimeout		25	/* ODBC connection attempt timeout value */
#define JET_paramExprObject				26  /* Expression Evaluation callback */
#define JET_paramGetTypeComp			27	/* Expression Evaluation callback */
#define JET_paramHostVersion			28	/* Host Version callback */
#define JET_paramSQLTraceMode			29	/* Enable/disable SQL tracing */
#define JET_paramEventId				46	/* NT event id */
#define JET_paramEventCategory			47	/* NT event category */
#define JET_paramRmtXactIsolation		39	/* Do not share connections with other sessions */
#define JET_paramJetInternal			35	/* Whether internal to JET; if set, allows ISAM to do things which are prevented in general */
#define JET_paramFullQJet				38	/* Allow full QJet functionality */

#define JET_paramLogFlushThreshold		18	/* log buffer flush threshold in 512 bytes [10] */
#define JET_paramLogFlushPeriod			22	/* log flush period in miliseconds [45] */

#define JET_paramOnLineCompact			37	/*	Options for compact pages on-line */
#define JET_paramRecovery				30	/* Switch for log on/off */

/* debug only not supported */
#define JET_paramTransactionLevel		32	/* Transaction level of session */
#define JET_paramAssertAction			44	/*	debug only determines action on assert */
#define	JET_paramPrintFunction			49	/* debug only. synched print function */
#define JET_paramRFS2IOsPermitted		54  /* # IOs permitted to succeed (-1 = all) */
#define JET_paramRFS2AllocsPermitted	55  /* # allocs permitted to success (-1 = all) */

/*	fully supported parameters */
/*	Note that one page = 4kBytes.
/**/
#define JET_paramSysDbPath				0	/* path to the system database (defunct) ["<base name>.<base ext>"] */
#define JET_paramSystemPath				0	/* path to check point file ["."] */
#define JET_paramTempPath				1	/* path to the temporary database ["."] */
#define JET_paramMaxBuffers				8	/* maximum page cache size in pages [512] */
#define JET_paramMaxSessions			9	/* maximum number of sessions [128] */
#define JET_paramMaxOpenTables			10	/* maximum number of open tables [300] */
#define JET_paramPreferredMaxOpenTables 	59	/* prefered maximum number of open tables [300] */
#define JET_paramMaxVerPages			11	/* maximum version store size in 16KB buckets [64] */
#define JET_paramMaxCursors				12	/* maximum number of open cursors [1024] */
#define JET_paramLogFilePath			13	/* path to the log file directory ["."] */
#define JET_paramMaxOpenTableIndexes 	14	/* maximum open table indexes [300] */
#define JET_paramMaxTemporaryTables		15	/* maximum concurrent JetCreateIndex [20] */
#define JET_paramLogBuffers				16	/* maximum log buffers in 512 bytes [21] */
#define JET_paramLogFileSize			17	/* maximum log file size in kBytes [5120] */
#define JET_paramBfThrshldLowPrcnt		19	/* low percentage clean buffer flush start [20] */
#define JET_paramBfThrshldHighPrcnt		20	/* high percentage clean buffer flush stop [80] */
#define JET_paramWaitLogFlush			21	/* log flush wait time in milliseconds [15] */
#define JET_paramLogCheckpointPeriod	23	/* checkpoint period in 512 bytes [1024] */
#define JET_paramLogWaitingUserMax		24	/* maximum sessions waiting log flush [3] */
#define JET_paramSessionInfo			33	/* per session information [0] */
#define JET_paramPageFragment			34	/* maximum disk extent considered fragment in pages [8] */
#define JET_paramMaxOpenDatabases		36	/* maximum number of open databases [100] */
#define JET_paramBufBatchIOMax			41	/* maximum batch IO in pages [64] */
#define JET_paramPageReadAheadMax		42	/* maximum read-ahead IO in pages [20] */
#define JET_paramAsynchIOMax			43	/* maximum asynchronous IO in pages [64] */
#define JET_paramEventSource			45	/* language independant process descriptor string [""] */
#define JET_paramDbExtensionSize		48	/* database extension size in pages [16] */
#define JET_paramCommitDefault			50	/* default grbit for JetCommitTransaction [0] */
#define	JET_paramBufLogGenAgeThreshold	51	/* age threshold in log files [2] */
#define	JET_paramCircularLog			52	/* boolean flag for circular logging [0] */
#define JET_paramPageTempDBMin			53  /* minimum size temporary database in pages [0] */
#define JET_paramBaseName				56  /* base name for all DBMS object names ["edb"] */
#define JET_paramBaseExtension	  		57  /* base extension for all DBMS object names ["edb"] */
#define JET_paramTableClassName			58  /* table stats class name (class #, string) */

	/* Flags for JetTerm2 */

#define JET_bitTermComplete				0x00000001
#define JET_bitTermAbrupt				0x00000002

	/* Flags for JetIdle */

#define JET_bitIdleRemoveReadLocks		0x00000001
#define JET_bitIdleFlushBuffers			0x00000002
#define JET_bitIdleCompact				0x00000004
#define JET_bitIdleStatus				0x80000000

	/* Flags for JetEndSession */
								   	
#define JET_bitForceSessionClosed		0x00000001

	/* Flags for JetOpenDatabase */

#define JET_bitDbReadOnly				0x00000001
#define JET_bitDbExclusive				0x00000002 /* multiple opens allowed */
#define JET_bitDbRemoteSilent			0x00000004
#define JET_bitDbSingleExclusive		0x00000008 /* opened exactly once */

	/* Flags for JetCloseDatabase */
										
#define JET_bitDbForceClose				0x00000001
							   	
	/* Flags for JetCreateDatabase */

#define JET_bitDbVersion10				0x00000002 /* INTERNAL USE ONLY */
#define JET_bitDbVersion1x				0x00000004
#define JET_bitDbRecoveryOff 			0x00000008 /* disable logging/recovery for this database */
#define JET_bitDbNoLogging	 			JET_bitDbRecoveryOff
#define JET_bitDbCompleteConnstr		0x00000020
#define JET_bitDbVersioningOff			0x00000040

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitBackupAtomic				0x00000004

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */

	/* Flags for JetCreateLink */

/* Can use JET_bitObjectExclusive to cause linked to database to be opened */
/* exclusively.															   */



	/* Flags for JetCreateTableColumnIndex */
#define JET_bitTableCreateCheckColumnNames	0x00000001	/* Ensures that each column
														/* specified in the JET_COLUMNCREATE
														/* array has a unique name
														/* (for performance reasons,
														/* the default is to NOT perform
														/* this check and rely on the
														/* function caller to ensure
														/* column name uniqueness).
														/**/
#define JET_bitTableCreateCompaction		0x40000000	/* Internal grbit used when
														/* creating a table during
														/* off-line compact.
														/**/
#define JET_bitTableCreateSystemTable		0x80000000	/* Internal grbit used when
														/* creating system tables.
														/**/


	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged				0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement		0x00000010
#define JET_bitColumnUpdatable			0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending		0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnNotLast			0x00000100 /* Installable ISAM option */
#define JET_bitColumnRmtGraphic			0x00000200 /* JetGetColumnInfo */
#define JET_bitColumnMultiValued		0x00000400
#define JET_bitColumnColumnGUID			0x00000800
#define JET_bitColumnMostMany			0x00001000
#define JET_bitColumnPreventDelete		0x00002000

	/* Flags for JetSetCurrentIndex */

#define JET_bitMoveFirst				0x00000000
#define JET_bitMoveBeforeFirst 			0x00000001
#define JET_bitNoMove					0x00000002

	/* Flags for JetMakeKey */

#define JET_bitNewKey					0x00000001
#define JET_bitStrLimit 				0x00000002
#define JET_bitSubStrLimit				0x00000004
#define JET_bitNormalizedKey 			0x00000008
#define JET_bitKeyDataZeroLength		0x00000010

#ifdef DBCS /* johnta: LIKE "ABC" not converted to ="ABC" for Japanese */
#define JET_bitLikeExtra1				0x00000020
#endif /* DBCS */

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive			0x00000001
#define JET_bitRangeUpperLimit			0x00000002
#define JET_bitRangeInstantDuration		0x00000004
#define JET_bitRangeRemove				0x00000008

	/* Constants for JetMove */

#define JET_MoveFirst					(0x80000000)
#define JET_MovePrevious				(-1)
#define JET_MoveNext					(+1)
#define JET_MoveLast					(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE				0x00000001
#define JET_bitMoveCheckTS				0x00000002
#define JET_bitMoveInPage				0x00000004

	/* Flags for JetSeek */

#define JET_bitSeekEQ					0x00000001
#define JET_bitSeekLT					0x00000002
#define JET_bitSeekLE					0x00000004
#define JET_bitSeekGE					0x00000008
#define JET_bitSeekGT		 			0x00000010
#define JET_bitSetIndexRange			0x00000020

	/* Flags for JetFastFind */

#define JET_bitFFindBackwards			0x00000001
#define JET_bitFFindFromCursor			0x00000004

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique				0x00000001
#define JET_bitIndexPrimary				0x00000002
#define JET_bitIndexDisallowNull		0x00000004
#define JET_bitIndexIgnoreNull			0x00000008
#define JET_bitIndexClustered			0x00000010
#define JET_bitIndexIgnoreAnyNull		0x00000020
#define JET_bitIndexIgnoreFirstNull		0x00000040
#define JET_bitIndexLazyFlush			0x00000080
#define JET_bitIndexEmptyTable			0x40000000	// Internal use only
#define JET_bitIndexReference			0x80000000    /* IndexInfo only */

	/* Flags for index key definition */

#define JET_bitKeyAscending				0x00000000
#define JET_bitKeyDescending			0x00000001


	/* Flags for JetCreateRelationship */

#define JET_bitRelationUnique			0x00000001
#define JET_bitRelationDontEnforce		0x00000002
#define JET_bitRelationInherited		0x00000004
#define JET_bitRelationTestLegal		0x00000008	/* don't create relationship */

#define JET_bitRelationshipMatchMask	0x000000F0
#define JET_bitRelationMatchDefault		0x00000000
#define JET_bitRelationMatchFull		0x00000010

#define JET_bitRelationUpdateActionMask	0x00000F00
#define JET_bitRelationUpdateDisallow	0x00000000
#define JET_bitRelationUpdateCascade	0x00000100
#define JET_bitRelationUpdateSetNull	0x00000200
#define JET_bitRelationUpdateSetDefault	0x00000300

#define JET_bitRelationDeleteActionMask	0x0000F000
#define JET_bitRelationDeleteDisallow	0x00000000
#define JET_bitRelationDeleteCascade	0x00001000
#define JET_bitRelationDeleteSetNull	0x00002000
#define JET_bitRelationDeleteSetDefault	0x00003000

#define JET_bitRelationUserMask			0xFF000000	/* non-enforced values */
#define JET_bitRelationJoinMask			0x03000000
#define JET_bitRelationInner			0x00000000
#define JET_bitRelationLeft				0x01000000
#define JET_bitRelationRight			0x02000000


	/* Flags for JetCreateReference/JetCreateRelationship */
	/* NOTE: use the bitRelationship flags instead! */

#define JET_ReferenceUnique				JET_bitRelationUnique
#define JET_ReferenceDontEnforce		JET_bitRelationDontEnforce
#define JET_ReferenceMatchTypeMask		JET_bitRelationMatchMask
#define JET_ReferenceMatchDefault		JET_bitRelationMatchDefault
#define JET_ReferenceMatchFull			JET_bitRelationMatchFull
#define JET_ReferenceUpdateActionMask	JET_bitRelationUpdateActionMask
#define JET_ReferenceUpdateDisallow		JET_bitRelationUpdateDisallow
#define JET_ReferenceUpdateCascade		JET_bitRelationUpdateCascade
#define JET_ReferenceUpdateSetNull		JET_bitRelationUpdateSetNull
#define JET_ReferenceUpdateSetDefault	JET_bitRelationUpdateSetDefault
#define JET_ReferenceDeleteActionMask	JET_bitRelationDeleteActionMask
#define JET_ReferenceDeleteDisallow		JET_bitRelationDeleteDisallow
#define JET_ReferenceDeleteCascade		JET_bitRelationDeleteCascade
#define JET_ReferenceDeleteSetNull		JET_bitRelationDeleteSetNull
#define JET_ReferenceDeleteSetDefault	JET_bitRelationDeleteSetDefault


	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableAppendOnly		0x00000008
#define JET_bitTableUpdatable		0x00000010
#define JET_bitTableScrollable		0x00000020
#define JET_bitTableFixedSet		0x00000040	/* Fixed working set */
#define JET_bitTableInconsistent	0x00000080
#define JET_bitTableBulk			0x00000100
#define JET_bitTableUsePrimaryIndex	0x00000200	/* Use with FixedSet */
#define JET_bitTableSampleData		0x00000400
#define JET_bitTableQuickBrowse		0x00000800	/* Bias optimizer toward index usage */
#define JET_bitTableDDL				0x00001000	/* similar to JET_bitTableBulk, for DDL */
#define JET_bitTablePassThrough		0x00002000  /* Remote DBs Only */
#define JET_bitTableRowReturning	0x00004000
#define JET_bitTableSequential		0x00008000	/* Intend to access table sequentially */

#define JET_bitTableClassMask		0x000F0000	/*  table stats class mask  */
#define JET_bitTableClassNone		0x00000000  /*  table belongs to no stats class (default)  */
#define JET_bitTableClass1			0x00010000  /*  table belongs to stats class 1  */
#define JET_bitTableClass2			0x00020000  /*  table belongs to stats class 2  */
#define JET_bitTableClass3			0x00030000  /*  table belongs to stats class 3  */
#define JET_bitTableClass4			0x00040000  /*  table belongs to stats class 4  */
#define JET_bitTableClass5			0x00050000  /*  table belongs to stats class 5  */
#define JET_bitTableClass6			0x00060000  /*  table belongs to stats class 6  */
#define JET_bitTableClass7			0x00070000  /*  table belongs to stats class 7  */
#define JET_bitTableClass8			0x00080000  /*  table belongs to stats class 8  */
#define JET_bitTableClass9			0x00090000  /*  table belongs to stats class 9  */
#define JET_bitTableClass10			0x000A0000  /*  table belongs to stats class 10  */
#define JET_bitTableClass11			0x000B0000  /*  table belongs to stats class 11  */
#define JET_bitTableClass12			0x000C0000  /*  table belongs to stats class 12  */
#define JET_bitTableClass13			0x000D0000  /*  table belongs to stats class 13  */
#define JET_bitTableClass14			0x000E0000  /*  table belongs to stats class 14  */
#define JET_bitTableClass15			0x000F0000  /*  table belongs to stats class 15  */

	/* Flags for JetSetQoSql/JetRetrieveQoSql */
#define JET_bitSqlPassThrough		0x00000001	/* Pass through Query returning records */
#define JET_bitSqlSPTBulkOp			0x00000002  /* SPT query returning no table */
	
	/* Flags for JetOpenVtQbe */

#define JET_bitQBEAddBrackets		0x00000001
#define JET_bitQBERemoveEquals		0x00000002

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed		0x00000001	/* Allow seek */
#define JET_bitTTUnique 		0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable		0x00000004	/* Allow updates */
#define JET_bitTTScrollable		0x00000008	/* Allow backwards scrolling */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV			0x00000001
#define JET_bitSetValidate			0x00000002
#define JET_bitSetOverwriteLV		0x00000004 /* overwrite JET_coltypLong* byte range */
#define JET_bitSetSizeLV			0x00000008 /* set JET_coltypLong* size */
#define JET_bitSetValidateColumn	0x00000010
#define JET_bitSetZeroLength		0x00000020
#define JET_bitSetSeparateLV 		0x00000040 /* force LV separation */
#define JET_bitSetNoVersion 		0x00000080 /* INTERNAL USE ONLY */

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void 				*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert					0
#define JET_prepInsertBeforeCurrent		1
#define JET_prepReplace 				2
#define JET_prepCancel					3
#define JET_prepReplaceNoLock			4
#define JET_prepInsertCopy				5

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy				0x00000001
#define JET_bitRetrieveFromIndex		0x00000002
#define JET_bitRetrieveCase				0x00000004
#define JET_bitRetrieveTag				0x00000008
#define JET_bitRetrieveNull				0x00000010	/*	for columnid 0 only */
#define JET_bitRetrieveIgnoreDefault	0x00000020	/*	for columnid 0 only */
#define JET_bitRetrieveLongId			0x00000040
#define JET_bitRetrieveRecord			0x80000000
#define JET_bitRetrieveFDB				0x40000000
#define JET_bitRetrieveBookmarks		0x20000000

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void 			*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;

	/* Flags for JetFillFatCursor */

#define JET_bitFCFillRange			0x00000001
#define JET_bitFCRefreshRange		0x00000002
#define JET_bitFCFillMemos			0x00000004

	/* Flags for JetCommitTransaction */

#define JET_bitCommitFlush			0x00000001	/* commit and flush page buffers. */
#define	JET_bitCommitLazyFlush		0x00000004	/* lazy flush log buffers. */
#define JET_bitWaitLastLevel0Commit	0x00000010	/* wait for last level 0 commit record flushed */

	/* Flags for JetRollback */

#define JET_bitRollbackAll			0x00000001

	/* Flags for JetSetAccess and JetGetAccess */

#define JET_bitACEInheritable		0x00000001

	/* Flags for JetCreateSystemDatabase */

#define JET_bitSysDbOverwrite		0x00000001

	/* Flags for Jet Property Management */
#define JET_bitPropDDL				0x00000001		/* also used for setting */
#define JET_bitPropInherited		0x00000002		/* not used for setting */

	/* JPM Flags that are only used for setting properties */
#define JET_bitPropReplaceOnly		0x00000010
#define JET_bitPropInsertOnly		0x00000020
#define JET_bitPropDeleteOnly		0x00000040
	
	/* InfoLevels for Jet Property Management */
#define JET_PropertyValue				0
#define JET_PropertyCount				1
#define JET_PropertySingleCollection 	2
#define JET_PropertyAllCollections		3

	/* Collate values for JetGetColumnInfo and JetGetIndexInfo */

#define JET_sortBinary			0x0000
#define JET_sortEFGPI			0x0100
#define JET_sortSNIFD			0x0101
#define JET_sortSpanish 		0x0102
#define JET_sortDutch			0x0103
#define JET_sortSweFin			0x0104
#define JET_sortNorDan			0x0105
#define JET_sortIcelandic		0x0106
#define JET_sortCyrillic		0x0107
#define JET_sortCzech			0x0108
#define JET_sortHungarian		0x0109
#define JET_sortPolish			0x010A
#define JET_sortArabic			0x010B
#define JET_sortHebrew			0x010C
#define JET_sortMax				0x010C		/* Max for nonDBCS sort orders */

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
#define JET_sortJapanese		0x010D
#endif /* DBCS */

#define JET_sortUnknown 		0xFFFF

	/* Paradox ISAM specific collate values */

#define JET_sortPdxIntl 		0x1000
#define JET_sortPdxSwedFin		0x1001
#define JET_sortPdxNorDan		0x1002

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename			0
#define JET_DbInfoConnect			1
#define JET_DbInfoCountry			2
#define JET_DbInfoLangid			3
#define JET_DbInfoCp				4
#define JET_DbInfoCollate			5
#define JET_DbInfoOptions			6
#define JET_DbInfoTransactions		7
#define JET_DbInfoVersion			8
#define JET_DbInfoIsam				9
#define JET_DbInfoFilesize			10
#define JET_DbInfoSpaceOwned		11
#define JET_DbInfoSpaceAvailable	12

	/* Database versions returned by JetGetDatabaseInfo */

#define JET_DbVersion10			0x00010000
#define JET_DbVersion11			0x00010001
#define JET_DbVersion20			0x00020000


	/* Isam specific info returned by JetGetDatabaseInfo */

#define JET_IsamInvalid			0
#define JET_IsamBuiltinRed		1
#define JET_IsamBuiltinBlue		2

#define	JET_IsamInstRed			21
#define JET_IsamInstBlue		22
#define	JET_IsamInstFox			23
#define JET_IsamInstParadox		24
#define JET_IsamInstDbase		25
#define	JET_IsamInstBtrieve		26

#define JET_IsamBuilinMost		JET_BuiltinBlue
#define JET_IsamInstMin			JET_IsamInstRed
#define	JET_IsamInstMost		JET_IsamInstBtrieve

	/* Link specific info for link identification */
#define JET_bitLinkInvalid		0x00000000
#define JET_bitLinkRemote		0x00100000
#define JET_bitLinkBuiltinRed	0x00200000
#define JET_bitLinkBuiltinBlue	0x00300000
#define JET_bitLinkInstRed		0x00400000
#define JET_bitLinkInstBlue		0x00500000
#define JET_bitLinkInstFox		0x00600000
#define JET_bitLinkInstParadox	0x00700000
#define JET_bitLinkInstDbase	0x00800000
#define JET_bitLinkInstBtrieve	0x00900000

#define JET_bitFourByteBookmark		0x00000001
#define	JET_bitContiguousBookmarks	0x00000002

	/* Column data types */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */
#define JET_coltypDatabase			13		/* Database name parameter */
#define JET_coltypTableid			14		/* Tableid parameter */
#define JET_coltypOLE				15		/* OLE blob */
#define JET_coltypGUID				15
#define JET_coltypMax				16		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U
#define JET_TblInfoSpaceAlloc	9U
#define JET_TblInfoSpaceOwned	10U				// OwnExt
#define JET_TblInfoSpaceAvailable	11U			// AvailExt

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U
#define JET_IdxInfoSpaceAlloc		5U
#define JET_IdxInfoLangid			6U
#define JET_IdxInfoCount			7U

	/* Info levels for JetGetReferenceInfo and JetGetTableReferenceInfo */

#define JET_ReferenceInfo				0U
#define JET_ReferenceInfoReferencing	1U
#define JET_ReferenceInfoReferenced		2U
#define JET_ReferenceInfoAll			3U
#define JET_ReferenceInfoCursor 		4U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#define JET_ColInfo					0U
#define JET_ColInfoList 			1U
	/* CONSIDER: Info level 2 is valid */
#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 			4U
#define JET_ColInfoListCompact 		5U


	/* Attribute types for query definitions */

#define JET_qoaBeginDef 		0
#define JET_qoaOperation		1
#define JET_qoaParameter		2
#define JET_qoaOptions			3
#define JET_qoaDatabase 		4
#define JET_qoaInputTable		5
#define JET_qoaOutput			6
#define JET_qoaJoin				7
#define JET_qoaRestriction		8
#define JET_qoaGroup			9
#define JET_qoaGroupRstr		10
#define JET_qoaOrdering 		11
#define JET_qoaEndDef			255
#define JET_qoaValidLeast		JET_qoaOperation
#define JET_qoaValidMost		JET_qoaOrdering


	/* Query object options */

#define JET_bitFqoOutputAllCols 	0x0001
#define JET_bitFqoRemoveDups		0x0002
#define JET_bitFqoOwnerAccess		0x0004
#define JET_bitFqoDistinctRow		0x0008
#define JET_bitFqoTop				0x0010
#define JET_bitFqoPercent			0x0020
#define JET_bitFqoCorresponding		0x0040 /* JET_qopSetOperation */

	/* Query object join type */

#define JET_fjoinInner			1
#define JET_fjoinLeftOuter		2
#define JET_fjoinRightOuter		3

	/* Query object operations */

#define JET_qopSelect			1
#define JET_qopSelectInto		2
#define JET_qopInsertSelection	3
#define JET_qopUpdate			4
#define JET_qopDelete			5
#define JET_qopTransform		6
#define JET_qopDDL				7
#define JET_qopSqlPassThrough	8
#define JET_qopSetOperation		9
#define JET_qopSPTBulk			10

#define JET_bitqopSelect			0x0000
#define JET_bitqopTransform			0x0010
#define JET_bitqopDelete			0x0020
#define JET_bitqopUpdate			0x0030
#define JET_bitqopInsertSelection	0x0040
#define JET_bitqopSelectInto		0x0050
#define JET_bitqopDDL				0x0060
#define JET_bitqopSqlPassThrough	0x0070
#define JET_bitqopSetOperation		0x0080
#define JET_bitqopSPTBulk			0x0090

	/* Engine Object Types */

#define JET_objtypNil				0
#define JET_objtypTable 			1
#define JET_objtypDb				2
#define JET_objtypContainer			3
#define JET_objtypSQLLink			4
#define JET_objtypQuery 			5
#define JET_objtypLink				6
#define JET_objtypTemplate			7
#define JET_objtypRelationship		8

	/* All types less than JET_objtypClientMin are reserved by JET */

#define JET_objtypClientMin			0x8000

	/* Security Constant Values */

#define JET_cchUserNameMax		20
#define JET_cchPasswordMax		14

	/* Security Access Masks */

#define JET_acmNoAccess 		0x00000000L
#define JET_acmFullAccess		0x000FFFFFL

#define JET_acmSpecificMask		0x0000FFFFL
#define JET_acmSpecific_1		0x00000001L
#define JET_acmSpecific_2		0x00000002L
#define JET_acmSpecific_3		0x00000004L
#define JET_acmSpecific_4		0x00000008L
#define JET_acmSpecific_5		0x00000010L
#define JET_acmSpecific_6		0x00000020L
#define JET_acmSpecific_7		0x00000040L
#define JET_acmSpecific_8		0x00000080L
#define JET_acmSpecific_9		0x00000100L
#define JET_acmSpecific_10		0x00000200L
#define JET_acmSpecific_11		0x00000400L
#define JET_acmSpecific_12		0x00000800L
#define JET_acmSpecific_13		0x00001000L
#define JET_acmSpecific_14		0x00002000L
#define JET_acmSpecific_15		0x00004000L
#define JET_acmSpecific_16		0x00008000L

#define JET_acmStandardMask		0x00FF0000L
#define JET_acmDelete			0x00010000L
#define JET_acmReadControl		0x00020000L
#define JET_acmWriteDac 		0x00040000L
#define JET_acmWriteOwner		0x00080000L

#define JET_acmTblCreate			(JET_acmSpecific_1)
#define JET_acmTblAccessRcols		(JET_acmSpecific_2)
#define JET_acmTblReadDef			(JET_acmSpecific_3)
#define JET_acmTblWriteDef			(JET_acmSpecific_4)
#define JET_acmTblRetrieveData		(JET_acmSpecific_5)
#define JET_acmTblInsertData		(JET_acmSpecific_6)
#define JET_acmTblReplaceData		(JET_acmSpecific_7)
#define JET_acmTblDeleteData		(JET_acmSpecific_8)

#define JET_acmDbCreate 			(JET_acmSpecific_1)
#define JET_acmDbOpen				(JET_acmSpecific_2)

	/* Compact Options */

#define JET_bitCompactDontCopyLocale	0x00000004	/* Don't copy locale from source to dest */
#define JET_bitCompactVersion10			0x00000008	/* Destination is version 1.0 format */
#define JET_bitCompactVersion1x			0x00000010	/* Destination is version 1.x format */
#define JET_bitCompactStats				0x00000020	/* Dump off-line compaction stats (only when progress meter also specified) */

	/* On-line Compact Options */

#define JET_bitCompactOn	 			0x00000001	/* enable on-line compaction */

	/* Repair Notification Types */

#define JET_rntSelfContained		0
#define JET_rntDeletedIndex			1
#define JET_rntDeletedRec			2
#define JET_rntDeletedLv			3
#define JET_rntTruncated			4

	/* Status Notification Processes */

#define JET_snpIndex				0
#define JET_snpQuery				1
#define JET_snpRepair				2
#define JET_snpImex					3
#define JET_snpCompact				4
#define JET_snpFastFind 			5
#define JET_snpODBCNotReady			6
#define JET_snpQuerySort	   		7
#define JET_snpRestore				8
#define JET_snpBackup				9
#define JET_snpUpgrade				10

	/* Status Notification Types */

#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntMessage			1
#define JET_sntBulkRecords		2	/* callback for # rec for bulk op */
#define JET_sntFail				3	/* callback for failure during progress */
#define JET_sntErrCount 		4	/* callback for err count */
#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntCantRollback		7	/* callback for no rollback */
#define JET_sntRestoreMap		8	/* callback for restore map */

	/* Message codes for JET_snpCompact */

#define JET_sncCopyObject		0	/* Starting to copy object */
#define JET_sncCopyFailed		1	/* Copy of this object failed */
#define JET_sncYield			2	/* Client can yield/check for user interrupt */
#define JET_sncTransactionFull	3	/* Client can yield/check for user interrupt */
#define JET_sncAboutToWrap		4	/* Find find is about to wrap */

	/* Message codes for JET_snpODBCNotReady */

#define JET_sncODBCNotReady		0	/* Waiting for results from ODBC */


	/* Constants for the [ODBC] section of JET.INI */

#define JET_SQLTraceCanonical	0x0001	/* Output ODBC Generic SQL */

	/* Constants for the [Debug] section of JET.INI */

	/* APITrace */

#define JET_APITraceEnter		0x0001
#define JET_APITraceExit		0x0002
#define JET_APITraceExitError	0x0004
#define JET_APIBreakOnError		0x0008
#define JET_APITraceCount		0x0010
#define JET_APITraceNoIdle		0x0020
#define JET_APITraceParameters	0x0040

	/* IdleTrace */

#define JET_IdleTraceCursor		0x0001
#define JET_IdleTraceBuffer		0x0002
#define JET_IdleTraceFlush		0x0004

	/* AssertAction */

#define JET_AssertExit			0x0000		/* Exit the application */
#define JET_AssertBreak 		0x0001		/* Break to debugger */
#define JET_AssertMsgBox		0x0002		/* Display message box */
#define JET_AssertStop			0x0004		/* Alert and stop */

	/* IOTrace */

#define JET_IOTraceAlloc		0x0001		/* DB Page Allocation */
#define JET_IOTraceFree 		0x0002		/* DB Page Free */
#define JET_IOTraceRead 		0x0004		/* DB Page Read */
#define JET_IOTraceWrite		0x0008		/* DB Page Write */
#define JET_IOTraceError		0x0010		/* DB Page I/O Error */

	/* MemTrace */

#define JET_MemTraceAlloc		0x0001		/* Memory allocation */
#define JET_MemTraceRealloc		0x0002		/* Memory reallocation */
#define JET_MemTraceFree		0x0004		/* Memory free */

	/* RmtTrace */

#define JET_RmtTraceError		0x0001	/* Remote server error message */
#define JET_RmtTraceSql			0x0002	/* Remote SQL Prepares & Exec's */
#define JET_RmtTraceAPI			0x0004	/* Remote ODBC API calls */
#define JET_RmtTraceODBC		0x0008
#define JET_RmtSyncODBC			0x0010	/* Turn on ODBC Sync mode */
	
/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess						 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100  /* JET_errRfsFailure */
#define JET_errRfsNotArmed					-101  /* JET_errRfsFailure */
#define JET_errFileClose					-102  /* Could not close DOS file */
#define JET_errOutOfThreads					-103  /* Could not start thread */
#define JET_errTooManyIO		  			-105  /* System busy due to too many IOs */
#define JET_errDatabase200Format			-106  /* 200 format database */
#define JET_errDatabase400Format			-107  /* 400 format database */

/*	BUFFER MANAGER errors
/**/
#define wrnBFNotSynchronous					200	  /* Buffer page evicted */
#define wrnBFPageNotFound		  			201	  /* Page not found */
#define errBFInUse				  			-202  /* Cannot abandon buffer */
#define wrnBFNewIO							203	  /* Buffer access caused a new IO (cache miss) */
#define wrnBFCacheMiss						204	  /* Buffer access was a cache miss but didn't cause a new IO */
#define	wrnBFNoBufAvailable					205	  /* Need to allocate new buffer for read (used in Async IO ) */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300  /* Out of page space */
#define errPMItagTooBig 		  			-301  /* Itag too big */
#define errPMRecDeleted 		  			-302  /* Record deleted */
#define errPMTagsUsedUp 		  			-303  /* Tags used up */
#define wrnBMConflict			  			304   /* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305  /* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306  /* Cannot horizontally split FDP */
#define errDIRTop				  			-307  /* Cannot go up */
#define errDIRFDP							308	  /* On an FDP Node */
#define errDIRNotSynchronous				-309  /* May have left critical section */
#define wrnDIREmptyPage						310	  /* Moved through empty page */
#define errSPConflict						-311  /* Device extent being extended */
#define wrnNDFoundLess						312	  /* Found Less */
#define wrnNDFoundGreater					313	  /* Found Greater */
#define errNDOutSonRange					-314  /* Son out of range */
#define errNDOutItemRange					-315  /* Item out of range */
#define errNDGreaterThanAllItems 			-316  /* Greater than all items */
#define errNDLastItemNode					-317  /* Last node of item list */
#define errNDFirstItemNode					-318  /* First node of item list */
#define wrnNDDuplicateItem					319	  /* Duplicated Item */
#define errNDNoItem							-320  /* Item not there */
#define JET_wrnRemainingVersions 			321	  /* Some versions couldn't be cleaned */
#define JET_wrnPreviousVersion				322	  /* Version already existed */
#define JET_errPageBoundary					-323  /* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324  /* Reached Key Boundary */
#define errDIRInPageFather  				-325  /* sridFather in page to free */
#define	errBMMaxKeyInPage					-326  /* used by OLC to avoid cleanup of parent pages */
#define	JET_errBadPageLink					-327  /* next/previous page link page does not point back to source */
#define	JET_errBadBookmark					-328  /* bookmark has no corresponding address in database */
#define wrnBMCleanNullOp					329	  /* BMClean returns this on encountering a page
												  /* deleted MaxKeyInPage [but there was no conflict]
												
/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					400	  /* Key too big (truncated it) */
#define errFLDTooManySegments				-401  /* Too many key segments */
#define wrnFLDNullKey						402	  /* Key is entirely NULL */
#define wrnFLDOutOfKeys 					403	  /* No more keys to extract */
#define wrnFLDNullSeg						404	  /* Null segment in key */
#define wrnRECLongField 					405	  /* Separated long value */
#define JET_wrnSeparateLongValue			406	  /* Separated long value */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid
#define wrnFLDNullFirstSeg		   			407	  /* Null first segment in key */
#define JET_errKeyTooBig					-408  /* Key with column truncation still truncated */

/*	LOGGING/RECOVERY errors
/**/
#define JET_errInvalidLoggedOperation		-500  /* Logged operation cannot be redone */
#define JET_errLogFileCorrupt		  		-501  /* Log file is corrupt */
#define errLGNoMoreRecords					-502  /* Last log record read */
#define JET_errNoBackupDirectory 			-503  /* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504  /* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505  /* Backup is active already */
#define JET_errMissingPreviousLogFile		-509  /* Missing the log file for check point */
#define JET_errLogWriteFail					-510  /* Fail when writing to log file */
#define JET_errBadLogVersion  	  			-514  /* Version of log file is not compatible with Jet version */
#define JET_errInvalidLogSequence  			-515  /* Timestamp in next log does not match expected */
#define JET_errLoggingDisabled 				-516  /* Log is not active */
#define JET_errLogBufferTooSmall			-517  /* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518  /* retry to LGLogRec */
#define JET_errLogSequenceEnd				-519  /* Exceed maximum log file number */
#define JET_errNoBackup						-520  /* No backup in progress */
#define	JET_errInvalidBackupSequence		-521  /* Backup call out of sequence */
#define JET_errBackupNotAllowedYet			-523  /* Can not do backup now */
#define JET_errDeleteBackupFileFail	   		-524  /* Could not delete backup file */
#define JET_errMakeBackupDirectoryFail 		-525  /* Could not make backup temp directory */
#define JET_errInvalidBackup		 		-526  /* Cannot incremental backup when circular logging enabled */
#define JET_errRecoveredWithErrors			-527  /* For repair, restored with errors */
#define JET_errMissingLogFile				-528  /* current log file missing */
#define JET_errLogDiskFull					-529  /* log disk full */
#define JET_errBadLogSignature				-530  /* bad signature for a log file */
#define JET_errBadDbSignature				-531  /* bad signature for a db file */
#define JET_errBadCheckpointSignature		-532  /* bad signature for a checkpoint file */
#define	JET_errCheckpointCorrupt			-533  /* checkpoint file not found or corrupt */
#define	JET_errMissingPatchPage				-534  /* patch file page not found during recovery */


#define JET_errDatabaseInconsistent			-550  /* database is in inconsistent state */
#define JET_errConsistentTimeMismatch		-551  /* database last consistent time unmatched */
#define JET_errDatabasePatchFileMismatch	-552  /* patch file is not generated from this backup */
#define JET_errEndingRestoreLogTooLow		-553  /* the starting log number too low for the restore */
#define JET_errStartingRestoreLogTooHigh	-554  /* the starting log number too high for the restore */
#define JET_errGivenLogFileHasBadSignature	-555  /* Restore log file has bad signature */
#define JET_errGivenLogFileIsNotContiguous	-556  /* Restore log file is not contiguous */
#define JET_errMissingRestoreLogFiles		-557  /* Some restore log files are missing */
#define JET_wrnExistingLogFileHasBadSignature	558  /* Existing log file has bad signature */
#define JET_wrnExistingLogFileIsNotContiguous	559  /* Existing log file is not contiguous */
#define JET_errMissingFullBackup			-560  /* The database miss a previous full backup befor incremental backup */
#define JET_errBadBackupDatabaseSize		-561  /* The backup database size is not in 4k */
#define JET_errDatabaseAlreadyUpgraded		-562  /* Attempted to upgrade a database that is already current */

#define JET_errTermInProgress		  		-1000 /* Termination in progress */
#define JET_errFeatureNotAvailable			-1001 /* API not supported */
#define JET_errInvalidName					-1002 /* Invalid name */
#define JET_errInvalidParameter 			-1003 /* Invalid API parameter */
#define JET_wrnColumnNull					 1004 /* Column is NULL-valued */
#define JET_wrnBufferTruncated				 1006 /* Buffer too small for data */
#define JET_wrnDatabaseAttached 			 1007 /* Database is already attached */
#define JET_errDatabaseFileReadOnly			-1008 /* Attach a readonly database file for read/write operations */
#define JET_wrnSortOverflow					 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId			-1010 /* Invalid database id */
#define JET_errOutOfMemory					-1011 /* Out of Memory */
#define JET_errOutOfDatabaseSpace 			-1012 /* Maximum database size reached */
#define JET_errOutOfCursors					-1013 /* Out of table cursors */
#define JET_errOutOfBuffers					-1014 /* Out of database page buffers */
#define JET_errTooManyIndexes				-1015 /* Too many indexes */
#define JET_errTooManyKeys					-1016 /* Too many columns in an index */
#define JET_errRecordDeleted				-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure			-1018 /* Read verification error */
#define JET_errOutOfFileHandles	 			-1020 /* Out of file handles */
#define JET_errDiskIO						-1022 /* Disk IO error */
#define JET_errInvalidPath					-1023 /* Invalid file path */
#define JET_errRecordTooBig					-1026 /* Record larger than maximum size */
#define JET_errTooManyOpenDatabases			-1027 /* Too many open databases */
#define JET_errInvalidDatabase				-1028 /* Not a database file */
#define JET_errNotInitialized				-1029 /* JetInit not yet called */
#define JET_errAlreadyInitialized			-1030 /* JetInit already called */
#define JET_errFileAccessDenied 			-1032 /* Cannot access file */
#define JET_errQueryNotSupported			-1034 /* Query support unavailable */
#define JET_errSQLLinkNotSupported			-1035 /* SQL Link support unavailable */
#define JET_errBufferTooSmall				-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual					 1039 /* SeekLE or SeekGE didn't find exact match */
#define JET_errTooManyColumns				-1040 /* Too many columns defined */
#define JET_errContainerNotEmpty			-1043 /* Container is not empty */
#define JET_errInvalidFilename				-1044 /* Filename is invalid */
#define JET_errInvalidBookmark				-1045 /* Invalid bookmark */
#define JET_errColumnInUse					-1046 /* Column used in an index */
#define JET_errInvalidBufferSize			-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable			-1048 /* Cannot set column value */
#define JET_errIndexInUse					-1051 /* Index is in use */
#define JET_errLinkNotSupported 			-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed			-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 			-1054 /* Operation must be within a transaction */
#define JET_wrnNoErrorInfo					1055  /* No extended error information */
#define JET_wrnNoIdleActivity		 		1058  /* No idle activity occured */
#define JET_errTooManyActiveUsers			-1059 /* Too many active database users */
#define JET_errInvalidAppend				-1060 /* Cannot append long value */
#define JET_errInvalidCountry				-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId			-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage				-1063 /* Invalid or unknown code page */
#define JET_wrnNoWriteLock					1067  /* No write lock at transaction level 0 */
#define JET_wrnColumnSetNull		   		 1068 /* Column set to NULL-value */
#define JET_errVersionStoreOutOfMemory		-1069 /* lMaxVerPages exceeded (XJET only) */
#define JET_errCurrencyStackOutOfMemory		-1070 /* lCSRPerfFUCB * lMaxCursors exceeded (XJET only) */
#define JET_errOutOfSessions  				-1101 /* Out of sessions */
#define JET_errWriteConflict				-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep					-1103 /* Xactions nested too deeply */
#define JET_errInvalidSesid					-1104 /* Invalid session handle */
#define JET_errSessionWriteConflict			-1107 /* Another session has private version of page */
#define JET_errInTransaction				-1108 /* Operation not allowed within a transaction */
#define JET_errDatabaseDuplicate			-1201 /* Database already exists */
#define JET_errDatabaseInUse				-1202 /* Database in use */
#define JET_errDatabaseNotFound 			-1203 /* No such database */
#define JET_errDatabaseInvalidName			-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages			-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted			-1206 /* non-db file or corrupted db */
#define JET_errDatabaseLocked				-1207 /* Database exclusively locked */
#define	JET_errCannotDisableVersioning		-1208 /* Cannot disable versioning for this database */
#define JET_wrnTableEmpty			 		1301  /* Open an empty table */
#define JET_errTableLocked					-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate				-1303 /* Table already exists */
#define JET_errTableInUse					-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound				-1305 /* No such table or object */
#define JET_errDensityInvalid				-1307 /* Bad file/index density */
#define JET_errTableNotEmpty				-1308 /* Cannot define clustered index */
#define JET_errInvalidTableId				-1310 /* Invalid table id */
#define JET_errTooManyOpenTables			-1311 /* Cannot open any more tables */
#define JET_errIllegalOperation 			-1312 /* Oper. not supported on table */
#define JET_errObjectDuplicate				-1314 /* Table or object name in use */
#define JET_errInvalidObject				-1316 /* object is invalid for operation */
#define JET_errIndexCantBuild				-1401 /* Cannot build clustered index */
#define JET_errIndexHasPrimary				-1402 /* Primary index already defined */
#define JET_errIndexDuplicate				-1403 /* Index is already defined */
#define JET_errIndexNotFound				-1404 /* No such index */
#define JET_errIndexMustStay				-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef				-1406 /* Illegal index definition */
#define JET_errIndexHasClustered			-1408 /* Clustered index already defined */
#define JET_errInvalidCreateIndex	 		-1409 /* Invali create index description */
#define JET_errTooManyOpenIndexes			-1410 /* Out of index description blocks */
#define JET_errColumnLong					-1501 /* Column value is long */
#define JET_errColumnNoChunk				-1502 /* no such chunk in long value */
#define JET_errColumnDoesNotFit 			-1503 /* Field will not fit in record */
#define JET_errNullInvalid					-1504 /* Null not valid */
#define JET_errColumnIndexed				-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig					-1506 /* Field length is > maximum */
#define JET_errColumnNotFound				-1507 /* No such column */
#define JET_errColumnDuplicate				-1508 /* Field is already defined */
#define JET_errColumn2ndSysMaint			-1510 /* Second autoinc or version column */
#define JET_errInvalidColumnType			-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 		1512  /* Max length too big, truncated */
#define JET_errColumnCannotIndex			-1513 /* Cannot index Bit,LongText,LongBinary */
#define JET_errTaggedNotNULL				-1514 /* No non-NULL tagged columns */
#define JET_errNoCurrentIndex				-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade					-1516 /* The key is completely made */
#define JET_errBadColumnId					-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence				-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship			-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue				1520  /* Single instance column bursted */
#define JET_errCannotBeTagged				-1521 /* AutoIncrement and Version cannot be tagged */
#define JET_errRecordNotFound				-1601 /* The key was not found */
#define JET_errRecordNoCopy					-1602 /* No working buffer */
#define JET_errNoCurrentRecord				-1603 /* Currency not on a record */
#define JET_errRecordClusteredChanged		-1604 /* Clustered key may not change */
#define JET_errKeyDuplicate					-1605 /* Illegal duplicate key */
#define JET_errAlreadyPrepared				-1607 /* Already copy/clear current */
#define JET_errKeyNotMade					-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared			-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 		1610  /* Data has changed */
#define JET_errDataHasChanged				-1611 /* Data has changed, operation aborted */
#define JET_wrnKeyChanged			 		1618  /* Moved to new key */
#define JET_errTooManySorts					-1701 /* Too many sort processes */
#define JET_errInvalidOnSort				-1702 /* Invalid operation on Sort */
#define JET_errTempFileOpenError			-1803 /* Temp file could not be opened */
#define JET_errTooManyAttachedDatabases 	-1805 /* Too many open databases */
#define JET_errDiskFull 					-1808 /* No space left on disk */
#define JET_errPermissionDenied 			-1809 /* Permission denied */
#define JET_errFileNotFound					-1811 /* File not found */
#define JET_wrnFileOpenReadOnly				1813  /* Database file is read only */
#define JET_errAfterInitialization			-1850 /* Cannot Restore after init. */
#define JET_errLogCorrupted					-1852 /* Logs could not be interpreted */
#define JET_errInvalidOperation 			-1906 /* invalid operation */
#define JET_errAccessDenied					-1907 /* access denied */
#define JET_wrnIdleFull						 1908 /* ilde registry full */


/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

JET_ERR JET_API JetInit(JET_INSTANCE *pinstance);

JET_ERR JET_API JetTerm(JET_INSTANCE instance);

JET_ERR JET_API JetTerm2( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetSetSystemParameter(JET_INSTANCE *pinstance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char *sz);

JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR *plParam, char *sz, unsigned long cbMax);

#define ctAccessPage			1
#define ctLatchConflict			2
#define ctSplitRetry			3
#define ctNeighborPageScanned	4
#define ctSplits				5
JET_ERR JET_API JetResetCounter( JET_SESID sesid, long CounterType );
JET_ERR JET_API JetGetCounter( JET_SESID sesid, long CounterType, long *plValue );

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID *psesid,
	const char *szUserName, const char *szPassword);

JET_ERR JET_API JetDupSession(JET_SESID sesid, JET_SESID *psesid);

JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long *pwVersion);

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
	const char *szFilename, const char *szConnect,
	JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char *szFilename, JET_GRBIT grbit );

JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char *szFilename);

JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, unsigned long lPages, unsigned long lDensity,
	JET_TABLEID *ptableid);

JET_ERR JET_API JetCreateTableColumnIndex( JET_SESID sesid, JET_DBID dbid,
	JET_TABLECREATE *ptablecreate );

JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName);

JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumnName, void *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const char *szColumnName,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumn, const JET_COLUMNDEF *pcolumndef,
	const void *pvDefault, unsigned long cbDefault,
	JET_COLUMNID *pcolumnid);

JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumn);

JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, void *pvResult, unsigned long cbResult,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const char *szIndexName,
	void *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, JET_GRBIT grbit,
	const char *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName);

JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char *szContainerName,
	const char *szObjectName, void *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetCloseDatabase(JET_SESID sesid, JET_DBID dbid,
	JET_GRBIT grbit);

JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char *szFilename,
	const char *szConnect, JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetOpenTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const void *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID *ptableid);

JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbBookmark,
	unsigned long *pcbActual);

JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void *pvData, unsigned long cbData,
	unsigned long *pcbActual, JET_GRBIT grbit, JET_RETINFO *pretinfo);

JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn );

JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO *psetinfo);

JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn );

JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep);

JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos, unsigned long cbRecpos);

JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos );

JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char *szIndexName, unsigned long cchIndexName);

JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName);

JET_ERR JET_API JetSetCurrentIndex2(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, JET_GRBIT grbit );

JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit);

JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void *pvData, unsigned long cbData, JET_GRBIT grbit);

JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit);

JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbMax,
	unsigned long *pcbActual);
	
JET_ERR JET_API JetCompact(JET_SESID sesid, const char *szDatabaseSrc,
	const char *szDatabaseDest, JET_PFNSTATUS pfnStatus, JET_CONVERT *pconvert,
	JET_GRBIT grbit);

JET_ERR JET_API JetDBUtilities( JET_DBUTIL *pdbutil );	

JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbBookmark);

JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid);

typedef ULONG_PTR JET_VSESID;          /* Received from dispatcher */

struct tagVDBFNDEF;

typedef ULONG_PTR JET_VDBID;           /* Received from dispatcher */

struct tagVTFNDEF;

typedef ULONG_PTR JET_VTID;            /* Received from dispatcher */

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid);

JET_ERR JET_API JetOpenTempTable2( JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef,
	unsigned long ccolumn,
	unsigned long langid,
	JET_GRBIT grbit,
	JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid );

JET_ERR JET_API JetBackup( const char *szBackupPath, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus );

JET_ERR JET_API JetRestore(const char *sz, JET_PFNSTATUS pfn );
JET_ERR JET_API JetRestore2(const char *sz, const char *szDest, JET_PFNSTATUS pfn );

JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);

JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long *pcrec, unsigned long crecMax );

JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void *pvData, unsigned long cbMax,
	unsigned long *pcbActual, JET_GRBIT grbit );

JET_ERR JET_API JetBeginExternalBackup( JET_GRBIT grbit );

JET_ERR JET_API JetGetAttachInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );

JET_ERR JET_API JetOpenFile( const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh );

JET_ERR JET_API JetReadFile( JET_HANDLE hfFile,
	void *pv,
	unsigned long cb,
	unsigned long *pcb );

JET_ERR JET_API JetCloseFile( JET_HANDLE hfFile );

JET_ERR JET_API JetGetLogInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );

JET_ERR JET_API JetTruncateLog( void );

JET_ERR JET_API JetEndExternalBackup( void );

JET_ERR JET_API JetExternalRestore( char *szCheckpointFilePath, char *szLogPath, JET_RSTMAP *rgstmap, long crstfilemap, char *szBackupLogPath, long genLow, long genHigh, JET_PFNSTATUS pfn );

#endif	/* _JET_NOPROTOTYPES */

#pragma pack()

#ifdef	__cplusplus
}
#endif

#endif	/* _JET_INCLUDED */




=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\nettypes.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nettypes.h

Abstract:

    This header file contains type definitions for the NT TDI, NDI,
    DDI, and PDI interfaces which are not specific to a single interface.

Author:

    Steve Jones (stevej) 26-Oct-1989

Revision History:

--*/

#ifndef _NETTYPES_
#define _NETTYPES_

//
// The following basic type is used to provide extensibility in request
// and response packets.  The OFFSET type is used to contain a value which
// is interpreted as a relative address consisting of a number of bytes
// from the beginning of the immediate parent structure.
//

typedef ULONG OFFSET;

//
// The following basic type is used throughout all the layers to pass a
// string through an I/O interface which does not allow embedded pointers.
// To allocate a FLAT_STRING, one must make room for the correct number of
// buffer bytes in the allocation.
//

typedef struct _FLAT_STRING {
    SHORT MaximumLength;            // total size of string buffer.
    SHORT Length;                   // number of bytes represented in string.
    char Buffer [1];                // the buffer itself follows this struct.
} FLAT_STRING, *PFLAT_STRING;

//
// Basic type used to represent a network name, typically as a component of
// a transport address structure through the TDI.  This type is also passed
// through the NDI interface.  This type is declared as a structure so that
// it can be extended easily without modifying applications, even though it
// currently only has one element.
//
//

typedef struct _NETWORK_NAME {
    FLAT_STRING Name;                   // network name in FLAT_STRING format.
} NETWORK_NAME, *PNETWORK_NAME;

//
// Basic type used to represent an address at the hardware level of the
// network.  Hardware addresses are abstract types which are mapped to
// adapter addresses by the physical provider.  See the Physical Driver
// Interface specification for details on how this is accomplished.
//

#define HARDWARE_ADDRESS_LENGTH     6   // number of octets in a hardware address.

typedef struct _HARDWARE_ADDRESS {
    UCHAR Address [HARDWARE_ADDRESS_LENGTH];
} HARDWARE_ADDRESS, *PHARDWARE_ADDRESS;

//
// Network management variable types used by all interface levels.
//

#define NETMAN_VARTYPE_ULONG            0       // type is a ULONG.
#define NETMAN_VARTYPE_HARDWARE_ADDRESS 1       // type is a HARDWARE_ADDRESS.
#define NETMAN_VARTYPE_STRING           2       // type is a FLAT_STRING.

#endif // _NETTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\kerbcli.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        kerbcli.h
//
// Contents:    exported functions from kerbcli.lib
//
//
// History:     24-May-1999     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBCLI_H__
#define __KERBCLI_H__

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
KerbChangePasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR OldPassword,
    IN LPWSTR NewPassword
    );


NTSTATUS
KerbSetPasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR NewPassword,
    IN OPTIONAL PCredHandle CredentialsHandle
    );

#ifdef __cplusplus
}
#endif

#endif // __KERBCLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\ldi.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1993,1994
 *  All Rights Reserved.
 *
 *  LDI.H - Diamond Memory Decompression Interface (LDI)
 *
 *  History:
 *      03-Jul-1994     jforbes      Initial version.
 *
 *  Functions:
 *      LDICreateDecompression  - Create and reset an LDI decompression context
 *      LDIDecompress           - Decompress a block of data
 *      LDIResetDecompression   - Reset LDI decompression context
 *      LDIDestroyDecompression - Destroy LDI Decompression context
 *
 *  Types:
 *      LDI_CONTEXT_HANDLE      - Handle to an LDI decompression context
 *      PFNALLOC                - Memory allocation function for LDI
 *      PFNFREE                 - Free memory function for LDI
 */

/* --- types -------------------------------------------------------------- */

#include <basetsd.h>

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int  UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef NEAR
#  ifdef BIT16
#     define NEAR __near
#  else
#     define NEAR
#  endif
#endif

#ifndef FAR
#ifdef BIT16
#define FAR __far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE __huge
#else
#define HUGE
#endif
#endif

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif

#ifndef _MHANDLE_DEFINED
#define _MHANDLE_DEFINED
#if defined(_WIN64)
typedef unsigned __int64 MHANDLE;
#else
typedef unsigned long  MHANDLE;
#endif
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif


/*
 *  LDI will try to create a virtual ring buffer on disk if the pfnalloc call
 *  to create the buffer fails.  These functions provide LDI the disk access
 *  features needed.
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  LDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  For PFNOPEN, the pszFile parameter will take on a special form for LDI's
 *  temporary file.  The special form appears as a file named "*".  Such a
 *  name field should be cast into the struct below, which contains the
 *  required file's size as shown in the RINGNAME structure below.
 *
 *  Example open and close callbacks are provided.  It is assumed that the
 *  client will provide more adaptive code for determining the temporary
 *  file's name and drive location, based on environment variables and the
 *  amount of free disk space.  This sample code has hard-coded the actual
 *  path and fails if there is not enough free space.  This code creates the
 *  file, then attempts to expand it to the requested size by writing a byte
 *  (any byte) at the requested size - 1.  (This approach is not suitable for
 *  a file system which can support sparse files.)
 *
 *  The callback routine may create this file on any path, and with any name,
 *  as appropriate.  If the file cannot be created with the requested size,
 *  the PFNOPEN should fail.  The file really should be placed on a local
 *  fixed disk.  It would not be appropriate for the file to be placed on a
 *  compressed drive or a floppy disk.  If the client has access to alternate
 *  memory, such as XMS or EMS, these operations could be emuluated.
 *
 *  static int tempHandle = -1;
 *
 *  int FAR DIAMONDAPI MyOpen(char FAR *pszFile,int oflag,int pmode)
 *  {
 *      if (*pszFile == '*')
 *      {
 *          PRINGNAME pringDescriptor;
 *
 *          pringDescriptor = (PRINGNAME) pszFile;
 *
 *          tempHandle = _open("C:\\ldi_temp.$$$",oflag,pmode);
 *
 *          if (tempHandle != -1)
 *          {
 *              _lseek(tempHandle,(pringDescriptor->fileSize - 1),SEEK_SET);
 *
 *              if (_write(tempHandle,&tempHandle,1) != 1)
 *              {
 *                  _close(tempHandle);
 *                  remove("C:\\ldi_temp.$$$");
 *                  tempHandle = -1;
 *              }
 *          }
 *
 *          return(tempHandle);
 *      }
 *      else
 *      {
 *          * LDI only will call with *pszFile == '*' *
 *      }
 *  }
 *
 *  The callback provider must watch for the corresponding PFNCLOSE call on
 *  the returned handle, and delete the created file after closing.  (The
 *  file handle and file name assigned to the temporary file must be tracked;
 *  a close operation on that handle must be trapped, so the temporary file
 *  can be deleted as well.)
 *
 *  The client does not need to worry about multiple concurrent opens of the
 *  temporary file, or more than a single temporary file (from LDI).
 *
 *  int FAR DIAMONDAPI MyClose(int handle)
 *  {
 *      int result;
 *
 *      result = _close(handle);
 *
 *      if (handle == tempHandle)
 *      {
 *          remove("C:\\ldi_temp.$$$");
 *          tempHandle = -1;
 *      }
 *
 *      return(result);
 *  }
 */
typedef INT_PTR (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile,int oflag,int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (INT_PTR hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(INT_PTR hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(INT_PTR hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (INT_PTR hf, long dist, int seektype);


/* --- LDI-defined types -------------------------------------------------- */

/* LDI_CONTEXT_HANDLE - Handle to a LDI decompression context */

typedef MHANDLE LDI_CONTEXT_HANDLE;      /* hmd */


/***    PFNALLOC - Memory allocation function for LDI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for LDI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- prototypes --------------------------------------------------------- */

/***    LDICreateDecompression - Create LDI decompression context
 *
 *  Entry:
 *      pcbDataBlockMax     *largest uncompressed data block size expected,
 *                          gets largest uncompressed data block allowed
 *      pvConfiguration     passes implementation-specific info to decompressor.
 *      pfnma               memory allocation function pointer
 *      pfnmf               memory free function pointer
 *      pcbSrcBufferMin     gets max compressed buffer size
 *      pmdhHandle          gets newly-created context's handle
 *      pfnopen             file open function pointer (or NULL)
 *      pfnread             file read function pointer (or don't care)
 *      pfnwrite            file write function pointer (or don't care)
 *      pfnclose            file close function pointer (or don't care)
 *      pfnseek             file seek function pointer (or don't care)
 *
 *      If NULL is provided for pfnopen, and the ring buffer cannot be
 *      created via pfnma, LDICreateDecompression will fail.
 *
 *      If pmdhHandle==NULL, *pcbDataBlockMax and *pcbSrcBufferMin will be
 *      filled in, but no context will be created.  This query will allow
 *      the caller to determine required buffer sizes before creating a
 *      context.
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      *pcbDataBlockMax, *pcbSrcBufferMin, *pmdhHandle filled in.
 *
 *  Exit-Failure:
 *      MDI_ERROR_NOT_ENOUGH_MEMORY, could not allocate enough memory.
 *      MDI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 *      *pcbDataBlockMax, *pcbSrcBufferMin, *pmdhHandle undefined.
 */
int FAR DIAMONDAPI LDICreateDecompression(
        UINT FAR *      pcbDataBlockMax,  /* max uncompressed data block size */
        void FAR *      pvConfiguration,  /* implementation-defined */
        PFNALLOC        pfnma,            /* Memory allocation function ptr */
        PFNFREE         pfnmf,            /* Memory free function ptr */
        UINT FAR *      pcbSrcBufferMin,  /* gets max. comp. buffer size */
        LDI_CONTEXT_HANDLE FAR * pmdhHandle, /* gets newly-created handle */
        PFNOPEN         pfnopen,          /* open a file callback */
        PFNREAD         pfnread,          /* read a file callback */
        PFNWRITE        pfnwrite,         /* write a file callback */
        PFNCLOSE        pfnclose,         /* close a file callback */
        PFNSEEK         pfnseek);         /* seek in file callback */


/***    LDIDecompress - Decompress a block of data
 *
 *  Entry:
 *      hmd                 handle to decompression context
 *      pbSrc               source buffer (compressed data)
 *      cbSrc               compressed size of data to be decompressed
 *      pbDst               destination buffer (for decompressed data)
 *      *pcbDecompressed    (ptr to UINT) the expected de-compressed size
 *                          of this data block.  (same as cbSrc from the
 *                          LCICompress() call.).
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      *pcbDecompressed has size of decompressed data in pbDst.
 *      Decompression context updated.
 *
 *  Exit-Failure:
 *      MDI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 *      MDI_ERROR_BUFFER_OVERFLOW, cbSrc is too small to yield the
 *          requested *pcbDecompressed count.  cbSrc before LDIDecompressed
 *          should always equal *pcbResult after QCICompress(), and
 *          *pcbDecompressed before LDIDecompress should always equal the
 *          cbSrc before QCICompress().
 *      MDI_ERROR_FAILED, either cbSrc is too small, *pcbDecompressed is too
 *          large, or *pbSrc is corrupt.
 *
 *  Note:
 *      Set your cbDecompressed to the expected de-compressed size of this
 *      data block, then call LDIDecompress() with the address of your
 *      cbDecompressed.
 */
int FAR DIAMONDAPI LDIDecompress(
        LDI_CONTEXT_HANDLE  hmd,         /* decompression context */
        void FAR *          pbSrc,       /* source buffer */
        UINT                cbSrc,       /* source data size */
        void FAR *          pbDst,       /* target buffer */
        UINT FAR *          pcbDecompressed);  /* target data size */


/***    LDIResetDecompression - Reset decompression history (if any)
 *
 *  De-compression can only be started on a block which was compressed
 *  immediately following a MCICreateCompression() or MCIResetCompression()
 *  call.  This function provides notification to the decompressor that the
 *  next compressed block begins on a compression boundary.
 *
 *  Entry:
 *      hmd - handle to decompression context
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      Decompression context reset.
 *
 *  Exit-Failure:
 *      Returns MDI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LDIResetDecompression(LDI_CONTEXT_HANDLE hmd);


/***    LDIDestroyDecompression - Destroy LDI decompression context
 *
 *  Entry:
 *      hmd - handle to decompression context
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      Decompression context destroyed.
 *
 *  Exit-Failure:
 *      Returns MDI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LDIDestroyDecompression(LDI_CONTEXT_HANDLE hmd);


#ifndef BIT16
int FAR DIAMONDAPI LDIGetWindow(
        LDI_CONTEXT_HANDLE  hmd,            /* decompression context */
        BYTE FAR **         ppWindow,       /* pointer to window start */
        long *              pFileOffset,    /* offset in folder */
        long *              pWindowOffset,  /* offset in window */
        long *              pcbBytesAvail);   /* bytes avail from window start */
#endif


/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     MDI_ERROR_NO_ERROR              0
#define     MDI_ERROR_NOT_ENOUGH_MEMORY     1
#define     MDI_ERROR_BAD_PARAMETERS        2
#define     MDI_ERROR_BUFFER_OVERFLOW       3
#define     MDI_ERROR_FAILED                4
#define     MDI_ERROR_CONFIGURATION         5

/* --- LZX configuration details ------------------------------------- */

/***    LZX pvConfiguration structure
 *
 *  For the LZX decompressor, two parameters are configurable, the
 *  "window bits", which defines the size of the buffer needed by the
 *  the decompressor (must match the value used to compress), and the CPU
 *  type, which controls whether 386 opcodes will be used or not.  If
 *  "unknown" is provided for the fCPUtype, LDI will attempt to determine
 *  the CPU type itself, which could fail or produce system faults on
 *  non-DOS platforms (like Windows.)  Windows apps should use GetWinFlags()
 *  or a similiar method, and never pass "unknown".
 *
 *  pvConfiguration points to this structure.
 */

#pragma pack (1)

typedef struct {
    long	WindowSize;         /* buffersize */
    long	fCPUtype;           /* controls internal code selection */
} LZXDECOMPRESS; /* qdec */

#pragma pack ()

typedef LZXDECOMPRESS *PLZXDECOMPRESS; /* pldec */
typedef LZXDECOMPRESS FAR *PFLZXDECOMPRESS; /* pfldec */

/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 *
 *   LDI_CPU_UNKNOWN detection does *not* work when running under Windows
 *                   in 286 protected mode!  Call GetWinFlags() to determine
 *                   the CPU type and pass it explicitly!
 */

#define     LDI_CPU_UNKNOWN         (-1)    /* internally determined */

/*
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 */

#define     LDI_CPU_80286           (0)     /* '286 opcodes only */
#define     LDI_CPU_80386           (1)     /* '386 opcodes used */
#define     LDI_CPU_CONSERVATIVE    (LDI_CPU_80286)

/* ----------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\lci.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1996
 *  All Rights Reserved.
 *
 *  LCI.H - Diamond Memory Compression Interface (LCI)
 *
 *  History:
 *      03-Jul-1996     jforbes     Created from QCI.H
 *
 *  Functions:
 *      LCICreateCompression    - Create and reset an LCI compression context
 *      LCICompress             - Compress a block of data
 *      LCIResetCompression     - Reset compression context
 *      LCIDestroyCompression   - Destroy LCI compression context
 *      LCISetTranslationSize   - Set file translation size
 *
 *  Types:
 *      LCI_CONTEXT_HANDLE      - Handle to an LCI compression context
 *      PFNALLOC                - Memory allocation function for LCI
 *      PFNFREE                 - Free memory function for LCI
 */

/* --- types -------------------------------------------------------------- */

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int  UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef FAR
#ifdef BIT16
#define FAR far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE huge
#else
#define HUGE
#endif
#endif

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif

#ifndef _MHANDLE_DEFINED
#define _MHANDLE_DEFINED
#if defined(_WIN64)
typedef unsigned __int64 MHANDLE;
#else
typedef unsigned long MHANDLE;
#endif
#endif

/* --- LCI-defined types -------------------------------------------------- */

/* LCI_CONTEXT_HANDLE - Handle to an LCI compression context */

typedef MHANDLE LCI_CONTEXT_HANDLE;      /* hmc */


/***    PFNALLOC - Memory allocation function for LCI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for LCI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- prototypes --------------------------------------------------------- */

/***    LCICreateCompression - Create LCI compression context
 *
 *  Entry:
 *      pcbDataBlockMax     *largest uncompressed data block size desired,
 *                          gets largest uncompressed data block allowed
 *      pvConfiguration     passes implementation-specific info to compressor.
 *      pfnma               memory allocation function pointer
 *      pfnmf               memory free function pointer
 *      pcbDstBufferMin     gets required compressed data buffer size
 *      pmchHandle          gets newly-created context's handle
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      *pcbDataBlockMax, *pcbDstBufferMin, *pmchHandle filled in.
 *
 *  Exit-Failure:
 *      MCI_ERROR_NOT_ENOUGH_MEMORY, could not allocate enough memory.
 *      MCI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 */
int FAR DIAMONDAPI LCICreateCompression(
        UINT FAR *      pcbDataBlockMax,  /* max uncompressed data block size */
        void FAR *      pvConfiguration,  /* See LZXCONFIGURATION */
        PFNALLOC        pfnma,            /* Memory allocation function ptr */
        PFNFREE         pfnmf,            /* Memory free function ptr */
        UINT FAR *      pcbDstBufferMin,  /* gets required output buffer size */
        LCI_CONTEXT_HANDLE FAR *pmchHandle, /* gets newly-created handle */
		int FAR	(DIAMONDAPI *pfnlzx_output_callback)(
			void *			pfol,
			unsigned char *	compressed_data,
			long			compressed_size,
			long			uncompressed_size
        ),
        void FAR *      fci_pv // not the same as the FCI client's pv
);


/***    LCICompress - Compress a block of data
 *
 *  Entry:
 *      hmc                 handle to compression context
 *      pbSrc               source buffer (uncompressed data)
 *      cbSrc               size of data to be compressed
 *      pbDst               destination buffer (for compressed data)
 *      cbDst               size of destination buffer
 *      pcbResult           receives compressed size of data
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      *pcbResult has size of compressed data in pbDst.
 *      Compression context possibly updated.
 *
 *  Exit-Failure:
 *      MCI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 */
int FAR DIAMONDAPI LCICompress(
        LCI_CONTEXT_HANDLE  hmc,         /* compression context */
        void FAR *          pbSrc,       /* source buffer */
        UINT                cbSrc,       /* source buffer size */
        void FAR *          pbDst,       /* target buffer */
        UINT                cbDst,       /* target buffer size */
        ULONG FAR *         pcbResult);  /* gets target data size */


/***    LCIResetCompression - Reset compression history (if any)
 *
 *  De-compression can only be started on a block which was compressed
 *  immediately following a LCICreateCompression() or LCIResetCompression()
 *  call.  This function forces such a new "compression boundary" to be
 *  created (only by causing the compressor to ignore history, can the data
 *  output be decompressed without history.)
 *
 *  Entry:
 *      hmc - handle to compression context
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      Compression context reset.
 *
 *  Exit-Failure:
 *      Returns MCI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LCIResetCompression(LCI_CONTEXT_HANDLE hmc);


/***    LCIDestroyCompression - Destroy LCI compression context
 *
 *  Entry:
 *      hmc - handle to compression context
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      Compression context destroyed.
 *
 *  Exit-Failure:
 *      Returns MCI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI LCIDestroyCompression(LCI_CONTEXT_HANDLE hmc);


/*
 * Forces encoder to flush remaining output
 */
int FAR DIAMONDAPI LCIFlushCompressorOutput(LCI_CONTEXT_HANDLE hmc);


/*
 * Set the file translation size
 * (this must be done immediately after a reset, or an LCICreateCompression)
 */
int FAR DIAMONDAPI LCISetTranslationSize(LCI_CONTEXT_HANDLE hmc, unsigned long size);


/*
 * Returns a pointer to the input data present in LZX's buffers.
 *
 * input_position is the offset of the data from the beginning of the file
 * bytes_available is the number of bytes available from that offset
 */
unsigned char * FAR DIAMONDAPI LCIGetInputData(
    LCI_CONTEXT_HANDLE hmc,
    unsigned long *input_position,
    unsigned long *bytes_available
);



/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     MCI_ERROR_NO_ERROR              0
#define     MCI_ERROR_NOT_ENOUGH_MEMORY     1
#define     MCI_ERROR_BAD_PARAMETERS        2
#define     MCI_ERROR_BUFFER_OVERFLOW       3
#define     MCI_ERROR_FAILED                4
#define     MCI_ERROR_CONFIGURATION         5

/* --- LZX configuration details ------------------------------------- */

/***    LZX pvConfiguration structure
 *
 * The SecondPartitionSize must be >= 32K.  It is the amount of
 * data which LZX compresses before copymem'ing the window and
 * tree contents around.
 */

#pragma pack (2)

typedef struct {
    int WindowSize;           // buffer size
    int SecondPartitionSize;
} LZXCONFIGURATION; /* lcfg */

#pragma pack ()

typedef LZXCONFIGURATION *PLZXCONFIGURATION; /* plcfg */

/* ----------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\newres.h ===
/**
**      Header for the New version of RC.EXE. This contains the structures
**      for new format of BITMAP files.
**/

/*  The width of the name field in the Data for the group resources */
#ifndef RC_INVOKED       // RC can't handle #pragmas
#pragma pack(2)

typedef struct tagBITMAPHEADER
  {
    DWORD   Size;
    WORD    Width;
    WORD    Height;
    WORD    Planes;
    WORD    BitCount;
  } BITMAPHEADER;

// IDIOTS!  WHY WASN'T THIS DEFINED TO BE SAME AS RESOURCE FORMAT?
// Image File header
typedef struct tagIMAGEFILEHEADER
{
    BYTE    cx;
    BYTE    cy;
    BYTE    nColors;
    BYTE    iUnused;
    WORD    xHotSpot;
    WORD    yHotSpot;
    DWORD   cbDIB;
    DWORD   offsetDIB;
} IMAGEFILEHEADER;

// File header
#define FT_ICON     1
#define FT_CURSOR   2

typedef struct tagICONFILEHEADER
{
        WORD iReserved;
        WORD iResourceType;
        WORD cresIcons;
        IMAGEFILEHEADER imh[1];
} ICONFILEHEADER;

typedef struct tagNEWHEADER {
    WORD    Reserved;
    WORD    ResType;
    WORD    ResCount;
} NEWHEADER, *LPNEWHEADER;

typedef struct tagICONDIR
{
        BYTE  Width;            /* 16, 32, 64 */
        BYTE  Height;           /* 16, 32, 64 */
        BYTE  ColorCount;       /* 2, 8, 16 */
        BYTE  reserved;
} ICONDIR;

// Format of resource directory (array of resources)

typedef struct tagRESDIR
{
        ICONDIR Icon;
        WORD    Planes;
        WORD    BitCount;
        DWORD   BytesInRes;
        WORD    idIcon;
} RESDIR, *LPRESDIR;

typedef struct tagRESDIRDISK
{
        struct  tagICONDIR  Icon;

        WORD   Reserved[2];
        DWORD  BytesInRes;
        DWORD  Offset;
} RESDIRDISK, *LPRESDIRDISK;

#pragma pack()
#endif // !RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\newexe.h ===
/*
 *	SCCSID = @(#)newexe.h	13.4 89/06/26
 *
 *  Title
 *
 *	newexe.h
 *	Pete Stewart
 *	(C) Copyright Microsoft Corp 1984-1998
 *	17 August 1984
 *
 *  Description
 *
 *	Data structure definitions for the DOS 4.0/Windows 2.0
 *	executable file format.
 *
 *  Modification History
 *
 *	84/08/17	Pete Stewart	Initial version
 *	84/10/17	Pete Stewart	Changed some constants to match OMF
 *	84/10/23	Pete Stewart	Updates to match .EXE format revision
 *	84/11/20	Pete Stewart	Substantial .EXE format revision
 *	85/01/09	Pete Stewart	Added constants ENEWEXE and ENEWHDR
 *	85/01/10	Steve Wood	Added resource definitions
 *	85/03/04	Vic Heller	Reconciled Windows and DOS 4.0 versions
 *	85/03/07	Pete Stewart	Added movable entry count
 *	85/04/01	Pete Stewart	Segment alignment field, error bit
 *	85/10/03	Reuben Borman	Removed segment discard priority
 *	85/10/11	Vic Heller	Added PIF header fields
 *	86/03/10	Reuben Borman	Changes for DOS 5.0
 *	86/09/02	Reuben Borman	NSPURE ==> NSSHARED
 *	87/05/04	Reuben Borman	Added ne_cres and NSCONFORM
 *	87/07/08	Reuben Borman	Added NEAPPTYPE definitions
 *	88/03/24	Wieslaw Kalkus	Added 32-bit .EXE format
 *	89/03/23	Wieslaw Kalkus	Added ne_flagsothers for OS/2 1.2
 */

/*INT32*/

    /*_________________________________________________________________*
     |								       |
     |								       |
     |	DOS3 .EXE FILE HEADER DEFINITION			       |
     |								       |
     |_________________________________________________________________|
     *								       */


#define EMAGIC		0x5A4D		/* Old magic number */
#define ENEWEXE		sizeof(struct exe_hdr)
					/* Value of E_LFARLC for new .EXEs */
#define ENEWHDR		0x003C		/* Offset in old hdr. of ptr. to new */
#define ERESWDS		0x0010		/* No. of reserved words (OLD) */
#define ERES1WDS	0x0004		/* No. of reserved words in e_res */
#define ERES2WDS	0x000A		/* No. of reserved words in e_res2 */
#define ECP		0x0004		/* Offset in struct of E_CP */
#define ECBLP		0x0002		/* Offset in struct of E_CBLP */
#define EMINALLOC	0x000A		/* Offset in struct of E_MINALLOC */

struct exe_hdr {			/* DOS 1, 2, 3 .EXE header */
    unsigned short	e_magic;	/* Magic number */
    unsigned short	e_cblp;		/* Bytes on last page of file */
    unsigned short	e_cp;		/* Pages in file */
    unsigned short	e_crlc;		/* Relocations */
    unsigned short	e_cparhdr;	/* Size of header in paragraphs */
    unsigned short	e_minalloc;	/* Minimum extra paragraphs needed */
    unsigned short	e_maxalloc;	/* Maximum extra paragraphs needed */
    unsigned short	e_ss;		/* Initial (relative) SS value */
    unsigned short	e_sp;		/* Initial SP value */
    unsigned short	e_csum;		/* Checksum */
    unsigned short	e_ip;		/* Initial IP value */
    unsigned short	e_cs;		/* Initial (relative) CS value */
    unsigned short	e_lfarlc;	/* File address of relocation table */
    unsigned short	e_ovno;		/* Overlay number */
    unsigned short	e_res[ERES1WDS];/* Reserved words */
    unsigned short	e_oemid;	/* OEM identifier (for e_oeminfo) */
    unsigned short	e_oeminfo;	/* OEM information; e_oemid specific */
    unsigned short	e_res2[ERES2WDS];/* Reserved words */
    long		e_lfanew;	/* File address of new exe header */
  };

/* XLATOFF */
#define E_MAGIC(x)	(x).e_magic
#define E_CBLP(x)	(x).e_cblp
#define E_CP(x)		(x).e_cp
#define E_CRLC(x)	(x).e_crlc
#define E_CPARHDR(x)	(x).e_cparhdr
#define E_MINALLOC(x)	(x).e_minalloc
#define E_MAXALLOC(x)	(x).e_maxalloc
#define E_SS(x)		(x).e_ss
#define E_SP(x)		(x).e_sp
#define E_CSUM(x)	(x).e_csum
#define E_IP(x)		(x).e_ip
#define E_CS(x)		(x).e_cs
#define E_LFARLC(x)	(x).e_lfarlc
#define E_OVNO(x)	(x).e_ovno
#define E_RES(x)	(x).e_res
#define E_OEMID(x)	(x).e_oemid
#define E_OEMINFO(x)	(x).e_oeminfo
#define E_RES2(x)	(x).e_res2
#define E_LFANEW(x)	(x).e_lfanew
/* XLATON */


    /*_________________________________________________________________*
     |								       |
     |								       |
     |	OS/2 & WINDOWS .EXE FILE HEADER DEFINITION - 286 version       |
     |								       |
     |_________________________________________________________________|
     *								       */

#define NEMAGIC		0x454E		/* New magic number */
#define NECRC		8		/* Offset into new header of NE_CRC */

#ifdef	CRUISER

#define NERESBYTES	8		/* Eight bytes reserved (now) */

struct new_exe {			/* New .EXE header */
    unsigned short	ne_magic;	/* Magic number NE_MAGIC */
    unsigned char	ne_ver;		/* Version number */
    unsigned char	ne_rev;		/* Revision number */
    unsigned short	ne_enttab;	/* Offset of Entry Table */
    unsigned short	ne_cbenttab;	/* Number of bytes in Entry Table */
    long		ne_crc;		/* Checksum of whole file */
    unsigned short	ne_flags;	/* Flag word */
    unsigned short	ne_autodata;	/* Automatic data segment number */
    unsigned short	ne_heap;	/* Initial heap allocation */
    unsigned short	ne_stack;	/* Initial stack allocation */
    long		ne_csip;	/* Initial CS:IP setting */
    long		ne_sssp;	/* Initial SS:SP setting */
    unsigned short	ne_cseg;	/* Count of file segments */
    unsigned short	ne_cmod;	/* Entries in Module Reference Table */
    unsigned short	ne_cbnrestab;	/* Size of non-resident name table */
    unsigned short	ne_segtab;	/* Offset of Segment Table */
    unsigned short	ne_rsrctab;	/* Offset of Resource Table */
    unsigned short	ne_restab;	/* Offset of resident name table */
    unsigned short	ne_modtab;	/* Offset of Module Reference Table */
    unsigned short	ne_imptab;	/* Offset of Imported Names Table */
    long		ne_nrestab;	/* Offset of Non-resident Names Table */
    unsigned short	ne_cmovent;	/* Count of movable entries */
    unsigned short	ne_align;	/* Segment alignment shift count */
    unsigned short	ne_cres;	/* Count of resource entries */
    unsigned char	ne_exetyp;	/* Target operating system */
    unsigned char	ne_flagsothers; /* Other .EXE flags */
    char		ne_res[NERESBYTES];
					/* Pad structure to 64 bytes */
  };
#else

#define NERESBYTES	0

struct new_exe {			/* New .EXE header */
    unsigned short int	ne_magic;	/* Magic number NE_MAGIC */
    char		ne_ver;		/* Version number */
    char		ne_rev;		/* Revision number */
    unsigned short int	ne_enttab;	/* Offset of Entry Table */
    unsigned short int	ne_cbenttab;	/* Number of bytes in Entry Table */
    long		ne_crc;		/* Checksum of whole file */
    unsigned short int	ne_flags;	/* Flag word */
    unsigned short int	ne_autodata;	/* Automatic data segment number */
    unsigned short int	ne_heap;	/* Initial heap allocation */
    unsigned short int	ne_stack;	/* Initial stack allocation */
    long		ne_csip;	/* Initial CS:IP setting */
    long		ne_sssp;	/* Initial SS:SP setting */
    unsigned short int	ne_cseg;	/* Count of file segments */
    unsigned short int	ne_cmod;	/* Entries in Module Reference Table */
    unsigned short int	ne_cbnrestab;	/* Size of non-resident name table */
    unsigned short int	ne_segtab;	/* Offset of Segment Table */
    unsigned short int	ne_rsrctab;	/* Offset of Resource Table */
    unsigned short int	ne_restab;	/* Offset of resident name table */
    unsigned short int	ne_modtab;	/* Offset of Module Reference Table */
    unsigned short int	ne_imptab;	/* Offset of Imported Names Table */
    long		ne_nrestab;	/* Offset of Non-resident Names Table */
    unsigned short int	ne_cmovent;	/* Count of movable entries */
    unsigned short int	ne_align;	/* Segment alignment shift count */
    unsigned short int	ne_cres;	/* Count of resource segments */
    unsigned char	ne_exetyp;	/* Target operating system */
    unsigned char	ne_flagsothers; /* Other .EXE flags */
    unsigned short int	ne_pretthunks;	/* offset to return thunks */
    unsigned short int	ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int	ne_swaparea;	/* Minimum code swap area size */
    unsigned short int	ne_expver;	/* Expected Windows version number */
  };
#endif

/* ASM
; Chksum not supported unless ne_psegcsum defined in NEW_EXE structure

ne_psegcsum = word ptr ne_exetyp
ne_onextexe = word ptr ne_crc

; New 3.0 Gang Load area description

ne_gang_start	= ne_pretthunks
ne_gang_length	= ne_psegrefbytes

new_exe1	struc
		dw  ?
ne_usage	dw  ?
		dw  ?
ne_pnextexe	dw  ?
ne_pautodata	dw  ?
ne_pfileinfo	dw  ?
new_exe1	ends
*/

/* XLATOFF */
#define NE_MAGIC(x)	    (x).ne_magic
#define NE_VER(x)	    (x).ne_ver
#define NE_REV(x)	    (x).ne_rev
#define NE_ENTTAB(x)	    (x).ne_enttab
#define NE_CBENTTAB(x)	    (x).ne_cbenttab
#define NE_CRC(x)	    (x).ne_crc
#define NE_FLAGS(x)	    (x).ne_flags
#define NE_AUTODATA(x)	    (x).ne_autodata
#define NE_HEAP(x)	    (x).ne_heap
#define NE_STACK(x)	    (x).ne_stack
#define NE_CSIP(x)	    (x).ne_csip
#define NE_SSSP(x)	    (x).ne_sssp
#define NE_CSEG(x)	    (x).ne_cseg
#define NE_CMOD(x)	    (x).ne_cmod
#define NE_CBNRESTAB(x)	    (x).ne_cbnrestab
#define NE_SEGTAB(x)	    (x).ne_segtab
#define NE_RSRCTAB(x)	    (x).ne_rsrctab
#define NE_RESTAB(x)	    (x).ne_restab
#define NE_MODTAB(x)	    (x).ne_modtab
#define NE_IMPTAB(x)	    (x).ne_imptab
#define NE_NRESTAB(x)	    (x).ne_nrestab
#define NE_CMOVENT(x)	    (x).ne_cmovent
#define NE_ALIGN(x)	    (x).ne_align
#define NE_CRES(x)	    (x).ne_cres
#define NE_RES(x)	    (x).ne_res
#define NE_EXETYP(x)	    (x).ne_exetyp
#define NE_FLAGSOTHERS(x)   (x).ne_flagsothers

#define NE_USAGE(x)	(WORD)*((WORD *)(x)+1)
#define NE_PNEXTEXE(x)	(WORD)(x).ne_cbenttab
#define NE_ONEWEXE(x)	(WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif
/* XLATON */

/*
 *  Format of NE_FLAGS(x):
 *
 *  p					Not-a-process
 *   x					Unused
 *    e					Errors in image
 *     x				Unused
 *	b				Bound Family/API
 *	 ttt				Application type
 *	    f				Floating-point instructions
 *	     3				386 instructions
 *	      2				286 instructions
 *	       0			8086 instructions
 *		P			Protected mode only
 *		 p			Per-process library initialization
 *		  i			Instance data
 *		   s			Solo data
 */
#define NENOTP		0x8000		/* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define	NEPRIVLIB       0x4000		/* A lib which lives above the line */
#define NEIERR		0x2000		/* Errors in image */
#define NEBOUND		0x0800		/* Bound Family/API */
#define NEAPPTYP	0x0700		/* Application type mask */
#define NENOTWINCOMPAT	0x0100		/* Not compatible with P.M. Windowing */
#define NEWINCOMPAT	0x0200		/* Compatible with P.M. Windowing */
#define NEWINAPI	0x0300		/* Uses P.M. Windowing API */
#define NEFLTP		0x0080		/* Floating-point instructions */
#define NEI386		0x0040		/* 386 instructions */
#define NEI286		0x0020		/* 286 instructions */
#define NEI086		0x0010		/* 8086 instructions */
#define NEPROT		0x0008		/* Runs in protected mode only */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEPPLI		0x0004		/* Per-Process Library Initialization */
#define NEINST		0x0002		/* Instance data */
#define NESOLO		0x0001		/* Solo data */

/*
 * Below are the private bits used by the Windows 2.0 loader.  All are
 * in the file, with the exception of NENONRES and NEWINPROT which are
 * runtime only flags.
 */

#define NEWINPROT	NEIERR
#define NENONRES        NEFLTP        /* Contains non-resident code segments */
#define NEALLOCHIGH     NEI386        /* Private allocs above the line okay */
#define NEEMSSEPINST    NEI286        /* Want each instance in separate */
#define NELIM32         NEI086        /* Uses LIM 3.2 API (Intel Above board) */

/*
 *  Format of NE_FLAGSOTHERS(x):
 *
 *	7 6 5 4 3 2 1 0	 - bit no
 *	| |   |	      |
 *	| |   |	      +---------------- Support for long file names
 *	| |   +------------------------ Reserved for Win16 loader: must be 0
 *      | +---------------------------- Intl versions use this for ml shell
 *      +------------------------------ Some segs of this module get patched
 */

#define NELONGNAMES	0x01
#define NEFORCESTUB	0x02	/* WIN40 - Always run the stub from DOS */
#define	NEINFONT	0x02	/* WIN30 - 2.x app runs in 3.x prot mode */
#define	NEINPROT	0x04	/* WIN30 - 2.x app gets proportional font */
#define	NEGANGLOAD	0x08	/* WIN30 - Contains gangload area */
#define NEASSUMENODEP   0x10	/* Reserved for Win16 loader. Must be 0 in file */
#define NEINTLAPP       0x40	/* WIN31 - intl versions use this. */
#define NEHASPATCH      0x80    /* WIN40 - Some segs of this module get patched */

/*
 *  Target operating systems
 */

#define NE_UNKNOWN	0x0		/* Unknown (any "new-format" OS) */
#define NE_OS2		0x1		/* Microsoft/IBM OS/2 (default)	 */
#define NE_WINDOWS	0x2		/* Microsoft Windows */
#define NE_DOS4		0x3		/* Microsoft MS-DOS 4.x */
#define NE_DEV386	0x4		/* Microsoft Windows 386 */

#ifndef NO_APPLOADER
#define	NEAPPLOADER     0x0800		/* set if app has its own loader */
#endif  /* !NO_APPLOADER */

struct new_seg {			/* New .EXE segment table entry */
    unsigned short	ns_sector;	/* File sector of start of segment */
    unsigned short	ns_cbseg;	/* Number of bytes in file */
    unsigned short	ns_flags;	/* Attribute flags */
    unsigned short	ns_minalloc;	/* Minimum allocation in bytes */
  };

/* ASM
new_seg1	struc
		db	size new_seg dup (?)
ns_handle	dw	?	
new_seg1	ends
*/

/* XLATOFF */
struct new_seg1 {			/* New .EXE segment table entry */
    unsigned short	ns_sector;	/* File sector of start of segment */
    unsigned short	ns_cbseg;	/* Number of bytes in file */
    unsigned short	ns_flags;	/* Attribute flags */
    unsigned short	ns_minalloc;	/* Minimum allocation in bytes */
    unsigned short	ns_handle;	/* Handle of segment */
  };

#define NS_SECTOR(x)	(x).ns_sector
#define NS_CBSEG(x)	(x).ns_cbseg
#define NS_FLAGS(x)	(x).ns_flags
#define NS_MINALLOC(x)	(x).ns_minalloc
/* XLATON */

/*
 *  Format of NS_FLAGS(x)
 *
 *  Flag word has the following format:
 *
 *	15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *	    |  |  |  |	| | | | | | | | | | |
 *	    |  |  |  |	| | | | | | | | +-+-+--- Segment type DATA/CODE
 *	    |  |  |  |	| | | | | | | +--------- Iterated segment
 *	    |  |  |  |	| | | | | | +----------- Movable segment
 *	    |  |  |  |	| | | | | +------------- Segment can be shared
 *	    |  |  |  |	| | | | +--------------- Preload segment
 *	    |  |  |  |	| | | +----------------- Execute/read-only for code/data segment
 *	    |  |  |  |	| | +------------------- Segment has relocations
 *	    |  |  |  |	| +--------------------- Code conforming/Data is expand down
 *	    |  |  |  +--+----------------------- I/O privilege level
 *	    |  |  +----------------------------- Discardable segment
 *	    |  +-------------------------------- 32-bit code segment
 *	    +----------------------------------- Huge segment/GDT allocation requested
 *
 */

#define NSTYPE		0x0007		/* Segment type mask */
#define NSCODE		0x0000		/* Code segment */
#define NSDATA		0x0001		/* Data segment */
#define NSITER		0x0008		/* Iterated segment flag */
#define NSMOVE		0x0010		/* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSSHARED	0x0020		/* Shared segment flag */
#define NSSHARE		0x0020
#define NSPRELOAD	0x0040		/* Preload segment flag */
#define NSEXRD		0x0080		/* Execute-only (code segment) or */
#define NSERONLY	0x0080		/* read-only (data segment) */
#define NSRELOC		0x0100		/* Segment has relocations */
#define NSCONFORM	0x0200		/* Conforming segment */
#define NSEXPDOWN	0x0200		/* Data segment is expand down */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL		0x0C00		/* I/O privilege level (286 DPL bits) */
#define SHIFTDPL	10		/* Left shift count for SEGDPL field */
#define NSDISCARD	0x1000		/* Segment is discardable */
#define NS32BIT		0x2000		/* 32-bit code segment */
#define NSHUGE		0x4000		/* Huge memory segment, length of
					   segment and minimum allocation
					   size are in segment sector units */
#define NSGDT		0x8000		/* GDT allocation requested */

#define	NS286DOS        0xEE06		/* These bits only used by 286DOS */

#define NSALIGN 9			/* Segment data aligned on 512 byte
					   boundaries */

#define	NSALLOCED       0x0002		/* Set if ns_handle points to
					   uninitialized mem */
#define NSLOADED	0x0004		/* ns_sector field contains memory
					   address */
#define	NSUSESDATA      0x0400     	/* Set if an entry point in this
					   segment uses the automatic data
					   segment of a SOLO library */

#define	NSGETHIGH	0x0200
#define	NSINDIRECT	0x2000
#define	NSWINCODE	0x4000		/* flag for code */

#define	NSKCACHED	0x0800		/* cached by kernel */
#define	NSPRIVLIB	NSITER
#define	NSNOTP		0x8000

#ifndef NO_APPLOADER
#define	NSCACHED	0x8000		/* in AppLoader Cache */
#endif /*!NO_APPLOADER */

/* XLATOFF */
struct new_segdata {			/* Segment data */
    union {
	struct {
	    unsigned short	ns_niter;	/* number of iterations */
	    unsigned short	ns_nbytes;	/* number of bytes */
	    char		ns_iterdata;	/* iterated data bytes */
	  } ns_iter;
	struct {
	    char		ns_data;	/* data bytes */
	  } ns_noniter;
      } ns_union;
  };
/* XLATON */

struct new_rlcinfo {			/* Relocation info */
    unsigned short	nr_nreloc;	/* number of relocation items that */
  };					/* follow */

/* XLATOFF */
#pragma pack(1)

struct new_rlc {			/* Relocation item */
    char		nr_stype;	/* Source type */
    char		nr_flags;	/* Flag byte */
    unsigned short	nr_soff;	/* Source offset */
    union {
	struct {
	    char	nr_segno;	/* Target segment number */
	    char	nr_res;		/* Reserved */
	    unsigned short nr_entry;	/* Target Entry Table offset */
	  } 		nr_intref;	/* Internal reference */
	struct {
	    unsigned short nr_mod;	/* Index into Module Reference Table */
	    unsigned short nr_proc;	/* Procedure ordinal or name offset */
	  } 		nr_import;	/* Import */
	struct {
	    unsigned short nr_ostype;	/* OSFIXUP type */
	    unsigned short nr_osres;	/* reserved */
	  }		nr_osfix;	/* Operating system fixup */
      }			nr_union;	/* Union */
  };

#pragma pack()
/* XLATON */

/* ASM
new_rlc         struc
nr_stype        db  ?
nr_flags        db  ?
nr_soff         dw  ?
nr_mod          dw  ?
nr_proc         dw  ?
new_rlc         ends

nr_segno        equ nr_flags+3
nr_entry        equ nr_proc
*/

/* XLATOFF */
#define NR_STYPE(x)	(x).nr_stype
#define NR_FLAGS(x)	(x).nr_flags
#define NR_SOFF(x)	(x).nr_soff
#define NR_SEGNO(x)	(x).nr_union.nr_intref.nr_segno
#define NR_RES(x)	(x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)	(x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)	(x).nr_union.nr_import.nr_mod
#define NR_PROC(x)	(x).nr_union.nr_import.nr_proc
#define NR_OSTYPE(x)	(x).nr_union.nr_osfix.nr_ostype
#define NR_OSRES(x)	(x).nr_union.nr_osfix.nr_osres
/* XLATON */

/*
 *  Format of NR_STYPE(x) and R32_STYPE(x):
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *		 | | | |
 *		 +-+-+-+--- source type
 *
 */

#define NRSTYP		0x0f		/* Source type mask */
#define NRSBYT		0x00		/* lo byte (8-bits)*/
#define NRSBYTE		0x00
#define NRSSEG		0x02		/* 16-bit segment (16-bits) */
#define NRSPTR		0x03		/* 16:16 pointer (32-bits) */
#define NRSOFF		0x05		/* 16-bit offset (16-bits) */
#define NRPTR48		0x06		/* 16:32 pointer (48-bits) */
#define NROFF32		0x07		/* 32-bit offset (32-bits) */
#define NRSOFF32	0x08		/* 32-bit self-relative offset (32-bits) */

/*
 *  Format of NR_FLAGS(x) and R32_FLAGS(x):
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *		   | | |
 *		   | +-+--- Reference type
 *		   +------- Additive fixup
 */

#define NRADD		0x04		/* Additive fixup */
#define NRRTYP		0x03		/* Reference type mask */
#define NRRINT		0x00		/* Internal reference */
#define NRRORD		0x01		/* Import by ordinal */
#define NRRNAM		0x02		/* Import by name */
#define NRROSF		0x03		/* Operating system fixup */
#define OSFIXUP		NRROSF

/* Resource type or name string */
struct rsrc_string {
    char rs_len;	    /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

/* XLATOFF */
#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string
/* XLATON */

/* Resource type information block */
struct rsrc_typeinfo {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

/* XLATOFF */
#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc
/* XLATON */

/* Resource name information block */
struct rsrc_nameinfo {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are	      */
    unsigned short rn_offset;	/* file offset to resource data */
    unsigned short rn_length;	/* length of resource data */
    unsigned short rn_flags;	/* resource flags */
    unsigned short rn_id;	/* resource name id */
    unsigned short rn_handle;	/* If loaded, then global handle */
    unsigned short rn_usage;	/* Initially zero.  Number of times */
				/* the handle for this resource has */
				/* been given out */
    };

/* XLATOFF */
#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage
/* XLATON */

#define RSORDID	    0x8000	/* if high bit of ID set then integer id */
				/* otherwise ID is offset of string from
				   the beginning of the resource table */

				/* Ideally these are the same as the */
				/* corresponding segment flags */
#define RNMOVE	    0x0010	/* Moveable resource */
#define RNPURE	    0x0020	/* Pure (read-only) resource */
#define RNPRELOAD   0x0040	/* Preloaded resource */
#define RNDISCARD   0x1000	/* Discard priority level for resource */
#define	RNLOADED    0x0004	/* True if handler proc return handle */

#define RNUNUSED    0x0EF8B	/* Unused resource flags */

/* XLATOFF */
/* Resource table */
struct new_rsrc {
    unsigned short rs_align;	/* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align
/* XLATON */

/* ASM
new_rsrc        struc
rs_align        dw ?
new_rsrc        ends

entfixed        struc
entflags        db  ?
entoffset       dw  ?
entfixed        ends

pent		struc
penttype	db  ?
pentflags	db  ?
pentsegno	db  ?
pentoffset	dw  ?
pent		ends

pm_entstruc	struc
pm_entstart	dw	?
pm_entend	dw	?
pm_entnext	dw	?
pm_entstruc	ends

ENT_UNUSED	= 000h
ENT_ABSSEG      = 0FEh
ENT_MOVEABLE    = 0FFh
ENT_PUBLIC      = 001h
ENT_DATA        = 002h
INTOPCODE       = 0CDh

savedCS = 4
savedIP = 2
savedBP = 0
savedDS = -2
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\oakdefs.h ===
/*++

Copyright (C) 1997 Cisco Systems, Inc.  All Rights Reserved.

Module Name:

    oakrpc.h

Abstract:

    This module contains the definitions requires for the
	ISAKMP/Oakley RPC interface.

Author:

	Derrell Piper (v-dpiper)

Facility:

    ISAKMP/Oakley

Revision History:

--*/
#ifndef __OAKRPC
#define __OAKRPC

typedef unsigned long IPADDR, *PIPADDR;
typedef LARGE_INTEGER COOKIE, *PCOOKIE;
typedef unsigned long SPI, *PSPI;

/* Oakley hash algorithms */
#define OAK_MD5 1
#define OAK_SHA 2
#define OAK_TIGER 3

/* Oakley pseudo-random functions */
#define OAK_3DES_CBC_MAC 1

/* Oakley authentication methods */
// See oakrpc.idl

/* Oakley Flags */
#define IPSEC_ALLOW_SOFT_SA 0x00000001
#define IPSEC_TUNNEL_MODE 0x00000002
#define IPSEC_DEFAULT_POLICY 0x00000004
#define IPSEC_POLICY_TOO_GENERAL 0x00000008
#define IPSEC_POLICY_CLEAR 0x00000010
#define IPSEC_POLICY_BLOCK 0x00000020


#define None 0
#define Auth 1
#define Encypt 2


// Status flags

#define STATUS_MM 0x1
#define STATUS_QM 0x2
#define STATUS_ME 0x4
#define STATUS_PEER 0x8

/* Oakley encryption algorithms */
#define OAK_DES_CBC 1
#define OAK_IDEA_CBC 2
#define OAK_BLOWFISH_CBC 3
#define OAK_RC5_R12_B64_CBC 4
#define OAK_3DES_CBC 5
#define OAK_CAST_CBC 6

#define OAK_MM_NO_STATE 0
#define OAK_MM_SA_SETUP 1
#define OAK_MM_KEY_EXCH 2
#define OAK_MM_KEY_AUTH 3

#define OAK_AG_NO_STATE 4
#define OAK_AG_INIT_EXCH 5
#define OAK_AG_AUTH 6

#define OAK_QM_SA_ACCEPT 7
#define OAK_QM_AUTH_AWAIT 8
#define OAK_QM_IDLE 9

typedef DWORD OAKLEY_STATE;

/* Oakley states */

#define OAK_MM_NO_STATE			0
#define OAK_MM_SA_SETUP			1
#define OAK_MM_KEY_EXCH			2
#define OAK_MM_KEY_AUTH			3

#define OAK_AG_NOSTATE			4
#define OAK_AG_INIT_EXCH		5
#define OAK_AG_AUTH				6

#define OAK_QM_SA_ACCEPT		7
#define OAK_QM_AUTH_AWAIT		8
#define OAK_QM_IDLE				9
#define OAK_QM_CONNECT_WAIT		10

#define OAK_MAX_PHASE1_OFFERS	100
#define OAK_MAX_PHASE2_OFFERS	1000


/* generic crypto lifetime */
typedef struct _Lifetime {
	DWORD		KBytes;
    DWORD		Seconds;
} OAKLEY_LIFETIME, *POAKLEY_LIFETIME;

/* generic algorithm descriptor */
typedef struct _Algorithm {
	ULONG	AlgorithmIdentifier;
	ULONG	KeySize;
	ULONG	Rounds;
} OAKLEY_ALGORITHM, *POAKLEY_ALGORITHM;

#define CRYPTO_VERSION_MAJOR 1		/* MajorVersion */
#define CRYPTO_VERSION_MINOR 0		/* MinorVersion */

#define MAX_ALGOS 3              //comp,ah,esp

typedef struct _CryptoBundle {
    BYTE		MajorVersion;
    BYTE		MinorVersion;
    OAKLEY_ALGORITHM	EncryptionAlgorithm;
    OAKLEY_ALGORITHM	HashAlgorithm;
    OAKLEY_ALGORITHM	PseudoRandomFunction;
    BYTE		AuthenticationMethod;
    DWORD		OakleyGroup;
    DWORD		QuickModeLimit;
    OAKLEY_LIFETIME	Lifetime;
    BOOL		PfsIdentityRequired;
} CRYPTO_BUNDLE, *PCRYPTO_BUNDLE;

typedef struct _IsakmpPolicy {
    GUID		PolicyId;
    BOOL		IdentityProtectionRequired;
    BOOL		PfsIdentityRequired;
    DWORD		ThreadingFactor;
    DWORD		AcquireLimit;
    DWORD		ReceiveLimit;
    DWORD		AcquireSize;
    DWORD		ReceiveSize;
    DWORD		ReaperInterval;
    DWORD		RpcMaxCalls;
    DWORD		RetryInterval;
    DWORD		RetryLimit;
} ISAKMP_POLICY, *PISAKMP_POLICY;

typedef struct {
	GUID       	PolicyId;
	DWORD      	Version;
	DWORD      	RefreshInterval;
	IPADDR		TunnelAddress;
	BOOL		PfsQMRequired;
} IPSEC_POLICY, *PIPSEC_POLICY; 

typedef struct _IsakmpStatistics {
    DWORD		ActiveAcquire;
    DWORD		ActiveReceive;
	DWORD		ActiveSend;
	DWORD		AcquireFail;
	DWORD		ReceiveFail;
	DWORD		SendFail;
	DWORD		AcquireHeapSize;
	DWORD		ReceiveHeapSize;
	DWORD		SendHeapSize;
    DWORD		NegotiationFailures;
    DWORD		AuthenticationFailures;
    DWORD		InvalidCookiesReceived;
	DWORD		TotalAcquire;
	DWORD		TotalGetSpi;
	DWORD		TotalKeyAdd;
	DWORD		TotalKeyUpdate;
	DWORD		GetSpiFail;
	DWORD		KeyAddFail;
	DWORD		KeyUpdateFail;
	DWORD		IsadbListSize;
	DWORD		ConnListSize;
    DWORD		OakleyMainModes;
    DWORD		OakleyQuickModes;
    DWORD		OakleyAggressiveModes;
    DWORD		OakleyNewGroupModes;
	DWORD		DeadAssociations;
	DWORD		InactiveAssociations;
    DWORD       SoftAssociations;
} ISAKMP_STATISTICS, *PISAKMP_STATISTICS;

typedef struct _CookiePair {
    COOKIE		Inbound;
	COOKIE		Outbound;
} COOKIE_PAIR, *PCOOKIE_PAIR;

typedef struct _SpiPair {
    SPI			Inbound;
	SPI			Outbound;
} SPI_PAIR, *PSPI_PAIR;

typedef struct _IsakmpSa {
    GUID		PolicyId;
    COOKIE_PAIR	Spi;
    IPADDR		Source;
    IPADDR		Destination;
    BOOL		IdentityProtectionUsed;
    BOOL		PerfectForwardSecrecyUsed;
    CRYPTO_BUNDLE CryptoSelected;
    OAKLEY_STATE CurrentState;
} ISAKMP_SA, *PISAKMP_SA;

typedef struct _IpsecSa {
    GUID		PolicyId;
    SPI_PAIR	Spi;
    IPADDR		Source;
    IPADDR		Destination;
    IPADDR		Tunnel;
    OAKLEY_ALGORITHM	ConfidentialityAlgorithm;
    OAKLEY_ALGORITHM	IntegrityAlgorithm;
    OAKLEY_STATE CurrentState;
} IPSEC_SA, *PIPSEC_SA;

typedef struct  _IPSEC_ALGO_INFO {
    ULONG   algoIdentifier;     // ESP_ALGO or AH_ALGO
    ULONG   secondaryAlgoIdentifier;   // for hmac in ESP case
    ULONG   operation;       // of type OPERATION_E (ipsec.h)	  
    ULONG   algoKeylen;         // len in bytes
    ULONG   algoRounds;         // # of algo rounds
} IPSEC_ALGO_INFO, *PIPSEC_ALGO_INFO;


typedef struct {
    LIFETIME	        Lifetime;
    DWORD		Flags;
    BOOL		PfsQMRequired;
    DWORD               Count;  //Number of Algos
    IPSEC_ALGO_INFO     Algos[MAX_ALGOS];
} IPSEC_ALG_TYPE, *PIPSEC_ALG_TYPE;

typedef enum _AuthenicationEnum {	
	OAK_PRESHARED_KEY	= 1,
	OAK_DSS_SIGNATURE	= 2,
	OAK_RSA_SIGNATURE	= 3,
	OAK_RSA_ENCRYPTION	= 4,
	OAK_SSPI	= 5
}AuthenticationEnum ;

typedef enum _DeleteMessage {
	SA_DELETE,
	SA_REKEY
} DeleteMessage;



#endif /* __OAKRPC */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\objselp.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       objselp.h
//
//  Contents:   Object Picker Dialog private header
//
//---------------------------------------------------------------------------

#include <objbase.h>

DEFINE_GUID(IID_IObjectPickerScope,
0xe8f3a4c4, 0x9e62, 0x11d1, 0x8b, 0x22, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7);

DEFINE_GUID(IID_IDsObjectPickerScope,
0xd8150286, 0x9e64, 0x11d1, 0x8b, 0x22, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7);

DEFINE_GUID(IID_IBindHelper,
0x29b3711c, 0xa6fd, 0x11d1, 0x8b, 0x23, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7);

DEFINE_GUID(IID_ICustomizeDsBrowser,
0x58dc8834, 0x9d9f, 0x11d1, 0x8b, 0x22, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7);

DEFINE_GUID(IID_IObjectBrowser,
0x35920279, 0xee67, 0x11d0, 0x80, 0x93, 0x00, 0xc0, 0x4f, 0xd8, 0xe1, 0xda);

DEFINE_GUID(IID_IDsObjectPickerEx,
0xa4e86007, 0x62e4, 0x11d2, 0xae, 0x51, 0x00, 0xc0, 0x4f, 0x79, 0xdb, 0x19);

#ifndef __OBJSELP_H_
#define __OBJSELP_H_

#ifndef __iads_h__
#include <iads.h>
#endif // __iads_h__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


typedef struct tagDSQUERYINFO
{
    ULONG               cbSize;
    LPCWSTR             pwzLdapQuery;
    ULONG               cFilters;
    LPCWSTR            *apwzFilter;
    LPCWSTR             pwzCaption;
} DSQUERYINFO, *PDSQUERYINFO;



//
// Private Object Picker Interfaces
//

#undef INTERFACE
#define INTERFACE IObjectPickerScope

DECLARE_INTERFACE_(IObjectPickerScope, IUnknown)
{
    // *** IUnknown methods ***

    STDMETHOD(QueryInterface)(THIS_
                              REFIID riid,
                              PVOID *ppv) PURE;

    STDMETHOD_(ULONG,AddRef)(THIS) PURE;

    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IObjectPickerScope methods ***

    STDMETHOD_(HWND, GetHwnd)(THIS) PURE;

    STDMETHOD(SetHwnd)(THIS_
                HWND hwndScopeDialog) PURE;
};

#undef INTERFACE
#define INTERFACE IDsObjectPickerScope


DECLARE_INTERFACE_(IDsObjectPickerScope, IObjectPickerScope)
{
    // *** IUnknown methods ***

    STDMETHOD(QueryInterface)(THIS_
                REFIID   riid,
                LPVOID * ppv) PURE;

    STDMETHOD_(ULONG,AddRef)(THIS) PURE;

    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IObjectPickerScope methods ***

    STDMETHOD_(HWND, GetHwnd)(THIS) PURE;

    STDMETHOD(SetHwnd)(THIS_
                HWND hwndScopeDialog) PURE;

    // *** IDsObjectPickerScope methods ***

    STDMETHOD_(ULONG,GetType)(THIS) PURE;

    STDMETHOD(GetQueryInfo)(THIS_
                PDSQUERYINFO *ppqi) PURE;

    STDMETHOD_(BOOL, IsUplevel)(THIS) PURE;

    STDMETHOD_(BOOL, IsDownlevel)(THIS) PURE;

    STDMETHOD_(BOOL, IsExternalDomain)(THIS) PURE;

    STDMETHOD(GetADsPath)(THIS_
                PWSTR *ppwzADsPath) PURE;
};


#undef INTERFACE
#define INTERFACE IBindHelper

DECLARE_INTERFACE_(IBindHelper, IUnknown)
{
    // *** IUnknown methods ***

    STDMETHOD(QueryInterface)(THIS_
                REFIID   riid,
                LPVOID * ppv) PURE;

    STDMETHOD_(ULONG,AddRef)(THIS) PURE;

    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBindHelper methods ***

    STDMETHOD(BindToObject)(THIS_
                HWND    hwnd,
                PCWSTR pwzADsPath,
                REFIID riid,
                LPVOID *ppv,
                ULONG  flags) PURE;

    STDMETHOD(GetNameTranslate)(THIS_
                HWND                hwnd,
                PCWSTR              pwzADsPath,
                IADsNameTranslate **ppNameTranslate) PURE;

    STDMETHOD(GetDomainRootDSE)(THIS_
                HWND    hwnd,
                PCWSTR pwzDomain,
                IADs **ppADsRootDSE) PURE;
};



#undef INTERFACE
#define INTERFACE ICustomizeDsBrowser

DECLARE_INTERFACE_(ICustomizeDsBrowser, IUnknown)
{
    // *** IUnknown methods ***

    STDMETHOD(QueryInterface)(THIS_
                REFIID   riid,
                LPVOID * ppv) PURE;

    STDMETHOD_(ULONG,AddRef)(THIS) PURE;

    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** ICustomizeDsBrowser methods ***

    STDMETHOD(Initialize)(THIS_
                          HWND         hwnd,
                          PCDSOP_INIT_INFO pInitInfo,
                          IBindHelper *pBindHelper) PURE;

    STDMETHOD(GetQueryInfoByScope)(THIS_
                IDsObjectPickerScope *pDsScope,
                PDSQUERYINFO *ppdsqi) PURE;

    STDMETHOD(AddObjects)(THIS_
                IDsObjectPickerScope *pDsScope,
                IDataObject **ppdo) PURE;

    STDMETHOD(ApproveObjects)(THIS_
                IDsObjectPickerScope *pDsScope,
                IDataObject *pdo,
                PBOOL afApproved) PURE;

    STDMETHOD(PrefixSearch)(THIS_
                IDsObjectPickerScope *pDsScope,
                PCWSTR pwzSearchFor,
                IDataObject **pdo) PURE;

    STDMETHOD_(PSID, LookupDownlevelName)(THIS_
        PCWSTR pwzAccountName) PURE;
};


#undef INTERFACE
#define INTERFACE IDsObjectPickerEx

DECLARE_INTERFACE_(IDsObjectPickerEx, IDsObjectPicker)
{
    // *** IUnknown methods ***

    STDMETHOD(QueryInterface)(THIS_
                REFIID   riid,
                LPVOID * ppv) PURE;

    STDMETHOD_(ULONG,AddRef)(THIS) PURE;

    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDsObjectPicker methods ***

    // Sets scope, filter, etc. for use with next invocation of dialog
    STDMETHOD(Initialize)(
        THIS_
        PDSOP_INIT_INFO pInitInfo) PURE;

    // Creates the modal DS Object Picker dialog.
    STDMETHOD(InvokeDialog)(
         THIS_
         HWND               hwndParent,
         IDataObject      **ppdoSelections) PURE;

    // *** IDsObjectPickerEx methods ***

    // Creates the modal DS Object Picker dialog.
    STDMETHOD(InvokeDialogEx)(
         THIS_
         HWND                   hwndParent,
         ICustomizeDsBrowser   *pCustomizeDsBrowser,
         IDataObject          **ppdoSelections) PURE;
};


//
// Private scope types
//

#define DSOP_SCOPE_TYPE_INVALID                        0x00000000
#define DSOP_SCOPE_TYPE_SEPARATOR                      0x00100000

//
// Private clipboard formats supported by CDataObject
//

#define CFSTR_DSOP_DS_OBJECT_LIST     TEXT("CFSTR_DSOP_DS_OBJECT_LIST")

//
// Object Picker Structures
//

typedef struct tagSELECTIONITEM
{
    ULONG   cbNameOffset;       // Offset to the item name
    ULONG   cbData;             // Item-specific data size
    ULONG   cbDataOffset;       // Offset to item-specific data
} SELECTIONITEM, *PSELECTIONITEM;

typedef const struct tagSELECTIONITEM * PCSELECTIONITEM;

typedef struct tagSELECTIONITEMLIST
{
    ULONG        cbSize;                // size in bytes, including cbSize
    ULONG        cItems;                // Selection count
    SELECTIONITEM rgItems[ANYSIZE_ARRAY];
} SELECTIONITEMLIST, * PSELECTIONITEMLIST;

typedef const struct tagSELECTIONITEMLIST * PCSELECTIONITEMLIST;

typedef struct tagOBJECTPICKERINFO *POBJECTPICKERINFO;

typedef struct tagOBJECTBROWSEINIT
{
    HWND hwndFrame;
    HWND hwndComboBoxEx;
    POBJECTPICKERINFO popi;
} OBJECTBROWSEINIT, *POBJECTBROWSEINIT;


//
// Private Object Picker Interfaces
//


#undef INTERFACE
#define INTERFACE IObjectBrowser

DECLARE_INTERFACE_(IObjectBrowser, IUnknown)
{
    // *** IUnknown methods ***

    STDMETHOD(QueryInterface)(THIS_
                REFIID   riid,
                LPVOID * ppv) PURE;

    STDMETHOD_(ULONG,AddRef)(THIS) PURE;

    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IObjectBrowser methods ***

    STDMETHOD(Initialize)(THIS_
                POBJECTBROWSEINIT pInit) PURE;

    STDMETHOD(CreateView)(THIS_
                HWND hwndParent,
                IObjectPickerScope *pScope) PURE;

    STDMETHOD(DeleteScope)(THIS_
                IObjectPickerScope *pScope) PURE;
};




typedef struct tagOBJECTPICKERINFO
{
    ULONG               cbSize;             // Struct size
    HWND                hwndParent;         // Parent window
    ULONG               flObjectPicker;     // OP_* flags
    LPCTSTR             pwzCaption;         // Dialog caption
    IObjectBrowser     *pBrowser;           // browse view manager
    LPVOID              pvSelection;        // selection view template/name
    DLGPROC             pSelectDlgProc;     // selection dialog procedure
    LPARAM              lParamSelectInit;   // for CreateDialogParam
    HINSTANCE           hInstance;          // location for resources
    IDataObject        *pDataObject;        // holds selection on return
} OBJECTPICKERINFO;


//
// Private Object Picker Messages
//


#define OPM_BASE                   (WM_USER + 400)
#define OPM_SHOW                   (OPM_BASE + 0)  // show or hide browse
#define OPM_GET_SELECTION          (OPM_BASE + 1)  // create data object
#define OPM_GET_CUR_SCOPE          (OPM_BASE + 2)  // return cur IObjectPickerScope
#define OPM_BROWSE_DOUBLE_CLICK    (OPM_BASE + 3)  // user dbl clicked in browser
#define OPM_QUERY_CLOSE            (OPM_BASE + 4)  // is it ok to close?
#define OPM_GET_ICON               (OPM_BASE + 5)  // get icon for item
#define OPM_REFRESH_SCOPE          (OPM_BASE + 6)  // sent after setcursel
#define OPM_BROWSER_HAS_SELECTION  (OPM_BASE + 7) // notification fromo browser, t/f
#define OPM_GET_SCOPE_HWND         (OPM_BASE + 8) // return hwnd of scope combo
#define OPM_ENABLE_OK              (OPM_BASE + 9) // enable/disable OK button
#define OPM_CLOSING                (OPM_BASE + 10) // notification of dialog closing
#define OPM_DELETE_SCOPE           (OPM_BASE + 11) // delete lookin combo item

//
// Private DS Object Picker Messages
//

#define DSOPM_BASE                      (WM_USER + 500)
#define DSOPM_NEWBLOCK                  (DSOPM_BASE + 0)
#define DSOPM_QUERY_DONE                (DSOPM_BASE + 1)
#define DSOPM_PROMPT_FOR_CREDS          (DSOPM_BASE + 2)
#define DSOPM_GET_BROWSE_MGR            (DSOPM_BASE + 3)

//
// Private API
//

STDAPI
GetObjectSelection(
    POBJECTPICKERINFO popi);


//
// Private Bit flags for flObjectPicker
//

#define OP_MULTISELECT                          0x00000001  // show selection bucket dialog
#define OP_SELECTION_TEMPLATE                   0x00000002  // use CreateDialogIndirect
#define OP_SELECTION_TEMPLATE_NAME              0x00000004  // use CreateDialog
#define OP_SELECTION_TEMPLATE_DEFAULT           0x00000008  // use built-in selection template

//
// Private typedefs and ordinals for use with LoadLibrary
//

#define GETOBJECTSELECTION_ORDINAL      1

typedef HRESULT (STDAPICALLTYPE *PFN_GetObjectSelection)(POBJECTPICKERINFO);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __OBJSELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\packon.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packon.h

Abstract:

    This file turns packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    The file packoff.h is the complement to this file.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack(1)                 // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\packoff.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packoff.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    packoff.h is the complement to packon.h.  An inclusion of packoff.h
    MUST ALWAYS be preceded by an inclusion of packon.h, in one-to-one
    correspondence.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack()
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\prefix.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Prefix.h

Abstract:

    This header file declares equates for debug print "prefix" strings.
    For the moment, these are of the form:

        #define PREFIX_NETLIB     "NETLIB: "

    These are collected into a header file in case someone decides to
    change the look of these strings, or internationalize them, or
    whatever.

Author:

    John Rogers (JohnRo) 08-May-1992

Environment:

    Portable to just about any computer I ever saw.  --JR

Revision History:

    08-May-1992 JohnRo
        Created.
    27-May-1992 JohnRo
        Added PREFIX_SC and PREFIX_SC_CLIENT for service controller.
        Added PREFIX_PORTUAS for PortUAS utility (run during setup).
    07-Aug-1992 JohnRo
        RAID 1895: Net APIs and svc should use OEM char set (not ANSI).
        (Added PREFIX_XACTSRV as part of support for that.)
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.

--*/


#ifndef _PREFIX_
#define _PREFIX_


#define PREFIX_NETAPI       "NETAPI32: "
#define PREFIX_NETLIB       "NETLIB: "
#define PREFIX_NETLOGON     "NETLOGON: "
#define PREFIX_NETRAP       "NETRAP: "
#define PREFIX_PORTUAS      "PORTUAS: "
#define PREFIX_REPL         "REPL: "
#define PREFIX_REPL_CLIENT  "REPL-CLIENT: "
#define PREFIX_REPL_MASTER  "REPL-MASTER: "
#define PREFIX_SC           "SC: "
#define PREFIX_SC_CLIENT    "SC-CLIENT: "
#define PREFIX_WKSTA        "WKSTA: "
#define PREFIX_XACTSRV      "XACTSRV: "



#endif // ndef _PREFIX_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\oldcrypt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

--*/

#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsubauth

#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;

#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
// end_ntsubauth

#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

// begin_ntsubauth
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
// end_ntsubauth



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

// begin_ntsubauth
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
// end_ntsubauth



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

// begin_ntsubauth
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
// end_ntsubauth


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

// begin_ntsubauth
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
// end_ntsubauth


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
// begin_ntsubauth
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;
// end_ntsubauth


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033
#define RtlGetUserSessionKeyClientBinding SystemFunction034
#define RtlCheckSignatureInFile         SystemFunction035


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

ULONG
RtlCheckSignatureInFile(
    IN PWSTR File
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\olechar.h ===
//+======================================================
//
//  File:       olechar.h
//
//  Purpose:    Provide wrappers for string-related
//              functions so that the Ansi or Unicode function
//              is called, whichever is appropriate for the
//              current OLECHAR definition.
//
//              This file is similar to "tchar.h", except
//              that it covers OLECHARs rather than TCHARs.
//
//+======================================================


#ifndef _OLECHAR_H_
#define _OLECHAR_H_

//#include <objbase.h>

#ifdef OLE2ANSI

#   ifdef _MAC
#       define ocslen      strlen
#       define ocscpy      strcpy
#       define ocscmp      strcmp
#       define ocscat      strcat
#       define ocschr      strchr
#       define soprintf    sprintf
#       define oprintf     printf
#       define ocsnicmp    _strnicmp
#   else
#       define ocslen      lstrlenA
#       define ocscpy      lstrcpyA
#       define ocscmp      lpstrcmpA
#       define ocscat      lpstrcatA
#       define ocschr      strchr
#       define soprintf    sprintf
#       define oprintf     printf
#       define ocsnicmp    _strnicmp
#   endif

    // "Unsigned Long to OLESTR"
#   define ULTOO(value,string,radix)  _ultoa( (value), (string), (radix) )

#else // !OLE2ANSI

                        // BUGBUG: In the #else below, restore wcslen to
                        // lstrlenW when property code is  moved from NTDLL
                        // to OLE32.
#   ifdef IPROPERTY_DLL
#       define ocslen      wcslen //lstrlenW
#       define ocscpy      wcscpy
#       define ocscmp      wcscmp
#       define ocscat      wcscat
#       define ocschr      wcschr
#       define ocsnicmp    _wcsnicmp
#       define soprintf    swprintf
#       define oprintf     wprintf
#       define ocsnicmp    _wcsnicmp
#       define ocsstr      wcsstr
#   else
#       define ocslen      wcslen //lstrlenW
#       define ocscpy      lstrcpyW
#       define ocscmp      lstrcmpW
#       define ocscat      lstrcatW
#       define ocschr      wcschr
#       define ocsnicmp    _wcsnicmp
#       define soprintf    swprintf
#       define oprintf     wprintf
#       define ocsnicmp    _wcsnicmp
#       define ocsstr      wcsstr
#   endif

    // "Unsigned Long to OLESTR"
#   define ULTOO(value,string,radix)  _ultow( (value), (string), (radix) )

#endif // !OLE2ANSI

#endif // !_OLECHAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\soundcfg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1990  Microsoft Corporation

Module Name:

    soundcfg.h

Abstract:

    This include file defines common strings and values for sound driver
	configuration.

Author:

    Robin Speed (RobinSp) 17-Oct-92

Revision History:
--*/

#define SOUND_REG_PORT (L"Port")
#define SOUND_REG_DMACHANNEL (L"DmaChannel")
#define SOUND_REG_INTERRUPT (L"Interrupt")
#define SOUND_REG_INPUTSOURCE (L"Input Source")
#define SOUND_REG_DMABUFFERSIZE (L"Dma Buffer Size")
#define SOUND_REG_CONFIGERROR (L"Configuration Error")
#define SOUND_REG_LOADTYPE (L"Load Type")
#define SOUND_REG_PNPDEVICE (L"PnP Device")

    //
    //  Values for Load Type
    //

    #define SOUND_LOADTYPE_NORMAL  0x00
    #define SOUND_LOADTYPE_CONFIG  0x01  // Fail load but return config data

#define SOUND_REG_SYNTH_TYPE (L"Synth Type")

    //
    //  Values for synth type
    //

    #define SOUND_SYNTH_TYPE_ADLIB  0x01
    #define SOUND_SYNTH_TYPE_OPL3   0x02
    #define SOUND_SYNTH_TYPE_NONE   0x03

#define SOUND_MIXER_SETTINGS_NAME (L"Mixer Settings")


//
// Errors
//

#define SOUND_CONFIG_ERROR      0x00000000
#define SOUND_CONFIG_OK         0xFFFFFFFF
#define SOUND_CONFIG_NOCARD     0x00000001
#define SOUND_CONFIG_BADINT     0x00000002
#define SOUND_CONFIG_BADDMA     0x00000003
#define SOUND_CONFIG_BADCARD    0x00000004
#define SOUND_CONFIG_RESOURCE   0x00000005

#define SOUND_CONFIG_BADPORT    0x00000006
#define SOUND_CONFIG_PORT_INUSE 0x00000007
#define SOUND_CONFIG_DMA_INUSE  0x00000008
#define SOUND_CONFIG_INT_INUSE  0x00000009

#define SOUND_CONFIG_NOINT      0x0000000A
#define SOUND_CONFIG_NODMA      0x0000000B


#define PARMS_SUBKEY                  L"Parameters"
#define SOUND_DEVICES_SUBKEY          L"Devices"
#define SOUND_DRIVER_PARMS            L"DriverParameters"

#define REG_VALUENAME_LEFTMASTER      L"LeftMasterVolumeAtten"
#define REG_VALUENAME_RIGHTMASTER     L"RightMasterVolumeAtten"
#define REG_VALUENAME_LEFTLINEIN      L"LeftLineInAtten"
#define REG_VALUENAME_RIGHTLINEIN     L"RightLineInAtten"
#define REG_VALUENAME_LEFTDAC         L"LeftDACAtten"
#define REG_VALUENAME_RIGHTDAC        L"RightDACAtten"
#define REG_VALUENAME_LEFTMICMIX      L"LeftMicMixAtten"
#define REG_VALUENAME_RIGHTMICMIX     L"RightMicMixAtten"
#define REG_VALUENAME_LEFTADC         L"LeftADCAtten"
#define REG_VALUENAME_RIGHTADC        L"RightADCAtten"
#define REG_VALUENAME_LEFTSYNTH       L"LeftSynthAtten"
#define REG_VALUENAME_RIGHTSYNTH      L"RightSynthAtten"


//
// Input source selection
//

#define INPUT_LINEIN            0
#define INPUT_AUX               1
#define INPUT_MIC               2
#define INPUT_OUTPUT            3

//
// Default volume settings on initial install
//

#define DEF_ADC_VOLUME    0x24000000
#define DEF_DAC_VOLUME    0x24000000
#define DEF_SYNTH_VOLUME  0x24000000
#define DEF_AUX_VOLUME    0x24000000
#define DEF_MICMIX_VOLUME 0x00000000

/****************************************************************************

 Device Types

 ***************************************************************************/

//
// Device type flags used in the local info structure
//

#define WAVE_IN             0x01    // Wave in device
#define WAVE_OUT            0x02    // Wave out device
#define MIDI_IN             0x03    // Midi in device
#define MIDI_OUT            0x04    // Midi out device
#define AUX_DEVICE          0x05    // aux device
#define MIXER_DEVICE        0x06    // Mixer device
#define SYNTH_DEVICE        0x07    // Synth device (adlib or opl3)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\protocol.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    protocol.h

Abstract:

    This file defines the protocol specific constants for NT Lanman


Author:

    Larry Osterman (larryo) 5-Apr-1991

Revision History:

    5-Apr-1991  LarryO

        Created from LANMAN 1.2 protocol header.

--*/


#ifndef _PROTOCOL_
#define _PROCOTOL_

//
//
//      Define protocol names
//
//


//
//      PCNET1 is the original SMB protocol (CORE).
//

#define PCNET1          "PC NETWORK PROGRAM 1.0"

//
//      Some versions of the original MSNET defined this as an alternate
//      to the core protocol name
//

#define PCLAN1          "PCLAN1.0"

//
//      This is used for the MS-NET 1.03 product.  It defines Lock&Read,
//      Write&Unlock, and a special version of raw read and raw write.
//
#define MSNET103        "MICROSOFT NETWORKS 1.03"

//
//      This is the  DOS Lanman 1.0 specific protocol.  It is equivilant
//      to the LANMAN 1.0 protocol, except the server is required to
//      map errors from the OS/2 error to an appropriate DOS error.
//
#define MSNET30         "MICROSOFT NETWORKS 3.0"

//
//      This is the first version of the full LANMAN 1.0 protocol, defined in
//      the SMB FILE SHARING PROTOCOL EXTENSIONS VERSION 2.0 document.
//

#define LANMAN10        "LANMAN1.0"

//
//      This is the first version of the full LANMAN 2.0 protocol, defined in
//      the SMB FILE SHARING PROTOCOL EXTENSIONS VERSION 3.0 document.  Note
//      that the name is an interim protocol definition.  This is for
//      interoperability with IBM LAN SERVER 1.2
//

#define LANMAN12        "LM1.2X002"

//
//      This is the dos equivilant of the LANMAN12 protocol.  It is identical
//      to the LANMAN12 protocol, but the server will perform error mapping
//      to appropriate DOS errors.
//
#define DOSLANMAN12     "DOS LM1.2X002" /* DOS equivalant of above.  Final
                                         * string will be "DOS LANMAN2.0" */

//
//      Strings for LANMAN 2.1.
//
#define LANMAN21 "LANMAN2.1"
#define DOSLANMAN21 "DOS LANMAN2.1"

//
//       !!! Do not set to final protcol string until the spec
//           is cast in stone.
//
//       The SMB protocol designed for NT.  This has special SMBs
//       which duplicate the NT semantics.
//
#define NTLANMAN "NT LM 0.12"

//
// The Cairo dialect
//
//
#define CAIROX   "Cairo 0.xa"


//
//      The XENIXCORE dialect is a bit special.  It is identical to core,
//      except user passwords are not to be uppercased before being shipped
//      to the server
//
#define XENIXCORE       "XENIX CORE"


//
//      Windows for Workgroups V1.0
//
#define WFW10           "Windows for Workgroups 3.1a"


#define PCNET1_SZ       22
#define PCLAN1_SZ        8

#define MSNET103_SZ     23
#define MSNET30_SZ      22

#define LANMAN10_SZ      9
#define LANMAN12_SZ      9

#define DOSLANMAN12_SZ  13



/*
 * Defines and data for Negotiate Protocol
 */
#define PC1             0
#define PC2             1
#define LM1             2
#define MS30            3
#define MS103           4
#define LM12            5
#define DOSLM12         6


/*  Protocol indexes definition.  */
#define PCLAN           1               /* PC Lan 1.0 & MS Lan 1.03 */
#define MSNT30          2               /* MS Net 3.0 redirector    */
#define DOSLM20         3               /* Dos LAN Manager 2.0      */
#define LANMAN          4               /* Lanman redirector        */
#define LANMAN20        5               /* Lan Manager 2.0          */

//
//  Protocol specific path constraints.
//

#define MAXIMUM_PATHLEN_LANMAN12        260
#define MAXIMUM_PATHLEN_CORE            128

#define MAXIMUM_COMPONENT_LANMAN12      254
#define MAXIMUM_COMPONENT_CORE          8+1+3 // 8.3 filenames.


/*NOINC*/
/*  CLTYPE_BASE should specify the name the first string in the file
    apperr2.h.  NUM_CLTYPES should be equal to the index of the last
    protocol just as is the case with the above definitions.  Also,
    this part should be ifdef'd so that only the files that also include
    the apperr2.h header will have it defined.  */

#ifdef APE2_CLIENT_DOWNLEVEL

#define CLTYPE_BASE     APE2_CLIENT_DOWNLEVEL
#define NUM_CLTYPES     LANMAN20

#endif

#endif  // _PROTOCOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\riname.c ===
static PWSTR cszFirst = L"First";
static PWSTR cszLast  = L"Last";
static PWSTR cszUserName = L"Username";
static PWSTR cszMAC   = L"MAC";

static const int iFirst = (sizeof(L"First") / sizeof(WCHAR)) - 1;
static const int iLast  = (sizeof(L"Last" ) / sizeof(WCHAR)) - 1;
static const int iUserName = (sizeof(L"Username") / sizeof(WCHAR)) - 1;
static const int iMAC   = (sizeof(L"MAC"  ) / sizeof(WCHAR)) - 1;

#define STRING_MISSING(_x) (((_x) == NULL) || (*(_x) == 0))

DWORD
GenerateNameFromTemplate (
    IN PWSTR Template,
    IN PGENNAME_VARIABLES Variables,
    IN PWSTR Name,
    IN DWORD NameLength,
    OUT PWSTR *MissingVariable OPTIONAL,
    OUT BOOL *UsedCounter OPTIONAL,
    OUT DWORD *MaximumGeneratedNameLength OPTIONAL
    )
{
    DWORD error;
    DWORD maxLength;
    DWORD fieldLength;
    WCHAR localString[10];
    PWSTR pTemplate;
    PWSTR pOutput;
    PWSTR pOutputEnd;
    PWSTR stringToAdd;
    PWSTR pString;
    BOOL usedUserName;

    pTemplate = Template;
    pOutput = Name;
    pOutputEnd = pOutput + NameLength - 1;

    error = GENNAME_NO_ERROR;
    maxLength = 0;
    usedUserName = FALSE;
    if ( UsedCounter != NULL ) {
        *UsedCounter = FALSE;
    }

    while ( *pTemplate != 0 ) {

        if ( *pTemplate == L'%' ) {

            pTemplate++;
            fieldLength = 0;

            if ( *pTemplate >= L'0' && *pTemplate <= L'9' ) {

                do {
                    fieldLength = (fieldLength * 10) + (*pTemplate - L'0');
                    pTemplate++;
                } while ( *pTemplate >= L'0' && *pTemplate <= L'9' );
            }

            if ( *pTemplate == L'#' ) {

                DWORD maxCounter;
                DWORD counter;
                DWORD i;

                if (fieldLength > 9) {
                    fieldLength = 9;
                }
                if (fieldLength == 0) {
                    fieldLength = 2;
                }

                maxCounter = 10;
                for ( i = 1; i < fieldLength; i++ ) {
                    maxCounter *= 10;
                }

                counter = Variables->Counter;
                if ( counter >= maxCounter ) {
                    if ( !Variables->AllowCounterTruncation ) {
                        return GENNAME_COUNTER_TOO_HIGH;
                    }

                    //
                    // Truncate the counter on the right.
                    //

                    while ( counter > maxCounter ) {
                        counter /= 10;
                    }
                }

                if ( UsedCounter != NULL ) {
                    *UsedCounter = TRUE;
                }

                wsprintf( localString, L"%d", counter );
                stringToAdd = localString;

                pTemplate++;

            } else if ( StrCmpNI( pTemplate, cszFirst, iFirst ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                stringToAdd = Variables->FirstName;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( !usedUserName ) {
                        stringToAdd = Variables->UserName;
                        if ( STRING_MISSING(stringToAdd) ) {
                            if ( MissingVariable != NULL ) {
                                *MissingVariable = GENNAME_VARIABLE_FIRSTNAME;
                            }
                            return GENNAME_VARIABLE_MISSING;
                        }
                        usedUserName = TRUE;
                    }
                }

                pTemplate += iFirst;
                
            } else if ( StrCmpNI( pTemplate, cszLast, iLast ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                stringToAdd = Variables->LastName;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( !usedUserName ) {
                        stringToAdd = Variables->UserName;
                        if ( STRING_MISSING(stringToAdd) ) {
                            if ( MissingVariable != NULL ) {
                                *MissingVariable = GENNAME_VARIABLE_LASTNAME;
                            }
                            return GENNAME_VARIABLE_MISSING;
                        }
                        usedUserName = TRUE;
                    }
                }

                pTemplate += iLast;

            } else if ( StrCmpNI( pTemplate, cszUserName, iUserName ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                if ( !usedUserName ) {
                    stringToAdd = Variables->UserName;
                    if ( STRING_MISSING(stringToAdd) ) {
                        if ( MissingVariable != NULL ) {
                            *MissingVariable = GENNAME_VARIABLE_USERNAME;
                        }
                        return GENNAME_VARIABLE_MISSING;
                    }
                    usedUserName = TRUE;
                }

                pTemplate += iUserName;

            } else if ( StrCmpNI( pTemplate, cszMAC, iMAC ) == 0 ) {

                if (fieldLength > 12) {
                    fieldLength = 12;
                }
                if (fieldLength == 0) {
                    fieldLength = 12;
                }

                stringToAdd = Variables->MacAddress;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( MissingVariable != NULL ) {
                        *MissingVariable = GENNAME_VARIABLE_MAC;
                    }
                    return GENNAME_VARIABLE_MISSING;
                }

                pTemplate += iMAC;
                
            } else {

                return GENNAME_TEMPLATE_INVALID;
            }

        } else {

            fieldLength = 1;

            localString[0] = *pTemplate;
            localString[1] = 0;
            stringToAdd = localString;

            pTemplate++;
        }

        maxLength += fieldLength;

        pString = stringToAdd;
        for ( pString = stringToAdd;
              (fieldLength > 0) && (*pString != 0);
              fieldLength--, pString++ ) {
            if ( pOutput < pOutputEnd ) {
                *pOutput++ = *pString;
            } else {
                error = GENNAME_NAME_TOO_LONG;
                break;
            }
        }
    }

    if ( MaximumGeneratedNameLength != NULL ) {
        *MaximumGeneratedNameLength = maxLength;
    }

    *pOutput++ = 0;
    
    return error;

} // GenerateNameFromTemplate
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\safearray.h ===
/****************************************************************************************
 * NAME:	SafeArray.h
 *
 * CLASS:	CSafeArray
 *
 * OVERVIEW
 *
 * Internet Authentication Server: Utility class for SafeArray
 *
 * Copyright (c) 1998, Microsoft Corporation.  All Rights Reserved.
 *
 * History:	
 *				3/1/98	Created		byao
 *						This file is created according to the online web document:
 *						"Ole Development: Article 5: The Safe OLE Way of Handling Arrays"
 *						by Bruce McKinney,  http://tahiti/oledev/olecome/article5.htm"
 *					
 *				5/14/98	Modified	byao
 *						CSafeArray used 0x80 as a contructed flag in fFeature.
 *						This flag is now used in the official Win32API header file
 *						We get rid of this flag, and added another private member for 
 *						the same purpose
 *
 *
 *****************************************************************************************/
 
#ifndef _SAFEARRAY_H_
#define _SAFEARRAY_H_

// Dim class encapsulates an array dimension
//@B Dim
class Dim : public SAFEARRAYBOUND
{
public:
	Dim(const long iLo, const long iHi)
	{ cElements = abs(iHi - iLo) + 1; lLbound = iLo; }
	Dim(const long c)
	{ cElements = c; lLbound = 0; }
	const Dim & operator=(const Dim & dim) 
	{ cElements = dim.cElements; lLbound = dim.lLbound; return *this; }
	const Dim & operator=(const long c) 
	{ cElements = c; lLbound = 0; return *this; }
	~Dim() {}
	long Elements() { return cElements; }
	long LBound() { return lLbound; }
	long UBound() { return lLbound + cElements - 1; }
};
//@E Dim

// CSafeArray container class for OLE types

//@B CSafeArray1
template<class T, VARTYPE vt> 
class CSafeArray 
{
public:
	// Constructors
	CSafeArray();
	CSafeArray(SAFEARRAY * psaSrc);
	CSafeArray(Dim & dim);
    // Copy constructor
	CSafeArray(const CSafeArray & saSrc);

	// Destructor
	~CSafeArray(); 

	// Operator equal
	const CSafeArray & operator=(const CSafeArray & saSrc);

	// Indexing
	T & Get(long i);
	T & Set(T & t, long i);
	T & operator[](const long i);    // C++ style (0-indexed)
	T & operator()(const long i);    // Basic style (LBound-indexed)
//@E CSafeArray1

	// Type casts
	operator SAFEARRAY(); 
	operator SAFEARRAY() const; 

//	operator Variant(); 
//	operator Variant() const; 

	// Operations
	BOOL ReDim(Dim & dim);
	long LBound();
	long UBound();
	long Elements();
	long Dimensions();
    BOOL IsSizable();
	void Lock();
	void Unlock();

//@B CSafeArray2
private:
	SAFEARRAY * psa;
	BOOL m_fConstructed;  // is this safe array constructed?

    void Destroy();
};
//@E CSafeArray2

// Private helpers

template<class T, VARTYPE vt> 
inline void CSafeArray<T,vt>::Destroy()
{
    m_fConstructed = FALSE;
	HRESULT hres = SafeArrayDestroy(psa);
    if (hres) 
	{
		throw hres;
	}
}

// Constructors
template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::CSafeArray() 
{ 
    Dim dim(0);
	
	psa	= SafeArrayCreate(vt, 1, &dim); 
    if (psa == NULL) 
	{
		throw E_OUTOFMEMORY;
	}
    m_fConstructed	= TRUE;
}


template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::CSafeArray(SAFEARRAY * psaSrc) 
{ 
    if (SafeArrayGetDim(psaSrc) != 1) throw E_INVALIDARG;
    
	HRESULT hres	= SafeArrayCopy(psaSrc, &psa);
	if (hres) 
	{
		throw hres;
	}
    m_fConstructed	= TRUE;
}

template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::CSafeArray(const CSafeArray & saSrc) 
{
    HRESULT hres	= SafeArrayCopy(saSrc.psa, &psa);
    if (hres) 
	{
		throw hres;
	}

    m_fConstructed	= TRUE;
}


template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::CSafeArray(Dim & dim) 
{
	psa = SafeArrayCreate(vt, 1, &dim); 
    if (psa == NULL) 
	{
		throw E_OUTOFMEMORY;
	}

    m_fConstructed	= TRUE;
} 

// Destructor
template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::~CSafeArray()
{
	if (m_fConstructed) {
        Destroy();
    }
} 
	
// Operator = 
template<class T, VARTYPE vt> 
const CSafeArray<T,vt> & CSafeArray<T,vt>::operator=(const CSafeArray & saSrc)
{
    if (psa) 
	{
        SafeArrayDestroy(psa);
    }

    HRESULT hres = SafeArrayCopy(saSrc.psa, &psa);
    if (hres) 
	{
		throw hres;
	}
    m_fConstructed = TRUE;
    return *this;
}

// Type casts
template<class T, VARTYPE vt> 
inline CSafeArray<T,vt>::operator SAFEARRAY()
{
    return *psa; 
}

template<class T, VARTYPE vt> 
CSafeArray<T,vt>::operator SAFEARRAY() const
{
    static SAFEARRAY * psaT;
    SafeArrayCopy(psa, &psaT);
    return *psaT;
}

/*
template<class T, VARTYPE vt> 
CSafeArray<T,vt>::operator Variant() 
{
    return Variant(psa);
}

template<class T, VARTYPE vt> 
CSafeArray<T,vt>::operator Variant() const
{
    static Variant v(psa);
    return v;
}
*/

// Indexing
template<class T, VARTYPE vt> 
T & CSafeArray<T,vt>::Get(long i)
{
	static T tRes;
	HRESULT hres = SafeArrayGetElement(psa, &i, &tRes);
	if (hres) throw hres;
	return tRes;
}

//@B Indexing
template<class T, VARTYPE vt> 
inline T & CSafeArray<T,vt>::Set(T & t, long i)
{
	HRESULT hres = SafeArrayPutElement(psa, &i, (T *)&t);
	if (hres) throw hres;
    return t;
}

template<class T, VARTYPE vt> 
inline T & CSafeArray<T,vt>::operator[](const long i)
{
    if (i < 0 || i > Elements() - 1) throw DISP_E_BADINDEX;
	return ((T*)psa->pvData)[i];
}

template<class T, VARTYPE vt> 
T & CSafeArray<T,vt>::operator()(const long i)
{
    if (i < LBound() || i > UBound()) throw DISP_E_BADINDEX;
	return ((T*)psa->pvData)[i - LBound()];
}
//@E Indexing

// Operations
template<class T, VARTYPE vt> 
BOOL CSafeArray<T,vt>::ReDim(Dim &dim)
{
    if (!IsSizable()) {
        return FALSE;
    }
	HRESULT hres = SafeArrayRedim(psa, &dim);
	if (hres) throw hres;
    return TRUE;
}

template<class T, VARTYPE vt> 
long CSafeArray<T,vt>::LBound()
{
	long iRes;
	HRESULT hres = SafeArrayGetLBound(psa, 1, &iRes);
	if (hres) throw hres;
	return iRes;
}

template<class T, VARTYPE vt> 
inline long CSafeArray<T,vt>::Elements()
{
	return psa->rgsabound[0].cElements;
}

template<class T, VARTYPE vt> 
long CSafeArray<T,vt>::UBound()
{
	long iRes;
	HRESULT hres = SafeArrayGetUBound(psa, 1, &iRes);
	if (hres) throw hres;
	return iRes;
}

template<class T, VARTYPE vt> 
inline long CSafeArray<T,vt>::Dimensions()
{
	return 1;
}

template<class T, VARTYPE vt> 
inline BOOL CSafeArray<T,vt>::IsSizable()
{
    return (psa->fFeatures & FADF_FIXEDSIZE) ? FALSE : TRUE;
}

template<class T, VARTYPE vt>
inline void CSafeArray<T,vt>::Lock()
{
	HRESULT hres = SafeArrayLock(psa);
	if (hres) 
	{
		throw hres;
	}
}

template<class T, VARTYPE vt>
inline void CSafeArray<T,vt>::Unlock()
{
	HRESULT hres = SafeArrayUnlock(psa);
	if (hres) 
	{
		throw hres;
	}
}


#endif // _SAFEARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sndblst.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992  Microsoft Corporation

Module Name:

    sndblst.h

Abstract:

    This include file defines constants and types for
    the Sound blaster card.

	This header file is shared between the low level driver and the
	kernel driver.

Revision History:

--*/

#define SOUND_DEF_DMACHANNEL   1        // DMA channel no
#define SOUND_DEF_DMACHANNEL16 5        // DMA channel no 5
#define SOUND_DEF_INT          7
#define SOUND_DEF_PORT         0x220
#define SOUND_DEF_MPU401_PORT  0x330

#define NUMBER_OF_SOUND_PORTS (0x10)
#define NUMBER_OF_MPU401_PORTS (0x02)

/*
**  Registry value names
*/

#define SOUND_REG_DMACHANNEL16 (L"DmaChannel16")
#define SOUND_REG_MPU401_PORT  (L"MPU401 Port")
#define SOUND_REG_DSP_VERSION  (L"DSP Version")
#define SOUND_REG_REALBUFFERSIZE (L"Actual Dma Buffer Size")

/*
**  Sound blaster midi mappings
*/

#define SNDBLST_MAPPER_OPL3 TEXT("SNDBLST OPL3")
#define SNDBLST_MAPPER_ADLIB TEXT("SNDBLST AD LIB")


/*
**  Registry 'return' codes
*/

#define SOUND_CONFIG_THUNDER             0x80000001
#define SOUND_CONFIG_MPU401_PORT_INUSE   0x80000002
#define SOUND_CONFIG_BAD_MPU401_PORT     0x80000003

/*
**  String ids (strings in sndblst.dll)
*/

#define IDS_AUX_LINE_PNAME                                   100
#define IDS_AUX_CD_PNAME                                     101
#define IDS_SYNTH_PNAME                                      102
#define IDS_WAVEIN_PNAME                                     103
#define IDS_WAVEOUT_PNAME                                    104
#define IDS_MIXER_PNAME                                      105

#define IDS_CONTROL_AGCMIC_LONG_NAME                         106
#define IDS_CONTROL_AGCMIC_SHORT_NAME                        107
#define IDS_CONTROL_METERRECORD_LONG_NAME                    108
#define IDS_CONTROL_METERRECORD_SHORT_NAME                   109
#define IDS_CONTROL_MUTEAUX_LONG_NAME                        110
#define IDS_CONTROL_MUTEAUX_SHORT_NAME                       111
#define IDS_CONTROL_MUTEINTERNAL_LONG_NAME                   112
#define IDS_CONTROL_MUTEINTERNAL_SHORT_NAME                  113
#define IDS_CONTROL_MUTELINEOUT_LONG_NAME                    114
#define IDS_CONTROL_MUTELINEOUT_SHORT_NAME                   115
#define IDS_CONTROL_MUTEMIC_SHORT_NAME                       116
#define IDS_CONTROL_MUTEMIC_LONG_NAME                        117
#define IDS_CONTROL_MUTEMIDIOUT_LONG_NAME                    118
#define IDS_CONTROL_MUTEMIDIOUT_SHORT_NAME                   119
#define IDS_CONTROL_MUTEWAVEOUT_LONG_NAME                    120
#define IDS_CONTROL_MUTEWAVEOUT_SHORT_NAME                   121
#define IDS_CONTROL_MUXLINEOUT_LONG_NAME                     122
#define IDS_CONTROL_MUXLINEOUT_SHORT_NAME                    123
#define IDS_CONTROL_MUXWAVEIN_LONG_NAME                      124
#define IDS_CONTROL_MUXWAVEIN_SHORT_NAME                     125
#define IDS_CONTROL_PEAKVOICEINAUX_LONG_NAME                 126
#define IDS_CONTROL_PEAKVOICEINAUX_SHORT_NAME                127
#define IDS_CONTROL_PEAKVOICEINMIC_LONG_NAME                 128
#define IDS_CONTROL_PEAKVOICEINMIC_SHORT_NAME                129
#define IDS_CONTROL_PEAKWAVEINAUX_LONG_NAME                  130
#define IDS_CONTROL_PEAKWAVEINAUX_SHORT_NAME                 131
#define IDS_CONTROL_PEAKWAVEININTERNAL_LONG_NAME             132
#define IDS_CONTROL_PEAKWAVEININTERNAL_SHORT_NAME            133
#define IDS_CONTROL_PEAKWAVEINMIC_LONG_NAME                  134
#define IDS_CONTROL_PEAKWAVEINMIC_SHORT_NAME                 135
#define IDS_CONTROL_PEAKWAVEOUT_LONG_NAME                    136
#define IDS_CONTROL_PEAKWAVEOUT_SHORT_NAME                   137
#define IDS_CONTROL_VOICEINMUX_LONG_NAME                     138
#define IDS_CONTROL_VOICEINMUX_SHORT_NAME                    139
#define IDS_CONTROL_VOLBASS_LONG_NAME                        140
#define IDS_CONTROL_VOLBASS_SHORT_NAME                       141
#define IDS_CONTROL_VOLLINEOUTAUX_LONG_NAME                  142
#define IDS_CONTROL_VOLLINEOUTAUX_SHORT_NAME                 143
#define IDS_CONTROL_VOLLINEOUTINTERNAL_LONG_NAME             144
#define IDS_CONTROL_VOLLINEOUTINTERNAL_SHORT_NAME            145
#define IDS_CONTROL_VOLLINEOUTMIC_LONG_NAME                  146
#define IDS_CONTROL_VOLLINEOUTMIC_SHORT_NAME                 147
#define IDS_CONTROL_VOLLINEOUTMIDIOUT_LONG_NAME              148
#define IDS_CONTROL_VOLLINEOUTMIDIOUT_SHORT_NAME             149
#define IDS_CONTROL_VOLLINEOUTWAVEOUT_LONG_NAME              150
#define IDS_CONTROL_VOLLINEOUTWAVEOUT_SHORT_NAME             151
#define IDS_CONTROL_VOLLINEOUT_LONG_NAME                     152
#define IDS_CONTROL_VOLLINEOUT_SHORT_NAME                    153
#define IDS_CONTROL_VOLRECORD_LONG_NAME                      154
#define IDS_CONTROL_VOLRECORD_SHORT_NAME                     155
#define IDS_CONTROL_VOLTREBLE_LONG_NAME                      156
#define IDS_CONTROL_VOLTREBLE_SHORT_NAME                     157
#define IDS_CONTROL_VOLVOICEINAUX_LONG_NAME                  158
#define IDS_CONTROL_VOLVOICEINAUX_SHORT_NAME                 159
#define IDS_CONTROL_VOLVOICEINMIC_LONG_NAME                  160
#define IDS_CONTROL_VOLVOICEINMIC_SHORT_NAME                 161
#define IDS_CONTROL_VOLWAVEINAUX_LONG_NAME                   162
#define IDS_CONTROL_VOLWAVEINAUX_SHORT_NAME                  163
#define IDS_CONTROL_VOLWAVEININTERNAL_LONG_NAME              164
#define IDS_CONTROL_VOLWAVEININTERNAL_SHORT_NAME             165
#define IDS_CONTROL_VOLWAVEINMIC_LONG_NAME                   166
#define IDS_CONTROL_VOLWAVEINMIC_SHORT_NAME                  167
#define IDS_CONTROL_VOLWAVEINMIDIOUT_LONG_NAME               168
#define IDS_CONTROL_VOLWAVEINMIDIOUT_SHORT_NAME              169
#define IDS_DESTLINEOUT_LONG_NAME                            170
#define IDS_DESTLINEOUT_SHORT_NAME                           171
#define IDS_DESTVOICEIN_LONG_NAME                            172
#define IDS_DESTVOICEIN_SHORT_NAME                           173
#define IDS_DESTWAVEIN_LONG_NAME                             174
#define IDS_DESTWAVEIN_SHORT_NAME                            175
#define IDS_SRCAUX_LONG_NAME                                 176
#define IDS_SRCAUX_SHORT_NAME                                177
#define IDS_SRCINTERNALCD_LONG_NAME                          178
#define IDS_SRCINTERNALCD_SHORT_NAME                         179
#define IDS_SRCMICOUT_LONG_NAME                              180
#define IDS_SRCMICOUT_SHORT_NAME                             181
#define IDS_SRCMIDIOUT_LONG_NAME                             182
#define IDS_SRCMIDIOUT_SHORT_NAME                            183
#define IDS_SRCWAVEOUT_LONG_NAME                             184
#define IDS_SRCWAVEOUT_SHORT_NAME                            185
#define IDS_CONTROL_MIXERWAVEIN_LONG_NAME                    186
#define IDS_CONTROL_MIXERWAVEIN_SHORT_NAME                   187
#define IDS_CONTROL_VOLGAIN_SHORT_NAME                       188
#define IDS_CONTROL_VOLGAIN_LONG_NAME                        189
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sgadmin.h ===
// ---------------------------------------------------------------------------------------
// sgadmin.h
//
// Security Gateway Admin Library
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __SGADMIN_H__
#define __SGADMIN_H__

NTSTATUS SgConfigure(PSTR pConfig);
NTSTATUS SgCmd(PWSTR pCmd, ULONG cbOut, PBYTE pbOut);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\seopaque.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    seopaque.h

Abstract:

    This module contains definitions of opaque Security data structures.

    These structures are available to user and kernel security routines
    only.

    This file is not included by including "ntos.h".

Author:

    Jim Kelly (Jimk) 23-Mar-1990

Revision History:

--*/

#ifndef _SEOPAQUE_
#define _SEOPAQUE_

///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Private Structures                                                   //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
// Generic ACE structures, to be used for casting ACE's of known types
//

typedef struct _KNOWN_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} KNOWN_ACE, *PKNOWN_ACE;

typedef struct _KNOWN_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG Flags;
    // GUID ObjectType;             // Optionally present
    // GUID InheritedObjectType;    // Optionally present
    ULONG SidStart;
} KNOWN_OBJECT_ACE, *PKNOWN_OBJECT_ACE;

typedef struct _KNOWN_COMPOUND_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    USHORT CompoundAceType;
    USHORT Reserved;
    ULONG SidStart;
} KNOWN_COMPOUND_ACE, *PKNOWN_COMPOUND_ACE;

//typedef struct _KNOWN_IMPERSONATION_ACE {
//    ACE_HEADER Header;
//    ACCESS_MASK Mask;
//    USHORT DataType;
//    USHORT Argument;
//    ULONG Operands;
//} KNOWN_IMPERSONATION_ACE, *PKNOWN_IMPERSONATION_ACE;



///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Miscellaneous support macros                                         //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
//  Given a pointer return its word aligned equivalent value
//

#define WordAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 1) & -2)     \
    )

//
//  Given a pointer return its longword aligned equivalent value
//

#define LongAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 3) & -4)     \
    )

//
//  Given a size return its longword aligned equivalent value
//

#define LongAlignSize(Size) (((ULONG)(Size) + 3) & -4)

//
//  Given a pointer return its quadword aligned equivalent value
//

#define QuadAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 7) & -8)     \
    )

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag) (               \
    ((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE \
    )

//
//  This macro clears a single flag in a set of flags
//

#define ClearFlag(Flags,SingleFlag) { \
    (Flags) &= ~(SingleFlag);         \
    }

//
//  Get a pointer to the first ace in an acl
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Get a pointer to the following ace
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

//
// A "known" ACE is one of the types that existed before the introduction of
// compound ACEs.  While the name is no longer as accurate as it used to be,
// it's convenient.
//

#define IsKnownAceType(Ace) (                                     \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid version 3 ACE.
//

#define IsV3AceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V3_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid version 4 ACE.
//

#define IsV4AceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V4_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid ACE.
//

#define IsMSAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_ACE_TYPE)           \
    )

//
//  Determine if an ace is a standard ace
//

#define IsCompoundAceType(Ace) (                                           \
    (((PACE_HEADER)(Ace))->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE))

//
// Test if the ACE is an object ACE.
//

#define IsObjectAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)    \
    )

//
// Update this macro as new ACL revisions are defined.
//

#define ValidAclRevision(Acl) ((Acl)->AclRevision >= MIN_ACL_REVISION && \
                               (Acl)->AclRevision <= MAX_ACL_REVISION )

//
//  Macro to determine if an ace is to be inherited by a subdirectory
//

#define ContainerInherit(Ace) (                      \
    FlagOn((Ace)->AceFlags, CONTAINER_INHERIT_ACE) \
    )

//
//  Macro to determine if an ace is to be proprogate to a subdirectory.
//  It will if it is inheritable by either a container or non-container
//  and is not explicitly marked for no-propagation.
//

#define Propagate(Ace) (                                              \
    !FlagOn((Ace)->AceFlags, NO_PROPAGATE_INHERIT_ACE)  &&            \
    (FlagOn(( Ace )->AceFlags, OBJECT_INHERIT_ACE) ||                 \
     FlagOn(( Ace )->AceFlags, CONTAINER_INHERIT_ACE) )               \
    )

//
//  Macro to determine if an ACE is to be inherited by a sub-object
//

#define ObjectInherit(Ace) (                      \
    FlagOn(( Ace )->AceFlags, OBJECT_INHERIT_ACE) \
    )

//
// Macro to determine if an ACE was inherited.
//

#define AceInherited(Ace) (                      \
    FlagOn(( Ace )->AceFlags, INHERITED_ACE) \
    )

//
// Extract the SID from a object ACE
//
#define RtlObjectAceObjectTypePresent( Ace ) \
     ((((PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_OBJECT_TYPE_PRESENT) != 0 )
#define RtlObjectAceInheritedObjectTypePresent( Ace ) \
     ((((PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) != 0 )

#define RtlObjectAceSid( Ace ) \
    ((PSID)(((PUCHAR)&(((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + \
     (RtlObjectAceObjectTypePresent(Ace) ? sizeof(GUID) : 0 ) + \
     (RtlObjectAceInheritedObjectTypePresent(Ace) ? sizeof(GUID) : 0 )))

#define RtlObjectAceObjectType( Ace ) \
     ((GUID *)(RtlObjectAceObjectTypePresent(Ace) ? \
        &((PKNOWN_OBJECT_ACE)(Ace))->SidStart : \
        NULL ))

#define RtlObjectAceInheritedObjectType( Ace ) \
     ((GUID *)(RtlObjectAceInheritedObjectTypePresent(Ace) ? \
        ( RtlObjectAceObjectTypePresent(Ace) ? \
            (PULONG)(((PUCHAR)(&((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + sizeof(GUID)) : \
            &((PKNOWN_OBJECT_ACE)(Ace))->SidStart ) : \
        NULL ))

//
// Comparison routine for two GUIDs.
//
#define RtlpIsEqualGuid(rguid1, rguid2)  \
        (((PLONG) rguid1)[0] == ((PLONG) rguid2)[0] &&   \
        ((PLONG) rguid1)[1] == ((PLONG) rguid2)[1] &&    \
        ((PLONG) rguid1)[2] == ((PLONG) rguid2)[2] &&    \
        ((PLONG) rguid1)[3] == ((PLONG) rguid2)[3])

//
// Macros for mapping DACL/SACL specific security descriptor control bits
//  to generic control bits.
//
// This mapping allows common routines to manipulate control bits generically
//  and have the appropriate bits set in the security descriptor based
//  on whether to ACL is a DACL or a SACL.
//

#define SEP_ACL_PRESENT             SE_DACL_PRESENT
#define SEP_ACL_DEFAULTED           SE_DACL_DEFAULTED
#define SEP_ACL_AUTO_INHERITED      SE_DACL_AUTO_INHERITED
#define SEP_ACL_PROTECTED           SE_DACL_PROTECTED

#define SEP_ACL_ALL ( \
        SEP_ACL_PRESENT | \
        SEP_ACL_DEFAULTED | \
        SEP_ACL_AUTO_INHERITED | \
        SEP_ACL_PROTECTED )

#define SeControlDaclToGeneric( _Dacl ) \
    ((_Dacl) & SEP_ACL_ALL )

#define SeControlGenericToDacl( _Generic ) \
    ((_Generic) & SEP_ACL_ALL )

#define SeControlSaclToGeneric( _Sacl ) ( \
            (((_Sacl) & SE_SACL_PRESENT) ? SEP_ACL_PRESENT : 0 ) | \
            (((_Sacl) & SE_SACL_DEFAULTED) ? SEP_ACL_DEFAULTED : 0 ) | \
            (((_Sacl) & SE_SACL_AUTO_INHERITED) ? SEP_ACL_AUTO_INHERITED : 0 ) | \
            (((_Sacl) & SE_SACL_PROTECTED) ? SEP_ACL_PROTECTED : 0 ) )

#define SeControlGenericToSacl( _Generic ) ( \
            (((_Generic) & SEP_ACL_PRESENT) ? SE_SACL_PRESENT : 0 ) | \
            (((_Generic) & SEP_ACL_DEFAULTED) ? SE_SACL_DEFAULTED : 0 ) | \
            (((_Generic) & SEP_ACL_AUTO_INHERITED) ? SE_SACL_AUTO_INHERITED : 0 ) | \
            (((_Generic) & SEP_ACL_PROTECTED) ? SE_SACL_PROTECTED : 0 ) )




#endif // _SEOPAQUE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\soundsys.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992  Microsoft Corporation

Module Name:

    soundsys.h

Abstract:

    This include file defines constants and types for
    the Microsoft sound system card.

	This header file is shared between the low level driver and the
	kernel driver.

Author:

    Robin Speed (RobinSp) 20-Oct-92

Revision History:

--*/

#define VALID_IO_PORTS {0x530, 0x604, 0xE80, 0xF40, 0xFFFF}
#define VALID_INTERRUPTS {7, 9, 10, 11, 0xFFFF}
#define VALID_DMA_CHANNELS {0, 1, 3, 0xFFFF}

#define SOUND_DEF_DMACHANNEL 1        // DMA channel no
#define SOUND_DEF_INT        11
#define SOUND_DEF_PORT       0x530

#define SOUND_REG_SINGLEMODEDMA L"Single Mode DMA"

#define SOUNDSYS_BUFFERSIZE 0x4000    // DMA buffer size - 16K

/*
** CAPS strings
*/

#define STR_DRIVERWAVEIN L"Windows Sound System Record"
#define STR_DRIVERWAVEOUT L"Windows Sound System Playback"
#define STR_DRIVERMIDIOUT L"Windows Sound System MIDI"
#define STR_DRIVERMIC L"Windows Sound System Mic"
#define STR_DRIVERLINEIN L"Windows Sound System Line In"
#define STR_DRIVERMASTERVOLUME L"Windows Sound System Master"


#define IDS_WAVEOUT_PNAME                          101
#define IDS_WAVEIN_PNAME                           102
#define IDS_MIDIOUT_PNAME                          103
#define IDS_AUX_PNAME                              104

#define IDS_DESTLINEOUT_SHORT_NAME                 110
#define IDS_DESTLINEOUT_LONG_NAME                  111
#define IDS_DESTWAVEIN_SHORT_NAME                  112
#define IDS_DESTWAVEIN_LONG_NAME                   113
#define IDS_DESTVOICEIN_SHORT_NAME                 114
#define IDS_DESTVOICEIN_LONG_NAME                  115

#define IDS_SRCAUX1_SHORT_NAME                     120
#define IDS_SRCAUX1_LONG_NAME                      121
#define IDS_SRCWAVEOUT_SHORT_NAME                  122
#define IDS_SRCWAVEOUT_LONG_NAME                   123
#define IDS_SRCMIDIOUT_SHORT_NAME                  124
#define IDS_SRCMIDIOUT_LONG_NAME                   125
#define IDS_SRCMIC_SHORT_NAME                      126
#define IDS_SRCMIC_LONG_NAME                       127

#define IDS_CONTROL_VOLLINEOUT_SHORT_NAME          130
#define IDS_CONTROL_VOLLINEOUT_LONG_NAME           131
#define IDS_CONTROL_MUTELINEOUT_SHORT_NAME         132
#define IDS_CONTROL_MUTELINEOUT_LONG_NAME          133
#define IDS_CONTROL_MUXWAVEIN_SHORT_NAME           134
#define IDS_CONTROL_MUXWAVEIN_LONG_NAME            135
#define IDS_CONTROL_MUXVOICEIN_SHORT_NAME          136
#define IDS_CONTROL_MUXVOICEIN_LONG_NAME           137
#define IDS_CONTROL_VOLLINEOUTAUX1_SHORT_NAME      138
#define IDS_CONTROL_VOLLINEOUTAUX1_LONG_NAME       139
#define IDS_CONTROL_MUTELINEOUTAUX1_SHORT_NAME     140
#define IDS_CONTROL_MUTELINEOUTAUX1_LONG_NAME      141
#define IDS_CONTROL_VOLLINEOUTWAVEOUT_SHORT_NAME   142
#define IDS_CONTROL_VOLLINEOUTWAVEOUT_LONG_NAME    143
#define IDS_CONTROL_MUTELINEOUTWAVEOUT_SHORT_NAME  144
#define IDS_CONTROL_MUTELINEOUTWAVEOUT_LONG_NAME   145
#define IDS_CONTROL_PEAKLINEOUTWAVEOUT_SHORT_NAME  146
#define IDS_CONTROL_PEAKLINEOUTWAVEOUT_LONG_NAME   147
#define IDS_CONTROL_VOLLINEOUTMIDIOUT_SHORT_NAME   148
#define IDS_CONTROL_VOLLINEOUTMIDIOUT_LONG_NAME    149
#define IDS_CONTROL_MUTELINEOUTMIDIOUT_SHORT_NAME  150
#define IDS_CONTROL_MUTELINEOUTMIDIOUT_LONG_NAME   151
#define IDS_CONTROL_VOLWAVEINAUX1_SHORT_NAME       152
#define IDS_CONTROL_VOLWAVEINAUX1_LONG_NAME        153
#define IDS_CONTROL_PEAKWAVEINAUX1_SHORT_NAME      154
#define IDS_CONTROL_PEAKWAVEINUAX1_LONG_NAME       155
#define IDS_CONTROL_VOLWAVEINMIC_SHORT_NAME        156
#define IDS_CONTROL_VOLWAVEINMIC_LONG_NAME         157
#define IDS_CONTROL_PEAKWAVEINMIC_SHORT_NAME       158
#define IDS_CONTROL_PEAKWAVEINMIC_LONG_NAME        159
#define IDS_CONTROL_VOLVOICEINAUX1_SHORT_NAME      160
#define IDS_CONTROL_VOLVOICEINAUX1_LONG_NAME       161
#define IDS_CONTROL_PEAKVOICEINAUX1_SHORT_NAME     162
#define IDS_CONTROL_PEAKVOICEINUAX1_LONG_NAME      163
#define IDS_CONTROL_VOLVOICEINMIC_SHORT_NAME       164
#define IDS_CONTROL_VOLVOICEINMIC_LONG_NAME        165
#define IDS_CONTROL_PEAKVOICEINMIC_SHORT_NAME      166
#define IDS_CONTROL_PEAKVOICEINMIC_LONG_NAME       167

#define SR_STR_DRIVER_MIXER                        180
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\simbad.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    simbad.h

Abstract:

    The SIMulated BAD sector utility allows a user to specify
    bad physical sectors through the device control interface.
    The device driver keeps an array of SIMBAD sectors and when
    a request for a transfer includes one of these sectors the
    driver returns the corresponding status and fails the transfer.

Author:

    Mike Glass (mglass) 2-Feb-1992
    Bob Rinne  (bobri)

Revision History:

    09-Apr-92 - bobri    added specific control over errors (read,map,etc).
    12-May-94 - venkat   added code to drop of writes to DISK (CHKDSK testing)
    19-Nov-94 - kpeery   added code to reset the system (restart testing)
    29-Dec-97 - kbarrus  added code: ranges (fail regions on dynamic disks)
    01-May-98 - kbarrus  added partitionOffset field in SIMBAD_DATA, changed max
                         sectors and max ranges
    27-Oct-98 - kbarrus  added modulus, change debug print level
    06-Oct-99 - kbarrus  added ioctl fail flag
--*/

#if _MSC_VER > 1000
#pragma once
#endif

//
// driver name
//

#define SIMBAD_SERVICE_NAME L"Simbad"

//
// These values are selected so that
// sizeof( SIMBAD_SECTORS ) + sizeof( SIMBAD_RANGES ) <= 4096 bytes
//

#define MAXIMUM_SIMBAD_SECTORS 248
#define MAXIMUM_SIMBAD_RANGES  4

//
// psuedo random number generator parameters
//

// default seed should be non-zero
#define SIMBAD_DEFAULT_SEED 5


// default modulus should be > 1
#define SIMBAD_DEFAULT_MODULUS 100

//
// This structure is used by the driver and application to
// specify which sector is BAD and what status the driver
// should return.
//

typedef struct _BAD_SECTOR
{
   ULONGLONG BlockAddress;
   ULONG AccessType;
   NTSTATUS Status;
} BAD_SECTOR, *PBAD_SECTOR;

//
// This structure is used by the driver and application to
// specify a range of sectors that have been marked BAD and
// what status the driver should return.
//

typedef struct _BAD_RANGE
{
   ULONGLONG BlockBegin;
   ULONGLONG BlockEnd;
   ULONG AccessType;
   NTSTATUS Status;
} BAD_RANGE, *PBAD_RANGE;

//
// This structure is maintained by the device driver. It keeps a
// count of how many sectors have been marked BAD and an array of
// the BAD sectors.
//

typedef struct _SIMBAD_SECTORS
{
   ULONG Flags;
   ULONG SectorCount;
   BAD_SECTOR Sector[MAXIMUM_SIMBAD_SECTORS];
} SIMBAD_SECTORS, *PSIMBAD_SECTORS;

//
// This structure is maintained by the device driver. It keeps a
// count of how many ranges have been marked BAD and an array of
// the BAD ranges.
//

typedef struct _SIMBAD_RANGES
{
   ULONG Flags;
    LONG Seed;
   ULONG Modulus;
   ULONG RangeCount;
   BAD_RANGE Range[MAXIMUM_SIMBAD_RANGES];
} SIMBAD_RANGES, *PSIMBAD_RANGES;

//
// This structure is passed from the application to the device
// driver through the device control interface to add and remove
// bad sectors or ranges.
//
// If the function is add or remove sectors or ranges then the Count
// field specifies how many sectors or ranges to add or remove.
//
// If the function is list then the array returns all sectors or
// ranges marked bad.
//
// This facility does not allow mixed adds and removes in a
// single device control call.
//
// NOTE: if a request specifies a number of adds that will exceed
// the array limit (MAXIMUM_SIMBAD_SECTORS or MAXIMUM_SIMBAD_RANGES),
// then sectors or ranges will be added to fill the array and the
// count field will be adjusted to the number of sectors or ranges
// successfully added.
//

typedef struct _SIMBAD_DATA
{
   ULONG Function;
   ULONG SectorCount;
   ULONG RangeCount;
   ULONGLONG Offset;
   BAD_SECTOR Sector[MAXIMUM_SIMBAD_SECTORS];
   BAD_RANGE  Range[MAXIMUM_SIMBAD_RANGES];
} SIMBAD_DATA, *PSIMBAD_DATA;

//
// Simulated Bad Sector Functions
//

//
// When the disable or enable function is specified,
// the rest of the structure is ignored.
// The SimBad function is disabled on driver startup.
// The disable/enable status affects whether completing
// transfers are checks against the bad sector array.
// While the function is disabled, requests to manipulate
// the driver's bad sector array are still allowed
// (ie add sector, remove sector, list bad sectors).
//

#define SIMBAD_DISABLE            0x00000000
#define SIMBAD_ENABLE             0x00000001

//
// These functions are used to set and clear bad sectors or ranges.
//

#define SIMBAD_ADD_SECTORS        0x00000002
#define SIMBAD_REMOVE_SECTORS     0x00000004
#define SIMBAD_LIST_BAD_SECTORS   0x00000008
#define SIMBAD_ADD_RANGES         0x00000010
#define SIMBAD_REMOVE_RANGES      0x00000020
#define SIMBAD_LIST_BAD_RANGES    0x00000040

//
// This function cause all accesses to a driver
// to return failure.
//

#define SIMBAD_ORPHAN             0x00000080

//
// This function clears the internal bad sector list in the driver.
// It also clears the orphan state.
//

#define SIMBAD_CLEAR              0x00000100

//
// Randomly drops of writes to the disk. Used for corrupting the DISK.
// These corrupt disk are used to test CHKDSK.
//

#define SIMBAD_RANDOM_WRITE_FAIL  0x00000200

//
// Bug checks the system.  Used for crash dump
//

#define SIMBAD_BUG_CHECK          0x00000400

//
// Call HalReturnToFirmware() to reset the system.
// Used for restart testing.
//

#define SIMBAD_FIRMWARE_RESET     0x00000800

//
// Return internal version number
//

#define SIMBAD_GET_VERSION        0x00001000

//
// Change debug level (how much prints to the debugger)
//

#define SIMBAD_DEBUG_LEVEL        0x00002000

//
// Simulated Bad Sector Access Codes
//

//
// These are the access codes that will drive when simbad
// returns failures on disks.
//

#define SIMBAD_ACCESS_READ                  0x00000001
#define SIMBAD_ACCESS_WRITE                 0x00000002
#define SIMBAD_ACCESS_VERIFY                0x00000004

//
// Error sector can be mapped via device control.
//

#define SIMBAD_ACCESS_CAN_REASSIGN_SECTOR   0x00000008

//
// When returning an error indicate Irp offset of zero
// (simulates drivers that cannot tell where the error occured within
// an I/O)
//

#define SIMBAD_ACCESS_ERROR_ZERO_OFFSET     0x00000010

//
// Fail calls to reassign bad sector IOCTL.
//

#define SIMBAD_ACCESS_FAIL_REASSIGN_SECTOR  0x00000020

//
// Fail general storage IOCTLs
//

#define SIMBAD_ACCESS_FAIL_IOCTL            0x00000040
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\status.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    status.h

Abstract:

    This module defines manifest constants for the LAN Manager server.

Author:

    David Treadwell (davidtr)    10-May-1990

Revision History:

--*/

#ifndef _STATUS_
#define _STATUS_



//
// The server has 16 bits available to it in each 32-bit status code.
// See \nt\sdk\inc\ntstatus.h for a description of the use of the
// high 16 bits of the status.
//
// The layout of the bits is:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------+-----------------------+
//  |Sev|C|   Facility--Server      | Class |        Code           |
//  +---+-+-------------------------+-------+-----------------------+
//
// Class values:
//     0 - a server-specific error code, not put directly on the wire.
//     1 - SMB error class DOS.  This includes those OS/2 errors
//             that share code values and meanings with the SMB protocol.
//     2 - SMB error class SERVER.
//     3 - SMB error class HARDWARE.
//     4 - other SMB error classes
//     5-E - undefined
//     F - an OS/2-specific error.  If the client is OS/2, then the
//              SMB error class is set to DOS and the code is set to
//              the actual OS/2 error code contained in the Code field.
//
// The meaning of the Code field depends on the Class value.  If the
// class is 00, then the code value is arbitrary.  For other classes,
// the code is the actual code of the error in the SMB or OS/2
// protocols.
//

#define SRV_STATUS_FACILITY_CODE 0x00980000L
#define SRV_SRV_STATUS                (0xC0000000L | SRV_STATUS_FACILITY_CODE)
#define SRV_DOS_STATUS                (0xC0001000L | SRV_STATUS_FACILITY_CODE)
#define SRV_SERVER_STATUS             (0xC0002000L | SRV_STATUS_FACILITY_CODE)
#define SRV_HARDWARE_STATUS           (0xC0003000L | SRV_STATUS_FACILITY_CODE)
#define SRV_WIN32_STATUS              (0xC000E000L | SRV_STATUS_FACILITY_CODE)
#define SRV_OS2_STATUS                (0xC000F000L | SRV_STATUS_FACILITY_CODE)

//++
//
// BOOLEAN
// SmbIsSrvStatus (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     Macro to determine whether a status code is one defined by the
//     server (has the server facility code).
//
// Arguments:
//
//     Status - the status code to check.
//
// Return Value:
//
//     BOOLEAN - TRUE if the facility code is the servers, FALSE
//         otherwise.
//
//--

#define SrvIsSrvStatus(Status) \
    ( ((Status) & 0x1FFF0000) == SRV_STATUS_FACILITY_CODE ? TRUE : FALSE )

//++
//
// UCHAR
// SmbErrorClass (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro extracts the error class field from a server status
//     code.
//
// Arguments:
//
//     Status - the status code from which to get the error class.
//
// Return Value:
//
//     UCHAR - the server error class of the status code.
//
//--

#define SrvErrorClass(Status) ((UCHAR)( ((Status) & 0x0000F000) >> 12 ))

//++
//
// UCHAR
// SmbErrorCode (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro extracts the error code field from a server status
//     code.
//
// Arguments:
//
//     Status - the status code from which to get the error code.
//
// Return Value:
//
//     UCHAR - the server error code of the status code.
//
//--

#define SrvErrorCode(Status) ((USHORT)( (Status) & 0xFFF) )

//
// Status codes unique to the server.  These error codes are used
// internally only.
//

#define STATUS_ENDPOINT_CLOSED              (SRV_SRV_STATUS | 0x01)
#define STATUS_DISCONNECTED                 (SRV_SRV_STATUS | 0x02)
#define STATUS_SERVER_ALREADY_STARTED       (SRV_SRV_STATUS | 0x04)
#define STATUS_SERVER_NOT_STARTED           (SRV_SRV_STATUS | 0x05)
#define STATUS_OPLOCK_BREAK_UNDERWAY        (SRV_SRV_STATUS | 0x06)
#define STATUS_NONEXISTENT_NET_NAME         (SRV_SRV_STATUS | 0x08)

//
// Error codes that exist in both the SMB protocol and OS/2 but not NT.
// Note that all SMB DOS-class error codes are defined in OS/2.
//

#define STATUS_OS2_INVALID_FUNCTION   (SRV_DOS_STATUS | ERROR_INVALID_FUNCTION)
#define STATUS_OS2_TOO_MANY_OPEN_FILES \
                                   (SRV_DOS_STATUS | ERROR_TOO_MANY_OPEN_FILES)
#define STATUS_OS2_INVALID_ACCESS     (SRV_DOS_STATUS | ERROR_INVALID_ACCESS)

//
// SMB SERVER-class error codes that lack an NT or OS/2 equivalent.
//

#define STATUS_INVALID_SMB            (SRV_SERVER_STATUS | SMB_ERR_ERROR)
#define STATUS_SMB_BAD_NET_NAME       (SRV_SERVER_STATUS | SMB_ERR_BAD_NET_NAME)
#define STATUS_SMB_BAD_TID            (SRV_SERVER_STATUS | SMB_ERR_BAD_TID)
#define STATUS_SMB_BAD_UID            (SRV_SERVER_STATUS | SMB_ERR_BAD_UID)
#define STATUS_SMB_TOO_MANY_UIDS      (SRV_SERVER_STATUS | SMB_ERR_TOO_MANY_UIDS)
#define STATUS_SMB_USE_MPX            (SRV_SERVER_STATUS | SMB_ERR_USE_MPX)
#define STATUS_SMB_USE_STANDARD       (SRV_SERVER_STATUS | SMB_ERR_USE_STANDARD)
#define STATUS_SMB_CONTINUE_MPX       (SRV_SERVER_STATUS | SMB_ERR_CONTINUE_MPX)
#define STATUS_SMB_BAD_COMMAND        (SRV_SERVER_STATUS | SMB_ERR_BAD_COMMAND)
#define STATUS_SMB_NO_SUPPORT         (SRV_SERVER_STATUS | SMB_ERR_NO_SUPPORT_INTERNAL)

// *** because SMB_ERR_NO_SUPPORT uses 16 bits, but we have only 12 bits
//     available for error codes, it must be special-cased in the code.

//
// SMB HARDWARE-class error codes that lack an NT or OS/2 equivalent.
//

#define STATUS_SMB_DATA               (SRV_HARDWARE_STATUS | SMB_ERR_DATA)

//
// OS/2 error codes that lack an NT or SMB equivalent.
//

#include <winerror.h>

#define STATUS_OS2_INVALID_LEVEL \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_INVALID_LEVEL)

#define STATUS_OS2_EA_LIST_INCONSISTENT \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EA_LIST_INCONSISTENT)

#define STATUS_OS2_NEGATIVE_SEEK \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_NEGATIVE_SEEK)

#define STATUS_OS2_NO_MORE_SIDS \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_NO_MORE_SEARCH_HANDLES)

#define STATUS_OS2_EAS_DIDNT_FIT \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EAS_DIDNT_FIT)

#define STATUS_OS2_EA_ACCESS_DENIED \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EA_ACCESS_DENIED)

#define STATUS_OS2_CANCEL_VIOLATION \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_CANCEL_VIOLATION)

#define STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_ATOMIC_LOCKS_NOT_SUPPORTED)

#define STATUS_OS2_CANNOT_COPY \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_CANNOT_COPY)

#endif // ndef _STATUS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\stdexts.c ===
/****************************** Module Header ******************************\
* Module Name: stdexts.c
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
* It is meant to be included after stdexts.h in one of the files comprising
* the debug extsnsions for a given product or module.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

HANDLE                  hCurrentProcess;
HANDLE                  hCurrentThread;
DWORD                   dwCurrentPc;
PWINDBG_EXTENSION_APIS  lpExtensionApis;
#ifdef KERNEL
DWORD                   dwProcessor;
#endif // KERNEL

PSTR pszAccessViolation = "%s: Access violation on \"%s\".\n";
PSTR pszMoveException   = "%s: exception in moveBlock()\n";
PSTR pszReadFailure     = "%s: lpReadProcessMemoryRoutine failed!\n";
PSTR pszCantContinue    = "%s: Non-continuable exception.\n";
BOOL fCtrlCHit = FALSE;


/*
 * This function returns TRUE once the user has hit a Ctrl-C.
 * This allows proper operation of nested SAFEWHILE loops so
 * that all levels exit.
 *
 * The globall fCtrlCHit flag needs to be reset manually and
 * is done so in the CommandEP function.
 */
BOOL IsCtrlCHit()
{
    if ((lpExtensionApis->lpCheckControlCRoutine)()) {
        fCtrlCHit = TRUE;
    }
    return fCtrlCHit;
}



VOID moveBlock(
PVOID pdst,
PVOID src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem((DWORD_PTR)src, pdst, size, &Result)) {
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess,
                    src, pdst, size, NULL))) {
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Print(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        DEBUGPRINT("%s: moveBlock(%p, %p, %x) failed.\n",
                pszExtName, pdst, src, size);
        OUTAHERE();
    }
}



BOOL tryMoveBlock(
PVOID pdst,
PVOID src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem((DWORD_PTR)src, pdst, size, &Result)) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess, src, pdst, size, NULL))) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) faulted.\n", pszExtName, pdst, src, size);
        fSuccess = FALSE;
    }
    return(fSuccess);
}



VOID moveExp(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dwGlobal;
    BOOL fSuccess = TRUE;

    try {
        dwGlobal = (DWORD_PTR)EvalExp(pszExp);
#ifndef KERNEL
        if (IsWinDbg()) {
            fSuccess = tryMoveBlock(&dwGlobal, (PVOID)dwGlobal, sizeof(DWORD));
        }
#endif // !KERNEL
        *((PDWORD_PTR)pdst) = dwGlobal;
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        Print("%s: moveExp failed on %s.\n", pszExtName, pszExp);
        OUTAHERE();
    }
}


BOOL tryMoveExp(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dwGlobal;
    BOOL fSuccess = TRUE;

    try {
        dwGlobal = (DWORD_PTR)EvalExp(pszExp);
#ifndef KERNEL
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, (PVOID)dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExp(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *((PDWORD_PTR)pdst) = dwGlobal;
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExp(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    DWORD_PTR addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMoveBlock(&dw, (PVOID)addr, sizeof(DWORD))) {
            *((PDWORD)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


BOOL tryMoveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    DWORD_PTR addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMove(dw, (PVOID)addr)) {
            *((PDWORD)pdst) = dw;
            return(TRUE);
        }
    }
    DEBUGPRINT("%s: tryMoveExpValue failed on %s.\n", pszExtName, pszExp);
    return(FALSE);
}


BOOL tryMoveExpPtr(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dwGlobal;
    BOOL fSuccess = TRUE;

    try {
        dwGlobal = (DWORD_PTR)EvalExp(pszExp);
#ifndef KERNEL
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, (PVOID)dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *((PDWORD_PTR)pdst) = dwGlobal;
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValuePtr(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dw;

    if (tryMoveExpPtr(&dw, pszExp)) {
        if (tryMoveBlock(&dw, (PVOID)dw, sizeof(dw))) {
            *((PDWORD_PTR)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


/***************************************************************************
 * Common command parsing stuff                                            *
 ***************************************************************************/
PVOID EvalExp(
LPSTR psz)
{
    PVOID p;

    p = (PVOID)(lpExtensionApis->lpGetExpressionRoutine)(psz);
    if (p == NULL) {
        Print("%s: EvalExp failed to evaluate %s.\n", pszExtName, psz);
    }
    return p;
}



PVOID OptEvalExp(
LPSTR psz)
{
    while (*psz == ' ')
        psz++;
    if (*psz == '\0') {
        return(NULL);
    }
    return(EvalExp(psz));
}



PVOID OptEvalExp2(
LPSTR *ppsz)
{
    LPSTR psz = *ppsz;
    PVOID dwRet = NULL;

    while (*psz == ' ')
        psz++;
    if (*psz != '\0') {
        dwRet = EvalExp(psz);
        while (*psz != '\0' && *psz != ' ') {
            psz++;
        }
    }
    *ppsz = psz;
    return(dwRet);
}



DWORD StringToOpts(
LPSTR psz)
{
    DWORD opts = 0;

    while (*psz != '\0' && *psz != ' ') {
        if (*psz >= 'a' && *psz <= 'z') {
            opts |= 1 << (*psz - 'a');
        } else if (*psz >= 'A' && *psz <= 'Z') {
            opts |= 1 << (*psz - 'A');
        } else {
            return(OPTS_ERROR);     // any non-letter option is an error.
        }
        psz++;
    }
    return(opts);
}


/*
 * Function to convert an option string to a DWORD of flags.  pszLegalArgs
 * is used to allow option validation at the same time.
 *
 * *ppszArgs is set to point to after the options on exit.
 * On error, returns OPTS_ERROR.
 */
DWORD GetOpts(
LPSTR *ppszArgs,
LPSTR pszLegalArgs) // OPTIONAL
{
    DWORD Opts = 0;
    LPSTR pszArgs = *ppszArgs;

    /*
     * Skip whitespace
     */
    while (*pszArgs == ' ') {
        pszArgs++;
    }
    /*
     * process '-' prepended options.
     */
    while (*pszArgs == '-') {
        pszArgs++;
        Opts = StringToOpts(pszArgs);
        /*
         * skip to whitespace or end.
         */
        while (*pszArgs != '\0' && *pszArgs != ' ') {
            pszArgs++;
        }
        /*
         * skip trailing whitespace.
         */
        while (*pszArgs == ' ') {
            pszArgs++;
        }
        *ppszArgs = pszArgs;

        /*
         * optionally validate against LegalArgs
         */
        if (pszLegalArgs != NULL && ((Opts & StringToOpts(pszLegalArgs)) != Opts)) {
            Opts = OPTS_ERROR;
            Print("Bad options.\n");
            return(Opts);
        }
    }
    return(Opts);
}



VOID PrintHuge(
LPSTR psz)
{
    /*
     * Looks like this is faulting these days - Print seems to be fixed
     * so I'm leaving this entry point for compatibility. (SAS)
     */
#ifdef ITWORKS
#define HUNK_SIZE   400
    int cch;
    CHAR chSave;

    /*
     * since dorky Print extension can't handle very long strings,
     * break it up into peices for it to chew.
     */
    cch = strlen(psz);
    while (cch > HUNK_SIZE) {
        chSave = psz[HUNK_SIZE];
        psz[HUNK_SIZE] = '\0';
        Print(psz);
        psz[HUNK_SIZE] = chSave;
        psz += HUNK_SIZE;
        cch -= HUNK_SIZE;
    }
#endif
    Print(psz);
}



/*
 * Dispatcher function used by generated entrypoint functions.
 */
VOID CommonEP(
PVOID pFunction,
LPSTR pszName,
int type,
LPSTR pszLegalOpts,
HANDLE hcp,
HANDLE hct,
DWORD dwcp,
#ifdef KERNEL
DWORD dwp,
#else // !KERNEL
PWINDBG_EXTENSION_APIS lpea,
#endif // !KERNEL
LPSTR lpas)
{
    BOOL dwOptions, fSuccess;
    PVOID param1, param2, param3;

    hCurrentProcess = hcp;
    hCurrentThread = hct;
    dwCurrentPc = dwcp;
#ifdef KERNEL
    dwProcessor = dwp;
    lpExtensionApis = &ExtensionApis;
#else // !KERNEL
    lpExtensionApis = lpea;
#endif // !KERNLE

#if 0
    DEBUGPRINT("CommonEP(%x, \"%s\", %d, \"%s\", %x, %x, %x, %x, \"%s\")\n",
            pFunction,
            pszName,
            type,
            pszLegalOpts,
            hcp,
            hct,
            dwcp,
#ifdef KERNEL
            dwp,
#else // !KERNLE
            lpea,
#endif // !KERNEL
            lpas);
#endif

    fCtrlCHit = FALSE;  // reset this with each command. (SAFEWHILE fix)
    switch (type) {
    case NOARGS:
        fSuccess = ((TYPE_NOARGS)pFunction)();
        goto Exit;
    }

    dwOptions = GetOpts(&lpas, pszLegalOpts);
    if (dwOptions == OPTS_ERROR) {
        fSuccess = Ihelp(0, pszName);
        goto Exit;
    }

    try {
        switch (type) {
        case CUSTOM:
            fSuccess = ((TYPE_CUSTOM)pFunction)(dwOptions, lpas);
            break;

        case STDARGS0:
            fSuccess = ((TYPE_STDARGS0)pFunction)(dwOptions);
            break;

        case STDARGS1:
            fSuccess = ((TYPE_STDARGS1)pFunction)(dwOptions, OptEvalExp(lpas));
            break;

        case STDARGS2:
            param1 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS2)pFunction)(dwOptions, param1, OptEvalExp(lpas));
            break;

        case STDARGS3:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS3)pFunction)(dwOptions, param1, param2, OptEvalExp(lpas));
            break;

        case STDARGS4:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            param3 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS4)pFunction)(dwOptions, param1, param2, param3, OptEvalExp(lpas));
            break;

        default:
            Print("CommonEP: Don't recognize function type %d.\n", type);
            break;
        }
    } except (GetExceptionCode() == STATUS_NONCONTINUABLE_EXCEPTION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszCantContinue, pszExtName);
    }

Exit:
    if (!fSuccess) {
        Print("%s failed.\n", pszName);
        Ihelp(0, pszName);
    }
}

/*
 * Entrypoint functions (generated from exts.h)
 */
#ifdef KERNEL
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    DWORD dwcp,                                         \
    DWORD dwp,                                          \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, dwp, lpas); \
}
#else // !KERNEL
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    DWORD dwcp,                                         \
    PWINDBG_EXTENSION_APIS lpea,                        \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, lpea, lpas); \
}
#endif // !KERNEL
#include "exts.h"
#undef DOIT


/*
 * Standard help extension - present in all standard extensions.
 */
BOOL Ihelp(
    DWORD opts,
    LPSTR lpas)
{
#define DOIT(name, help1, help2, opts, type)  { #name, help1, help2 },

    static struct {
        LPSTR pszCmdName;
        LPSTR pszHelp1;
        LPSTR pszHelp2;
    } he[] = {
#include "exts.h"
    };
#undef DOIT
    int i;

    while (*lpas == ' ')
        lpas++;

    if (*lpas == '\0') {
        Print("-------------- %s Debug Extension help:--------------\n\n", pszExtName);
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            Print(he[i].pszHelp1);
            if (opts & OFLAG(v)) {
                PrintHuge(he[i].pszHelp2);
            }
        }
        return(TRUE);
    } else {
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            if (strcmp(lpas, he[i].pszCmdName) == 0) {
                Print(he[i].pszHelp1);
                PrintHuge(he[i].pszHelp2);
                return(TRUE);
            }
        }
        Print("%s is not supported.\n", lpas);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\stdexts.h ===
/****************************** Module Header ******************************\
* Module Name: stdexts.h
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

#ifdef NOEXTAPI
#undef NOEXTAPI
#endif // !NOEXTAPI

#define NOEXTAPI
#include <wdbgexts.h>

/*
 * Preceeding this header the following must have been defined:
 * PSTR pszExtName;
 *
 * This module includes "exts.h" which defines what exported functions are
 * supported by each extension and contains all help text and legal option
 * information.  At a minimum exts.h must have:

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

 */


extern HANDLE                  hCurrentProcess;
extern HANDLE                  hCurrentThread;
extern DWORD                   dwCurrentPc;
extern PWINDBG_EXTENSION_APIS  lpExtensionApis;
#ifdef KERNEL
extern DWORD                   dwProcessor;
extern WINDBG_EXTENSION_APIS   ExtensionApis;
#endif // KERNEL

#define Print           (lpExtensionApis->lpOutputRoutine)
#define OUTAHERE()      RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
#define GetSym          (lpExtensionApis->lpGetSymbolRoutine)
#define ReadMem         (lpExtensionApis->lpReadProcessMemoryRoutine)
#define IsWinDbg()      (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))
#define SAFEWHILE(exp)  while (!IsCtrlCHit() && (exp))

extern PSTR pszAccessViolation;
extern PSTR pszMoveException;
extern PSTR pszReadFailure;

#define OPTS_ERROR 0xFFFFFFFF

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define move(dst, src)  moveBlock(&(dst), src, sizeof(dst))
#define tryMove(dst, src)  tryMoveBlock(&(dst), src, sizeof(dst))
#define tryDword(pdst, src) tryMoveBlock(pdst, src, sizeof(DWORD))
//#define DEBUGPRINT      Print       // set this when debuging your extensions
#define DEBUGPRINT

VOID moveBlock(PVOID pdst, PVOID src, DWORD size);
BOOL tryMoveBlock(PVOID pdst, PVOID src, DWORD size);
VOID moveExp(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExp(PVOID pdst, LPSTR pszExp);
VOID moveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpPtr(PVOID pdst, LPSTR pszExp);
VOID moveExpValuePtr(PVOID pdst, LPSTR pszExp);
BOOL IsCtrlCHit(VOID);

PVOID OptEvalExp(LPSTR psz);
PVOID OptEvalExp2(LPSTR *ppsz);
DWORD StringToOpts(LPSTR psz);
DWORD GetOpts(LPSTR *ppszArgs, LPSTR pszLegalArgs);
VOID PrintHuge(LPSTR psz);
PVOID EvalExp(LPSTR psz);

/*
 * entrypoint function type values
 */
#define NOARGS      0
#define STDARGS0    1
#define STDARGS1    2
#define STDARGS2    3
#define STDARGS3    4
#define STDARGS4    5
#define CUSTOM      9

/*
 * worker function prototype types
 */
typedef BOOL (* TYPE_NOARGS)(VOID);
typedef BOOL (* TYPE_STDARGS0)(DWORD);
typedef BOOL (* TYPE_STDARGS1)(DWORD, PVOID);
typedef BOOL (* TYPE_STDARGS2)(DWORD, PVOID, PVOID);
typedef BOOL (* TYPE_STDARGS3)(DWORD, PVOID, PVOID, PVOID);
typedef BOOL (* TYPE_STDARGS4)(DWORD, PVOID, PVOID, PVOID, PVOID);
typedef BOOL (* TYPE_CUSTOM)(DWORD, LPSTR);

/*
 * worker function proto-prototypes
 */
#define PROTO_NOARGS(name, opts)   BOOL I##name(VOID)
#define PROTO_STDARGS0(name, opts) BOOL I##name(DWORD options)
#define PROTO_STDARGS1(name, opts) BOOL I##name(DWORD options, PVOID param1)
#define PROTO_STDARGS2(name, opts) BOOL I##name(DWORD options, PVOID param1, PVOID param2)
#define PROTO_STDARGS3(name, opts) BOOL I##name(DWORD options, PVOID param1, PVOID param2, PVOID param3)
#define PROTO_STDARGS4(name, opts) BOOL I##name(DWORD options, PVOID param1, PVOID param2, PVOID param3, PVOID param4)
#define PROTO_CUSTOM(name, opts)   BOOL I##name(DWORD options, LPSTR pszArg)

/*
 * worker function prototypes (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type) PROTO_##type(name, opts);
#include "exts.h"
#undef DOIT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\usbxapi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    usbxapi.h

    Generated from usb.x

Abstract:

    USB imports especially for xapi

Environment:

    Xbox

--*/

#ifndef __USB_X__
#define __USB_X__


#define EXTERNUSB extern

//
//	USB drivers, and XAPI code modules that rely on USB all go into 
//	the XPP section.
//
#pragma code_seg(".XPPCODE")
#pragma data_seg(".XPP$Data")
#pragma const_seg(".XPPRDATA")


//------------------------------------------------
//  Entry Point XAPI must call
//------------------------------------------------
EXTERNUSB VOID USBD_Init(DWORD NumDeviceTypes, PXDEVICE_PREALLOC_TYPE DeviceTypes);

#endif //__USB_X__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\vlan.h ===
// ---------------------------------------------------------------------------------------
// vlan.h
//
// Virtual Lan Library
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __VLAN_H__
#define __VLAN_H__

BOOL WINAPI VLanInit();
BOOL WINAPI VLanDriver();
BOOL WINAPI VLanAttach(char * pszLan, BYTE * pbEnet, void * pvArg);
void WINAPI VLanRecv(BYTE * pb, UINT cb, void * pvArg);
BOOL WINAPI VLanXmit(BYTE * pb, UINT cb);
BOOL WINAPI VLanDetach(BYTE * pbEnet);
void WINAPI VLanTerm();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\windowsp.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\validc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    validc.h

Abstract:

    Strings of valid/invalid characters for canonicalization

Author:

    Richard Firth (rfirth) 15-May-1991

Revision History:

    03-Jan-1992 rfirth
        Added ILLEGAL_FAT_CHARS and ILLEGAL_HPFS_CHARS (from fsrtl\name.c)

    27-Sep-1991 JohnRo
        Changed TEXT macro usage to allow UNICODE.
--*/

//
// Disallowed control characters (not including \0)
//

#define CTRL_CHARS_0   TEXT(    "\001\002\003\004\005\006\007")
#define CTRL_CHARS_1   TEXT("\010\011\012\013\014\015\016\017")
#define CTRL_CHARS_2   TEXT("\020\021\022\023\024\025\026\027")
#define CTRL_CHARS_3   TEXT("\030\031\032\033\034\035\036\037")

#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

//
// Character subsets
//

#define NON_COMPONENT_CHARS TEXT("\\/:")
#define ILLEGAL_CHARS_STR   TEXT("\"<>|")
#define DOT_AND_SPACE_STR   TEXT(". ")
#define PATH_SEPARATORS     TEXT("\\/")

//
// Combinations of the above
//

#define ILLEGAL_CHARS       CTRL_CHARS_STR ILLEGAL_CHARS_STR
#define ILLEGAL_NAME_CHARS_STR  TEXT("\"/\\[]:|<>+=;,?") CTRL_CHARS_STR

//
// Characters which may not appear in a canonicalized FAT filename are:
//
//  0x00 - 0x1f " * + , / : ; < = > ? [ \ ] |
//

#define ILLEGAL_FAT_CHARS   CTRL_CHARS_STR TEXT("\"*+,/:;<=>?[\\]|")

//
// Characters which may not appear in a canonicalized HPFS filename are:
//
//  0x00 - 0x1f " * / : < > ? \ |
//

#define ILLEGAL_HPFS_CHARS  CTRL_CHARS_STR TEXT("\"*/:<>?\\|")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\w32w64.h ===
/****************************** Module Header ******************************\
* Module Name: w32w64.h
*
* Copyright (c) 1985-95, Microsoft Corporation
*
* This header file contains macros used to access kernel mode data
* from user mode for wow64.
*
* History:
* 08-18-98 PeterHal     Created.
\***************************************************************************/

#ifndef _W32W64_
#define _W32W64_


/*
 * Kernel32 includes this structure, but we don't want to use _ptr64 in it yet.
 * Kernel32 does not use any shared memory itself.
 */
#if defined(BUILD_WOW6432) && !defined(_KERNEL32_)

    #define KPTR_MODIFIER __ptr64

    typedef VOID * __ptr64          KERNEL_PVOID;
    typedef unsigned __int64        KERNEL_UINT_PTR;
    typedef __int64                 KERNEL_INT_PTR;
    typedef unsigned __int64        KERNEL_ULONG_PTR;
    typedef __int64                 KERNEL_LONG_PTR;

    #define KHANDLE_NULL            0

    #ifdef STRICT
    typedef void * KPTR_MODIFIER KHANDLE;
    #define DECLARE_KHANDLE(name) typedef struct name##__ * KPTR_MODIFIER K ## name
    #else
    typedef KERNEL_PVOID KHANDLE;
    #define DECLARE_KHANDLE(name) typedef KHANDLE K ## name
    #endif

#else

    #define KPTR_MODIFIER

    typedef PVOID                   KERNEL_PVOID;
    typedef UINT_PTR                KERNEL_UINT_PTR;
    typedef INT_PTR                 KERNEL_INT_PTR;
    typedef ULONG_PTR               KERNEL_ULONG_PTR;
    typedef LONG_PTR                KERNEL_LONG_PTR;

    #define KHANDLE_NULL            NULL

    #define DECLARE_KHANDLE(name) typedef name K ## name
    typedef HANDLE KHANDLE;

#endif



#endif // _W32W64_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\synth.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992  Microsoft Corporation

Module Name:

    synth.h

Abstract:

    This include file defines constants and types for
    the Microsoft midi synthesizer driver

    This header file is shared between the low level driver and the
    kernel mode driver.

Author:

    Robin Speed (RobinSp) 20-Oct-92

Revision History:

--*/

#define STR_DRIVERNAME L"synth"
#define STR_MV_DRIVERNAME L"mvopl3"
#define STR_OPL3_DEVICENAME L"\\Device\\opl3.mid"
#define STR_ADLIB_DEVICENAME L"\\Device\\adlib.mid"

/*
 *  Stucture for passing synth data
 *  Why on earth isn't there a type for sharing short data?
 */

 typedef struct {
     unsigned short IoPort;
     unsigned short PortData;
 } SYNTH_DATA, *PSYNTH_DATA;

/* positions within FM */
#define AD_LSI                          (0x000)
#define AD_LSI2                         (0x101)
#define AD_TIMER1                       (0x001)
#define AD_TIMER2                       (0x002)
#define AD_MASK                         (0x004)
#define AD_CONNECTION                   (0x104)
#define AD_NEW                          (0x105)
#define AD_NTS                          (0x008)
#define AD_MULT                         (0x020)
#define AD_MULT2                        (0x120)
#define AD_LEVEL                        (0x040)
#define AD_LEVEL2                       (0x140)
#define AD_AD                           (0x060)
#define AD_AD2                          (0x160)
#define AD_SR                           (0x080)
#define AD_SR2                          (0x180)
#define AD_FNUMBER                      (0x0a0)
#define AD_FNUMBER2                     (0x1a0)
#define AD_BLOCK                        (0x0b0)
#define AD_BLOCK2                       (0x1b0)
#define AD_DRUM                         (0x0bd)
#define AD_FEEDBACK                     (0x0c0)
#define AD_FEEDBACK2                    (0x1c0)
#define AD_WAVE                         (0x0e0)
#define AD_WAVE2                        (0x1e0)

/*
**  Special IOCTL
*/

#define IOCTL_MIDI_SET_OPL3_MODE CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x000A, METHOD_BUFFERED, FILE_WRITE_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\winnlsp.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1998, Microsoft Corporation

Module Name:

    winnlsp.h

Abstract:

    Private procedure declarations, constant definitions, and macros for the
    NLS component.

--*/

#ifndef _WINNLSP_
#define _WINNLSP_

#ifdef __cplusplus
extern "C" {
#endif


//
//  Flags for DLL Code Page Translation Function.
//
#define NLS_CP_CPINFO             0x10000000
#define NLS_CP_CPINFOEX           0x20000000
#define NLS_CP_MBTOWC             0x40000000
#define NLS_CP_WCTOMB             0x80000000


#define NORM_STOP_ON_NULL         0x10000000  // stop at the null termination

#define LCMAP_IGNOREDBCS          0x80000000  // don't casemap DBCS characters

//
// LCType to represent the registry locale value
//
#define LOCALE_SLOCALE                (-1)
#define DATE_ADDHIJRIDATETEMP     0x80000000  // use AddHijriDateTemp reg value
WINBASEAPI
BOOL
WINAPI
InvalidateNLSCache(void);


//
//  This private API is only called by the Complex Script
//  Language Pack (CSLPK).
//
ULONG
WINAPI NlsGetCacheUpdateCount(void);


//
// This API is called only from intl.cpl when the user
// locale changes.
//
void
WINAPI
NlsResetProcessLocale(void);
//
// These definitions are used by both winnls and base\server
//

//
//  Names of Registry Value Entries.
//
#define NLS_VALUE_ACP              L"ACP"
#define NLS_VALUE_OEMCP            L"OEMCP"
#define NLS_VALUE_MACCP            L"MACCP"
#define NLS_VALUE_DEFAULT          L"Default"

//  User Info
#define NLS_VALUE_LOCALE           L"Locale"
#define NLS_VALUE_SLANGUAGE        L"sLanguage"
#define NLS_VALUE_ICOUNTRY         L"iCountry"
#define NLS_VALUE_SCOUNTRY         L"sCountry"
#define NLS_VALUE_SLIST            L"sList"
#define NLS_VALUE_IMEASURE         L"iMeasure"
#define NLS_VALUE_IPAPERSIZE       L"iPaperSize"
#define NLS_VALUE_SDECIMAL         L"sDecimal"
#define NLS_VALUE_STHOUSAND        L"sThousand"
#define NLS_VALUE_SGROUPING        L"sGrouping"
#define NLS_VALUE_IDIGITS          L"iDigits"
#define NLS_VALUE_ILZERO           L"iLZero"
#define NLS_VALUE_INEGNUMBER       L"iNegNumber"
#define NLS_VALUE_SNATIVEDIGITS    L"sNativeDigits"
#define NLS_VALUE_IDIGITSUBST      L"NumShape"
#define NLS_VALUE_SCURRENCY        L"sCurrency"
#define NLS_VALUE_SMONDECIMALSEP   L"sMonDecimalSep"
#define NLS_VALUE_SMONTHOUSANDSEP  L"sMonThousandSep"
#define NLS_VALUE_SMONGROUPING     L"sMonGrouping"
#define NLS_VALUE_ICURRDIGITS      L"iCurrDigits"
#define NLS_VALUE_ICURRENCY        L"iCurrency"
#define NLS_VALUE_INEGCURR         L"iNegCurr"
#define NLS_VALUE_SPOSITIVESIGN    L"sPositiveSign"
#define NLS_VALUE_SNEGATIVESIGN    L"sNegativeSign"
#define NLS_VALUE_STIMEFORMAT      L"sTimeFormat"
#define NLS_VALUE_STIME            L"sTime"
#define NLS_VALUE_ITIME            L"iTime"
#define NLS_VALUE_ITLZERO          L"iTLZero"
#define NLS_VALUE_ITIMEMARKPOSN    L"iTimePrefix"
#define NLS_VALUE_S1159            L"s1159"
#define NLS_VALUE_S2359            L"s2359"
#define NLS_VALUE_SSHORTDATE       L"sShortDate"
#define NLS_VALUE_SDATE            L"sDate"
#define NLS_VALUE_IDATE            L"iDate"
#define NLS_VALUE_SYEARMONTH       L"sYearMonth"
#define NLS_VALUE_SLONGDATE        L"sLongDate"
#define NLS_VALUE_ICALENDARTYPE    L"iCalendarType"
#define NLS_VALUE_IFIRSTDAYOFWEEK  L"iFirstDayOfWeek"
#define NLS_VALUE_IFIRSTWEEKOFYEAR L"iFirstWeekOfYear"


//
//  String constants for CreateSection/OpenSection name string.
//
#define NLS_SECTION_CPPREFIX       L"\\NLS\\NlsSectionCP"
#define NLS_SECTION_LANGPREFIX     L"\\NLS\\NlsSectionLANG"

#define NLS_SECTION_UNICODE        L"\\NLS\\NlsSectionUnicode"
#define NLS_SECTION_LOCALE         L"\\NLS\\NlsSectionLocale"
#define NLS_SECTION_CTYPE          L"\\NLS\\NlsSectionCType"
#define NLS_SECTION_SORTKEY        L"\\NLS\\NlsSectionSortkey"
#define NLS_SECTION_SORTTBLS       L"\\NLS\\NlsSectionSortTbls"
#define NLS_SECTION_LANG_INTL      L"\\NLS\\NlsSectionLANG_INTL"
#define NLS_SECTION_LANG_EXCEPT    L"\\NLS\\NlsSectionLANG_EXCEPT"

//
//  Unicode file names.
//  These files will always be installed by setup in the system directory,
//  so there is no need to put these names in the registry.
//
#define NLS_FILE_UNICODE           L"unicode.nls"
#define NLS_FILE_LOCALE            L"locale.nls"
#define NLS_FILE_CTYPE             L"ctype.nls"
#define NLS_FILE_SORTKEY           L"sortkey.nls"
#define NLS_FILE_SORTTBLS          L"sorttbls.nls"
#define NLS_FILE_LANG_INTL         L"l_intl.nls"
#define NLS_FILE_LANG_EXCEPT       L"l_except.nls"

//
//  Default file names if registry is corrupt.
//
#define NLS_DEFAULT_FILE_ACP       L"c_1252.nls"
#define NLS_DEFAULT_FILE_OEMCP     L"c_437.nls"



//
//  Default section names if registry is corrupt.
//
#define NLS_DEFAULT_SECTION_ACP    L"\\NLS\\NlsSectionCP1252"
#define NLS_DEFAULT_SECTION_OEMCP  L"\\NLS\\NlsSectionCP437"

#ifdef _WINDOWS_BASE
//
//  winnls routines that are called from base\server.  The prototypes must
//  continue to match the typedefs.
//

typedef ULONG
(*PNLS_CONVERT_INTEGER_TO_STRING)(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size);
ULONG
NlsConvertIntegerToString(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size);

typedef ULONG
(*PGET_NLS_SECTION_NAME)(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName);
ULONG
GetNlsSectionName(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName);


typedef WINBASEAPI BOOL
(WINAPI *PIS_VALID_CODEPAGE)(
    UINT CodePage);
WINBASEAPI BOOL WINAPI
IsValidCodePage(
    UINT CodePage);

typedef ULONG
(*POPEN_DATA_FILE)(HANDLE *phFile, LPWSTR pFile);
ULONG OpenDataFile(HANDLE *phFile, LPWSTR pFile);

typedef ULONG
(*PGET_DEFAULT_SORTKEY_SIZE)(PLARGE_INTEGER pSize);
ULONG GetDefaultSortkeySize(PLARGE_INTEGER pSize);

typedef ULONG
(*PGET_LINGUIST_LANG_SIZE)(PLARGE_INTEGER pSize);
ULONG GetLinguistLangSize(PLARGE_INTEGER pSize);

typedef BOOL
(*PVALIDATE_LOCALE)(LCID Locale);
BOOL ValidateLocale(LCID Locale);

typedef BOOL
(*PVALIDATE_LCTYPE)(PVOID pInfo, LCTYPE LCType, LPWSTR *ppwReg, LPWSTR *ppwCache);
BOOL ValidateLCType(PNLS_USER_INFO pInfo, LCTYPE LCType, LPWSTR *ppwReg, LPWSTR *ppwCache);

#endif // _WINDOWS_BASE

#ifdef __cplusplus
}
#endif

#endif // _WINNLSP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\winprtp.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation
All rights reserved.

Module Name:

    WinPrtP.h

Abstract:

    Private PrintUI library public header.

Author:

    Albert Ting (AlbertT)  27-Jun-95

Revision History:

--*/

DEFINE_GUID(CLSID_PrintUIShellExtension, 0x77597368, 0x7b15, 0x11d0, 0xa0, 0xc2, 0x08, 0x00, 0x36, 0xaf, 0x3f, 0x03 );
DEFINE_GUID(IID_IFindPrinter, 0xb4cd8efc, 0xd70b, 0x11d1, 0x99, 0xb1, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IPrinterFolder,  0xef99abd4, 0x5b8d, 0x11d1, 0xa9, 0xc8, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IFolderNotify,  0xff22d71, 0x5172, 0x11d1, 0xa9, 0xc6, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IDsPrinterProperties,0x8a58bc16, 0x410e, 0x11d1, 0xa9, 0xc2, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IPhysicalLocation, 0xdfe8c7eb, 0x651b, 0x11d2, 0x92, 0xce, 0x08, 0x00, 0x36, 0xaf, 0x3f, 0x03);
DEFINE_GUID(IID_IPrnStream, 0xa24c1d62, 0x75f5, 0x11d2, 0xb8, 0x99, 0x0, 0xc0, 0x4f, 0x86, 0xae, 0x55);


#ifndef _PRTLIB_H
#define _PRTLIB_H

#ifdef __cplusplus
extern "C" {
#endif

/********************************************************************

    Prototypes

********************************************************************/

//
// Initialize the library.
//
BOOL
bPrintLibInit(
    VOID
    );

//
// Create a new print queue.
//
VOID
vQueueCreate(
    HWND    hwndOwner,
    LPCTSTR pszPrinter,
    INT     nCmdShow,
    LPARAM  lParam
    );

//
// Display document defaults for a print queue.
//
VOID
vDocumentDefaults(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    );

#define PRINTER_SHARING_PAGE 1

//
// Display properties for a print queue.
//
VOID
vPrinterPropPages(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    );

VOID
vServerPropPages(
    HWND    hwndOwner,
    LPCTSTR pszServerName,
    INT     nCmdShow,
    LPARAM  lParam
    );

//
// Run printer and drivers setup.
//
BOOL
bPrinterSetup(
    HWND    hwnd,
    UINT    uAction,
    UINT    cchPrinterName,
    LPTSTR  pszPrinterName,
    UINT*   pcchPrinterName,
    LPCTSTR pszServerName
    );

/********************************************************************

    Print folder interfaces.

********************************************************************/

/********************************************************************

    Printers Folder Extenstion Interface.  This interface extends
    the printers IShellFolder implementation.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPrinterFolder

DECLARE_INTERFACE_(IPrinterFolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IPrintersFolder methods ***
    STDMETHOD_(BOOL, IsPrinter)( THIS_ LPCITEMIDLIST pidl ) PURE;
};

/********************************************************************

    Folder Notification interface.

********************************************************************/

//
// Folder notify type
//

typedef enum IFolderNotifyType
{
    kFolderNone,                            // No item changed do not generate notification
    kFolderUpdate,                          // Item changed
    kFolderAttributes,                      // Item attribute changed
    kFolderCreate,                          // Item created
    kFolderDelete,                          // Item deleted
    kFolderRename,                          // Item renamed
    kFolderUpdateAll,                       // Update all items == 'F5'
} FOLDER_NOTIFY_TYPE, *PFOLDER_NOTIFY_TYPE;

//
// Folder notification callback interface definition.
//

#undef  INTERFACE
#define INTERFACE   IFolderNotify

DECLARE_INTERFACE_(IFolderNotify, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IFolderNotify methods ***
    STDMETHOD_(BOOL, ProcessNotify)( THIS_ FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName ) PURE;
};

typedef struct _FOLDER_PRINTER_DATA {
    LPCTSTR pName;
    LPCTSTR pComment;
    DWORD   Status;
    DWORD   Attributes;
    DWORD   cJobs;
    DWORD   cbSize;
    LPCTSTR pLocation;
    LPCTSTR pDriverName;
    LPCTSTR pStatus;            // Connection status i.e. <opening...>
    LPCTSTR pPortName;
} FOLDER_PRINTER_DATA, *PFOLDER_PRINTER_DATA;

//
// Register folder watch.  Currently this only works for print
// servers; connections aren't maintained.
//
HRESULT
RegisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder
    );

//
// Unregister folder watch.  Currently this only works for print
// servers; connections aren't maintained.
//
HRESULT
UnregisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder
    );

BOOL
bFolderEnumPrinters(
    IN   HANDLE                  hFolder,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded,
    OUT  PDWORD                  pcbReturned
    );

BOOL
bFolderRefresh(
    IN   HANDLE                  hFolder,
    OUT  PBOOL                   pbAdministrator
    );

BOOL
bFolderGetPrinter(
    IN   HANDLE                  hFolder,
    IN   LPCTSTR                 pszPrinter,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded
    );

/********************************************************************

    IPhysicalLocation

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPhysicalLocation

DECLARE_INTERFACE_(IPhysicalLocation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IPhysicalLocation methods
    STDMETHOD(DiscoverPhysicalLocation)(THIS) PURE;
    STDMETHOD(GetExactPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetSearchPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;

    // IPhysicalLocation methods for fetching individual physical locations
    STDMETHOD(GetUserPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetMachinePhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetSubnetPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetSitePhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(BrowseForLocation)(THIS_ HWND hParent, BSTR bsDefault, BSTR *pbsLocation) PURE;
    STDMETHOD(ShowPhysicalLocationUI)(THIS) PURE;
};

/********************************************************************

    IDsPrinterProperties

    This is a private interface used to launch printer properties
    from the DS MMC snapin.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IDsPrinterProperties

DECLARE_INTERFACE_(IDsPrinterProperties, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IDsFolder methods
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, LPCWSTR pszObjectPath, PBOOL pbDisplayed) PURE;
};

/********************************************************************

    Find Printer Interface.  This inferface allows a user to find
    a printer either on the network or in the DS if one is
    available.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IFindPrinter

DECLARE_INTERFACE_(IFindPrinter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IFindPrinter methods
    STDMETHOD(FindPrinter)(THIS_ HWND hwnd, LPWSTR pszBuffer, UINT *puSize) PURE;
};

/********************************************************************

    Print Dialog Data Structures.

********************************************************************/

#define PDS_PROPSHEETPAGE  0x00000001       // If prop page is a psp or hpage.
#define PDS_NOAPPLYNOW     0x00000002       // Do not display the apply button
#define PDS_PROPTITLE      0x00000004       // Add properties text to end of title
#define PDS_USEHICON       0x00000008       // Icon is a handle to icon
#define PDS_DEFTITLE       0x00000010       // Use default title

//
// Return value from InsertDevicePage() function
//

typedef enum IPrintDlgErrorCodes
{
    kSuccess,                               // Success no error
    kInvalidDevMode,                        // Invalid devmode specified
    kInvalidPrinterName,                    // Invalid printer name specified
    kPageAlreadyLoaded,                     // Device page is already loaded
    kError,                                 // General error
    kAccessDenied,                          // User does not have access to printer
} PRINTDLG_ERROR, *PPRINTDLG_ERROR;

//
// Print dialog interface definition.
//

#undef  INTERFACE
#define INTERFACE   IPrintDlg

DECLARE_INTERFACE(IPrintDlg)
{
    // *** IPrintDlg methods ***
    STDMETHOD_(PDEVMODE, GetCurrentDevMode)( THIS ) PURE;
    STDMETHOD_(BOOL, FindPrinter)( THIS_ HWND hwnd, LPWSTR pszBuffer, UINT cchSize ) PURE;
    STDMETHOD_(UINT, InsertDevicePage)( THIS_ LPCWSTR pszName, PDEVMODE pDevMode ) PURE;
    STDMETHOD_(BOOL, GetCurrentPrinterName)( THIS_ LPWSTR pszPrinterName, PDWORD pdwSize ) PURE;
    STDMETHOD_(BOOL, AddPrinterWizard)( THIS ) PURE;
    STDMETHOD_(UINT, RemoveDevicePage)( THIS ) PURE;
    STDMETHOD_(BOOL, RefreshDevMode)( THIS ) PURE;
    STDMETHOD_(BOOL, DriverApplyNow)( THIS ) PURE;
    STDMETHOD_(BOOL, AddPrinterWizardModal )( THIS_ HWND hwnd, UINT *pcchName, LPWSTR pszName ) PURE;
};

//
// Print Dialog Page Structure.
//

typedef struct PrintDlgPage
{
    DWORD               dwSize;             // Size of this structure for validation
    LPARAM              lParam;             // User defined data
    PVOID               pAppInterface;      // Application page interface
    IPrintDlg          *pPrintDlg;          // Pointer to print dialog interface
    HANDLE              hHandle;            // Compstui page handle
} PRINTDLG_PAGE, *PPRINTDLG_PAGE;

//
// Print Dialog Data Structure.
//

typedef struct PrintDlgData
{
    DWORD               dwSize;             // Size of this structure for validation
    LPCWSTR             pszCaption;         // Dialog caption
    HWND                hwndParent;         // Parent window handle
    HINSTANCE           hInstance;          // Header instance handle
    union
    {
        HICON           hIcon;              // Dialog icon handle
        DWORD           IconID;             // Dialog icon identifier
    };
    DWORD               dwComDlgFlags;      // Common Dialog flags
    UINT                nComDlgPages;       // Number of common dialog pages
    union
    {
        LPPROPSHEETPAGE pComDlgpsp;         // Pointer to array of prop sheet pages
        HPROPSHEETPAGE *pComDlghpage;       // Pointer to array of prop sheet page handles
    };
    DWORD               dwAppFlags;         // Application page flags
    UINT                nAppPages;          // Number of application pages
    union
    {
        LPPROPSHEETPAGE pApppsp;            // Pointer to array of prop sheet pages
        HPROPSHEETPAGE *pApphpage;          // Pointer to array of prop sheet page handles
    };
    DWORD               dwExclusionFlags;   // Exclusion flags == Devmode field selection bits
    PVOID               pAppPageInterface;  // Interface pointer given to the application pages
} PRINTDLG_DATA, *PPRINTDLG_DATA;

//
// Print Dialog main entry point.
//

BOOL
bPrintDlgSheetsPropPages(
    IN HWND             hWnd,               // Parent window handle
    IN PPRINTDLG_DATA   pPrintDlgData       // Pointer to print dlg data
    );

#define SZ_PRINTUI                  TEXT("printui.dll")

#define SZ_PRINTDLGSHEETSPROPPAGES  "bPrintDlgSheetsPropPages"

typedef BOOL(*PF_PRINTDLGSHEETSPROPPAGES)( HWND, PPRINTDLG_DATA );


/********************************************************************

    IPageSwitch - Interface used as a connection point for
    the connect to printer dialog when integrated in a wizard.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPageSwitch

DECLARE_INTERFACE(IPageSwitch)
{
    // *** INotifyReflect methods ***

    //
    // This functions provide opportunity to the client to change
    // the next/prev page ID and/or allow/deny advancing to the
    // next/prev page.
    //
    // S_OK:        means you can advance to the next/prev page
    // S_FALSE:     means you cant advance to the next/prev page
    //
    STDMETHOD(GetPrevPageID)( THIS_ UINT *puPageID ) PURE;
    STDMETHOD(GetNextPageID)( THIS_ UINT *puPageID ) PURE;

    //
    // The property page calls this method when the printer connection is
    // successfully created and we are about to advance to the
    // next/prev page
    //
    STDMETHOD(SetPrinterInfo)( THIS_ LPCWSTR pszPrinterName, LPCWSTR pszComment, LPCWSTR pszLocation, LPCWSTR pszShareName ) PURE;

    //
    // This method provide notification to the client that
    // the user clicked "Cancel" button on the wizard - which
    // normaly leads to closing the wizard.
    //
    // S_OK     - Prevent cancel operation
    // S_FALSE  - Allow cancel operation
    //
    STDMETHOD(QueryCancel)( THIS ) PURE;
};

//
// The API function for creating the ConnectToPrinterDlg style
// property page
//
HRESULT
ConnectToPrinterPropertyPage(
    OUT HPROPSHEETPAGE   *phPsp,
    OUT UINT             *puPageID,
    IN  IPageSwitch      *pPageSwitchController
    );

/********************************************************************

    IPrnStream flags

********************************************************************/

typedef enum _PrinterPersistentFlags
{
    PRST_PRINTER_DATA       = 1<<0,
    PRST_PRINTER_INFO_2     = 1<<1,
    PRST_PRINTER_INFO_7     = 1<<2,
    PRST_PRINTER_SEC        = 1<<3,
    PRST_USER_DEVMODE       = 1<<4,
    PRST_PRINTER_DEVMODE    = 1<<5,
    PRST_COLOR_PROF         = 1<<6,
    PRST_FORCE_NAME         = 1<<7,
    PRST_RESOLVE_NAME       = 1<<8,
    PRST_RESOLVE_PORT       = 1<<9,
    PRST_RESOLVE_SHARE      = 1<<10,
    PRST_DONT_GENERATE_SHARE = 1<<11,
    PRST_MINIMUM_SETTINGS   = PRST_PRINTER_DATA | PRST_PRINTER_INFO_2 | PRST_PRINTER_DEVMODE,
    PRST_ALL_SETTINGS       = PRST_MINIMUM_SETTINGS | 
                              PRST_PRINTER_INFO_7   | 
                              PRST_PRINTER_SEC      | 
                              PRST_USER_DEVMODE     | 
                              PRST_COLOR_PROF,
} PrinterPersistentFlags;

/********************************************************************

    IPrnStream query flags.

********************************************************************/

typedef enum _PrinterPersistentQueryFlag
{
    kPrinterPersistentPrinterInfo2,
    kPrinterPersistentPrinterInfo7,
    kPrinterPersistentUserDevMode,
    kPrinterPersistentPrinterDevMode,
    kPrinterPersistentSecurity,
    kPrinterPersistentColorProfile,
} PrinterPersistentQueryFlag;

typedef union _PersistentInfo
{
    PRINTER_INFO_2      *pi2;
    PRINTER_INFO_7      *pi7;
    DEVMODE             *pDevMode;
    SECURITY_DESCRIPTOR *pszSecurity;
    LPWSTR              pMultiSzColor;
} PersistentInfo;

/********************************************************************

    IPrnStream interface definition

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPrnStream

DECLARE_INTERFACE_(IPrnStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IPrnStream methods
    STDMETHOD(BindPrinterAndFile)(THIS_ LPCWSTR pszPrinter, LPCWSTR pszFile) PURE;
    STDMETHOD(StorePrinterInfo)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(RestorePrinterInfo)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(QueryPrinterInfo)(THIS_ PrinterPersistentQueryFlag Flag, PersistentInfo *pPrstInfo) PURE;
};

/********************************************************************

    Error codes returned by IPrnStream methods

********************************************************************/

typedef enum _PrnPrstError
{
    //
    //  When storing/ restoring opereations called and
    //  BindPrinterAndFile wasn't called or failed
    //
    PRN_PERSIST_ERROR_INVALID_OBJ       = 0x1,
    //
    //  Failed to write Printer data because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PRNDATA     = 0x2,
    //
    //  Failed to restore Printer data because SetPrinterData failed
    //
    PRN_PERSIST_ERROR_RESTORE_PRNDATA   = 0x3,
    //
    //  Failed to restore Printer data because because reading failure
    //
    PRN_PERSIST_ERROR_READ_PRNDATA      = 0x4,
    //
    //  Failed to store Printer Info 2 because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PI2         = 0x5,
    //
    //  Failed to store Printer Info 2 because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_PI2           = 0x6,
    //
    //  Failed to restore Printer Info 2 because reading failure
    //
    PRN_PERSIST_ERROR_READ_PI2          = 0x7,
    //
    //  Failed to restore Printer Info 2 because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_PI2       = 0x8,
    //
    //  Failed to store Printer Info 7 because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PI7         = 0x9,
    //
    //  Failed to store Printer Info 7 because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_PI7           = 0xa,
    //
    //  Failed to restore Printer Info 7 because reading failure
    //
    PRN_PERSIST_ERROR_READ_PI7          = 0xb,
    //
    //  Failed to restore Printer Info 7 because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_PI7       = 0xc,
    //
    //  Failed to store Printer Security Descriptor because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_SEC         = 0xd,
    //
    //  Failed to store Printer Security Descriptor because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_SEC           = 0xe,
    //
    //  Failed to restore Printer Security Descriptor because reading failure
    //
    PRN_PERSIST_ERROR_READ_SEC          = 0xf,
    //
    //  Failed to restore Printer Security Descriptor because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_SEC       = 0x10,
    //
    //  Failed to store Printer Color Profiles because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_COLOR_PRF   = 0x11,
    //
    //  Failed to store Printer Color Profiles because EnumcolorProfiles failure
    //
    PRN_PERSIST_ERROR_GET_COLOR_PRF     = 0x12,
    //
    //  Failed to restore Printer Color Profiles because reading failure
    //
    PRN_PERSIST_ERROR_READ_COLOR_PRF    = 0x13,
    //
    //  Failed to restore Printer Color Profiles because AddColorProfile failure
    //
    PRN_PERSIST_ERROR_RESTORE_COLOR_PRF = 0x14,
    //
    //  Failed to store User DevMode because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_USR_DEVMODE = 0x15,
    //
    //  Failed to store User DevMode because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_USR_DEVMODE   = 0x16,
    //
    //  Failed to restore User DevMode because reading failure
    //
    PRN_PERSIST_ERROR_READ_USR_DEVMODE  = 0x17,
    //
    //  Failed to restore User DevMode because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_USR_DEVMODE   = 0x18,
    //
    //  Failed to store Printer DevMode because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PRN_DEVMODE     = 0x19,
    //
    //  Failed to store Printer DevMode because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_PRN_DEVMODE       = 0x1a,
    //
    //  Failed to restore Printer DevMode because reading failure
    //
    PRN_PERSIST_ERROR_READ_PRN_DEVMODE      = 0x1b,
    //
    //  Failed to restore Printer DevMode because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_PRN_DEVMODE   = 0x1c,
    //
    //  Failed because of unresolved printer name conflict
    //
    PRN_PERSIST_ERROR_PRN_NAME_CONFLICT     = 0x1d,
    //
    //  Failed because of printer name conflict
    //
    PRN_PERSIST_ERROR_UNBOUND               = 0x1e,
    //
    //  Restoring failure because failure at building backup info
    //
    PRN_PERSIST_ERROR_BACKUP                = 0x1f,
    //
    //  Restoring failure and Backup Failure too ; printer settings in undefined status
    //
    PRN_PERSIST_ERROR_FATAL                 = 0xffff
} PrnPrstError;

#ifdef __cplusplus
}
#endif
#endif // ndef _PRTLIB_HXX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\tstr.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    tstr.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa() routine.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    18-Oct-1991 JohnRo
        Added NetpCopy routines and WCSSIZE().
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (like strncpy but do conversions as well).
    09-Dec-1991 rfirth
        Added STRREV
    03-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
    09-Jan-1992 JohnRo
        Added ATOL() macro and wtol() routine.
        Ditto ULTOA() macro and ultow() routine.
    16-Jan-1992 Danl
        Cut this info from \net\inc\tstring.h
    30-Jan-1992 JohnRo
        Added STRSTR().
        Use _wcsupr() instead of wcsupr() to keep PC-LINT happy.
        Added STRCMPI() and STRNCMPI().
        Fixed a few definitions which were missing MAKE_STR_FUNCTION etc.
    14-Mar-1992 JohnRo
        Avoid compiler warnings using WCSSIZE(), MEMCPY(), etc.
        Added TCHAR_TAB.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

#ifndef _TSTR_H_INCLUDED
#define _TSTR_H_INCLUDED

#include <ctype.h>              // isdigit(), iswdigit() eventually, etc.
#include <stdlib.h>             // atol(), _ultoa().
#include <string.h>             // memcpy(), strlen(), etc.
#include <wchar.h>

#ifdef __cplusplus
extern "C" {
#endif

LPWSTR
ultow (
    IN DWORD Value,
    OUT LPWSTR Area,
    IN DWORD Radix
    );

LONG
wtol (
    IN LPWSTR Src
    );


#ifdef LM20_COMPATIBLE
#define MAKE_STR_FUNCTION(s)    s##f
#else
#define MAKE_STR_FUNCTION(s)    s
#endif


#if defined(UNICODE)

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(wtol)(Src)

#define ISALNUM(tchar)      iswalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      iswalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iswcntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      iswdigit(tchar)
#define ISGRAPH(tchar)      iswgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      iswlower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      iswprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      iswpunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      iswspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      iswupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     iswxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscat)((dest), (src))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(wcschr)((s1), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscpy)((dest), (src))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(wcscspn)((s), (c))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(wcslen)(s)
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncat)((dest), (src), (n))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncpy)((dest), (src), (n))
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(wcsspn)((s1), (s2))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(wcsrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(wcswcs)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(_wcsupr)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(wcscmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(wcsncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)

#define TOLOWER(tchar)      towlower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      towupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(ultow)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  WCHAR

#else   // not UNICODE

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(atol)(Src)

#define ISALNUM(tchar)      isalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      isalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iscntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      isdigit(tchar)
#define ISGRAPH(tchar)      isgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      islower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      isprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      ispunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      isspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      isupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     isxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcat)((dest), (src))
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncat)((dest), (src), (n))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(strlen)(s)
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(strspn)((s1), (s2))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(strcspn)((s), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcpy)((dest), (src))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncpy)((dest), (src), (n))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(strchr)((s1), (c))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(strrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(strstr)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(strupr)(s)
#define STRREV(s)           (LPTSTR)MAKE_STR_FUNCTION(strrev)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(strcmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(_stricmp)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(_stricmp)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(strncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_strnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_strnicmp)

#define TOLOWER(tchar)      tolower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      toupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(_ultoa)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  TCHAR

#endif // not UNICODE


//
// For the memory routines, the counts are always BYTE counts.
//
#define MEMCPY                  MAKE_STR_FUNCTION(memcpy)
#define MEMMOVE                 MAKE_STR_FUNCTION(memmove)

//
// These are used to determine the number of bytes (including the NUL
// terminator) in a string.  This will generally be used when
// calculating the size of a string for allocation purposes.
//

#define STRSIZE(p)      ((STRLEN(p)+1) * sizeof(TCHAR))
#define WCSSIZE(s)      ((MAKE_STR_FUNCTION(wcslen)(s)+1) * sizeof(WCHAR))


//
// character literals (both types)
//

#define TCHAR_EOS       ((_CHAR_TYPE)'\0')
#define TCHAR_STAR      ((_CHAR_TYPE)'*')
#define TCHAR_BACKSLASH ((_CHAR_TYPE)'\\')
#define TCHAR_FWDSLASH  ((_CHAR_TYPE)'/')
#define TCHAR_COLON     ((_CHAR_TYPE)':')
#define TCHAR_DOT       ((_CHAR_TYPE)'.')
#define TCHAR_SPACE     ((_CHAR_TYPE)' ')
#define TCHAR_TAB       ((_CHAR_TYPE)'\t')


//
// General purpose macro for casting character types to whatever type in vogue
// (as defined in this file)
//

#define MAKE_TCHAR(c)   ((_CHAR_TYPE)(c))

//
// IS_PATH_SEPARATOR
//
// lifted from curdir.c and changed to use TCHAR_ character literals, checks
// if a character is a path separator i.e. is a member of the set [\/]
//

#define IS_PATH_SEPARATOR(ch) ((ch == TCHAR_BACKSLASH) || (ch == TCHAR_FWDSLASH))

//
// The following 2 macros lifted from I_Net canonicalization files
//

#define IS_DRIVE(c)             ISALPHA(c)
#define IS_NON_ZERO_DIGIT(c)    (((c) >= MAKE_TCHAR('1')) && ((c) <= MAKE_TCHAR('9')))

//
// STRING_SPACE_REQD returns a number (of bytes) corresponding to the space
// required in which (n) characters can be accomodated
//

#define STRING_SPACE_REQD(n)    ((n) * sizeof(_CHAR_TYPE))

//
// DOWN_LEVEL_STRLEN returns the number of single-byte characters necessary to
// store a converted _CHAR_TYPE string. This will be WCHAR (or wchar_t) if
// UNICODE is defined or CHAR (or char) otherwise
//

#define DOWN_LEVEL_STRSIZE(n)   ((n) / sizeof(_CHAR_TYPE))

#ifdef __cplusplus
}
#endif

#endif  // _TSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\winnt32p.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    winnt32p.h

Abstract:

    Header file for winnt32 plug-in down-level-side DLLs.

Author:

    Ted Miller (tedm) 6 December 1996

Revision History:

--*/
#ifndef WINNT32P_H
#define WINNT32P_H

//
// WMX_ACTIVATEPAGE is sent when a page is being activated or deactivated.
//
// (The plug-in's pages do not receive WM_NOTIFY with PSN_SETACTIVE and
// PSN_KILLACTIVE -- they get a WMX_ACTIVATEPAGE instead.)
//
// wParam non-0: activating
// wParam 0    : deactivating
// lParam      : unused.
//
// Return non-0 to accept (de)activation, 0 to not accept it. The semantics
// of not accepting (de)activation are exactly the same as for the
// PSN_SETACTIVE/PSN_KILLACTIVE case.
//
#define WMX_ACTIVATEPAGE        (WM_APP+0)

//
// First custom window message a plug-in can use.
// Do NOT use any below this value.
//
#define WMX_PLUGIN_FIRST        (WM_APP+1000)

//
// IDs the plug-in must use for its title and subtitle text on each
// wizard page.
//
#define ID_TITLE_TEXT           1000
#define ID_SUBTITLE_TEXT        1029

//
// Define types for routines that the plug-in DLL must export.
//



//
// Maximum source count..
//
#define MAX_SOURCE_COUNT 8


/*
    This structure contains the information that is passed to a Winnt32 plug-in in
    its Init function.

    UnattendedFlag - Supplies the address of the global attended flag within
        winnt32 itself. A plugin should react accordingly to setup being in
        unattended mode.

    CancelledFlag - supplies the address of a global variable within
        winnt32 itself. If the plug-in encounters a fatal error while
        processing later it should inform the user, set the BOOL to which
        this parameter points to TRUE, and do the following:

        PropSheet_PressButton(WizardDialogBox,PSBTN_CANCEL);

        where WizardDialogBox is the window handle of the wizard dialog box
        (typically obtained via GetParent(hdlg) where hdlg is the
        window handle of a page in the wizard).

    AbortedFlag - supplies the address of a global variable within winnt32 itself.
        If the plugin would like to exit setup, but not show the unsuccessfull
        completion page, it should set both CancelledFlag and AbortedFlag to TRUE.

    UpgradeFlag - supplies the address of a global variable that will
        indicate whether the user is upgrading or installing a new fresh
        copy of NT. The plug-in must sample this value when it is asked to
        activate its pages and take appropriate action (ie, not activating
        if the user is not upgrading). The value this pointer points to
        is NOT valid until after the plug-in's pages are first
        activated.

    LocalSourceModeFlag - supplies the address of a global variable that will
        indicate whether the user is installing via local source mode or not.
        This parameter is not valid until after the plug-in's pages are first
        activated.

    CdRomInstallFlag - supplies the address of a global variable that will
        indicate whetherthe user is installing via CdRom or not. This
        parameter is not valid until after the plug-in's pages are first
        activated.

    NotEnoughSpaceBlockFlag - supplies the address of a global variable that will
        indicate wether setup should halt setup and exit if it detects that
        there is not enough space to complete setup (not enough space for the ~ls dir.)

    LocalSourceDrive - supplies the address of a global variable that will indicate
        the drive number of the local source directory. (2 = C, 3 = D, etc...) This is
        not valid until after winnt32 builds the copy list. 0 indicates an invalid drive.

    LocalSourceSpaceRequired - supplies the address of a global variable that indicates the amount
        of space on the LocalSourceDrive required by winnt32. This is not valid until after
        winnt32 builds the copy list.

    UnattendedScriptFile - supplies the address of a global variable that will
        contain the unattend script file (such as passed in on the command line.)
        This parameter is not valid until after the plug-in's pages are first
        activated.

    SourcePath - supplies an array of SourcePaths that indicate where the
        NT source files exist. This parameter is not valid until after the
        plug-in's pages are first activated.

    SourceCount - supplies the count of SourcePaths in the above array.
        This parameter is not valid until after the plug-in's pages are first
        activated.

    UpgradeOptions - supplies a multistring of special Upgrade commandline options
        to the dll. These options are of the form /#U:[Option] so, for example,
        if someone started winnt32 with the commandline winnt32 /#U:FOO /#U:BAR,
        this string would eventually contain "FOO\0BAR\0\0" This parameter is not
        valid untila after the upgrade plug-in's pages are first activated.

    ProductType - Specifies the type of product being installed.  The value this pointer
        points to is NOT valid until after the plug-in's pages are first activated.

    BuildNumber - Specifies the build of NT being installed.

    ProductVersion - Specifies the version of NT being installed.  The major version is
        in the high byte, and the minor version is in the low byte.

    Debug - Specifies if WINNT32 is the checked build (TRUE) or the free build (FALSE).

    PreRelease - Specifies if the current build is a pre-release (TRUE) or final release (FALSE).

*/

typedef enum {
    UNKNOWN,
    NT_WORKSTATION,
    NT_SERVER
} PRODUCTTYPE;


typedef struct tagWINNT32_PLUGIN_INIT_INFORMATION_BLOCK {
    UINT            Size;
    BOOL     *      UnattendedFlag;
    BOOL     *      CancelledFlag;
    BOOL     *      AbortedFlag;
    BOOL     *      UpgradeFlag;
    BOOL     *      LocalSourceModeFlag;
    BOOL     *      CdRomInstallFlag;
    BOOL     *      NotEnoughSpaceBlockFlag;
    DWORD    *      LocalSourceDrive;
    LONGLONG *      LocalSourceSpaceRequired;
    LPCTSTR  *      UnattendedScriptFile;
    LPCTSTR  *      SourceDirectories;
    DWORD    *      SourceDirectoryCount;
    LPCTSTR  *      UpgradeOptions;
    PRODUCTTYPE *   ProductType;
    DWORD           BuildNumber;
    WORD            ProductVersion;         // i.e., MAKEWORD(5,0)
    BOOL            Debug;
    BOOL            PreRelease;
    BOOL     *      ForceNTFSConversion;
    UINT     *      Boot16;                 // Win9x upgrade only
} WINNT32_PLUGIN_INIT_INFORMATION_BLOCK,*PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK;


typedef BOOL (*READ_DISK_SECTORS_PROC) (TCHAR,UINT,UINT,UINT,PBYTE);

typedef struct tagWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK {



    UINT      Size;
    PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK BaseInfo;
    LPCTSTR   UpgradeSourcePath;
    PLONGLONG WinDirSpace;
    PUINT     RequiredMb;
    PUINT     AvailableMb;
    LPCTSTR * OptionalDirectories;
    DWORD   * OptionalDirectoryCount;
    UINT    * UpgradeFailureReason;
    READ_DISK_SECTORS_PROC ReadDiskSectors;

} WINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK, *PWINNT32_WIN9XUPG_INIT_INFORMATION_BLOCK;


/*++

UPGRADEFAILURES is a list of reasons that an upgrade cannot be performed. This list allows winnt32 to own certain messages
for failures, but for the upgrade dll to do the actual checking for those failures.

If you define a FAILREASON(<x>) you need to add a MSG_<x> to the winnt32 dll message.mc file.

This macro expansion list will create an enumerated type FAILREASON_<x> as well as populate an array of potential
failure messages.


++*/
#define UPGRADEFAILURES                         \
    FAILREASON(UPGRADE_OK)                      \
    FAILREASON(UPGRADE_OTHER_OS_FOUND)          \

#define FAILREASON(x) REASON_##x,

enum {UPGRADEFAILURES /*,*/ REASON_LAST_REASON};

#undef FAILREASON

typedef
DWORD
(CALLBACK WINNT32_PLUGIN_INIT_ROUTINE_PROTOTYPE)(
    PWINNT32_PLUGIN_INIT_INFORMATION_BLOCK Info
    );

typedef WINNT32_PLUGIN_INIT_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_INIT_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 to initialize the plug-in dll.

Arguments:

    Info - A WINNT32_PLUGIN_INIT_INFORMATION_BLOCK. See above for details.

Return Value:

    Win32 error code indicating outcome. If not NO_ERROR then winnt32 will
    put up UI telling the user of the failure.

--*/


typedef
DWORD
(CALLBACK WINNT32_PLUGIN_GETPAGES_ROUTINE_PROTOTYPE)(
    PUINT            PageCount1,
    LPPROPSHEETPAGE *Pages1,
    PUINT            PageCount2,
    LPPROPSHEETPAGE *Pages2,
    PUINT            PageCount3,
    LPPROPSHEETPAGE *Pages3
    );

typedef WINNT32_PLUGIN_GETPAGES_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_GETPAGES_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 to retrieve wizard pages from the
    plug-in dll.

    Note that the plug-in does NOT need to worry about drawing watermarks
    or background bitmaps, or the separator between a header-area watermark
    and the body of its pages. Winnt32 does all this automatically.

    The plugin should, however, have regular static text controls in the
    header area. Static text controls in that area should use the reserved
    IDs (see above) for the title and subtitle, since winnt32 will automatically
    change the font and size of that text when the page is displayed.

Arguments:

    PageCount1 - receives the number of pages in the first set of contiguous
        pages.

    Pages1 - receives a pointer to an array of property sheet page structures.
        The plug-in is responsible for managing this array but must not free
        it at any time since winnt32 may refer to it at any point.

    PageCount2 - receives the number of pages in the second set of contiguous
        pages.

    Pages2 - receives a pointer to an array of property sheet page structures.
        The plug-in is responsible for managing this array but must not free
        it at any time since winnt32 may refer to it at any point.

    PageCount3 - receives the number of pages in the third set of contiguous
        pages.

    Pages3 - receives a pointer to an array of property sheet page structures.
        The plug-in is responsible for managing this array but must not free
        it at any time since winnt32 may refer to it at any point.

Return Value:

    Win32 error code indicating outcome. If not NO_ERROR then winnt32 will
    put up UI telling the user of the failure.

--*/


typedef
DWORD
(CALLBACK WINNT32_PLUGIN_WRITEPARAMS_ROUTINE_PROTOTYPE)(
    LPCTSTR FileName
    );

typedef WINNT32_PLUGIN_WRITEPARAMS_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_WRITEPARAMS_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 to request the plug-in write to the
    parameters file that will be passed to text mode setup (ie, winnt.sif).

Arguments:

    FileName - supplies the filename of the .ini-style file to be written to.
        This file is the parameters file plus any user-specified unattend file.
        The plug-in should make whatever modifications are meaningful to it.

Return Value:

    Win32 error code indicating outcome. If not NO_ERROR then winnt32 will
    put up UI telling the user of the failure.

--*/


typedef
VOID
(CALLBACK WINNT32_PLUGIN_CLEANUP_ROUTINE_PROTOTYPE)(
    VOID
    );

typedef WINNT32_PLUGIN_CLEANUP_ROUTINE_PROTOTYPE * PWINNT32_PLUGIN_CLEANUP_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 in the case where installation is
    aborted after the wizard has been started.

    The plug-in should silently perform whatever cleanup is needs to
    to undo any changes it made to the user's system.

Arguments:

    None.

Return Value:

    None.

--*/

typedef
BOOL
(CALLBACK WINNT32_PLUGIN_VIRUSSCANNER_CHECK_PROTOTYPE)(
    VOID
    );

typedef WINNT32_PLUGIN_VIRUSSCANNER_CHECK_PROTOTYPE * PWINNT32_PLUGIN_VIRUSSCANNER_CHECK_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 when running on win9x machines.

    The plugin should do a check for any virus scanners on the machine that could cause setup
    to be unable to complete installation (locking the MBR, for instance.) The plugin is also
    responsible for communicating any problems to the user.

Arguments:

    None.

Return Value:

    TRUE if there are no virus scanners to worry about, FALSE otherwise.

--*/



typedef
PTSTR
(CALLBACK WINNT32_PLUGIN_OPTIONAL_DIRS_PROTOTYPE)(
    VOID
    );

typedef WINNT32_PLUGIN_OPTIONAL_DIRS_PROTOTYPE * PWINNT32_PLUGIN_OPTIONAL_DIRS_ROUTINE;

/*++

Routine Description:

    This routine is called by winnt32 when running on win9x machines.

    The plugin should do a check for any virus scanners on the machine that could cause setup
    to be unable to complete installation (locking the MBR, for instance.) The plugin is also
    responsible for communicating any problems to the user.

Arguments:

    None.

Return Value:

    TRUE if there are no virus scanners to worry about, FALSE otherwise.

--*/



//
// Names of routines that must be exported by the plug-in dll.
//
#define WINNT32_PLUGIN_INIT_NAME        "Winnt32PluginInit"
#define WINNT32_PLUGIN_GETPAGES_NAME    "Winnt32PluginGetPages"
#define WINNT32_PLUGIN_WRITEPARAMS_NAME "Winnt32WriteParams"
#define WINNT32_PLUGIN_CLEANUP_NAME     "Winnt32Cleanup"
#define WINNT32_PLUGIN_VIRUSSCANCHECK_NAME "Winnt32VirusScannerCheck"
#define WINNT32_PLUGIN_GETOPTIONALDIRS_NAME "Winnt32GetOptionalDirectories"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\wingdip.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:

    wingdi.h

Abstract:

    Procedure declarations, constant definitions and macros for the GDI
    component.

--*/
#ifndef _WINGDIP_
#define _WINGDIP_
#ifdef __cplusplus
extern "C" {
#endif
// BitBlt RTL mirroring rop (RTL_MIRRORING)
// RTL Layout Constants (RTL_MIRRORING)
// SetLayout Metafile call (RTL_MIRRORING)
#define LCS_DEVICE_RGB                  0x00000001L
#define LCS_DEVICE_CMYK                 0x00000002L
#define BI_CMYK      10L
#define BI_CMYKRLE8  11L
#define BI_CMYKRLE4  12L
#define CAPS1         94    /* Extra Caps */

/* CAPS1 (Win 9x internal) */
#define C1_TRANSPARENT      0x0001
#define TC_TT_ABLE          0x0002
#define C1_TT_CR_ANY        0x0004
#define C1_EMF_COMPLIANT    0x0008
#define C1_DIBENGINE        0x0010
#define C1_GAMMA_RAMP       0x0020 /* CM_GAMMA_RAMP for NT */
#define C1_DIC              0x0040 /* CM_DEVICE_ICM for NT */
#define C1_REINIT_ABLE      0x0080
#define C1_GLYPH_INDEX      0x0100
#define C1_BIT_PACKED       0x0200
#define C1_BYTE_PACKED      0x0400
#define C1_COLORCURSOR      0x0800
#define C1_CMYK_ABLE        0x1000 /* CM_CMYK_COLOR for NT */
#define C1_SLOW_CARD        0x2000

/* CAPS1 (NT 5 internal) */
#define C1_MIRROR_DEVICE    0x4000

#define CBM_CREATEDIB   0x02L   /* create DIB bitmap */
#define DMDUP_LAST      DMDUP_HORIZONTAL
#define DMTT_LAST             DMTT_DOWNLOAD_OUTLINE
#define DMDISPLAYFLAGS_VALID    0x00000004
#define DMICMMETHOD_LAST    DMICMMETHOD_DEVICE
#define DMICM_LAST          DMICM_ABS_COLORIMETRIC
#define DMMEDIA_LAST          DMMEDIA_GLOSSY
#define DMDITHER_LAST       DMDITHER_GRAYSCALE
#define DISPLAY_DEVICE_POWERED_OFF         0x80000000
#define DISPLAY_DEVICE_ACPI                0x40000000

WINGDIAPI int  WINAPI GetTextFaceAliasW(HDC hdc,int c,LPWSTR pwsz);

/* DC_MANUFACTURER is DC_ICC_MANUFACTURER in 16 bit PRINT.H */
/* DC_MODEL is DC_ICC_MODEL in 16 bit PRINT.H               */
HANDLE WINAPI SetObjectOwner( IN HGDIOBJ, IN HANDLE);
// Mirroring APIs (RTL_MIRRORING)
#if(WINVER >= 0x0500)
WINGDIAPI BOOL  WINAPI MirrorRgn(IN HWND, IN HRGN);
WINGDIAPI DWORD WINAPI SetLayoutWidth(IN HDC, IN LONG, IN DWORD);
#endif /* WINVER >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

WINGDIAPI BOOL  WINAPI GdiAlphaBlend( IN HDC, IN int, IN int, IN int, IN int, IN HDC, IN int, IN int, IN int, IN int, IN BLENDFUNCTION);

WINGDIAPI BOOL  WINAPI GdiTransparentBlt(IN HDC,IN int,IN int,IN int,IN int,IN HDC,IN int,IN int,IN int,IN int,IN UINT);

WINGDIAPI BOOL  WINAPI GdiGradientFill( IN HDC, IN PTRIVERTEX, IN ULONG, IN PVOID, IN ULONG, IN ULONG);

#endif

// Ansi version of CreateColorSpace
// (Windows 98 comaptible record)
// Unicode version of StartDoc record
// SetLayout Metafile Record (RTL_MIRRORING)
// 117 not used
#ifdef __cplusplus
}
#endif

#define CCB_NOVIDEOMEMORY       0x01000000

// Old fields that Chicago won't support that we can't publically
// support anymore

#define HS_SOLIDCLR         6
#define HS_DITHEREDCLR      7
#define HS_SOLIDTEXTCLR     8
#define HS_DITHEREDTEXTCLR  9
#define HS_SOLIDBKCLR       10
#define HS_DITHEREDBKCLR    11
#define HS_API_MAX          12

#define DIB_PAL_INDICES     2 /* No color table indices into surf palette */

// Private indicies for GetStockObject over the CS interface.

#define PRIV_STOCK_COLORSPACE   (STOCK_LAST + 1)
#define PRIV_STOCK_BITMAP       (STOCK_LAST + 2)
#define PRIV_STOCK_LAST         PRIV_STOCK_BITMAP

#define DCB_WINDOWMGR   0x00008000L

// GetTransform flags.

#define XFORM_WORLD_TO_PAGE       0x0203
#define XFORM_WORLD_TO_DEVICE     0x0204
#define XFORM_PAGE_TO_DEVICE      0x0304
#define XFORM_PAGE_TO_WORLD       0x0302
#define XFORM_DEVICE_TO_WORLD     0x0402
#define XFORM_DEVICE_TO_PAGE      0x0403


#if(WINVER >= 0x0500)
#define EMR_DRAWESCAPE                 105
#define EMR_EXTESCAPE                  106
// Unicode version of StartDoc record
#define EMR_STARTDOC                   107
#define EMR_SMALLTEXTOUT               108
#define EMR_FORCEUFIMAPPING            109
#define EMR_NAMEDESCAPE                110
#define EMR_SETLINKEDUFIS              119
#define EMR_SETTEXTJUSTIFICATION       120
#endif /* WINVER >= 0x0500 */

enum DCTYPE {
    DCTYPE_DIRECT,
    DCTYPE_MEMORY,
    DCTYPE_INFO};

// the following structure is only used for GetETM postscript escape

typedef struct _EXTTEXTMETRIC {
    SHORT  etmSize;
    SHORT  etmPointSize;
    SHORT  etmOrientation;
    SHORT  etmMasterHeight;
    SHORT  etmMinScale;
    SHORT  etmMaxScale;
    SHORT  etmMasterUnits;
    SHORT  etmCapHeight;
    SHORT  etmXHeight;
    SHORT  etmLowerCaseAscent;
    SHORT  etmLowerCaseDescent;
    SHORT  etmSlant;
    SHORT  etmSuperScript;
    SHORT  etmSubScript;
    SHORT  etmSuperScriptSize;
    SHORT  etmSubScriptSize;
    SHORT  etmUnderlineOffset;
    SHORT  etmUnderlineWidth;
    SHORT  etmDoubleUpperUnderlineOffset;
    SHORT  etmDoubleLowerUnderlineOffset;
    SHORT  etmDoubleUpperUnderlineWidth;
    SHORT  etmDoubleLowerUnderlineWidth;
    SHORT  etmStrikeOutOffset;
    SHORT  etmStrikeOutWidth;
    WORD   etmNKernPairs;
    WORD   etmNKernTracks;
} EXTTEXTMETRIC;

// the following structure is only used for GETPAIRKERNTABLE escape

#pragma pack(1)
typedef struct _KERNPAIR
{
    WORD  wBoth;
    SHORT sAmount;
} KERNPAIR, *LPKERNPAIR;
#pragma pack()

BOOL
GetETM(
    HDC hdc,
    EXTTEXTMETRIC *petm);


HFONT
APIENTRY
GetHFONT(
    HDC);


HANDLE         GdiCreateLocalMetaFilePict(HANDLE hRemote);
HENHMETAFILE   GdiCreateLocalEnhMetaFile(HANDLE hRemote);
HANDLE         GdiConvertBitmapV5(LPBYTE,int,HPALETTE,UINT);
HANDLE         GdiConvertMetaFilePict(HANDLE hmfp);
HANDLE         GdiConvertEnhMetaFile(HENHMETAFILE hmf);
HDC            GdiConvertAndCheckDC(HDC hdc);
HBRUSH         GdiConvertBrush(HBRUSH hbrush);
HDC            GdiConvertDC(HDC hdc);
HRGN           GdiConvertRegion(HRGN hrgn);
BOOL           GdiValidateHandle(HANDLE hObj);
BOOL           GdiReleaseDC(HDC hdc);
HANDLE         GdiFixUpHandle(HANDLE h);
int            GdiGetCharDimensions(HDC hdc,TEXTMETRICW *lptm,LPINT lpcy);
DWORD          GdiGetCodePage(HDC hdc);

// Driver-specific pixel format support in GDI
int  APIENTRY GdiDescribePixelFormat(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);
BOOL APIENTRY GdiSetPixelFormat(HDC, int);
BOOL APIENTRY GdiSwapBuffers(HDC);

// OpenGL metafile support in GDI
BOOL APIENTRY GdiAddGlsRecord(HDC hdc, DWORD cb, BYTE *pb, LPRECTL prclBounds);
BOOL APIENTRY GdiAddGlsBounds(HDC hdc, LPRECTL prclBounds);
BOOL APIENTRY GdiIsMetaPrintDC(HDC hdc);

// OpenGL metafile support in OpenGL
BOOL APIENTRY GlmfInitPlayback(HDC hdc, ENHMETAHEADER *pemh,
                               LPRECTL prclDest);
BOOL APIENTRY GlmfBeginGlsBlock(HDC hdc);
BOOL APIENTRY GlmfPlayGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds);
BOOL APIENTRY GlmfEndGlsBlock(HDC hdc);
BOOL APIENTRY GlmfEndPlayback(HDC hdc);
BOOL APIENTRY GlmfCloseMetaFile(HDC hdc);

BOOL  APIENTRY GdiPlayJournal(HDC,LPWSTR,DWORD,DWORD,int);

typedef int (CALLBACK* EMFPLAYPROC)( HDC, INT, HANDLE );

// User Mode Driver Unload

BOOL WINAPI GdiArtificialDecrementDriver(
    LPWSTR       pDriverDllName,
    DWORD        dwDriverAttributes
);

// Print processor interfaces and definitions

#define  EMF_PP_NORMAL      0x01
#define  EMF_PP_FORM        0x02

#define  EMF_PP_COLOR_OPTIMIZATION  0x01

BOOL WINAPI GdiPlayEMF(
    LPWSTR      pwszPrinterName,
    LPDEVMODEW  pDevmode,
    LPWSTR      pwszDocName,
    EMFPLAYPROC pfnPageQueryFn,
    HANDLE      hPageQuery
);

HANDLE WINAPI GdiGetSpoolFileHandle(
    LPWSTR     pwszPrinterName,
    LPDEVMODEW pDevmode,
    LPWSTR     pwszDocName);

BOOL WINAPI GdiDeleteSpoolFileHandle(
    HANDLE     SpoolFileHandle);

DWORD WINAPI GdiGetPageCount(
    HANDLE     SpoolFileHandle);

HDC WINAPI GdiGetDC(
    HANDLE     SpoolFileHandle);

HANDLE WINAPI GdiGetPageHandle(
    HANDLE     SpoolFileHandle,
    DWORD      Page,
    LPDWORD    pdwPageType);

BOOL WINAPI GdiStartDocEMF(
    HANDLE     SpoolFileHandle,
    DOCINFOW   *pDocInfo);

BOOL WINAPI GdiStartPageEMF(
    HANDLE     SpoolFileHandle);

BOOL WINAPI GdiPlayPageEMF(
    HANDLE     SpoolFileHandle,
    HANDLE     hemf,
    RECT       *prectDocument,
    RECT       *prectBorder,
    RECT       *prectClip);

BOOL WINAPI GdiPlayPrivatePageEMF(
    HANDLE       SpoolFileHandle,
    HENHMETAFILE hEnhMetaFile,
    RECT         *prectDocument);

BOOL WINAPI GdiEndPageEMF(
    HANDLE     SpoolFileHandle,
    DWORD      dwOptimization);

BOOL WINAPI GdiEndDocEMF(
    HANDLE     SpoolFileHandle);

BOOL WINAPI GdiGetDevmodeForPage(
    HANDLE     SpoolFileHandle,
    DWORD      dwPageNumber,
    PDEVMODEW  *pCurrDM,
    PDEVMODEW  *pLastDM);

BOOL WINAPI GdiResetDCEMF(
    HANDLE     SpoolFileHandle,
    PDEVMODEW  pCurrDM);


ULONG cGetTTFFromFOT(WCHAR *,ULONG,WCHAR *,FLONG *,FLONG *, DWORD *, BOOL);
BOOL bMakePathNameW (WCHAR *, WCHAR *, WCHAR **, FLONG *);
BOOL bInitSystemAndFontsDirectoriesW(WCHAR **, WCHAR **);
#define FONT_IN_FONTS_DIR     1
#define FONT_IN_SYSTEM_DIR    2
#define FONT_RELATIVE_PATH    4
#define FONT_ISNOT_FOT        8

#ifdef LANGPACK
BOOL LpkInitialize();
VOID APIENTRY GdiSetLastError(ULONG iError);

#define FRINFO_BITMAP   1
#define FRINFO_VECTOR   2
#define FRINFO_OTHER    3

typedef struct tagREALIZATION_INFO {
    UINT uFontTechnology;
    UINT uRealizationID;
    UINT uFontFileID;
} REALIZATION_INFO, *PREALIZATION_INFO;

BOOL APIENTRY GdiRealizationInfo(HDC, PREALIZATION_INFO);
WINGDIAPI BOOL  WINAPI GetTextExtentExPointWPri(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE);
BOOL APIENTRY GdiIsPlayMetafileDC(HDC hdc);
#endif

//
// Font Enumeration defines
//

#define FE_FILTER_NONE      0L
#define FE_FILTER_TRUETYPE  1L
#define FE_AA_ON            2L      // force antialiased text
#define FE_SET_AA           4L

ULONG
WINAPI SetFontEnumeration (
    ULONG   ulType);


//
// Private Control Panel entry point to enumerate fonts by file.
//

#define GFRI_NUMFONTS       0L
#define GFRI_DESCRIPTION    1L
#define GFRI_LOGFONTS       2L
#define GFRI_ISTRUETYPE     3L
#define GFRI_TTFILENAME     4L
#define GFRI_ISREMOVED      5L
#if defined(FE_SB) // for GetFontResourceInfo()
#define GFRI_FONTMETRICS    6L
#endif // FE_SB

// file path separator for Add/RemoveFontResourceA/W

#define PATH_SEPARATOR L'|'


WINGDIAPI BOOL
WINAPI
GetFontResourceInfoW(
    LPWSTR  lpPathname,
    LPDWORD lpBytes,
    LPVOID  lpBuffer,
    DWORD   iType);

BOOL WINAPI GdiGetMessage(VOID *pv);


typedef enum _GdiCallId {
    MapFontFile_        = 1
  , UnmapFontFile_      = 2
  , GetFilePath_        = 3
  , LpkInstalled_       = 4
  , ComputeGlyphSet_    = 5
  , LoadModuleForWrite_ = 6
  , FreeModule_         = 7
  , GetFileChangeTime_  = 8
  , GetCurrentCodePage_ = 9
} GdiCallId;

typedef struct _GDICALL {
    GdiCallId Id;
    union {
        struct {
            ULONG iFile;
            PVOID pvUser;
            ULONG ByteCount;
        } MapFontFileArgs;
        struct {
            ULONG iFile;
        } UnmapFontFileArgs;
        struct {
            BOOL ReturnValue;
            HANDLE h;
            WCHAR (*pDest)[MAX_PATH+1];
        } GetFilePathArgs;
        struct {
            BOOL ReturnValue;
        } LpkInstalledArgs;
        struct {
                           BOOL   ReturnValue;
            struct _FD_GLYPHSET **ppGlyphSet;
            union {
                          ULONG   ByteCount;
            struct _FD_GLYPHSET  *pGlyphSet;
                                           };
                            INT   nCodePage;
                            INT   nFirstChar;
                            INT   cChars;
        } ComputeGlyphSetArgs;
        struct {
                    HANDLE ReturnValue;
                     WCHAR *pwsz;       // pointer to string
                     ULONG cj;
        } LoadModuleForWriteArgs;
        struct {
            HANDLE h;
        } FreeModuleArgs;
        struct {
            BOOL ReturnValue;
            HANDLE h;
            LARGE_INTEGER Time;
        } GetFileChangeTimeArgs;
        struct {
            USHORT OemCodePage;
            USHORT AnsiCodePage;
        } GetCurrentCodePageArgs;
    };
} GDICALL;

BOOL WINAPI GdiCall(GDICALL *pCall);

typedef struct  _CHWIDTHINFO
{
    LONG    lMaxNegA;
    LONG    lMaxNegC;
    LONG    lMinWidthD;
} CHWIDTHINFO,  *PCHWIDTHI